/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_toruslabs_solana-embed_dist_solanaEmbed_esm_js"],{

/***/ "./node_modules/@toruslabs/base-controllers/dist/baseControllers.esm.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@toruslabs/base-controllers/dist/baseControllers.esm.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ACCOUNT_CATEGORY\": function() { return /* binding */ ACCOUNT_CATEGORY; },\n/* harmony export */   \"ACTIVITY_ACTION\": function() { return /* binding */ ACTIVITY_ACTION; },\n/* harmony export */   \"ACTIVITY_ACTION_ALL\": function() { return /* binding */ ACTIVITY_ACTION_ALL; },\n/* harmony export */   \"ACTIVITY_ACTION_RECEIVE\": function() { return /* binding */ ACTIVITY_ACTION_RECEIVE; },\n/* harmony export */   \"ACTIVITY_ACTION_SEND\": function() { return /* binding */ ACTIVITY_ACTION_SEND; },\n/* harmony export */   \"ACTIVITY_ACTION_TOPUP\": function() { return /* binding */ ACTIVITY_ACTION_TOPUP; },\n/* harmony export */   \"ACTIVITY_PERIOD_ALL\": function() { return /* binding */ ACTIVITY_PERIOD_ALL; },\n/* harmony export */   \"ACTIVITY_PERIOD_MONTH_ONE\": function() { return /* binding */ ACTIVITY_PERIOD_MONTH_ONE; },\n/* harmony export */   \"ACTIVITY_PERIOD_MONTH_SIX\": function() { return /* binding */ ACTIVITY_PERIOD_MONTH_SIX; },\n/* harmony export */   \"ACTIVITY_PERIOD_WEEK_ONE\": function() { return /* binding */ ACTIVITY_PERIOD_WEEK_ONE; },\n/* harmony export */   \"ACTIVITY_STATUS_CANCELLED\": function() { return /* binding */ ACTIVITY_STATUS_CANCELLED; },\n/* harmony export */   \"ACTIVITY_STATUS_CANCELLING\": function() { return /* binding */ ACTIVITY_STATUS_CANCELLING; },\n/* harmony export */   \"ACTIVITY_STATUS_PENDING\": function() { return /* binding */ ACTIVITY_STATUS_PENDING; },\n/* harmony export */   \"ACTIVITY_STATUS_SUCCESSFUL\": function() { return /* binding */ ACTIVITY_STATUS_SUCCESSFUL; },\n/* harmony export */   \"ACTIVITY_STATUS_UNSUCCESSFUL\": function() { return /* binding */ ACTIVITY_STATUS_UNSUCCESSFUL; },\n/* harmony export */   \"BROADCAST_CHANNELS\": function() { return /* binding */ BROADCAST_CHANNELS; },\n/* harmony export */   \"BROADCAST_CHANNELS_MSGS\": function() { return /* binding */ BROADCAST_CHANNELS_MSGS; },\n/* harmony export */   \"BaseBlockTracker\": function() { return /* binding */ BaseBlockTracker; },\n/* harmony export */   \"BaseController\": function() { return /* binding */ BaseController; },\n/* harmony export */   \"BaseCurrencyController\": function() { return /* binding */ BaseCurrencyController; },\n/* harmony export */   \"BaseEmbedController\": function() { return /* binding */ BaseEmbedController; },\n/* harmony export */   \"BaseKeyringController\": function() { return /* binding */ BaseKeyringController; },\n/* harmony export */   \"BasePreferencesController\": function() { return /* binding */ BasePreferencesController; },\n/* harmony export */   \"BaseTransactionStateManager\": function() { return /* binding */ BaseTransactionStateManager; },\n/* harmony export */   \"BroadcastChannelHandler\": function() { return /* binding */ BroadcastChannelHandler; },\n/* harmony export */   \"COMMUNICATION_JRPC_METHODS\": function() { return /* binding */ COMMUNICATION_JRPC_METHODS; },\n/* harmony export */   \"COMMUNICATION_NOTIFICATIONS\": function() { return /* binding */ COMMUNICATION_NOTIFICATIONS; },\n/* harmony export */   \"CommunicationWindowManager\": function() { return /* binding */ CommunicationWindowManager; },\n/* harmony export */   \"DEFAULT_PREFERENCES\": function() { return /* binding */ DEFAULT_PREFERENCES; },\n/* harmony export */   \"FEATURES_CONFIRM_WINDOW\": function() { return /* binding */ FEATURES_CONFIRM_WINDOW; },\n/* harmony export */   \"FEATURES_DEFAULT_POPUP_WINDOW\": function() { return /* binding */ FEATURES_DEFAULT_POPUP_WINDOW; },\n/* harmony export */   \"FEATURES_DEFAULT_WALLET_WINDOW\": function() { return /* binding */ FEATURES_DEFAULT_WALLET_WINDOW; },\n/* harmony export */   \"FEATURES_PROVIDER_CHANGE_WINDOW\": function() { return /* binding */ FEATURES_PROVIDER_CHANGE_WINDOW; },\n/* harmony export */   \"LOGIN_PROVIDER\": function() { return /* binding */ LOGIN_PROVIDER; },\n/* harmony export */   \"PAYMENT_PROVIDER\": function() { return /* binding */ PAYMENT_PROVIDER; },\n/* harmony export */   \"POPUP_LOADED\": function() { return /* binding */ POPUP_LOADED; },\n/* harmony export */   \"POPUP_RESULT\": function() { return /* binding */ POPUP_RESULT; },\n/* harmony export */   \"PROVIDER_JRPC_METHODS\": function() { return /* binding */ PROVIDER_JRPC_METHODS; },\n/* harmony export */   \"PROVIDER_NOTIFICATIONS\": function() { return /* binding */ PROVIDER_NOTIFICATIONS; },\n/* harmony export */   \"PopupHandler\": function() { return /* binding */ PopupHandler; },\n/* harmony export */   \"PopupStoreChannel\": function() { return /* binding */ PopupStoreChannel; },\n/* harmony export */   \"PopupWithBcHandler\": function() { return /* binding */ PopupWithBcHandler; },\n/* harmony export */   \"RedirectHandler\": function() { return /* binding */ RedirectHandler; },\n/* harmony export */   \"SETUP_COMPLETE\": function() { return /* binding */ SETUP_COMPLETE; },\n/* harmony export */   \"StreamWindow\": function() { return /* binding */ StreamWindow; },\n/* harmony export */   \"TRANSACTION_TYPES\": function() { return /* binding */ TRANSACTION_TYPES; },\n/* harmony export */   \"TX_EVENTS\": function() { return /* binding */ TX_EVENTS; },\n/* harmony export */   \"TransactionStatus\": function() { return /* binding */ TransactionStatus; },\n/* harmony export */   \"UserError\": function() { return /* binding */ UserError; },\n/* harmony export */   \"addressSlicer\": function() { return /* binding */ addressSlicer; },\n/* harmony export */   \"broadcastChannelOptions\": function() { return /* binding */ broadcastChannelOptions; },\n/* harmony export */   \"concatSig\": function() { return /* binding */ concatSig; },\n/* harmony export */   \"createChangeProviderMiddlewareMiddleware\": function() { return /* binding */ createChangeProviderMiddlewareMiddleware; },\n/* harmony export */   \"createCommunicationMiddleware\": function() { return /* binding */ createCommunicationMiddleware; },\n/* harmony export */   \"createEventEmitterProxy\": function() { return /* binding */ createEventEmitterProxy; },\n/* harmony export */   \"createFetchConfigFromReq\": function() { return /* binding */ createFetchConfigFromReq; },\n/* harmony export */   \"createFetchMiddleware\": function() { return /* binding */ createFetchMiddleware; },\n/* harmony export */   \"createGenericJRPCMiddleware\": function() { return /* binding */ createGenericJRPCMiddleware; },\n/* harmony export */   \"createLoggerMiddleware\": function() { return /* binding */ createLoggerMiddleware; },\n/* harmony export */   \"createOriginMiddleware\": function() { return /* binding */ createOriginMiddleware; },\n/* harmony export */   \"createRandomId\": function() { return /* binding */ createRandomId; },\n/* harmony export */   \"createSwappableProxy\": function() { return /* binding */ createSwappableProxy; },\n/* harmony export */   \"createTopupMiddleware\": function() { return /* binding */ createTopupMiddleware; },\n/* harmony export */   \"formatDate\": function() { return /* binding */ formatDate; },\n/* harmony export */   \"formatSmallNumbers\": function() { return /* binding */ formatSmallNumbers; },\n/* harmony export */   \"formatTime\": function() { return /* binding */ formatTime; },\n/* harmony export */   \"getCustomDeviceInfo\": function() { return /* binding */ getCustomDeviceInfo; },\n/* harmony export */   \"getPopupFeatures\": function() { return /* binding */ getPopupFeatures; },\n/* harmony export */   \"getTxStatusText\": function() { return /* binding */ getTxStatusText; },\n/* harmony export */   \"handleRedirectParameters\": function() { return /* binding */ handleRedirectParameters; },\n/* harmony export */   \"hashMessage\": function() { return /* binding */ hashMessage; },\n/* harmony export */   \"intToHex\": function() { return /* binding */ intToHex; },\n/* harmony export */   \"padWithZeroes\": function() { return /* binding */ padWithZeroes; },\n/* harmony export */   \"providerAsMiddleware\": function() { return /* binding */ providerAsMiddleware; },\n/* harmony export */   \"providerFromEngine\": function() { return /* binding */ providerFromEngine; },\n/* harmony export */   \"providerFromMiddleware\": function() { return /* binding */ providerFromMiddleware; },\n/* harmony export */   \"randomId\": function() { return /* binding */ randomId; },\n/* harmony export */   \"signMessage\": function() { return /* binding */ signMessage; },\n/* harmony export */   \"significantDigits\": function() { return /* binding */ significantDigits; },\n/* harmony export */   \"timeout\": function() { return /* binding */ timeout$1; },\n/* harmony export */   \"transactionMatchesNetwork\": function() { return /* binding */ transactionMatchesNetwork; }\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/esm/defineProperty.js\");\n/* harmony import */ var _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @toruslabs/openlogin-jrpc */ \"./node_modules/@toruslabs/openlogin-jrpc/dist/openloginJrpc.esm.js\");\n/* harmony import */ var json_rpc_random_id__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! json-rpc-random-id */ \"./node_modules/json-rpc-random-id/index.js\");\n/* harmony import */ var json_rpc_random_id__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(json_rpc_random_id__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var bignumber_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! bignumber.js */ \"./node_modules/bignumber.js/bignumber.js\");\n/* harmony import */ var bignumber_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(bignumber_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var ethereumjs_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ethereumjs-util */ \"./node_modules/ethereumjs-util/dist.browser/index.js\");\n/* harmony import */ var ethereumjs_util__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(ethereumjs_util__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var eth_rpc_errors__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! eth-rpc-errors */ \"./node_modules/eth-rpc-errors/dist/index.js\");\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! loglevel */ \"./node_modules/loglevel/lib/loglevel.js\");\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(loglevel__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var broadcast_channel__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! broadcast-channel */ \"./node_modules/broadcast-channel/dist/esbrowser/index.js\");\n/* harmony import */ var _toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @toruslabs/http-helpers */ \"./node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js\");\n/* harmony import */ var bowser__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! bowser */ \"./node_modules/bowser/es5.js\");\n/* harmony import */ var bowser__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(bowser__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lodash */ \"./node_modules/lodash/lodash.js\");\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_9__);\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\r\n\r\nfunction _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$3(Object(source), !0).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\r\n/**\r\n * Controller class that provides configuration, state management, and subscriptions\r\n */\r\n\r\nclass BaseController extends _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_1__.SafeEventEmitter {\r\n  /**\r\n   * Default options used to configure this controller\r\n   */\r\n\r\n  /**\r\n   * Default state set on this controller\r\n   */\r\n\r\n  /**\r\n   * Determines if listeners are notified of state changes\r\n   */\r\n\r\n  /**\r\n   * Name of this controller used during composition\r\n   */\r\n\r\n  /**\r\n   * Creates a BaseController instance. Both initial state and initial\r\n   * configuration options are merged with defaults upon initialization.\r\n   *\r\n   * @param config - Initial options used to configure this controller\r\n   * @param state - Initial state to set on this controller\r\n   */\r\n  constructor(_ref) {\r\n    let {\r\n      config = {},\r\n      state = {}\r\n    } = _ref;\r\n    super(); // Use assign since generics can't be spread: https://git.io/vpRhY\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"defaultConfig\", {});\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"defaultState\", {});\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"disabled\", false);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"name\", \"BaseController\");\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"initialConfig\", void 0);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"initialState\", void 0);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"internalConfig\", this.defaultConfig);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"internalState\", this.defaultState);\r\n\r\n    this.initialState = state;\r\n    this.initialConfig = config;\r\n  }\r\n  /**\r\n   * Retrieves current controller configuration options\r\n   *\r\n   * @returns - Current configuration\r\n   */\r\n\r\n\r\n  get config() {\r\n    return this.internalConfig;\r\n  }\r\n  /**\r\n   * Retrieves current controller state\r\n   *\r\n   * @returns - Current state\r\n   */\r\n\r\n\r\n  get state() {\r\n    return this.internalState;\r\n  }\r\n  /**\r\n   * Updates controller configuration\r\n   *\r\n   * @param config - New configuration options\r\n   * @param overwrite - Overwrite config instead of merging\r\n   * @param fullUpdate - Boolean that defines if the update is partial or not\r\n   */\r\n\r\n\r\n  configure(config) {\r\n    let overwrite = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\r\n    let fullUpdate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\r\n\r\n    if (fullUpdate) {\r\n      this.internalConfig = overwrite ? config : Object.assign(this.internalConfig, config);\r\n\r\n      for (const key in this.internalConfig) {\r\n        if (typeof this.internalConfig[key] !== \"undefined\") {\r\n          this[key] = this.internalConfig[key];\r\n        }\r\n      }\r\n    } else {\r\n      for (const key in config) {\r\n        /* istanbul ignore else */\r\n        if (typeof this.internalConfig[key] !== \"undefined\") {\r\n          this.internalConfig[key] = config[key];\r\n          this[key] = config[key];\r\n        }\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * Updates controller state\r\n   *\r\n   * @param state - New state\r\n   * @param overwrite - Overwrite state instead of merging\r\n   */\r\n\r\n\r\n  update(state) {\r\n    let overwrite = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\r\n    this.internalState = overwrite ? _objectSpread$3({}, state) : _objectSpread$3(_objectSpread$3({}, this.internalState), state);\r\n    this.emit(\"store\", this.internalState);\r\n  }\r\n  /**\r\n   * Enables the controller. This sets each config option as a member\r\n   * variable on this instance and triggers any defined setters. This\r\n   * also sets initial state and triggers any listeners.\r\n   *\r\n   * @returns - This controller instance\r\n   */\r\n\r\n\r\n  initialize() {\r\n    this.internalState = this.defaultState;\r\n    this.internalConfig = this.defaultConfig;\r\n    this.configure(this.initialConfig);\r\n    this.update(this.initialState);\r\n    return this;\r\n  }\r\n\r\n}\r\n\r\nconst sec = 1000;\r\n\r\nconst calculateSum = (accumulator, currentValue) => accumulator + currentValue;\r\n\r\nconst blockTrackerEvents = [\"sync\", \"latest\"];\r\nclass BaseBlockTracker extends BaseController {\r\n  constructor(_ref) {\r\n    let {\r\n      config = {},\r\n      state = {}\r\n    } = _ref;\r\n    super({\r\n      config,\r\n      state\r\n    }); // config\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"name\", \"BaseBlockTracker\");\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"_blockResetTimeout\", void 0);\r\n\r\n    this.defaultState = {\r\n      _currentBlock: {\r\n        idempotencyKey: \"\"\r\n      },\r\n      _isRunning: false\r\n    };\r\n    this.defaultConfig = {\r\n      blockResetDuration: 20 * sec\r\n    };\r\n    this.initialize(); // bind functions for internal use\r\n\r\n    this._onNewListener = this._onNewListener.bind(this);\r\n    this._onRemoveListener = this._onRemoveListener.bind(this);\r\n    this._resetCurrentBlock = this._resetCurrentBlock.bind(this); // listen for handler changes\r\n\r\n    this._setupInternalEvents();\r\n  }\r\n\r\n  isRunning() {\r\n    return this.state._isRunning;\r\n  }\r\n\r\n  getCurrentBlock() {\r\n    return this.state._currentBlock;\r\n  }\r\n\r\n  async getLatestBlock() {\r\n    // return if available\r\n    if (this.state._currentBlock) {\r\n      return this.state._currentBlock;\r\n    } // wait for a new latest block\r\n\r\n\r\n    const latestBlock = await new Promise(resolve => this.once(\"latest\", newState => {\r\n      if (newState._currentBlock) {\r\n        resolve(newState._currentBlock);\r\n      }\r\n    })); // return newly set current block\r\n\r\n    return latestBlock;\r\n  } // dont allow module consumer to remove our internal event listeners\r\n\r\n\r\n  removeAllListeners(eventName) {\r\n    if (eventName) {\r\n      super.removeAllListeners(eventName);\r\n    } else {\r\n      super.removeAllListeners();\r\n    } // re-add internal events\r\n\r\n\r\n    this._setupInternalEvents(); // trigger stop check just in case\r\n\r\n\r\n    this._onRemoveListener();\r\n\r\n    return this;\r\n  }\r\n  /**\r\n   * To be implemented in subclass.\r\n   */\r\n\r\n\r\n  _start() {// default behavior is noop\r\n  }\r\n  /**\r\n   * To be implemented in subclass.\r\n   */\r\n\r\n\r\n  _end() {// default behavior is noop\r\n  }\r\n\r\n  _newPotentialLatest(newBlock) {\r\n    const currentBlock = this.state._currentBlock; // only update if blok number is higher\r\n\r\n    if (currentBlock && newBlock.idempotencyKey === currentBlock.idempotencyKey) {\r\n      return;\r\n    }\r\n\r\n    this._setCurrentBlock(newBlock);\r\n  }\r\n\r\n  _setupInternalEvents() {\r\n    // first remove listeners for idempotency\r\n    this.removeListener(\"newListener\", this._onNewListener);\r\n    this.removeListener(\"removeListener\", this._onRemoveListener); // then add them\r\n\r\n    this.on(\"removeListener\", this._onRemoveListener);\r\n    this.on(\"newListener\", this._onNewListener);\r\n  }\r\n\r\n  _onNewListener() {\r\n    this._maybeStart();\r\n  }\r\n\r\n  _onRemoveListener() {\r\n    // `removeListener` is called *after* the listener is removed\r\n    if (this._getBlockTrackerEventCount() > 0) {\r\n      return;\r\n    }\r\n\r\n    this._maybeEnd();\r\n  }\r\n\r\n  _maybeStart() {\r\n    if (this.state._isRunning) {\r\n      return;\r\n    }\r\n\r\n    this.state._isRunning = true; // cancel setting latest block to stale\r\n\r\n    this._cancelBlockResetTimeout();\r\n\r\n    this._start();\r\n  }\r\n\r\n  _maybeEnd() {\r\n    if (!this.state._isRunning) {\r\n      return;\r\n    }\r\n\r\n    this.state._isRunning = false;\r\n\r\n    this._setupBlockResetTimeout();\r\n\r\n    this._end();\r\n  }\r\n\r\n  _getBlockTrackerEventCount() {\r\n    return blockTrackerEvents.map(eventName => this.listenerCount(eventName)).reduce(calculateSum);\r\n  }\r\n\r\n  _setCurrentBlock(newBlock) {\r\n    const oldBlock = this.state._currentBlock;\r\n    this.update({\r\n      _currentBlock: newBlock\r\n    });\r\n    this.emit(\"latest\", newBlock);\r\n    this.emit(\"sync\", {\r\n      oldBlock,\r\n      newBlock\r\n    });\r\n  }\r\n\r\n  _setupBlockResetTimeout() {\r\n    // clear any existing timeout\r\n    this._cancelBlockResetTimeout(); // clear latest block when stale\r\n\r\n\r\n    this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this.config.blockResetDuration); // nodejs - dont hold process open\r\n\r\n    if (this._blockResetTimeout.unref) {\r\n      this._blockResetTimeout.unref();\r\n    }\r\n  }\r\n\r\n  _cancelBlockResetTimeout() {\r\n    if (this._blockResetTimeout) {\r\n      clearTimeout(this._blockResetTimeout);\r\n    }\r\n  }\r\n\r\n  _resetCurrentBlock() {\r\n    this.update({\r\n      _currentBlock: {\r\n        idempotencyKey: \"\"\r\n      }\r\n    });\r\n  }\r\n\r\n}\r\n\r\nconst filterNoop = () => true;\r\n\r\nconst internalEvents = [\"newListener\", \"removeListener\"];\r\n\r\nconst externalEventFilter = name => !internalEvents.includes(name);\r\n\r\nfunction getRawListeners(eventEmitter, name) {\r\n  // prefer native\r\n  return eventEmitter.rawListeners(name);\r\n}\r\n\r\nfunction createEventEmitterProxy(initialTarget, opts) {\r\n  // parse options\r\n  const finalOpts = opts || {};\r\n  let eventFilter = finalOpts.eventFilter || filterNoop;\r\n  if (typeof eventFilter === \"string\" && eventFilter === \"skipInternal\") eventFilter = externalEventFilter;\r\n  if (typeof eventFilter !== \"function\") throw new Error(\"createEventEmitterProxy - Invalid eventFilter\");\r\n  let target = initialTarget;\r\n\r\n  let setTarget = newTarget => {\r\n    const oldTarget = target;\r\n    target = newTarget;\r\n    oldTarget.eventNames().filter(eventFilter).forEach(name => {\r\n      getRawListeners(oldTarget, name).forEach(handler => newTarget.on(name, handler));\r\n    }); // remove old listeners\r\n\r\n    oldTarget.removeAllListeners();\r\n  };\r\n\r\n  const proxy = new Proxy({}, {\r\n    get: (_, name) => {\r\n      // override `setTarget` access\r\n      if (name === \"setTarget\") return setTarget;\r\n      return target[name];\r\n    },\r\n    set: (_, name, value) => {\r\n      // allow `setTarget` overrides\r\n      if (name === \"setTarget\") {\r\n        setTarget = value;\r\n        return true;\r\n      }\r\n\r\n      target[name] = value;\r\n      return true;\r\n    }\r\n  });\r\n  return proxy;\r\n}\r\n\r\nfunction createSwappableProxy(initialTarget) {\r\n  let target = initialTarget;\r\n\r\n  let setTarget = newTarget => {\r\n    target = newTarget;\r\n  };\r\n\r\n  const proxy = new Proxy({}, {\r\n    get: (_, name) => {\r\n      // override `setTarget` access\r\n      if (name === \"setTarget\") return setTarget;\r\n      return target[name];\r\n    },\r\n    set: (_, name, value) => {\r\n      // allow `setTarget` overrides\r\n      if (name === \"setTarget\") {\r\n        setTarget = value;\r\n        return true;\r\n      }\r\n\r\n      target[name] = value;\r\n      return true;\r\n    }\r\n  });\r\n  return proxy;\r\n}\r\n\r\nconst POLLING_INTERVAL = 600000;\r\nclass BaseCurrencyController extends BaseController {\r\n  constructor(_ref) {\r\n    let {\r\n      config = {},\r\n      state\r\n    } = _ref;\r\n    super({\r\n      config,\r\n      state\r\n    });\r\n    this.defaultState = {\r\n      currentCurrency: \"usd\",\r\n      conversionRate: 0,\r\n      conversionDate: \"N/A\",\r\n      nativeCurrency: \"ETH\"\r\n    };\r\n    this.defaultConfig = {\r\n      pollInterval: POLLING_INTERVAL\r\n    };\r\n    this.initialize();\r\n  } //\r\n  // PUBLIC METHODS\r\n  //\r\n\r\n\r\n  getNativeCurrency() {\r\n    return this.state.nativeCurrency;\r\n  }\r\n\r\n  setNativeCurrency(nativeCurrency) {\r\n    this.update({\r\n      nativeCurrency,\r\n      ticker: nativeCurrency\r\n    });\r\n  }\r\n\r\n  getCurrentCurrency() {\r\n    return this.state.currentCurrency;\r\n  }\r\n\r\n  setCurrentCurrency(currentCurrency) {\r\n    this.update({\r\n      currentCurrency\r\n    });\r\n  }\r\n  /**\r\n   * A getter for the conversionRate property\r\n   *\r\n   * @returns The conversion rate from ETH to the selected currency.\r\n   *\r\n   */\r\n\r\n\r\n  getConversionRate() {\r\n    return this.state.conversionRate;\r\n  }\r\n\r\n  setConversionRate(conversionRate) {\r\n    this.update({\r\n      conversionRate\r\n    });\r\n  }\r\n  /**\r\n   * A getter for the conversionDate property\r\n   *\r\n   * @returns The date at which the conversion rate was set. Expressed in milliseconds since midnight of\r\n   * January 1, 1970\r\n   *\r\n   */\r\n\r\n\r\n  getConversionDate() {\r\n    return this.state.conversionDate;\r\n  }\r\n\r\n  setConversionDate(conversionDate) {\r\n    this.update({\r\n      conversionDate\r\n    });\r\n  }\r\n\r\n}\r\n\r\nfunction ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\r\n\r\nfunction _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\r\nconst createRandomId = json_rpc_random_id__WEBPACK_IMPORTED_MODULE_2___default()();\r\nfunction providerFromEngine(engine) {\r\n  const provider = new _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_1__.SafeEventEmitter(); // handle both rpc send methods\r\n\r\n  provider.sendAsync = async req => {\r\n    const res = await engine.handle(req);\r\n\r\n    if (res.error) {\r\n      throw new Error(res.error);\r\n    }\r\n\r\n    return res.result;\r\n  }; // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\r\n\r\n  provider.send = (req, callback) => {\r\n    if (typeof callback !== \"function\") {\r\n      throw new Error('Must provide callback to \"send\" method.');\r\n    }\r\n\r\n    engine.handle(req, callback);\r\n  }; // forward notifications\r\n\r\n\r\n  if (engine.on) {\r\n    engine.on(\"notification\", message => {\r\n      provider.emit(\"data\", null, message);\r\n    });\r\n  }\r\n\r\n  provider.request = async args => {\r\n    const req = _objectSpread$2(_objectSpread$2({}, args), {}, {\r\n      id: createRandomId(),\r\n      jsonrpc: \"2.0\"\r\n    });\r\n\r\n    const res = await provider.sendAsync(req);\r\n    return res;\r\n  };\r\n\r\n  return provider;\r\n}\r\nfunction providerFromMiddleware(middleware) {\r\n  const engine = new _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_1__.JRPCEngine();\r\n  engine.push(middleware);\r\n  const provider = providerFromEngine(engine);\r\n  return provider;\r\n}\r\nfunction providerAsMiddleware(provider) {\r\n  return async (req, res, _next, end) => {\r\n    // send request to provider\r\n    try {\r\n      const providerRes = await provider.sendAsync(req);\r\n      res.result = providerRes;\r\n      return end();\r\n    } catch (error) {\r\n      return end(error.message);\r\n    }\r\n  };\r\n}\r\n\r\nconst FEATURES_PROVIDER_CHANGE_WINDOW = {\r\n  height: 660,\r\n  width: 375\r\n};\r\nconst FEATURES_DEFAULT_WALLET_WINDOW = {\r\n  height: 740,\r\n  width: 1315\r\n};\r\nconst FEATURES_DEFAULT_POPUP_WINDOW = {\r\n  height: 700,\r\n  width: 1200\r\n};\r\nconst FEATURES_CONFIRM_WINDOW = {\r\n  height: 700,\r\n  width: 450\r\n};\r\nconst POPUP_LOADED = \"popup_loaded\";\r\nconst POPUP_RESULT = \"popup_result\";\r\nconst SETUP_COMPLETE = \"setup_complete\";\r\nconst ACTIVITY_ACTION_ALL = \"walletActivity.allTransactions\";\r\nconst ACTIVITY_ACTION_SEND = \"walletActivity.send\";\r\nconst ACTIVITY_ACTION_RECEIVE = \"walletActivity.receive\";\r\nconst ACTIVITY_ACTION_TOPUP = \"walletActivity.topup\";\r\nconst ACTIVITY_PERIOD_ALL = \"walletActivity.all\";\r\nconst ACTIVITY_PERIOD_WEEK_ONE = \"walletActivity.lastOneWeek\";\r\nconst ACTIVITY_PERIOD_MONTH_ONE = \"walletActivity.lastOneMonth\";\r\nconst ACTIVITY_PERIOD_MONTH_SIX = \"walletActivity.lastSixMonts\";\r\nconst ACTIVITY_STATUS_SUCCESSFUL = \"walletActivity.successful\";\r\nconst ACTIVITY_STATUS_UNSUCCESSFUL = \"walletActivity.unsuccessful\";\r\nconst ACTIVITY_STATUS_PENDING = \"walletActivity.pending\";\r\nconst ACTIVITY_STATUS_CANCELLED = \"walletActivity.cancelled\";\r\nconst ACTIVITY_STATUS_CANCELLING = \"walletActivity.cancelling\";\r\nconst COMMUNICATION_NOTIFICATIONS = {\r\n  IFRAME_STATUS: \"iframe_status\",\r\n  // Tell embed to create the window\r\n  CREATE_WINDOW: \"create_window\",\r\n  // Tell embed to close the window\r\n  CLOSE_WINDOW: \"close_window\",\r\n  USER_LOGGED_IN: \"user_logged_in\",\r\n  USER_LOGGED_OUT: \"user_logged_out\"\r\n};\r\nconst COMMUNICATION_JRPC_METHODS = {\r\n  LOGOUT: \"logout\",\r\n  WALLET_INSTANCE_ID: \"wallet_instance_id\",\r\n  USER_INFO: \"user_info\",\r\n  SET_PROVIDER: \"set_provider\",\r\n  TOPUP: \"topup\",\r\n  IFRAME_STATUS: \"iframe_status\",\r\n  // embed has opened the window as requested\r\n  OPENED_WINDOW: \"opened_window\",\r\n  // user has closed the window from embed's side\r\n  CLOSED_WINDOW: \"closed_window\",\r\n  GET_PROVIDER_STATE: \"get_provider_state\",\r\n  LOGIN_WITH_PRIVATE_KEY: \"login_with_private_key\"\r\n};\r\nconst PROVIDER_JRPC_METHODS = {\r\n  GET_PROVIDER_STATE: \"wallet_get_provider_state\"\r\n};\r\nconst PROVIDER_NOTIFICATIONS = {\r\n  ACCOUNTS_CHANGED: \"wallet_accounts_changed\",\r\n  CHAIN_CHANGED: \"wallet_chain_changed\",\r\n  UNLOCK_STATE_CHANGED: \"wallet_unlock_state_changed\"\r\n};\r\nconst BROADCAST_CHANNELS = {\r\n  REDIRECT_CHANNEL: \"redirect_channel\",\r\n  PROVIDER_CHANGE_CHANNEL: \"torus_provider_change_channel\",\r\n  TRANSACTION_CHANNEL: \"torus_channel\",\r\n  MESSAGE_CHANNEL: \"torus_message_channel\",\r\n  WALLET_LOGOUT_CHANNEL: \"wallet_logout_channel\",\r\n  WALLET_SELECTED_ADDRESS_CHANNEL: \"wallet_selected_address_channel\",\r\n  WALLET_NETWORK_CHANGE_CHANNEL: \"wallet_network_change_channel\",\r\n  WALLET_ACCOUNT_IMPORT_CHANNEL: \"wallet_account_import_channel\"\r\n};\r\nconst BROADCAST_CHANNELS_MSGS = {\r\n  LOGOUT: \"logout\",\r\n  ACCOUNT_IMPORTED: \"account_imported\",\r\n  SELECTED_ADDRESS_CHANGE: \"selected_address_change\",\r\n  NETWORK_CHANGE: \"network_change\"\r\n};\r\n\r\nfunction createChangeProviderMiddlewareMiddleware(_ref) {\r\n  let {\r\n    changeProvider\r\n  } = _ref;\r\n  return (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_1__.createAsyncMiddleware)(async (request, response, next) => {\r\n    const {\r\n      method\r\n    } = request;\r\n    if (method !== COMMUNICATION_JRPC_METHODS.SET_PROVIDER) return next();\r\n    if (!changeProvider) throw new Error(\"CommunicationMiddleware - opts.changeProvider not provided\");\r\n    response.result = await changeProvider(request);\r\n  });\r\n}\r\nfunction createTopupMiddleware(_ref2) {\r\n  let {\r\n    topup\r\n  } = _ref2;\r\n  return (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_1__.createAsyncMiddleware)(async (request, response, next) => {\r\n    const {\r\n      method\r\n    } = request;\r\n    if (method !== COMMUNICATION_JRPC_METHODS.TOPUP) return next();\r\n    if (!topup) throw new Error(\"CommunicationMiddleware - opts.topup not provided\");\r\n    response.result = await topup(request);\r\n  });\r\n}\r\nfunction createGenericJRPCMiddleware(targetMethod, handler) {\r\n  return (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_1__.createAsyncMiddleware)(async (request, response, next) => {\r\n    const {\r\n      method\r\n    } = request;\r\n    if (method !== targetMethod) return next();\r\n    if (!handler) throw new Error(\"CommunicationMiddleware - \".concat(targetMethod, \" not provided\"));\r\n    const result = await handler(request);\r\n\r\n    if (!result) {\r\n      return next();\r\n    }\r\n\r\n    response.result = result;\r\n    return undefined;\r\n  });\r\n}\r\nfunction createCommunicationMiddleware(providerHandlers) {\r\n  const {\r\n    getUserInfo,\r\n    getWalletInstanceId,\r\n    topup,\r\n    logout,\r\n    changeProvider,\r\n    setIFrameStatus,\r\n    handleWindowRpc,\r\n    getProviderState,\r\n    loginWithPrivateKey\r\n  } = providerHandlers;\r\n  return (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_1__.mergeMiddleware)([createChangeProviderMiddlewareMiddleware({\r\n    changeProvider\r\n  }), createTopupMiddleware({\r\n    topup\r\n  }), (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_1__.createScaffoldMiddleware)({\r\n    [COMMUNICATION_JRPC_METHODS.LOGOUT]: logout,\r\n    [COMMUNICATION_JRPC_METHODS.WALLET_INSTANCE_ID]: getWalletInstanceId,\r\n    [COMMUNICATION_JRPC_METHODS.USER_INFO]: getUserInfo,\r\n    [COMMUNICATION_JRPC_METHODS.IFRAME_STATUS]: setIFrameStatus,\r\n    // Do this in the orchestrator because communicationWindowManager needs to be passed into PopupHandlers\r\n    [COMMUNICATION_JRPC_METHODS.OPENED_WINDOW]: handleWindowRpc,\r\n    [COMMUNICATION_JRPC_METHODS.CLOSED_WINDOW]: handleWindowRpc,\r\n    [COMMUNICATION_JRPC_METHODS.GET_PROVIDER_STATE]: getProviderState\r\n  }), createGenericJRPCMiddleware(COMMUNICATION_JRPC_METHODS.LOGIN_WITH_PRIVATE_KEY, loginWithPrivateKey)]);\r\n}\r\n\r\nclass BaseEmbedController extends BaseController {\r\n  constructor(_ref) {\r\n    let {\r\n      config = {},\r\n      state\r\n    } = _ref;\r\n    super({\r\n      config,\r\n      state\r\n    });\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"_communicationProviderProxy\", void 0);\r\n\r\n    this.defaultState = {\r\n      buttonPosition: \"bottom-right\",\r\n      isIFrameFullScreen: true,\r\n      apiKey: \"torus-default\",\r\n      oauthModalVisibility: false,\r\n      loginInProgress: false,\r\n      dappMetadata: {\r\n        name: \"\",\r\n        icon: \"\"\r\n      }\r\n    };\r\n    this.initialize();\r\n  }\r\n  /**\r\n   * Called by orchestrator once while initializing the class\r\n   * @param handlers - JRPC handlers for provider\r\n   * @returns - provider - Returns the providerProxy\r\n   */\r\n\r\n\r\n  initializeProvider(handlers) {\r\n    const engine = new _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_1__.JRPCEngine();\r\n    const communicationMiddleware = createCommunicationMiddleware(handlers);\r\n    engine.push(communicationMiddleware);\r\n    const communicationProvider = providerFromEngine(engine);\r\n    this.setCommunicationProvider(communicationProvider);\r\n  }\r\n\r\n  setCommunicationProvider(communicationProvider) {\r\n    if (this._communicationProviderProxy) {\r\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\r\n      // @ts-ignore\r\n      this._communicationProviderProxy.setTarget(communicationProvider);\r\n    } else {\r\n      this._communicationProviderProxy = createSwappableProxy(communicationProvider);\r\n    }\r\n  }\r\n\r\n}\r\n\r\nclass CommunicationWindowManager extends _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_1__.SafeEventEmitter {\r\n  constructor() {\r\n    super(...arguments);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"handleWindowRpc\", (request, response, next, end) => {\r\n      const {\r\n        method,\r\n        params\r\n      } = request;\r\n\r\n      if (method === COMMUNICATION_JRPC_METHODS.OPENED_WINDOW) {\r\n        const {\r\n          windowId\r\n        } = params; // I've been informed that a window has been opened\r\n\r\n        this.emit(\"\".concat(windowId, \":opened\"));\r\n        response.result = true;\r\n        end();\r\n      } else if (method === COMMUNICATION_JRPC_METHODS.CLOSED_WINDOW) {\r\n        const {\r\n          windowId\r\n        } = params; // I've been informed that a window has been closed\r\n\r\n        this.emit(\"\".concat(windowId, \":closed\"));\r\n        response.result = true;\r\n        end();\r\n      } else {\r\n        next();\r\n      }\r\n    });\r\n  }\r\n\r\n}\r\n\r\nconst LOGIN_PROVIDER = {\r\n  GOOGLE: \"google\",\r\n  FACEBOOK: \"facebook\",\r\n  REDDIT: \"reddit\",\r\n  DISCORD: \"discord\",\r\n  TWITCH: \"twitch\",\r\n  APPLE: \"apple\",\r\n  LINE: \"line\",\r\n  GITHUB: \"github\",\r\n  KAKAO: \"kakao\",\r\n  LINKEDIN: \"linkedin\",\r\n  TWITTER: \"twitter\",\r\n  WEIBO: \"weibo\",\r\n  WECHAT: \"wechat\",\r\n  EMAIL_PASSWORDLESS: \"email_passwordless\"\r\n};\r\nconst PAYMENT_PROVIDER = {\r\n  MOONPAY: \"moonpay\",\r\n  WYRE: \"wyre\",\r\n  RAMPNETWORK: \"rampnetwork\",\r\n  XANPOOL: \"xanpool\",\r\n  MERCURYO: \"mercuryo\",\r\n  TRANSAK: \"transak\"\r\n};\r\n\r\nconst getTxStatusText = txStatus => {\r\n  switch (txStatus) {\r\n    case \"rejected\":\r\n    case \"unapproved\":\r\n    case \"failed\":\r\n      return ACTIVITY_STATUS_UNSUCCESSFUL;\r\n\r\n    case \"confirmed\":\r\n      return ACTIVITY_STATUS_SUCCESSFUL;\r\n\r\n    case \"submitted\":\r\n      return ACTIVITY_STATUS_PENDING;\r\n\r\n    case \"cancelled\":\r\n      return ACTIVITY_STATUS_CANCELLED;\r\n\r\n    default:\r\n      return \"\";\r\n  }\r\n};\r\n\r\n/**\r\n * General utility functions\r\n */\r\n\r\nfunction intToHex(i) {\r\n  const hex = i.toString(16);\r\n  return \"0x\".concat(hex);\r\n}\r\n/**\r\n * Returns a random number. Don't use for cryptographic purposes.\r\n * @returns a random number\r\n */\r\n\r\nconst randomId = () => Math.random().toString(36).slice(2);\r\n/**\r\n * Pads the front of the given hex string with zeroes until it reaches the\r\n * target length. If the input string is already longer than or equal to the\r\n * target length, it is returned unmodified.\r\n *\r\n * If the input string is \"0x\"-prefixed or not a hex string, an error will be\r\n * thrown.\r\n *\r\n * @param hexString - The hexadecimal string to pad with zeroes.\r\n * @param targetLength - The target length of the hexadecimal string.\r\n * @returns The input string front-padded with zeroes, or the original string\r\n * if it was already greater than or equal to to the target length.\r\n */\r\n\r\nfunction padWithZeroes(hexString, targetLength) {\r\n  if (hexString !== \"\" && !/^[a-f0-9]+$/iu.test(hexString)) {\r\n    throw new Error(\"Expected an unprefixed hex string. Received: \".concat(hexString));\r\n  }\r\n\r\n  if (targetLength < 0) {\r\n    throw new Error(\"Expected a non-negative integer target length. Received: \".concat(targetLength));\r\n  }\r\n\r\n  return String.prototype.padStart.call(hexString, targetLength, \"0\");\r\n}\r\n/**\r\n * Concatenate an extended ECDSA signature into a hex string.\r\n *\r\n * @param v - The 'v' portion of the signature.\r\n * @param r - The 'r' portion of the signature.\r\n * @param s - The 's' portion of the signature.\r\n * @returns The concatenated ECDSA signature.\r\n */\r\n\r\nfunction concatSig(v, r, s) {\r\n  const rSig = (0,ethereumjs_util__WEBPACK_IMPORTED_MODULE_4__.fromSigned)(r);\r\n  const sSig = (0,ethereumjs_util__WEBPACK_IMPORTED_MODULE_4__.fromSigned)(s);\r\n  const vSig = (0,ethereumjs_util__WEBPACK_IMPORTED_MODULE_4__.bufferToInt)(v);\r\n  const rStr = padWithZeroes((0,ethereumjs_util__WEBPACK_IMPORTED_MODULE_4__.toUnsigned)(rSig).toString(\"hex\"), 64);\r\n  const sStr = padWithZeroes((0,ethereumjs_util__WEBPACK_IMPORTED_MODULE_4__.toUnsigned)(sSig).toString(\"hex\"), 64);\r\n  const vStr = (0,ethereumjs_util__WEBPACK_IMPORTED_MODULE_4__.stripHexPrefix)(intToHex(vSig));\r\n  return (0,ethereumjs_util__WEBPACK_IMPORTED_MODULE_4__.addHexPrefix)(rStr.concat(sStr, vStr));\r\n}\r\nfunction timeout$1(duration) {\r\n  return new Promise(resolve => {\r\n    const timeoutRef = window.setTimeout(() => {\r\n      resolve();\r\n      window.clearTimeout(timeoutRef);\r\n    }, duration);\r\n  });\r\n}\r\n/**\r\n * Text/number formatting utilities\r\n */\r\n\r\nconst formatSmallNumbers = function (number) {\r\n  let currency = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"usd\";\r\n  let noTilde = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\r\n  const finalNumber = bignumber_js__WEBPACK_IMPORTED_MODULE_3__.BigNumber.isBigNumber(number) ? number.toNumber() : number;\r\n  if (!Number.isFinite(finalNumber)) return \"\";\r\n  const value = currency.toLowerCase() === \"usd\" ? parseFloat(Number(finalNumber).toFixed(2)) : parseFloat(Number(finalNumber).toFixed(5));\r\n  const tilde = value > 0 ? \"~ \" : \"\";\r\n  return \"\".concat(currency.toLowerCase() === \"usd\" || noTilde ? \"\" : tilde).concat(Number(value), \" \").concat(currency.toUpperCase());\r\n};\r\nconst addressSlicer = function (address) {\r\n  let sliceLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;\r\n\r\n  if (address.length < 11) {\r\n    return address;\r\n  }\r\n\r\n  if (typeof address !== \"string\") return \"\";\r\n  return \"\".concat(address.slice(0, sliceLength), \"...\").concat(address.slice(-sliceLength));\r\n};\r\nconst significantDigits = function (number) {\r\n  let perc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\r\n  let length_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;\r\n  let input = !bignumber_js__WEBPACK_IMPORTED_MODULE_3__.BigNumber.isBigNumber(number) ? new bignumber_js__WEBPACK_IMPORTED_MODULE_3__.BigNumber(number) : number;\r\n  if (input.isZero()) return input;\r\n\r\n  if (perc) {\r\n    input = input.times(new bignumber_js__WEBPACK_IMPORTED_MODULE_3__.BigNumber(100));\r\n  }\r\n\r\n  let depth;\r\n\r\n  if (input.gte(new bignumber_js__WEBPACK_IMPORTED_MODULE_3__.BigNumber(1))) {\r\n    depth = length_;\r\n  } else {\r\n    depth = length_ - 1 + Math.ceil(Math.log10(new bignumber_js__WEBPACK_IMPORTED_MODULE_3__.BigNumber(\"1\").div(input).toNumber()));\r\n  }\r\n\r\n  const shift = new bignumber_js__WEBPACK_IMPORTED_MODULE_3__.BigNumber(10).pow(new bignumber_js__WEBPACK_IMPORTED_MODULE_3__.BigNumber(depth));\r\n  const roundedNumber = Math.round(shift.times(input).toNumber()) / shift.toNumber();\r\n  return roundedNumber;\r\n};\r\nconst formatDate = inputDate => {\r\n  const monthList = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\r\n  const date = new Date(inputDate);\r\n  const day = date.getDate();\r\n  const month = monthList[date.getMonth()];\r\n  const year = date.getFullYear();\r\n  return \"\".concat(day, \" \").concat(month, \" \").concat(year);\r\n};\r\nconst formatTime = time => {\r\n  return new Date(time).toTimeString().slice(0, 8);\r\n};\r\n/**\r\n * Network utilities\r\n */\r\n\r\nconst transactionMatchesNetwork = (transaction, chainId) => {\r\n  if (typeof transaction.chainId !== \"undefined\") {\r\n    return transaction.chainId === chainId;\r\n  }\r\n\r\n  return false;\r\n};\r\n/**\r\n * Signing utils\r\n */\r\n\r\nconst hashMessage = message => {\r\n  const bufferedMessage = Buffer.from(message, \"utf8\");\r\n  const el = (0,ethereumjs_util__WEBPACK_IMPORTED_MODULE_4__.hashPersonalMessage)(bufferedMessage);\r\n  return el;\r\n};\r\nconst signMessage = (privateKey, data) => {\r\n  const privKey = Buffer.from(privateKey, \"hex\");\r\n  const message = (0,ethereumjs_util__WEBPACK_IMPORTED_MODULE_4__.stripHexPrefix)(data);\r\n  const msgSig = (0,ethereumjs_util__WEBPACK_IMPORTED_MODULE_4__.ecsign)(Buffer.from(message, \"hex\"), privKey);\r\n  const rawMsgSig = concatSig((0,ethereumjs_util__WEBPACK_IMPORTED_MODULE_4__.intToBuffer)(msgSig.v), msgSig.r, msgSig.s);\r\n  return rawMsgSig;\r\n};\r\n/**\r\n * popup handler utils\r\n */\r\n\r\nfunction getPopupFeatures(_ref) {\r\n  let {\r\n    width: w,\r\n    height: h\r\n  } = _ref;\r\n  // Fixes dual-screen position                             Most browsers      Firefox\r\n  const dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : window.screenX;\r\n  const dualScreenTop = window.screenTop !== undefined ? window.screenTop : window.screenY;\r\n  const width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : window.screen.width;\r\n  const height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : window.screen.height;\r\n  const systemZoom = 1; // No reliable estimate\r\n\r\n  const left = Math.abs((width - w) / 2 / systemZoom + dualScreenLeft);\r\n  const top = Math.abs((height - h) / 2 / systemZoom + dualScreenTop);\r\n  const features = \"titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=\".concat(h / systemZoom, \",width=\").concat(w / systemZoom, \",top=\").concat(top, \",left=\").concat(left);\r\n  return features;\r\n}\r\nconst broadcastChannelOptions = {\r\n  // type: 'localstorage', // (optional) enforce a type, oneOf['native', 'idb', 'localstorage', 'node']\r\n  webWorkerSupport: false // (optional) set this to false if you know that your channel will never be used in a WebWorker (increases performance)\r\n\r\n};\r\nfunction getCustomDeviceInfo() {\r\n  var _navigator;\r\n\r\n  if ((_navigator = navigator) !== null && _navigator !== void 0 && _navigator.brave) {\r\n    return {\r\n      browser: \"Brave\"\r\n    };\r\n  }\r\n}\r\nclass UserError extends Error {}\r\nconst handleRedirectParameters = (hash, queryParameters) => {\r\n  const hashParameters = {};\r\n  const hashUrl = new URL(\"\".concat(window.location.origin, \"/?\").concat(hash.slice(1)));\r\n  hashUrl.searchParams.forEach((value, key) => {\r\n    hashParameters[key] = value;\r\n  });\r\n  let instanceParameters = {};\r\n  let error = \"\";\r\n\r\n  if (!queryParameters.windowId) {\r\n    if (Object.keys(hashParameters).length > 0 && hashParameters.state) {\r\n      instanceParameters = JSON.parse(window.atob(decodeURIComponent(decodeURIComponent(hashParameters.state)))) || {};\r\n      error = hashParameters.error_description || hashParameters.error || error;\r\n    } else if (Object.keys(queryParameters).length > 0 && queryParameters.state) {\r\n      instanceParameters = JSON.parse(window.atob(decodeURIComponent(decodeURIComponent(queryParameters.state)))) || {};\r\n      if (queryParameters.error) error = queryParameters.error;\r\n    }\r\n  }\r\n\r\n  return {\r\n    error,\r\n    instanceParameters,\r\n    hashParameters\r\n  };\r\n};\r\n\r\nclass BaseKeyringController extends BaseController {\r\n  constructor(_ref) {\r\n    var _state$wallets;\r\n\r\n    let {\r\n      config = {},\r\n      state\r\n    } = _ref;\r\n    super({\r\n      config,\r\n      state\r\n    });\r\n    this.defaultState = {\r\n      wallets: (_state$wallets = state.wallets) !== null && _state$wallets !== void 0 ? _state$wallets : []\r\n    };\r\n    this.initialize();\r\n  } // for signing auth message\r\n\r\n\r\n  signAuthMessage(address, message) {\r\n    const keyring = this.state.wallets.find(x => x.address === address);\r\n\r\n    if (!keyring) {\r\n      throw new Error(\"key does not exist\");\r\n    }\r\n\r\n    const hashedMessage = hashMessage(message).toString(\"hex\");\r\n    const rawMessageSig = signMessage(keyring.privateKey, hashedMessage);\r\n    return rawMessageSig;\r\n  }\r\n\r\n}\r\n\r\nconst RETRIABLE_ERRORS = [// ignore server overload errors\r\n\"Gateway timeout\", \"ETIMEDOUT\", // ignore server sent html error pages\r\n// or truncated json responses\r\n\"failed to parse response body\", // ignore errors where http req failed to establish\r\n\"Failed to fetch\"];\r\n\r\nfunction checkForHttpErrors(fetchRes) {\r\n  // check for errors\r\n  switch (fetchRes.status) {\r\n    case 405:\r\n      throw eth_rpc_errors__WEBPACK_IMPORTED_MODULE_5__.ethErrors.rpc.methodNotFound();\r\n\r\n    case 418:\r\n      throw eth_rpc_errors__WEBPACK_IMPORTED_MODULE_5__.ethErrors.rpc.internal({\r\n        message: \"Request is being rate limited.\"\r\n      });\r\n\r\n    case 503:\r\n    case 504:\r\n      throw eth_rpc_errors__WEBPACK_IMPORTED_MODULE_5__.ethErrors.rpc.internal({\r\n        message: \"Gateway timeout. The request took too long to process.\" + \"This can happen when querying over too wide a block range.\"\r\n      });\r\n  }\r\n}\r\n\r\nfunction timeout(duration) {\r\n  return new Promise(resolve => setTimeout(resolve, duration));\r\n}\r\n\r\nfunction parseResponse(fetchRes, body) {\r\n  // check for error code\r\n  if (fetchRes.status !== 200) {\r\n    throw eth_rpc_errors__WEBPACK_IMPORTED_MODULE_5__.ethErrors.rpc.internal({\r\n      message: \"Non-200 status code: '\".concat(fetchRes.status, \"'\"),\r\n      data: body\r\n    });\r\n  } // check for rpc error\r\n\r\n\r\n  if (body.error) {\r\n    throw eth_rpc_errors__WEBPACK_IMPORTED_MODULE_5__.ethErrors.rpc.internal({\r\n      data: body.error\r\n    });\r\n  } // return successful result\r\n\r\n\r\n  return body.result;\r\n}\r\n\r\nfunction createFetchConfigFromReq(_ref) {\r\n  let {\r\n    req,\r\n    rpcTarget,\r\n    originHttpHeaderKey\r\n  } = _ref;\r\n  const parsedUrl = new URL(rpcTarget); // prepare payload\r\n  // copy only canonical json rpc properties\r\n\r\n  const payload = {\r\n    id: req.id,\r\n    jsonrpc: req.jsonrpc,\r\n    method: req.method,\r\n    params: req.params\r\n  }; // extract 'origin' parameter from request\r\n\r\n  const originDomain = req.origin; // serialize request body\r\n\r\n  const serializedPayload = JSON.stringify(payload); // configure fetch params\r\n\r\n  const fetchParams = {\r\n    method: \"POST\",\r\n    headers: {\r\n      Accept: \"application/json\",\r\n      \"Content-Type\": \"application/json\"\r\n    },\r\n    body: serializedPayload\r\n  }; // optional: add request origin as header\r\n\r\n  if (originHttpHeaderKey && originDomain) {\r\n    fetchParams.headers[originHttpHeaderKey] = originDomain;\r\n  }\r\n\r\n  return {\r\n    fetchUrl: parsedUrl.href,\r\n    fetchParams\r\n  };\r\n}\r\nfunction createFetchMiddleware(_ref2) {\r\n  let {\r\n    rpcTarget,\r\n    originHttpHeaderKey\r\n  } = _ref2;\r\n  return (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_1__.createAsyncMiddleware)(async (req, res, _next) => {\r\n    const {\r\n      fetchUrl,\r\n      fetchParams\r\n    } = createFetchConfigFromReq({\r\n      req,\r\n      rpcTarget,\r\n      originHttpHeaderKey\r\n    }); // attempt request multiple times\r\n\r\n    const maxAttempts = 5;\r\n    const retryInterval = 1000;\r\n\r\n    for (let attempt = 0; attempt < maxAttempts; attempt++) {\r\n      try {\r\n        const fetchRes = await fetch(fetchUrl, fetchParams); // check for http errrors\r\n\r\n        checkForHttpErrors(fetchRes); // parse response body\r\n\r\n        const fetchBody = await fetchRes.json();\r\n        const result = parseResponse(fetchRes, fetchBody); // set result and exit retry loop\r\n\r\n        res.result = result;\r\n        return;\r\n      } catch (err) {\r\n        const errMsg = err.toString();\r\n        const isRetriable = RETRIABLE_ERRORS.some(phrase => errMsg.includes(phrase)); // re-throw error if not retriable\r\n\r\n        if (!isRetriable) {\r\n          throw err;\r\n        }\r\n      } // delay before retrying\r\n\r\n\r\n      await timeout(retryInterval);\r\n    }\r\n  });\r\n}\r\n\r\nfunction createLoggerMiddleware(options) {\r\n  return function loggerMiddleware(request, response, next) {\r\n    next(callback => {\r\n      if (response.error) {\r\n        loglevel__WEBPACK_IMPORTED_MODULE_6___default().warn(\"Error in RPC response:\\n\", response);\r\n      }\r\n\r\n      if (request.isTorusInternal) return;\r\n      loglevel__WEBPACK_IMPORTED_MODULE_6___default().info(\"RPC (\".concat(options.origin, \"):\"), request, \"->\", response);\r\n      callback();\r\n    });\r\n  };\r\n}\r\n\r\nfunction createOriginMiddleware(options) {\r\n  return function originMiddleware(request, _, next) {\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    request.origin = options.origin;\r\n    next();\r\n  };\r\n}\r\n\r\nclass BroadcastChannelHandler {\r\n  constructor(channelPrefix) {\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"bc\", void 0);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"channel\", void 0);\r\n\r\n    const queryParameters = new URLSearchParams(window.location.search);\r\n    const instanceId = queryParameters.get(\"instanceId\");\r\n    this.channel = \"\".concat(channelPrefix, \"_\").concat(instanceId);\r\n    this.bc = new broadcast_channel__WEBPACK_IMPORTED_MODULE_10__.BroadcastChannel(this.channel, broadcastChannelOptions);\r\n  }\r\n\r\n  getMessageFromChannel() {\r\n    return new Promise((resolve, reject) => {\r\n      this.bc.addEventListener(\"message\", async ev => {\r\n        this.bc.close();\r\n\r\n        if (ev.error) {\r\n          reject(ev.error);\r\n        } else {\r\n          resolve(ev.data);\r\n        }\r\n      });\r\n      this.bc.postMessage({\r\n        data: {\r\n          type: POPUP_LOADED\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n}\r\n\r\nclass StreamWindow extends BaseController {\r\n  // if window has been closed by users\r\n  constructor(_ref) {\r\n    let {\r\n      config,\r\n      state = {}\r\n    } = _ref;\r\n    super({\r\n      config,\r\n      state\r\n    });\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"closed\", false);\r\n\r\n    this.initialize();\r\n  }\r\n\r\n  async open() {\r\n    return new Promise((resolve, reject) => {\r\n      const {\r\n        communicationEngine,\r\n        communicationWindowManager\r\n      } = this.config;\r\n      communicationWindowManager.once(\"\".concat(this.state.windowId, \":closed\"), () => {\r\n        this.closed = true;\r\n      }); // Window is not open yet\r\n\r\n      if (!this.state.windowId) {\r\n        this.update({\r\n          windowId: randomId()\r\n        });\r\n        communicationWindowManager.once(\"\".concat(this.state.windowId, \":opened\"), () => {\r\n          resolve(this);\r\n        }); // Tell the other party to create a window by prompting the user to click on something\r\n\r\n        communicationEngine.emit(\"notification\", {\r\n          method: COMMUNICATION_NOTIFICATIONS.CREATE_WINDOW,\r\n          params: {\r\n            windowId: this.state.windowId,\r\n            url: this.state.url.href\r\n          }\r\n        });\r\n      } else {\r\n        // Send this window with `windowId` the url to open via bc\r\n        const bc = new broadcast_channel__WEBPACK_IMPORTED_MODULE_10__.BroadcastChannel(this.state.windowId, broadcastChannelOptions);\r\n        let writeInterval = null;\r\n        bc.addEventListener(\"message\", async ev => {\r\n          try {\r\n            loglevel__WEBPACK_IMPORTED_MODULE_6___default().info(ev, \"receiving data on channel: \".concat(bc.name));\r\n            const {\r\n              error\r\n            } = ev;\r\n\r\n            if (error) {\r\n              // Popup says some error. so, we say it's not really opened\r\n              reject(new Error(error));\r\n              return;\r\n            }\r\n\r\n            const {\r\n              message\r\n            } = ev.data;\r\n\r\n            if (message === POPUP_LOADED) {\r\n              if (writeInterval) window.clearInterval(writeInterval);\r\n              await bc.postMessage({\r\n                data: {\r\n                  url: this.state.url.href,\r\n                  message: \"\" // No need of a msg\r\n\r\n                }\r\n              });\r\n              resolve(this);\r\n              bc.close();\r\n            }\r\n          } catch (error) {\r\n            reject(error);\r\n            bc.close(); // Something went wrong. so, we close that window\r\n\r\n            this.close();\r\n          }\r\n        }); // We don't know if the other end is ready to receive this msg. So, we keep writing until it receives and sends back something\r\n\r\n        writeInterval = window.setInterval(() => {\r\n          bc.postMessage({\r\n            data: {\r\n              message: SETUP_COMPLETE\r\n            }\r\n          });\r\n        }, 200);\r\n      }\r\n    });\r\n  }\r\n\r\n  close() {\r\n    const {\r\n      communicationEngine\r\n    } = this.config;\r\n    communicationEngine.emit(\"notification\", {\r\n      method: COMMUNICATION_NOTIFICATIONS.CLOSE_WINDOW,\r\n      params: {\r\n        windowId: this.state.windowId\r\n      }\r\n    });\r\n  }\r\n\r\n}\r\n\r\n/*\r\nScenarios:\r\n1. Open a normal popup window and no communication with it - Use PopupHandler\r\n2. Open a popup window and communicate with it - Use PopupWithBcHandler (can initiate communication by waiting for window to open or not)\r\n\r\n3. If window is already opened, pass in windowId to the popup handler.\r\n   This will establish communication with the popup window and sends it a new url to redirect to\r\n\r\n\r\nIf you're trying to open a window and it gets blocked (happens if you're in iframe or delay b/w click and opening window),\r\nStreamWindow is invoked and it writes in a channel to display a message to the user\r\n\r\nOnce user clicks on that modal/dialog, we pre-open the window and pass in the windowId (goes to 3)\r\n*/\r\n\r\n/**\r\n * Handles popup window management.\r\n * For broadcast channel communication, use url with `instanceId` coded into state parameter.\r\n * This state parameter will be passed across redirects according to OAuth spec.\r\n */\r\n\r\nclass PopupHandler extends BaseController {\r\n  constructor(_ref) {\r\n    let {\r\n      config,\r\n      state\r\n    } = _ref;\r\n    super({\r\n      config,\r\n      state\r\n    }); // this.id = randomId()\r\n    // Add in dapp storage key to all popups as a hash parameter\r\n\r\n    this.defaultConfig = {\r\n      dappStorageKey: \"\",\r\n      features: getPopupFeatures(FEATURES_DEFAULT_POPUP_WINDOW),\r\n      target: \"_blank\",\r\n      communicationEngine: null,\r\n      communicationWindowManager: null\r\n    };\r\n    this.defaultState = {\r\n      windowTimer: null,\r\n      window: null,\r\n      iClosedWindow: false,\r\n      windowId: \"\",\r\n      url: state.url\r\n    };\r\n    this.initialize();\r\n\r\n    this._setupTimer();\r\n  }\r\n\r\n  async open() {\r\n    // if window is already open\r\n    const {\r\n      target,\r\n      features,\r\n      dappStorageKey,\r\n      communicationEngine,\r\n      communicationWindowManager\r\n    } = this.config;\r\n    const {\r\n      windowId,\r\n      url\r\n    } = this.state;\r\n\r\n    if (dappStorageKey) {\r\n      const urlHashParams = new URLSearchParams(url.hash.slice(1));\r\n      urlHashParams.append(\"dappStorageKey\", dappStorageKey);\r\n      url.hash = urlHashParams.toString();\r\n      this.update({\r\n        url\r\n      });\r\n    } // No window has been pre-opened\r\n\r\n\r\n    if (!windowId) {\r\n      // try to open a window first\r\n      let localWindow = window.open(url.href, target, features);\r\n\r\n      if (!localWindow) {\r\n        // if it's blocked, open StreamWindow\r\n        localWindow = new StreamWindow({\r\n          config: {\r\n            communicationEngine,\r\n            communicationWindowManager\r\n          },\r\n          state: {\r\n            url\r\n          }\r\n        });\r\n        localWindow.open();\r\n      }\r\n\r\n      this.update({\r\n        window: localWindow\r\n      });\r\n      return;\r\n    } // A window has been pre-opened with a query parameter `windowId`\r\n\r\n\r\n    const localWindow = new StreamWindow({\r\n      config: {\r\n        communicationEngine,\r\n        communicationWindowManager\r\n      },\r\n      state: {\r\n        url,\r\n        windowId\r\n      }\r\n    });\r\n    this.update({\r\n      window: localWindow\r\n    });\r\n    await localWindow.open();\r\n  }\r\n\r\n  close() {\r\n    this.update({\r\n      iClosedWindow: true\r\n    });\r\n    const {\r\n      window\r\n    } = this.state;\r\n    if (window) window.close();\r\n  }\r\n\r\n  _setupTimer() {\r\n    const timer = window.setInterval(() => {\r\n      const {\r\n        window,\r\n        windowTimer,\r\n        iClosedWindow\r\n      } = this.state;\r\n\r\n      if (window && window.closed) {\r\n        if (windowTimer) clearInterval(windowTimer);\r\n\r\n        if (!iClosedWindow) {\r\n          this.emit(\"close\");\r\n        }\r\n\r\n        this.update({\r\n          iClosedWindow: false,\r\n          window: null\r\n        });\r\n      }\r\n\r\n      if (window === null && windowTimer) clearInterval(windowTimer);\r\n    }, 500);\r\n    this.update({\r\n      windowTimer: timer\r\n    });\r\n  }\r\n\r\n}\r\n\r\nclass PopupStoreChannel {\r\n  constructor(_ref) {\r\n    let {\r\n      instanceId,\r\n      handleLogout,\r\n      handleAccountImport,\r\n      handleNetworkChange,\r\n      handleSelectedAddressChange\r\n    } = _ref;\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"handleLogout\", void 0);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"handleAccountImport\", void 0);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"handleNetworkChange\", void 0);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"handleSelectedAddressChange\", void 0);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"instanceId\", void 0);\r\n\r\n    this.instanceId = instanceId;\r\n    this.handleLogout = handleLogout;\r\n    this.handleAccountImport = handleAccountImport;\r\n    this.handleNetworkChange = handleNetworkChange;\r\n    this.handleSelectedAddressChange = handleSelectedAddressChange;\r\n  }\r\n\r\n  setupStoreChannels() {\r\n    this.logoutChannel();\r\n    this.importAccountChannel();\r\n    this.networkChangeChannel();\r\n    this.selectedAddressChangeChannel();\r\n  }\r\n\r\n  logoutChannel() {\r\n    const logoutChannel = new broadcast_channel__WEBPACK_IMPORTED_MODULE_10__.BroadcastChannel(\"\".concat(BROADCAST_CHANNELS.WALLET_LOGOUT_CHANNEL, \"_\").concat(this.instanceId), broadcastChannelOptions);\r\n    logoutChannel.addEventListener(\"message\", ev => {\r\n      var _ev$data;\r\n\r\n      loglevel__WEBPACK_IMPORTED_MODULE_6___default().info(\"received logout message\", ev);\r\n\r\n      if (!ev.error && ((_ev$data = ev.data) === null || _ev$data === void 0 ? void 0 : _ev$data.type) === BROADCAST_CHANNELS_MSGS.LOGOUT) {\r\n        loglevel__WEBPACK_IMPORTED_MODULE_6___default().info(\"Logging Out\");\r\n        this.handleLogout();\r\n      }\r\n    });\r\n  }\r\n\r\n  importAccountChannel() {\r\n    const walletAccountImportChannel = new broadcast_channel__WEBPACK_IMPORTED_MODULE_10__.BroadcastChannel(\"\".concat(BROADCAST_CHANNELS.WALLET_ACCOUNT_IMPORT_CHANNEL, \"_\").concat(this.instanceId), broadcastChannelOptions);\r\n    walletAccountImportChannel.addEventListener(\"message\", ev => {\r\n      var _ev$data2;\r\n\r\n      if (!ev.error && ((_ev$data2 = ev.data) === null || _ev$data2 === void 0 ? void 0 : _ev$data2.type) === BROADCAST_CHANNELS_MSGS.ACCOUNT_IMPORTED) {\r\n        var _ev$data3;\r\n\r\n        this.handleAccountImport((_ev$data3 = ev.data) === null || _ev$data3 === void 0 ? void 0 : _ev$data3.privKey);\r\n      }\r\n    });\r\n  }\r\n\r\n  networkChangeChannel() {\r\n    const walletAccountImportChannel = new broadcast_channel__WEBPACK_IMPORTED_MODULE_10__.BroadcastChannel(\"\".concat(BROADCAST_CHANNELS.WALLET_NETWORK_CHANGE_CHANNEL, \"_\").concat(this.instanceId), broadcastChannelOptions);\r\n    walletAccountImportChannel.addEventListener(\"message\", ev => {\r\n      var _ev$data4;\r\n\r\n      if (!ev.error && ((_ev$data4 = ev.data) === null || _ev$data4 === void 0 ? void 0 : _ev$data4.type) === BROADCAST_CHANNELS_MSGS.NETWORK_CHANGE) {\r\n        var _ev$data5;\r\n\r\n        this.handleNetworkChange((_ev$data5 = ev.data) === null || _ev$data5 === void 0 ? void 0 : _ev$data5.network);\r\n      }\r\n    });\r\n  }\r\n\r\n  selectedAddressChangeChannel() {\r\n    const walletAccountImportChannel = new broadcast_channel__WEBPACK_IMPORTED_MODULE_10__.BroadcastChannel(\"\".concat(BROADCAST_CHANNELS.WALLET_SELECTED_ADDRESS_CHANNEL, \"_\").concat(this.instanceId), broadcastChannelOptions);\r\n    walletAccountImportChannel.addEventListener(\"message\", ev => {\r\n      var _ev$data6;\r\n\r\n      if (!ev.error && ((_ev$data6 = ev.data) === null || _ev$data6 === void 0 ? void 0 : _ev$data6.type) === BROADCAST_CHANNELS_MSGS.SELECTED_ADDRESS_CHANGE) {\r\n        var _ev$data7;\r\n\r\n        this.handleSelectedAddressChange((_ev$data7 = ev.data) === null || _ev$data7 === void 0 ? void 0 : _ev$data7.selectedAddress);\r\n      }\r\n    });\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * PopupWithBcHandler is a PopupHandler which uses broadcast channel to communicate with the popup window.\r\n */\r\n\r\nclass PopupWithBcHandler extends PopupHandler {\r\n  constructor(_ref) {\r\n    let {\r\n      config,\r\n      state,\r\n      instanceId\r\n    } = _ref;\r\n    super({\r\n      config,\r\n      state\r\n    });\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"bc\", void 0);\r\n\r\n    this.bc = new broadcast_channel__WEBPACK_IMPORTED_MODULE_10__.BroadcastChannel(instanceId, broadcastChannelOptions);\r\n  }\r\n  /**\r\n   * Receives the data from popup window and closes the window\r\n   * @param successExtraFn - Extra function to be called after the data is received\r\n   * @returns The data to be received\r\n   */\r\n\r\n\r\n  handle(successExtraFn) {\r\n    return new Promise((resolve, reject) => {\r\n      const closeListener = () => {\r\n        this.bc.close();\r\n        reject(new UserError(\"user closed popup\"));\r\n        this.removeListener(\"close\", closeListener);\r\n      };\r\n\r\n      this.on(\"close\", closeListener);\r\n      this.bc.addEventListener(\"message\", async ev => {\r\n        loglevel__WEBPACK_IMPORTED_MODULE_6___default().info(ev, \"receiving data on channel: \".concat(this.bc.name));\r\n\r\n        try {\r\n          const {\r\n            error,\r\n            data\r\n          } = ev;\r\n\r\n          if (error) {\r\n            reject(new Error(error));\r\n            return;\r\n          }\r\n\r\n          if (successExtraFn) await successExtraFn.call(this, data);\r\n          resolve(data);\r\n        } catch (error) {\r\n          reject(error);\r\n        } finally {\r\n          this.bc.close();\r\n          this.close();\r\n        }\r\n      });\r\n      this.open().then(() => {\r\n        loglevel__WEBPACK_IMPORTED_MODULE_6___default().info(\"opened window \".concat(this.bc.name)); // Opened window. yay.  let the bc events do their job\r\n\r\n        return undefined;\r\n      }).catch(err => {\r\n        loglevel__WEBPACK_IMPORTED_MODULE_6___default().error(err, \"something went wrong while opening window\");\r\n        reject(err);\r\n      });\r\n    });\r\n  }\r\n  /**\r\n   * Use this if we have to send large payloads which don't fit in query/hash params.\r\n   * Waits for ack that popup window is ready to receive data.\r\n   * Receives the data from popup window and closes the window\r\n   * @param payload - The data to be sent to the popup window once we have ack that window is ready to receive data\r\n   * @param successExtraFn - Extra function to be called after the data is received\r\n   * @returns The data to be received\r\n   */\r\n\r\n\r\n  handleWithHandshake(payload, successExtraFn) {\r\n    return new Promise((resolve, reject) => {\r\n      const closeListener = () => {\r\n        this.bc.close();\r\n        reject(new UserError(\"user closed popup\"));\r\n        this.removeListener(\"close\", closeListener);\r\n      };\r\n\r\n      this.on(\"close\", closeListener);\r\n      this.bc.addEventListener(\"message\", async ev => {\r\n        try {\r\n          loglevel__WEBPACK_IMPORTED_MODULE_6___default().info(ev, \"receiving data on channel: \".concat(this.bc.name));\r\n          const {\r\n            error,\r\n            data\r\n          } = ev;\r\n\r\n          if (error) {\r\n            reject(new Error(error));\r\n            return;\r\n          } // Do handshake\r\n\r\n\r\n          const {\r\n            type = \"\"\r\n          } = data;\r\n\r\n          if (type === POPUP_LOADED) {\r\n            // Hack with generic to use the same type for both send and receive\r\n            await this.bc.postMessage({\r\n              data: payload\r\n            });\r\n          } else if (type === POPUP_RESULT) {\r\n            if (successExtraFn) await successExtraFn.call(this, data);\r\n            resolve(data); // Must only close the bc after result is done\r\n\r\n            this.bc.close();\r\n            this.close();\r\n          }\r\n        } catch (error) {\r\n          reject(error);\r\n          this.bc.close();\r\n          this.close();\r\n        }\r\n      });\r\n      this.open().then(() => {\r\n        loglevel__WEBPACK_IMPORTED_MODULE_6___default().info(\"opened window \".concat(this.bc.name)); // Opened window. yay.  let the bc events do their job\r\n\r\n        return undefined;\r\n      }).catch(err => {\r\n        loglevel__WEBPACK_IMPORTED_MODULE_6___default().error(err, \"something went wrong while opening window\");\r\n        reject(err);\r\n      });\r\n    });\r\n  }\r\n\r\n}\r\n\r\nclass RedirectHandler {\r\n  constructor() {\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"error\", void 0);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"finalQueryParams\", {});\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"instanceParameters\", void 0);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"hashParameters\", void 0);\r\n\r\n    const {\r\n      hash\r\n    } = window.location;\r\n    const queryParameters = new URLSearchParams(window.location.search);\r\n    queryParameters.forEach((value, key) => {\r\n      this.finalQueryParams[key] = value;\r\n    });\r\n    const {\r\n      error,\r\n      instanceParameters,\r\n      hashParameters\r\n    } = handleRedirectParameters(hash, this.finalQueryParams);\r\n    this.error = error;\r\n    this.instanceParameters = instanceParameters;\r\n    this.hashParameters = hashParameters;\r\n  }\r\n\r\n  async handle() {\r\n    return new Promise((resolve, reject) => {\r\n      const {\r\n        finalQueryParams,\r\n        instanceParameters,\r\n        hashParameters,\r\n        error\r\n      } = this;\r\n      let bc;\r\n\r\n      try {\r\n        if (!finalQueryParams.windowId) {\r\n          bc = new broadcast_channel__WEBPACK_IMPORTED_MODULE_10__.BroadcastChannel(\"\".concat(BROADCAST_CHANNELS.REDIRECT_CHANNEL, \"_\").concat(instanceParameters.instanceId), broadcastChannelOptions);\r\n          bc.addEventListener(\"message\", async ev => {\r\n            if (ev.error) {\r\n              reject(ev.error);\r\n              window.close();\r\n            } else {\r\n              resolve();\r\n              bc.close();\r\n              loglevel__WEBPACK_IMPORTED_MODULE_6___default().info(\"posted\", {\r\n                finalQueryParams,\r\n                hashParameters,\r\n                instanceParameters\r\n              });\r\n            }\r\n          });\r\n          bc.postMessage({\r\n            data: {\r\n              instanceParams: instanceParameters,\r\n              hashParams: hashParameters,\r\n              queryParams: finalQueryParams\r\n            },\r\n            error\r\n          });\r\n          setTimeout(() => {\r\n            resolve();\r\n            window.location.href = window.location.origin + window.location.search + window.location.hash;\r\n          }, 5000);\r\n        } else {\r\n          bc = new broadcast_channel__WEBPACK_IMPORTED_MODULE_10__.BroadcastChannel(\"\".concat(finalQueryParams.windowId), broadcastChannelOptions);\r\n          bc.addEventListener(\"message\", async ev => {\r\n            const {\r\n              url,\r\n              message\r\n            } = ev.data;\r\n\r\n            if (url) {\r\n              resolve();\r\n              window.location.href = url;\r\n            } else if (message === SETUP_COMPLETE) {\r\n              await bc.postMessage({\r\n                data: {\r\n                  windowId: finalQueryParams.windowId,\r\n                  message: POPUP_LOADED\r\n                }\r\n              });\r\n            }\r\n\r\n            if (ev.error && ev.error !== \"\") {\r\n              loglevel__WEBPACK_IMPORTED_MODULE_6___default().error(ev.error);\r\n              resolve();\r\n              bc.close();\r\n            }\r\n          });\r\n        }\r\n      } catch (err) {\r\n        loglevel__WEBPACK_IMPORTED_MODULE_6___default().info(err, \"something went wrong\");\r\n        reject(err);\r\n        if (bc) bc.close();\r\n        window.close();\r\n      }\r\n    });\r\n  }\r\n\r\n}\r\n\r\nconst ACTIVITY_ACTION = {\r\n  ACTIVITY_ACTION_ALL: \"walletActivity.allTransactions\",\r\n  ACTIVITY_ACTION_SEND: \"walletActivity.send\",\r\n  ACTIVITY_ACTION_RECEIVE: \"walletActivity.receive\",\r\n  ACTIVITY_ACTION_TOPUP: \"walletActivity.topup\"\r\n};\r\nconst ACCOUNT_CATEGORY = {\r\n  NORMAL: \"normal\",\r\n  THRESHOLD: \"threshold\",\r\n  IMPORTED: \"imported\"\r\n};\r\n\r\nfunction ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\r\n\r\nfunction _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\r\n\r\nconst DEFAULT_INTERVAL = 180 * 1000;\r\nconst DEFAULT_PREFERENCES = {\r\n  selectedCurrency: \"USD\",\r\n  theme: \"dark\",\r\n  locale: \"en-US\",\r\n  accountType: ACCOUNT_CATEGORY.NORMAL,\r\n  contacts: [],\r\n  jwtToken: \"\",\r\n  fetchedPastTx: [],\r\n  pastTransactions: [],\r\n  paymentTx: [],\r\n  defaultPublicAddress: \"\",\r\n  customTokens: [],\r\n  customNfts: [],\r\n  crashReport: true,\r\n  userInfo: {\r\n    aggregateVerifier: \"\",\r\n    email: \"\",\r\n    name: \"\",\r\n    profileImage: \"\",\r\n    typeOfLogin: LOGIN_PROVIDER.GOOGLE,\r\n    verifier: \"\",\r\n    verifierId: \"\"\r\n  }\r\n};\r\n/**\r\n * Controller that stores shared settings and exposes convenience methods\r\n */\r\n\r\nclass BasePreferencesController extends BaseController {\r\n  /**\r\n   * Name of this controller used during composition\r\n   */\r\n\r\n  /**\r\n   * Creates a PreferencesController instance\r\n   *\r\n   * @param config - Initial options used to configure this controller\r\n   * @param state - Initial state to set on this controller\r\n   */\r\n  constructor(_ref) {\r\n    let {\r\n      config,\r\n      state,\r\n      defaultPreferences,\r\n      signAuthMessage\r\n    } = _ref;\r\n    super({\r\n      config,\r\n      state\r\n    });\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"name\", \"PreferencesController\");\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"iframeOrigin\", void 0);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"signAuthMessage\", void 0);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"defaultPreferences\", void 0);\r\n\r\n    if (!config.api) {\r\n      throw new Error(\"PreferencesController - no api specified in config.\");\r\n    }\r\n\r\n    this.defaultState = {\r\n      identities: {},\r\n      selectedAddress: \"\",\r\n      lastErrorMessage: \"\",\r\n      lastSuccessMessage: \"\"\r\n    };\r\n    this.defaultConfig = {\r\n      api: config.api,\r\n      pollInterval: DEFAULT_INTERVAL\r\n    };\r\n    this.initialize();\r\n    this.defaultPreferences = _objectSpread$1(_objectSpread$1({}, DEFAULT_PREFERENCES), defaultPreferences);\r\n    this.signAuthMessage = signAuthMessage;\r\n  }\r\n\r\n  setIframeOrigin(origin) {\r\n    this.iframeOrigin = origin;\r\n  }\r\n\r\n  getAddressState(address) {\r\n    const selectedAddress = address || this.state.selectedAddress;\r\n    return this.state.identities[selectedAddress];\r\n  }\r\n  /**\r\n   * Sets selected address\r\n   *\r\n   * @param selectedAddress - casper account hash\r\n   */\r\n\r\n\r\n  setSelectedAddress(selectedAddress) {\r\n    this.update({\r\n      selectedAddress\r\n    });\r\n  }\r\n\r\n  async getUser(address) {\r\n    const user = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_7__.get)(\"\".concat(this.config.api, \"/user?fetchTx=false\"), this.headers(address), {\r\n      useAPIKey: true\r\n    });\r\n    return user.data;\r\n  }\r\n\r\n  async createUser(params) {\r\n    const {\r\n      selectedCurrency,\r\n      theme,\r\n      verifier,\r\n      verifierId,\r\n      locale,\r\n      address\r\n    } = params;\r\n    const userPayload = {\r\n      default_currency: selectedCurrency,\r\n      theme,\r\n      verifier,\r\n      verifier_id: verifierId,\r\n      locale\r\n    };\r\n    await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_7__.post)(\"\".concat(this.config.api, \"/user\"), userPayload, this.headers(address), {\r\n      useAPIKey: true\r\n    });\r\n    this.updateState({\r\n      theme,\r\n      defaultPublicAddress: address,\r\n      selectedCurrency,\r\n      locale\r\n    }, address);\r\n  }\r\n\r\n  async storeUserLogin(params) {\r\n    const {\r\n      verifierId,\r\n      verifier,\r\n      options,\r\n      address\r\n    } = params;\r\n\r\n    if (!options.rehydrate) {\r\n      const browser = bowser__WEBPACK_IMPORTED_MODULE_8___default().getParser(window.navigator.userAgent);\r\n      const specialBrowser = getCustomDeviceInfo();\r\n      const recordLoginPayload = {\r\n        os: browser.getOSName(),\r\n        os_version: browser.getOSVersion() || \"unidentified\",\r\n        browser: (specialBrowser === null || specialBrowser === void 0 ? void 0 : specialBrowser.browser) || browser.getBrowserName() || \"unidentified\",\r\n        browser_version: browser.getBrowserVersion() || \"unidentified\",\r\n        platform: browser.getPlatform().type || \"desktop\",\r\n        hostname: this.iframeOrigin,\r\n        verifier,\r\n        verifier_id: verifierId\r\n      };\r\n      await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_7__.post)(\"\".concat(this.config.api, \"/user/recordLogin\"), recordLoginPayload, this.headers(address), {\r\n        useAPIKey: true\r\n      });\r\n    }\r\n  }\r\n\r\n  async setCrashReport(isEnabled) {\r\n    var _this$getAddressState;\r\n\r\n    if (isEnabled === ((_this$getAddressState = this.getAddressState()) === null || _this$getAddressState === void 0 ? void 0 : _this$getAddressState.crashReport)) return true;\r\n\r\n    try {\r\n      await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_7__.patch)(\"\".concat(this.config.api, \"/user\"), {\r\n        enable_crash_reporter: isEnabled\r\n      }, this.headers(), {\r\n        useAPIKey: true\r\n      });\r\n      this.updateState({\r\n        crashReport: isEnabled\r\n      });\r\n      return true;\r\n    } catch (error) {\r\n      loglevel__WEBPACK_IMPORTED_MODULE_6___default().error(error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async setUserTheme(theme) {\r\n    var _this$getAddressState2;\r\n\r\n    if (theme === ((_this$getAddressState2 = this.getAddressState()) === null || _this$getAddressState2 === void 0 ? void 0 : _this$getAddressState2.theme)) return true;\r\n\r\n    try {\r\n      await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_7__.patch)(\"\".concat(this.config.api, \"/user\"), {\r\n        theme\r\n      }, this.headers(), {\r\n        useAPIKey: true\r\n      });\r\n      this.updateState({\r\n        theme\r\n      });\r\n      return true;\r\n    } catch (error) {\r\n      loglevel__WEBPACK_IMPORTED_MODULE_6___default().error(error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async setUserLocale(locale) {\r\n    var _this$getAddressState3;\r\n\r\n    if (locale === ((_this$getAddressState3 = this.getAddressState()) === null || _this$getAddressState3 === void 0 ? void 0 : _this$getAddressState3.locale)) return;\r\n\r\n    try {\r\n      await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_7__.patch)(\"\".concat(this.config.api, \"/user\"), {\r\n        locale\r\n      }, this.headers(), {\r\n        useAPIKey: true\r\n      });\r\n      this.updateState({\r\n        locale\r\n      });\r\n      return true;\r\n    } catch (error) {\r\n      loglevel__WEBPACK_IMPORTED_MODULE_6___default().error(\"unable to set locale\", error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async setSelectedCurrency(payload) {\r\n    var _this$getAddressState4;\r\n\r\n    if (payload.selectedCurrency === ((_this$getAddressState4 = this.getAddressState()) === null || _this$getAddressState4 === void 0 ? void 0 : _this$getAddressState4.selectedCurrency)) return true;\r\n\r\n    try {\r\n      await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_7__.patch)(\"\".concat(this.config.api, \"/user\"), {\r\n        default_currency: payload.selectedCurrency\r\n      }, this.headers(), {\r\n        useAPIKey: true\r\n      });\r\n      this.updateState({\r\n        selectedCurrency: payload.selectedCurrency\r\n      });\r\n      return true;\r\n    } catch (error) {\r\n      loglevel__WEBPACK_IMPORTED_MODULE_6___default().error(error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async addContact(contact) {\r\n    try {\r\n      var _this$getAddressState5;\r\n\r\n      const response = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_7__.post)(\"\".concat(this.config.api, \"/contact\"), contact, this.headers(), {\r\n        useAPIKey: true\r\n      });\r\n      this.updateState({\r\n        contacts: [...(((_this$getAddressState5 = this.getAddressState()) === null || _this$getAddressState5 === void 0 ? void 0 : _this$getAddressState5.contacts) || []), response.data]\r\n      });\r\n      return true;\r\n    } catch (error) {\r\n      loglevel__WEBPACK_IMPORTED_MODULE_6___default().error(\"unable to add contact\", error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async deleteContact(contactId) {\r\n    try {\r\n      var _this$getAddressState6;\r\n\r\n      const response = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_7__.remove)(\"\".concat(this.config.api, \"/contact/\").concat(contactId), {}, this.headers(), {\r\n        useAPIKey: true\r\n      });\r\n      const finalContacts = (_this$getAddressState6 = this.getAddressState()) === null || _this$getAddressState6 === void 0 ? void 0 : _this$getAddressState6.contacts.filter(contact => contact.id !== response.data.id);\r\n      if (finalContacts) this.updateState({\r\n        contacts: [...finalContacts]\r\n      });\r\n      return true;\r\n    } catch (error) {\r\n      loglevel__WEBPACK_IMPORTED_MODULE_6___default().error(\"unable to delete contact\", error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async revokeDiscord(idToken) {\r\n    try {\r\n      const resp = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_7__.post)(\"\".concat(this.config.api, \"/revoke/discord\"), {\r\n        token: idToken\r\n      }, this.headers(), {\r\n        useAPIKey: true\r\n      });\r\n      loglevel__WEBPACK_IMPORTED_MODULE_6___default().info(resp);\r\n    } catch (error) {\r\n      loglevel__WEBPACK_IMPORTED_MODULE_6___default().error(error);\r\n    }\r\n  }\r\n\r\n  async patchPastTx(body, address) {\r\n    try {\r\n      const response = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_7__.patch)(\"\".concat(this.config.api, \"/transaction\"), body, this.headers(address), {\r\n        useAPIKey: true\r\n      });\r\n      loglevel__WEBPACK_IMPORTED_MODULE_6___default().info(\"successfully patched\", response);\r\n    } catch (error) {\r\n      loglevel__WEBPACK_IMPORTED_MODULE_6___default().error(\"unable to patch tx\", error);\r\n    }\r\n  }\r\n\r\n  async postPastTx(tx, address) {\r\n    try {\r\n      const response = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_7__.post)(\"\".concat(this.config.api, \"/transaction\"), tx, this.headers(address), {\r\n        useAPIKey: true\r\n      });\r\n      loglevel__WEBPACK_IMPORTED_MODULE_6___default().info(\"successfully posted tx\", response);\r\n      return response;\r\n    } catch (error) {\r\n      loglevel__WEBPACK_IMPORTED_MODULE_6___default().error(error, \"unable to insert transaction\");\r\n    }\r\n  }\r\n\r\n  async getWalletOrders(address) {\r\n    try {\r\n      const response = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_7__.get)(\"\".concat(this.config.api, \"/transaction\"), this.headers(address), {\r\n        useAPIKey: true\r\n      });\r\n      return response.success ? response.data ? response.data : [] : [];\r\n    } catch (error) {\r\n      loglevel__WEBPACK_IMPORTED_MODULE_6___default().error(\"unable to get wallet orders tx\", error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  async getTopUpOrders(address) {\r\n    try {\r\n      const response = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_7__.get)(\"\".concat(this.config.commonApiHost, \"/transaction\"), this.headers(address), {\r\n        useAPIKey: true\r\n      });\r\n      return response.data || [];\r\n    } catch (error) {\r\n      loglevel__WEBPACK_IMPORTED_MODULE_6___default().error(\"unable to fetch past Top up orders\", error);\r\n    }\r\n  }\r\n\r\n  async getBillBoardData() {\r\n    try {\r\n      const response = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_7__.get)(\"\".concat(this.config.api, \"/billboard\"), this.headers(), {\r\n        useAPIKey: true\r\n      });\r\n      return response.success ? response.data : [];\r\n    } catch (error) {\r\n      loglevel__WEBPACK_IMPORTED_MODULE_6___default().error(\"unable to get billboard data\", error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  async getMessageForSigning(publicAddress) {\r\n    const response = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_7__.post)(\"\".concat(this.config.api, \"/auth/message\"), {\r\n      public_address: publicAddress\r\n    }, {}, {\r\n      useAPIKey: true\r\n    });\r\n    return response.message;\r\n  }\r\n\r\n  async getTwitterId(payload) {\r\n    const res = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_7__.get)(\"\".concat(this.config.api, \"/twitter?screen_name=\").concat(payload.nick), this.headers(), {\r\n      useAPIKey: true\r\n    });\r\n    return \"\".concat(payload.typeOfLogin.toLowerCase(), \"|\").concat(res.data.toString());\r\n  }\r\n\r\n  async sendEmail(payload) {\r\n    return (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_7__.post)(\"\".concat(this.config.api, \"/transaction/sendemail\"), payload.emailObject, this.headers(), {\r\n      useAPIKey: true\r\n    });\r\n  }\r\n\r\n  async refreshJwt() {\r\n    const address = this.state.selectedAddress;\r\n    const messageToSign = await this.getMessageForSigning(address);\r\n    if (!messageToSign.startsWith(this.config.signInPrefix)) throw new Error(\"Cannot sign on invalid message\");\r\n    const signedMessage = this.signAuthMessage(address, messageToSign);\r\n    const response = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_7__.post)(\"\".concat(this.config.api, \"/auth/verify\"), {\r\n      public_address: address,\r\n      signed_message: signedMessage\r\n    }, {}, {\r\n      useAPIKey: true\r\n    });\r\n    this.updateState({\r\n      jwtToken: response.token\r\n    }, address);\r\n  }\r\n\r\n  async getDappList() {\r\n    try {\r\n      const response = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_7__.get)(\"\".concat(this.config.api, \"/dapps\"), this.headers(), {\r\n        useAPIKey: true\r\n      });\r\n      return response.success ? response.data : [];\r\n    } catch (error) {\r\n      loglevel__WEBPACK_IMPORTED_MODULE_6___default().error(\"unable to get billboard data\", error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  async init(address, userInfo, jwtToken) {\r\n    let response = {\r\n      token: jwtToken\r\n    };\r\n    if (this.getAddressState(address)) return;\r\n\r\n    if (!jwtToken) {\r\n      const messageToSign = await this.getMessageForSigning(address);\r\n      if (!messageToSign.startsWith(this.config.signInPrefix)) throw new Error(\"Cannot sign on invalid message\");\r\n      const signedMessage = this.signAuthMessage(address, messageToSign);\r\n      response = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_7__.post)(\"\".concat(this.config.api, \"/auth/verify\"), {\r\n        public_address: address,\r\n        signed_message: signedMessage\r\n      }, {}, {\r\n        useAPIKey: true\r\n      });\r\n    }\r\n\r\n    this.updateState({\r\n      jwtToken: response.token,\r\n      userInfo\r\n    }, address);\r\n  }\r\n\r\n  updateState(preferences, address) {\r\n    const selectedAddress = address || this.state.selectedAddress;\r\n    const currentState = this.getAddressState(selectedAddress) || (0,lodash__WEBPACK_IMPORTED_MODULE_9__.cloneDeep)(this.defaultPreferences);\r\n\r\n    const mergedState = _objectSpread$1(_objectSpread$1({}, currentState), preferences);\r\n\r\n    this.update({\r\n      identities: _objectSpread$1(_objectSpread$1({}, this.state.identities), {}, {\r\n        [selectedAddress]: mergedState\r\n      })\r\n    });\r\n    return mergedState;\r\n  }\r\n\r\n  headers(address) {\r\n    var _this$getAddressState7;\r\n\r\n    const selectedAddress = address || this.state.selectedAddress;\r\n    return {\r\n      headers: {\r\n        Authorization: \"Bearer \".concat(((_this$getAddressState7 = this.getAddressState(selectedAddress)) === null || _this$getAddressState7 === void 0 ? void 0 : _this$getAddressState7.jwtToken) || \"\"),\r\n        \"Content-Type\": \"application/json; charset=utf-8\"\r\n      }\r\n    };\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * The status of the transaction. Each status represents the state of the transaction internally\r\n * in the wallet. Some of these correspond with the state of the transaction on the network, but\r\n * some are wallet-specific.\r\n */\r\nvar TransactionStatus;\r\n\r\n(function (TransactionStatus) {\r\n  TransactionStatus[\"approved\"] = \"approved\";\r\n  TransactionStatus[\"cancelled\"] = \"cancelled\";\r\n  TransactionStatus[\"confirmed\"] = \"confirmed\";\r\n  TransactionStatus[\"failed\"] = \"failed\";\r\n  TransactionStatus[\"finalized\"] = \"finalized\";\r\n  TransactionStatus[\"processed\"] = \"processed\";\r\n  TransactionStatus[\"rejected\"] = \"rejected\";\r\n  TransactionStatus[\"signed\"] = \"signed\";\r\n  TransactionStatus[\"submitted\"] = \"submitted\";\r\n  TransactionStatus[\"unapproved\"] = \"unapproved\";\r\n  TransactionStatus[\"dropped\"] = \"dropped\";\r\n  TransactionStatus[\"expired\"] = \"expired\";\r\n})(TransactionStatus || (TransactionStatus = {}));\r\n\r\nconst TRANSACTION_TYPES = {\r\n  CONTRACT_INTERACTION: \"contractInteraction\",\r\n  DEPLOY_CONTRACT: \"contractDeployment\",\r\n  STANDARD_TRANSACTION: \"transaction\",\r\n  STANDARD_PAYMENT_TRANSACTION: \"payment_transaction\" // specific to chains like solana and casper\r\n\r\n};\r\nconst TX_EVENTS = {\r\n  TX_WARNING: \"tx:warning\",\r\n  TX_ERROR: \"tx:error\",\r\n  TX_FAILED: \"tx:failed\",\r\n  TX_CONFIRMED: \"tx:confirmed\",\r\n  TX_DROPPED: \"tx:dropped\",\r\n  TX_EXPIRED: \"tx:expired\",\r\n  TX_STATUS_UPDATE: \"tx:status_update\",\r\n  TX_UNAPPROVED: \"tx:unapproved\"\r\n};\r\n\r\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\r\n\r\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\r\nclass BaseTransactionStateManager extends BaseController {\r\n  constructor(_ref) {\r\n    let {\r\n      config,\r\n      state,\r\n      getCurrentChainId\r\n    } = _ref;\r\n    super({\r\n      config,\r\n      state\r\n    });\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"getCurrentChainId\", void 0);\r\n\r\n    this.defaultConfig = {\r\n      txHistoryLimit: 40\r\n    };\r\n    this.defaultState = {\r\n      transactions: {},\r\n      unapprovedTxs: {},\r\n      currentNetworkTxsList: []\r\n    };\r\n    this.initialize();\r\n    this.getCurrentChainId = getCurrentChainId;\r\n  }\r\n\r\n  getUnapprovedTxList() {\r\n    const chainId = this.getCurrentChainId();\r\n    return (0,lodash__WEBPACK_IMPORTED_MODULE_9__.pickBy)(this.state.transactions, transaction => transaction.status === TransactionStatus.unapproved && transactionMatchesNetwork(transaction, chainId));\r\n  }\r\n\r\n  getTransaction(txId) {\r\n    const {\r\n      transactions\r\n    } = this.state;\r\n    return transactions[txId];\r\n  }\r\n\r\n  updateTransaction(txMeta) {\r\n    // commit txMeta to state\r\n    const txId = txMeta.id;\r\n    txMeta.updated_at = new Date().toISOString();\r\n    this.update({\r\n      transactions: _objectSpread(_objectSpread({}, this.state.transactions), {}, {\r\n        [txId]: txMeta\r\n      })\r\n    });\r\n  }\r\n\r\n  setTxStatusRejected(txId) {\r\n    this._setTransactionStatus(txId, TransactionStatus.rejected);\r\n\r\n    this._deleteTransaction(txId);\r\n  }\r\n  /**\r\n   * The implementing controller can override this functionality and add custom logic + call super.()\r\n   */\r\n\r\n\r\n  setTxStatusUnapproved(txId) {\r\n    this._setTransactionStatus(txId, TransactionStatus.unapproved);\r\n  }\r\n\r\n  setTxStatusApproved(txId) {\r\n    this._setTransactionStatus(txId, TransactionStatus.approved);\r\n  }\r\n\r\n  setTxStatusSigned(txId) {\r\n    this._setTransactionStatus(txId, TransactionStatus.signed);\r\n  }\r\n\r\n  setTxStatusSubmitted(txId) {\r\n    this._setTransactionStatus(txId, TransactionStatus.submitted);\r\n  }\r\n\r\n  setTxStatusDropped(txId) {\r\n    this._setTransactionStatus(txId, TransactionStatus.dropped);\r\n  }\r\n\r\n  setTxStatusExpired(txId) {\r\n    this._setTransactionStatus(txId, TransactionStatus.expired);\r\n  }\r\n\r\n  setTxStatusConfirmed(txId) {\r\n    this._setTransactionStatus(txId, TransactionStatus.confirmed);\r\n  }\r\n\r\n  setTxStatusFailed(txId, error_) {\r\n    const error = !error_ ? new Error(\"Internal torus failure\") : error_;\r\n    const txMeta = this.getTransaction(txId);\r\n    txMeta.error = error;\r\n    this.updateTransaction(txMeta);\r\n\r\n    this._setTransactionStatus(txId, TransactionStatus.failed);\r\n  }\r\n  /**\r\n   * Method to determine if the transaction is in a final state\r\n   * @param status - Transaction status\r\n   * @returns boolean if the transaction is in a final state\r\n   */\r\n\r\n\r\n  isFinalState(status) {\r\n    return status === TransactionStatus.rejected || status === TransactionStatus.submitted || status === TransactionStatus.confirmed || status === TransactionStatus.failed || status === TransactionStatus.cancelled || status === TransactionStatus.expired;\r\n  }\r\n  /**\r\n   * Filters out the unapproved transactions from state\r\n   */\r\n\r\n\r\n  clearUnapprovedTxs() {\r\n    this.update({\r\n      transactions: (0,lodash__WEBPACK_IMPORTED_MODULE_9__.omitBy)(this.state.transactions, transaction => transaction.status === TransactionStatus.unapproved)\r\n    });\r\n  }\r\n  /**\r\n   * will append new transactions to old txns.\r\n   */\r\n\r\n\r\n  _addTransactionsToState(transactions) {\r\n    this.update({\r\n      transactions: transactions.reduce((result, newTx) => {\r\n        result[newTx.id] = newTx;\r\n        return result;\r\n      }, this.state.transactions)\r\n    });\r\n  }\r\n  /**\r\n   * will set new txns, override existing if any in state.\r\n   */\r\n\r\n\r\n  _setTransactionsToState(transactions) {\r\n    this.update({\r\n      transactions: transactions.reduce((result, newTx) => {\r\n        result[newTx.id] = newTx;\r\n        return result;\r\n      }, {})\r\n    });\r\n  }\r\n\r\n  _deleteTransaction(targetTransactionId) {\r\n    const {\r\n      transactions\r\n    } = this.state;\r\n    delete transactions[targetTransactionId];\r\n    this.update({\r\n      transactions\r\n    });\r\n  }\r\n\r\n  _deleteTransactions(targetTransactionIds) {\r\n    const {\r\n      transactions\r\n    } = this.state;\r\n    targetTransactionIds.forEach(transactionId => {\r\n      delete transactions[transactionId];\r\n    });\r\n    this.update({\r\n      transactions\r\n    });\r\n  }\r\n\r\n  _setTransactionStatus(txId, status) {\r\n    const txMeta = this.getTransaction(txId);\r\n\r\n    if (!txMeta) {\r\n      return;\r\n    }\r\n\r\n    txMeta.status = status; // only updating status so no validation required on txn.\r\n\r\n    this.updateTransaction(txMeta);\r\n    this.emit(TX_EVENTS.TX_STATUS_UPDATE, {\r\n      txId,\r\n      status\r\n    });\r\n\r\n    if (this.isFinalState(status)) {\r\n      this.emit(\"\".concat(txMeta.id, \":finished\"), txMeta);\r\n    } else {\r\n      this.emit(\"\".concat(txMeta.id, \":\").concat(status), txId);\r\n    }\r\n  }\r\n\r\n}\r\n\r\n\r\n//# sourceMappingURL=baseControllers.esm.js.map\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9iYXNlLWNvbnRyb2xsZXJzL2Rpc3QvYmFzZUNvbnRyb2xsZXJzLmVzbS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0U7QUFDdUU7QUFDeEY7QUFDVjtBQUNxRztBQUNuRztBQUNoQjtBQUMwQjtBQUNjO0FBQ3ZDO0FBQ3VCO0FBQ25EO0FBQ0EsNkNBQTZDLGdDQUFnQyxvQ0FBb0Msb0RBQW9ELDZEQUE2RCxpRUFBaUUsc0NBQXNDO0FBQ3pVO0FBQ0EsbUNBQW1DLGdCQUFnQixzQkFBc0IsT0FBTyx1REFBdUQsK0RBQStELGlGQUFlLDZCQUE2QixzS0FBc0ssbUZBQW1GLEtBQUs7QUFDaGY7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsdUVBQWdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsTUFBTTtBQUNOLGFBQWE7QUFDYjtBQUNBLElBQUksaUZBQWUsMEJBQTBCO0FBQzdDO0FBQ0EsSUFBSSxpRkFBZSx5QkFBeUI7QUFDNUM7QUFDQSxJQUFJLGlGQUFlO0FBQ25CO0FBQ0EsSUFBSSxpRkFBZTtBQUNuQjtBQUNBLElBQUksaUZBQWU7QUFDbkI7QUFDQSxJQUFJLGlGQUFlO0FBQ25CO0FBQ0EsSUFBSSxpRkFBZTtBQUNuQjtBQUNBLElBQUksaUZBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELDZDQUE2QztBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEtBQUssR0FBRztBQUNSO0FBQ0EsSUFBSSxpRkFBZTtBQUNuQjtBQUNBLElBQUksaUZBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSxtR0FBbUc7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssR0FBRztBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsOENBQU07QUFDMUIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLElBQUk7QUFDWCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM0dEQ7QUFDNXREIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AdG9ydXNsYWJzL2Jhc2UtY29udHJvbGxlcnMvZGlzdC9iYXNlQ29udHJvbGxlcnMuZXNtLmpzP2Q5NGIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5JztcclxuaW1wb3J0IHsgU2FmZUV2ZW50RW1pdHRlciwgSlJQQ0VuZ2luZSwgY3JlYXRlQXN5bmNNaWRkbGV3YXJlLCBtZXJnZU1pZGRsZXdhcmUsIGNyZWF0ZVNjYWZmb2xkTWlkZGxld2FyZSB9IGZyb20gJ0B0b3J1c2xhYnMvb3BlbmxvZ2luLWpycGMnO1xyXG5pbXBvcnQgZ2V0Q3JlYXRlUmFuZG9tSWQgZnJvbSAnanNvbi1ycGMtcmFuZG9tLWlkJztcclxuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSAnYmlnbnVtYmVyLmpzJztcclxuaW1wb3J0IHsgZnJvbVNpZ25lZCwgYnVmZmVyVG9JbnQsIHRvVW5zaWduZWQsIHN0cmlwSGV4UHJlZml4LCBhZGRIZXhQcmVmaXgsIGhhc2hQZXJzb25hbE1lc3NhZ2UsIGVjc2lnbiwgaW50VG9CdWZmZXIgfSBmcm9tICdldGhlcmV1bWpzLXV0aWwnO1xyXG5pbXBvcnQgeyBldGhFcnJvcnMgfSBmcm9tICdldGgtcnBjLWVycm9ycyc7XHJcbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xyXG5pbXBvcnQgeyBCcm9hZGNhc3RDaGFubmVsIH0gZnJvbSAnYnJvYWRjYXN0LWNoYW5uZWwnO1xyXG5pbXBvcnQgeyBnZXQsIHBvc3QsIHBhdGNoLCByZW1vdmUgfSBmcm9tICdAdG9ydXNsYWJzL2h0dHAtaGVscGVycyc7XHJcbmltcG9ydCBib3dzZXIgZnJvbSAnYm93c2VyJztcclxuaW1wb3J0IHsgY2xvbmVEZWVwLCBwaWNrQnksIG9taXRCeSB9IGZyb20gJ2xvZGFzaCc7XHJcblxyXG5mdW5jdGlvbiBvd25LZXlzJDMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XHJcblxyXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDModGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpICUgMiA/IG93bktleXMkMyhPYmplY3Qoc291cmNlKSwgITApLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSkgOiBvd25LZXlzJDMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gcmV0dXJuIHRhcmdldDsgfVxyXG4vKipcclxuICogQ29udHJvbGxlciBjbGFzcyB0aGF0IHByb3ZpZGVzIGNvbmZpZ3VyYXRpb24sIHN0YXRlIG1hbmFnZW1lbnQsIGFuZCBzdWJzY3JpcHRpb25zXHJcbiAqL1xyXG5cclxuY2xhc3MgQmFzZUNvbnRyb2xsZXIgZXh0ZW5kcyBTYWZlRXZlbnRFbWl0dGVyIHtcclxuICAvKipcclxuICAgKiBEZWZhdWx0IG9wdGlvbnMgdXNlZCB0byBjb25maWd1cmUgdGhpcyBjb250cm9sbGVyXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIERlZmF1bHQgc3RhdGUgc2V0IG9uIHRoaXMgY29udHJvbGxlclxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBEZXRlcm1pbmVzIGlmIGxpc3RlbmVycyBhcmUgbm90aWZpZWQgb2Ygc3RhdGUgY2hhbmdlc1xyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBOYW1lIG9mIHRoaXMgY29udHJvbGxlciB1c2VkIGR1cmluZyBjb21wb3NpdGlvblxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgQmFzZUNvbnRyb2xsZXIgaW5zdGFuY2UuIEJvdGggaW5pdGlhbCBzdGF0ZSBhbmQgaW5pdGlhbFxyXG4gICAqIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBhcmUgbWVyZ2VkIHdpdGggZGVmYXVsdHMgdXBvbiBpbml0aWFsaXphdGlvbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBjb25maWcgLSBJbml0aWFsIG9wdGlvbnMgdXNlZCB0byBjb25maWd1cmUgdGhpcyBjb250cm9sbGVyXHJcbiAgICogQHBhcmFtIHN0YXRlIC0gSW5pdGlhbCBzdGF0ZSB0byBzZXQgb24gdGhpcyBjb250cm9sbGVyXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoX3JlZikge1xyXG4gICAgbGV0IHtcclxuICAgICAgY29uZmlnID0ge30sXHJcbiAgICAgIHN0YXRlID0ge31cclxuICAgIH0gPSBfcmVmO1xyXG4gICAgc3VwZXIoKTsgLy8gVXNlIGFzc2lnbiBzaW5jZSBnZW5lcmljcyBjYW4ndCBiZSBzcHJlYWQ6IGh0dHBzOi8vZ2l0LmlvL3ZwUmhZXHJcblxyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZGVmYXVsdENvbmZpZ1wiLCB7fSk7XHJcblxyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZGVmYXVsdFN0YXRlXCIsIHt9KTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJkaXNhYmxlZFwiLCBmYWxzZSk7XHJcblxyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCBcIkJhc2VDb250cm9sbGVyXCIpO1xyXG5cclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluaXRpYWxDb25maWdcIiwgdm9pZCAwKTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbml0aWFsU3RhdGVcIiwgdm9pZCAwKTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbnRlcm5hbENvbmZpZ1wiLCB0aGlzLmRlZmF1bHRDb25maWcpO1xyXG5cclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImludGVybmFsU3RhdGVcIiwgdGhpcy5kZWZhdWx0U3RhdGUpO1xyXG5cclxuICAgIHRoaXMuaW5pdGlhbFN0YXRlID0gc3RhdGU7XHJcbiAgICB0aGlzLmluaXRpYWxDb25maWcgPSBjb25maWc7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFJldHJpZXZlcyBjdXJyZW50IGNvbnRyb2xsZXIgY29uZmlndXJhdGlvbiBvcHRpb25zXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyAtIEN1cnJlbnQgY29uZmlndXJhdGlvblxyXG4gICAqL1xyXG5cclxuXHJcbiAgZ2V0IGNvbmZpZygpIHtcclxuICAgIHJldHVybiB0aGlzLmludGVybmFsQ29uZmlnO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBSZXRyaWV2ZXMgY3VycmVudCBjb250cm9sbGVyIHN0YXRlXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyAtIEN1cnJlbnQgc3RhdGVcclxuICAgKi9cclxuXHJcblxyXG4gIGdldCBzdGF0ZSgpIHtcclxuICAgIHJldHVybiB0aGlzLmludGVybmFsU3RhdGU7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZXMgY29udHJvbGxlciBjb25maWd1cmF0aW9uXHJcbiAgICpcclxuICAgKiBAcGFyYW0gY29uZmlnIC0gTmV3IGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xyXG4gICAqIEBwYXJhbSBvdmVyd3JpdGUgLSBPdmVyd3JpdGUgY29uZmlnIGluc3RlYWQgb2YgbWVyZ2luZ1xyXG4gICAqIEBwYXJhbSBmdWxsVXBkYXRlIC0gQm9vbGVhbiB0aGF0IGRlZmluZXMgaWYgdGhlIHVwZGF0ZSBpcyBwYXJ0aWFsIG9yIG5vdFxyXG4gICAqL1xyXG5cclxuXHJcbiAgY29uZmlndXJlKGNvbmZpZykge1xyXG4gICAgbGV0IG92ZXJ3cml0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XHJcbiAgICBsZXQgZnVsbFVwZGF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcclxuXHJcbiAgICBpZiAoZnVsbFVwZGF0ZSkge1xyXG4gICAgICB0aGlzLmludGVybmFsQ29uZmlnID0gb3ZlcndyaXRlID8gY29uZmlnIDogT2JqZWN0LmFzc2lnbih0aGlzLmludGVybmFsQ29uZmlnLCBjb25maWcpO1xyXG5cclxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5pbnRlcm5hbENvbmZpZykge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5pbnRlcm5hbENvbmZpZ1trZXldICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICB0aGlzW2tleV0gPSB0aGlzLmludGVybmFsQ29uZmlnW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBjb25maWcpIHtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5pbnRlcm5hbENvbmZpZ1trZXldICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICB0aGlzLmludGVybmFsQ29uZmlnW2tleV0gPSBjb25maWdba2V5XTtcclxuICAgICAgICAgIHRoaXNba2V5XSA9IGNvbmZpZ1trZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICAvKipcclxuICAgKiBVcGRhdGVzIGNvbnRyb2xsZXIgc3RhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSBzdGF0ZSAtIE5ldyBzdGF0ZVxyXG4gICAqIEBwYXJhbSBvdmVyd3JpdGUgLSBPdmVyd3JpdGUgc3RhdGUgaW5zdGVhZCBvZiBtZXJnaW5nXHJcbiAgICovXHJcblxyXG5cclxuICB1cGRhdGUoc3RhdGUpIHtcclxuICAgIGxldCBvdmVyd3JpdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xyXG4gICAgdGhpcy5pbnRlcm5hbFN0YXRlID0gb3ZlcndyaXRlID8gX29iamVjdFNwcmVhZCQzKHt9LCBzdGF0ZSkgOiBfb2JqZWN0U3ByZWFkJDMoX29iamVjdFNwcmVhZCQzKHt9LCB0aGlzLmludGVybmFsU3RhdGUpLCBzdGF0ZSk7XHJcbiAgICB0aGlzLmVtaXQoXCJzdG9yZVwiLCB0aGlzLmludGVybmFsU3RhdGUpO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBFbmFibGVzIHRoZSBjb250cm9sbGVyLiBUaGlzIHNldHMgZWFjaCBjb25maWcgb3B0aW9uIGFzIGEgbWVtYmVyXHJcbiAgICogdmFyaWFibGUgb24gdGhpcyBpbnN0YW5jZSBhbmQgdHJpZ2dlcnMgYW55IGRlZmluZWQgc2V0dGVycy4gVGhpc1xyXG4gICAqIGFsc28gc2V0cyBpbml0aWFsIHN0YXRlIGFuZCB0cmlnZ2VycyBhbnkgbGlzdGVuZXJzLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMgLSBUaGlzIGNvbnRyb2xsZXIgaW5zdGFuY2VcclxuICAgKi9cclxuXHJcblxyXG4gIGluaXRpYWxpemUoKSB7XHJcbiAgICB0aGlzLmludGVybmFsU3RhdGUgPSB0aGlzLmRlZmF1bHRTdGF0ZTtcclxuICAgIHRoaXMuaW50ZXJuYWxDb25maWcgPSB0aGlzLmRlZmF1bHRDb25maWc7XHJcbiAgICB0aGlzLmNvbmZpZ3VyZSh0aGlzLmluaXRpYWxDb25maWcpO1xyXG4gICAgdGhpcy51cGRhdGUodGhpcy5pbml0aWFsU3RhdGUpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxufVxyXG5cclxuY29uc3Qgc2VjID0gMTAwMDtcclxuXHJcbmNvbnN0IGNhbGN1bGF0ZVN1bSA9IChhY2N1bXVsYXRvciwgY3VycmVudFZhbHVlKSA9PiBhY2N1bXVsYXRvciArIGN1cnJlbnRWYWx1ZTtcclxuXHJcbmNvbnN0IGJsb2NrVHJhY2tlckV2ZW50cyA9IFtcInN5bmNcIiwgXCJsYXRlc3RcIl07XHJcbmNsYXNzIEJhc2VCbG9ja1RyYWNrZXIgZXh0ZW5kcyBCYXNlQ29udHJvbGxlciB7XHJcbiAgY29uc3RydWN0b3IoX3JlZikge1xyXG4gICAgbGV0IHtcclxuICAgICAgY29uZmlnID0ge30sXHJcbiAgICAgIHN0YXRlID0ge31cclxuICAgIH0gPSBfcmVmO1xyXG4gICAgc3VwZXIoe1xyXG4gICAgICBjb25maWcsXHJcbiAgICAgIHN0YXRlXHJcbiAgICB9KTsgLy8gY29uZmlnXHJcblxyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCBcIkJhc2VCbG9ja1RyYWNrZXJcIik7XHJcblxyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2Jsb2NrUmVzZXRUaW1lb3V0XCIsIHZvaWQgMCk7XHJcblxyXG4gICAgdGhpcy5kZWZhdWx0U3RhdGUgPSB7XHJcbiAgICAgIF9jdXJyZW50QmxvY2s6IHtcclxuICAgICAgICBpZGVtcG90ZW5jeUtleTogXCJcIlxyXG4gICAgICB9LFxyXG4gICAgICBfaXNSdW5uaW5nOiBmYWxzZVxyXG4gICAgfTtcclxuICAgIHRoaXMuZGVmYXVsdENvbmZpZyA9IHtcclxuICAgICAgYmxvY2tSZXNldER1cmF0aW9uOiAyMCAqIHNlY1xyXG4gICAgfTtcclxuICAgIHRoaXMuaW5pdGlhbGl6ZSgpOyAvLyBiaW5kIGZ1bmN0aW9ucyBmb3IgaW50ZXJuYWwgdXNlXHJcblxyXG4gICAgdGhpcy5fb25OZXdMaXN0ZW5lciA9IHRoaXMuX29uTmV3TGlzdGVuZXIuYmluZCh0aGlzKTtcclxuICAgIHRoaXMuX29uUmVtb3ZlTGlzdGVuZXIgPSB0aGlzLl9vblJlbW92ZUxpc3RlbmVyLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLl9yZXNldEN1cnJlbnRCbG9jayA9IHRoaXMuX3Jlc2V0Q3VycmVudEJsb2NrLmJpbmQodGhpcyk7IC8vIGxpc3RlbiBmb3IgaGFuZGxlciBjaGFuZ2VzXHJcblxyXG4gICAgdGhpcy5fc2V0dXBJbnRlcm5hbEV2ZW50cygpO1xyXG4gIH1cclxuXHJcbiAgaXNSdW5uaW5nKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuX2lzUnVubmluZztcclxuICB9XHJcblxyXG4gIGdldEN1cnJlbnRCbG9jaygpIHtcclxuICAgIHJldHVybiB0aGlzLnN0YXRlLl9jdXJyZW50QmxvY2s7XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRMYXRlc3RCbG9jaygpIHtcclxuICAgIC8vIHJldHVybiBpZiBhdmFpbGFibGVcclxuICAgIGlmICh0aGlzLnN0YXRlLl9jdXJyZW50QmxvY2spIHtcclxuICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuX2N1cnJlbnRCbG9jaztcclxuICAgIH0gLy8gd2FpdCBmb3IgYSBuZXcgbGF0ZXN0IGJsb2NrXHJcblxyXG5cclxuICAgIGNvbnN0IGxhdGVzdEJsb2NrID0gYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiB0aGlzLm9uY2UoXCJsYXRlc3RcIiwgbmV3U3RhdGUgPT4ge1xyXG4gICAgICBpZiAobmV3U3RhdGUuX2N1cnJlbnRCbG9jaykge1xyXG4gICAgICAgIHJlc29sdmUobmV3U3RhdGUuX2N1cnJlbnRCbG9jayk7XHJcbiAgICAgIH1cclxuICAgIH0pKTsgLy8gcmV0dXJuIG5ld2x5IHNldCBjdXJyZW50IGJsb2NrXHJcblxyXG4gICAgcmV0dXJuIGxhdGVzdEJsb2NrO1xyXG4gIH0gLy8gZG9udCBhbGxvdyBtb2R1bGUgY29uc3VtZXIgdG8gcmVtb3ZlIG91ciBpbnRlcm5hbCBldmVudCBsaXN0ZW5lcnNcclxuXHJcblxyXG4gIHJlbW92ZUFsbExpc3RlbmVycyhldmVudE5hbWUpIHtcclxuICAgIGlmIChldmVudE5hbWUpIHtcclxuICAgICAgc3VwZXIucmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50TmFtZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzdXBlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcclxuICAgIH0gLy8gcmUtYWRkIGludGVybmFsIGV2ZW50c1xyXG5cclxuXHJcbiAgICB0aGlzLl9zZXR1cEludGVybmFsRXZlbnRzKCk7IC8vIHRyaWdnZXIgc3RvcCBjaGVjayBqdXN0IGluIGNhc2VcclxuXHJcblxyXG4gICAgdGhpcy5fb25SZW1vdmVMaXN0ZW5lcigpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBUbyBiZSBpbXBsZW1lbnRlZCBpbiBzdWJjbGFzcy5cclxuICAgKi9cclxuXHJcblxyXG4gIF9zdGFydCgpIHsvLyBkZWZhdWx0IGJlaGF2aW9yIGlzIG5vb3BcclxuICB9XHJcbiAgLyoqXHJcbiAgICogVG8gYmUgaW1wbGVtZW50ZWQgaW4gc3ViY2xhc3MuXHJcbiAgICovXHJcblxyXG5cclxuICBfZW5kKCkgey8vIGRlZmF1bHQgYmVoYXZpb3IgaXMgbm9vcFxyXG4gIH1cclxuXHJcbiAgX25ld1BvdGVudGlhbExhdGVzdChuZXdCbG9jaykge1xyXG4gICAgY29uc3QgY3VycmVudEJsb2NrID0gdGhpcy5zdGF0ZS5fY3VycmVudEJsb2NrOyAvLyBvbmx5IHVwZGF0ZSBpZiBibG9rIG51bWJlciBpcyBoaWdoZXJcclxuXHJcbiAgICBpZiAoY3VycmVudEJsb2NrICYmIG5ld0Jsb2NrLmlkZW1wb3RlbmN5S2V5ID09PSBjdXJyZW50QmxvY2suaWRlbXBvdGVuY3lLZXkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX3NldEN1cnJlbnRCbG9jayhuZXdCbG9jayk7XHJcbiAgfVxyXG5cclxuICBfc2V0dXBJbnRlcm5hbEV2ZW50cygpIHtcclxuICAgIC8vIGZpcnN0IHJlbW92ZSBsaXN0ZW5lcnMgZm9yIGlkZW1wb3RlbmN5XHJcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKFwibmV3TGlzdGVuZXJcIiwgdGhpcy5fb25OZXdMaXN0ZW5lcik7XHJcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKFwicmVtb3ZlTGlzdGVuZXJcIiwgdGhpcy5fb25SZW1vdmVMaXN0ZW5lcik7IC8vIHRoZW4gYWRkIHRoZW1cclxuXHJcbiAgICB0aGlzLm9uKFwicmVtb3ZlTGlzdGVuZXJcIiwgdGhpcy5fb25SZW1vdmVMaXN0ZW5lcik7XHJcbiAgICB0aGlzLm9uKFwibmV3TGlzdGVuZXJcIiwgdGhpcy5fb25OZXdMaXN0ZW5lcik7XHJcbiAgfVxyXG5cclxuICBfb25OZXdMaXN0ZW5lcigpIHtcclxuICAgIHRoaXMuX21heWJlU3RhcnQoKTtcclxuICB9XHJcblxyXG4gIF9vblJlbW92ZUxpc3RlbmVyKCkge1xyXG4gICAgLy8gYHJlbW92ZUxpc3RlbmVyYCBpcyBjYWxsZWQgKmFmdGVyKiB0aGUgbGlzdGVuZXIgaXMgcmVtb3ZlZFxyXG4gICAgaWYgKHRoaXMuX2dldEJsb2NrVHJhY2tlckV2ZW50Q291bnQoKSA+IDApIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX21heWJlRW5kKCk7XHJcbiAgfVxyXG5cclxuICBfbWF5YmVTdGFydCgpIHtcclxuICAgIGlmICh0aGlzLnN0YXRlLl9pc1J1bm5pbmcpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc3RhdGUuX2lzUnVubmluZyA9IHRydWU7IC8vIGNhbmNlbCBzZXR0aW5nIGxhdGVzdCBibG9jayB0byBzdGFsZVxyXG5cclxuICAgIHRoaXMuX2NhbmNlbEJsb2NrUmVzZXRUaW1lb3V0KCk7XHJcblxyXG4gICAgdGhpcy5fc3RhcnQoKTtcclxuICB9XHJcblxyXG4gIF9tYXliZUVuZCgpIHtcclxuICAgIGlmICghdGhpcy5zdGF0ZS5faXNSdW5uaW5nKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnN0YXRlLl9pc1J1bm5pbmcgPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzLl9zZXR1cEJsb2NrUmVzZXRUaW1lb3V0KCk7XHJcblxyXG4gICAgdGhpcy5fZW5kKCk7XHJcbiAgfVxyXG5cclxuICBfZ2V0QmxvY2tUcmFja2VyRXZlbnRDb3VudCgpIHtcclxuICAgIHJldHVybiBibG9ja1RyYWNrZXJFdmVudHMubWFwKGV2ZW50TmFtZSA9PiB0aGlzLmxpc3RlbmVyQ291bnQoZXZlbnROYW1lKSkucmVkdWNlKGNhbGN1bGF0ZVN1bSk7XHJcbiAgfVxyXG5cclxuICBfc2V0Q3VycmVudEJsb2NrKG5ld0Jsb2NrKSB7XHJcbiAgICBjb25zdCBvbGRCbG9jayA9IHRoaXMuc3RhdGUuX2N1cnJlbnRCbG9jaztcclxuICAgIHRoaXMudXBkYXRlKHtcclxuICAgICAgX2N1cnJlbnRCbG9jazogbmV3QmxvY2tcclxuICAgIH0pO1xyXG4gICAgdGhpcy5lbWl0KFwibGF0ZXN0XCIsIG5ld0Jsb2NrKTtcclxuICAgIHRoaXMuZW1pdChcInN5bmNcIiwge1xyXG4gICAgICBvbGRCbG9jayxcclxuICAgICAgbmV3QmxvY2tcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgX3NldHVwQmxvY2tSZXNldFRpbWVvdXQoKSB7XHJcbiAgICAvLyBjbGVhciBhbnkgZXhpc3RpbmcgdGltZW91dFxyXG4gICAgdGhpcy5fY2FuY2VsQmxvY2tSZXNldFRpbWVvdXQoKTsgLy8gY2xlYXIgbGF0ZXN0IGJsb2NrIHdoZW4gc3RhbGVcclxuXHJcblxyXG4gICAgdGhpcy5fYmxvY2tSZXNldFRpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMuX3Jlc2V0Q3VycmVudEJsb2NrLCB0aGlzLmNvbmZpZy5ibG9ja1Jlc2V0RHVyYXRpb24pOyAvLyBub2RlanMgLSBkb250IGhvbGQgcHJvY2VzcyBvcGVuXHJcblxyXG4gICAgaWYgKHRoaXMuX2Jsb2NrUmVzZXRUaW1lb3V0LnVucmVmKSB7XHJcbiAgICAgIHRoaXMuX2Jsb2NrUmVzZXRUaW1lb3V0LnVucmVmKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfY2FuY2VsQmxvY2tSZXNldFRpbWVvdXQoKSB7XHJcbiAgICBpZiAodGhpcy5fYmxvY2tSZXNldFRpbWVvdXQpIHtcclxuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2Jsb2NrUmVzZXRUaW1lb3V0KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9yZXNldEN1cnJlbnRCbG9jaygpIHtcclxuICAgIHRoaXMudXBkYXRlKHtcclxuICAgICAgX2N1cnJlbnRCbG9jazoge1xyXG4gICAgICAgIGlkZW1wb3RlbmN5S2V5OiBcIlwiXHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbn1cclxuXHJcbmNvbnN0IGZpbHRlck5vb3AgPSAoKSA9PiB0cnVlO1xyXG5cclxuY29uc3QgaW50ZXJuYWxFdmVudHMgPSBbXCJuZXdMaXN0ZW5lclwiLCBcInJlbW92ZUxpc3RlbmVyXCJdO1xyXG5cclxuY29uc3QgZXh0ZXJuYWxFdmVudEZpbHRlciA9IG5hbWUgPT4gIWludGVybmFsRXZlbnRzLmluY2x1ZGVzKG5hbWUpO1xyXG5cclxuZnVuY3Rpb24gZ2V0UmF3TGlzdGVuZXJzKGV2ZW50RW1pdHRlciwgbmFtZSkge1xyXG4gIC8vIHByZWZlciBuYXRpdmVcclxuICByZXR1cm4gZXZlbnRFbWl0dGVyLnJhd0xpc3RlbmVycyhuYW1lKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlRXZlbnRFbWl0dGVyUHJveHkoaW5pdGlhbFRhcmdldCwgb3B0cykge1xyXG4gIC8vIHBhcnNlIG9wdGlvbnNcclxuICBjb25zdCBmaW5hbE9wdHMgPSBvcHRzIHx8IHt9O1xyXG4gIGxldCBldmVudEZpbHRlciA9IGZpbmFsT3B0cy5ldmVudEZpbHRlciB8fCBmaWx0ZXJOb29wO1xyXG4gIGlmICh0eXBlb2YgZXZlbnRGaWx0ZXIgPT09IFwic3RyaW5nXCIgJiYgZXZlbnRGaWx0ZXIgPT09IFwic2tpcEludGVybmFsXCIpIGV2ZW50RmlsdGVyID0gZXh0ZXJuYWxFdmVudEZpbHRlcjtcclxuICBpZiAodHlwZW9mIGV2ZW50RmlsdGVyICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcihcImNyZWF0ZUV2ZW50RW1pdHRlclByb3h5IC0gSW52YWxpZCBldmVudEZpbHRlclwiKTtcclxuICBsZXQgdGFyZ2V0ID0gaW5pdGlhbFRhcmdldDtcclxuXHJcbiAgbGV0IHNldFRhcmdldCA9IG5ld1RhcmdldCA9PiB7XHJcbiAgICBjb25zdCBvbGRUYXJnZXQgPSB0YXJnZXQ7XHJcbiAgICB0YXJnZXQgPSBuZXdUYXJnZXQ7XHJcbiAgICBvbGRUYXJnZXQuZXZlbnROYW1lcygpLmZpbHRlcihldmVudEZpbHRlcikuZm9yRWFjaChuYW1lID0+IHtcclxuICAgICAgZ2V0UmF3TGlzdGVuZXJzKG9sZFRhcmdldCwgbmFtZSkuZm9yRWFjaChoYW5kbGVyID0+IG5ld1RhcmdldC5vbihuYW1lLCBoYW5kbGVyKSk7XHJcbiAgICB9KTsgLy8gcmVtb3ZlIG9sZCBsaXN0ZW5lcnNcclxuXHJcbiAgICBvbGRUYXJnZXQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkoe30sIHtcclxuICAgIGdldDogKF8sIG5hbWUpID0+IHtcclxuICAgICAgLy8gb3ZlcnJpZGUgYHNldFRhcmdldGAgYWNjZXNzXHJcbiAgICAgIGlmIChuYW1lID09PSBcInNldFRhcmdldFwiKSByZXR1cm4gc2V0VGFyZ2V0O1xyXG4gICAgICByZXR1cm4gdGFyZ2V0W25hbWVdO1xyXG4gICAgfSxcclxuICAgIHNldDogKF8sIG5hbWUsIHZhbHVlKSA9PiB7XHJcbiAgICAgIC8vIGFsbG93IGBzZXRUYXJnZXRgIG92ZXJyaWRlc1xyXG4gICAgICBpZiAobmFtZSA9PT0gXCJzZXRUYXJnZXRcIikge1xyXG4gICAgICAgIHNldFRhcmdldCA9IHZhbHVlO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0YXJnZXRbbmFtZV0gPSB2YWx1ZTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgcmV0dXJuIHByb3h5O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVTd2FwcGFibGVQcm94eShpbml0aWFsVGFyZ2V0KSB7XHJcbiAgbGV0IHRhcmdldCA9IGluaXRpYWxUYXJnZXQ7XHJcblxyXG4gIGxldCBzZXRUYXJnZXQgPSBuZXdUYXJnZXQgPT4ge1xyXG4gICAgdGFyZ2V0ID0gbmV3VGFyZ2V0O1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KHt9LCB7XHJcbiAgICBnZXQ6IChfLCBuYW1lKSA9PiB7XHJcbiAgICAgIC8vIG92ZXJyaWRlIGBzZXRUYXJnZXRgIGFjY2Vzc1xyXG4gICAgICBpZiAobmFtZSA9PT0gXCJzZXRUYXJnZXRcIikgcmV0dXJuIHNldFRhcmdldDtcclxuICAgICAgcmV0dXJuIHRhcmdldFtuYW1lXTtcclxuICAgIH0sXHJcbiAgICBzZXQ6IChfLCBuYW1lLCB2YWx1ZSkgPT4ge1xyXG4gICAgICAvLyBhbGxvdyBgc2V0VGFyZ2V0YCBvdmVycmlkZXNcclxuICAgICAgaWYgKG5hbWUgPT09IFwic2V0VGFyZ2V0XCIpIHtcclxuICAgICAgICBzZXRUYXJnZXQgPSB2YWx1ZTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGFyZ2V0W25hbWVdID0gdmFsdWU7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIHJldHVybiBwcm94eTtcclxufVxyXG5cclxuY29uc3QgUE9MTElOR19JTlRFUlZBTCA9IDYwMDAwMDtcclxuY2xhc3MgQmFzZUN1cnJlbmN5Q29udHJvbGxlciBleHRlbmRzIEJhc2VDb250cm9sbGVyIHtcclxuICBjb25zdHJ1Y3RvcihfcmVmKSB7XHJcbiAgICBsZXQge1xyXG4gICAgICBjb25maWcgPSB7fSxcclxuICAgICAgc3RhdGVcclxuICAgIH0gPSBfcmVmO1xyXG4gICAgc3VwZXIoe1xyXG4gICAgICBjb25maWcsXHJcbiAgICAgIHN0YXRlXHJcbiAgICB9KTtcclxuICAgIHRoaXMuZGVmYXVsdFN0YXRlID0ge1xyXG4gICAgICBjdXJyZW50Q3VycmVuY3k6IFwidXNkXCIsXHJcbiAgICAgIGNvbnZlcnNpb25SYXRlOiAwLFxyXG4gICAgICBjb252ZXJzaW9uRGF0ZTogXCJOL0FcIixcclxuICAgICAgbmF0aXZlQ3VycmVuY3k6IFwiRVRIXCJcclxuICAgIH07XHJcbiAgICB0aGlzLmRlZmF1bHRDb25maWcgPSB7XHJcbiAgICAgIHBvbGxJbnRlcnZhbDogUE9MTElOR19JTlRFUlZBTFxyXG4gICAgfTtcclxuICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xyXG4gIH0gLy9cclxuICAvLyBQVUJMSUMgTUVUSE9EU1xyXG4gIC8vXHJcblxyXG5cclxuICBnZXROYXRpdmVDdXJyZW5jeSgpIHtcclxuICAgIHJldHVybiB0aGlzLnN0YXRlLm5hdGl2ZUN1cnJlbmN5O1xyXG4gIH1cclxuXHJcbiAgc2V0TmF0aXZlQ3VycmVuY3kobmF0aXZlQ3VycmVuY3kpIHtcclxuICAgIHRoaXMudXBkYXRlKHtcclxuICAgICAgbmF0aXZlQ3VycmVuY3ksXHJcbiAgICAgIHRpY2tlcjogbmF0aXZlQ3VycmVuY3lcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgZ2V0Q3VycmVudEN1cnJlbmN5KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuY3VycmVudEN1cnJlbmN5O1xyXG4gIH1cclxuXHJcbiAgc2V0Q3VycmVudEN1cnJlbmN5KGN1cnJlbnRDdXJyZW5jeSkge1xyXG4gICAgdGhpcy51cGRhdGUoe1xyXG4gICAgICBjdXJyZW50Q3VycmVuY3lcclxuICAgIH0pO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBBIGdldHRlciBmb3IgdGhlIGNvbnZlcnNpb25SYXRlIHByb3BlcnR5XHJcbiAgICpcclxuICAgKiBAcmV0dXJucyBUaGUgY29udmVyc2lvbiByYXRlIGZyb20gRVRIIHRvIHRoZSBzZWxlY3RlZCBjdXJyZW5jeS5cclxuICAgKlxyXG4gICAqL1xyXG5cclxuXHJcbiAgZ2V0Q29udmVyc2lvblJhdGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5jb252ZXJzaW9uUmF0ZTtcclxuICB9XHJcblxyXG4gIHNldENvbnZlcnNpb25SYXRlKGNvbnZlcnNpb25SYXRlKSB7XHJcbiAgICB0aGlzLnVwZGF0ZSh7XHJcbiAgICAgIGNvbnZlcnNpb25SYXRlXHJcbiAgICB9KTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogQSBnZXR0ZXIgZm9yIHRoZSBjb252ZXJzaW9uRGF0ZSBwcm9wZXJ0eVxyXG4gICAqXHJcbiAgICogQHJldHVybnMgVGhlIGRhdGUgYXQgd2hpY2ggdGhlIGNvbnZlcnNpb24gcmF0ZSB3YXMgc2V0LiBFeHByZXNzZWQgaW4gbWlsbGlzZWNvbmRzIHNpbmNlIG1pZG5pZ2h0IG9mXHJcbiAgICogSmFudWFyeSAxLCAxOTcwXHJcbiAgICpcclxuICAgKi9cclxuXHJcblxyXG4gIGdldENvbnZlcnNpb25EYXRlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuY29udmVyc2lvbkRhdGU7XHJcbiAgfVxyXG5cclxuICBzZXRDb252ZXJzaW9uRGF0ZShjb252ZXJzaW9uRGF0ZSkge1xyXG4gICAgdGhpcy51cGRhdGUoe1xyXG4gICAgICBjb252ZXJzaW9uRGF0ZVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gb3duS2V5cyQyKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxyXG5cclxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQyKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gbnVsbCAhPSBhcmd1bWVudHNbaV0gPyBhcmd1bWVudHNbaV0gOiB7fTsgaSAlIDIgPyBvd25LZXlzJDIoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyQyKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IHJldHVybiB0YXJnZXQ7IH1cclxuY29uc3QgY3JlYXRlUmFuZG9tSWQgPSBnZXRDcmVhdGVSYW5kb21JZCgpO1xyXG5mdW5jdGlvbiBwcm92aWRlckZyb21FbmdpbmUoZW5naW5lKSB7XHJcbiAgY29uc3QgcHJvdmlkZXIgPSBuZXcgU2FmZUV2ZW50RW1pdHRlcigpOyAvLyBoYW5kbGUgYm90aCBycGMgc2VuZCBtZXRob2RzXHJcblxyXG4gIHByb3ZpZGVyLnNlbmRBc3luYyA9IGFzeW5jIHJlcSA9PiB7XHJcbiAgICBjb25zdCByZXMgPSBhd2FpdCBlbmdpbmUuaGFuZGxlKHJlcSk7XHJcblxyXG4gICAgaWYgKHJlcy5lcnJvcikge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IocmVzLmVycm9yKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcclxuICB9OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG5cclxuXHJcbiAgcHJvdmlkZXIuc2VuZCA9IChyZXEsIGNhbGxiYWNrKSA9PiB7XHJcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHByb3ZpZGUgY2FsbGJhY2sgdG8gXCJzZW5kXCIgbWV0aG9kLicpO1xyXG4gICAgfVxyXG5cclxuICAgIGVuZ2luZS5oYW5kbGUocmVxLCBjYWxsYmFjayk7XHJcbiAgfTsgLy8gZm9yd2FyZCBub3RpZmljYXRpb25zXHJcblxyXG5cclxuICBpZiAoZW5naW5lLm9uKSB7XHJcbiAgICBlbmdpbmUub24oXCJub3RpZmljYXRpb25cIiwgbWVzc2FnZSA9PiB7XHJcbiAgICAgIHByb3ZpZGVyLmVtaXQoXCJkYXRhXCIsIG51bGwsIG1lc3NhZ2UpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBwcm92aWRlci5yZXF1ZXN0ID0gYXN5bmMgYXJncyA9PiB7XHJcbiAgICBjb25zdCByZXEgPSBfb2JqZWN0U3ByZWFkJDIoX29iamVjdFNwcmVhZCQyKHt9LCBhcmdzKSwge30sIHtcclxuICAgICAgaWQ6IGNyZWF0ZVJhbmRvbUlkKCksXHJcbiAgICAgIGpzb25ycGM6IFwiMi4wXCJcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHByb3ZpZGVyLnNlbmRBc3luYyhyZXEpO1xyXG4gICAgcmV0dXJuIHJlcztcclxuICB9O1xyXG5cclxuICByZXR1cm4gcHJvdmlkZXI7XHJcbn1cclxuZnVuY3Rpb24gcHJvdmlkZXJGcm9tTWlkZGxld2FyZShtaWRkbGV3YXJlKSB7XHJcbiAgY29uc3QgZW5naW5lID0gbmV3IEpSUENFbmdpbmUoKTtcclxuICBlbmdpbmUucHVzaChtaWRkbGV3YXJlKTtcclxuICBjb25zdCBwcm92aWRlciA9IHByb3ZpZGVyRnJvbUVuZ2luZShlbmdpbmUpO1xyXG4gIHJldHVybiBwcm92aWRlcjtcclxufVxyXG5mdW5jdGlvbiBwcm92aWRlckFzTWlkZGxld2FyZShwcm92aWRlcikge1xyXG4gIHJldHVybiBhc3luYyAocmVxLCByZXMsIF9uZXh0LCBlbmQpID0+IHtcclxuICAgIC8vIHNlbmQgcmVxdWVzdCB0byBwcm92aWRlclxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcHJvdmlkZXJSZXMgPSBhd2FpdCBwcm92aWRlci5zZW5kQXN5bmMocmVxKTtcclxuICAgICAgcmVzLnJlc3VsdCA9IHByb3ZpZGVyUmVzO1xyXG4gICAgICByZXR1cm4gZW5kKCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICByZXR1cm4gZW5kKGVycm9yLm1lc3NhZ2UpO1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuXHJcbmNvbnN0IEZFQVRVUkVTX1BST1ZJREVSX0NIQU5HRV9XSU5ET1cgPSB7XHJcbiAgaGVpZ2h0OiA2NjAsXHJcbiAgd2lkdGg6IDM3NVxyXG59O1xyXG5jb25zdCBGRUFUVVJFU19ERUZBVUxUX1dBTExFVF9XSU5ET1cgPSB7XHJcbiAgaGVpZ2h0OiA3NDAsXHJcbiAgd2lkdGg6IDEzMTVcclxufTtcclxuY29uc3QgRkVBVFVSRVNfREVGQVVMVF9QT1BVUF9XSU5ET1cgPSB7XHJcbiAgaGVpZ2h0OiA3MDAsXHJcbiAgd2lkdGg6IDEyMDBcclxufTtcclxuY29uc3QgRkVBVFVSRVNfQ09ORklSTV9XSU5ET1cgPSB7XHJcbiAgaGVpZ2h0OiA3MDAsXHJcbiAgd2lkdGg6IDQ1MFxyXG59O1xyXG5jb25zdCBQT1BVUF9MT0FERUQgPSBcInBvcHVwX2xvYWRlZFwiO1xyXG5jb25zdCBQT1BVUF9SRVNVTFQgPSBcInBvcHVwX3Jlc3VsdFwiO1xyXG5jb25zdCBTRVRVUF9DT01QTEVURSA9IFwic2V0dXBfY29tcGxldGVcIjtcclxuY29uc3QgQUNUSVZJVFlfQUNUSU9OX0FMTCA9IFwid2FsbGV0QWN0aXZpdHkuYWxsVHJhbnNhY3Rpb25zXCI7XHJcbmNvbnN0IEFDVElWSVRZX0FDVElPTl9TRU5EID0gXCJ3YWxsZXRBY3Rpdml0eS5zZW5kXCI7XHJcbmNvbnN0IEFDVElWSVRZX0FDVElPTl9SRUNFSVZFID0gXCJ3YWxsZXRBY3Rpdml0eS5yZWNlaXZlXCI7XHJcbmNvbnN0IEFDVElWSVRZX0FDVElPTl9UT1BVUCA9IFwid2FsbGV0QWN0aXZpdHkudG9wdXBcIjtcclxuY29uc3QgQUNUSVZJVFlfUEVSSU9EX0FMTCA9IFwid2FsbGV0QWN0aXZpdHkuYWxsXCI7XHJcbmNvbnN0IEFDVElWSVRZX1BFUklPRF9XRUVLX09ORSA9IFwid2FsbGV0QWN0aXZpdHkubGFzdE9uZVdlZWtcIjtcclxuY29uc3QgQUNUSVZJVFlfUEVSSU9EX01PTlRIX09ORSA9IFwid2FsbGV0QWN0aXZpdHkubGFzdE9uZU1vbnRoXCI7XHJcbmNvbnN0IEFDVElWSVRZX1BFUklPRF9NT05USF9TSVggPSBcIndhbGxldEFjdGl2aXR5Lmxhc3RTaXhNb250c1wiO1xyXG5jb25zdCBBQ1RJVklUWV9TVEFUVVNfU1VDQ0VTU0ZVTCA9IFwid2FsbGV0QWN0aXZpdHkuc3VjY2Vzc2Z1bFwiO1xyXG5jb25zdCBBQ1RJVklUWV9TVEFUVVNfVU5TVUNDRVNTRlVMID0gXCJ3YWxsZXRBY3Rpdml0eS51bnN1Y2Nlc3NmdWxcIjtcclxuY29uc3QgQUNUSVZJVFlfU1RBVFVTX1BFTkRJTkcgPSBcIndhbGxldEFjdGl2aXR5LnBlbmRpbmdcIjtcclxuY29uc3QgQUNUSVZJVFlfU1RBVFVTX0NBTkNFTExFRCA9IFwid2FsbGV0QWN0aXZpdHkuY2FuY2VsbGVkXCI7XHJcbmNvbnN0IEFDVElWSVRZX1NUQVRVU19DQU5DRUxMSU5HID0gXCJ3YWxsZXRBY3Rpdml0eS5jYW5jZWxsaW5nXCI7XHJcbmNvbnN0IENPTU1VTklDQVRJT05fTk9USUZJQ0FUSU9OUyA9IHtcclxuICBJRlJBTUVfU1RBVFVTOiBcImlmcmFtZV9zdGF0dXNcIixcclxuICAvLyBUZWxsIGVtYmVkIHRvIGNyZWF0ZSB0aGUgd2luZG93XHJcbiAgQ1JFQVRFX1dJTkRPVzogXCJjcmVhdGVfd2luZG93XCIsXHJcbiAgLy8gVGVsbCBlbWJlZCB0byBjbG9zZSB0aGUgd2luZG93XHJcbiAgQ0xPU0VfV0lORE9XOiBcImNsb3NlX3dpbmRvd1wiLFxyXG4gIFVTRVJfTE9HR0VEX0lOOiBcInVzZXJfbG9nZ2VkX2luXCIsXHJcbiAgVVNFUl9MT0dHRURfT1VUOiBcInVzZXJfbG9nZ2VkX291dFwiXHJcbn07XHJcbmNvbnN0IENPTU1VTklDQVRJT05fSlJQQ19NRVRIT0RTID0ge1xyXG4gIExPR09VVDogXCJsb2dvdXRcIixcclxuICBXQUxMRVRfSU5TVEFOQ0VfSUQ6IFwid2FsbGV0X2luc3RhbmNlX2lkXCIsXHJcbiAgVVNFUl9JTkZPOiBcInVzZXJfaW5mb1wiLFxyXG4gIFNFVF9QUk9WSURFUjogXCJzZXRfcHJvdmlkZXJcIixcclxuICBUT1BVUDogXCJ0b3B1cFwiLFxyXG4gIElGUkFNRV9TVEFUVVM6IFwiaWZyYW1lX3N0YXR1c1wiLFxyXG4gIC8vIGVtYmVkIGhhcyBvcGVuZWQgdGhlIHdpbmRvdyBhcyByZXF1ZXN0ZWRcclxuICBPUEVORURfV0lORE9XOiBcIm9wZW5lZF93aW5kb3dcIixcclxuICAvLyB1c2VyIGhhcyBjbG9zZWQgdGhlIHdpbmRvdyBmcm9tIGVtYmVkJ3Mgc2lkZVxyXG4gIENMT1NFRF9XSU5ET1c6IFwiY2xvc2VkX3dpbmRvd1wiLFxyXG4gIEdFVF9QUk9WSURFUl9TVEFURTogXCJnZXRfcHJvdmlkZXJfc3RhdGVcIixcclxuICBMT0dJTl9XSVRIX1BSSVZBVEVfS0VZOiBcImxvZ2luX3dpdGhfcHJpdmF0ZV9rZXlcIlxyXG59O1xyXG5jb25zdCBQUk9WSURFUl9KUlBDX01FVEhPRFMgPSB7XHJcbiAgR0VUX1BST1ZJREVSX1NUQVRFOiBcIndhbGxldF9nZXRfcHJvdmlkZXJfc3RhdGVcIlxyXG59O1xyXG5jb25zdCBQUk9WSURFUl9OT1RJRklDQVRJT05TID0ge1xyXG4gIEFDQ09VTlRTX0NIQU5HRUQ6IFwid2FsbGV0X2FjY291bnRzX2NoYW5nZWRcIixcclxuICBDSEFJTl9DSEFOR0VEOiBcIndhbGxldF9jaGFpbl9jaGFuZ2VkXCIsXHJcbiAgVU5MT0NLX1NUQVRFX0NIQU5HRUQ6IFwid2FsbGV0X3VubG9ja19zdGF0ZV9jaGFuZ2VkXCJcclxufTtcclxuY29uc3QgQlJPQURDQVNUX0NIQU5ORUxTID0ge1xyXG4gIFJFRElSRUNUX0NIQU5ORUw6IFwicmVkaXJlY3RfY2hhbm5lbFwiLFxyXG4gIFBST1ZJREVSX0NIQU5HRV9DSEFOTkVMOiBcInRvcnVzX3Byb3ZpZGVyX2NoYW5nZV9jaGFubmVsXCIsXHJcbiAgVFJBTlNBQ1RJT05fQ0hBTk5FTDogXCJ0b3J1c19jaGFubmVsXCIsXHJcbiAgTUVTU0FHRV9DSEFOTkVMOiBcInRvcnVzX21lc3NhZ2VfY2hhbm5lbFwiLFxyXG4gIFdBTExFVF9MT0dPVVRfQ0hBTk5FTDogXCJ3YWxsZXRfbG9nb3V0X2NoYW5uZWxcIixcclxuICBXQUxMRVRfU0VMRUNURURfQUREUkVTU19DSEFOTkVMOiBcIndhbGxldF9zZWxlY3RlZF9hZGRyZXNzX2NoYW5uZWxcIixcclxuICBXQUxMRVRfTkVUV09SS19DSEFOR0VfQ0hBTk5FTDogXCJ3YWxsZXRfbmV0d29ya19jaGFuZ2VfY2hhbm5lbFwiLFxyXG4gIFdBTExFVF9BQ0NPVU5UX0lNUE9SVF9DSEFOTkVMOiBcIndhbGxldF9hY2NvdW50X2ltcG9ydF9jaGFubmVsXCJcclxufTtcclxuY29uc3QgQlJPQURDQVNUX0NIQU5ORUxTX01TR1MgPSB7XHJcbiAgTE9HT1VUOiBcImxvZ291dFwiLFxyXG4gIEFDQ09VTlRfSU1QT1JURUQ6IFwiYWNjb3VudF9pbXBvcnRlZFwiLFxyXG4gIFNFTEVDVEVEX0FERFJFU1NfQ0hBTkdFOiBcInNlbGVjdGVkX2FkZHJlc3NfY2hhbmdlXCIsXHJcbiAgTkVUV09SS19DSEFOR0U6IFwibmV0d29ya19jaGFuZ2VcIlxyXG59O1xyXG5cclxuZnVuY3Rpb24gY3JlYXRlQ2hhbmdlUHJvdmlkZXJNaWRkbGV3YXJlTWlkZGxld2FyZShfcmVmKSB7XHJcbiAgbGV0IHtcclxuICAgIGNoYW5nZVByb3ZpZGVyXHJcbiAgfSA9IF9yZWY7XHJcbiAgcmV0dXJuIGNyZWF0ZUFzeW5jTWlkZGxld2FyZShhc3luYyAocmVxdWVzdCwgcmVzcG9uc2UsIG5leHQpID0+IHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgbWV0aG9kXHJcbiAgICB9ID0gcmVxdWVzdDtcclxuICAgIGlmIChtZXRob2QgIT09IENPTU1VTklDQVRJT05fSlJQQ19NRVRIT0RTLlNFVF9QUk9WSURFUikgcmV0dXJuIG5leHQoKTtcclxuICAgIGlmICghY2hhbmdlUHJvdmlkZXIpIHRocm93IG5ldyBFcnJvcihcIkNvbW11bmljYXRpb25NaWRkbGV3YXJlIC0gb3B0cy5jaGFuZ2VQcm92aWRlciBub3QgcHJvdmlkZWRcIik7XHJcbiAgICByZXNwb25zZS5yZXN1bHQgPSBhd2FpdCBjaGFuZ2VQcm92aWRlcihyZXF1ZXN0KTtcclxuICB9KTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVUb3B1cE1pZGRsZXdhcmUoX3JlZjIpIHtcclxuICBsZXQge1xyXG4gICAgdG9wdXBcclxuICB9ID0gX3JlZjI7XHJcbiAgcmV0dXJuIGNyZWF0ZUFzeW5jTWlkZGxld2FyZShhc3luYyAocmVxdWVzdCwgcmVzcG9uc2UsIG5leHQpID0+IHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgbWV0aG9kXHJcbiAgICB9ID0gcmVxdWVzdDtcclxuICAgIGlmIChtZXRob2QgIT09IENPTU1VTklDQVRJT05fSlJQQ19NRVRIT0RTLlRPUFVQKSByZXR1cm4gbmV4dCgpO1xyXG4gICAgaWYgKCF0b3B1cCkgdGhyb3cgbmV3IEVycm9yKFwiQ29tbXVuaWNhdGlvbk1pZGRsZXdhcmUgLSBvcHRzLnRvcHVwIG5vdCBwcm92aWRlZFwiKTtcclxuICAgIHJlc3BvbnNlLnJlc3VsdCA9IGF3YWl0IHRvcHVwKHJlcXVlc3QpO1xyXG4gIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUdlbmVyaWNKUlBDTWlkZGxld2FyZSh0YXJnZXRNZXRob2QsIGhhbmRsZXIpIHtcclxuICByZXR1cm4gY3JlYXRlQXN5bmNNaWRkbGV3YXJlKGFzeW5jIChyZXF1ZXN0LCByZXNwb25zZSwgbmV4dCkgPT4ge1xyXG4gICAgY29uc3Qge1xyXG4gICAgICBtZXRob2RcclxuICAgIH0gPSByZXF1ZXN0O1xyXG4gICAgaWYgKG1ldGhvZCAhPT0gdGFyZ2V0TWV0aG9kKSByZXR1cm4gbmV4dCgpO1xyXG4gICAgaWYgKCFoYW5kbGVyKSB0aHJvdyBuZXcgRXJyb3IoXCJDb21tdW5pY2F0aW9uTWlkZGxld2FyZSAtIFwiLmNvbmNhdCh0YXJnZXRNZXRob2QsIFwiIG5vdCBwcm92aWRlZFwiKSk7XHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBoYW5kbGVyKHJlcXVlc3QpO1xyXG5cclxuICAgIGlmICghcmVzdWx0KSB7XHJcbiAgICAgIHJldHVybiBuZXh0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVzcG9uc2UucmVzdWx0ID0gcmVzdWx0O1xyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICB9KTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVDb21tdW5pY2F0aW9uTWlkZGxld2FyZShwcm92aWRlckhhbmRsZXJzKSB7XHJcbiAgY29uc3Qge1xyXG4gICAgZ2V0VXNlckluZm8sXHJcbiAgICBnZXRXYWxsZXRJbnN0YW5jZUlkLFxyXG4gICAgdG9wdXAsXHJcbiAgICBsb2dvdXQsXHJcbiAgICBjaGFuZ2VQcm92aWRlcixcclxuICAgIHNldElGcmFtZVN0YXR1cyxcclxuICAgIGhhbmRsZVdpbmRvd1JwYyxcclxuICAgIGdldFByb3ZpZGVyU3RhdGUsXHJcbiAgICBsb2dpbldpdGhQcml2YXRlS2V5XHJcbiAgfSA9IHByb3ZpZGVySGFuZGxlcnM7XHJcbiAgcmV0dXJuIG1lcmdlTWlkZGxld2FyZShbY3JlYXRlQ2hhbmdlUHJvdmlkZXJNaWRkbGV3YXJlTWlkZGxld2FyZSh7XHJcbiAgICBjaGFuZ2VQcm92aWRlclxyXG4gIH0pLCBjcmVhdGVUb3B1cE1pZGRsZXdhcmUoe1xyXG4gICAgdG9wdXBcclxuICB9KSwgY3JlYXRlU2NhZmZvbGRNaWRkbGV3YXJlKHtcclxuICAgIFtDT01NVU5JQ0FUSU9OX0pSUENfTUVUSE9EUy5MT0dPVVRdOiBsb2dvdXQsXHJcbiAgICBbQ09NTVVOSUNBVElPTl9KUlBDX01FVEhPRFMuV0FMTEVUX0lOU1RBTkNFX0lEXTogZ2V0V2FsbGV0SW5zdGFuY2VJZCxcclxuICAgIFtDT01NVU5JQ0FUSU9OX0pSUENfTUVUSE9EUy5VU0VSX0lORk9dOiBnZXRVc2VySW5mbyxcclxuICAgIFtDT01NVU5JQ0FUSU9OX0pSUENfTUVUSE9EUy5JRlJBTUVfU1RBVFVTXTogc2V0SUZyYW1lU3RhdHVzLFxyXG4gICAgLy8gRG8gdGhpcyBpbiB0aGUgb3JjaGVzdHJhdG9yIGJlY2F1c2UgY29tbXVuaWNhdGlvbldpbmRvd01hbmFnZXIgbmVlZHMgdG8gYmUgcGFzc2VkIGludG8gUG9wdXBIYW5kbGVyc1xyXG4gICAgW0NPTU1VTklDQVRJT05fSlJQQ19NRVRIT0RTLk9QRU5FRF9XSU5ET1ddOiBoYW5kbGVXaW5kb3dScGMsXHJcbiAgICBbQ09NTVVOSUNBVElPTl9KUlBDX01FVEhPRFMuQ0xPU0VEX1dJTkRPV106IGhhbmRsZVdpbmRvd1JwYyxcclxuICAgIFtDT01NVU5JQ0FUSU9OX0pSUENfTUVUSE9EUy5HRVRfUFJPVklERVJfU1RBVEVdOiBnZXRQcm92aWRlclN0YXRlXHJcbiAgfSksIGNyZWF0ZUdlbmVyaWNKUlBDTWlkZGxld2FyZShDT01NVU5JQ0FUSU9OX0pSUENfTUVUSE9EUy5MT0dJTl9XSVRIX1BSSVZBVEVfS0VZLCBsb2dpbldpdGhQcml2YXRlS2V5KV0pO1xyXG59XHJcblxyXG5jbGFzcyBCYXNlRW1iZWRDb250cm9sbGVyIGV4dGVuZHMgQmFzZUNvbnRyb2xsZXIge1xyXG4gIGNvbnN0cnVjdG9yKF9yZWYpIHtcclxuICAgIGxldCB7XHJcbiAgICAgIGNvbmZpZyA9IHt9LFxyXG4gICAgICBzdGF0ZVxyXG4gICAgfSA9IF9yZWY7XHJcbiAgICBzdXBlcih7XHJcbiAgICAgIGNvbmZpZyxcclxuICAgICAgc3RhdGVcclxuICAgIH0pO1xyXG5cclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9jb21tdW5pY2F0aW9uUHJvdmlkZXJQcm94eVwiLCB2b2lkIDApO1xyXG5cclxuICAgIHRoaXMuZGVmYXVsdFN0YXRlID0ge1xyXG4gICAgICBidXR0b25Qb3NpdGlvbjogXCJib3R0b20tcmlnaHRcIixcclxuICAgICAgaXNJRnJhbWVGdWxsU2NyZWVuOiB0cnVlLFxyXG4gICAgICBhcGlLZXk6IFwidG9ydXMtZGVmYXVsdFwiLFxyXG4gICAgICBvYXV0aE1vZGFsVmlzaWJpbGl0eTogZmFsc2UsXHJcbiAgICAgIGxvZ2luSW5Qcm9ncmVzczogZmFsc2UsXHJcbiAgICAgIGRhcHBNZXRhZGF0YToge1xyXG4gICAgICAgIG5hbWU6IFwiXCIsXHJcbiAgICAgICAgaWNvbjogXCJcIlxyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhpcy5pbml0aWFsaXplKCk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIENhbGxlZCBieSBvcmNoZXN0cmF0b3Igb25jZSB3aGlsZSBpbml0aWFsaXppbmcgdGhlIGNsYXNzXHJcbiAgICogQHBhcmFtIGhhbmRsZXJzIC0gSlJQQyBoYW5kbGVycyBmb3IgcHJvdmlkZXJcclxuICAgKiBAcmV0dXJucyAtIHByb3ZpZGVyIC0gUmV0dXJucyB0aGUgcHJvdmlkZXJQcm94eVxyXG4gICAqL1xyXG5cclxuXHJcbiAgaW5pdGlhbGl6ZVByb3ZpZGVyKGhhbmRsZXJzKSB7XHJcbiAgICBjb25zdCBlbmdpbmUgPSBuZXcgSlJQQ0VuZ2luZSgpO1xyXG4gICAgY29uc3QgY29tbXVuaWNhdGlvbk1pZGRsZXdhcmUgPSBjcmVhdGVDb21tdW5pY2F0aW9uTWlkZGxld2FyZShoYW5kbGVycyk7XHJcbiAgICBlbmdpbmUucHVzaChjb21tdW5pY2F0aW9uTWlkZGxld2FyZSk7XHJcbiAgICBjb25zdCBjb21tdW5pY2F0aW9uUHJvdmlkZXIgPSBwcm92aWRlckZyb21FbmdpbmUoZW5naW5lKTtcclxuICAgIHRoaXMuc2V0Q29tbXVuaWNhdGlvblByb3ZpZGVyKGNvbW11bmljYXRpb25Qcm92aWRlcik7XHJcbiAgfVxyXG5cclxuICBzZXRDb21tdW5pY2F0aW9uUHJvdmlkZXIoY29tbXVuaWNhdGlvblByb3ZpZGVyKSB7XHJcbiAgICBpZiAodGhpcy5fY29tbXVuaWNhdGlvblByb3ZpZGVyUHJveHkpIHtcclxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxyXG4gICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgIHRoaXMuX2NvbW11bmljYXRpb25Qcm92aWRlclByb3h5LnNldFRhcmdldChjb21tdW5pY2F0aW9uUHJvdmlkZXIpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5fY29tbXVuaWNhdGlvblByb3ZpZGVyUHJveHkgPSBjcmVhdGVTd2FwcGFibGVQcm94eShjb21tdW5pY2F0aW9uUHJvdmlkZXIpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbn1cclxuXHJcbmNsYXNzIENvbW11bmljYXRpb25XaW5kb3dNYW5hZ2VyIGV4dGVuZHMgU2FmZUV2ZW50RW1pdHRlciB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG5cclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhbmRsZVdpbmRvd1JwY1wiLCAocmVxdWVzdCwgcmVzcG9uc2UsIG5leHQsIGVuZCkgPT4ge1xyXG4gICAgICBjb25zdCB7XHJcbiAgICAgICAgbWV0aG9kLFxyXG4gICAgICAgIHBhcmFtc1xyXG4gICAgICB9ID0gcmVxdWVzdDtcclxuXHJcbiAgICAgIGlmIChtZXRob2QgPT09IENPTU1VTklDQVRJT05fSlJQQ19NRVRIT0RTLk9QRU5FRF9XSU5ET1cpIHtcclxuICAgICAgICBjb25zdCB7XHJcbiAgICAgICAgICB3aW5kb3dJZFxyXG4gICAgICAgIH0gPSBwYXJhbXM7IC8vIEkndmUgYmVlbiBpbmZvcm1lZCB0aGF0IGEgd2luZG93IGhhcyBiZWVuIG9wZW5lZFxyXG5cclxuICAgICAgICB0aGlzLmVtaXQoXCJcIi5jb25jYXQod2luZG93SWQsIFwiOm9wZW5lZFwiKSk7XHJcbiAgICAgICAgcmVzcG9uc2UucmVzdWx0ID0gdHJ1ZTtcclxuICAgICAgICBlbmQoKTtcclxuICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09IENPTU1VTklDQVRJT05fSlJQQ19NRVRIT0RTLkNMT1NFRF9XSU5ET1cpIHtcclxuICAgICAgICBjb25zdCB7XHJcbiAgICAgICAgICB3aW5kb3dJZFxyXG4gICAgICAgIH0gPSBwYXJhbXM7IC8vIEkndmUgYmVlbiBpbmZvcm1lZCB0aGF0IGEgd2luZG93IGhhcyBiZWVuIGNsb3NlZFxyXG5cclxuICAgICAgICB0aGlzLmVtaXQoXCJcIi5jb25jYXQod2luZG93SWQsIFwiOmNsb3NlZFwiKSk7XHJcbiAgICAgICAgcmVzcG9uc2UucmVzdWx0ID0gdHJ1ZTtcclxuICAgICAgICBlbmQoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBuZXh0KCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbn1cclxuXHJcbmNvbnN0IExPR0lOX1BST1ZJREVSID0ge1xyXG4gIEdPT0dMRTogXCJnb29nbGVcIixcclxuICBGQUNFQk9PSzogXCJmYWNlYm9va1wiLFxyXG4gIFJFRERJVDogXCJyZWRkaXRcIixcclxuICBESVNDT1JEOiBcImRpc2NvcmRcIixcclxuICBUV0lUQ0g6IFwidHdpdGNoXCIsXHJcbiAgQVBQTEU6IFwiYXBwbGVcIixcclxuICBMSU5FOiBcImxpbmVcIixcclxuICBHSVRIVUI6IFwiZ2l0aHViXCIsXHJcbiAgS0FLQU86IFwia2FrYW9cIixcclxuICBMSU5LRURJTjogXCJsaW5rZWRpblwiLFxyXG4gIFRXSVRURVI6IFwidHdpdHRlclwiLFxyXG4gIFdFSUJPOiBcIndlaWJvXCIsXHJcbiAgV0VDSEFUOiBcIndlY2hhdFwiLFxyXG4gIEVNQUlMX1BBU1NXT1JETEVTUzogXCJlbWFpbF9wYXNzd29yZGxlc3NcIlxyXG59O1xyXG5jb25zdCBQQVlNRU5UX1BST1ZJREVSID0ge1xyXG4gIE1PT05QQVk6IFwibW9vbnBheVwiLFxyXG4gIFdZUkU6IFwid3lyZVwiLFxyXG4gIFJBTVBORVRXT1JLOiBcInJhbXBuZXR3b3JrXCIsXHJcbiAgWEFOUE9PTDogXCJ4YW5wb29sXCIsXHJcbiAgTUVSQ1VSWU86IFwibWVyY3VyeW9cIixcclxuICBUUkFOU0FLOiBcInRyYW5zYWtcIlxyXG59O1xyXG5cclxuY29uc3QgZ2V0VHhTdGF0dXNUZXh0ID0gdHhTdGF0dXMgPT4ge1xyXG4gIHN3aXRjaCAodHhTdGF0dXMpIHtcclxuICAgIGNhc2UgXCJyZWplY3RlZFwiOlxyXG4gICAgY2FzZSBcInVuYXBwcm92ZWRcIjpcclxuICAgIGNhc2UgXCJmYWlsZWRcIjpcclxuICAgICAgcmV0dXJuIEFDVElWSVRZX1NUQVRVU19VTlNVQ0NFU1NGVUw7XHJcblxyXG4gICAgY2FzZSBcImNvbmZpcm1lZFwiOlxyXG4gICAgICByZXR1cm4gQUNUSVZJVFlfU1RBVFVTX1NVQ0NFU1NGVUw7XHJcblxyXG4gICAgY2FzZSBcInN1Ym1pdHRlZFwiOlxyXG4gICAgICByZXR1cm4gQUNUSVZJVFlfU1RBVFVTX1BFTkRJTkc7XHJcblxyXG4gICAgY2FzZSBcImNhbmNlbGxlZFwiOlxyXG4gICAgICByZXR1cm4gQUNUSVZJVFlfU1RBVFVTX0NBTkNFTExFRDtcclxuXHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICByZXR1cm4gXCJcIjtcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogR2VuZXJhbCB1dGlsaXR5IGZ1bmN0aW9uc1xyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIGludFRvSGV4KGkpIHtcclxuICBjb25zdCBoZXggPSBpLnRvU3RyaW5nKDE2KTtcclxuICByZXR1cm4gXCIweFwiLmNvbmNhdChoZXgpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgcmFuZG9tIG51bWJlci4gRG9uJ3QgdXNlIGZvciBjcnlwdG9ncmFwaGljIHB1cnBvc2VzLlxyXG4gKiBAcmV0dXJucyBhIHJhbmRvbSBudW1iZXJcclxuICovXHJcblxyXG5jb25zdCByYW5kb21JZCA9ICgpID0+IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xyXG4vKipcclxuICogUGFkcyB0aGUgZnJvbnQgb2YgdGhlIGdpdmVuIGhleCBzdHJpbmcgd2l0aCB6ZXJvZXMgdW50aWwgaXQgcmVhY2hlcyB0aGVcclxuICogdGFyZ2V0IGxlbmd0aC4gSWYgdGhlIGlucHV0IHN0cmluZyBpcyBhbHJlYWR5IGxvbmdlciB0aGFuIG9yIGVxdWFsIHRvIHRoZVxyXG4gKiB0YXJnZXQgbGVuZ3RoLCBpdCBpcyByZXR1cm5lZCB1bm1vZGlmaWVkLlxyXG4gKlxyXG4gKiBJZiB0aGUgaW5wdXQgc3RyaW5nIGlzIFwiMHhcIi1wcmVmaXhlZCBvciBub3QgYSBoZXggc3RyaW5nLCBhbiBlcnJvciB3aWxsIGJlXHJcbiAqIHRocm93bi5cclxuICpcclxuICogQHBhcmFtIGhleFN0cmluZyAtIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gcGFkIHdpdGggemVyb2VzLlxyXG4gKiBAcGFyYW0gdGFyZ2V0TGVuZ3RoIC0gVGhlIHRhcmdldCBsZW5ndGggb2YgdGhlIGhleGFkZWNpbWFsIHN0cmluZy5cclxuICogQHJldHVybnMgVGhlIGlucHV0IHN0cmluZyBmcm9udC1wYWRkZWQgd2l0aCB6ZXJvZXMsIG9yIHRoZSBvcmlnaW5hbCBzdHJpbmdcclxuICogaWYgaXQgd2FzIGFscmVhZHkgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRvIHRoZSB0YXJnZXQgbGVuZ3RoLlxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIHBhZFdpdGhaZXJvZXMoaGV4U3RyaW5nLCB0YXJnZXRMZW5ndGgpIHtcclxuICBpZiAoaGV4U3RyaW5nICE9PSBcIlwiICYmICEvXlthLWYwLTldKyQvaXUudGVzdChoZXhTdHJpbmcpKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBhbiB1bnByZWZpeGVkIGhleCBzdHJpbmcuIFJlY2VpdmVkOiBcIi5jb25jYXQoaGV4U3RyaW5nKSk7XHJcbiAgfVxyXG5cclxuICBpZiAodGFyZ2V0TGVuZ3RoIDwgMCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgYSBub24tbmVnYXRpdmUgaW50ZWdlciB0YXJnZXQgbGVuZ3RoLiBSZWNlaXZlZDogXCIuY29uY2F0KHRhcmdldExlbmd0aCkpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIFN0cmluZy5wcm90b3R5cGUucGFkU3RhcnQuY2FsbChoZXhTdHJpbmcsIHRhcmdldExlbmd0aCwgXCIwXCIpO1xyXG59XHJcbi8qKlxyXG4gKiBDb25jYXRlbmF0ZSBhbiBleHRlbmRlZCBFQ0RTQSBzaWduYXR1cmUgaW50byBhIGhleCBzdHJpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSB2IC0gVGhlICd2JyBwb3J0aW9uIG9mIHRoZSBzaWduYXR1cmUuXHJcbiAqIEBwYXJhbSByIC0gVGhlICdyJyBwb3J0aW9uIG9mIHRoZSBzaWduYXR1cmUuXHJcbiAqIEBwYXJhbSBzIC0gVGhlICdzJyBwb3J0aW9uIG9mIHRoZSBzaWduYXR1cmUuXHJcbiAqIEByZXR1cm5zIFRoZSBjb25jYXRlbmF0ZWQgRUNEU0Egc2lnbmF0dXJlLlxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIGNvbmNhdFNpZyh2LCByLCBzKSB7XHJcbiAgY29uc3QgclNpZyA9IGZyb21TaWduZWQocik7XHJcbiAgY29uc3Qgc1NpZyA9IGZyb21TaWduZWQocyk7XHJcbiAgY29uc3QgdlNpZyA9IGJ1ZmZlclRvSW50KHYpO1xyXG4gIGNvbnN0IHJTdHIgPSBwYWRXaXRoWmVyb2VzKHRvVW5zaWduZWQoclNpZykudG9TdHJpbmcoXCJoZXhcIiksIDY0KTtcclxuICBjb25zdCBzU3RyID0gcGFkV2l0aFplcm9lcyh0b1Vuc2lnbmVkKHNTaWcpLnRvU3RyaW5nKFwiaGV4XCIpLCA2NCk7XHJcbiAgY29uc3QgdlN0ciA9IHN0cmlwSGV4UHJlZml4KGludFRvSGV4KHZTaWcpKTtcclxuICByZXR1cm4gYWRkSGV4UHJlZml4KHJTdHIuY29uY2F0KHNTdHIsIHZTdHIpKTtcclxufVxyXG5mdW5jdGlvbiB0aW1lb3V0JDEoZHVyYXRpb24pIHtcclxuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XHJcbiAgICBjb25zdCB0aW1lb3V0UmVmID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICByZXNvbHZlKCk7XHJcbiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dFJlZik7XHJcbiAgICB9LCBkdXJhdGlvbik7XHJcbiAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIFRleHQvbnVtYmVyIGZvcm1hdHRpbmcgdXRpbGl0aWVzXHJcbiAqL1xyXG5cclxuY29uc3QgZm9ybWF0U21hbGxOdW1iZXJzID0gZnVuY3Rpb24gKG51bWJlcikge1xyXG4gIGxldCBjdXJyZW5jeSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogXCJ1c2RcIjtcclxuICBsZXQgbm9UaWxkZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XHJcbiAgY29uc3QgZmluYWxOdW1iZXIgPSBCaWdOdW1iZXIuaXNCaWdOdW1iZXIobnVtYmVyKSA/IG51bWJlci50b051bWJlcigpIDogbnVtYmVyO1xyXG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGZpbmFsTnVtYmVyKSkgcmV0dXJuIFwiXCI7XHJcbiAgY29uc3QgdmFsdWUgPSBjdXJyZW5jeS50b0xvd2VyQ2FzZSgpID09PSBcInVzZFwiID8gcGFyc2VGbG9hdChOdW1iZXIoZmluYWxOdW1iZXIpLnRvRml4ZWQoMikpIDogcGFyc2VGbG9hdChOdW1iZXIoZmluYWxOdW1iZXIpLnRvRml4ZWQoNSkpO1xyXG4gIGNvbnN0IHRpbGRlID0gdmFsdWUgPiAwID8gXCJ+IFwiIDogXCJcIjtcclxuICByZXR1cm4gXCJcIi5jb25jYXQoY3VycmVuY3kudG9Mb3dlckNhc2UoKSA9PT0gXCJ1c2RcIiB8fCBub1RpbGRlID8gXCJcIiA6IHRpbGRlKS5jb25jYXQoTnVtYmVyKHZhbHVlKSwgXCIgXCIpLmNvbmNhdChjdXJyZW5jeS50b1VwcGVyQ2FzZSgpKTtcclxufTtcclxuY29uc3QgYWRkcmVzc1NsaWNlciA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XHJcbiAgbGV0IHNsaWNlTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiA1O1xyXG5cclxuICBpZiAoYWRkcmVzcy5sZW5ndGggPCAxMSkge1xyXG4gICAgcmV0dXJuIGFkZHJlc3M7XHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIGFkZHJlc3MgIT09IFwic3RyaW5nXCIpIHJldHVybiBcIlwiO1xyXG4gIHJldHVybiBcIlwiLmNvbmNhdChhZGRyZXNzLnNsaWNlKDAsIHNsaWNlTGVuZ3RoKSwgXCIuLi5cIikuY29uY2F0KGFkZHJlc3Muc2xpY2UoLXNsaWNlTGVuZ3RoKSk7XHJcbn07XHJcbmNvbnN0IHNpZ25pZmljYW50RGlnaXRzID0gZnVuY3Rpb24gKG51bWJlcikge1xyXG4gIGxldCBwZXJjID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcclxuICBsZXQgbGVuZ3RoXyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMjtcclxuICBsZXQgaW5wdXQgPSAhQmlnTnVtYmVyLmlzQmlnTnVtYmVyKG51bWJlcikgPyBuZXcgQmlnTnVtYmVyKG51bWJlcikgOiBudW1iZXI7XHJcbiAgaWYgKGlucHV0LmlzWmVybygpKSByZXR1cm4gaW5wdXQ7XHJcblxyXG4gIGlmIChwZXJjKSB7XHJcbiAgICBpbnB1dCA9IGlucHV0LnRpbWVzKG5ldyBCaWdOdW1iZXIoMTAwKSk7XHJcbiAgfVxyXG5cclxuICBsZXQgZGVwdGg7XHJcblxyXG4gIGlmIChpbnB1dC5ndGUobmV3IEJpZ051bWJlcigxKSkpIHtcclxuICAgIGRlcHRoID0gbGVuZ3RoXztcclxuICB9IGVsc2Uge1xyXG4gICAgZGVwdGggPSBsZW5ndGhfIC0gMSArIE1hdGguY2VpbChNYXRoLmxvZzEwKG5ldyBCaWdOdW1iZXIoXCIxXCIpLmRpdihpbnB1dCkudG9OdW1iZXIoKSkpO1xyXG4gIH1cclxuXHJcbiAgY29uc3Qgc2hpZnQgPSBuZXcgQmlnTnVtYmVyKDEwKS5wb3cobmV3IEJpZ051bWJlcihkZXB0aCkpO1xyXG4gIGNvbnN0IHJvdW5kZWROdW1iZXIgPSBNYXRoLnJvdW5kKHNoaWZ0LnRpbWVzKGlucHV0KS50b051bWJlcigpKSAvIHNoaWZ0LnRvTnVtYmVyKCk7XHJcbiAgcmV0dXJuIHJvdW5kZWROdW1iZXI7XHJcbn07XHJcbmNvbnN0IGZvcm1hdERhdGUgPSBpbnB1dERhdGUgPT4ge1xyXG4gIGNvbnN0IG1vbnRoTGlzdCA9IFtcIkphblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk1heVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkF1Z1wiLCBcIlNlcFwiLCBcIk9jdFwiLCBcIk5vdlwiLCBcIkRlY1wiXTtcclxuICBjb25zdCBkYXRlID0gbmV3IERhdGUoaW5wdXREYXRlKTtcclxuICBjb25zdCBkYXkgPSBkYXRlLmdldERhdGUoKTtcclxuICBjb25zdCBtb250aCA9IG1vbnRoTGlzdFtkYXRlLmdldE1vbnRoKCldO1xyXG4gIGNvbnN0IHllYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCk7XHJcbiAgcmV0dXJuIFwiXCIuY29uY2F0KGRheSwgXCIgXCIpLmNvbmNhdChtb250aCwgXCIgXCIpLmNvbmNhdCh5ZWFyKTtcclxufTtcclxuY29uc3QgZm9ybWF0VGltZSA9IHRpbWUgPT4ge1xyXG4gIHJldHVybiBuZXcgRGF0ZSh0aW1lKS50b1RpbWVTdHJpbmcoKS5zbGljZSgwLCA4KTtcclxufTtcclxuLyoqXHJcbiAqIE5ldHdvcmsgdXRpbGl0aWVzXHJcbiAqL1xyXG5cclxuY29uc3QgdHJhbnNhY3Rpb25NYXRjaGVzTmV0d29yayA9ICh0cmFuc2FjdGlvbiwgY2hhaW5JZCkgPT4ge1xyXG4gIGlmICh0eXBlb2YgdHJhbnNhY3Rpb24uY2hhaW5JZCAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uLmNoYWluSWQgPT09IGNoYWluSWQ7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZmFsc2U7XHJcbn07XHJcbi8qKlxyXG4gKiBTaWduaW5nIHV0aWxzXHJcbiAqL1xyXG5cclxuY29uc3QgaGFzaE1lc3NhZ2UgPSBtZXNzYWdlID0+IHtcclxuICBjb25zdCBidWZmZXJlZE1lc3NhZ2UgPSBCdWZmZXIuZnJvbShtZXNzYWdlLCBcInV0ZjhcIik7XHJcbiAgY29uc3QgZWwgPSBoYXNoUGVyc29uYWxNZXNzYWdlKGJ1ZmZlcmVkTWVzc2FnZSk7XHJcbiAgcmV0dXJuIGVsO1xyXG59O1xyXG5jb25zdCBzaWduTWVzc2FnZSA9IChwcml2YXRlS2V5LCBkYXRhKSA9PiB7XHJcbiAgY29uc3QgcHJpdktleSA9IEJ1ZmZlci5mcm9tKHByaXZhdGVLZXksIFwiaGV4XCIpO1xyXG4gIGNvbnN0IG1lc3NhZ2UgPSBzdHJpcEhleFByZWZpeChkYXRhKTtcclxuICBjb25zdCBtc2dTaWcgPSBlY3NpZ24oQnVmZmVyLmZyb20obWVzc2FnZSwgXCJoZXhcIiksIHByaXZLZXkpO1xyXG4gIGNvbnN0IHJhd01zZ1NpZyA9IGNvbmNhdFNpZyhpbnRUb0J1ZmZlcihtc2dTaWcudiksIG1zZ1NpZy5yLCBtc2dTaWcucyk7XHJcbiAgcmV0dXJuIHJhd01zZ1NpZztcclxufTtcclxuLyoqXHJcbiAqIHBvcHVwIGhhbmRsZXIgdXRpbHNcclxuICovXHJcblxyXG5mdW5jdGlvbiBnZXRQb3B1cEZlYXR1cmVzKF9yZWYpIHtcclxuICBsZXQge1xyXG4gICAgd2lkdGg6IHcsXHJcbiAgICBoZWlnaHQ6IGhcclxuICB9ID0gX3JlZjtcclxuICAvLyBGaXhlcyBkdWFsLXNjcmVlbiBwb3NpdGlvbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTW9zdCBicm93c2VycyAgICAgIEZpcmVmb3hcclxuICBjb25zdCBkdWFsU2NyZWVuTGVmdCA9IHdpbmRvdy5zY3JlZW5MZWZ0ICE9PSB1bmRlZmluZWQgPyB3aW5kb3cuc2NyZWVuTGVmdCA6IHdpbmRvdy5zY3JlZW5YO1xyXG4gIGNvbnN0IGR1YWxTY3JlZW5Ub3AgPSB3aW5kb3cuc2NyZWVuVG9wICE9PSB1bmRlZmluZWQgPyB3aW5kb3cuc2NyZWVuVG9wIDogd2luZG93LnNjcmVlblk7XHJcbiAgY29uc3Qgd2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aCA/IHdpbmRvdy5pbm5lcldpZHRoIDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoID8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoIDogd2luZG93LnNjcmVlbi53aWR0aDtcclxuICBjb25zdCBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgPyB3aW5kb3cuaW5uZXJIZWlnaHQgOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0ID8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCA6IHdpbmRvdy5zY3JlZW4uaGVpZ2h0O1xyXG4gIGNvbnN0IHN5c3RlbVpvb20gPSAxOyAvLyBObyByZWxpYWJsZSBlc3RpbWF0ZVxyXG5cclxuICBjb25zdCBsZWZ0ID0gTWF0aC5hYnMoKHdpZHRoIC0gdykgLyAyIC8gc3lzdGVtWm9vbSArIGR1YWxTY3JlZW5MZWZ0KTtcclxuICBjb25zdCB0b3AgPSBNYXRoLmFicygoaGVpZ2h0IC0gaCkgLyAyIC8gc3lzdGVtWm9vbSArIGR1YWxTY3JlZW5Ub3ApO1xyXG4gIGNvbnN0IGZlYXR1cmVzID0gXCJ0aXRsZWJhcj0wLHRvb2xiYXI9MCxzdGF0dXM9MCxsb2NhdGlvbj0wLG1lbnViYXI9MCxoZWlnaHQ9XCIuY29uY2F0KGggLyBzeXN0ZW1ab29tLCBcIix3aWR0aD1cIikuY29uY2F0KHcgLyBzeXN0ZW1ab29tLCBcIix0b3A9XCIpLmNvbmNhdCh0b3AsIFwiLGxlZnQ9XCIpLmNvbmNhdChsZWZ0KTtcclxuICByZXR1cm4gZmVhdHVyZXM7XHJcbn1cclxuY29uc3QgYnJvYWRjYXN0Q2hhbm5lbE9wdGlvbnMgPSB7XHJcbiAgLy8gdHlwZTogJ2xvY2Fsc3RvcmFnZScsIC8vIChvcHRpb25hbCkgZW5mb3JjZSBhIHR5cGUsIG9uZU9mWyduYXRpdmUnLCAnaWRiJywgJ2xvY2Fsc3RvcmFnZScsICdub2RlJ11cclxuICB3ZWJXb3JrZXJTdXBwb3J0OiBmYWxzZSAvLyAob3B0aW9uYWwpIHNldCB0aGlzIHRvIGZhbHNlIGlmIHlvdSBrbm93IHRoYXQgeW91ciBjaGFubmVsIHdpbGwgbmV2ZXIgYmUgdXNlZCBpbiBhIFdlYldvcmtlciAoaW5jcmVhc2VzIHBlcmZvcm1hbmNlKVxyXG5cclxufTtcclxuZnVuY3Rpb24gZ2V0Q3VzdG9tRGV2aWNlSW5mbygpIHtcclxuICB2YXIgX25hdmlnYXRvcjtcclxuXHJcbiAgaWYgKChfbmF2aWdhdG9yID0gbmF2aWdhdG9yKSAhPT0gbnVsbCAmJiBfbmF2aWdhdG9yICE9PSB2b2lkIDAgJiYgX25hdmlnYXRvci5icmF2ZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgYnJvd3NlcjogXCJCcmF2ZVwiXHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG5jbGFzcyBVc2VyRXJyb3IgZXh0ZW5kcyBFcnJvciB7fVxyXG5jb25zdCBoYW5kbGVSZWRpcmVjdFBhcmFtZXRlcnMgPSAoaGFzaCwgcXVlcnlQYXJhbWV0ZXJzKSA9PiB7XHJcbiAgY29uc3QgaGFzaFBhcmFtZXRlcnMgPSB7fTtcclxuICBjb25zdCBoYXNoVXJsID0gbmV3IFVSTChcIlwiLmNvbmNhdCh3aW5kb3cubG9jYXRpb24ub3JpZ2luLCBcIi8/XCIpLmNvbmNhdChoYXNoLnNsaWNlKDEpKSk7XHJcbiAgaGFzaFVybC5zZWFyY2hQYXJhbXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xyXG4gICAgaGFzaFBhcmFtZXRlcnNba2V5XSA9IHZhbHVlO1xyXG4gIH0pO1xyXG4gIGxldCBpbnN0YW5jZVBhcmFtZXRlcnMgPSB7fTtcclxuICBsZXQgZXJyb3IgPSBcIlwiO1xyXG5cclxuICBpZiAoIXF1ZXJ5UGFyYW1ldGVycy53aW5kb3dJZCkge1xyXG4gICAgaWYgKE9iamVjdC5rZXlzKGhhc2hQYXJhbWV0ZXJzKS5sZW5ndGggPiAwICYmIGhhc2hQYXJhbWV0ZXJzLnN0YXRlKSB7XHJcbiAgICAgIGluc3RhbmNlUGFyYW1ldGVycyA9IEpTT04ucGFyc2Uod2luZG93LmF0b2IoZGVjb2RlVVJJQ29tcG9uZW50KGRlY29kZVVSSUNvbXBvbmVudChoYXNoUGFyYW1ldGVycy5zdGF0ZSkpKSkgfHwge307XHJcbiAgICAgIGVycm9yID0gaGFzaFBhcmFtZXRlcnMuZXJyb3JfZGVzY3JpcHRpb24gfHwgaGFzaFBhcmFtZXRlcnMuZXJyb3IgfHwgZXJyb3I7XHJcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5rZXlzKHF1ZXJ5UGFyYW1ldGVycykubGVuZ3RoID4gMCAmJiBxdWVyeVBhcmFtZXRlcnMuc3RhdGUpIHtcclxuICAgICAgaW5zdGFuY2VQYXJhbWV0ZXJzID0gSlNPTi5wYXJzZSh3aW5kb3cuYXRvYihkZWNvZGVVUklDb21wb25lbnQoZGVjb2RlVVJJQ29tcG9uZW50KHF1ZXJ5UGFyYW1ldGVycy5zdGF0ZSkpKSkgfHwge307XHJcbiAgICAgIGlmIChxdWVyeVBhcmFtZXRlcnMuZXJyb3IpIGVycm9yID0gcXVlcnlQYXJhbWV0ZXJzLmVycm9yO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGVycm9yLFxyXG4gICAgaW5zdGFuY2VQYXJhbWV0ZXJzLFxyXG4gICAgaGFzaFBhcmFtZXRlcnNcclxuICB9O1xyXG59O1xyXG5cclxuY2xhc3MgQmFzZUtleXJpbmdDb250cm9sbGVyIGV4dGVuZHMgQmFzZUNvbnRyb2xsZXIge1xyXG4gIGNvbnN0cnVjdG9yKF9yZWYpIHtcclxuICAgIHZhciBfc3RhdGUkd2FsbGV0cztcclxuXHJcbiAgICBsZXQge1xyXG4gICAgICBjb25maWcgPSB7fSxcclxuICAgICAgc3RhdGVcclxuICAgIH0gPSBfcmVmO1xyXG4gICAgc3VwZXIoe1xyXG4gICAgICBjb25maWcsXHJcbiAgICAgIHN0YXRlXHJcbiAgICB9KTtcclxuICAgIHRoaXMuZGVmYXVsdFN0YXRlID0ge1xyXG4gICAgICB3YWxsZXRzOiAoX3N0YXRlJHdhbGxldHMgPSBzdGF0ZS53YWxsZXRzKSAhPT0gbnVsbCAmJiBfc3RhdGUkd2FsbGV0cyAhPT0gdm9pZCAwID8gX3N0YXRlJHdhbGxldHMgOiBbXVxyXG4gICAgfTtcclxuICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xyXG4gIH0gLy8gZm9yIHNpZ25pbmcgYXV0aCBtZXNzYWdlXHJcblxyXG5cclxuICBzaWduQXV0aE1lc3NhZ2UoYWRkcmVzcywgbWVzc2FnZSkge1xyXG4gICAgY29uc3Qga2V5cmluZyA9IHRoaXMuc3RhdGUud2FsbGV0cy5maW5kKHggPT4geC5hZGRyZXNzID09PSBhZGRyZXNzKTtcclxuXHJcbiAgICBpZiAoIWtleXJpbmcpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwia2V5IGRvZXMgbm90IGV4aXN0XCIpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGhhc2hlZE1lc3NhZ2UgPSBoYXNoTWVzc2FnZShtZXNzYWdlKS50b1N0cmluZyhcImhleFwiKTtcclxuICAgIGNvbnN0IHJhd01lc3NhZ2VTaWcgPSBzaWduTWVzc2FnZShrZXlyaW5nLnByaXZhdGVLZXksIGhhc2hlZE1lc3NhZ2UpO1xyXG4gICAgcmV0dXJuIHJhd01lc3NhZ2VTaWc7XHJcbiAgfVxyXG5cclxufVxyXG5cclxuY29uc3QgUkVUUklBQkxFX0VSUk9SUyA9IFsvLyBpZ25vcmUgc2VydmVyIG92ZXJsb2FkIGVycm9yc1xyXG5cIkdhdGV3YXkgdGltZW91dFwiLCBcIkVUSU1FRE9VVFwiLCAvLyBpZ25vcmUgc2VydmVyIHNlbnQgaHRtbCBlcnJvciBwYWdlc1xyXG4vLyBvciB0cnVuY2F0ZWQganNvbiByZXNwb25zZXNcclxuXCJmYWlsZWQgdG8gcGFyc2UgcmVzcG9uc2UgYm9keVwiLCAvLyBpZ25vcmUgZXJyb3JzIHdoZXJlIGh0dHAgcmVxIGZhaWxlZCB0byBlc3RhYmxpc2hcclxuXCJGYWlsZWQgdG8gZmV0Y2hcIl07XHJcblxyXG5mdW5jdGlvbiBjaGVja0Zvckh0dHBFcnJvcnMoZmV0Y2hSZXMpIHtcclxuICAvLyBjaGVjayBmb3IgZXJyb3JzXHJcbiAgc3dpdGNoIChmZXRjaFJlcy5zdGF0dXMpIHtcclxuICAgIGNhc2UgNDA1OlxyXG4gICAgICB0aHJvdyBldGhFcnJvcnMucnBjLm1ldGhvZE5vdEZvdW5kKCk7XHJcblxyXG4gICAgY2FzZSA0MTg6XHJcbiAgICAgIHRocm93IGV0aEVycm9ycy5ycGMuaW50ZXJuYWwoe1xyXG4gICAgICAgIG1lc3NhZ2U6IFwiUmVxdWVzdCBpcyBiZWluZyByYXRlIGxpbWl0ZWQuXCJcclxuICAgICAgfSk7XHJcblxyXG4gICAgY2FzZSA1MDM6XHJcbiAgICBjYXNlIDUwNDpcclxuICAgICAgdGhyb3cgZXRoRXJyb3JzLnJwYy5pbnRlcm5hbCh7XHJcbiAgICAgICAgbWVzc2FnZTogXCJHYXRld2F5IHRpbWVvdXQuIFRoZSByZXF1ZXN0IHRvb2sgdG9vIGxvbmcgdG8gcHJvY2Vzcy5cIiArIFwiVGhpcyBjYW4gaGFwcGVuIHdoZW4gcXVlcnlpbmcgb3ZlciB0b28gd2lkZSBhIGJsb2NrIHJhbmdlLlwiXHJcbiAgICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gdGltZW91dChkdXJhdGlvbikge1xyXG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZHVyYXRpb24pKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcGFyc2VSZXNwb25zZShmZXRjaFJlcywgYm9keSkge1xyXG4gIC8vIGNoZWNrIGZvciBlcnJvciBjb2RlXHJcbiAgaWYgKGZldGNoUmVzLnN0YXR1cyAhPT0gMjAwKSB7XHJcbiAgICB0aHJvdyBldGhFcnJvcnMucnBjLmludGVybmFsKHtcclxuICAgICAgbWVzc2FnZTogXCJOb24tMjAwIHN0YXR1cyBjb2RlOiAnXCIuY29uY2F0KGZldGNoUmVzLnN0YXR1cywgXCInXCIpLFxyXG4gICAgICBkYXRhOiBib2R5XHJcbiAgICB9KTtcclxuICB9IC8vIGNoZWNrIGZvciBycGMgZXJyb3JcclxuXHJcblxyXG4gIGlmIChib2R5LmVycm9yKSB7XHJcbiAgICB0aHJvdyBldGhFcnJvcnMucnBjLmludGVybmFsKHtcclxuICAgICAgZGF0YTogYm9keS5lcnJvclxyXG4gICAgfSk7XHJcbiAgfSAvLyByZXR1cm4gc3VjY2Vzc2Z1bCByZXN1bHRcclxuXHJcblxyXG4gIHJldHVybiBib2R5LnJlc3VsdDtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlRmV0Y2hDb25maWdGcm9tUmVxKF9yZWYpIHtcclxuICBsZXQge1xyXG4gICAgcmVxLFxyXG4gICAgcnBjVGFyZ2V0LFxyXG4gICAgb3JpZ2luSHR0cEhlYWRlcktleVxyXG4gIH0gPSBfcmVmO1xyXG4gIGNvbnN0IHBhcnNlZFVybCA9IG5ldyBVUkwocnBjVGFyZ2V0KTsgLy8gcHJlcGFyZSBwYXlsb2FkXHJcbiAgLy8gY29weSBvbmx5IGNhbm9uaWNhbCBqc29uIHJwYyBwcm9wZXJ0aWVzXHJcblxyXG4gIGNvbnN0IHBheWxvYWQgPSB7XHJcbiAgICBpZDogcmVxLmlkLFxyXG4gICAganNvbnJwYzogcmVxLmpzb25ycGMsXHJcbiAgICBtZXRob2Q6IHJlcS5tZXRob2QsXHJcbiAgICBwYXJhbXM6IHJlcS5wYXJhbXNcclxuICB9OyAvLyBleHRyYWN0ICdvcmlnaW4nIHBhcmFtZXRlciBmcm9tIHJlcXVlc3RcclxuXHJcbiAgY29uc3Qgb3JpZ2luRG9tYWluID0gcmVxLm9yaWdpbjsgLy8gc2VyaWFsaXplIHJlcXVlc3QgYm9keVxyXG5cclxuICBjb25zdCBzZXJpYWxpemVkUGF5bG9hZCA9IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpOyAvLyBjb25maWd1cmUgZmV0Y2ggcGFyYW1zXHJcblxyXG4gIGNvbnN0IGZldGNoUGFyYW1zID0ge1xyXG4gICAgbWV0aG9kOiBcIlBPU1RcIixcclxuICAgIGhlYWRlcnM6IHtcclxuICAgICAgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcclxuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcclxuICAgIH0sXHJcbiAgICBib2R5OiBzZXJpYWxpemVkUGF5bG9hZFxyXG4gIH07IC8vIG9wdGlvbmFsOiBhZGQgcmVxdWVzdCBvcmlnaW4gYXMgaGVhZGVyXHJcblxyXG4gIGlmIChvcmlnaW5IdHRwSGVhZGVyS2V5ICYmIG9yaWdpbkRvbWFpbikge1xyXG4gICAgZmV0Y2hQYXJhbXMuaGVhZGVyc1tvcmlnaW5IdHRwSGVhZGVyS2V5XSA9IG9yaWdpbkRvbWFpbjtcclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBmZXRjaFVybDogcGFyc2VkVXJsLmhyZWYsXHJcbiAgICBmZXRjaFBhcmFtc1xyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlRmV0Y2hNaWRkbGV3YXJlKF9yZWYyKSB7XHJcbiAgbGV0IHtcclxuICAgIHJwY1RhcmdldCxcclxuICAgIG9yaWdpbkh0dHBIZWFkZXJLZXlcclxuICB9ID0gX3JlZjI7XHJcbiAgcmV0dXJuIGNyZWF0ZUFzeW5jTWlkZGxld2FyZShhc3luYyAocmVxLCByZXMsIF9uZXh0KSA9PiB7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgIGZldGNoVXJsLFxyXG4gICAgICBmZXRjaFBhcmFtc1xyXG4gICAgfSA9IGNyZWF0ZUZldGNoQ29uZmlnRnJvbVJlcSh7XHJcbiAgICAgIHJlcSxcclxuICAgICAgcnBjVGFyZ2V0LFxyXG4gICAgICBvcmlnaW5IdHRwSGVhZGVyS2V5XHJcbiAgICB9KTsgLy8gYXR0ZW1wdCByZXF1ZXN0IG11bHRpcGxlIHRpbWVzXHJcblxyXG4gICAgY29uc3QgbWF4QXR0ZW1wdHMgPSA1O1xyXG4gICAgY29uc3QgcmV0cnlJbnRlcnZhbCA9IDEwMDA7XHJcblxyXG4gICAgZm9yIChsZXQgYXR0ZW1wdCA9IDA7IGF0dGVtcHQgPCBtYXhBdHRlbXB0czsgYXR0ZW1wdCsrKSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgZmV0Y2hSZXMgPSBhd2FpdCBmZXRjaChmZXRjaFVybCwgZmV0Y2hQYXJhbXMpOyAvLyBjaGVjayBmb3IgaHR0cCBlcnJyb3JzXHJcblxyXG4gICAgICAgIGNoZWNrRm9ySHR0cEVycm9ycyhmZXRjaFJlcyk7IC8vIHBhcnNlIHJlc3BvbnNlIGJvZHlcclxuXHJcbiAgICAgICAgY29uc3QgZmV0Y2hCb2R5ID0gYXdhaXQgZmV0Y2hSZXMuanNvbigpO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlUmVzcG9uc2UoZmV0Y2hSZXMsIGZldGNoQm9keSk7IC8vIHNldCByZXN1bHQgYW5kIGV4aXQgcmV0cnkgbG9vcFxyXG5cclxuICAgICAgICByZXMucmVzdWx0ID0gcmVzdWx0O1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgY29uc3QgZXJyTXNnID0gZXJyLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgY29uc3QgaXNSZXRyaWFibGUgPSBSRVRSSUFCTEVfRVJST1JTLnNvbWUocGhyYXNlID0+IGVyck1zZy5pbmNsdWRlcyhwaHJhc2UpKTsgLy8gcmUtdGhyb3cgZXJyb3IgaWYgbm90IHJldHJpYWJsZVxyXG5cclxuICAgICAgICBpZiAoIWlzUmV0cmlhYmxlKSB7XHJcbiAgICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IC8vIGRlbGF5IGJlZm9yZSByZXRyeWluZ1xyXG5cclxuXHJcbiAgICAgIGF3YWl0IHRpbWVvdXQocmV0cnlJbnRlcnZhbCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUxvZ2dlck1pZGRsZXdhcmUob3B0aW9ucykge1xyXG4gIHJldHVybiBmdW5jdGlvbiBsb2dnZXJNaWRkbGV3YXJlKHJlcXVlc3QsIHJlc3BvbnNlLCBuZXh0KSB7XHJcbiAgICBuZXh0KGNhbGxiYWNrID0+IHtcclxuICAgICAgaWYgKHJlc3BvbnNlLmVycm9yKSB7XHJcbiAgICAgICAgbG9nLndhcm4oXCJFcnJvciBpbiBSUEMgcmVzcG9uc2U6XFxuXCIsIHJlc3BvbnNlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHJlcXVlc3QuaXNUb3J1c0ludGVybmFsKSByZXR1cm47XHJcbiAgICAgIGxvZy5pbmZvKFwiUlBDIChcIi5jb25jYXQob3B0aW9ucy5vcmlnaW4sIFwiKTpcIiksIHJlcXVlc3QsIFwiLT5cIiwgcmVzcG9uc2UpO1xyXG4gICAgICBjYWxsYmFjaygpO1xyXG4gICAgfSk7XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlT3JpZ2luTWlkZGxld2FyZShvcHRpb25zKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uIG9yaWdpbk1pZGRsZXdhcmUocmVxdWVzdCwgXywgbmV4dCkge1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgIHJlcXVlc3Qub3JpZ2luID0gb3B0aW9ucy5vcmlnaW47XHJcbiAgICBuZXh0KCk7XHJcbiAgfTtcclxufVxyXG5cclxuY2xhc3MgQnJvYWRjYXN0Q2hhbm5lbEhhbmRsZXIge1xyXG4gIGNvbnN0cnVjdG9yKGNoYW5uZWxQcmVmaXgpIHtcclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJjXCIsIHZvaWQgMCk7XHJcblxyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY2hhbm5lbFwiLCB2b2lkIDApO1xyXG5cclxuICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaCk7XHJcbiAgICBjb25zdCBpbnN0YW5jZUlkID0gcXVlcnlQYXJhbWV0ZXJzLmdldChcImluc3RhbmNlSWRcIik7XHJcbiAgICB0aGlzLmNoYW5uZWwgPSBcIlwiLmNvbmNhdChjaGFubmVsUHJlZml4LCBcIl9cIikuY29uY2F0KGluc3RhbmNlSWQpO1xyXG4gICAgdGhpcy5iYyA9IG5ldyBCcm9hZGNhc3RDaGFubmVsKHRoaXMuY2hhbm5lbCwgYnJvYWRjYXN0Q2hhbm5lbE9wdGlvbnMpO1xyXG4gIH1cclxuXHJcbiAgZ2V0TWVzc2FnZUZyb21DaGFubmVsKCkge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgdGhpcy5iYy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBhc3luYyBldiA9PiB7XHJcbiAgICAgICAgdGhpcy5iYy5jbG9zZSgpO1xyXG5cclxuICAgICAgICBpZiAoZXYuZXJyb3IpIHtcclxuICAgICAgICAgIHJlamVjdChldi5lcnJvcik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJlc29sdmUoZXYuZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgdGhpcy5iYy5wb3N0TWVzc2FnZSh7XHJcbiAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgdHlwZTogUE9QVVBfTE9BREVEXHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbn1cclxuXHJcbmNsYXNzIFN0cmVhbVdpbmRvdyBleHRlbmRzIEJhc2VDb250cm9sbGVyIHtcclxuICAvLyBpZiB3aW5kb3cgaGFzIGJlZW4gY2xvc2VkIGJ5IHVzZXJzXHJcbiAgY29uc3RydWN0b3IoX3JlZikge1xyXG4gICAgbGV0IHtcclxuICAgICAgY29uZmlnLFxyXG4gICAgICBzdGF0ZSA9IHt9XHJcbiAgICB9ID0gX3JlZjtcclxuICAgIHN1cGVyKHtcclxuICAgICAgY29uZmlnLFxyXG4gICAgICBzdGF0ZVxyXG4gICAgfSk7XHJcblxyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY2xvc2VkXCIsIGZhbHNlKTtcclxuXHJcbiAgICB0aGlzLmluaXRpYWxpemUoKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIG9wZW4oKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICBjb25zdCB7XHJcbiAgICAgICAgY29tbXVuaWNhdGlvbkVuZ2luZSxcclxuICAgICAgICBjb21tdW5pY2F0aW9uV2luZG93TWFuYWdlclxyXG4gICAgICB9ID0gdGhpcy5jb25maWc7XHJcbiAgICAgIGNvbW11bmljYXRpb25XaW5kb3dNYW5hZ2VyLm9uY2UoXCJcIi5jb25jYXQodGhpcy5zdGF0ZS53aW5kb3dJZCwgXCI6Y2xvc2VkXCIpLCAoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xyXG4gICAgICB9KTsgLy8gV2luZG93IGlzIG5vdCBvcGVuIHlldFxyXG5cclxuICAgICAgaWYgKCF0aGlzLnN0YXRlLndpbmRvd0lkKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoe1xyXG4gICAgICAgICAgd2luZG93SWQ6IHJhbmRvbUlkKClcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb21tdW5pY2F0aW9uV2luZG93TWFuYWdlci5vbmNlKFwiXCIuY29uY2F0KHRoaXMuc3RhdGUud2luZG93SWQsIFwiOm9wZW5lZFwiKSwgKCkgPT4ge1xyXG4gICAgICAgICAgcmVzb2x2ZSh0aGlzKTtcclxuICAgICAgICB9KTsgLy8gVGVsbCB0aGUgb3RoZXIgcGFydHkgdG8gY3JlYXRlIGEgd2luZG93IGJ5IHByb21wdGluZyB0aGUgdXNlciB0byBjbGljayBvbiBzb21ldGhpbmdcclxuXHJcbiAgICAgICAgY29tbXVuaWNhdGlvbkVuZ2luZS5lbWl0KFwibm90aWZpY2F0aW9uXCIsIHtcclxuICAgICAgICAgIG1ldGhvZDogQ09NTVVOSUNBVElPTl9OT1RJRklDQVRJT05TLkNSRUFURV9XSU5ET1csXHJcbiAgICAgICAgICBwYXJhbXM6IHtcclxuICAgICAgICAgICAgd2luZG93SWQ6IHRoaXMuc3RhdGUud2luZG93SWQsXHJcbiAgICAgICAgICAgIHVybDogdGhpcy5zdGF0ZS51cmwuaHJlZlxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIFNlbmQgdGhpcyB3aW5kb3cgd2l0aCBgd2luZG93SWRgIHRoZSB1cmwgdG8gb3BlbiB2aWEgYmNcclxuICAgICAgICBjb25zdCBiYyA9IG5ldyBCcm9hZGNhc3RDaGFubmVsKHRoaXMuc3RhdGUud2luZG93SWQsIGJyb2FkY2FzdENoYW5uZWxPcHRpb25zKTtcclxuICAgICAgICBsZXQgd3JpdGVJbnRlcnZhbCA9IG51bGw7XHJcbiAgICAgICAgYmMuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgYXN5bmMgZXYgPT4ge1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgbG9nLmluZm8oZXYsIFwicmVjZWl2aW5nIGRhdGEgb24gY2hhbm5lbDogXCIuY29uY2F0KGJjLm5hbWUpKTtcclxuICAgICAgICAgICAgY29uc3Qge1xyXG4gICAgICAgICAgICAgIGVycm9yXHJcbiAgICAgICAgICAgIH0gPSBldjtcclxuXHJcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgICAgICAgIC8vIFBvcHVwIHNheXMgc29tZSBlcnJvci4gc28sIHdlIHNheSBpdCdzIG5vdCByZWFsbHkgb3BlbmVkXHJcbiAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihlcnJvcikpO1xyXG4gICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uc3Qge1xyXG4gICAgICAgICAgICAgIG1lc3NhZ2VcclxuICAgICAgICAgICAgfSA9IGV2LmRhdGE7XHJcblxyXG4gICAgICAgICAgICBpZiAobWVzc2FnZSA9PT0gUE9QVVBfTE9BREVEKSB7XHJcbiAgICAgICAgICAgICAgaWYgKHdyaXRlSW50ZXJ2YWwpIHdpbmRvdy5jbGVhckludGVydmFsKHdyaXRlSW50ZXJ2YWwpO1xyXG4gICAgICAgICAgICAgIGF3YWl0IGJjLnBvc3RNZXNzYWdlKHtcclxuICAgICAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICAgICAgdXJsOiB0aGlzLnN0YXRlLnVybC5ocmVmLFxyXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIlwiIC8vIE5vIG5lZWQgb2YgYSBtc2dcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzKTtcclxuICAgICAgICAgICAgICBiYy5jbG9zZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICBiYy5jbG9zZSgpOyAvLyBTb21ldGhpbmcgd2VudCB3cm9uZy4gc28sIHdlIGNsb3NlIHRoYXQgd2luZG93XHJcblxyXG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7IC8vIFdlIGRvbid0IGtub3cgaWYgdGhlIG90aGVyIGVuZCBpcyByZWFkeSB0byByZWNlaXZlIHRoaXMgbXNnLiBTbywgd2Uga2VlcCB3cml0aW5nIHVudGlsIGl0IHJlY2VpdmVzIGFuZCBzZW5kcyBiYWNrIHNvbWV0aGluZ1xyXG5cclxuICAgICAgICB3cml0ZUludGVydmFsID0gd2luZG93LnNldEludGVydmFsKCgpID0+IHtcclxuICAgICAgICAgIGJjLnBvc3RNZXNzYWdlKHtcclxuICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IFNFVFVQX0NPTVBMRVRFXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sIDIwMCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgY2xvc2UoKSB7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgIGNvbW11bmljYXRpb25FbmdpbmVcclxuICAgIH0gPSB0aGlzLmNvbmZpZztcclxuICAgIGNvbW11bmljYXRpb25FbmdpbmUuZW1pdChcIm5vdGlmaWNhdGlvblwiLCB7XHJcbiAgICAgIG1ldGhvZDogQ09NTVVOSUNBVElPTl9OT1RJRklDQVRJT05TLkNMT1NFX1dJTkRPVyxcclxuICAgICAgcGFyYW1zOiB7XHJcbiAgICAgICAgd2luZG93SWQ6IHRoaXMuc3RhdGUud2luZG93SWRcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxufVxyXG5cclxuLypcclxuU2NlbmFyaW9zOlxyXG4xLiBPcGVuIGEgbm9ybWFsIHBvcHVwIHdpbmRvdyBhbmQgbm8gY29tbXVuaWNhdGlvbiB3aXRoIGl0IC0gVXNlIFBvcHVwSGFuZGxlclxyXG4yLiBPcGVuIGEgcG9wdXAgd2luZG93IGFuZCBjb21tdW5pY2F0ZSB3aXRoIGl0IC0gVXNlIFBvcHVwV2l0aEJjSGFuZGxlciAoY2FuIGluaXRpYXRlIGNvbW11bmljYXRpb24gYnkgd2FpdGluZyBmb3Igd2luZG93IHRvIG9wZW4gb3Igbm90KVxyXG5cclxuMy4gSWYgd2luZG93IGlzIGFscmVhZHkgb3BlbmVkLCBwYXNzIGluIHdpbmRvd0lkIHRvIHRoZSBwb3B1cCBoYW5kbGVyLlxyXG4gICBUaGlzIHdpbGwgZXN0YWJsaXNoIGNvbW11bmljYXRpb24gd2l0aCB0aGUgcG9wdXAgd2luZG93IGFuZCBzZW5kcyBpdCBhIG5ldyB1cmwgdG8gcmVkaXJlY3QgdG9cclxuXHJcblxyXG5JZiB5b3UncmUgdHJ5aW5nIHRvIG9wZW4gYSB3aW5kb3cgYW5kIGl0IGdldHMgYmxvY2tlZCAoaGFwcGVucyBpZiB5b3UncmUgaW4gaWZyYW1lIG9yIGRlbGF5IGIvdyBjbGljayBhbmQgb3BlbmluZyB3aW5kb3cpLFxyXG5TdHJlYW1XaW5kb3cgaXMgaW52b2tlZCBhbmQgaXQgd3JpdGVzIGluIGEgY2hhbm5lbCB0byBkaXNwbGF5IGEgbWVzc2FnZSB0byB0aGUgdXNlclxyXG5cclxuT25jZSB1c2VyIGNsaWNrcyBvbiB0aGF0IG1vZGFsL2RpYWxvZywgd2UgcHJlLW9wZW4gdGhlIHdpbmRvdyBhbmQgcGFzcyBpbiB0aGUgd2luZG93SWQgKGdvZXMgdG8gMylcclxuKi9cclxuXHJcbi8qKlxyXG4gKiBIYW5kbGVzIHBvcHVwIHdpbmRvdyBtYW5hZ2VtZW50LlxyXG4gKiBGb3IgYnJvYWRjYXN0IGNoYW5uZWwgY29tbXVuaWNhdGlvbiwgdXNlIHVybCB3aXRoIGBpbnN0YW5jZUlkYCBjb2RlZCBpbnRvIHN0YXRlIHBhcmFtZXRlci5cclxuICogVGhpcyBzdGF0ZSBwYXJhbWV0ZXIgd2lsbCBiZSBwYXNzZWQgYWNyb3NzIHJlZGlyZWN0cyBhY2NvcmRpbmcgdG8gT0F1dGggc3BlYy5cclxuICovXHJcblxyXG5jbGFzcyBQb3B1cEhhbmRsZXIgZXh0ZW5kcyBCYXNlQ29udHJvbGxlciB7XHJcbiAgY29uc3RydWN0b3IoX3JlZikge1xyXG4gICAgbGV0IHtcclxuICAgICAgY29uZmlnLFxyXG4gICAgICBzdGF0ZVxyXG4gICAgfSA9IF9yZWY7XHJcbiAgICBzdXBlcih7XHJcbiAgICAgIGNvbmZpZyxcclxuICAgICAgc3RhdGVcclxuICAgIH0pOyAvLyB0aGlzLmlkID0gcmFuZG9tSWQoKVxyXG4gICAgLy8gQWRkIGluIGRhcHAgc3RvcmFnZSBrZXkgdG8gYWxsIHBvcHVwcyBhcyBhIGhhc2ggcGFyYW1ldGVyXHJcblxyXG4gICAgdGhpcy5kZWZhdWx0Q29uZmlnID0ge1xyXG4gICAgICBkYXBwU3RvcmFnZUtleTogXCJcIixcclxuICAgICAgZmVhdHVyZXM6IGdldFBvcHVwRmVhdHVyZXMoRkVBVFVSRVNfREVGQVVMVF9QT1BVUF9XSU5ET1cpLFxyXG4gICAgICB0YXJnZXQ6IFwiX2JsYW5rXCIsXHJcbiAgICAgIGNvbW11bmljYXRpb25FbmdpbmU6IG51bGwsXHJcbiAgICAgIGNvbW11bmljYXRpb25XaW5kb3dNYW5hZ2VyOiBudWxsXHJcbiAgICB9O1xyXG4gICAgdGhpcy5kZWZhdWx0U3RhdGUgPSB7XHJcbiAgICAgIHdpbmRvd1RpbWVyOiBudWxsLFxyXG4gICAgICB3aW5kb3c6IG51bGwsXHJcbiAgICAgIGlDbG9zZWRXaW5kb3c6IGZhbHNlLFxyXG4gICAgICB3aW5kb3dJZDogXCJcIixcclxuICAgICAgdXJsOiBzdGF0ZS51cmxcclxuICAgIH07XHJcbiAgICB0aGlzLmluaXRpYWxpemUoKTtcclxuXHJcbiAgICB0aGlzLl9zZXR1cFRpbWVyKCk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBvcGVuKCkge1xyXG4gICAgLy8gaWYgd2luZG93IGlzIGFscmVhZHkgb3BlblxyXG4gICAgY29uc3Qge1xyXG4gICAgICB0YXJnZXQsXHJcbiAgICAgIGZlYXR1cmVzLFxyXG4gICAgICBkYXBwU3RvcmFnZUtleSxcclxuICAgICAgY29tbXVuaWNhdGlvbkVuZ2luZSxcclxuICAgICAgY29tbXVuaWNhdGlvbldpbmRvd01hbmFnZXJcclxuICAgIH0gPSB0aGlzLmNvbmZpZztcclxuICAgIGNvbnN0IHtcclxuICAgICAgd2luZG93SWQsXHJcbiAgICAgIHVybFxyXG4gICAgfSA9IHRoaXMuc3RhdGU7XHJcblxyXG4gICAgaWYgKGRhcHBTdG9yYWdlS2V5KSB7XHJcbiAgICAgIGNvbnN0IHVybEhhc2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHVybC5oYXNoLnNsaWNlKDEpKTtcclxuICAgICAgdXJsSGFzaFBhcmFtcy5hcHBlbmQoXCJkYXBwU3RvcmFnZUtleVwiLCBkYXBwU3RvcmFnZUtleSk7XHJcbiAgICAgIHVybC5oYXNoID0gdXJsSGFzaFBhcmFtcy50b1N0cmluZygpO1xyXG4gICAgICB0aGlzLnVwZGF0ZSh7XHJcbiAgICAgICAgdXJsXHJcbiAgICAgIH0pO1xyXG4gICAgfSAvLyBObyB3aW5kb3cgaGFzIGJlZW4gcHJlLW9wZW5lZFxyXG5cclxuXHJcbiAgICBpZiAoIXdpbmRvd0lkKSB7XHJcbiAgICAgIC8vIHRyeSB0byBvcGVuIGEgd2luZG93IGZpcnN0XHJcbiAgICAgIGxldCBsb2NhbFdpbmRvdyA9IHdpbmRvdy5vcGVuKHVybC5ocmVmLCB0YXJnZXQsIGZlYXR1cmVzKTtcclxuXHJcbiAgICAgIGlmICghbG9jYWxXaW5kb3cpIHtcclxuICAgICAgICAvLyBpZiBpdCdzIGJsb2NrZWQsIG9wZW4gU3RyZWFtV2luZG93XHJcbiAgICAgICAgbG9jYWxXaW5kb3cgPSBuZXcgU3RyZWFtV2luZG93KHtcclxuICAgICAgICAgIGNvbmZpZzoge1xyXG4gICAgICAgICAgICBjb21tdW5pY2F0aW9uRW5naW5lLFxyXG4gICAgICAgICAgICBjb21tdW5pY2F0aW9uV2luZG93TWFuYWdlclxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHN0YXRlOiB7XHJcbiAgICAgICAgICAgIHVybFxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxvY2FsV2luZG93Lm9wZW4oKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy51cGRhdGUoe1xyXG4gICAgICAgIHdpbmRvdzogbG9jYWxXaW5kb3dcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH0gLy8gQSB3aW5kb3cgaGFzIGJlZW4gcHJlLW9wZW5lZCB3aXRoIGEgcXVlcnkgcGFyYW1ldGVyIGB3aW5kb3dJZGBcclxuXHJcblxyXG4gICAgY29uc3QgbG9jYWxXaW5kb3cgPSBuZXcgU3RyZWFtV2luZG93KHtcclxuICAgICAgY29uZmlnOiB7XHJcbiAgICAgICAgY29tbXVuaWNhdGlvbkVuZ2luZSxcclxuICAgICAgICBjb21tdW5pY2F0aW9uV2luZG93TWFuYWdlclxyXG4gICAgICB9LFxyXG4gICAgICBzdGF0ZToge1xyXG4gICAgICAgIHVybCxcclxuICAgICAgICB3aW5kb3dJZFxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHRoaXMudXBkYXRlKHtcclxuICAgICAgd2luZG93OiBsb2NhbFdpbmRvd1xyXG4gICAgfSk7XHJcbiAgICBhd2FpdCBsb2NhbFdpbmRvdy5vcGVuKCk7XHJcbiAgfVxyXG5cclxuICBjbG9zZSgpIHtcclxuICAgIHRoaXMudXBkYXRlKHtcclxuICAgICAgaUNsb3NlZFdpbmRvdzogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgIHdpbmRvd1xyXG4gICAgfSA9IHRoaXMuc3RhdGU7XHJcbiAgICBpZiAod2luZG93KSB3aW5kb3cuY2xvc2UoKTtcclxuICB9XHJcblxyXG4gIF9zZXR1cFRpbWVyKCkge1xyXG4gICAgY29uc3QgdGltZXIgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoKCkgPT4ge1xyXG4gICAgICBjb25zdCB7XHJcbiAgICAgICAgd2luZG93LFxyXG4gICAgICAgIHdpbmRvd1RpbWVyLFxyXG4gICAgICAgIGlDbG9zZWRXaW5kb3dcclxuICAgICAgfSA9IHRoaXMuc3RhdGU7XHJcblxyXG4gICAgICBpZiAod2luZG93ICYmIHdpbmRvdy5jbG9zZWQpIHtcclxuICAgICAgICBpZiAod2luZG93VGltZXIpIGNsZWFySW50ZXJ2YWwod2luZG93VGltZXIpO1xyXG5cclxuICAgICAgICBpZiAoIWlDbG9zZWRXaW5kb3cpIHtcclxuICAgICAgICAgIHRoaXMuZW1pdChcImNsb3NlXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy51cGRhdGUoe1xyXG4gICAgICAgICAgaUNsb3NlZFdpbmRvdzogZmFsc2UsXHJcbiAgICAgICAgICB3aW5kb3c6IG51bGxcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHdpbmRvdyA9PT0gbnVsbCAmJiB3aW5kb3dUaW1lcikgY2xlYXJJbnRlcnZhbCh3aW5kb3dUaW1lcik7XHJcbiAgICB9LCA1MDApO1xyXG4gICAgdGhpcy51cGRhdGUoe1xyXG4gICAgICB3aW5kb3dUaW1lcjogdGltZXJcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbn1cclxuXHJcbmNsYXNzIFBvcHVwU3RvcmVDaGFubmVsIHtcclxuICBjb25zdHJ1Y3RvcihfcmVmKSB7XHJcbiAgICBsZXQge1xyXG4gICAgICBpbnN0YW5jZUlkLFxyXG4gICAgICBoYW5kbGVMb2dvdXQsXHJcbiAgICAgIGhhbmRsZUFjY291bnRJbXBvcnQsXHJcbiAgICAgIGhhbmRsZU5ldHdvcmtDaGFuZ2UsXHJcbiAgICAgIGhhbmRsZVNlbGVjdGVkQWRkcmVzc0NoYW5nZVxyXG4gICAgfSA9IF9yZWY7XHJcblxyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaGFuZGxlTG9nb3V0XCIsIHZvaWQgMCk7XHJcblxyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaGFuZGxlQWNjb3VudEltcG9ydFwiLCB2b2lkIDApO1xyXG5cclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhbmRsZU5ldHdvcmtDaGFuZ2VcIiwgdm9pZCAwKTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJoYW5kbGVTZWxlY3RlZEFkZHJlc3NDaGFuZ2VcIiwgdm9pZCAwKTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbnN0YW5jZUlkXCIsIHZvaWQgMCk7XHJcblxyXG4gICAgdGhpcy5pbnN0YW5jZUlkID0gaW5zdGFuY2VJZDtcclxuICAgIHRoaXMuaGFuZGxlTG9nb3V0ID0gaGFuZGxlTG9nb3V0O1xyXG4gICAgdGhpcy5oYW5kbGVBY2NvdW50SW1wb3J0ID0gaGFuZGxlQWNjb3VudEltcG9ydDtcclxuICAgIHRoaXMuaGFuZGxlTmV0d29ya0NoYW5nZSA9IGhhbmRsZU5ldHdvcmtDaGFuZ2U7XHJcbiAgICB0aGlzLmhhbmRsZVNlbGVjdGVkQWRkcmVzc0NoYW5nZSA9IGhhbmRsZVNlbGVjdGVkQWRkcmVzc0NoYW5nZTtcclxuICB9XHJcblxyXG4gIHNldHVwU3RvcmVDaGFubmVscygpIHtcclxuICAgIHRoaXMubG9nb3V0Q2hhbm5lbCgpO1xyXG4gICAgdGhpcy5pbXBvcnRBY2NvdW50Q2hhbm5lbCgpO1xyXG4gICAgdGhpcy5uZXR3b3JrQ2hhbmdlQ2hhbm5lbCgpO1xyXG4gICAgdGhpcy5zZWxlY3RlZEFkZHJlc3NDaGFuZ2VDaGFubmVsKCk7XHJcbiAgfVxyXG5cclxuICBsb2dvdXRDaGFubmVsKCkge1xyXG4gICAgY29uc3QgbG9nb3V0Q2hhbm5lbCA9IG5ldyBCcm9hZGNhc3RDaGFubmVsKFwiXCIuY29uY2F0KEJST0FEQ0FTVF9DSEFOTkVMUy5XQUxMRVRfTE9HT1VUX0NIQU5ORUwsIFwiX1wiKS5jb25jYXQodGhpcy5pbnN0YW5jZUlkKSwgYnJvYWRjYXN0Q2hhbm5lbE9wdGlvbnMpO1xyXG4gICAgbG9nb3V0Q2hhbm5lbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBldiA9PiB7XHJcbiAgICAgIHZhciBfZXYkZGF0YTtcclxuXHJcbiAgICAgIGxvZy5pbmZvKFwicmVjZWl2ZWQgbG9nb3V0IG1lc3NhZ2VcIiwgZXYpO1xyXG5cclxuICAgICAgaWYgKCFldi5lcnJvciAmJiAoKF9ldiRkYXRhID0gZXYuZGF0YSkgPT09IG51bGwgfHwgX2V2JGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ldiRkYXRhLnR5cGUpID09PSBCUk9BRENBU1RfQ0hBTk5FTFNfTVNHUy5MT0dPVVQpIHtcclxuICAgICAgICBsb2cuaW5mbyhcIkxvZ2dpbmcgT3V0XCIpO1xyXG4gICAgICAgIHRoaXMuaGFuZGxlTG9nb3V0KCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgaW1wb3J0QWNjb3VudENoYW5uZWwoKSB7XHJcbiAgICBjb25zdCB3YWxsZXRBY2NvdW50SW1wb3J0Q2hhbm5lbCA9IG5ldyBCcm9hZGNhc3RDaGFubmVsKFwiXCIuY29uY2F0KEJST0FEQ0FTVF9DSEFOTkVMUy5XQUxMRVRfQUNDT1VOVF9JTVBPUlRfQ0hBTk5FTCwgXCJfXCIpLmNvbmNhdCh0aGlzLmluc3RhbmNlSWQpLCBicm9hZGNhc3RDaGFubmVsT3B0aW9ucyk7XHJcbiAgICB3YWxsZXRBY2NvdW50SW1wb3J0Q2hhbm5lbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBldiA9PiB7XHJcbiAgICAgIHZhciBfZXYkZGF0YTI7XHJcblxyXG4gICAgICBpZiAoIWV2LmVycm9yICYmICgoX2V2JGRhdGEyID0gZXYuZGF0YSkgPT09IG51bGwgfHwgX2V2JGRhdGEyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZXYkZGF0YTIudHlwZSkgPT09IEJST0FEQ0FTVF9DSEFOTkVMU19NU0dTLkFDQ09VTlRfSU1QT1JURUQpIHtcclxuICAgICAgICB2YXIgX2V2JGRhdGEzO1xyXG5cclxuICAgICAgICB0aGlzLmhhbmRsZUFjY291bnRJbXBvcnQoKF9ldiRkYXRhMyA9IGV2LmRhdGEpID09PSBudWxsIHx8IF9ldiRkYXRhMyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2V2JGRhdGEzLnByaXZLZXkpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIG5ldHdvcmtDaGFuZ2VDaGFubmVsKCkge1xyXG4gICAgY29uc3Qgd2FsbGV0QWNjb3VudEltcG9ydENoYW5uZWwgPSBuZXcgQnJvYWRjYXN0Q2hhbm5lbChcIlwiLmNvbmNhdChCUk9BRENBU1RfQ0hBTk5FTFMuV0FMTEVUX05FVFdPUktfQ0hBTkdFX0NIQU5ORUwsIFwiX1wiKS5jb25jYXQodGhpcy5pbnN0YW5jZUlkKSwgYnJvYWRjYXN0Q2hhbm5lbE9wdGlvbnMpO1xyXG4gICAgd2FsbGV0QWNjb3VudEltcG9ydENoYW5uZWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgZXYgPT4ge1xyXG4gICAgICB2YXIgX2V2JGRhdGE0O1xyXG5cclxuICAgICAgaWYgKCFldi5lcnJvciAmJiAoKF9ldiRkYXRhNCA9IGV2LmRhdGEpID09PSBudWxsIHx8IF9ldiRkYXRhNCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2V2JGRhdGE0LnR5cGUpID09PSBCUk9BRENBU1RfQ0hBTk5FTFNfTVNHUy5ORVRXT1JLX0NIQU5HRSkge1xyXG4gICAgICAgIHZhciBfZXYkZGF0YTU7XHJcblxyXG4gICAgICAgIHRoaXMuaGFuZGxlTmV0d29ya0NoYW5nZSgoX2V2JGRhdGE1ID0gZXYuZGF0YSkgPT09IG51bGwgfHwgX2V2JGRhdGE1ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZXYkZGF0YTUubmV0d29yayk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgc2VsZWN0ZWRBZGRyZXNzQ2hhbmdlQ2hhbm5lbCgpIHtcclxuICAgIGNvbnN0IHdhbGxldEFjY291bnRJbXBvcnRDaGFubmVsID0gbmV3IEJyb2FkY2FzdENoYW5uZWwoXCJcIi5jb25jYXQoQlJPQURDQVNUX0NIQU5ORUxTLldBTExFVF9TRUxFQ1RFRF9BRERSRVNTX0NIQU5ORUwsIFwiX1wiKS5jb25jYXQodGhpcy5pbnN0YW5jZUlkKSwgYnJvYWRjYXN0Q2hhbm5lbE9wdGlvbnMpO1xyXG4gICAgd2FsbGV0QWNjb3VudEltcG9ydENoYW5uZWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgZXYgPT4ge1xyXG4gICAgICB2YXIgX2V2JGRhdGE2O1xyXG5cclxuICAgICAgaWYgKCFldi5lcnJvciAmJiAoKF9ldiRkYXRhNiA9IGV2LmRhdGEpID09PSBudWxsIHx8IF9ldiRkYXRhNiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2V2JGRhdGE2LnR5cGUpID09PSBCUk9BRENBU1RfQ0hBTk5FTFNfTVNHUy5TRUxFQ1RFRF9BRERSRVNTX0NIQU5HRSkge1xyXG4gICAgICAgIHZhciBfZXYkZGF0YTc7XHJcblxyXG4gICAgICAgIHRoaXMuaGFuZGxlU2VsZWN0ZWRBZGRyZXNzQ2hhbmdlKChfZXYkZGF0YTcgPSBldi5kYXRhKSA9PT0gbnVsbCB8fCBfZXYkZGF0YTcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ldiRkYXRhNy5zZWxlY3RlZEFkZHJlc3MpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG59XHJcblxyXG4vKipcclxuICogUG9wdXBXaXRoQmNIYW5kbGVyIGlzIGEgUG9wdXBIYW5kbGVyIHdoaWNoIHVzZXMgYnJvYWRjYXN0IGNoYW5uZWwgdG8gY29tbXVuaWNhdGUgd2l0aCB0aGUgcG9wdXAgd2luZG93LlxyXG4gKi9cclxuXHJcbmNsYXNzIFBvcHVwV2l0aEJjSGFuZGxlciBleHRlbmRzIFBvcHVwSGFuZGxlciB7XHJcbiAgY29uc3RydWN0b3IoX3JlZikge1xyXG4gICAgbGV0IHtcclxuICAgICAgY29uZmlnLFxyXG4gICAgICBzdGF0ZSxcclxuICAgICAgaW5zdGFuY2VJZFxyXG4gICAgfSA9IF9yZWY7XHJcbiAgICBzdXBlcih7XHJcbiAgICAgIGNvbmZpZyxcclxuICAgICAgc3RhdGVcclxuICAgIH0pO1xyXG5cclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJjXCIsIHZvaWQgMCk7XHJcblxyXG4gICAgdGhpcy5iYyA9IG5ldyBCcm9hZGNhc3RDaGFubmVsKGluc3RhbmNlSWQsIGJyb2FkY2FzdENoYW5uZWxPcHRpb25zKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogUmVjZWl2ZXMgdGhlIGRhdGEgZnJvbSBwb3B1cCB3aW5kb3cgYW5kIGNsb3NlcyB0aGUgd2luZG93XHJcbiAgICogQHBhcmFtIHN1Y2Nlc3NFeHRyYUZuIC0gRXh0cmEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGFmdGVyIHRoZSBkYXRhIGlzIHJlY2VpdmVkXHJcbiAgICogQHJldHVybnMgVGhlIGRhdGEgdG8gYmUgcmVjZWl2ZWRcclxuICAgKi9cclxuXHJcblxyXG4gIGhhbmRsZShzdWNjZXNzRXh0cmFGbikge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgY29uc3QgY2xvc2VMaXN0ZW5lciA9ICgpID0+IHtcclxuICAgICAgICB0aGlzLmJjLmNsb3NlKCk7XHJcbiAgICAgICAgcmVqZWN0KG5ldyBVc2VyRXJyb3IoXCJ1c2VyIGNsb3NlZCBwb3B1cFwiKSk7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihcImNsb3NlXCIsIGNsb3NlTGlzdGVuZXIpO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgdGhpcy5vbihcImNsb3NlXCIsIGNsb3NlTGlzdGVuZXIpO1xyXG4gICAgICB0aGlzLmJjLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGFzeW5jIGV2ID0+IHtcclxuICAgICAgICBsb2cuaW5mbyhldiwgXCJyZWNlaXZpbmcgZGF0YSBvbiBjaGFubmVsOiBcIi5jb25jYXQodGhpcy5iYy5uYW1lKSk7XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zdCB7XHJcbiAgICAgICAgICAgIGVycm9yLFxyXG4gICAgICAgICAgICBkYXRhXHJcbiAgICAgICAgICB9ID0gZXY7XHJcblxyXG4gICAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoZXJyb3IpKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmIChzdWNjZXNzRXh0cmFGbikgYXdhaXQgc3VjY2Vzc0V4dHJhRm4uY2FsbCh0aGlzLCBkYXRhKTtcclxuICAgICAgICAgIHJlc29sdmUoZGF0YSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgIHRoaXMuYmMuY2xvc2UoKTtcclxuICAgICAgICAgIHRoaXMuY2xvc2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICB0aGlzLm9wZW4oKS50aGVuKCgpID0+IHtcclxuICAgICAgICBsb2cuaW5mbyhcIm9wZW5lZCB3aW5kb3cgXCIuY29uY2F0KHRoaXMuYmMubmFtZSkpOyAvLyBPcGVuZWQgd2luZG93LiB5YXkuICBsZXQgdGhlIGJjIGV2ZW50cyBkbyB0aGVpciBqb2JcclxuXHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgfSkuY2F0Y2goZXJyID0+IHtcclxuICAgICAgICBsb2cuZXJyb3IoZXJyLCBcInNvbWV0aGluZyB3ZW50IHdyb25nIHdoaWxlIG9wZW5pbmcgd2luZG93XCIpO1xyXG4gICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBVc2UgdGhpcyBpZiB3ZSBoYXZlIHRvIHNlbmQgbGFyZ2UgcGF5bG9hZHMgd2hpY2ggZG9uJ3QgZml0IGluIHF1ZXJ5L2hhc2ggcGFyYW1zLlxyXG4gICAqIFdhaXRzIGZvciBhY2sgdGhhdCBwb3B1cCB3aW5kb3cgaXMgcmVhZHkgdG8gcmVjZWl2ZSBkYXRhLlxyXG4gICAqIFJlY2VpdmVzIHRoZSBkYXRhIGZyb20gcG9wdXAgd2luZG93IGFuZCBjbG9zZXMgdGhlIHdpbmRvd1xyXG4gICAqIEBwYXJhbSBwYXlsb2FkIC0gVGhlIGRhdGEgdG8gYmUgc2VudCB0byB0aGUgcG9wdXAgd2luZG93IG9uY2Ugd2UgaGF2ZSBhY2sgdGhhdCB3aW5kb3cgaXMgcmVhZHkgdG8gcmVjZWl2ZSBkYXRhXHJcbiAgICogQHBhcmFtIHN1Y2Nlc3NFeHRyYUZuIC0gRXh0cmEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGFmdGVyIHRoZSBkYXRhIGlzIHJlY2VpdmVkXHJcbiAgICogQHJldHVybnMgVGhlIGRhdGEgdG8gYmUgcmVjZWl2ZWRcclxuICAgKi9cclxuXHJcblxyXG4gIGhhbmRsZVdpdGhIYW5kc2hha2UocGF5bG9hZCwgc3VjY2Vzc0V4dHJhRm4pIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIGNvbnN0IGNsb3NlTGlzdGVuZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5iYy5jbG9zZSgpO1xyXG4gICAgICAgIHJlamVjdChuZXcgVXNlckVycm9yKFwidXNlciBjbG9zZWQgcG9wdXBcIikpO1xyXG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoXCJjbG9zZVwiLCBjbG9zZUxpc3RlbmVyKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHRoaXMub24oXCJjbG9zZVwiLCBjbG9zZUxpc3RlbmVyKTtcclxuICAgICAgdGhpcy5iYy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBhc3luYyBldiA9PiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGxvZy5pbmZvKGV2LCBcInJlY2VpdmluZyBkYXRhIG9uIGNoYW5uZWw6IFwiLmNvbmNhdCh0aGlzLmJjLm5hbWUpKTtcclxuICAgICAgICAgIGNvbnN0IHtcclxuICAgICAgICAgICAgZXJyb3IsXHJcbiAgICAgICAgICAgIGRhdGFcclxuICAgICAgICAgIH0gPSBldjtcclxuXHJcbiAgICAgICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihlcnJvcikpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9IC8vIERvIGhhbmRzaGFrZVxyXG5cclxuXHJcbiAgICAgICAgICBjb25zdCB7XHJcbiAgICAgICAgICAgIHR5cGUgPSBcIlwiXHJcbiAgICAgICAgICB9ID0gZGF0YTtcclxuXHJcbiAgICAgICAgICBpZiAodHlwZSA9PT0gUE9QVVBfTE9BREVEKSB7XHJcbiAgICAgICAgICAgIC8vIEhhY2sgd2l0aCBnZW5lcmljIHRvIHVzZSB0aGUgc2FtZSB0eXBlIGZvciBib3RoIHNlbmQgYW5kIHJlY2VpdmVcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5iYy5wb3N0TWVzc2FnZSh7XHJcbiAgICAgICAgICAgICAgZGF0YTogcGF5bG9hZFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gUE9QVVBfUkVTVUxUKSB7XHJcbiAgICAgICAgICAgIGlmIChzdWNjZXNzRXh0cmFGbikgYXdhaXQgc3VjY2Vzc0V4dHJhRm4uY2FsbCh0aGlzLCBkYXRhKTtcclxuICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTsgLy8gTXVzdCBvbmx5IGNsb3NlIHRoZSBiYyBhZnRlciByZXN1bHQgaXMgZG9uZVxyXG5cclxuICAgICAgICAgICAgdGhpcy5iYy5jbG9zZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICB0aGlzLmJjLmNsb3NlKCk7XHJcbiAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgdGhpcy5vcGVuKCkudGhlbigoKSA9PiB7XHJcbiAgICAgICAgbG9nLmluZm8oXCJvcGVuZWQgd2luZG93IFwiLmNvbmNhdCh0aGlzLmJjLm5hbWUpKTsgLy8gT3BlbmVkIHdpbmRvdy4geWF5LiAgbGV0IHRoZSBiYyBldmVudHMgZG8gdGhlaXIgam9iXHJcblxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgIH0pLmNhdGNoKGVyciA9PiB7XHJcbiAgICAgICAgbG9nLmVycm9yKGVyciwgXCJzb21ldGhpbmcgd2VudCB3cm9uZyB3aGlsZSBvcGVuaW5nIHdpbmRvd1wiKTtcclxuICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG59XHJcblxyXG5jbGFzcyBSZWRpcmVjdEhhbmRsZXIge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZXJyb3JcIiwgdm9pZCAwKTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJmaW5hbFF1ZXJ5UGFyYW1zXCIsIHt9KTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbnN0YW5jZVBhcmFtZXRlcnNcIiwgdm9pZCAwKTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJoYXNoUGFyYW1ldGVyc1wiLCB2b2lkIDApO1xyXG5cclxuICAgIGNvbnN0IHtcclxuICAgICAgaGFzaFxyXG4gICAgfSA9IHdpbmRvdy5sb2NhdGlvbjtcclxuICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaCk7XHJcbiAgICBxdWVyeVBhcmFtZXRlcnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xyXG4gICAgICB0aGlzLmZpbmFsUXVlcnlQYXJhbXNba2V5XSA9IHZhbHVlO1xyXG4gICAgfSk7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgIGVycm9yLFxyXG4gICAgICBpbnN0YW5jZVBhcmFtZXRlcnMsXHJcbiAgICAgIGhhc2hQYXJhbWV0ZXJzXHJcbiAgICB9ID0gaGFuZGxlUmVkaXJlY3RQYXJhbWV0ZXJzKGhhc2gsIHRoaXMuZmluYWxRdWVyeVBhcmFtcyk7XHJcbiAgICB0aGlzLmVycm9yID0gZXJyb3I7XHJcbiAgICB0aGlzLmluc3RhbmNlUGFyYW1ldGVycyA9IGluc3RhbmNlUGFyYW1ldGVycztcclxuICAgIHRoaXMuaGFzaFBhcmFtZXRlcnMgPSBoYXNoUGFyYW1ldGVycztcclxuICB9XHJcblxyXG4gIGFzeW5jIGhhbmRsZSgpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIGNvbnN0IHtcclxuICAgICAgICBmaW5hbFF1ZXJ5UGFyYW1zLFxyXG4gICAgICAgIGluc3RhbmNlUGFyYW1ldGVycyxcclxuICAgICAgICBoYXNoUGFyYW1ldGVycyxcclxuICAgICAgICBlcnJvclxyXG4gICAgICB9ID0gdGhpcztcclxuICAgICAgbGV0IGJjO1xyXG5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICBpZiAoIWZpbmFsUXVlcnlQYXJhbXMud2luZG93SWQpIHtcclxuICAgICAgICAgIGJjID0gbmV3IEJyb2FkY2FzdENoYW5uZWwoXCJcIi5jb25jYXQoQlJPQURDQVNUX0NIQU5ORUxTLlJFRElSRUNUX0NIQU5ORUwsIFwiX1wiKS5jb25jYXQoaW5zdGFuY2VQYXJhbWV0ZXJzLmluc3RhbmNlSWQpLCBicm9hZGNhc3RDaGFubmVsT3B0aW9ucyk7XHJcbiAgICAgICAgICBiYy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBhc3luYyBldiA9PiB7XHJcbiAgICAgICAgICAgIGlmIChldi5lcnJvcikge1xyXG4gICAgICAgICAgICAgIHJlamVjdChldi5lcnJvcik7XHJcbiAgICAgICAgICAgICAgd2luZG93LmNsb3NlKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgIGJjLmNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgbG9nLmluZm8oXCJwb3N0ZWRcIiwge1xyXG4gICAgICAgICAgICAgICAgZmluYWxRdWVyeVBhcmFtcyxcclxuICAgICAgICAgICAgICAgIGhhc2hQYXJhbWV0ZXJzLFxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2VQYXJhbWV0ZXJzXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgYmMucG9zdE1lc3NhZ2Uoe1xyXG4gICAgICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgICAgaW5zdGFuY2VQYXJhbXM6IGluc3RhbmNlUGFyYW1ldGVycyxcclxuICAgICAgICAgICAgICBoYXNoUGFyYW1zOiBoYXNoUGFyYW1ldGVycyxcclxuICAgICAgICAgICAgICBxdWVyeVBhcmFtczogZmluYWxRdWVyeVBhcmFtc1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlcnJvclxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4gKyB3aW5kb3cubG9jYXRpb24uc2VhcmNoICsgd2luZG93LmxvY2F0aW9uLmhhc2g7XHJcbiAgICAgICAgICB9LCA1MDAwKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYmMgPSBuZXcgQnJvYWRjYXN0Q2hhbm5lbChcIlwiLmNvbmNhdChmaW5hbFF1ZXJ5UGFyYW1zLndpbmRvd0lkKSwgYnJvYWRjYXN0Q2hhbm5lbE9wdGlvbnMpO1xyXG4gICAgICAgICAgYmMuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgYXN5bmMgZXYgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB7XHJcbiAgICAgICAgICAgICAgdXJsLFxyXG4gICAgICAgICAgICAgIG1lc3NhZ2VcclxuICAgICAgICAgICAgfSA9IGV2LmRhdGE7XHJcblxyXG4gICAgICAgICAgICBpZiAodXJsKSB7XHJcbiAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1lc3NhZ2UgPT09IFNFVFVQX0NPTVBMRVRFKSB7XHJcbiAgICAgICAgICAgICAgYXdhaXQgYmMucG9zdE1lc3NhZ2Uoe1xyXG4gICAgICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgICB3aW5kb3dJZDogZmluYWxRdWVyeVBhcmFtcy53aW5kb3dJZCxcclxuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogUE9QVVBfTE9BREVEXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChldi5lcnJvciAmJiBldi5lcnJvciAhPT0gXCJcIikge1xyXG4gICAgICAgICAgICAgIGxvZy5lcnJvcihldi5lcnJvcik7XHJcbiAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgIGJjLmNsb3NlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgbG9nLmluZm8oZXJyLCBcInNvbWV0aGluZyB3ZW50IHdyb25nXCIpO1xyXG4gICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgIGlmIChiYykgYmMuY2xvc2UoKTtcclxuICAgICAgICB3aW5kb3cuY2xvc2UoKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxufVxyXG5cclxuY29uc3QgQUNUSVZJVFlfQUNUSU9OID0ge1xyXG4gIEFDVElWSVRZX0FDVElPTl9BTEw6IFwid2FsbGV0QWN0aXZpdHkuYWxsVHJhbnNhY3Rpb25zXCIsXHJcbiAgQUNUSVZJVFlfQUNUSU9OX1NFTkQ6IFwid2FsbGV0QWN0aXZpdHkuc2VuZFwiLFxyXG4gIEFDVElWSVRZX0FDVElPTl9SRUNFSVZFOiBcIndhbGxldEFjdGl2aXR5LnJlY2VpdmVcIixcclxuICBBQ1RJVklUWV9BQ1RJT05fVE9QVVA6IFwid2FsbGV0QWN0aXZpdHkudG9wdXBcIlxyXG59O1xyXG5jb25zdCBBQ0NPVU5UX0NBVEVHT1JZID0ge1xyXG4gIE5PUk1BTDogXCJub3JtYWxcIixcclxuICBUSFJFU0hPTEQ6IFwidGhyZXNob2xkXCIsXHJcbiAgSU1QT1JURUQ6IFwiaW1wb3J0ZWRcIlxyXG59O1xyXG5cclxuZnVuY3Rpb24gb3duS2V5cyQxKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxyXG5cclxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQxKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gbnVsbCAhPSBhcmd1bWVudHNbaV0gPyBhcmd1bWVudHNbaV0gOiB7fTsgaSAlIDIgPyBvd25LZXlzJDEoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyQxKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IHJldHVybiB0YXJnZXQ7IH1cclxuXHJcbmNvbnN0IERFRkFVTFRfSU5URVJWQUwgPSAxODAgKiAxMDAwO1xyXG5jb25zdCBERUZBVUxUX1BSRUZFUkVOQ0VTID0ge1xyXG4gIHNlbGVjdGVkQ3VycmVuY3k6IFwiVVNEXCIsXHJcbiAgdGhlbWU6IFwiZGFya1wiLFxyXG4gIGxvY2FsZTogXCJlbi1VU1wiLFxyXG4gIGFjY291bnRUeXBlOiBBQ0NPVU5UX0NBVEVHT1JZLk5PUk1BTCxcclxuICBjb250YWN0czogW10sXHJcbiAgand0VG9rZW46IFwiXCIsXHJcbiAgZmV0Y2hlZFBhc3RUeDogW10sXHJcbiAgcGFzdFRyYW5zYWN0aW9uczogW10sXHJcbiAgcGF5bWVudFR4OiBbXSxcclxuICBkZWZhdWx0UHVibGljQWRkcmVzczogXCJcIixcclxuICBjdXN0b21Ub2tlbnM6IFtdLFxyXG4gIGN1c3RvbU5mdHM6IFtdLFxyXG4gIGNyYXNoUmVwb3J0OiB0cnVlLFxyXG4gIHVzZXJJbmZvOiB7XHJcbiAgICBhZ2dyZWdhdGVWZXJpZmllcjogXCJcIixcclxuICAgIGVtYWlsOiBcIlwiLFxyXG4gICAgbmFtZTogXCJcIixcclxuICAgIHByb2ZpbGVJbWFnZTogXCJcIixcclxuICAgIHR5cGVPZkxvZ2luOiBMT0dJTl9QUk9WSURFUi5HT09HTEUsXHJcbiAgICB2ZXJpZmllcjogXCJcIixcclxuICAgIHZlcmlmaWVySWQ6IFwiXCJcclxuICB9XHJcbn07XHJcbi8qKlxyXG4gKiBDb250cm9sbGVyIHRoYXQgc3RvcmVzIHNoYXJlZCBzZXR0aW5ncyBhbmQgZXhwb3NlcyBjb252ZW5pZW5jZSBtZXRob2RzXHJcbiAqL1xyXG5cclxuY2xhc3MgQmFzZVByZWZlcmVuY2VzQ29udHJvbGxlciBleHRlbmRzIEJhc2VDb250cm9sbGVyIHtcclxuICAvKipcclxuICAgKiBOYW1lIG9mIHRoaXMgY29udHJvbGxlciB1c2VkIGR1cmluZyBjb21wb3NpdGlvblxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgUHJlZmVyZW5jZXNDb250cm9sbGVyIGluc3RhbmNlXHJcbiAgICpcclxuICAgKiBAcGFyYW0gY29uZmlnIC0gSW5pdGlhbCBvcHRpb25zIHVzZWQgdG8gY29uZmlndXJlIHRoaXMgY29udHJvbGxlclxyXG4gICAqIEBwYXJhbSBzdGF0ZSAtIEluaXRpYWwgc3RhdGUgdG8gc2V0IG9uIHRoaXMgY29udHJvbGxlclxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKF9yZWYpIHtcclxuICAgIGxldCB7XHJcbiAgICAgIGNvbmZpZyxcclxuICAgICAgc3RhdGUsXHJcbiAgICAgIGRlZmF1bHRQcmVmZXJlbmNlcyxcclxuICAgICAgc2lnbkF1dGhNZXNzYWdlXHJcbiAgICB9ID0gX3JlZjtcclxuICAgIHN1cGVyKHtcclxuICAgICAgY29uZmlnLFxyXG4gICAgICBzdGF0ZVxyXG4gICAgfSk7XHJcblxyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCBcIlByZWZlcmVuY2VzQ29udHJvbGxlclwiKTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpZnJhbWVPcmlnaW5cIiwgdm9pZCAwKTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzaWduQXV0aE1lc3NhZ2VcIiwgdm9pZCAwKTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJkZWZhdWx0UHJlZmVyZW5jZXNcIiwgdm9pZCAwKTtcclxuXHJcbiAgICBpZiAoIWNvbmZpZy5hcGkpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJlZmVyZW5jZXNDb250cm9sbGVyIC0gbm8gYXBpIHNwZWNpZmllZCBpbiBjb25maWcuXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZGVmYXVsdFN0YXRlID0ge1xyXG4gICAgICBpZGVudGl0aWVzOiB7fSxcclxuICAgICAgc2VsZWN0ZWRBZGRyZXNzOiBcIlwiLFxyXG4gICAgICBsYXN0RXJyb3JNZXNzYWdlOiBcIlwiLFxyXG4gICAgICBsYXN0U3VjY2Vzc01lc3NhZ2U6IFwiXCJcclxuICAgIH07XHJcbiAgICB0aGlzLmRlZmF1bHRDb25maWcgPSB7XHJcbiAgICAgIGFwaTogY29uZmlnLmFwaSxcclxuICAgICAgcG9sbEludGVydmFsOiBERUZBVUxUX0lOVEVSVkFMXHJcbiAgICB9O1xyXG4gICAgdGhpcy5pbml0aWFsaXplKCk7XHJcbiAgICB0aGlzLmRlZmF1bHRQcmVmZXJlbmNlcyA9IF9vYmplY3RTcHJlYWQkMShfb2JqZWN0U3ByZWFkJDEoe30sIERFRkFVTFRfUFJFRkVSRU5DRVMpLCBkZWZhdWx0UHJlZmVyZW5jZXMpO1xyXG4gICAgdGhpcy5zaWduQXV0aE1lc3NhZ2UgPSBzaWduQXV0aE1lc3NhZ2U7XHJcbiAgfVxyXG5cclxuICBzZXRJZnJhbWVPcmlnaW4ob3JpZ2luKSB7XHJcbiAgICB0aGlzLmlmcmFtZU9yaWdpbiA9IG9yaWdpbjtcclxuICB9XHJcblxyXG4gIGdldEFkZHJlc3NTdGF0ZShhZGRyZXNzKSB7XHJcbiAgICBjb25zdCBzZWxlY3RlZEFkZHJlc3MgPSBhZGRyZXNzIHx8IHRoaXMuc3RhdGUuc2VsZWN0ZWRBZGRyZXNzO1xyXG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuaWRlbnRpdGllc1tzZWxlY3RlZEFkZHJlc3NdO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBTZXRzIHNlbGVjdGVkIGFkZHJlc3NcclxuICAgKlxyXG4gICAqIEBwYXJhbSBzZWxlY3RlZEFkZHJlc3MgLSBjYXNwZXIgYWNjb3VudCBoYXNoXHJcbiAgICovXHJcblxyXG5cclxuICBzZXRTZWxlY3RlZEFkZHJlc3Moc2VsZWN0ZWRBZGRyZXNzKSB7XHJcbiAgICB0aGlzLnVwZGF0ZSh7XHJcbiAgICAgIHNlbGVjdGVkQWRkcmVzc1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRVc2VyKGFkZHJlc3MpIHtcclxuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBnZXQoXCJcIi5jb25jYXQodGhpcy5jb25maWcuYXBpLCBcIi91c2VyP2ZldGNoVHg9ZmFsc2VcIiksIHRoaXMuaGVhZGVycyhhZGRyZXNzKSwge1xyXG4gICAgICB1c2VBUElLZXk6IHRydWVcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHVzZXIuZGF0YTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGNyZWF0ZVVzZXIocGFyYW1zKSB7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgIHNlbGVjdGVkQ3VycmVuY3ksXHJcbiAgICAgIHRoZW1lLFxyXG4gICAgICB2ZXJpZmllcixcclxuICAgICAgdmVyaWZpZXJJZCxcclxuICAgICAgbG9jYWxlLFxyXG4gICAgICBhZGRyZXNzXHJcbiAgICB9ID0gcGFyYW1zO1xyXG4gICAgY29uc3QgdXNlclBheWxvYWQgPSB7XHJcbiAgICAgIGRlZmF1bHRfY3VycmVuY3k6IHNlbGVjdGVkQ3VycmVuY3ksXHJcbiAgICAgIHRoZW1lLFxyXG4gICAgICB2ZXJpZmllcixcclxuICAgICAgdmVyaWZpZXJfaWQ6IHZlcmlmaWVySWQsXHJcbiAgICAgIGxvY2FsZVxyXG4gICAgfTtcclxuICAgIGF3YWl0IHBvc3QoXCJcIi5jb25jYXQodGhpcy5jb25maWcuYXBpLCBcIi91c2VyXCIpLCB1c2VyUGF5bG9hZCwgdGhpcy5oZWFkZXJzKGFkZHJlc3MpLCB7XHJcbiAgICAgIHVzZUFQSUtleTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICB0aGlzLnVwZGF0ZVN0YXRlKHtcclxuICAgICAgdGhlbWUsXHJcbiAgICAgIGRlZmF1bHRQdWJsaWNBZGRyZXNzOiBhZGRyZXNzLFxyXG4gICAgICBzZWxlY3RlZEN1cnJlbmN5LFxyXG4gICAgICBsb2NhbGVcclxuICAgIH0sIGFkZHJlc3MpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgc3RvcmVVc2VyTG9naW4ocGFyYW1zKSB7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgIHZlcmlmaWVySWQsXHJcbiAgICAgIHZlcmlmaWVyLFxyXG4gICAgICBvcHRpb25zLFxyXG4gICAgICBhZGRyZXNzXHJcbiAgICB9ID0gcGFyYW1zO1xyXG5cclxuICAgIGlmICghb3B0aW9ucy5yZWh5ZHJhdGUpIHtcclxuICAgICAgY29uc3QgYnJvd3NlciA9IGJvd3Nlci5nZXRQYXJzZXIod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpO1xyXG4gICAgICBjb25zdCBzcGVjaWFsQnJvd3NlciA9IGdldEN1c3RvbURldmljZUluZm8oKTtcclxuICAgICAgY29uc3QgcmVjb3JkTG9naW5QYXlsb2FkID0ge1xyXG4gICAgICAgIG9zOiBicm93c2VyLmdldE9TTmFtZSgpLFxyXG4gICAgICAgIG9zX3ZlcnNpb246IGJyb3dzZXIuZ2V0T1NWZXJzaW9uKCkgfHwgXCJ1bmlkZW50aWZpZWRcIixcclxuICAgICAgICBicm93c2VyOiAoc3BlY2lhbEJyb3dzZXIgPT09IG51bGwgfHwgc3BlY2lhbEJyb3dzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNwZWNpYWxCcm93c2VyLmJyb3dzZXIpIHx8IGJyb3dzZXIuZ2V0QnJvd3Nlck5hbWUoKSB8fCBcInVuaWRlbnRpZmllZFwiLFxyXG4gICAgICAgIGJyb3dzZXJfdmVyc2lvbjogYnJvd3Nlci5nZXRCcm93c2VyVmVyc2lvbigpIHx8IFwidW5pZGVudGlmaWVkXCIsXHJcbiAgICAgICAgcGxhdGZvcm06IGJyb3dzZXIuZ2V0UGxhdGZvcm0oKS50eXBlIHx8IFwiZGVza3RvcFwiLFxyXG4gICAgICAgIGhvc3RuYW1lOiB0aGlzLmlmcmFtZU9yaWdpbixcclxuICAgICAgICB2ZXJpZmllcixcclxuICAgICAgICB2ZXJpZmllcl9pZDogdmVyaWZpZXJJZFxyXG4gICAgICB9O1xyXG4gICAgICBhd2FpdCBwb3N0KFwiXCIuY29uY2F0KHRoaXMuY29uZmlnLmFwaSwgXCIvdXNlci9yZWNvcmRMb2dpblwiKSwgcmVjb3JkTG9naW5QYXlsb2FkLCB0aGlzLmhlYWRlcnMoYWRkcmVzcyksIHtcclxuICAgICAgICB1c2VBUElLZXk6IHRydWVcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBzZXRDcmFzaFJlcG9ydChpc0VuYWJsZWQpIHtcclxuICAgIHZhciBfdGhpcyRnZXRBZGRyZXNzU3RhdGU7XHJcblxyXG4gICAgaWYgKGlzRW5hYmxlZCA9PT0gKChfdGhpcyRnZXRBZGRyZXNzU3RhdGUgPSB0aGlzLmdldEFkZHJlc3NTdGF0ZSgpKSA9PT0gbnVsbCB8fCBfdGhpcyRnZXRBZGRyZXNzU3RhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJGdldEFkZHJlc3NTdGF0ZS5jcmFzaFJlcG9ydCkpIHJldHVybiB0cnVlO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGF3YWl0IHBhdGNoKFwiXCIuY29uY2F0KHRoaXMuY29uZmlnLmFwaSwgXCIvdXNlclwiKSwge1xyXG4gICAgICAgIGVuYWJsZV9jcmFzaF9yZXBvcnRlcjogaXNFbmFibGVkXHJcbiAgICAgIH0sIHRoaXMuaGVhZGVycygpLCB7XHJcbiAgICAgICAgdXNlQVBJS2V5OiB0cnVlXHJcbiAgICAgIH0pO1xyXG4gICAgICB0aGlzLnVwZGF0ZVN0YXRlKHtcclxuICAgICAgICBjcmFzaFJlcG9ydDogaXNFbmFibGVkXHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGxvZy5lcnJvcihlcnJvcik7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIHNldFVzZXJUaGVtZSh0aGVtZSkge1xyXG4gICAgdmFyIF90aGlzJGdldEFkZHJlc3NTdGF0ZTI7XHJcblxyXG4gICAgaWYgKHRoZW1lID09PSAoKF90aGlzJGdldEFkZHJlc3NTdGF0ZTIgPSB0aGlzLmdldEFkZHJlc3NTdGF0ZSgpKSA9PT0gbnVsbCB8fCBfdGhpcyRnZXRBZGRyZXNzU3RhdGUyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRnZXRBZGRyZXNzU3RhdGUyLnRoZW1lKSkgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgYXdhaXQgcGF0Y2goXCJcIi5jb25jYXQodGhpcy5jb25maWcuYXBpLCBcIi91c2VyXCIpLCB7XHJcbiAgICAgICAgdGhlbWVcclxuICAgICAgfSwgdGhpcy5oZWFkZXJzKCksIHtcclxuICAgICAgICB1c2VBUElLZXk6IHRydWVcclxuICAgICAgfSk7XHJcbiAgICAgIHRoaXMudXBkYXRlU3RhdGUoe1xyXG4gICAgICAgIHRoZW1lXHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGxvZy5lcnJvcihlcnJvcik7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIHNldFVzZXJMb2NhbGUobG9jYWxlKSB7XHJcbiAgICB2YXIgX3RoaXMkZ2V0QWRkcmVzc1N0YXRlMztcclxuXHJcbiAgICBpZiAobG9jYWxlID09PSAoKF90aGlzJGdldEFkZHJlc3NTdGF0ZTMgPSB0aGlzLmdldEFkZHJlc3NTdGF0ZSgpKSA9PT0gbnVsbCB8fCBfdGhpcyRnZXRBZGRyZXNzU3RhdGUzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRnZXRBZGRyZXNzU3RhdGUzLmxvY2FsZSkpIHJldHVybjtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBhd2FpdCBwYXRjaChcIlwiLmNvbmNhdCh0aGlzLmNvbmZpZy5hcGksIFwiL3VzZXJcIiksIHtcclxuICAgICAgICBsb2NhbGVcclxuICAgICAgfSwgdGhpcy5oZWFkZXJzKCksIHtcclxuICAgICAgICB1c2VBUElLZXk6IHRydWVcclxuICAgICAgfSk7XHJcbiAgICAgIHRoaXMudXBkYXRlU3RhdGUoe1xyXG4gICAgICAgIGxvY2FsZVxyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBsb2cuZXJyb3IoXCJ1bmFibGUgdG8gc2V0IGxvY2FsZVwiLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIHNldFNlbGVjdGVkQ3VycmVuY3kocGF5bG9hZCkge1xyXG4gICAgdmFyIF90aGlzJGdldEFkZHJlc3NTdGF0ZTQ7XHJcblxyXG4gICAgaWYgKHBheWxvYWQuc2VsZWN0ZWRDdXJyZW5jeSA9PT0gKChfdGhpcyRnZXRBZGRyZXNzU3RhdGU0ID0gdGhpcy5nZXRBZGRyZXNzU3RhdGUoKSkgPT09IG51bGwgfHwgX3RoaXMkZ2V0QWRkcmVzc1N0YXRlNCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkZ2V0QWRkcmVzc1N0YXRlNC5zZWxlY3RlZEN1cnJlbmN5KSkgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgYXdhaXQgcGF0Y2goXCJcIi5jb25jYXQodGhpcy5jb25maWcuYXBpLCBcIi91c2VyXCIpLCB7XHJcbiAgICAgICAgZGVmYXVsdF9jdXJyZW5jeTogcGF5bG9hZC5zZWxlY3RlZEN1cnJlbmN5XHJcbiAgICAgIH0sIHRoaXMuaGVhZGVycygpLCB7XHJcbiAgICAgICAgdXNlQVBJS2V5OiB0cnVlXHJcbiAgICAgIH0pO1xyXG4gICAgICB0aGlzLnVwZGF0ZVN0YXRlKHtcclxuICAgICAgICBzZWxlY3RlZEN1cnJlbmN5OiBwYXlsb2FkLnNlbGVjdGVkQ3VycmVuY3lcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgbG9nLmVycm9yKGVycm9yKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgYWRkQ29udGFjdChjb250YWN0KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICB2YXIgX3RoaXMkZ2V0QWRkcmVzc1N0YXRlNTtcclxuXHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcG9zdChcIlwiLmNvbmNhdCh0aGlzLmNvbmZpZy5hcGksIFwiL2NvbnRhY3RcIiksIGNvbnRhY3QsIHRoaXMuaGVhZGVycygpLCB7XHJcbiAgICAgICAgdXNlQVBJS2V5OiB0cnVlXHJcbiAgICAgIH0pO1xyXG4gICAgICB0aGlzLnVwZGF0ZVN0YXRlKHtcclxuICAgICAgICBjb250YWN0czogWy4uLigoKF90aGlzJGdldEFkZHJlc3NTdGF0ZTUgPSB0aGlzLmdldEFkZHJlc3NTdGF0ZSgpKSA9PT0gbnVsbCB8fCBfdGhpcyRnZXRBZGRyZXNzU3RhdGU1ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRnZXRBZGRyZXNzU3RhdGU1LmNvbnRhY3RzKSB8fCBbXSksIHJlc3BvbnNlLmRhdGFdXHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGxvZy5lcnJvcihcInVuYWJsZSB0byBhZGQgY29udGFjdFwiLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIGRlbGV0ZUNvbnRhY3QoY29udGFjdElkKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICB2YXIgX3RoaXMkZ2V0QWRkcmVzc1N0YXRlNjtcclxuXHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVtb3ZlKFwiXCIuY29uY2F0KHRoaXMuY29uZmlnLmFwaSwgXCIvY29udGFjdC9cIikuY29uY2F0KGNvbnRhY3RJZCksIHt9LCB0aGlzLmhlYWRlcnMoKSwge1xyXG4gICAgICAgIHVzZUFQSUtleTogdHJ1ZVxyXG4gICAgICB9KTtcclxuICAgICAgY29uc3QgZmluYWxDb250YWN0cyA9IChfdGhpcyRnZXRBZGRyZXNzU3RhdGU2ID0gdGhpcy5nZXRBZGRyZXNzU3RhdGUoKSkgPT09IG51bGwgfHwgX3RoaXMkZ2V0QWRkcmVzc1N0YXRlNiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkZ2V0QWRkcmVzc1N0YXRlNi5jb250YWN0cy5maWx0ZXIoY29udGFjdCA9PiBjb250YWN0LmlkICE9PSByZXNwb25zZS5kYXRhLmlkKTtcclxuICAgICAgaWYgKGZpbmFsQ29udGFjdHMpIHRoaXMudXBkYXRlU3RhdGUoe1xyXG4gICAgICAgIGNvbnRhY3RzOiBbLi4uZmluYWxDb250YWN0c11cclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgbG9nLmVycm9yKFwidW5hYmxlIHRvIGRlbGV0ZSBjb250YWN0XCIsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgcmV2b2tlRGlzY29yZChpZFRva2VuKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwID0gYXdhaXQgcG9zdChcIlwiLmNvbmNhdCh0aGlzLmNvbmZpZy5hcGksIFwiL3Jldm9rZS9kaXNjb3JkXCIpLCB7XHJcbiAgICAgICAgdG9rZW46IGlkVG9rZW5cclxuICAgICAgfSwgdGhpcy5oZWFkZXJzKCksIHtcclxuICAgICAgICB1c2VBUElLZXk6IHRydWVcclxuICAgICAgfSk7XHJcbiAgICAgIGxvZy5pbmZvKHJlc3ApO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgbG9nLmVycm9yKGVycm9yKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIHBhdGNoUGFzdFR4KGJvZHksIGFkZHJlc3MpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcGF0Y2goXCJcIi5jb25jYXQodGhpcy5jb25maWcuYXBpLCBcIi90cmFuc2FjdGlvblwiKSwgYm9keSwgdGhpcy5oZWFkZXJzKGFkZHJlc3MpLCB7XHJcbiAgICAgICAgdXNlQVBJS2V5OiB0cnVlXHJcbiAgICAgIH0pO1xyXG4gICAgICBsb2cuaW5mbyhcInN1Y2Nlc3NmdWxseSBwYXRjaGVkXCIsIHJlc3BvbnNlKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGxvZy5lcnJvcihcInVuYWJsZSB0byBwYXRjaCB0eFwiLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBwb3N0UGFzdFR4KHR4LCBhZGRyZXNzKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHBvc3QoXCJcIi5jb25jYXQodGhpcy5jb25maWcuYXBpLCBcIi90cmFuc2FjdGlvblwiKSwgdHgsIHRoaXMuaGVhZGVycyhhZGRyZXNzKSwge1xyXG4gICAgICAgIHVzZUFQSUtleTogdHJ1ZVxyXG4gICAgICB9KTtcclxuICAgICAgbG9nLmluZm8oXCJzdWNjZXNzZnVsbHkgcG9zdGVkIHR4XCIsIHJlc3BvbnNlKTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgbG9nLmVycm9yKGVycm9yLCBcInVuYWJsZSB0byBpbnNlcnQgdHJhbnNhY3Rpb25cIik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRXYWxsZXRPcmRlcnMoYWRkcmVzcykge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBnZXQoXCJcIi5jb25jYXQodGhpcy5jb25maWcuYXBpLCBcIi90cmFuc2FjdGlvblwiKSwgdGhpcy5oZWFkZXJzKGFkZHJlc3MpLCB7XHJcbiAgICAgICAgdXNlQVBJS2V5OiB0cnVlXHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2Uuc3VjY2VzcyA/IHJlc3BvbnNlLmRhdGEgPyByZXNwb25zZS5kYXRhIDogW10gOiBbXTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGxvZy5lcnJvcihcInVuYWJsZSB0byBnZXQgd2FsbGV0IG9yZGVycyB0eFwiLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIGdldFRvcFVwT3JkZXJzKGFkZHJlc3MpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZ2V0KFwiXCIuY29uY2F0KHRoaXMuY29uZmlnLmNvbW1vbkFwaUhvc3QsIFwiL3RyYW5zYWN0aW9uXCIpLCB0aGlzLmhlYWRlcnMoYWRkcmVzcyksIHtcclxuICAgICAgICB1c2VBUElLZXk6IHRydWVcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhIHx8IFtdO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgbG9nLmVycm9yKFwidW5hYmxlIHRvIGZldGNoIHBhc3QgVG9wIHVwIG9yZGVyc1wiLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRCaWxsQm9hcmREYXRhKCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBnZXQoXCJcIi5jb25jYXQodGhpcy5jb25maWcuYXBpLCBcIi9iaWxsYm9hcmRcIiksIHRoaXMuaGVhZGVycygpLCB7XHJcbiAgICAgICAgdXNlQVBJS2V5OiB0cnVlXHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2Uuc3VjY2VzcyA/IHJlc3BvbnNlLmRhdGEgOiBbXTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGxvZy5lcnJvcihcInVuYWJsZSB0byBnZXQgYmlsbGJvYXJkIGRhdGFcIiwgZXJyb3IpO1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRNZXNzYWdlRm9yU2lnbmluZyhwdWJsaWNBZGRyZXNzKSB7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHBvc3QoXCJcIi5jb25jYXQodGhpcy5jb25maWcuYXBpLCBcIi9hdXRoL21lc3NhZ2VcIiksIHtcclxuICAgICAgcHVibGljX2FkZHJlc3M6IHB1YmxpY0FkZHJlc3NcclxuICAgIH0sIHt9LCB7XHJcbiAgICAgIHVzZUFQSUtleTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzcG9uc2UubWVzc2FnZTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGdldFR3aXR0ZXJJZChwYXlsb2FkKSB7XHJcbiAgICBjb25zdCByZXMgPSBhd2FpdCBnZXQoXCJcIi5jb25jYXQodGhpcy5jb25maWcuYXBpLCBcIi90d2l0dGVyP3NjcmVlbl9uYW1lPVwiKS5jb25jYXQocGF5bG9hZC5uaWNrKSwgdGhpcy5oZWFkZXJzKCksIHtcclxuICAgICAgdXNlQVBJS2V5OiB0cnVlXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBcIlwiLmNvbmNhdChwYXlsb2FkLnR5cGVPZkxvZ2luLnRvTG93ZXJDYXNlKCksIFwifFwiKS5jb25jYXQocmVzLmRhdGEudG9TdHJpbmcoKSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBzZW5kRW1haWwocGF5bG9hZCkge1xyXG4gICAgcmV0dXJuIHBvc3QoXCJcIi5jb25jYXQodGhpcy5jb25maWcuYXBpLCBcIi90cmFuc2FjdGlvbi9zZW5kZW1haWxcIiksIHBheWxvYWQuZW1haWxPYmplY3QsIHRoaXMuaGVhZGVycygpLCB7XHJcbiAgICAgIHVzZUFQSUtleTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyByZWZyZXNoSnd0KCkge1xyXG4gICAgY29uc3QgYWRkcmVzcyA9IHRoaXMuc3RhdGUuc2VsZWN0ZWRBZGRyZXNzO1xyXG4gICAgY29uc3QgbWVzc2FnZVRvU2lnbiA9IGF3YWl0IHRoaXMuZ2V0TWVzc2FnZUZvclNpZ25pbmcoYWRkcmVzcyk7XHJcbiAgICBpZiAoIW1lc3NhZ2VUb1NpZ24uc3RhcnRzV2l0aCh0aGlzLmNvbmZpZy5zaWduSW5QcmVmaXgpKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2lnbiBvbiBpbnZhbGlkIG1lc3NhZ2VcIik7XHJcbiAgICBjb25zdCBzaWduZWRNZXNzYWdlID0gdGhpcy5zaWduQXV0aE1lc3NhZ2UoYWRkcmVzcywgbWVzc2FnZVRvU2lnbik7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHBvc3QoXCJcIi5jb25jYXQodGhpcy5jb25maWcuYXBpLCBcIi9hdXRoL3ZlcmlmeVwiKSwge1xyXG4gICAgICBwdWJsaWNfYWRkcmVzczogYWRkcmVzcyxcclxuICAgICAgc2lnbmVkX21lc3NhZ2U6IHNpZ25lZE1lc3NhZ2VcclxuICAgIH0sIHt9LCB7XHJcbiAgICAgIHVzZUFQSUtleTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICB0aGlzLnVwZGF0ZVN0YXRlKHtcclxuICAgICAgand0VG9rZW46IHJlc3BvbnNlLnRva2VuXHJcbiAgICB9LCBhZGRyZXNzKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGdldERhcHBMaXN0KCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBnZXQoXCJcIi5jb25jYXQodGhpcy5jb25maWcuYXBpLCBcIi9kYXBwc1wiKSwgdGhpcy5oZWFkZXJzKCksIHtcclxuICAgICAgICB1c2VBUElLZXk6IHRydWVcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5zdWNjZXNzID8gcmVzcG9uc2UuZGF0YSA6IFtdO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgbG9nLmVycm9yKFwidW5hYmxlIHRvIGdldCBiaWxsYm9hcmQgZGF0YVwiLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIGluaXQoYWRkcmVzcywgdXNlckluZm8sIGp3dFRva2VuKSB7XHJcbiAgICBsZXQgcmVzcG9uc2UgPSB7XHJcbiAgICAgIHRva2VuOiBqd3RUb2tlblxyXG4gICAgfTtcclxuICAgIGlmICh0aGlzLmdldEFkZHJlc3NTdGF0ZShhZGRyZXNzKSkgcmV0dXJuO1xyXG5cclxuICAgIGlmICghand0VG9rZW4pIHtcclxuICAgICAgY29uc3QgbWVzc2FnZVRvU2lnbiA9IGF3YWl0IHRoaXMuZ2V0TWVzc2FnZUZvclNpZ25pbmcoYWRkcmVzcyk7XHJcbiAgICAgIGlmICghbWVzc2FnZVRvU2lnbi5zdGFydHNXaXRoKHRoaXMuY29uZmlnLnNpZ25JblByZWZpeCkpIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzaWduIG9uIGludmFsaWQgbWVzc2FnZVwiKTtcclxuICAgICAgY29uc3Qgc2lnbmVkTWVzc2FnZSA9IHRoaXMuc2lnbkF1dGhNZXNzYWdlKGFkZHJlc3MsIG1lc3NhZ2VUb1NpZ24pO1xyXG4gICAgICByZXNwb25zZSA9IGF3YWl0IHBvc3QoXCJcIi5jb25jYXQodGhpcy5jb25maWcuYXBpLCBcIi9hdXRoL3ZlcmlmeVwiKSwge1xyXG4gICAgICAgIHB1YmxpY19hZGRyZXNzOiBhZGRyZXNzLFxyXG4gICAgICAgIHNpZ25lZF9tZXNzYWdlOiBzaWduZWRNZXNzYWdlXHJcbiAgICAgIH0sIHt9LCB7XHJcbiAgICAgICAgdXNlQVBJS2V5OiB0cnVlXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMudXBkYXRlU3RhdGUoe1xyXG4gICAgICBqd3RUb2tlbjogcmVzcG9uc2UudG9rZW4sXHJcbiAgICAgIHVzZXJJbmZvXHJcbiAgICB9LCBhZGRyZXNzKTtcclxuICB9XHJcblxyXG4gIHVwZGF0ZVN0YXRlKHByZWZlcmVuY2VzLCBhZGRyZXNzKSB7XHJcbiAgICBjb25zdCBzZWxlY3RlZEFkZHJlc3MgPSBhZGRyZXNzIHx8IHRoaXMuc3RhdGUuc2VsZWN0ZWRBZGRyZXNzO1xyXG4gICAgY29uc3QgY3VycmVudFN0YXRlID0gdGhpcy5nZXRBZGRyZXNzU3RhdGUoc2VsZWN0ZWRBZGRyZXNzKSB8fCBjbG9uZURlZXAodGhpcy5kZWZhdWx0UHJlZmVyZW5jZXMpO1xyXG5cclxuICAgIGNvbnN0IG1lcmdlZFN0YXRlID0gX29iamVjdFNwcmVhZCQxKF9vYmplY3RTcHJlYWQkMSh7fSwgY3VycmVudFN0YXRlKSwgcHJlZmVyZW5jZXMpO1xyXG5cclxuICAgIHRoaXMudXBkYXRlKHtcclxuICAgICAgaWRlbnRpdGllczogX29iamVjdFNwcmVhZCQxKF9vYmplY3RTcHJlYWQkMSh7fSwgdGhpcy5zdGF0ZS5pZGVudGl0aWVzKSwge30sIHtcclxuICAgICAgICBbc2VsZWN0ZWRBZGRyZXNzXTogbWVyZ2VkU3RhdGVcclxuICAgICAgfSlcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIG1lcmdlZFN0YXRlO1xyXG4gIH1cclxuXHJcbiAgaGVhZGVycyhhZGRyZXNzKSB7XHJcbiAgICB2YXIgX3RoaXMkZ2V0QWRkcmVzc1N0YXRlNztcclxuXHJcbiAgICBjb25zdCBzZWxlY3RlZEFkZHJlc3MgPSBhZGRyZXNzIHx8IHRoaXMuc3RhdGUuc2VsZWN0ZWRBZGRyZXNzO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgIEF1dGhvcml6YXRpb246IFwiQmVhcmVyIFwiLmNvbmNhdCgoKF90aGlzJGdldEFkZHJlc3NTdGF0ZTcgPSB0aGlzLmdldEFkZHJlc3NTdGF0ZShzZWxlY3RlZEFkZHJlc3MpKSA9PT0gbnVsbCB8fCBfdGhpcyRnZXRBZGRyZXNzU3RhdGU3ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRnZXRBZGRyZXNzU3RhdGU3Lmp3dFRva2VuKSB8fCBcIlwiKSxcclxuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIlxyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgc3RhdHVzIG9mIHRoZSB0cmFuc2FjdGlvbi4gRWFjaCBzdGF0dXMgcmVwcmVzZW50cyB0aGUgc3RhdGUgb2YgdGhlIHRyYW5zYWN0aW9uIGludGVybmFsbHlcclxuICogaW4gdGhlIHdhbGxldC4gU29tZSBvZiB0aGVzZSBjb3JyZXNwb25kIHdpdGggdGhlIHN0YXRlIG9mIHRoZSB0cmFuc2FjdGlvbiBvbiB0aGUgbmV0d29yaywgYnV0XHJcbiAqIHNvbWUgYXJlIHdhbGxldC1zcGVjaWZpYy5cclxuICovXHJcbnZhciBUcmFuc2FjdGlvblN0YXR1cztcclxuXHJcbihmdW5jdGlvbiAoVHJhbnNhY3Rpb25TdGF0dXMpIHtcclxuICBUcmFuc2FjdGlvblN0YXR1c1tcImFwcHJvdmVkXCJdID0gXCJhcHByb3ZlZFwiO1xyXG4gIFRyYW5zYWN0aW9uU3RhdHVzW1wiY2FuY2VsbGVkXCJdID0gXCJjYW5jZWxsZWRcIjtcclxuICBUcmFuc2FjdGlvblN0YXR1c1tcImNvbmZpcm1lZFwiXSA9IFwiY29uZmlybWVkXCI7XHJcbiAgVHJhbnNhY3Rpb25TdGF0dXNbXCJmYWlsZWRcIl0gPSBcImZhaWxlZFwiO1xyXG4gIFRyYW5zYWN0aW9uU3RhdHVzW1wiZmluYWxpemVkXCJdID0gXCJmaW5hbGl6ZWRcIjtcclxuICBUcmFuc2FjdGlvblN0YXR1c1tcInByb2Nlc3NlZFwiXSA9IFwicHJvY2Vzc2VkXCI7XHJcbiAgVHJhbnNhY3Rpb25TdGF0dXNbXCJyZWplY3RlZFwiXSA9IFwicmVqZWN0ZWRcIjtcclxuICBUcmFuc2FjdGlvblN0YXR1c1tcInNpZ25lZFwiXSA9IFwic2lnbmVkXCI7XHJcbiAgVHJhbnNhY3Rpb25TdGF0dXNbXCJzdWJtaXR0ZWRcIl0gPSBcInN1Ym1pdHRlZFwiO1xyXG4gIFRyYW5zYWN0aW9uU3RhdHVzW1widW5hcHByb3ZlZFwiXSA9IFwidW5hcHByb3ZlZFwiO1xyXG4gIFRyYW5zYWN0aW9uU3RhdHVzW1wiZHJvcHBlZFwiXSA9IFwiZHJvcHBlZFwiO1xyXG4gIFRyYW5zYWN0aW9uU3RhdHVzW1wiZXhwaXJlZFwiXSA9IFwiZXhwaXJlZFwiO1xyXG59KShUcmFuc2FjdGlvblN0YXR1cyB8fCAoVHJhbnNhY3Rpb25TdGF0dXMgPSB7fSkpO1xyXG5cclxuY29uc3QgVFJBTlNBQ1RJT05fVFlQRVMgPSB7XHJcbiAgQ09OVFJBQ1RfSU5URVJBQ1RJT046IFwiY29udHJhY3RJbnRlcmFjdGlvblwiLFxyXG4gIERFUExPWV9DT05UUkFDVDogXCJjb250cmFjdERlcGxveW1lbnRcIixcclxuICBTVEFOREFSRF9UUkFOU0FDVElPTjogXCJ0cmFuc2FjdGlvblwiLFxyXG4gIFNUQU5EQVJEX1BBWU1FTlRfVFJBTlNBQ1RJT046IFwicGF5bWVudF90cmFuc2FjdGlvblwiIC8vIHNwZWNpZmljIHRvIGNoYWlucyBsaWtlIHNvbGFuYSBhbmQgY2FzcGVyXHJcblxyXG59O1xyXG5jb25zdCBUWF9FVkVOVFMgPSB7XHJcbiAgVFhfV0FSTklORzogXCJ0eDp3YXJuaW5nXCIsXHJcbiAgVFhfRVJST1I6IFwidHg6ZXJyb3JcIixcclxuICBUWF9GQUlMRUQ6IFwidHg6ZmFpbGVkXCIsXHJcbiAgVFhfQ09ORklSTUVEOiBcInR4OmNvbmZpcm1lZFwiLFxyXG4gIFRYX0RST1BQRUQ6IFwidHg6ZHJvcHBlZFwiLFxyXG4gIFRYX0VYUElSRUQ6IFwidHg6ZXhwaXJlZFwiLFxyXG4gIFRYX1NUQVRVU19VUERBVEU6IFwidHg6c3RhdHVzX3VwZGF0ZVwiLFxyXG4gIFRYX1VOQVBQUk9WRUQ6IFwidHg6dW5hcHByb3ZlZFwiXHJcbn07XHJcblxyXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxyXG5cclxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307IGkgJSAyID8gb3duS2V5cyhPYmplY3Qoc291cmNlKSwgITApLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSkgOiBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IHJldHVybiB0YXJnZXQ7IH1cclxuY2xhc3MgQmFzZVRyYW5zYWN0aW9uU3RhdGVNYW5hZ2VyIGV4dGVuZHMgQmFzZUNvbnRyb2xsZXIge1xyXG4gIGNvbnN0cnVjdG9yKF9yZWYpIHtcclxuICAgIGxldCB7XHJcbiAgICAgIGNvbmZpZyxcclxuICAgICAgc3RhdGUsXHJcbiAgICAgIGdldEN1cnJlbnRDaGFpbklkXHJcbiAgICB9ID0gX3JlZjtcclxuICAgIHN1cGVyKHtcclxuICAgICAgY29uZmlnLFxyXG4gICAgICBzdGF0ZVxyXG4gICAgfSk7XHJcblxyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2V0Q3VycmVudENoYWluSWRcIiwgdm9pZCAwKTtcclxuXHJcbiAgICB0aGlzLmRlZmF1bHRDb25maWcgPSB7XHJcbiAgICAgIHR4SGlzdG9yeUxpbWl0OiA0MFxyXG4gICAgfTtcclxuICAgIHRoaXMuZGVmYXVsdFN0YXRlID0ge1xyXG4gICAgICB0cmFuc2FjdGlvbnM6IHt9LFxyXG4gICAgICB1bmFwcHJvdmVkVHhzOiB7fSxcclxuICAgICAgY3VycmVudE5ldHdvcmtUeHNMaXN0OiBbXVxyXG4gICAgfTtcclxuICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xyXG4gICAgdGhpcy5nZXRDdXJyZW50Q2hhaW5JZCA9IGdldEN1cnJlbnRDaGFpbklkO1xyXG4gIH1cclxuXHJcbiAgZ2V0VW5hcHByb3ZlZFR4TGlzdCgpIHtcclxuICAgIGNvbnN0IGNoYWluSWQgPSB0aGlzLmdldEN1cnJlbnRDaGFpbklkKCk7XHJcbiAgICByZXR1cm4gcGlja0J5KHRoaXMuc3RhdGUudHJhbnNhY3Rpb25zLCB0cmFuc2FjdGlvbiA9PiB0cmFuc2FjdGlvbi5zdGF0dXMgPT09IFRyYW5zYWN0aW9uU3RhdHVzLnVuYXBwcm92ZWQgJiYgdHJhbnNhY3Rpb25NYXRjaGVzTmV0d29yayh0cmFuc2FjdGlvbiwgY2hhaW5JZCkpO1xyXG4gIH1cclxuXHJcbiAgZ2V0VHJhbnNhY3Rpb24odHhJZCkge1xyXG4gICAgY29uc3Qge1xyXG4gICAgICB0cmFuc2FjdGlvbnNcclxuICAgIH0gPSB0aGlzLnN0YXRlO1xyXG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uc1t0eElkXTtcclxuICB9XHJcblxyXG4gIHVwZGF0ZVRyYW5zYWN0aW9uKHR4TWV0YSkge1xyXG4gICAgLy8gY29tbWl0IHR4TWV0YSB0byBzdGF0ZVxyXG4gICAgY29uc3QgdHhJZCA9IHR4TWV0YS5pZDtcclxuICAgIHR4TWV0YS51cGRhdGVkX2F0ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xyXG4gICAgdGhpcy51cGRhdGUoe1xyXG4gICAgICB0cmFuc2FjdGlvbnM6IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgdGhpcy5zdGF0ZS50cmFuc2FjdGlvbnMpLCB7fSwge1xyXG4gICAgICAgIFt0eElkXTogdHhNZXRhXHJcbiAgICAgIH0pXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHNldFR4U3RhdHVzUmVqZWN0ZWQodHhJZCkge1xyXG4gICAgdGhpcy5fc2V0VHJhbnNhY3Rpb25TdGF0dXModHhJZCwgVHJhbnNhY3Rpb25TdGF0dXMucmVqZWN0ZWQpO1xyXG5cclxuICAgIHRoaXMuX2RlbGV0ZVRyYW5zYWN0aW9uKHR4SWQpO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBUaGUgaW1wbGVtZW50aW5nIGNvbnRyb2xsZXIgY2FuIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb25hbGl0eSBhbmQgYWRkIGN1c3RvbSBsb2dpYyArIGNhbGwgc3VwZXIuKClcclxuICAgKi9cclxuXHJcblxyXG4gIHNldFR4U3RhdHVzVW5hcHByb3ZlZCh0eElkKSB7XHJcbiAgICB0aGlzLl9zZXRUcmFuc2FjdGlvblN0YXR1cyh0eElkLCBUcmFuc2FjdGlvblN0YXR1cy51bmFwcHJvdmVkKTtcclxuICB9XHJcblxyXG4gIHNldFR4U3RhdHVzQXBwcm92ZWQodHhJZCkge1xyXG4gICAgdGhpcy5fc2V0VHJhbnNhY3Rpb25TdGF0dXModHhJZCwgVHJhbnNhY3Rpb25TdGF0dXMuYXBwcm92ZWQpO1xyXG4gIH1cclxuXHJcbiAgc2V0VHhTdGF0dXNTaWduZWQodHhJZCkge1xyXG4gICAgdGhpcy5fc2V0VHJhbnNhY3Rpb25TdGF0dXModHhJZCwgVHJhbnNhY3Rpb25TdGF0dXMuc2lnbmVkKTtcclxuICB9XHJcblxyXG4gIHNldFR4U3RhdHVzU3VibWl0dGVkKHR4SWQpIHtcclxuICAgIHRoaXMuX3NldFRyYW5zYWN0aW9uU3RhdHVzKHR4SWQsIFRyYW5zYWN0aW9uU3RhdHVzLnN1Ym1pdHRlZCk7XHJcbiAgfVxyXG5cclxuICBzZXRUeFN0YXR1c0Ryb3BwZWQodHhJZCkge1xyXG4gICAgdGhpcy5fc2V0VHJhbnNhY3Rpb25TdGF0dXModHhJZCwgVHJhbnNhY3Rpb25TdGF0dXMuZHJvcHBlZCk7XHJcbiAgfVxyXG5cclxuICBzZXRUeFN0YXR1c0V4cGlyZWQodHhJZCkge1xyXG4gICAgdGhpcy5fc2V0VHJhbnNhY3Rpb25TdGF0dXModHhJZCwgVHJhbnNhY3Rpb25TdGF0dXMuZXhwaXJlZCk7XHJcbiAgfVxyXG5cclxuICBzZXRUeFN0YXR1c0NvbmZpcm1lZCh0eElkKSB7XHJcbiAgICB0aGlzLl9zZXRUcmFuc2FjdGlvblN0YXR1cyh0eElkLCBUcmFuc2FjdGlvblN0YXR1cy5jb25maXJtZWQpO1xyXG4gIH1cclxuXHJcbiAgc2V0VHhTdGF0dXNGYWlsZWQodHhJZCwgZXJyb3JfKSB7XHJcbiAgICBjb25zdCBlcnJvciA9ICFlcnJvcl8gPyBuZXcgRXJyb3IoXCJJbnRlcm5hbCB0b3J1cyBmYWlsdXJlXCIpIDogZXJyb3JfO1xyXG4gICAgY29uc3QgdHhNZXRhID0gdGhpcy5nZXRUcmFuc2FjdGlvbih0eElkKTtcclxuICAgIHR4TWV0YS5lcnJvciA9IGVycm9yO1xyXG4gICAgdGhpcy51cGRhdGVUcmFuc2FjdGlvbih0eE1ldGEpO1xyXG5cclxuICAgIHRoaXMuX3NldFRyYW5zYWN0aW9uU3RhdHVzKHR4SWQsIFRyYW5zYWN0aW9uU3RhdHVzLmZhaWxlZCk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIE1ldGhvZCB0byBkZXRlcm1pbmUgaWYgdGhlIHRyYW5zYWN0aW9uIGlzIGluIGEgZmluYWwgc3RhdGVcclxuICAgKiBAcGFyYW0gc3RhdHVzIC0gVHJhbnNhY3Rpb24gc3RhdHVzXHJcbiAgICogQHJldHVybnMgYm9vbGVhbiBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgaW4gYSBmaW5hbCBzdGF0ZVxyXG4gICAqL1xyXG5cclxuXHJcbiAgaXNGaW5hbFN0YXRlKHN0YXR1cykge1xyXG4gICAgcmV0dXJuIHN0YXR1cyA9PT0gVHJhbnNhY3Rpb25TdGF0dXMucmVqZWN0ZWQgfHwgc3RhdHVzID09PSBUcmFuc2FjdGlvblN0YXR1cy5zdWJtaXR0ZWQgfHwgc3RhdHVzID09PSBUcmFuc2FjdGlvblN0YXR1cy5jb25maXJtZWQgfHwgc3RhdHVzID09PSBUcmFuc2FjdGlvblN0YXR1cy5mYWlsZWQgfHwgc3RhdHVzID09PSBUcmFuc2FjdGlvblN0YXR1cy5jYW5jZWxsZWQgfHwgc3RhdHVzID09PSBUcmFuc2FjdGlvblN0YXR1cy5leHBpcmVkO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBGaWx0ZXJzIG91dCB0aGUgdW5hcHByb3ZlZCB0cmFuc2FjdGlvbnMgZnJvbSBzdGF0ZVxyXG4gICAqL1xyXG5cclxuXHJcbiAgY2xlYXJVbmFwcHJvdmVkVHhzKCkge1xyXG4gICAgdGhpcy51cGRhdGUoe1xyXG4gICAgICB0cmFuc2FjdGlvbnM6IG9taXRCeSh0aGlzLnN0YXRlLnRyYW5zYWN0aW9ucywgdHJhbnNhY3Rpb24gPT4gdHJhbnNhY3Rpb24uc3RhdHVzID09PSBUcmFuc2FjdGlvblN0YXR1cy51bmFwcHJvdmVkKVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIHdpbGwgYXBwZW5kIG5ldyB0cmFuc2FjdGlvbnMgdG8gb2xkIHR4bnMuXHJcbiAgICovXHJcblxyXG5cclxuICBfYWRkVHJhbnNhY3Rpb25zVG9TdGF0ZSh0cmFuc2FjdGlvbnMpIHtcclxuICAgIHRoaXMudXBkYXRlKHtcclxuICAgICAgdHJhbnNhY3Rpb25zOiB0cmFuc2FjdGlvbnMucmVkdWNlKChyZXN1bHQsIG5ld1R4KSA9PiB7XHJcbiAgICAgICAgcmVzdWx0W25ld1R4LmlkXSA9IG5ld1R4O1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgIH0sIHRoaXMuc3RhdGUudHJhbnNhY3Rpb25zKVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIHdpbGwgc2V0IG5ldyB0eG5zLCBvdmVycmlkZSBleGlzdGluZyBpZiBhbnkgaW4gc3RhdGUuXHJcbiAgICovXHJcblxyXG5cclxuICBfc2V0VHJhbnNhY3Rpb25zVG9TdGF0ZSh0cmFuc2FjdGlvbnMpIHtcclxuICAgIHRoaXMudXBkYXRlKHtcclxuICAgICAgdHJhbnNhY3Rpb25zOiB0cmFuc2FjdGlvbnMucmVkdWNlKChyZXN1bHQsIG5ld1R4KSA9PiB7XHJcbiAgICAgICAgcmVzdWx0W25ld1R4LmlkXSA9IG5ld1R4O1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgIH0sIHt9KVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBfZGVsZXRlVHJhbnNhY3Rpb24odGFyZ2V0VHJhbnNhY3Rpb25JZCkge1xyXG4gICAgY29uc3Qge1xyXG4gICAgICB0cmFuc2FjdGlvbnNcclxuICAgIH0gPSB0aGlzLnN0YXRlO1xyXG4gICAgZGVsZXRlIHRyYW5zYWN0aW9uc1t0YXJnZXRUcmFuc2FjdGlvbklkXTtcclxuICAgIHRoaXMudXBkYXRlKHtcclxuICAgICAgdHJhbnNhY3Rpb25zXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIF9kZWxldGVUcmFuc2FjdGlvbnModGFyZ2V0VHJhbnNhY3Rpb25JZHMpIHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgdHJhbnNhY3Rpb25zXHJcbiAgICB9ID0gdGhpcy5zdGF0ZTtcclxuICAgIHRhcmdldFRyYW5zYWN0aW9uSWRzLmZvckVhY2godHJhbnNhY3Rpb25JZCA9PiB7XHJcbiAgICAgIGRlbGV0ZSB0cmFuc2FjdGlvbnNbdHJhbnNhY3Rpb25JZF07XHJcbiAgICB9KTtcclxuICAgIHRoaXMudXBkYXRlKHtcclxuICAgICAgdHJhbnNhY3Rpb25zXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIF9zZXRUcmFuc2FjdGlvblN0YXR1cyh0eElkLCBzdGF0dXMpIHtcclxuICAgIGNvbnN0IHR4TWV0YSA9IHRoaXMuZ2V0VHJhbnNhY3Rpb24odHhJZCk7XHJcblxyXG4gICAgaWYgKCF0eE1ldGEpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHR4TWV0YS5zdGF0dXMgPSBzdGF0dXM7IC8vIG9ubHkgdXBkYXRpbmcgc3RhdHVzIHNvIG5vIHZhbGlkYXRpb24gcmVxdWlyZWQgb24gdHhuLlxyXG5cclxuICAgIHRoaXMudXBkYXRlVHJhbnNhY3Rpb24odHhNZXRhKTtcclxuICAgIHRoaXMuZW1pdChUWF9FVkVOVFMuVFhfU1RBVFVTX1VQREFURSwge1xyXG4gICAgICB0eElkLFxyXG4gICAgICBzdGF0dXNcclxuICAgIH0pO1xyXG5cclxuICAgIGlmICh0aGlzLmlzRmluYWxTdGF0ZShzdGF0dXMpKSB7XHJcbiAgICAgIHRoaXMuZW1pdChcIlwiLmNvbmNhdCh0eE1ldGEuaWQsIFwiOmZpbmlzaGVkXCIpLCB0eE1ldGEpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5lbWl0KFwiXCIuY29uY2F0KHR4TWV0YS5pZCwgXCI6XCIpLmNvbmNhdChzdGF0dXMpLCB0eElkKTtcclxuICAgIH1cclxuICB9XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBBQ0NPVU5UX0NBVEVHT1JZLCBBQ1RJVklUWV9BQ1RJT04sIEFDVElWSVRZX0FDVElPTl9BTEwsIEFDVElWSVRZX0FDVElPTl9SRUNFSVZFLCBBQ1RJVklUWV9BQ1RJT05fU0VORCwgQUNUSVZJVFlfQUNUSU9OX1RPUFVQLCBBQ1RJVklUWV9QRVJJT0RfQUxMLCBBQ1RJVklUWV9QRVJJT0RfTU9OVEhfT05FLCBBQ1RJVklUWV9QRVJJT0RfTU9OVEhfU0lYLCBBQ1RJVklUWV9QRVJJT0RfV0VFS19PTkUsIEFDVElWSVRZX1NUQVRVU19DQU5DRUxMRUQsIEFDVElWSVRZX1NUQVRVU19DQU5DRUxMSU5HLCBBQ1RJVklUWV9TVEFUVVNfUEVORElORywgQUNUSVZJVFlfU1RBVFVTX1NVQ0NFU1NGVUwsIEFDVElWSVRZX1NUQVRVU19VTlNVQ0NFU1NGVUwsIEJST0FEQ0FTVF9DSEFOTkVMUywgQlJPQURDQVNUX0NIQU5ORUxTX01TR1MsIEJhc2VCbG9ja1RyYWNrZXIsIEJhc2VDb250cm9sbGVyLCBCYXNlQ3VycmVuY3lDb250cm9sbGVyLCBCYXNlRW1iZWRDb250cm9sbGVyLCBCYXNlS2V5cmluZ0NvbnRyb2xsZXIsIEJhc2VQcmVmZXJlbmNlc0NvbnRyb2xsZXIsIEJhc2VUcmFuc2FjdGlvblN0YXRlTWFuYWdlciwgQnJvYWRjYXN0Q2hhbm5lbEhhbmRsZXIsIENPTU1VTklDQVRJT05fSlJQQ19NRVRIT0RTLCBDT01NVU5JQ0FUSU9OX05PVElGSUNBVElPTlMsIENvbW11bmljYXRpb25XaW5kb3dNYW5hZ2VyLCBERUZBVUxUX1BSRUZFUkVOQ0VTLCBGRUFUVVJFU19DT05GSVJNX1dJTkRPVywgRkVBVFVSRVNfREVGQVVMVF9QT1BVUF9XSU5ET1csIEZFQVRVUkVTX0RFRkFVTFRfV0FMTEVUX1dJTkRPVywgRkVBVFVSRVNfUFJPVklERVJfQ0hBTkdFX1dJTkRPVywgTE9HSU5fUFJPVklERVIsIFBBWU1FTlRfUFJPVklERVIsIFBPUFVQX0xPQURFRCwgUE9QVVBfUkVTVUxULCBQUk9WSURFUl9KUlBDX01FVEhPRFMsIFBST1ZJREVSX05PVElGSUNBVElPTlMsIFBvcHVwSGFuZGxlciwgUG9wdXBTdG9yZUNoYW5uZWwsIFBvcHVwV2l0aEJjSGFuZGxlciwgUmVkaXJlY3RIYW5kbGVyLCBTRVRVUF9DT01QTEVURSwgU3RyZWFtV2luZG93LCBUUkFOU0FDVElPTl9UWVBFUywgVFhfRVZFTlRTLCBUcmFuc2FjdGlvblN0YXR1cywgVXNlckVycm9yLCBhZGRyZXNzU2xpY2VyLCBicm9hZGNhc3RDaGFubmVsT3B0aW9ucywgY29uY2F0U2lnLCBjcmVhdGVDaGFuZ2VQcm92aWRlck1pZGRsZXdhcmVNaWRkbGV3YXJlLCBjcmVhdGVDb21tdW5pY2F0aW9uTWlkZGxld2FyZSwgY3JlYXRlRXZlbnRFbWl0dGVyUHJveHksIGNyZWF0ZUZldGNoQ29uZmlnRnJvbVJlcSwgY3JlYXRlRmV0Y2hNaWRkbGV3YXJlLCBjcmVhdGVHZW5lcmljSlJQQ01pZGRsZXdhcmUsIGNyZWF0ZUxvZ2dlck1pZGRsZXdhcmUsIGNyZWF0ZU9yaWdpbk1pZGRsZXdhcmUsIGNyZWF0ZVJhbmRvbUlkLCBjcmVhdGVTd2FwcGFibGVQcm94eSwgY3JlYXRlVG9wdXBNaWRkbGV3YXJlLCBmb3JtYXREYXRlLCBmb3JtYXRTbWFsbE51bWJlcnMsIGZvcm1hdFRpbWUsIGdldEN1c3RvbURldmljZUluZm8sIGdldFBvcHVwRmVhdHVyZXMsIGdldFR4U3RhdHVzVGV4dCwgaGFuZGxlUmVkaXJlY3RQYXJhbWV0ZXJzLCBoYXNoTWVzc2FnZSwgaW50VG9IZXgsIHBhZFdpdGhaZXJvZXMsIHByb3ZpZGVyQXNNaWRkbGV3YXJlLCBwcm92aWRlckZyb21FbmdpbmUsIHByb3ZpZGVyRnJvbU1pZGRsZXdhcmUsIHJhbmRvbUlkLCBzaWduTWVzc2FnZSwgc2lnbmlmaWNhbnREaWdpdHMsIHRpbWVvdXQkMSBhcyB0aW1lb3V0LCB0cmFuc2FjdGlvbk1hdGNoZXNOZXR3b3JrIH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2VDb250cm9sbGVycy5lc20uanMubWFwXHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@toruslabs/base-controllers/dist/baseControllers.esm.js\n");

/***/ }),

/***/ "./node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"clearAPIKey\": function() { return /* binding */ clearAPIKey; },\n/* harmony export */   \"clearEmbedHost\": function() { return /* binding */ clearEmbedHost; },\n/* harmony export */   \"gatewayAuthHeader\": function() { return /* binding */ gatewayAuthHeader; },\n/* harmony export */   \"gatewayEmbedHostHeader\": function() { return /* binding */ gatewayEmbedHostHeader; },\n/* harmony export */   \"generateJsonRPCObject\": function() { return /* binding */ generateJsonRPCObject; },\n/* harmony export */   \"get\": function() { return /* binding */ get; },\n/* harmony export */   \"getAPIKey\": function() { return /* binding */ getAPIKey; },\n/* harmony export */   \"getEmbedHost\": function() { return /* binding */ getEmbedHost; },\n/* harmony export */   \"patch\": function() { return /* binding */ patch; },\n/* harmony export */   \"post\": function() { return /* binding */ post; },\n/* harmony export */   \"promiseRace\": function() { return /* binding */ promiseRace; },\n/* harmony export */   \"promiseTimeout\": function() { return /* binding */ promiseTimeout; },\n/* harmony export */   \"remove\": function() { return /* binding */ remove; },\n/* harmony export */   \"setAPIKey\": function() { return /* binding */ setAPIKey; },\n/* harmony export */   \"setEmbedHost\": function() { return /* binding */ setEmbedHost; },\n/* harmony export */   \"setLogLevel\": function() { return /* binding */ setLogLevel; }\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/esm/defineProperty.js\");\n/* harmony import */ var lodash_merge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash.merge */ \"./node_modules/lodash.merge/index.js\");\n/* harmony import */ var lodash_merge__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_merge__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! loglevel */ \"./node_modules/loglevel/lib/loglevel.js\");\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(loglevel__WEBPACK_IMPORTED_MODULE_2__);\n\r\n\r\n\r\n\r\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\r\n\r\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\r\nconst log = loglevel__WEBPACK_IMPORTED_MODULE_2___default().getLogger(\"http-helpers\");\r\nlog.setLevel(loglevel__WEBPACK_IMPORTED_MODULE_2__.levels.INFO);\r\nlet apiKey = \"torus-default\";\r\nlet embedHost = \"\"; // #region API Keys\r\n\r\nconst gatewayAuthHeader = \"x-api-key\";\r\nconst gatewayEmbedHostHeader = \"x-embed-host\";\r\nfunction setEmbedHost(embedHost_) {\r\n  embedHost = embedHost_;\r\n}\r\nfunction clearEmbedHost() {\r\n  embedHost = \"\";\r\n}\r\nfunction getEmbedHost() {\r\n  return embedHost;\r\n}\r\nfunction setAPIKey(apiKey_) {\r\n  apiKey = apiKey_;\r\n}\r\nfunction clearAPIKey() {\r\n  apiKey = \"torus-default\";\r\n}\r\nfunction getAPIKey() {\r\n  return apiKey;\r\n} // #endregion\r\n\r\nfunction setLogLevel(level) {\r\n  log.setLevel(level);\r\n}\r\n\r\nfunction getApiKeyHeaders() {\r\n  const headers = {};\r\n  if (apiKey) headers[gatewayAuthHeader] = apiKey;\r\n  if (embedHost) headers[gatewayEmbedHostHeader] = embedHost;\r\n  return headers;\r\n}\r\n\r\nfunction debugLogResponse(response) {\r\n  log.info(\"Response: \".concat(response.status, \" \").concat(response.statusText));\r\n  log.info(\"Url: \".concat(response.url));\r\n}\r\n\r\nconst promiseTimeout = (ms, promise) => {\r\n  const timeout = new Promise((resolve, reject) => {\r\n    const id = setTimeout(() => {\r\n      clearTimeout(id);\r\n      reject(new Error(\"Timed out in \".concat(ms, \"ms\")));\r\n    }, ms);\r\n  });\r\n  return Promise.race([promise, timeout]);\r\n};\r\nconst get = async function (url) {\r\n  let options_ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\r\n  let customOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\r\n  const defaultOptions = {\r\n    mode: \"cors\",\r\n    headers: {}\r\n  };\r\n\r\n  if (customOptions.useAPIKey) {\r\n    defaultOptions.headers = _objectSpread(_objectSpread({}, defaultOptions.headers), getApiKeyHeaders());\r\n  }\r\n\r\n  const options = lodash_merge__WEBPACK_IMPORTED_MODULE_1___default()(defaultOptions, options_, {\r\n    method: \"GET\"\r\n  });\r\n  const response = await fetch(url, options);\r\n\r\n  if (response.ok) {\r\n    return response.json();\r\n  }\r\n\r\n  debugLogResponse(response);\r\n  throw response;\r\n};\r\nconst post = function (url) {\r\n  let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\r\n  let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\r\n  let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\r\n  const defaultOptions = {\r\n    mode: \"cors\",\r\n    headers: {\r\n      \"Content-Type\": \"application/json; charset=utf-8\"\r\n    }\r\n  };\r\n\r\n  if (customOptions.useAPIKey) {\r\n    defaultOptions.headers = _objectSpread(_objectSpread({}, defaultOptions.headers), getApiKeyHeaders());\r\n  }\r\n\r\n  const options = lodash_merge__WEBPACK_IMPORTED_MODULE_1___default()(defaultOptions, options_, {\r\n    method: \"POST\"\r\n  }); // deep merge changes the structure of form data and url encoded data ,\r\n  // so we should not deepmerge body data\r\n\r\n  if (customOptions.isUrlEncodedData) {\r\n    // for multipart request browser/client will add multipart content type\r\n    // along with multipart boundary , so for multipart request send\r\n    // content-type: undefined or send with multipart boundary if already known\r\n    options.body = data; // If url encoded data, this must not be the content type\r\n\r\n    if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\r\n  } else {\r\n    options.body = JSON.stringify(data);\r\n  }\r\n\r\n  return promiseTimeout(customOptions.timeout || 60000, fetch(url, options).then(response => {\r\n    if (response.ok) {\r\n      return response.json();\r\n    }\r\n\r\n    debugLogResponse(response);\r\n    throw response;\r\n  }));\r\n};\r\nconst patch = async function (url) {\r\n  let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\r\n  let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\r\n  let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\r\n  const defaultOptions = {\r\n    mode: \"cors\",\r\n    headers: {\r\n      \"Content-Type\": \"application/json; charset=utf-8\"\r\n    }\r\n  }; // for multipart request browser/client will add multipart content type\r\n  // along with multipart boundary , so for multipart request send\r\n  // content-type: undefined or send with multipart boundary if already known\r\n\r\n  if (customOptions.useAPIKey) {\r\n    defaultOptions.headers = _objectSpread(_objectSpread({}, defaultOptions.headers), getApiKeyHeaders());\r\n  }\r\n\r\n  const options = lodash_merge__WEBPACK_IMPORTED_MODULE_1___default()(defaultOptions, options_, {\r\n    method: \"PATCH\"\r\n  }); // deep merge changes the structure of form data and url encoded data ,\r\n  // so we should not deepmerge body data\r\n\r\n  if (customOptions.isUrlEncodedData) {\r\n    // for multipart request browser/client will add multipart content type\r\n    // along with multipart boundary , so for multipart request send\r\n    // content-type: undefined or send with multipart boundary if already known\r\n    options.body = data; // If url encoded data, this must not be the content type\r\n\r\n    if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\r\n  } else {\r\n    options.body = JSON.stringify(data);\r\n  }\r\n\r\n  const response = await fetch(url, options);\r\n\r\n  if (response.ok) {\r\n    return response.json();\r\n  }\r\n\r\n  debugLogResponse(response);\r\n  throw response;\r\n};\r\nconst remove = async function (url) {\r\n  let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\r\n  let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\r\n  let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\r\n  const defaultOptions = {\r\n    mode: \"cors\",\r\n    headers: {\r\n      \"Content-Type\": \"application/json; charset=utf-8\"\r\n    }\r\n  }; // for multipart request browser/client will add multipart content type\r\n  // along with multipart boundary , so for multipart request send\r\n  // content-type: undefined or send with multipart boundary if already known\r\n\r\n  if (customOptions.useAPIKey) {\r\n    defaultOptions.headers = _objectSpread(_objectSpread({}, defaultOptions.headers), getApiKeyHeaders());\r\n  }\r\n\r\n  const options = lodash_merge__WEBPACK_IMPORTED_MODULE_1___default()(defaultOptions, options_, {\r\n    method: \"DELETE\"\r\n  });\r\n\r\n  if (customOptions.isUrlEncodedData) {\r\n    // for multipart request browser/client will add multipart content type\r\n    // along with multipart boundary , so for multipart request send\r\n    // content-type: undefined or send with multipart boundary if already known\r\n    options.body = data; // If url encoded data, this must not be the content type\r\n\r\n    if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\r\n  } else {\r\n    options.body = JSON.stringify(data);\r\n  }\r\n\r\n  const response = await fetch(url, options);\r\n\r\n  if (response.ok) {\r\n    return response.json();\r\n  }\r\n\r\n  debugLogResponse(response);\r\n  throw response;\r\n};\r\nconst generateJsonRPCObject = (method, parameters) => ({\r\n  jsonrpc: \"2.0\",\r\n  method,\r\n  id: 10,\r\n  params: parameters\r\n});\r\nconst promiseRace = function (url, options) {\r\n  let timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 60000;\r\n  return Promise.race([get(url, options), new Promise((resolve, reject) => {\r\n    setTimeout(() => {\r\n      reject(new Error(\"timed out\"));\r\n    }, timeout);\r\n  })]);\r\n};\r\n\r\n\r\n//# sourceMappingURL=httpHelpers.esm.js.map\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9odHRwLWhlbHBlcnMvZGlzdC9odHRwSGVscGVycy5lc20uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW9FO0FBQ25DO0FBQ1c7QUFDNUM7QUFDQSwyQ0FBMkMsZ0NBQWdDLG9DQUFvQyxvREFBb0QsNkRBQTZELGlFQUFpRSxzQ0FBc0M7QUFDdlU7QUFDQSxpQ0FBaUMsZ0JBQWdCLHNCQUFzQixPQUFPLHVEQUF1RCw2REFBNkQsaUZBQWUsNkJBQTZCLG9LQUFvSyxtRkFBbUYsS0FBSztBQUMxZSxZQUFZLHlEQUFrQjtBQUM5QixhQUFhLGlEQUFXO0FBQ3hCO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLGtCQUFrQixtREFBSztBQUN2QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0Esa0JBQWtCLG1EQUFLO0FBQ3ZCO0FBQ0EsR0FBRyxHQUFHO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsK0RBQStEO0FBQy9ELElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSxrQkFBa0IsbURBQUs7QUFDdkI7QUFDQSxHQUFHLEdBQUc7QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSwrREFBK0Q7QUFDL0QsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSxrQkFBa0IsbURBQUs7QUFDdkI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLCtEQUErRDtBQUMvRCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQytOO0FBQy9OIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AdG9ydXNsYWJzL2h0dHAtaGVscGVycy9kaXN0L2h0dHBIZWxwZXJzLmVzbS5qcz80NjJmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eSc7XHJcbmltcG9ydCBtZXJnZSBmcm9tICdsb2Rhc2gubWVyZ2UnO1xyXG5pbXBvcnQgbG9nTGV2ZWwsIHsgbGV2ZWxzIH0gZnJvbSAnbG9nbGV2ZWwnO1xyXG5cclxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGVudW1lcmFibGVPbmx5ICYmIChzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSkpLCBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cclxuXHJcbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpICUgMiA/IG93bktleXMoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XHJcbmNvbnN0IGxvZyA9IGxvZ0xldmVsLmdldExvZ2dlcihcImh0dHAtaGVscGVyc1wiKTtcclxubG9nLnNldExldmVsKGxldmVscy5JTkZPKTtcclxubGV0IGFwaUtleSA9IFwidG9ydXMtZGVmYXVsdFwiO1xyXG5sZXQgZW1iZWRIb3N0ID0gXCJcIjsgLy8gI3JlZ2lvbiBBUEkgS2V5c1xyXG5cclxuY29uc3QgZ2F0ZXdheUF1dGhIZWFkZXIgPSBcIngtYXBpLWtleVwiO1xyXG5jb25zdCBnYXRld2F5RW1iZWRIb3N0SGVhZGVyID0gXCJ4LWVtYmVkLWhvc3RcIjtcclxuZnVuY3Rpb24gc2V0RW1iZWRIb3N0KGVtYmVkSG9zdF8pIHtcclxuICBlbWJlZEhvc3QgPSBlbWJlZEhvc3RfO1xyXG59XHJcbmZ1bmN0aW9uIGNsZWFyRW1iZWRIb3N0KCkge1xyXG4gIGVtYmVkSG9zdCA9IFwiXCI7XHJcbn1cclxuZnVuY3Rpb24gZ2V0RW1iZWRIb3N0KCkge1xyXG4gIHJldHVybiBlbWJlZEhvc3Q7XHJcbn1cclxuZnVuY3Rpb24gc2V0QVBJS2V5KGFwaUtleV8pIHtcclxuICBhcGlLZXkgPSBhcGlLZXlfO1xyXG59XHJcbmZ1bmN0aW9uIGNsZWFyQVBJS2V5KCkge1xyXG4gIGFwaUtleSA9IFwidG9ydXMtZGVmYXVsdFwiO1xyXG59XHJcbmZ1bmN0aW9uIGdldEFQSUtleSgpIHtcclxuICByZXR1cm4gYXBpS2V5O1xyXG59IC8vICNlbmRyZWdpb25cclxuXHJcbmZ1bmN0aW9uIHNldExvZ0xldmVsKGxldmVsKSB7XHJcbiAgbG9nLnNldExldmVsKGxldmVsKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0QXBpS2V5SGVhZGVycygpIHtcclxuICBjb25zdCBoZWFkZXJzID0ge307XHJcbiAgaWYgKGFwaUtleSkgaGVhZGVyc1tnYXRld2F5QXV0aEhlYWRlcl0gPSBhcGlLZXk7XHJcbiAgaWYgKGVtYmVkSG9zdCkgaGVhZGVyc1tnYXRld2F5RW1iZWRIb3N0SGVhZGVyXSA9IGVtYmVkSG9zdDtcclxuICByZXR1cm4gaGVhZGVycztcclxufVxyXG5cclxuZnVuY3Rpb24gZGVidWdMb2dSZXNwb25zZShyZXNwb25zZSkge1xyXG4gIGxvZy5pbmZvKFwiUmVzcG9uc2U6IFwiLmNvbmNhdChyZXNwb25zZS5zdGF0dXMsIFwiIFwiKS5jb25jYXQocmVzcG9uc2Uuc3RhdHVzVGV4dCkpO1xyXG4gIGxvZy5pbmZvKFwiVXJsOiBcIi5jb25jYXQocmVzcG9uc2UudXJsKSk7XHJcbn1cclxuXHJcbmNvbnN0IHByb21pc2VUaW1lb3V0ID0gKG1zLCBwcm9taXNlKSA9PiB7XHJcbiAgY29uc3QgdGltZW91dCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgIGNvbnN0IGlkID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgIGNsZWFyVGltZW91dChpZCk7XHJcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJUaW1lZCBvdXQgaW4gXCIuY29uY2F0KG1zLCBcIm1zXCIpKSk7XHJcbiAgICB9LCBtcyk7XHJcbiAgfSk7XHJcbiAgcmV0dXJuIFByb21pc2UucmFjZShbcHJvbWlzZSwgdGltZW91dF0pO1xyXG59O1xyXG5jb25zdCBnZXQgPSBhc3luYyBmdW5jdGlvbiAodXJsKSB7XHJcbiAgbGV0IG9wdGlvbnNfID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcclxuICBsZXQgY3VzdG9tT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XHJcbiAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XHJcbiAgICBtb2RlOiBcImNvcnNcIixcclxuICAgIGhlYWRlcnM6IHt9XHJcbiAgfTtcclxuXHJcbiAgaWYgKGN1c3RvbU9wdGlvbnMudXNlQVBJS2V5KSB7XHJcbiAgICBkZWZhdWx0T3B0aW9ucy5oZWFkZXJzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBkZWZhdWx0T3B0aW9ucy5oZWFkZXJzKSwgZ2V0QXBpS2V5SGVhZGVycygpKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IG9wdGlvbnMgPSBtZXJnZShkZWZhdWx0T3B0aW9ucywgb3B0aW9uc18sIHtcclxuICAgIG1ldGhvZDogXCJHRVRcIlxyXG4gIH0pO1xyXG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCBvcHRpb25zKTtcclxuXHJcbiAgaWYgKHJlc3BvbnNlLm9rKSB7XHJcbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xyXG4gIH1cclxuXHJcbiAgZGVidWdMb2dSZXNwb25zZShyZXNwb25zZSk7XHJcbiAgdGhyb3cgcmVzcG9uc2U7XHJcbn07XHJcbmNvbnN0IHBvc3QgPSBmdW5jdGlvbiAodXJsKSB7XHJcbiAgbGV0IGRhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xyXG4gIGxldCBvcHRpb25zXyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XHJcbiAgbGV0IGN1c3RvbU9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xyXG4gIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xyXG4gICAgbW9kZTogXCJjb3JzXCIsXHJcbiAgICBoZWFkZXJzOiB7XHJcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiXHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgaWYgKGN1c3RvbU9wdGlvbnMudXNlQVBJS2V5KSB7XHJcbiAgICBkZWZhdWx0T3B0aW9ucy5oZWFkZXJzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBkZWZhdWx0T3B0aW9ucy5oZWFkZXJzKSwgZ2V0QXBpS2V5SGVhZGVycygpKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IG9wdGlvbnMgPSBtZXJnZShkZWZhdWx0T3B0aW9ucywgb3B0aW9uc18sIHtcclxuICAgIG1ldGhvZDogXCJQT1NUXCJcclxuICB9KTsgLy8gZGVlcCBtZXJnZSBjaGFuZ2VzIHRoZSBzdHJ1Y3R1cmUgb2YgZm9ybSBkYXRhIGFuZCB1cmwgZW5jb2RlZCBkYXRhICxcclxuICAvLyBzbyB3ZSBzaG91bGQgbm90IGRlZXBtZXJnZSBib2R5IGRhdGFcclxuXHJcbiAgaWYgKGN1c3RvbU9wdGlvbnMuaXNVcmxFbmNvZGVkRGF0YSkge1xyXG4gICAgLy8gZm9yIG11bHRpcGFydCByZXF1ZXN0IGJyb3dzZXIvY2xpZW50IHdpbGwgYWRkIG11bHRpcGFydCBjb250ZW50IHR5cGVcclxuICAgIC8vIGFsb25nIHdpdGggbXVsdGlwYXJ0IGJvdW5kYXJ5ICwgc28gZm9yIG11bHRpcGFydCByZXF1ZXN0IHNlbmRcclxuICAgIC8vIGNvbnRlbnQtdHlwZTogdW5kZWZpbmVkIG9yIHNlbmQgd2l0aCBtdWx0aXBhcnQgYm91bmRhcnkgaWYgYWxyZWFkeSBrbm93blxyXG4gICAgb3B0aW9ucy5ib2R5ID0gZGF0YTsgLy8gSWYgdXJsIGVuY29kZWQgZGF0YSwgdGhpcyBtdXN0IG5vdCBiZSB0aGUgY29udGVudCB0eXBlXHJcblxyXG4gICAgaWYgKG9wdGlvbnMuaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSA9PT0gXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIpIGRlbGV0ZSBvcHRpb25zLmhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl07XHJcbiAgfSBlbHNlIHtcclxuICAgIG9wdGlvbnMuYm9keSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHByb21pc2VUaW1lb3V0KGN1c3RvbU9wdGlvbnMudGltZW91dCB8fCA2MDAwMCwgZmV0Y2godXJsLCBvcHRpb25zKS50aGVuKHJlc3BvbnNlID0+IHtcclxuICAgIGlmIChyZXNwb25zZS5vaykge1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xyXG4gICAgfVxyXG5cclxuICAgIGRlYnVnTG9nUmVzcG9uc2UocmVzcG9uc2UpO1xyXG4gICAgdGhyb3cgcmVzcG9uc2U7XHJcbiAgfSkpO1xyXG59O1xyXG5jb25zdCBwYXRjaCA9IGFzeW5jIGZ1bmN0aW9uICh1cmwpIHtcclxuICBsZXQgZGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XHJcbiAgbGV0IG9wdGlvbnNfID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcclxuICBsZXQgY3VzdG9tT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XHJcbiAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XHJcbiAgICBtb2RlOiBcImNvcnNcIixcclxuICAgIGhlYWRlcnM6IHtcclxuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCJcclxuICAgIH1cclxuICB9OyAvLyBmb3IgbXVsdGlwYXJ0IHJlcXVlc3QgYnJvd3Nlci9jbGllbnQgd2lsbCBhZGQgbXVsdGlwYXJ0IGNvbnRlbnQgdHlwZVxyXG4gIC8vIGFsb25nIHdpdGggbXVsdGlwYXJ0IGJvdW5kYXJ5ICwgc28gZm9yIG11bHRpcGFydCByZXF1ZXN0IHNlbmRcclxuICAvLyBjb250ZW50LXR5cGU6IHVuZGVmaW5lZCBvciBzZW5kIHdpdGggbXVsdGlwYXJ0IGJvdW5kYXJ5IGlmIGFscmVhZHkga25vd25cclxuXHJcbiAgaWYgKGN1c3RvbU9wdGlvbnMudXNlQVBJS2V5KSB7XHJcbiAgICBkZWZhdWx0T3B0aW9ucy5oZWFkZXJzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBkZWZhdWx0T3B0aW9ucy5oZWFkZXJzKSwgZ2V0QXBpS2V5SGVhZGVycygpKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IG9wdGlvbnMgPSBtZXJnZShkZWZhdWx0T3B0aW9ucywgb3B0aW9uc18sIHtcclxuICAgIG1ldGhvZDogXCJQQVRDSFwiXHJcbiAgfSk7IC8vIGRlZXAgbWVyZ2UgY2hhbmdlcyB0aGUgc3RydWN0dXJlIG9mIGZvcm0gZGF0YSBhbmQgdXJsIGVuY29kZWQgZGF0YSAsXHJcbiAgLy8gc28gd2Ugc2hvdWxkIG5vdCBkZWVwbWVyZ2UgYm9keSBkYXRhXHJcblxyXG4gIGlmIChjdXN0b21PcHRpb25zLmlzVXJsRW5jb2RlZERhdGEpIHtcclxuICAgIC8vIGZvciBtdWx0aXBhcnQgcmVxdWVzdCBicm93c2VyL2NsaWVudCB3aWxsIGFkZCBtdWx0aXBhcnQgY29udGVudCB0eXBlXHJcbiAgICAvLyBhbG9uZyB3aXRoIG11bHRpcGFydCBib3VuZGFyeSAsIHNvIGZvciBtdWx0aXBhcnQgcmVxdWVzdCBzZW5kXHJcbiAgICAvLyBjb250ZW50LXR5cGU6IHVuZGVmaW5lZCBvciBzZW5kIHdpdGggbXVsdGlwYXJ0IGJvdW5kYXJ5IGlmIGFscmVhZHkga25vd25cclxuICAgIG9wdGlvbnMuYm9keSA9IGRhdGE7IC8vIElmIHVybCBlbmNvZGVkIGRhdGEsIHRoaXMgbXVzdCBub3QgYmUgdGhlIGNvbnRlbnQgdHlwZVxyXG5cclxuICAgIGlmIChvcHRpb25zLmhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPT09IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiKSBkZWxldGUgb3B0aW9ucy5oZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBvcHRpb25zLmJvZHkgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCBvcHRpb25zKTtcclxuXHJcbiAgaWYgKHJlc3BvbnNlLm9rKSB7XHJcbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xyXG4gIH1cclxuXHJcbiAgZGVidWdMb2dSZXNwb25zZShyZXNwb25zZSk7XHJcbiAgdGhyb3cgcmVzcG9uc2U7XHJcbn07XHJcbmNvbnN0IHJlbW92ZSA9IGFzeW5jIGZ1bmN0aW9uICh1cmwpIHtcclxuICBsZXQgZGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XHJcbiAgbGV0IG9wdGlvbnNfID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcclxuICBsZXQgY3VzdG9tT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XHJcbiAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XHJcbiAgICBtb2RlOiBcImNvcnNcIixcclxuICAgIGhlYWRlcnM6IHtcclxuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCJcclxuICAgIH1cclxuICB9OyAvLyBmb3IgbXVsdGlwYXJ0IHJlcXVlc3QgYnJvd3Nlci9jbGllbnQgd2lsbCBhZGQgbXVsdGlwYXJ0IGNvbnRlbnQgdHlwZVxyXG4gIC8vIGFsb25nIHdpdGggbXVsdGlwYXJ0IGJvdW5kYXJ5ICwgc28gZm9yIG11bHRpcGFydCByZXF1ZXN0IHNlbmRcclxuICAvLyBjb250ZW50LXR5cGU6IHVuZGVmaW5lZCBvciBzZW5kIHdpdGggbXVsdGlwYXJ0IGJvdW5kYXJ5IGlmIGFscmVhZHkga25vd25cclxuXHJcbiAgaWYgKGN1c3RvbU9wdGlvbnMudXNlQVBJS2V5KSB7XHJcbiAgICBkZWZhdWx0T3B0aW9ucy5oZWFkZXJzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBkZWZhdWx0T3B0aW9ucy5oZWFkZXJzKSwgZ2V0QXBpS2V5SGVhZGVycygpKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IG9wdGlvbnMgPSBtZXJnZShkZWZhdWx0T3B0aW9ucywgb3B0aW9uc18sIHtcclxuICAgIG1ldGhvZDogXCJERUxFVEVcIlxyXG4gIH0pO1xyXG5cclxuICBpZiAoY3VzdG9tT3B0aW9ucy5pc1VybEVuY29kZWREYXRhKSB7XHJcbiAgICAvLyBmb3IgbXVsdGlwYXJ0IHJlcXVlc3QgYnJvd3Nlci9jbGllbnQgd2lsbCBhZGQgbXVsdGlwYXJ0IGNvbnRlbnQgdHlwZVxyXG4gICAgLy8gYWxvbmcgd2l0aCBtdWx0aXBhcnQgYm91bmRhcnkgLCBzbyBmb3IgbXVsdGlwYXJ0IHJlcXVlc3Qgc2VuZFxyXG4gICAgLy8gY29udGVudC10eXBlOiB1bmRlZmluZWQgb3Igc2VuZCB3aXRoIG11bHRpcGFydCBib3VuZGFyeSBpZiBhbHJlYWR5IGtub3duXHJcbiAgICBvcHRpb25zLmJvZHkgPSBkYXRhOyAvLyBJZiB1cmwgZW5jb2RlZCBkYXRhLCB0aGlzIG11c3Qgbm90IGJlIHRoZSBjb250ZW50IHR5cGVcclxuXHJcbiAgICBpZiAob3B0aW9ucy5oZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID09PSBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIikgZGVsZXRlIG9wdGlvbnMuaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXTtcclxuICB9IGVsc2Uge1xyXG4gICAgb3B0aW9ucy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XHJcbiAgfVxyXG5cclxuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwgb3B0aW9ucyk7XHJcblxyXG4gIGlmIChyZXNwb25zZS5vaykge1xyXG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcclxuICB9XHJcblxyXG4gIGRlYnVnTG9nUmVzcG9uc2UocmVzcG9uc2UpO1xyXG4gIHRocm93IHJlc3BvbnNlO1xyXG59O1xyXG5jb25zdCBnZW5lcmF0ZUpzb25SUENPYmplY3QgPSAobWV0aG9kLCBwYXJhbWV0ZXJzKSA9PiAoe1xyXG4gIGpzb25ycGM6IFwiMi4wXCIsXHJcbiAgbWV0aG9kLFxyXG4gIGlkOiAxMCxcclxuICBwYXJhbXM6IHBhcmFtZXRlcnNcclxufSk7XHJcbmNvbnN0IHByb21pc2VSYWNlID0gZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xyXG4gIGxldCB0aW1lb3V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiA2MDAwMDtcclxuICByZXR1cm4gUHJvbWlzZS5yYWNlKFtnZXQodXJsLCBvcHRpb25zKSwgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJ0aW1lZCBvdXRcIikpO1xyXG4gICAgfSwgdGltZW91dCk7XHJcbiAgfSldKTtcclxufTtcclxuXHJcbmV4cG9ydCB7IGNsZWFyQVBJS2V5LCBjbGVhckVtYmVkSG9zdCwgZ2F0ZXdheUF1dGhIZWFkZXIsIGdhdGV3YXlFbWJlZEhvc3RIZWFkZXIsIGdlbmVyYXRlSnNvblJQQ09iamVjdCwgZ2V0LCBnZXRBUElLZXksIGdldEVtYmVkSG9zdCwgcGF0Y2gsIHBvc3QsIHByb21pc2VSYWNlLCBwcm9taXNlVGltZW91dCwgcmVtb3ZlLCBzZXRBUElLZXksIHNldEVtYmVkSG9zdCwgc2V0TG9nTGV2ZWwgfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aHR0cEhlbHBlcnMuZXNtLmpzLm1hcFxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js\n");

/***/ }),

/***/ "./node_modules/@toruslabs/openlogin-jrpc/dist/openloginJrpc.esm.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@toruslabs/openlogin-jrpc/dist/openloginJrpc.esm.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BasePostMessageStream\": function() { return /* binding */ BasePostMessageStream; },\n/* harmony export */   \"IGNORE_SUBSTREAM\": function() { return /* binding */ IGNORE_SUBSTREAM; },\n/* harmony export */   \"JRPCEngine\": function() { return /* binding */ JRPCEngine; },\n/* harmony export */   \"ObjectMultiplex\": function() { return /* binding */ ObjectMultiplex; },\n/* harmony export */   \"PostMessageStream\": function() { return /* binding */ PostMessageStream; },\n/* harmony export */   \"SafeEventEmitter\": function() { return /* binding */ SafeEventEmitter; },\n/* harmony export */   \"SerializableError\": function() { return /* binding */ SerializableError; },\n/* harmony export */   \"Substream\": function() { return /* binding */ Substream; },\n/* harmony export */   \"createAsyncMiddleware\": function() { return /* binding */ createAsyncMiddleware; },\n/* harmony export */   \"createEngineStream\": function() { return /* binding */ createEngineStream; },\n/* harmony export */   \"createErrorMiddleware\": function() { return /* binding */ createErrorMiddleware; },\n/* harmony export */   \"createIdRemapMiddleware\": function() { return /* binding */ createIdRemapMiddleware; },\n/* harmony export */   \"createLoggerMiddleware\": function() { return /* binding */ createLoggerMiddleware; },\n/* harmony export */   \"createScaffoldMiddleware\": function() { return /* binding */ createScaffoldMiddleware; },\n/* harmony export */   \"createStreamMiddleware\": function() { return /* binding */ createStreamMiddleware; },\n/* harmony export */   \"getRpcPromiseCallback\": function() { return /* binding */ getRpcPromiseCallback; },\n/* harmony export */   \"mergeMiddleware\": function() { return /* binding */ mergeMiddleware; },\n/* harmony export */   \"serializeError\": function() { return /* binding */ serializeError; },\n/* harmony export */   \"setupMultiplex\": function() { return /* binding */ setupMultiplex; }\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/esm/defineProperty.js\");\n/* harmony import */ var readable_stream__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! readable-stream */ \"./node_modules/readable-stream/readable-browser.js\");\n/* harmony import */ var readable_stream__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(readable_stream__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @toruslabs/openlogin-utils */ \"./node_modules/@toruslabs/openlogin-utils/dist/openloginUtils.esm.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var fast_safe_stringify__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! fast-safe-stringify */ \"./node_modules/fast-safe-stringify/index.js\");\n/* harmony import */ var fast_safe_stringify__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(fast_safe_stringify__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var end_of_stream__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! end-of-stream */ \"./node_modules/end-of-stream/index.js\");\n/* harmony import */ var end_of_stream__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(end_of_stream__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var once__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! once */ \"./node_modules/once/once.js\");\n/* harmony import */ var once__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(once__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var pump__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! pump */ \"./node_modules/pump/index.js\");\n/* harmony import */ var pump__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(pump__WEBPACK_IMPORTED_MODULE_7__);\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction noop() {\r\n  return undefined;\r\n}\r\n\r\nconst SYN = \"SYN\";\r\nconst ACK = \"ACK\";\r\nconst BRK = \"BRK\";\r\nclass BasePostMessageStream extends readable_stream__WEBPACK_IMPORTED_MODULE_1__.Duplex {\r\n  constructor(_ref) {\r\n    let {\r\n      name,\r\n      target,\r\n      targetWindow = window,\r\n      targetOrigin = \"*\"\r\n    } = _ref;\r\n    super({\r\n      objectMode: true\r\n    });\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"_init\", void 0);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"_haveSyn\", void 0);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"_name\", void 0);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"_target\", void 0);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"_targetWindow\", void 0);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"_targetOrigin\", void 0);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"_onMessage\", void 0);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"_synIntervalId\", void 0);\r\n\r\n    if (!name || !target) {\r\n      throw new Error(\"Invalid input.\");\r\n    }\r\n\r\n    this._init = false;\r\n    this._haveSyn = false;\r\n    this._name = name;\r\n    this._target = target; // target origin\r\n\r\n    this._targetWindow = targetWindow;\r\n    this._targetOrigin = targetOrigin;\r\n    this._onMessage = this.onMessage.bind(this);\r\n    this._synIntervalId = null;\r\n    window.addEventListener(\"message\", this._onMessage, false);\r\n\r\n    this._handShake();\r\n  }\r\n\r\n  _break() {\r\n    this.cork();\r\n\r\n    this._write(BRK, null, noop);\r\n\r\n    this._haveSyn = false;\r\n    this._init = false;\r\n  }\r\n\r\n  _handShake() {\r\n    this._write(SYN, null, noop);\r\n\r\n    this.cork();\r\n  }\r\n\r\n  _onData(data) {\r\n    if (!this._init) {\r\n      // listen for handshake\r\n      if (data === SYN) {\r\n        this._haveSyn = true;\r\n\r\n        this._write(ACK, null, noop);\r\n      } else if (data === ACK) {\r\n        this._init = true;\r\n\r\n        if (!this._haveSyn) {\r\n          this._write(ACK, null, noop);\r\n        }\r\n\r\n        this.uncork();\r\n      }\r\n    } else if (data === BRK) {\r\n      this._break();\r\n    } else {\r\n      // forward message\r\n      try {\r\n        this.push(data);\r\n      } catch (err) {\r\n        this.emit(\"error\", err);\r\n      }\r\n    }\r\n  }\r\n\r\n  _postMessage(data) {\r\n    const originConstraint = this._targetOrigin;\r\n\r\n    this._targetWindow.postMessage({\r\n      target: this._target,\r\n      data\r\n    }, originConstraint);\r\n  }\r\n\r\n  onMessage(event) {\r\n    const message = event.data; // validate message\r\n\r\n    if (this._targetOrigin !== \"*\" && event.origin !== this._targetOrigin || event.source !== this._targetWindow || typeof message !== \"object\" || message.target !== this._name || !message.data) {\r\n      return;\r\n    }\r\n\r\n    this._onData(message.data);\r\n  }\r\n\r\n  _read() {\r\n    return undefined;\r\n  }\r\n\r\n  _write(data, _, cb) {\r\n    this._postMessage(data);\r\n\r\n    cb();\r\n  }\r\n\r\n  _destroy() {\r\n    window.removeEventListener(\"message\", this._onMessage, false);\r\n  }\r\n\r\n}\r\n\r\nfunction safeApply(handler, context, args) {\r\n  try {\r\n    Reflect.apply(handler, context, args);\r\n  } catch (err) {\r\n    // Throw error after timeout so as not to interrupt the stack\r\n    setTimeout(() => {\r\n      throw err;\r\n    });\r\n  }\r\n}\r\n\r\nfunction arrayClone(arr) {\r\n  const n = arr.length;\r\n  const copy = new Array(n);\r\n\r\n  for (let i = 0; i < n; i += 1) {\r\n    copy[i] = arr[i];\r\n  }\r\n\r\n  return copy;\r\n}\r\n\r\nclass SafeEventEmitter extends events__WEBPACK_IMPORTED_MODULE_3__.EventEmitter {\r\n  emit(type) {\r\n    let doError = type === \"error\";\r\n    const events = this._events;\r\n\r\n    if (events !== undefined) {\r\n      doError = doError && events.error === undefined;\r\n    } else if (!doError) {\r\n      return false;\r\n    } // If there is no 'error' event listener then throw.\r\n\r\n\r\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\r\n      args[_key - 1] = arguments[_key];\r\n    }\r\n\r\n    if (doError) {\r\n      let er;\r\n\r\n      if (args.length > 0) {\r\n        [er] = args;\r\n      }\r\n\r\n      if (er instanceof Error) {\r\n        // Note: The comments on the `throw` lines are intentional, they show\r\n        // up in Node's output if this results in an unhandled exception.\r\n        throw er; // Unhandled 'error' event\r\n      } // At least give some kind of context to the user\r\n\r\n\r\n      const err = new Error(\"Unhandled error.\".concat(er ? \" (\".concat(er.message, \")\") : \"\"));\r\n      err.context = er;\r\n      throw err; // Unhandled 'error' event\r\n    }\r\n\r\n    const handler = events[type];\r\n\r\n    if (handler === undefined) {\r\n      return false;\r\n    }\r\n\r\n    if (typeof handler === \"function\") {\r\n      safeApply(handler, this, args);\r\n    } else {\r\n      const len = handler.length;\r\n      const listeners = arrayClone(handler);\r\n\r\n      for (let i = 0; i < len; i += 1) {\r\n        safeApply(listeners[i], this, args);\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\nclass SerializableError extends Error {\r\n  constructor(_ref) {\r\n    let {\r\n      code,\r\n      message,\r\n      data\r\n    } = _ref;\r\n\r\n    if (!Number.isInteger(code)) {\r\n      throw new Error(\"code must be an integer\");\r\n    }\r\n\r\n    if (!message || typeof message !== \"string\") {\r\n      throw new Error(\"message must be string\");\r\n    }\r\n\r\n    super(message);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"code\", void 0);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"data\", void 0);\r\n\r\n    this.code = code;\r\n\r\n    if (data !== undefined) {\r\n      this.data = data;\r\n    }\r\n  }\r\n\r\n  toString() {\r\n    return fast_safe_stringify__WEBPACK_IMPORTED_MODULE_4___default()({\r\n      code: this.code,\r\n      message: this.message,\r\n      data: this.data,\r\n      stack: this.stack\r\n    });\r\n  }\r\n\r\n}\r\n\r\nfunction serializeError(error) {\r\n  return error.toString();\r\n}\r\nconst getRpcPromiseCallback = function (resolve, reject) {\r\n  let unwrapResult = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\r\n  return (error, response) => {\r\n    if (error || response.error) {\r\n      reject(error || response.error);\r\n    } else if (!unwrapResult || Array.isArray(response)) {\r\n      resolve(response);\r\n    } else {\r\n      resolve(response.result);\r\n    }\r\n  };\r\n};\r\nfunction createErrorMiddleware(log) {\r\n  return (req, res, next, end) => {\r\n    try {\r\n      // json-rpc-engine will terminate the request when it notices this error\r\n      if (typeof req.method !== \"string\" || !req.method) {\r\n        res.error = new SerializableError({\r\n          code: -32603,\r\n          message: \"invalid method\"\r\n        });\r\n        end();\r\n        return;\r\n      }\r\n\r\n      next(done => {\r\n        const {\r\n          error\r\n        } = res;\r\n\r\n        if (!error) {\r\n          return done();\r\n        }\r\n\r\n        log.error(\"OpenLogin - RPC Error: \".concat(error.message), error);\r\n        return done();\r\n      });\r\n    } catch (error) {\r\n      log.error(\"OpenLogin - RPC Error thrown: \".concat(error.message), error);\r\n      res.error = new SerializableError({\r\n        code: -32603,\r\n        message: error.message\r\n      });\r\n      end();\r\n    }\r\n  };\r\n}\r\nfunction createStreamMiddleware() {\r\n  const idMap = {};\r\n\r\n  function readNoop() {\r\n    return false;\r\n  }\r\n\r\n  const events = new SafeEventEmitter();\r\n\r\n  function processResponse(res) {\r\n    const context = idMap[res.id];\r\n\r\n    if (!context) {\r\n      throw new Error(\"StreamMiddleware - Unknown response id \\\"\".concat(res.id, \"\\\"\"));\r\n    }\r\n\r\n    delete idMap[res.id]; // copy whole res onto original res\r\n\r\n    Object.assign(context.res, res); // run callback on empty stack,\r\n    // prevent internal stream-handler from catching errors\r\n\r\n    setTimeout(context.end);\r\n  }\r\n\r\n  function processNotification(res) {\r\n    events.emit(\"notification\", res);\r\n  }\r\n\r\n  function processMessage(res, _encoding, cb) {\r\n    let err;\r\n\r\n    try {\r\n      const isNotification = !res.id;\r\n\r\n      if (isNotification) {\r\n        processNotification(res);\r\n      } else {\r\n        processResponse(res);\r\n      }\r\n    } catch (_err) {\r\n      err = _err;\r\n    } // continue processing stream\r\n\r\n\r\n    cb(err);\r\n  }\r\n\r\n  const stream = new readable_stream__WEBPACK_IMPORTED_MODULE_1__.Duplex({\r\n    objectMode: true,\r\n    read: readNoop,\r\n    write: processMessage\r\n  });\r\n\r\n  const middleware = (req, res, next, end) => {\r\n    // write req to stream\r\n    stream.push(req); // register request on id map\r\n\r\n    idMap[req.id] = {\r\n      req,\r\n      res,\r\n      next,\r\n      end\r\n    };\r\n  };\r\n\r\n  return {\r\n    events,\r\n    middleware,\r\n    stream\r\n  };\r\n}\r\nfunction createScaffoldMiddleware(handlers) {\r\n  return (req, res, next, end) => {\r\n    const handler = handlers[req.method]; // if no handler, return\r\n\r\n    if (handler === undefined) {\r\n      return next();\r\n    } // if handler is fn, call as middleware\r\n\r\n\r\n    if (typeof handler === \"function\") {\r\n      return handler(req, res, next, end);\r\n    } // if handler is some other value, use as result\r\n\r\n\r\n    res.result = handler;\r\n    return end();\r\n  };\r\n}\r\nfunction createIdRemapMiddleware() {\r\n  return (req, res, next, _end) => {\r\n    const originalId = req.id;\r\n    const newId = (0,_toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_2__.randomId)();\r\n    req.id = newId;\r\n    res.id = newId;\r\n    next(done => {\r\n      req.id = originalId;\r\n      res.id = originalId;\r\n      done();\r\n    });\r\n  };\r\n}\r\nfunction createLoggerMiddleware(logger) {\r\n  return (req, res, next, _) => {\r\n    logger.debug(\"REQ\", req, \"RES\", res);\r\n    next();\r\n  };\r\n}\r\nfunction createAsyncMiddleware(asyncMiddleware) {\r\n  return async (req, res, next, end) => {\r\n    // nextPromise is the key to the implementation\r\n    // it is resolved by the return handler passed to the\r\n    // \"next\" function\r\n    let resolveNextPromise;\r\n    const nextPromise = new Promise(resolve => {\r\n      resolveNextPromise = resolve;\r\n    });\r\n    let returnHandlerCallback = null;\r\n    let nextWasCalled = false; // This will be called by the consumer's async middleware.\r\n\r\n    const asyncNext = async () => {\r\n      nextWasCalled = true; // We pass a return handler to next(). When it is called by the engine,\r\n      // the consumer's async middleware will resume executing.\r\n\r\n      next(runReturnHandlersCallback => {\r\n        // This callback comes from JRPCEngine._runReturnHandlers\r\n        returnHandlerCallback = runReturnHandlersCallback;\r\n        resolveNextPromise();\r\n      });\r\n      await nextPromise;\r\n    };\r\n\r\n    try {\r\n      await asyncMiddleware(req, res, asyncNext);\r\n\r\n      if (nextWasCalled) {\r\n        await nextPromise; // we must wait until the return handler is called\r\n\r\n        returnHandlerCallback(null);\r\n      } else {\r\n        end(null);\r\n      }\r\n    } catch (error) {\r\n      if (returnHandlerCallback) {\r\n        returnHandlerCallback(error);\r\n      } else {\r\n        end(error);\r\n      }\r\n    }\r\n  };\r\n}\r\n\r\nfunction ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\r\n\r\nfunction _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\r\n/**\r\n * A JSON-RPC request and response processor.\r\n * Give it a stack of middleware, pass it requests, and get back responses.\r\n */\r\n\r\nclass JRPCEngine extends SafeEventEmitter {\r\n  constructor() {\r\n    super();\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"_middleware\", void 0);\r\n\r\n    this._middleware = [];\r\n  }\r\n  /**\r\n   * Serially executes the given stack of middleware.\r\n   *\r\n   * @returns An array of any error encountered during middleware execution,\r\n   * a boolean indicating whether the request was completed, and an array of\r\n   * middleware-defined return handlers.\r\n   */\r\n\r\n\r\n  static async _runAllMiddleware(req, res, middlewareStack) {\r\n    const returnHandlers = [];\r\n    let error = null;\r\n    let isComplete = false; // Go down stack of middleware, call and collect optional returnHandlers\r\n\r\n    for (const middleware of middlewareStack) {\r\n      [error, isComplete] = await JRPCEngine._runMiddleware(req, res, middleware, returnHandlers);\r\n\r\n      if (isComplete) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    return [error, isComplete, returnHandlers.reverse()];\r\n  }\r\n  /**\r\n   * Runs an individual middleware.\r\n   *\r\n   * @returns An array of any error encountered during middleware exection,\r\n   * and a boolean indicating whether the request should end.\r\n   */\r\n\r\n\r\n  static _runMiddleware(req, res, middleware, returnHandlers) {\r\n    return new Promise(resolve => {\r\n      const end = err => {\r\n        const error = err || res.error;\r\n\r\n        if (error) {\r\n          res.error = serializeError(error);\r\n        } // True indicates that the request should end\r\n\r\n\r\n        resolve([error, true]);\r\n      };\r\n\r\n      const next = returnHandler => {\r\n        if (res.error) {\r\n          end(res.error);\r\n        } else {\r\n          if (returnHandler) {\r\n            if (typeof returnHandler !== \"function\") {\r\n              end(new SerializableError({\r\n                code: -32603,\r\n                message: \"JRPCEngine: 'next' return handlers must be functions\"\r\n              }));\r\n            }\r\n\r\n            returnHandlers.push(returnHandler);\r\n          } // False indicates that the request should not end\r\n\r\n\r\n          resolve([null, false]);\r\n        }\r\n      };\r\n\r\n      try {\r\n        middleware(req, res, next, end);\r\n      } catch (error) {\r\n        end(error);\r\n      }\r\n    });\r\n  }\r\n  /**\r\n   * Serially executes array of return handlers. The request and response are\r\n   * assumed to be in their scope.\r\n   */\r\n\r\n\r\n  static async _runReturnHandlers(handlers) {\r\n    for (const handler of handlers) {\r\n      await new Promise((resolve, reject) => {\r\n        handler(err => err ? reject(err) : resolve());\r\n      });\r\n    }\r\n  }\r\n  /**\r\n   * Throws an error if the response has neither a result nor an error, or if\r\n   * the \"isComplete\" flag is falsy.\r\n   */\r\n\r\n\r\n  static _checkForCompletion(req, res, isComplete) {\r\n    if (!(\"result\" in res) && !(\"error\" in res)) {\r\n      throw new SerializableError({\r\n        code: -32603,\r\n        message: \"Response has no error or result for request\"\r\n      });\r\n    }\r\n\r\n    if (!isComplete) {\r\n      throw new SerializableError({\r\n        code: -32603,\r\n        message: \"Nothing ended request\"\r\n      });\r\n    }\r\n  }\r\n  /**\r\n   * Add a middleware function to the engine's middleware stack.\r\n   *\r\n   * @param middleware - The middleware function to add.\r\n   */\r\n\r\n\r\n  push(middleware) {\r\n    this._middleware.push(middleware);\r\n  }\r\n\r\n  handle(req, cb) {\r\n    if (cb && typeof cb !== \"function\") {\r\n      throw new Error('\"callback\" must be a function if provided.');\r\n    }\r\n\r\n    if (Array.isArray(req)) {\r\n      if (cb) {\r\n        return this._handleBatch(req, cb);\r\n      }\r\n\r\n      return this._handleBatch(req);\r\n    }\r\n\r\n    if (cb) {\r\n      return this._handle(req, cb);\r\n    }\r\n\r\n    return this._promiseHandle(req);\r\n  }\r\n  /**\r\n   * Returns this engine as a middleware function that can be pushed to other\r\n   * engines.\r\n   *\r\n   * @returns This engine as a middleware function.\r\n   */\r\n\r\n\r\n  asMiddleware() {\r\n    return async (req, res, next, end) => {\r\n      try {\r\n        const [middlewareError, isComplete, returnHandlers] = await JRPCEngine._runAllMiddleware(req, res, this._middleware);\r\n\r\n        if (isComplete) {\r\n          await JRPCEngine._runReturnHandlers(returnHandlers);\r\n          return end(middlewareError);\r\n        }\r\n\r\n        return next(async handlerCallback => {\r\n          try {\r\n            await JRPCEngine._runReturnHandlers(returnHandlers);\r\n          } catch (error) {\r\n            return handlerCallback(error);\r\n          }\r\n\r\n          return handlerCallback();\r\n        });\r\n      } catch (error) {\r\n        return end(error);\r\n      }\r\n    };\r\n  }\r\n\r\n  async _handleBatch(reqs, cb) {\r\n    // The order here is important\r\n    try {\r\n      // 2. Wait for all requests to finish, or throw on some kind of fatal\r\n      // error\r\n      const responses = await Promise.all( // 1. Begin executing each request in the order received\r\n      reqs.map(this._promiseHandle.bind(this))); // 3. Return batch response\r\n\r\n      if (cb) {\r\n        return cb(null, responses);\r\n      }\r\n\r\n      return responses;\r\n    } catch (error) {\r\n      if (cb) {\r\n        return cb(error);\r\n      }\r\n\r\n      throw error;\r\n    }\r\n  }\r\n  /**\r\n   * A promise-wrapped _handle.\r\n   */\r\n\r\n\r\n  _promiseHandle(req) {\r\n    return new Promise(resolve => {\r\n      this._handle(req, (_err, res) => {\r\n        // There will always be a response, and it will always have any error\r\n        // that is caught and propagated.\r\n        resolve(res);\r\n      });\r\n    });\r\n  }\r\n  /**\r\n   * Ensures that the request object is valid, processes it, and passes any\r\n   * error and the response object to the given callback.\r\n   *\r\n   * Does not reject.\r\n   */\r\n\r\n\r\n  async _handle(callerReq, cb) {\r\n    if (!callerReq || Array.isArray(callerReq) || typeof callerReq !== \"object\") {\r\n      const error = new SerializableError({\r\n        code: -32603,\r\n        message: \"request must be plain object\"\r\n      });\r\n      return cb(error, {\r\n        id: undefined,\r\n        jsonrpc: \"2.0\",\r\n        error\r\n      });\r\n    }\r\n\r\n    if (typeof callerReq.method !== \"string\") {\r\n      const error = new SerializableError({\r\n        code: -32603,\r\n        message: \"method must be string\"\r\n      });\r\n      return cb(error, {\r\n        id: callerReq.id,\r\n        jsonrpc: \"2.0\",\r\n        error\r\n      });\r\n    }\r\n\r\n    const req = _objectSpread$1({}, callerReq);\r\n\r\n    const res = {\r\n      id: req.id,\r\n      jsonrpc: req.jsonrpc\r\n    };\r\n    let error = null;\r\n\r\n    try {\r\n      await this._processRequest(req, res);\r\n    } catch (_error) {\r\n      // A request handler error, a re-thrown middleware error, or something\r\n      // unexpected.\r\n      error = _error;\r\n    }\r\n\r\n    if (error) {\r\n      // Ensure no result is present on an errored response\r\n      delete res.result;\r\n\r\n      if (!res.error) {\r\n        res.error = serializeError(error);\r\n      }\r\n    }\r\n\r\n    return cb(error, res);\r\n  }\r\n  /**\r\n   * For the given request and response, runs all middleware and their return\r\n   * handlers, if any, and ensures that internal request processing semantics\r\n   * are satisfied.\r\n   */\r\n\r\n\r\n  async _processRequest(req, res) {\r\n    const [error, isComplete, returnHandlers] = await JRPCEngine._runAllMiddleware(req, res, this._middleware); // Throw if \"end\" was not called, or if the response has neither a result\r\n    // nor an error.\r\n\r\n    JRPCEngine._checkForCompletion(req, res, isComplete); // The return handlers should run even if an error was encountered during\r\n    // middleware processing.\r\n\r\n\r\n    await JRPCEngine._runReturnHandlers(returnHandlers); // Now we re-throw the middleware processing error, if any, to catch it\r\n    // further up the call chain.\r\n\r\n    if (error) {\r\n      throw error;\r\n    }\r\n  }\r\n\r\n}\r\nfunction mergeMiddleware(middlewareStack) {\r\n  const engine = new JRPCEngine();\r\n  middlewareStack.forEach(middleware => engine.push(middleware));\r\n  return engine.asMiddleware();\r\n}\r\nfunction createEngineStream(opts) {\r\n  if (!opts || !opts.engine) {\r\n    throw new Error(\"Missing engine parameter!\");\r\n  }\r\n\r\n  const {\r\n    engine\r\n  } = opts; // eslint-disable-next-line prefer-const\r\n\r\n  let stream;\r\n\r\n  function read() {\r\n    return undefined;\r\n  }\r\n\r\n  function write(req, _encoding, cb) {\r\n    engine.handle(req, (_err, res) => {\r\n      stream.push(res);\r\n    });\r\n    cb();\r\n  }\r\n\r\n  stream = new readable_stream__WEBPACK_IMPORTED_MODULE_1__.Duplex({\r\n    objectMode: true,\r\n    read,\r\n    write\r\n  }); // forward notifications\r\n\r\n  if (engine.on) {\r\n    engine.on(\"notification\", message => {\r\n      stream.push(message);\r\n    });\r\n  }\r\n\r\n  return stream;\r\n}\r\n\r\nclass Substream extends readable_stream__WEBPACK_IMPORTED_MODULE_1__.Duplex {\r\n  constructor(_ref) {\r\n    let {\r\n      parent,\r\n      name\r\n    } = _ref;\r\n    super({\r\n      objectMode: true\r\n    });\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"_parent\", void 0);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"_name\", void 0);\r\n\r\n    this._parent = parent;\r\n    this._name = name;\r\n  }\r\n  /**\r\n   * Explicitly sets read operations to a no-op.\r\n   */\r\n\r\n\r\n  _read() {\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Called when data should be written to this writable stream.\r\n   *\r\n   * @param chunk - Arbitrary object to write\r\n   * @param encoding - Encoding to use when writing payload\r\n   * @param callback - Called when writing is complete or an error occurs\r\n   */\r\n\r\n\r\n  _write(chunk, _encoding, callback) {\r\n    this._parent.push({\r\n      name: this._name,\r\n      data: chunk\r\n    });\r\n\r\n    callback();\r\n  }\r\n\r\n}\r\n\r\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\r\n\r\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\r\nconst IGNORE_SUBSTREAM = Symbol(\"IGNORE_SUBSTREAM\");\r\nclass ObjectMultiplex extends readable_stream__WEBPACK_IMPORTED_MODULE_1__.Duplex {\r\n  constructor() {\r\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\r\n    super(_objectSpread(_objectSpread({}, opts), {}, {\r\n      objectMode: true\r\n    }));\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"_substreams\", void 0);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"getStream\", void 0);\r\n\r\n    this._substreams = {};\r\n  }\r\n\r\n  createStream(name) {\r\n    // validate name\r\n    if (!name) {\r\n      throw new Error(\"ObjectMultiplex - name must not be empty\");\r\n    }\r\n\r\n    if (this._substreams[name]) {\r\n      throw new Error(\"ObjectMultiplex - Substream for name \\\"\".concat(name, \"\\\" already exists\"));\r\n    } // create substream\r\n\r\n\r\n    const substream = new Substream({\r\n      parent: this,\r\n      name\r\n    });\r\n    this._substreams[name] = substream; // listen for parent stream to end\r\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\r\n\r\n    anyStreamEnd(this, _error => substream.destroy(_error || undefined));\r\n    return substream;\r\n  } // ignore streams (dont display orphaned data warning)\r\n\r\n\r\n  ignoreStream(name) {\r\n    // validate name\r\n    if (!name) {\r\n      throw new Error(\"ObjectMultiplex - name must not be empty\");\r\n    }\r\n\r\n    if (this._substreams[name]) {\r\n      throw new Error(\"ObjectMultiplex - Substream for name \\\"\".concat(name, \"\\\" already exists\"));\r\n    } // set\r\n\r\n\r\n    this._substreams[name] = IGNORE_SUBSTREAM;\r\n  }\r\n\r\n  _read() {\r\n    return undefined;\r\n  }\r\n\r\n  _write(chunk, _encoding, callback) {\r\n    const {\r\n      name,\r\n      data\r\n    } = chunk;\r\n\r\n    if (!name) {\r\n      window.console.warn(\"ObjectMultiplex - malformed chunk without name \\\"\".concat(chunk, \"\\\"\"));\r\n      return callback();\r\n    } // get corresponding substream\r\n\r\n\r\n    const substream = this._substreams[name];\r\n\r\n    if (!substream) {\r\n      window.console.warn(\"ObjectMultiplex - orphaned data for stream \\\"\".concat(name, \"\\\"\"));\r\n      return callback();\r\n    } // push data into substream\r\n\r\n\r\n    if (substream !== IGNORE_SUBSTREAM) {\r\n      substream.push(data);\r\n    }\r\n\r\n    return callback();\r\n  }\r\n\r\n} // util\r\n\r\nfunction anyStreamEnd(stream, _cb) {\r\n  const cb = once__WEBPACK_IMPORTED_MODULE_6___default()(_cb);\r\n  end_of_stream__WEBPACK_IMPORTED_MODULE_5___default()(stream, {\r\n    readable: false\r\n  }, cb);\r\n  end_of_stream__WEBPACK_IMPORTED_MODULE_5___default()(stream, {\r\n    writable: false\r\n  }, cb);\r\n}\r\n\r\nfunction setupMultiplex(stream) {\r\n  const mux = new ObjectMultiplex();\r\n\r\n  mux.getStream = function streamHelper(name) {\r\n    if (this._substreams[name]) {\r\n      return this._substreams[name];\r\n    }\r\n\r\n    return this.createStream(name);\r\n  };\r\n\r\n  pump__WEBPACK_IMPORTED_MODULE_7___default()(stream, mux, stream, err => {\r\n    if (err) window.console.error(err);\r\n  });\r\n  return mux;\r\n}\r\n\r\nclass PostMessageStream extends BasePostMessageStream {\r\n  _postMessage(data) {\r\n    let originConstraint = this._targetOrigin;\r\n\r\n    if (typeof data === \"object\") {\r\n      const dataObj = data;\r\n\r\n      if (typeof dataObj.data === \"object\") {\r\n        const dataObjData = dataObj.data;\r\n\r\n        if (Array.isArray(dataObjData.params) && dataObjData.params.length > 0) {\r\n          const dataObjDataParam = dataObjData.params[0];\r\n\r\n          if (dataObjDataParam._origin) {\r\n            originConstraint = dataObjDataParam._origin;\r\n          } // add a constraint for the response\r\n\r\n\r\n          dataObjDataParam._origin = window.location.origin;\r\n        }\r\n      }\r\n    }\r\n\r\n    this._targetWindow.postMessage({\r\n      target: this._target,\r\n      data\r\n    }, originConstraint);\r\n  }\r\n\r\n}\r\n\r\n\r\n//# sourceMappingURL=openloginJrpc.esm.js.map\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9vcGVubG9naW4tanJwYy9kaXN0L29wZW5sb2dpbkpycGMuZXNtLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvRTtBQUMzQjtBQUNhO0FBQ2hCO0FBQ007QUFDWjtBQUNSO0FBQ0E7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxtREFBTTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUksaUZBQWU7QUFDbkI7QUFDQSxJQUFJLGlGQUFlO0FBQ25CO0FBQ0EsSUFBSSxpRkFBZTtBQUNuQjtBQUNBLElBQUksaUZBQWU7QUFDbkI7QUFDQSxJQUFJLGlGQUFlO0FBQ25CO0FBQ0EsSUFBSSxpRkFBZTtBQUNuQjtBQUNBLElBQUksaUZBQWU7QUFDbkI7QUFDQSxJQUFJLGlGQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGdEQUFZO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsMkZBQTJGLGFBQWE7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxpRkFBZTtBQUNuQjtBQUNBLElBQUksaUZBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywwREFBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1EQUFNO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9FQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsZ0NBQWdDLG9DQUFvQyxvREFBb0QsNkRBQTZELGlFQUFpRSxzQ0FBc0M7QUFDelU7QUFDQSxtQ0FBbUMsZ0JBQWdCLHNCQUFzQixPQUFPLHVEQUF1RCwrREFBK0QsaUZBQWUsNkJBQTZCLHNLQUFzSyxtRkFBbUYsS0FBSztBQUNoZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlGQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDaFkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvb3BlbmxvZ2luLWpycGMvZGlzdC9vcGVubG9naW5KcnBjLmVzbS5qcz84YWE5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eSc7XHJcbmltcG9ydCB7IER1cGxleCB9IGZyb20gJ3JlYWRhYmxlLXN0cmVhbSc7XHJcbmltcG9ydCB7IHJhbmRvbUlkIH0gZnJvbSAnQHRvcnVzbGFicy9vcGVubG9naW4tdXRpbHMnO1xyXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xyXG5pbXBvcnQgc3RyaW5naWZ5IGZyb20gJ2Zhc3Qtc2FmZS1zdHJpbmdpZnknO1xyXG5pbXBvcnQgZW9zIGZyb20gJ2VuZC1vZi1zdHJlYW0nO1xyXG5pbXBvcnQgb25jZSBmcm9tICdvbmNlJztcclxuaW1wb3J0IHB1bXAgZnJvbSAncHVtcCc7XHJcblxyXG5mdW5jdGlvbiBub29wKCkge1xyXG4gIHJldHVybiB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbmNvbnN0IFNZTiA9IFwiU1lOXCI7XHJcbmNvbnN0IEFDSyA9IFwiQUNLXCI7XHJcbmNvbnN0IEJSSyA9IFwiQlJLXCI7XHJcbmNsYXNzIEJhc2VQb3N0TWVzc2FnZVN0cmVhbSBleHRlbmRzIER1cGxleCB7XHJcbiAgY29uc3RydWN0b3IoX3JlZikge1xyXG4gICAgbGV0IHtcclxuICAgICAgbmFtZSxcclxuICAgICAgdGFyZ2V0LFxyXG4gICAgICB0YXJnZXRXaW5kb3cgPSB3aW5kb3csXHJcbiAgICAgIHRhcmdldE9yaWdpbiA9IFwiKlwiXHJcbiAgICB9ID0gX3JlZjtcclxuICAgIHN1cGVyKHtcclxuICAgICAgb2JqZWN0TW9kZTogdHJ1ZVxyXG4gICAgfSk7XHJcblxyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2luaXRcIiwgdm9pZCAwKTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfaGF2ZVN5blwiLCB2b2lkIDApO1xyXG5cclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9uYW1lXCIsIHZvaWQgMCk7XHJcblxyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3RhcmdldFwiLCB2b2lkIDApO1xyXG5cclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl90YXJnZXRXaW5kb3dcIiwgdm9pZCAwKTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfdGFyZ2V0T3JpZ2luXCIsIHZvaWQgMCk7XHJcblxyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX29uTWVzc2FnZVwiLCB2b2lkIDApO1xyXG5cclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zeW5JbnRlcnZhbElkXCIsIHZvaWQgMCk7XHJcblxyXG4gICAgaWYgKCFuYW1lIHx8ICF0YXJnZXQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dC5cIik7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5faW5pdCA9IGZhbHNlO1xyXG4gICAgdGhpcy5faGF2ZVN5biA9IGZhbHNlO1xyXG4gICAgdGhpcy5fbmFtZSA9IG5hbWU7XHJcbiAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7IC8vIHRhcmdldCBvcmlnaW5cclxuXHJcbiAgICB0aGlzLl90YXJnZXRXaW5kb3cgPSB0YXJnZXRXaW5kb3c7XHJcbiAgICB0aGlzLl90YXJnZXRPcmlnaW4gPSB0YXJnZXRPcmlnaW47XHJcbiAgICB0aGlzLl9vbk1lc3NhZ2UgPSB0aGlzLm9uTWVzc2FnZS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5fc3luSW50ZXJ2YWxJZCA9IG51bGw7XHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgdGhpcy5fb25NZXNzYWdlLCBmYWxzZSk7XHJcblxyXG4gICAgdGhpcy5faGFuZFNoYWtlKCk7XHJcbiAgfVxyXG5cclxuICBfYnJlYWsoKSB7XHJcbiAgICB0aGlzLmNvcmsoKTtcclxuXHJcbiAgICB0aGlzLl93cml0ZShCUkssIG51bGwsIG5vb3ApO1xyXG5cclxuICAgIHRoaXMuX2hhdmVTeW4gPSBmYWxzZTtcclxuICAgIHRoaXMuX2luaXQgPSBmYWxzZTtcclxuICB9XHJcblxyXG4gIF9oYW5kU2hha2UoKSB7XHJcbiAgICB0aGlzLl93cml0ZShTWU4sIG51bGwsIG5vb3ApO1xyXG5cclxuICAgIHRoaXMuY29yaygpO1xyXG4gIH1cclxuXHJcbiAgX29uRGF0YShkYXRhKSB7XHJcbiAgICBpZiAoIXRoaXMuX2luaXQpIHtcclxuICAgICAgLy8gbGlzdGVuIGZvciBoYW5kc2hha2VcclxuICAgICAgaWYgKGRhdGEgPT09IFNZTikge1xyXG4gICAgICAgIHRoaXMuX2hhdmVTeW4gPSB0cnVlO1xyXG5cclxuICAgICAgICB0aGlzLl93cml0ZShBQ0ssIG51bGwsIG5vb3ApO1xyXG4gICAgICB9IGVsc2UgaWYgKGRhdGEgPT09IEFDSykge1xyXG4gICAgICAgIHRoaXMuX2luaXQgPSB0cnVlO1xyXG5cclxuICAgICAgICBpZiAoIXRoaXMuX2hhdmVTeW4pIHtcclxuICAgICAgICAgIHRoaXMuX3dyaXRlKEFDSywgbnVsbCwgbm9vcCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnVuY29yaygpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGRhdGEgPT09IEJSSykge1xyXG4gICAgICB0aGlzLl9icmVhaygpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gZm9yd2FyZCBtZXNzYWdlXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgdGhpcy5wdXNoKGRhdGEpO1xyXG4gICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBlcnIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfcG9zdE1lc3NhZ2UoZGF0YSkge1xyXG4gICAgY29uc3Qgb3JpZ2luQ29uc3RyYWludCA9IHRoaXMuX3RhcmdldE9yaWdpbjtcclxuXHJcbiAgICB0aGlzLl90YXJnZXRXaW5kb3cucG9zdE1lc3NhZ2Uoe1xyXG4gICAgICB0YXJnZXQ6IHRoaXMuX3RhcmdldCxcclxuICAgICAgZGF0YVxyXG4gICAgfSwgb3JpZ2luQ29uc3RyYWludCk7XHJcbiAgfVxyXG5cclxuICBvbk1lc3NhZ2UoZXZlbnQpIHtcclxuICAgIGNvbnN0IG1lc3NhZ2UgPSBldmVudC5kYXRhOyAvLyB2YWxpZGF0ZSBtZXNzYWdlXHJcblxyXG4gICAgaWYgKHRoaXMuX3RhcmdldE9yaWdpbiAhPT0gXCIqXCIgJiYgZXZlbnQub3JpZ2luICE9PSB0aGlzLl90YXJnZXRPcmlnaW4gfHwgZXZlbnQuc291cmNlICE9PSB0aGlzLl90YXJnZXRXaW5kb3cgfHwgdHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZS50YXJnZXQgIT09IHRoaXMuX25hbWUgfHwgIW1lc3NhZ2UuZGF0YSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fb25EYXRhKG1lc3NhZ2UuZGF0YSk7XHJcbiAgfVxyXG5cclxuICBfcmVhZCgpIHtcclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICBfd3JpdGUoZGF0YSwgXywgY2IpIHtcclxuICAgIHRoaXMuX3Bvc3RNZXNzYWdlKGRhdGEpO1xyXG5cclxuICAgIGNiKCk7XHJcbiAgfVxyXG5cclxuICBfZGVzdHJveSgpIHtcclxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB0aGlzLl9vbk1lc3NhZ2UsIGZhbHNlKTtcclxuICB9XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBzYWZlQXBwbHkoaGFuZGxlciwgY29udGV4dCwgYXJncykge1xyXG4gIHRyeSB7XHJcbiAgICBSZWZsZWN0LmFwcGx5KGhhbmRsZXIsIGNvbnRleHQsIGFyZ3MpO1xyXG4gIH0gY2F0Y2ggKGVycikge1xyXG4gICAgLy8gVGhyb3cgZXJyb3IgYWZ0ZXIgdGltZW91dCBzbyBhcyBub3QgdG8gaW50ZXJydXB0IHRoZSBzdGFja1xyXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgIHRocm93IGVycjtcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIpIHtcclxuICBjb25zdCBuID0gYXJyLmxlbmd0aDtcclxuICBjb25zdCBjb3B5ID0gbmV3IEFycmF5KG4pO1xyXG5cclxuICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkgKz0gMSkge1xyXG4gICAgY29weVtpXSA9IGFycltpXTtcclxuICB9XHJcblxyXG4gIHJldHVybiBjb3B5O1xyXG59XHJcblxyXG5jbGFzcyBTYWZlRXZlbnRFbWl0dGVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcclxuICBlbWl0KHR5cGUpIHtcclxuICAgIGxldCBkb0Vycm9yID0gdHlwZSA9PT0gXCJlcnJvclwiO1xyXG4gICAgY29uc3QgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xyXG5cclxuICAgIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBkb0Vycm9yID0gZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT09IHVuZGVmaW5lZDtcclxuICAgIH0gZWxzZSBpZiAoIWRvRXJyb3IpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXHJcblxyXG5cclxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcclxuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGRvRXJyb3IpIHtcclxuICAgICAgbGV0IGVyO1xyXG5cclxuICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIFtlcl0gPSBhcmdzO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xyXG4gICAgICAgIC8vIHVwIGluIE5vZGUncyBvdXRwdXQgaWYgdGhpcyByZXN1bHRzIGluIGFuIHVuaGFuZGxlZCBleGNlcHRpb24uXHJcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XHJcbiAgICAgIH0gLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxyXG5cclxuXHJcbiAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcIlVuaGFuZGxlZCBlcnJvci5cIi5jb25jYXQoZXIgPyBcIiAoXCIuY29uY2F0KGVyLm1lc3NhZ2UsIFwiKVwiKSA6IFwiXCIpKTtcclxuICAgICAgZXJyLmNvbnRleHQgPSBlcjtcclxuICAgICAgdGhyb3cgZXJyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGhhbmRsZXIgPSBldmVudHNbdHlwZV07XHJcblxyXG4gICAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgc2FmZUFwcGx5KGhhbmRsZXIsIHRoaXMsIGFyZ3MpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc3QgbGVuID0gaGFuZGxlci5sZW5ndGg7XHJcbiAgICAgIGNvbnN0IGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlcik7XHJcblxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgICAgc2FmZUFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG59XHJcblxyXG5jbGFzcyBTZXJpYWxpemFibGVFcnJvciBleHRlbmRzIEVycm9yIHtcclxuICBjb25zdHJ1Y3RvcihfcmVmKSB7XHJcbiAgICBsZXQge1xyXG4gICAgICBjb2RlLFxyXG4gICAgICBtZXNzYWdlLFxyXG4gICAgICBkYXRhXHJcbiAgICB9ID0gX3JlZjtcclxuXHJcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoY29kZSkpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29kZSBtdXN0IGJlIGFuIGludGVnZXJcIik7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFtZXNzYWdlIHx8IHR5cGVvZiBtZXNzYWdlICE9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm1lc3NhZ2UgbXVzdCBiZSBzdHJpbmdcIik7XHJcbiAgICB9XHJcblxyXG4gICAgc3VwZXIobWVzc2FnZSk7XHJcblxyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29kZVwiLCB2b2lkIDApO1xyXG5cclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRhdGFcIiwgdm9pZCAwKTtcclxuXHJcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xyXG5cclxuICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHRvU3RyaW5nKCkge1xyXG4gICAgcmV0dXJuIHN0cmluZ2lmeSh7XHJcbiAgICAgIGNvZGU6IHRoaXMuY29kZSxcclxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxyXG4gICAgICBkYXRhOiB0aGlzLmRhdGEsXHJcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBzZXJpYWxpemVFcnJvcihlcnJvcikge1xyXG4gIHJldHVybiBlcnJvci50b1N0cmluZygpO1xyXG59XHJcbmNvbnN0IGdldFJwY1Byb21pc2VDYWxsYmFjayA9IGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICBsZXQgdW53cmFwUmVzdWx0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xyXG4gIHJldHVybiAoZXJyb3IsIHJlc3BvbnNlKSA9PiB7XHJcbiAgICBpZiAoZXJyb3IgfHwgcmVzcG9uc2UuZXJyb3IpIHtcclxuICAgICAgcmVqZWN0KGVycm9yIHx8IHJlc3BvbnNlLmVycm9yKTtcclxuICAgIH0gZWxzZSBpZiAoIXVud3JhcFJlc3VsdCB8fCBBcnJheS5pc0FycmF5KHJlc3BvbnNlKSkge1xyXG4gICAgICByZXNvbHZlKHJlc3BvbnNlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJlc29sdmUocmVzcG9uc2UucmVzdWx0KTtcclxuICAgIH1cclxuICB9O1xyXG59O1xyXG5mdW5jdGlvbiBjcmVhdGVFcnJvck1pZGRsZXdhcmUobG9nKSB7XHJcbiAgcmV0dXJuIChyZXEsIHJlcywgbmV4dCwgZW5kKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBqc29uLXJwYy1lbmdpbmUgd2lsbCB0ZXJtaW5hdGUgdGhlIHJlcXVlc3Qgd2hlbiBpdCBub3RpY2VzIHRoaXMgZXJyb3JcclxuICAgICAgaWYgKHR5cGVvZiByZXEubWV0aG9kICE9PSBcInN0cmluZ1wiIHx8ICFyZXEubWV0aG9kKSB7XHJcbiAgICAgICAgcmVzLmVycm9yID0gbmV3IFNlcmlhbGl6YWJsZUVycm9yKHtcclxuICAgICAgICAgIGNvZGU6IC0zMjYwMyxcclxuICAgICAgICAgIG1lc3NhZ2U6IFwiaW52YWxpZCBtZXRob2RcIlxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGVuZCgpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgbmV4dChkb25lID0+IHtcclxuICAgICAgICBjb25zdCB7XHJcbiAgICAgICAgICBlcnJvclxyXG4gICAgICAgIH0gPSByZXM7XHJcblxyXG4gICAgICAgIGlmICghZXJyb3IpIHtcclxuICAgICAgICAgIHJldHVybiBkb25lKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsb2cuZXJyb3IoXCJPcGVuTG9naW4gLSBSUEMgRXJyb3I6IFwiLmNvbmNhdChlcnJvci5tZXNzYWdlKSwgZXJyb3IpO1xyXG4gICAgICAgIHJldHVybiBkb25lKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgbG9nLmVycm9yKFwiT3BlbkxvZ2luIC0gUlBDIEVycm9yIHRocm93bjogXCIuY29uY2F0KGVycm9yLm1lc3NhZ2UpLCBlcnJvcik7XHJcbiAgICAgIHJlcy5lcnJvciA9IG5ldyBTZXJpYWxpemFibGVFcnJvcih7XHJcbiAgICAgICAgY29kZTogLTMyNjAzLFxyXG4gICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2VcclxuICAgICAgfSk7XHJcbiAgICAgIGVuZCgpO1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlU3RyZWFtTWlkZGxld2FyZSgpIHtcclxuICBjb25zdCBpZE1hcCA9IHt9O1xyXG5cclxuICBmdW5jdGlvbiByZWFkTm9vcCgpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIGNvbnN0IGV2ZW50cyA9IG5ldyBTYWZlRXZlbnRFbWl0dGVyKCk7XHJcblxyXG4gIGZ1bmN0aW9uIHByb2Nlc3NSZXNwb25zZShyZXMpIHtcclxuICAgIGNvbnN0IGNvbnRleHQgPSBpZE1hcFtyZXMuaWRdO1xyXG5cclxuICAgIGlmICghY29udGV4dCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdHJlYW1NaWRkbGV3YXJlIC0gVW5rbm93biByZXNwb25zZSBpZCBcXFwiXCIuY29uY2F0KHJlcy5pZCwgXCJcXFwiXCIpKTtcclxuICAgIH1cclxuXHJcbiAgICBkZWxldGUgaWRNYXBbcmVzLmlkXTsgLy8gY29weSB3aG9sZSByZXMgb250byBvcmlnaW5hbCByZXNcclxuXHJcbiAgICBPYmplY3QuYXNzaWduKGNvbnRleHQucmVzLCByZXMpOyAvLyBydW4gY2FsbGJhY2sgb24gZW1wdHkgc3RhY2ssXHJcbiAgICAvLyBwcmV2ZW50IGludGVybmFsIHN0cmVhbS1oYW5kbGVyIGZyb20gY2F0Y2hpbmcgZXJyb3JzXHJcblxyXG4gICAgc2V0VGltZW91dChjb250ZXh0LmVuZCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBwcm9jZXNzTm90aWZpY2F0aW9uKHJlcykge1xyXG4gICAgZXZlbnRzLmVtaXQoXCJub3RpZmljYXRpb25cIiwgcmVzKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHByb2Nlc3NNZXNzYWdlKHJlcywgX2VuY29kaW5nLCBjYikge1xyXG4gICAgbGV0IGVycjtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBpc05vdGlmaWNhdGlvbiA9ICFyZXMuaWQ7XHJcblxyXG4gICAgICBpZiAoaXNOb3RpZmljYXRpb24pIHtcclxuICAgICAgICBwcm9jZXNzTm90aWZpY2F0aW9uKHJlcyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcHJvY2Vzc1Jlc3BvbnNlKHJlcyk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKF9lcnIpIHtcclxuICAgICAgZXJyID0gX2VycjtcclxuICAgIH0gLy8gY29udGludWUgcHJvY2Vzc2luZyBzdHJlYW1cclxuXHJcblxyXG4gICAgY2IoZXJyKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHN0cmVhbSA9IG5ldyBEdXBsZXgoe1xyXG4gICAgb2JqZWN0TW9kZTogdHJ1ZSxcclxuICAgIHJlYWQ6IHJlYWROb29wLFxyXG4gICAgd3JpdGU6IHByb2Nlc3NNZXNzYWdlXHJcbiAgfSk7XHJcblxyXG4gIGNvbnN0IG1pZGRsZXdhcmUgPSAocmVxLCByZXMsIG5leHQsIGVuZCkgPT4ge1xyXG4gICAgLy8gd3JpdGUgcmVxIHRvIHN0cmVhbVxyXG4gICAgc3RyZWFtLnB1c2gocmVxKTsgLy8gcmVnaXN0ZXIgcmVxdWVzdCBvbiBpZCBtYXBcclxuXHJcbiAgICBpZE1hcFtyZXEuaWRdID0ge1xyXG4gICAgICByZXEsXHJcbiAgICAgIHJlcyxcclxuICAgICAgbmV4dCxcclxuICAgICAgZW5kXHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBldmVudHMsXHJcbiAgICBtaWRkbGV3YXJlLFxyXG4gICAgc3RyZWFtXHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVTY2FmZm9sZE1pZGRsZXdhcmUoaGFuZGxlcnMpIHtcclxuICByZXR1cm4gKHJlcSwgcmVzLCBuZXh0LCBlbmQpID0+IHtcclxuICAgIGNvbnN0IGhhbmRsZXIgPSBoYW5kbGVyc1tyZXEubWV0aG9kXTsgLy8gaWYgbm8gaGFuZGxlciwgcmV0dXJuXHJcblxyXG4gICAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICByZXR1cm4gbmV4dCgpO1xyXG4gICAgfSAvLyBpZiBoYW5kbGVyIGlzIGZuLCBjYWxsIGFzIG1pZGRsZXdhcmVcclxuXHJcblxyXG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgcmV0dXJuIGhhbmRsZXIocmVxLCByZXMsIG5leHQsIGVuZCk7XHJcbiAgICB9IC8vIGlmIGhhbmRsZXIgaXMgc29tZSBvdGhlciB2YWx1ZSwgdXNlIGFzIHJlc3VsdFxyXG5cclxuXHJcbiAgICByZXMucmVzdWx0ID0gaGFuZGxlcjtcclxuICAgIHJldHVybiBlbmQoKTtcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUlkUmVtYXBNaWRkbGV3YXJlKCkge1xyXG4gIHJldHVybiAocmVxLCByZXMsIG5leHQsIF9lbmQpID0+IHtcclxuICAgIGNvbnN0IG9yaWdpbmFsSWQgPSByZXEuaWQ7XHJcbiAgICBjb25zdCBuZXdJZCA9IHJhbmRvbUlkKCk7XHJcbiAgICByZXEuaWQgPSBuZXdJZDtcclxuICAgIHJlcy5pZCA9IG5ld0lkO1xyXG4gICAgbmV4dChkb25lID0+IHtcclxuICAgICAgcmVxLmlkID0gb3JpZ2luYWxJZDtcclxuICAgICAgcmVzLmlkID0gb3JpZ2luYWxJZDtcclxuICAgICAgZG9uZSgpO1xyXG4gICAgfSk7XHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVMb2dnZXJNaWRkbGV3YXJlKGxvZ2dlcikge1xyXG4gIHJldHVybiAocmVxLCByZXMsIG5leHQsIF8pID0+IHtcclxuICAgIGxvZ2dlci5kZWJ1ZyhcIlJFUVwiLCByZXEsIFwiUkVTXCIsIHJlcyk7XHJcbiAgICBuZXh0KCk7XHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVBc3luY01pZGRsZXdhcmUoYXN5bmNNaWRkbGV3YXJlKSB7XHJcbiAgcmV0dXJuIGFzeW5jIChyZXEsIHJlcywgbmV4dCwgZW5kKSA9PiB7XHJcbiAgICAvLyBuZXh0UHJvbWlzZSBpcyB0aGUga2V5IHRvIHRoZSBpbXBsZW1lbnRhdGlvblxyXG4gICAgLy8gaXQgaXMgcmVzb2x2ZWQgYnkgdGhlIHJldHVybiBoYW5kbGVyIHBhc3NlZCB0byB0aGVcclxuICAgIC8vIFwibmV4dFwiIGZ1bmN0aW9uXHJcbiAgICBsZXQgcmVzb2x2ZU5leHRQcm9taXNlO1xyXG4gICAgY29uc3QgbmV4dFByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgICAgcmVzb2x2ZU5leHRQcm9taXNlID0gcmVzb2x2ZTtcclxuICAgIH0pO1xyXG4gICAgbGV0IHJldHVybkhhbmRsZXJDYWxsYmFjayA9IG51bGw7XHJcbiAgICBsZXQgbmV4dFdhc0NhbGxlZCA9IGZhbHNlOyAvLyBUaGlzIHdpbGwgYmUgY2FsbGVkIGJ5IHRoZSBjb25zdW1lcidzIGFzeW5jIG1pZGRsZXdhcmUuXHJcblxyXG4gICAgY29uc3QgYXN5bmNOZXh0ID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICBuZXh0V2FzQ2FsbGVkID0gdHJ1ZTsgLy8gV2UgcGFzcyBhIHJldHVybiBoYW5kbGVyIHRvIG5leHQoKS4gV2hlbiBpdCBpcyBjYWxsZWQgYnkgdGhlIGVuZ2luZSxcclxuICAgICAgLy8gdGhlIGNvbnN1bWVyJ3MgYXN5bmMgbWlkZGxld2FyZSB3aWxsIHJlc3VtZSBleGVjdXRpbmcuXHJcblxyXG4gICAgICBuZXh0KHJ1blJldHVybkhhbmRsZXJzQ2FsbGJhY2sgPT4ge1xyXG4gICAgICAgIC8vIFRoaXMgY2FsbGJhY2sgY29tZXMgZnJvbSBKUlBDRW5naW5lLl9ydW5SZXR1cm5IYW5kbGVyc1xyXG4gICAgICAgIHJldHVybkhhbmRsZXJDYWxsYmFjayA9IHJ1blJldHVybkhhbmRsZXJzQ2FsbGJhY2s7XHJcbiAgICAgICAgcmVzb2x2ZU5leHRQcm9taXNlKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgICBhd2FpdCBuZXh0UHJvbWlzZTtcclxuICAgIH07XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgYXdhaXQgYXN5bmNNaWRkbGV3YXJlKHJlcSwgcmVzLCBhc3luY05leHQpO1xyXG5cclxuICAgICAgaWYgKG5leHRXYXNDYWxsZWQpIHtcclxuICAgICAgICBhd2FpdCBuZXh0UHJvbWlzZTsgLy8gd2UgbXVzdCB3YWl0IHVudGlsIHRoZSByZXR1cm4gaGFuZGxlciBpcyBjYWxsZWRcclxuXHJcbiAgICAgICAgcmV0dXJuSGFuZGxlckNhbGxiYWNrKG51bGwpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGVuZChudWxsKTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgaWYgKHJldHVybkhhbmRsZXJDYWxsYmFjaykge1xyXG4gICAgICAgIHJldHVybkhhbmRsZXJDYWxsYmFjayhlcnJvcik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZW5kKGVycm9yKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG93bktleXMkMShvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGVudW1lcmFibGVPbmx5ICYmIChzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSkpLCBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cclxuXHJcbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMSh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307IGkgJSAyID8gb3duS2V5cyQxKE9iamVjdChzb3VyY2UpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IG93bktleXMkMShPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XHJcbi8qKlxyXG4gKiBBIEpTT04tUlBDIHJlcXVlc3QgYW5kIHJlc3BvbnNlIHByb2Nlc3Nvci5cclxuICogR2l2ZSBpdCBhIHN0YWNrIG9mIG1pZGRsZXdhcmUsIHBhc3MgaXQgcmVxdWVzdHMsIGFuZCBnZXQgYmFjayByZXNwb25zZXMuXHJcbiAqL1xyXG5cclxuY2xhc3MgSlJQQ0VuZ2luZSBleHRlbmRzIFNhZmVFdmVudEVtaXR0ZXIge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbWlkZGxld2FyZVwiLCB2b2lkIDApO1xyXG5cclxuICAgIHRoaXMuX21pZGRsZXdhcmUgPSBbXTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogU2VyaWFsbHkgZXhlY3V0ZXMgdGhlIGdpdmVuIHN0YWNrIG9mIG1pZGRsZXdhcmUuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBhbnkgZXJyb3IgZW5jb3VudGVyZWQgZHVyaW5nIG1pZGRsZXdhcmUgZXhlY3V0aW9uLFxyXG4gICAqIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHJlcXVlc3Qgd2FzIGNvbXBsZXRlZCwgYW5kIGFuIGFycmF5IG9mXHJcbiAgICogbWlkZGxld2FyZS1kZWZpbmVkIHJldHVybiBoYW5kbGVycy5cclxuICAgKi9cclxuXHJcblxyXG4gIHN0YXRpYyBhc3luYyBfcnVuQWxsTWlkZGxld2FyZShyZXEsIHJlcywgbWlkZGxld2FyZVN0YWNrKSB7XHJcbiAgICBjb25zdCByZXR1cm5IYW5kbGVycyA9IFtdO1xyXG4gICAgbGV0IGVycm9yID0gbnVsbDtcclxuICAgIGxldCBpc0NvbXBsZXRlID0gZmFsc2U7IC8vIEdvIGRvd24gc3RhY2sgb2YgbWlkZGxld2FyZSwgY2FsbCBhbmQgY29sbGVjdCBvcHRpb25hbCByZXR1cm5IYW5kbGVyc1xyXG5cclxuICAgIGZvciAoY29uc3QgbWlkZGxld2FyZSBvZiBtaWRkbGV3YXJlU3RhY2spIHtcclxuICAgICAgW2Vycm9yLCBpc0NvbXBsZXRlXSA9IGF3YWl0IEpSUENFbmdpbmUuX3J1bk1pZGRsZXdhcmUocmVxLCByZXMsIG1pZGRsZXdhcmUsIHJldHVybkhhbmRsZXJzKTtcclxuXHJcbiAgICAgIGlmIChpc0NvbXBsZXRlKSB7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gW2Vycm9yLCBpc0NvbXBsZXRlLCByZXR1cm5IYW5kbGVycy5yZXZlcnNlKCldO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBSdW5zIGFuIGluZGl2aWR1YWwgbWlkZGxld2FyZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIGFueSBlcnJvciBlbmNvdW50ZXJlZCBkdXJpbmcgbWlkZGxld2FyZSBleGVjdGlvbixcclxuICAgKiBhbmQgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgcmVxdWVzdCBzaG91bGQgZW5kLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgc3RhdGljIF9ydW5NaWRkbGV3YXJlKHJlcSwgcmVzLCBtaWRkbGV3YXJlLCByZXR1cm5IYW5kbGVycykge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xyXG4gICAgICBjb25zdCBlbmQgPSBlcnIgPT4ge1xyXG4gICAgICAgIGNvbnN0IGVycm9yID0gZXJyIHx8IHJlcy5lcnJvcjtcclxuXHJcbiAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICByZXMuZXJyb3IgPSBzZXJpYWxpemVFcnJvcihlcnJvcik7XHJcbiAgICAgICAgfSAvLyBUcnVlIGluZGljYXRlcyB0aGF0IHRoZSByZXF1ZXN0IHNob3VsZCBlbmRcclxuXHJcblxyXG4gICAgICAgIHJlc29sdmUoW2Vycm9yLCB0cnVlXSk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBjb25zdCBuZXh0ID0gcmV0dXJuSGFuZGxlciA9PiB7XHJcbiAgICAgICAgaWYgKHJlcy5lcnJvcikge1xyXG4gICAgICAgICAgZW5kKHJlcy5lcnJvcik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGlmIChyZXR1cm5IYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmV0dXJuSGFuZGxlciAhPT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgZW5kKG5ldyBTZXJpYWxpemFibGVFcnJvcih7XHJcbiAgICAgICAgICAgICAgICBjb2RlOiAtMzI2MDMsXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkpSUENFbmdpbmU6ICduZXh0JyByZXR1cm4gaGFuZGxlcnMgbXVzdCBiZSBmdW5jdGlvbnNcIlxyXG4gICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuSGFuZGxlcnMucHVzaChyZXR1cm5IYW5kbGVyKTtcclxuICAgICAgICAgIH0gLy8gRmFsc2UgaW5kaWNhdGVzIHRoYXQgdGhlIHJlcXVlc3Qgc2hvdWxkIG5vdCBlbmRcclxuXHJcblxyXG4gICAgICAgICAgcmVzb2x2ZShbbnVsbCwgZmFsc2VdKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIG1pZGRsZXdhcmUocmVxLCByZXMsIG5leHQsIGVuZCk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgZW5kKGVycm9yKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFNlcmlhbGx5IGV4ZWN1dGVzIGFycmF5IG9mIHJldHVybiBoYW5kbGVycy4gVGhlIHJlcXVlc3QgYW5kIHJlc3BvbnNlIGFyZVxyXG4gICAqIGFzc3VtZWQgdG8gYmUgaW4gdGhlaXIgc2NvcGUuXHJcbiAgICovXHJcblxyXG5cclxuICBzdGF0aWMgYXN5bmMgX3J1blJldHVybkhhbmRsZXJzKGhhbmRsZXJzKSB7XHJcbiAgICBmb3IgKGNvbnN0IGhhbmRsZXIgb2YgaGFuZGxlcnMpIHtcclxuICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIGhhbmRsZXIoZXJyID0+IGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZSgpKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgcmVzcG9uc2UgaGFzIG5laXRoZXIgYSByZXN1bHQgbm9yIGFuIGVycm9yLCBvciBpZlxyXG4gICAqIHRoZSBcImlzQ29tcGxldGVcIiBmbGFnIGlzIGZhbHN5LlxyXG4gICAqL1xyXG5cclxuXHJcbiAgc3RhdGljIF9jaGVja0ZvckNvbXBsZXRpb24ocmVxLCByZXMsIGlzQ29tcGxldGUpIHtcclxuICAgIGlmICghKFwicmVzdWx0XCIgaW4gcmVzKSAmJiAhKFwiZXJyb3JcIiBpbiByZXMpKSB7XHJcbiAgICAgIHRocm93IG5ldyBTZXJpYWxpemFibGVFcnJvcih7XHJcbiAgICAgICAgY29kZTogLTMyNjAzLFxyXG4gICAgICAgIG1lc3NhZ2U6IFwiUmVzcG9uc2UgaGFzIG5vIGVycm9yIG9yIHJlc3VsdCBmb3IgcmVxdWVzdFwiXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghaXNDb21wbGV0ZSkge1xyXG4gICAgICB0aHJvdyBuZXcgU2VyaWFsaXphYmxlRXJyb3Ioe1xyXG4gICAgICAgIGNvZGU6IC0zMjYwMyxcclxuICAgICAgICBtZXNzYWdlOiBcIk5vdGhpbmcgZW5kZWQgcmVxdWVzdFwiXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuICAvKipcclxuICAgKiBBZGQgYSBtaWRkbGV3YXJlIGZ1bmN0aW9uIHRvIHRoZSBlbmdpbmUncyBtaWRkbGV3YXJlIHN0YWNrLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIG1pZGRsZXdhcmUgLSBUaGUgbWlkZGxld2FyZSBmdW5jdGlvbiB0byBhZGQuXHJcbiAgICovXHJcblxyXG5cclxuICBwdXNoKG1pZGRsZXdhcmUpIHtcclxuICAgIHRoaXMuX21pZGRsZXdhcmUucHVzaChtaWRkbGV3YXJlKTtcclxuICB9XHJcblxyXG4gIGhhbmRsZShyZXEsIGNiKSB7XHJcbiAgICBpZiAoY2IgJiYgdHlwZW9mIGNiICE9PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImNhbGxiYWNrXCIgbXVzdCBiZSBhIGZ1bmN0aW9uIGlmIHByb3ZpZGVkLicpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChBcnJheS5pc0FycmF5KHJlcSkpIHtcclxuICAgICAgaWYgKGNiKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZUJhdGNoKHJlcSwgY2IpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGhpcy5faGFuZGxlQmF0Y2gocmVxKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY2IpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZShyZXEsIGNiKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZUhhbmRsZShyZXEpO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoaXMgZW5naW5lIGFzIGEgbWlkZGxld2FyZSBmdW5jdGlvbiB0aGF0IGNhbiBiZSBwdXNoZWQgdG8gb3RoZXJcclxuICAgKiBlbmdpbmVzLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMgVGhpcyBlbmdpbmUgYXMgYSBtaWRkbGV3YXJlIGZ1bmN0aW9uLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgYXNNaWRkbGV3YXJlKCkge1xyXG4gICAgcmV0dXJuIGFzeW5jIChyZXEsIHJlcywgbmV4dCwgZW5kKSA9PiB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgW21pZGRsZXdhcmVFcnJvciwgaXNDb21wbGV0ZSwgcmV0dXJuSGFuZGxlcnNdID0gYXdhaXQgSlJQQ0VuZ2luZS5fcnVuQWxsTWlkZGxld2FyZShyZXEsIHJlcywgdGhpcy5fbWlkZGxld2FyZSk7XHJcblxyXG4gICAgICAgIGlmIChpc0NvbXBsZXRlKSB7XHJcbiAgICAgICAgICBhd2FpdCBKUlBDRW5naW5lLl9ydW5SZXR1cm5IYW5kbGVycyhyZXR1cm5IYW5kbGVycyk7XHJcbiAgICAgICAgICByZXR1cm4gZW5kKG1pZGRsZXdhcmVFcnJvcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbmV4dChhc3luYyBoYW5kbGVyQ2FsbGJhY2sgPT4ge1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgYXdhaXQgSlJQQ0VuZ2luZS5fcnVuUmV0dXJuSGFuZGxlcnMocmV0dXJuSGFuZGxlcnMpO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXJDYWxsYmFjayhlcnJvcik7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZXJDYWxsYmFjaygpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIHJldHVybiBlbmQoZXJyb3IpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgX2hhbmRsZUJhdGNoKHJlcXMsIGNiKSB7XHJcbiAgICAvLyBUaGUgb3JkZXIgaGVyZSBpcyBpbXBvcnRhbnRcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIDIuIFdhaXQgZm9yIGFsbCByZXF1ZXN0cyB0byBmaW5pc2gsIG9yIHRocm93IG9uIHNvbWUga2luZCBvZiBmYXRhbFxyXG4gICAgICAvLyBlcnJvclxyXG4gICAgICBjb25zdCByZXNwb25zZXMgPSBhd2FpdCBQcm9taXNlLmFsbCggLy8gMS4gQmVnaW4gZXhlY3V0aW5nIGVhY2ggcmVxdWVzdCBpbiB0aGUgb3JkZXIgcmVjZWl2ZWRcclxuICAgICAgcmVxcy5tYXAodGhpcy5fcHJvbWlzZUhhbmRsZS5iaW5kKHRoaXMpKSk7IC8vIDMuIFJldHVybiBiYXRjaCByZXNwb25zZVxyXG5cclxuICAgICAgaWYgKGNiKSB7XHJcbiAgICAgICAgcmV0dXJuIGNiKG51bGwsIHJlc3BvbnNlcyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiByZXNwb25zZXM7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBpZiAoY2IpIHtcclxuICAgICAgICByZXR1cm4gY2IoZXJyb3IpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9XHJcbiAgLyoqXHJcbiAgICogQSBwcm9taXNlLXdyYXBwZWQgX2hhbmRsZS5cclxuICAgKi9cclxuXHJcblxyXG4gIF9wcm9taXNlSGFuZGxlKHJlcSkge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xyXG4gICAgICB0aGlzLl9oYW5kbGUocmVxLCAoX2VyciwgcmVzKSA9PiB7XHJcbiAgICAgICAgLy8gVGhlcmUgd2lsbCBhbHdheXMgYmUgYSByZXNwb25zZSwgYW5kIGl0IHdpbGwgYWx3YXlzIGhhdmUgYW55IGVycm9yXHJcbiAgICAgICAgLy8gdGhhdCBpcyBjYXVnaHQgYW5kIHByb3BhZ2F0ZWQuXHJcbiAgICAgICAgcmVzb2x2ZShyZXMpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBFbnN1cmVzIHRoYXQgdGhlIHJlcXVlc3Qgb2JqZWN0IGlzIHZhbGlkLCBwcm9jZXNzZXMgaXQsIGFuZCBwYXNzZXMgYW55XHJcbiAgICogZXJyb3IgYW5kIHRoZSByZXNwb25zZSBvYmplY3QgdG8gdGhlIGdpdmVuIGNhbGxiYWNrLlxyXG4gICAqXHJcbiAgICogRG9lcyBub3QgcmVqZWN0LlxyXG4gICAqL1xyXG5cclxuXHJcbiAgYXN5bmMgX2hhbmRsZShjYWxsZXJSZXEsIGNiKSB7XHJcbiAgICBpZiAoIWNhbGxlclJlcSB8fCBBcnJheS5pc0FycmF5KGNhbGxlclJlcSkgfHwgdHlwZW9mIGNhbGxlclJlcSAhPT0gXCJvYmplY3RcIikge1xyXG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBTZXJpYWxpemFibGVFcnJvcih7XHJcbiAgICAgICAgY29kZTogLTMyNjAzLFxyXG4gICAgICAgIG1lc3NhZ2U6IFwicmVxdWVzdCBtdXN0IGJlIHBsYWluIG9iamVjdFwiXHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gY2IoZXJyb3IsIHtcclxuICAgICAgICBpZDogdW5kZWZpbmVkLFxyXG4gICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXHJcbiAgICAgICAgZXJyb3JcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGVvZiBjYWxsZXJSZXEubWV0aG9kICE9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IFNlcmlhbGl6YWJsZUVycm9yKHtcclxuICAgICAgICBjb2RlOiAtMzI2MDMsXHJcbiAgICAgICAgbWVzc2FnZTogXCJtZXRob2QgbXVzdCBiZSBzdHJpbmdcIlxyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIGNiKGVycm9yLCB7XHJcbiAgICAgICAgaWQ6IGNhbGxlclJlcS5pZCxcclxuICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxyXG4gICAgICAgIGVycm9yXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHJlcSA9IF9vYmplY3RTcHJlYWQkMSh7fSwgY2FsbGVyUmVxKTtcclxuXHJcbiAgICBjb25zdCByZXMgPSB7XHJcbiAgICAgIGlkOiByZXEuaWQsXHJcbiAgICAgIGpzb25ycGM6IHJlcS5qc29ucnBjXHJcbiAgICB9O1xyXG4gICAgbGV0IGVycm9yID0gbnVsbDtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBhd2FpdCB0aGlzLl9wcm9jZXNzUmVxdWVzdChyZXEsIHJlcyk7XHJcbiAgICB9IGNhdGNoIChfZXJyb3IpIHtcclxuICAgICAgLy8gQSByZXF1ZXN0IGhhbmRsZXIgZXJyb3IsIGEgcmUtdGhyb3duIG1pZGRsZXdhcmUgZXJyb3IsIG9yIHNvbWV0aGluZ1xyXG4gICAgICAvLyB1bmV4cGVjdGVkLlxyXG4gICAgICBlcnJvciA9IF9lcnJvcjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgLy8gRW5zdXJlIG5vIHJlc3VsdCBpcyBwcmVzZW50IG9uIGFuIGVycm9yZWQgcmVzcG9uc2VcclxuICAgICAgZGVsZXRlIHJlcy5yZXN1bHQ7XHJcblxyXG4gICAgICBpZiAoIXJlcy5lcnJvcikge1xyXG4gICAgICAgIHJlcy5lcnJvciA9IHNlcmlhbGl6ZUVycm9yKGVycm9yKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjYihlcnJvciwgcmVzKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogRm9yIHRoZSBnaXZlbiByZXF1ZXN0IGFuZCByZXNwb25zZSwgcnVucyBhbGwgbWlkZGxld2FyZSBhbmQgdGhlaXIgcmV0dXJuXHJcbiAgICogaGFuZGxlcnMsIGlmIGFueSwgYW5kIGVuc3VyZXMgdGhhdCBpbnRlcm5hbCByZXF1ZXN0IHByb2Nlc3Npbmcgc2VtYW50aWNzXHJcbiAgICogYXJlIHNhdGlzZmllZC5cclxuICAgKi9cclxuXHJcblxyXG4gIGFzeW5jIF9wcm9jZXNzUmVxdWVzdChyZXEsIHJlcykge1xyXG4gICAgY29uc3QgW2Vycm9yLCBpc0NvbXBsZXRlLCByZXR1cm5IYW5kbGVyc10gPSBhd2FpdCBKUlBDRW5naW5lLl9ydW5BbGxNaWRkbGV3YXJlKHJlcSwgcmVzLCB0aGlzLl9taWRkbGV3YXJlKTsgLy8gVGhyb3cgaWYgXCJlbmRcIiB3YXMgbm90IGNhbGxlZCwgb3IgaWYgdGhlIHJlc3BvbnNlIGhhcyBuZWl0aGVyIGEgcmVzdWx0XHJcbiAgICAvLyBub3IgYW4gZXJyb3IuXHJcblxyXG4gICAgSlJQQ0VuZ2luZS5fY2hlY2tGb3JDb21wbGV0aW9uKHJlcSwgcmVzLCBpc0NvbXBsZXRlKTsgLy8gVGhlIHJldHVybiBoYW5kbGVycyBzaG91bGQgcnVuIGV2ZW4gaWYgYW4gZXJyb3Igd2FzIGVuY291bnRlcmVkIGR1cmluZ1xyXG4gICAgLy8gbWlkZGxld2FyZSBwcm9jZXNzaW5nLlxyXG5cclxuXHJcbiAgICBhd2FpdCBKUlBDRW5naW5lLl9ydW5SZXR1cm5IYW5kbGVycyhyZXR1cm5IYW5kbGVycyk7IC8vIE5vdyB3ZSByZS10aHJvdyB0aGUgbWlkZGxld2FyZSBwcm9jZXNzaW5nIGVycm9yLCBpZiBhbnksIHRvIGNhdGNoIGl0XHJcbiAgICAvLyBmdXJ0aGVyIHVwIHRoZSBjYWxsIGNoYWluLlxyXG5cclxuICAgIGlmIChlcnJvcikge1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9XHJcblxyXG59XHJcbmZ1bmN0aW9uIG1lcmdlTWlkZGxld2FyZShtaWRkbGV3YXJlU3RhY2spIHtcclxuICBjb25zdCBlbmdpbmUgPSBuZXcgSlJQQ0VuZ2luZSgpO1xyXG4gIG1pZGRsZXdhcmVTdGFjay5mb3JFYWNoKG1pZGRsZXdhcmUgPT4gZW5naW5lLnB1c2gobWlkZGxld2FyZSkpO1xyXG4gIHJldHVybiBlbmdpbmUuYXNNaWRkbGV3YXJlKCk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlRW5naW5lU3RyZWFtKG9wdHMpIHtcclxuICBpZiAoIW9wdHMgfHwgIW9wdHMuZW5naW5lKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGVuZ2luZSBwYXJhbWV0ZXIhXCIpO1xyXG4gIH1cclxuXHJcbiAgY29uc3Qge1xyXG4gICAgZW5naW5lXHJcbiAgfSA9IG9wdHM7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcclxuXHJcbiAgbGV0IHN0cmVhbTtcclxuXHJcbiAgZnVuY3Rpb24gcmVhZCgpIHtcclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB3cml0ZShyZXEsIF9lbmNvZGluZywgY2IpIHtcclxuICAgIGVuZ2luZS5oYW5kbGUocmVxLCAoX2VyciwgcmVzKSA9PiB7XHJcbiAgICAgIHN0cmVhbS5wdXNoKHJlcyk7XHJcbiAgICB9KTtcclxuICAgIGNiKCk7XHJcbiAgfVxyXG5cclxuICBzdHJlYW0gPSBuZXcgRHVwbGV4KHtcclxuICAgIG9iamVjdE1vZGU6IHRydWUsXHJcbiAgICByZWFkLFxyXG4gICAgd3JpdGVcclxuICB9KTsgLy8gZm9yd2FyZCBub3RpZmljYXRpb25zXHJcblxyXG4gIGlmIChlbmdpbmUub24pIHtcclxuICAgIGVuZ2luZS5vbihcIm5vdGlmaWNhdGlvblwiLCBtZXNzYWdlID0+IHtcclxuICAgICAgc3RyZWFtLnB1c2gobWVzc2FnZSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHJldHVybiBzdHJlYW07XHJcbn1cclxuXHJcbmNsYXNzIFN1YnN0cmVhbSBleHRlbmRzIER1cGxleCB7XHJcbiAgY29uc3RydWN0b3IoX3JlZikge1xyXG4gICAgbGV0IHtcclxuICAgICAgcGFyZW50LFxyXG4gICAgICBuYW1lXHJcbiAgICB9ID0gX3JlZjtcclxuICAgIHN1cGVyKHtcclxuICAgICAgb2JqZWN0TW9kZTogdHJ1ZVxyXG4gICAgfSk7XHJcblxyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3BhcmVudFwiLCB2b2lkIDApO1xyXG5cclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9uYW1lXCIsIHZvaWQgMCk7XHJcblxyXG4gICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xyXG4gICAgdGhpcy5fbmFtZSA9IG5hbWU7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEV4cGxpY2l0bHkgc2V0cyByZWFkIG9wZXJhdGlvbnMgdG8gYSBuby1vcC5cclxuICAgKi9cclxuXHJcblxyXG4gIF9yZWFkKCkge1xyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogQ2FsbGVkIHdoZW4gZGF0YSBzaG91bGQgYmUgd3JpdHRlbiB0byB0aGlzIHdyaXRhYmxlIHN0cmVhbS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBjaHVuayAtIEFyYml0cmFyeSBvYmplY3QgdG8gd3JpdGVcclxuICAgKiBAcGFyYW0gZW5jb2RpbmcgLSBFbmNvZGluZyB0byB1c2Ugd2hlbiB3cml0aW5nIHBheWxvYWRcclxuICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBDYWxsZWQgd2hlbiB3cml0aW5nIGlzIGNvbXBsZXRlIG9yIGFuIGVycm9yIG9jY3Vyc1xyXG4gICAqL1xyXG5cclxuXHJcbiAgX3dyaXRlKGNodW5rLCBfZW5jb2RpbmcsIGNhbGxiYWNrKSB7XHJcbiAgICB0aGlzLl9wYXJlbnQucHVzaCh7XHJcbiAgICAgIG5hbWU6IHRoaXMuX25hbWUsXHJcbiAgICAgIGRhdGE6IGNodW5rXHJcbiAgICB9KTtcclxuXHJcbiAgICBjYWxsYmFjaygpO1xyXG4gIH1cclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XHJcblxyXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gbnVsbCAhPSBhcmd1bWVudHNbaV0gPyBhcmd1bWVudHNbaV0gOiB7fTsgaSAlIDIgPyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gcmV0dXJuIHRhcmdldDsgfVxyXG5jb25zdCBJR05PUkVfU1VCU1RSRUFNID0gU3ltYm9sKFwiSUdOT1JFX1NVQlNUUkVBTVwiKTtcclxuY2xhc3MgT2JqZWN0TXVsdGlwbGV4IGV4dGVuZHMgRHVwbGV4IHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcclxuICAgIHN1cGVyKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgb3B0cyksIHt9LCB7XHJcbiAgICAgIG9iamVjdE1vZGU6IHRydWVcclxuICAgIH0pKTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfc3Vic3RyZWFtc1wiLCB2b2lkIDApO1xyXG5cclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdldFN0cmVhbVwiLCB2b2lkIDApO1xyXG5cclxuICAgIHRoaXMuX3N1YnN0cmVhbXMgPSB7fTtcclxuICB9XHJcblxyXG4gIGNyZWF0ZVN0cmVhbShuYW1lKSB7XHJcbiAgICAvLyB2YWxpZGF0ZSBuYW1lXHJcbiAgICBpZiAoIW5hbWUpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT2JqZWN0TXVsdGlwbGV4IC0gbmFtZSBtdXN0IG5vdCBiZSBlbXB0eVwiKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5fc3Vic3RyZWFtc1tuYW1lXSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPYmplY3RNdWx0aXBsZXggLSBTdWJzdHJlYW0gZm9yIG5hbWUgXFxcIlwiLmNvbmNhdChuYW1lLCBcIlxcXCIgYWxyZWFkeSBleGlzdHNcIikpO1xyXG4gICAgfSAvLyBjcmVhdGUgc3Vic3RyZWFtXHJcblxyXG5cclxuICAgIGNvbnN0IHN1YnN0cmVhbSA9IG5ldyBTdWJzdHJlYW0oe1xyXG4gICAgICBwYXJlbnQ6IHRoaXMsXHJcbiAgICAgIG5hbWVcclxuICAgIH0pO1xyXG4gICAgdGhpcy5fc3Vic3RyZWFtc1tuYW1lXSA9IHN1YnN0cmVhbTsgLy8gbGlzdGVuIGZvciBwYXJlbnQgc3RyZWFtIHRvIGVuZFxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxyXG5cclxuICAgIGFueVN0cmVhbUVuZCh0aGlzLCBfZXJyb3IgPT4gc3Vic3RyZWFtLmRlc3Ryb3koX2Vycm9yIHx8IHVuZGVmaW5lZCkpO1xyXG4gICAgcmV0dXJuIHN1YnN0cmVhbTtcclxuICB9IC8vIGlnbm9yZSBzdHJlYW1zIChkb250IGRpc3BsYXkgb3JwaGFuZWQgZGF0YSB3YXJuaW5nKVxyXG5cclxuXHJcbiAgaWdub3JlU3RyZWFtKG5hbWUpIHtcclxuICAgIC8vIHZhbGlkYXRlIG5hbWVcclxuICAgIGlmICghbmFtZSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPYmplY3RNdWx0aXBsZXggLSBuYW1lIG11c3Qgbm90IGJlIGVtcHR5XCIpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl9zdWJzdHJlYW1zW25hbWVdKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk9iamVjdE11bHRpcGxleCAtIFN1YnN0cmVhbSBmb3IgbmFtZSBcXFwiXCIuY29uY2F0KG5hbWUsIFwiXFxcIiBhbHJlYWR5IGV4aXN0c1wiKSk7XHJcbiAgICB9IC8vIHNldFxyXG5cclxuXHJcbiAgICB0aGlzLl9zdWJzdHJlYW1zW25hbWVdID0gSUdOT1JFX1NVQlNUUkVBTTtcclxuICB9XHJcblxyXG4gIF9yZWFkKCkge1xyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICB9XHJcblxyXG4gIF93cml0ZShjaHVuaywgX2VuY29kaW5nLCBjYWxsYmFjaykge1xyXG4gICAgY29uc3Qge1xyXG4gICAgICBuYW1lLFxyXG4gICAgICBkYXRhXHJcbiAgICB9ID0gY2h1bms7XHJcblxyXG4gICAgaWYgKCFuYW1lKSB7XHJcbiAgICAgIHdpbmRvdy5jb25zb2xlLndhcm4oXCJPYmplY3RNdWx0aXBsZXggLSBtYWxmb3JtZWQgY2h1bmsgd2l0aG91dCBuYW1lIFxcXCJcIi5jb25jYXQoY2h1bmssIFwiXFxcIlwiKSk7XHJcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xyXG4gICAgfSAvLyBnZXQgY29ycmVzcG9uZGluZyBzdWJzdHJlYW1cclxuXHJcblxyXG4gICAgY29uc3Qgc3Vic3RyZWFtID0gdGhpcy5fc3Vic3RyZWFtc1tuYW1lXTtcclxuXHJcbiAgICBpZiAoIXN1YnN0cmVhbSkge1xyXG4gICAgICB3aW5kb3cuY29uc29sZS53YXJuKFwiT2JqZWN0TXVsdGlwbGV4IC0gb3JwaGFuZWQgZGF0YSBmb3Igc3RyZWFtIFxcXCJcIi5jb25jYXQobmFtZSwgXCJcXFwiXCIpKTtcclxuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XHJcbiAgICB9IC8vIHB1c2ggZGF0YSBpbnRvIHN1YnN0cmVhbVxyXG5cclxuXHJcbiAgICBpZiAoc3Vic3RyZWFtICE9PSBJR05PUkVfU1VCU1RSRUFNKSB7XHJcbiAgICAgIHN1YnN0cmVhbS5wdXNoKGRhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjYWxsYmFjaygpO1xyXG4gIH1cclxuXHJcbn0gLy8gdXRpbFxyXG5cclxuZnVuY3Rpb24gYW55U3RyZWFtRW5kKHN0cmVhbSwgX2NiKSB7XHJcbiAgY29uc3QgY2IgPSBvbmNlKF9jYik7XHJcbiAgZW9zKHN0cmVhbSwge1xyXG4gICAgcmVhZGFibGU6IGZhbHNlXHJcbiAgfSwgY2IpO1xyXG4gIGVvcyhzdHJlYW0sIHtcclxuICAgIHdyaXRhYmxlOiBmYWxzZVxyXG4gIH0sIGNiKTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2V0dXBNdWx0aXBsZXgoc3RyZWFtKSB7XHJcbiAgY29uc3QgbXV4ID0gbmV3IE9iamVjdE11bHRpcGxleCgpO1xyXG5cclxuICBtdXguZ2V0U3RyZWFtID0gZnVuY3Rpb24gc3RyZWFtSGVscGVyKG5hbWUpIHtcclxuICAgIGlmICh0aGlzLl9zdWJzdHJlYW1zW25hbWVdKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9zdWJzdHJlYW1zW25hbWVdO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLmNyZWF0ZVN0cmVhbShuYW1lKTtcclxuICB9O1xyXG5cclxuICBwdW1wKHN0cmVhbSwgbXV4LCBzdHJlYW0sIGVyciA9PiB7XHJcbiAgICBpZiAoZXJyKSB3aW5kb3cuY29uc29sZS5lcnJvcihlcnIpO1xyXG4gIH0pO1xyXG4gIHJldHVybiBtdXg7XHJcbn1cclxuXHJcbmNsYXNzIFBvc3RNZXNzYWdlU3RyZWFtIGV4dGVuZHMgQmFzZVBvc3RNZXNzYWdlU3RyZWFtIHtcclxuICBfcG9zdE1lc3NhZ2UoZGF0YSkge1xyXG4gICAgbGV0IG9yaWdpbkNvbnN0cmFpbnQgPSB0aGlzLl90YXJnZXRPcmlnaW47XHJcblxyXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgIGNvbnN0IGRhdGFPYmogPSBkYXRhO1xyXG5cclxuICAgICAgaWYgKHR5cGVvZiBkYXRhT2JqLmRhdGEgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICBjb25zdCBkYXRhT2JqRGF0YSA9IGRhdGFPYmouZGF0YTtcclxuXHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YU9iakRhdGEucGFyYW1zKSAmJiBkYXRhT2JqRGF0YS5wYXJhbXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgY29uc3QgZGF0YU9iakRhdGFQYXJhbSA9IGRhdGFPYmpEYXRhLnBhcmFtc1swXTtcclxuXHJcbiAgICAgICAgICBpZiAoZGF0YU9iakRhdGFQYXJhbS5fb3JpZ2luKSB7XHJcbiAgICAgICAgICAgIG9yaWdpbkNvbnN0cmFpbnQgPSBkYXRhT2JqRGF0YVBhcmFtLl9vcmlnaW47XHJcbiAgICAgICAgICB9IC8vIGFkZCBhIGNvbnN0cmFpbnQgZm9yIHRoZSByZXNwb25zZVxyXG5cclxuXHJcbiAgICAgICAgICBkYXRhT2JqRGF0YVBhcmFtLl9vcmlnaW4gPSB3aW5kb3cubG9jYXRpb24ub3JpZ2luO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX3RhcmdldFdpbmRvdy5wb3N0TWVzc2FnZSh7XHJcbiAgICAgIHRhcmdldDogdGhpcy5fdGFyZ2V0LFxyXG4gICAgICBkYXRhXHJcbiAgICB9LCBvcmlnaW5Db25zdHJhaW50KTtcclxuICB9XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBCYXNlUG9zdE1lc3NhZ2VTdHJlYW0sIElHTk9SRV9TVUJTVFJFQU0sIEpSUENFbmdpbmUsIE9iamVjdE11bHRpcGxleCwgUG9zdE1lc3NhZ2VTdHJlYW0sIFNhZmVFdmVudEVtaXR0ZXIsIFNlcmlhbGl6YWJsZUVycm9yLCBTdWJzdHJlYW0sIGNyZWF0ZUFzeW5jTWlkZGxld2FyZSwgY3JlYXRlRW5naW5lU3RyZWFtLCBjcmVhdGVFcnJvck1pZGRsZXdhcmUsIGNyZWF0ZUlkUmVtYXBNaWRkbGV3YXJlLCBjcmVhdGVMb2dnZXJNaWRkbGV3YXJlLCBjcmVhdGVTY2FmZm9sZE1pZGRsZXdhcmUsIGNyZWF0ZVN0cmVhbU1pZGRsZXdhcmUsIGdldFJwY1Byb21pc2VDYWxsYmFjaywgbWVyZ2VNaWRkbGV3YXJlLCBzZXJpYWxpemVFcnJvciwgc2V0dXBNdWx0aXBsZXggfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3BlbmxvZ2luSnJwYy5lc20uanMubWFwXHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@toruslabs/openlogin-jrpc/dist/openloginJrpc.esm.js\n");

/***/ }),

/***/ "./node_modules/@toruslabs/openlogin-utils/dist/openloginUtils.esm.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@toruslabs/openlogin-utils/dist/openloginUtils.esm.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"URLWithHashParams\": function() { return /* binding */ URLWithHashParams; },\n/* harmony export */   \"base64toJSON\": function() { return /* binding */ base64toJSON; },\n/* harmony export */   \"base64url\": function() { return /* binding */ base64url; },\n/* harmony export */   \"jsonToBase64\": function() { return /* binding */ jsonToBase64; },\n/* harmony export */   \"keccak\": function() { return /* binding */ keccak; },\n/* harmony export */   \"keccak256\": function() { return /* binding */ keccak256; },\n/* harmony export */   \"randomId\": function() { return /* binding */ randomId; },\n/* harmony export */   \"safeatob\": function() { return /* binding */ safeatob; },\n/* harmony export */   \"safebtoa\": function() { return /* binding */ safebtoa; }\n/* harmony export */ });\n/* harmony import */ var randombytes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! randombytes */ \"./node_modules/randombytes/browser.js\");\n/* harmony import */ var randombytes__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(randombytes__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/esm/defineProperty.js\");\n/* harmony import */ var base64url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! base64url */ \"./node_modules/base64url/index.js\");\n/* harmony import */ var base64url__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(base64url__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var keccak__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! keccak */ \"./node_modules/keccak/js.js\");\n/* harmony import */ var keccak__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(keccak__WEBPACK_IMPORTED_MODULE_3__);\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\r\n\r\n\r\n\r\n\r\n// TODO: should be crypto safe\r\nconst randomId = () => randombytes__WEBPACK_IMPORTED_MODULE_0___default()(32).toString(\"hex\");\r\n\r\nclass URLWithHashParams extends URL {\r\n  constructor() {\r\n    super(...arguments);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"hashParams\", new URLSearchParams());\r\n  }\r\n\r\n  toString() {\r\n    this.hash = this.hashParams.toString();\r\n    return super.toString.call(this);\r\n  }\r\n\r\n}\r\n\r\nconst base64url = (base64url__WEBPACK_IMPORTED_MODULE_2___default());\r\nfunction safebtoa(str) {\r\n  return base64url.encode(str);\r\n}\r\nfunction safeatob(str) {\r\n  // Going backwards: from bytestream, to percent-encoding, to original string.\r\n  return base64url.decode(str);\r\n}\r\nconst keccak = (keccak__WEBPACK_IMPORTED_MODULE_3___default());\r\nfunction base64toJSON(b64str) {\r\n  return JSON.parse(base64url.decode(b64str));\r\n}\r\nfunction jsonToBase64(json) {\r\n  return base64url.encode(JSON.stringify(json));\r\n}\r\nfunction keccak256(str) {\r\n  let input = str;\r\n\r\n  if (typeof str === \"string\" && str.slice(0, 2) === \"0x\" && str.length === 66) {\r\n    input = Buffer.from(str.slice(2), \"hex\");\r\n  }\r\n\r\n  const data = \"0x\".concat(keccak(\"keccak256\").update(input).digest(\"hex\").padStart(64, \"0\"));\r\n  return data;\r\n}\r\n\r\n\r\n//# sourceMappingURL=openloginUtils.esm.js.map\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9vcGVubG9naW4tdXRpbHMvZGlzdC9vcGVubG9naW5VdGlscy5lc20uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBc0M7QUFDOEI7QUFDL0I7QUFDTjtBQUMvQjtBQUNBO0FBQ0EsdUJBQXVCLGtEQUFXO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlGQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrREFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsK0NBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3FIO0FBQ3JIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AdG9ydXNsYWJzL29wZW5sb2dpbi11dGlscy9kaXN0L29wZW5sb2dpblV0aWxzLmVzbS5qcz9mOTNhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCByYW5kb21ieXRlcyBmcm9tICdyYW5kb21ieXRlcyc7XHJcbmltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eSc7XHJcbmltcG9ydCBiYXNlNjR1cmxMaWIgZnJvbSAnYmFzZTY0dXJsJztcclxuaW1wb3J0IGtlY2Nha0xpYiBmcm9tICdrZWNjYWsnO1xyXG5cclxuLy8gVE9ETzogc2hvdWxkIGJlIGNyeXB0byBzYWZlXHJcbmNvbnN0IHJhbmRvbUlkID0gKCkgPT4gcmFuZG9tYnl0ZXMoMzIpLnRvU3RyaW5nKFwiaGV4XCIpO1xyXG5cclxuY2xhc3MgVVJMV2l0aEhhc2hQYXJhbXMgZXh0ZW5kcyBVUkwge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJoYXNoUGFyYW1zXCIsIG5ldyBVUkxTZWFyY2hQYXJhbXMoKSk7XHJcbiAgfVxyXG5cclxuICB0b1N0cmluZygpIHtcclxuICAgIHRoaXMuaGFzaCA9IHRoaXMuaGFzaFBhcmFtcy50b1N0cmluZygpO1xyXG4gICAgcmV0dXJuIHN1cGVyLnRvU3RyaW5nLmNhbGwodGhpcyk7XHJcbiAgfVxyXG5cclxufVxyXG5cclxuY29uc3QgYmFzZTY0dXJsID0gYmFzZTY0dXJsTGliO1xyXG5mdW5jdGlvbiBzYWZlYnRvYShzdHIpIHtcclxuICByZXR1cm4gYmFzZTY0dXJsLmVuY29kZShzdHIpO1xyXG59XHJcbmZ1bmN0aW9uIHNhZmVhdG9iKHN0cikge1xyXG4gIC8vIEdvaW5nIGJhY2t3YXJkczogZnJvbSBieXRlc3RyZWFtLCB0byBwZXJjZW50LWVuY29kaW5nLCB0byBvcmlnaW5hbCBzdHJpbmcuXHJcbiAgcmV0dXJuIGJhc2U2NHVybC5kZWNvZGUoc3RyKTtcclxufVxyXG5jb25zdCBrZWNjYWsgPSBrZWNjYWtMaWI7XHJcbmZ1bmN0aW9uIGJhc2U2NHRvSlNPTihiNjRzdHIpIHtcclxuICByZXR1cm4gSlNPTi5wYXJzZShiYXNlNjR1cmwuZGVjb2RlKGI2NHN0cikpO1xyXG59XHJcbmZ1bmN0aW9uIGpzb25Ub0Jhc2U2NChqc29uKSB7XHJcbiAgcmV0dXJuIGJhc2U2NHVybC5lbmNvZGUoSlNPTi5zdHJpbmdpZnkoanNvbikpO1xyXG59XHJcbmZ1bmN0aW9uIGtlY2NhazI1NihzdHIpIHtcclxuICBsZXQgaW5wdXQgPSBzdHI7XHJcblxyXG4gIGlmICh0eXBlb2Ygc3RyID09PSBcInN0cmluZ1wiICYmIHN0ci5zbGljZSgwLCAyKSA9PT0gXCIweFwiICYmIHN0ci5sZW5ndGggPT09IDY2KSB7XHJcbiAgICBpbnB1dCA9IEJ1ZmZlci5mcm9tKHN0ci5zbGljZSgyKSwgXCJoZXhcIik7XHJcbiAgfVxyXG5cclxuICBjb25zdCBkYXRhID0gXCIweFwiLmNvbmNhdChrZWNjYWsoXCJrZWNjYWsyNTZcIikudXBkYXRlKGlucHV0KS5kaWdlc3QoXCJoZXhcIikucGFkU3RhcnQoNjQsIFwiMFwiKSk7XHJcbiAgcmV0dXJuIGRhdGE7XHJcbn1cclxuXHJcbmV4cG9ydCB7IFVSTFdpdGhIYXNoUGFyYW1zLCBiYXNlNjR0b0pTT04sIGJhc2U2NHVybCwganNvblRvQmFzZTY0LCBrZWNjYWssIGtlY2NhazI1NiwgcmFuZG9tSWQsIHNhZmVhdG9iLCBzYWZlYnRvYSB9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcGVubG9naW5VdGlscy5lc20uanMubWFwXHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@toruslabs/openlogin-utils/dist/openloginUtils.esm.js\n");

/***/ }),

/***/ "./node_modules/@toruslabs/solana-embed/dist/solanaEmbed.esm.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@toruslabs/solana-embed/dist/solanaEmbed.esm.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BUTTON_POSITION\": function() { return /* binding */ BUTTON_POSITION; },\n/* harmony export */   \"LOGIN_PROVIDER\": function() { return /* binding */ LOGIN_PROVIDER; },\n/* harmony export */   \"PAYMENT_PROVIDER\": function() { return /* binding */ PAYMENT_PROVIDER; },\n/* harmony export */   \"TORUS_BUILD_ENV\": function() { return /* binding */ TORUS_BUILD_ENV; },\n/* harmony export */   \"TorusInPageProvider\": function() { return /* binding */ TorusInPageProvider; },\n/* harmony export */   \"default\": function() { return /* binding */ Torus; }\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/esm/defineProperty.js\");\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana/web3.js */ \"./node_modules/@solana/web3.js/lib/index.browser.esm.js\");\n/* harmony import */ var _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @toruslabs/base-controllers */ \"./node_modules/@toruslabs/base-controllers/dist/baseControllers.esm.js\");\n/* harmony import */ var _toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @toruslabs/http-helpers */ \"./node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js\");\n/* harmony import */ var _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @toruslabs/openlogin-jrpc */ \"./node_modules/@toruslabs/openlogin-jrpc/dist/openloginJrpc.esm.js\");\n/* harmony import */ var eth_rpc_errors__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! eth-rpc-errors */ \"./node_modules/eth-rpc-errors/dist/index.js\");\n/* harmony import */ var is_stream__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! is-stream */ \"./node_modules/@toruslabs/solana-embed/node_modules/is-stream/index.js\");\n/* harmony import */ var pump__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! pump */ \"./node_modules/pump/index.js\");\n/* harmony import */ var pump__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(pump__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! loglevel */ \"./node_modules/loglevel/lib/loglevel.js\");\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(loglevel__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var fast_deep_equal__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! fast-deep-equal */ \"./node_modules/fast-deep-equal/index.js\");\n/* harmony import */ var fast_deep_equal__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(fast_deep_equal__WEBPACK_IMPORTED_MODULE_9__);\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar messages = {\r\n  errors: {\r\n    disconnected: () => \"Torus: Lost connection to Torus.\",\r\n    permanentlyDisconnected: () => \"Torus: Disconnected from iframe. Page reload required.\",\r\n    unsupportedSync: method => \"Torus: The Torus Ethereum provider does not support synchronous methods like \".concat(method, \" without a callback parameter.\"),\r\n    invalidDuplexStream: () => \"Must provide a Node.js-style duplex stream.\",\r\n    invalidOptions: maxEventListeners => \"Invalid options. Received: { maxEventListeners: \".concat(maxEventListeners, \"}\"),\r\n    invalidRequestArgs: () => \"Expected a single, non-array, object argument.\",\r\n    invalidRequestMethod: () => \"'args.method' must be a non-empty string.\",\r\n    invalidRequestParams: () => \"'args.params' must be an object or array if provided.\",\r\n    invalidLoggerObject: () => \"'args.logger' must be an object if provided.\",\r\n    invalidLoggerMethod: method => \"'args.logger' must include required method '\".concat(method, \"'.\")\r\n  },\r\n  info: {\r\n    connected: chainId => \"Torus: Connected to chain with ID \\\"\".concat(chainId, \"\\\".\")\r\n  },\r\n  warnings: {}\r\n};\r\n\r\nconst PAYMENT_PROVIDER = {\r\n  MOONPAY: \"moonpay\",\r\n  WYRE: \"wyre\",\r\n  RAMPNETWORK: \"rampnetwork\",\r\n  XANPOOL: \"xanpool\",\r\n  MERCURYO: \"mercuryo\",\r\n  TRANSAK: \"transak\"\r\n};\r\nconst TORUS_BUILD_ENV = {\r\n  PRODUCTION: \"production\",\r\n  DEVELOPMENT: \"development\",\r\n  TESTING: \"testing\"\r\n};\r\nconst BUTTON_POSITION = {\r\n  BOTTOM_LEFT: \"bottom-left\",\r\n  TOP_LEFT: \"top-left\",\r\n  BOTTOM_RIGHT: \"bottom-right\",\r\n  TOP_RIGHT: \"top-right\"\r\n};\r\nconst LOGIN_PROVIDER = {\r\n  GOOGLE: \"google\",\r\n  FACEBOOK: \"facebook\",\r\n  REDDIT: \"reddit\",\r\n  DISCORD: \"discord\",\r\n  TWITCH: \"twitch\",\r\n  APPLE: \"apple\",\r\n  LINE: \"line\",\r\n  GITHUB: \"github\",\r\n  KAKAO: \"kakao\",\r\n  LINKEDIN: \"linkedin\",\r\n  TWITTER: \"twitter\",\r\n  WEIBO: \"weibo\",\r\n  WECHAT: \"wechat\",\r\n  EMAIL_PASSWORDLESS: \"email_passwordless\"\r\n};\r\n\r\nconst translations = {\r\n  en: {\r\n    embed: {\r\n      continue: \"Continue\",\r\n      actionRequired: \"Authorization required\",\r\n      pendingAction: \"Click continue to proceed with your request in a popup\",\r\n      cookiesRequired: \"Cookies Required\",\r\n      enableCookies: \"Please enable cookies in your browser preferences to access Torus\",\r\n      clickHere: \"More Info\"\r\n    }\r\n  },\r\n  de: {\r\n    embed: {\r\n      continue: \"Fortsetzen\",\r\n      actionRequired: \"Autorisierung erforderlich\",\r\n      pendingAction: \"Klicken Sie in einem Popup auf Weiter, um mit Ihrer Anfrage fortzufahren\",\r\n      cookiesRequired: \"Cookies benötigt\",\r\n      enableCookies: \"Bitte aktivieren Sie Cookies in Ihren Browsereinstellungen, um auf Torus zuzugreifen\",\r\n      clickHere: \"Mehr Info\"\r\n    }\r\n  },\r\n  ja: {\r\n    embed: {\r\n      continue: \"継続する\",\r\n      actionRequired: \"認証が必要です\",\r\n      pendingAction: \"続行をクリックして、ポップアップでリクエストを続行します\",\r\n      cookiesRequired: \"必要なクッキー\",\r\n      enableCookies: \"Torusにアクセスするには、ブラウザの設定でCookieを有効にしてください。\",\r\n      clickHere: \"詳しくは\"\r\n    }\r\n  },\r\n  ko: {\r\n    embed: {\r\n      continue: \"계속하다\",\r\n      actionRequired: \"승인 필요\",\r\n      pendingAction: \"팝업에서 요청을 진행하려면 계속을 클릭하십시오.\",\r\n      cookiesRequired: \"쿠키 필요\",\r\n      enableCookies: \"브라우저 환경 설정에서 쿠키를 활성화하여 Torus에 액세스하십시오.\",\r\n      clickHere: \"더 많은 정보\"\r\n    }\r\n  },\r\n  zh: {\r\n    embed: {\r\n      continue: \"继续\",\r\n      actionRequired: \"需要授权\",\r\n      pendingAction: \"单击继续以在弹出窗口中继续您的请求\",\r\n      cookiesRequired: \"必填Cookie\",\r\n      enableCookies: \"请在您的浏览器首选项中启用cookie以访问Torus。\",\r\n      clickHere: \"更多信息\"\r\n    }\r\n  }\r\n};\r\nvar configuration = {\r\n  supportedVerifierList: [LOGIN_PROVIDER.GOOGLE, LOGIN_PROVIDER.REDDIT, LOGIN_PROVIDER.DISCORD],\r\n  api: \"https://api.tor.us\",\r\n  translations,\r\n  prodTorusUrl: \"\",\r\n  localStorageKey: \"torus-\".concat(window.location.hostname)\r\n};\r\n\r\nvar log = loglevel__WEBPACK_IMPORTED_MODULE_8___default().getLogger(\"solana-embed\");\r\n\r\n/**\r\n * json-rpc-engine middleware that logs RPC errors and and validates req.method.\r\n *\r\n * @param log - The logging API to use.\r\n * @returns  json-rpc-engine middleware function\r\n */\r\n\r\nfunction createErrorMiddleware() {\r\n  return (req, res, next) => {\r\n    // json-rpc-engine will terminate the request when it notices this error\r\n    if (typeof req.method !== \"string\" || !req.method) {\r\n      res.error = eth_rpc_errors__WEBPACK_IMPORTED_MODULE_5__.ethErrors.rpc.invalidRequest({\r\n        message: \"The request 'method' must be a non-empty string.\",\r\n        data: req\r\n      });\r\n    }\r\n\r\n    next(done => {\r\n      const {\r\n        error\r\n      } = res;\r\n\r\n      if (!error) {\r\n        return done();\r\n      }\r\n\r\n      log.error(\"Torus - RPC Error: \".concat(error.message), error);\r\n      return done();\r\n    });\r\n  };\r\n}\r\n/**\r\n * Logs a stream disconnection error. Emits an 'error' if given an\r\n * EventEmitter that has listeners for the 'error' event.\r\n *\r\n * @param log - The logging API to use.\r\n * @param remoteLabel - The label of the disconnected stream.\r\n * @param error - The associated error to log.\r\n * @param emitter - The logging API to use.\r\n */\r\n\r\nfunction logStreamDisconnectWarning(remoteLabel, error, emitter) {\r\n  let warningMsg = \"Torus: Lost connection to \\\"\".concat(remoteLabel, \"\\\".\");\r\n\r\n  if (error !== null && error !== void 0 && error.stack) {\r\n    warningMsg += \"\\n\".concat(error.stack);\r\n  }\r\n\r\n  log.warn(warningMsg);\r\n\r\n  if (emitter && emitter.listenerCount(\"error\") > 0) {\r\n    emitter.emit(\"error\", warningMsg);\r\n  }\r\n}\r\nconst getWindowId = () => Math.random().toString(36).slice(2);\r\nconst getTorusUrl = async buildEnv => {\r\n  let torusUrl;\r\n  let logLevel; // const versionUsed = version;\r\n  // log.info(\"solana embed version used: \", versionUsed);\r\n\r\n  switch (buildEnv) {\r\n    case \"testing\":\r\n      torusUrl = \"https://solana-testing.tor.us\";\r\n      logLevel = \"debug\";\r\n      break;\r\n\r\n    case \"development\":\r\n      torusUrl = \"http://localhost:8080\";\r\n      logLevel = \"debug\";\r\n      break;\r\n\r\n    default:\r\n      torusUrl = \"https://solana.tor.us\";\r\n      logLevel = \"error\";\r\n      break;\r\n  }\r\n\r\n  return {\r\n    torusUrl,\r\n    logLevel\r\n  };\r\n};\r\nconst getUserLanguage = () => {\r\n  let userLanguage = window.navigator.language || \"en-US\";\r\n  const userLanguages = userLanguage.split(\"-\");\r\n  userLanguage = Object.prototype.hasOwnProperty.call(configuration.translations, userLanguages[0]) ? userLanguages[0] : \"en\";\r\n  return userLanguage;\r\n};\r\nconst FEATURES_PROVIDER_CHANGE_WINDOW = {\r\n  height: 660,\r\n  width: 375\r\n};\r\nconst FEATURES_DEFAULT_WALLET_WINDOW = {\r\n  height: 740,\r\n  width: 1315\r\n};\r\nconst FEATURES_DEFAULT_POPUP_WINDOW = {\r\n  height: 700,\r\n  width: 1200\r\n};\r\nconst FEATURES_CONFIRM_WINDOW = {\r\n  height: 600,\r\n  width: 400\r\n};\r\nfunction storageAvailable(type) {\r\n  let storage;\r\n\r\n  try {\r\n    storage = window[type];\r\n    const x = \"__storage_test__\";\r\n    storage.setItem(x, x);\r\n    storage.removeItem(x);\r\n    return true;\r\n  } catch (e) {\r\n    return e && ( // everything except Firefox\r\n    e.code === 22 || // Firefox\r\n    e.code === 1014 || // test name field too, because code might not be present\r\n    // everything except Firefox\r\n    e.name === \"QuotaExceededError\" || // Firefox\r\n    e.name === \"NS_ERROR_DOM_QUOTA_REACHED\") && // acknowledge QuotaExceededError only if there's something already stored\r\n    storage && storage.length !== 0;\r\n  }\r\n}\r\n/**\r\n * popup handler utils\r\n */\r\n\r\nfunction getPopupFeatures(_ref) {\r\n  let {\r\n    width: w,\r\n    height: h\r\n  } = _ref;\r\n  // Fixes dual-screen position                             Most browsers      Firefox\r\n  const dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : window.screenX;\r\n  const dualScreenTop = window.screenTop !== undefined ? window.screenTop : window.screenY;\r\n  const width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : window.screen.width;\r\n  const height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : window.screen.height;\r\n  const systemZoom = 1; // No reliable estimate\r\n\r\n  const left = Math.abs((width - w) / 2 / systemZoom + dualScreenLeft);\r\n  const top = Math.abs((height - h) / 2 / systemZoom + dualScreenTop);\r\n  const features = \"titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=\".concat(h / systemZoom, \",width=\").concat(w / systemZoom, \",top=\").concat(top, \",left=\").concat(left);\r\n  return features;\r\n}\r\nconst getNetworkConfig = label => {\r\n  switch (label) {\r\n    case \"mainnet-beta\":\r\n      return {\r\n        blockExplorerUrl: \"https://explorer.solana.com\",\r\n        chainId: \"0x1\",\r\n        displayName: \"Solana Mainnet\",\r\n        logo: \"solana.svg\",\r\n        rpcTarget: \"https://api.mainnet-beta.solana.com\",\r\n        ticker: \"SOL\",\r\n        tickerName: \"Solana Token\"\r\n      };\r\n\r\n    case \"testnet\":\r\n      return {\r\n        blockExplorerUrl: \"https://explorer.solana.com\",\r\n        chainId: \"0x2\",\r\n        displayName: \"Solana Testnet\",\r\n        logo: \"solana.svg\",\r\n        rpcTarget: \"https://api.testnet.solana.com\",\r\n        ticker: \"SOL\",\r\n        tickerName: \"Solana Token\"\r\n      };\r\n\r\n    case \"devnet\":\r\n      return {\r\n        blockExplorerUrl: \"https://explorer.solana.com\",\r\n        chainId: \"0x3\",\r\n        displayName: \"Solana Devnet\",\r\n        logo: \"solana.svg\",\r\n        rpcTarget: \"https://api.devnet.solana.com\",\r\n        ticker: \"SOL\",\r\n        tickerName: \"Solana Token\"\r\n      };\r\n\r\n    default:\r\n      return undefined;\r\n  }\r\n};\r\n\r\nclass BaseProvider extends _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_4__.SafeEventEmitter {\r\n  /**\r\n   * Indicating that this provider is a Torus provider.\r\n   */\r\n  constructor(connectionStream, _ref) {\r\n    let {\r\n      maxEventListeners = 100,\r\n      jsonRpcStreamName = \"provider\"\r\n    } = _ref;\r\n    super();\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"isTorus\", void 0);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"_rpcEngine\", void 0);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"jsonRpcConnectionEvents\", void 0);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"_state\", void 0);\r\n\r\n    if (!(0,is_stream__WEBPACK_IMPORTED_MODULE_6__.isDuplexStream)(connectionStream)) {\r\n      throw new Error(messages.errors.invalidDuplexStream());\r\n    }\r\n\r\n    this.isTorus = true;\r\n    this.setMaxListeners(maxEventListeners);\r\n    this._handleConnect = this._handleConnect.bind(this);\r\n    this._handleDisconnect = this._handleDisconnect.bind(this);\r\n    this._handleStreamDisconnect = this._handleStreamDisconnect.bind(this);\r\n    this._rpcRequest = this._rpcRequest.bind(this);\r\n    this._initializeState = this._initializeState.bind(this);\r\n    this.request = this.request.bind(this);\r\n    this.sendAsync = this.sendAsync.bind(this); // this.enable = this.enable.bind(this);\r\n    // setup connectionStream multiplexing\r\n\r\n    const mux = new _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_4__.ObjectMultiplex();\r\n    pump__WEBPACK_IMPORTED_MODULE_7___default()(connectionStream, mux, connectionStream, this._handleStreamDisconnect.bind(this, \"Torus\")); // ignore phishing warning message (handled elsewhere)\r\n\r\n    mux.ignoreStream(\"phishing\"); // setup own event listeners\r\n    // connect to async provider\r\n\r\n    const jsonRpcConnection = (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_4__.createStreamMiddleware)();\r\n    pump__WEBPACK_IMPORTED_MODULE_7___default()(jsonRpcConnection.stream, mux.createStream(jsonRpcStreamName), jsonRpcConnection.stream, this._handleStreamDisconnect.bind(this, \"Torus RpcProvider\")); // handle RPC requests via dapp-side rpc engine\r\n\r\n    const rpcEngine = new _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_4__.JRPCEngine();\r\n    rpcEngine.push((0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_4__.createIdRemapMiddleware)());\r\n    rpcEngine.push(createErrorMiddleware());\r\n    rpcEngine.push((0,_toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_2__.createLoggerMiddleware)({\r\n      origin: location.origin\r\n    }));\r\n    rpcEngine.push(jsonRpcConnection.middleware);\r\n    this._rpcEngine = rpcEngine;\r\n    this.jsonRpcConnectionEvents = jsonRpcConnection.events;\r\n  }\r\n  /**\r\n   * Submits an RPC request for the given method, with the given params.\r\n   * Resolves with the result of the method call, or rejects on error.\r\n   */\r\n\r\n\r\n  async request(args) {\r\n    if (!args || typeof args !== \"object\" || Array.isArray(args)) {\r\n      throw eth_rpc_errors__WEBPACK_IMPORTED_MODULE_5__.ethErrors.rpc.invalidRequest({\r\n        message: messages.errors.invalidRequestArgs(),\r\n        data: args\r\n      });\r\n    }\r\n\r\n    const {\r\n      method,\r\n      params\r\n    } = args;\r\n\r\n    if (typeof method !== \"string\" || method.length === 0) {\r\n      throw eth_rpc_errors__WEBPACK_IMPORTED_MODULE_5__.ethErrors.rpc.invalidRequest({\r\n        message: messages.errors.invalidRequestMethod(),\r\n        data: args\r\n      });\r\n    }\r\n\r\n    if (params !== undefined && !Array.isArray(params) && (typeof params !== \"object\" || params === null)) {\r\n      throw eth_rpc_errors__WEBPACK_IMPORTED_MODULE_5__.ethErrors.rpc.invalidRequest({\r\n        message: messages.errors.invalidRequestParams(),\r\n        data: args\r\n      });\r\n    }\r\n\r\n    return new Promise((resolve, reject) => {\r\n      this._rpcRequest({\r\n        method,\r\n        params\r\n      }, (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_4__.getRpcPromiseCallback)(resolve, reject));\r\n    });\r\n  }\r\n  /**\r\n   * Submits an RPC request per the given JSON-RPC request object.\r\n   */\r\n\r\n\r\n  send(payload, callback) {\r\n    this._rpcRequest(payload, callback);\r\n  }\r\n  /**\r\n   * Submits an RPC request per the given JSON-RPC request object.\r\n   */\r\n\r\n\r\n  sendAsync(payload) {\r\n    return new Promise((resolve, reject) => {\r\n      this._rpcRequest(payload, (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_4__.getRpcPromiseCallback)(resolve, reject));\r\n    });\r\n  }\r\n  /**\r\n   * Called when connection is lost to critical streams.\r\n   *\r\n   * emits TorusInpageProvider#disconnect\r\n   */\r\n\r\n\r\n  _handleStreamDisconnect(streamName, error) {\r\n    logStreamDisconnectWarning(streamName, error, this);\r\n\r\n    this._handleDisconnect(false, error ? error.message : undefined);\r\n  }\r\n\r\n}\r\n\r\nconst handleEvent = function (handle, eventName, handler) {\r\n  for (var _len = arguments.length, handlerArgs = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\r\n    handlerArgs[_key - 3] = arguments[_key];\r\n  }\r\n\r\n  const handlerWrapper = () => {\r\n    handler(...handlerArgs);\r\n    handle.removeEventListener(eventName, handlerWrapper);\r\n  };\r\n\r\n  handle.addEventListener(eventName, handlerWrapper);\r\n};\r\nasync function documentReady() {\r\n  return new Promise(resolve => {\r\n    if (document.readyState !== \"loading\") {\r\n      resolve();\r\n    } else {\r\n      handleEvent(document, \"DOMContentLoaded\", resolve);\r\n    }\r\n  });\r\n}\r\nconst htmlToElement = html => {\r\n  const template = window.document.createElement(\"template\");\r\n  const trimmedHtml = html.trim(); // Never return a text node of whitespace as the result\r\n\r\n  template.innerHTML = trimmedHtml;\r\n  return template.content.firstChild;\r\n};\r\n\r\nclass PopupHandler extends _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_4__.SafeEventEmitter {\r\n  constructor(_ref) {\r\n    let {\r\n      url,\r\n      target,\r\n      features\r\n    } = _ref;\r\n    super();\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"url\", void 0);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"target\", void 0);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"features\", void 0);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"window\", void 0);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"windowTimer\", void 0);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"iClosedWindow\", void 0);\r\n\r\n    this.url = url;\r\n    this.target = target || \"_blank\";\r\n    this.features = features || getPopupFeatures(FEATURES_DEFAULT_POPUP_WINDOW);\r\n    this.window = undefined;\r\n    this.windowTimer = undefined;\r\n    this.iClosedWindow = false;\r\n\r\n    this._setupTimer();\r\n  }\r\n\r\n  _setupTimer() {\r\n    this.windowTimer = Number(setInterval(() => {\r\n      if (this.window && this.window.closed) {\r\n        clearInterval(this.windowTimer);\r\n\r\n        if (!this.iClosedWindow) {\r\n          this.emit(\"close\");\r\n        }\r\n\r\n        this.iClosedWindow = false;\r\n        this.window = undefined;\r\n      }\r\n\r\n      if (this.window === undefined) clearInterval(this.windowTimer);\r\n    }, 500));\r\n  }\r\n\r\n  open() {\r\n    var _this$window;\r\n\r\n    this.window = window.open(this.url.href, this.target, this.features);\r\n    if ((_this$window = this.window) !== null && _this$window !== void 0 && _this$window.focus) this.window.focus();\r\n    return Promise.resolve();\r\n  }\r\n\r\n  close() {\r\n    this.iClosedWindow = true;\r\n    if (this.window) this.window.close();\r\n  }\r\n\r\n  redirect(locationReplaceOnRedirect) {\r\n    if (locationReplaceOnRedirect) {\r\n      window.location.replace(this.url.href);\r\n    } else {\r\n      window.location.href = this.url.href;\r\n    }\r\n  }\r\n\r\n}\r\n\r\nfunction ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\r\n\r\nfunction _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\r\n\r\nclass TorusCommunicationProvider extends BaseProvider {\r\n  constructor(connectionStream, _ref) {\r\n    let {\r\n      maxEventListeners = 100,\r\n      jsonRpcStreamName = \"provider\"\r\n    } = _ref;\r\n    super(connectionStream, {\r\n      maxEventListeners,\r\n      jsonRpcStreamName\r\n    }); // private state\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"embedTranslations\", void 0);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"torusUrl\", void 0);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"dappStorageKey\", void 0);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"windowRefs\", void 0);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"tryWindowHandle\", void 0);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"torusAlertContainer\", void 0);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"torusIframe\", void 0);\r\n\r\n    this._state = _objectSpread$2({}, TorusCommunicationProvider._defaultState); // public state\r\n\r\n    this.torusUrl = \"\";\r\n    this.dappStorageKey = \"\";\r\n    const languageTranslations = configuration.translations[getUserLanguage()];\r\n    this.embedTranslations = languageTranslations.embed;\r\n    this.windowRefs = {}; // setup own event listeners\r\n    // EIP-1193 connect\r\n\r\n    this.on(\"connect\", () => {\r\n      this._state.isConnected = true;\r\n    });\r\n\r\n    const notificationHandler = payload => {\r\n      const {\r\n        method,\r\n        params\r\n      } = payload;\r\n\r\n      if (method === _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_2__.COMMUNICATION_NOTIFICATIONS.IFRAME_STATUS) {\r\n        const {\r\n          isFullScreen,\r\n          rid\r\n        } = params;\r\n\r\n        this._displayIframe({\r\n          isFull: isFullScreen,\r\n          rid: rid\r\n        });\r\n      } else if (method === _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_2__.COMMUNICATION_NOTIFICATIONS.CREATE_WINDOW) {\r\n        const {\r\n          windowId,\r\n          url\r\n        } = params;\r\n\r\n        this._createPopupBlockAlert(windowId, url);\r\n      } else if (method === _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_2__.COMMUNICATION_NOTIFICATIONS.CLOSE_WINDOW) {\r\n        this._handleCloseWindow(params);\r\n      } else if (method === _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_2__.COMMUNICATION_NOTIFICATIONS.USER_LOGGED_IN) {\r\n        const {\r\n          currentLoginProvider\r\n        } = params;\r\n        this._state.isLoggedIn = true;\r\n        this._state.currentLoginProvider = currentLoginProvider;\r\n      } else if (method === _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_2__.COMMUNICATION_NOTIFICATIONS.USER_LOGGED_OUT) {\r\n        this._state.isLoggedIn = false;\r\n        this._state.currentLoginProvider = null;\r\n\r\n        this._displayIframe();\r\n      }\r\n    };\r\n\r\n    this.jsonRpcConnectionEvents.on(\"notification\", notificationHandler);\r\n  }\r\n\r\n  get isLoggedIn() {\r\n    return this._state.isLoggedIn;\r\n  }\r\n\r\n  get isIFrameFullScreen() {\r\n    return this._state.isIFrameFullScreen;\r\n  }\r\n  /**\r\n   * Returns whether the inPage provider is connected to Torus.\r\n   */\r\n\r\n\r\n  isConnected() {\r\n    return this._state.isConnected;\r\n  }\r\n\r\n  async _initializeState(params) {\r\n    try {\r\n      const {\r\n        torusUrl,\r\n        dappStorageKey,\r\n        torusAlertContainer,\r\n        torusIframe\r\n      } = params;\r\n      this.torusUrl = torusUrl;\r\n      this.dappStorageKey = dappStorageKey;\r\n      this.torusAlertContainer = torusAlertContainer;\r\n      this.torusIframe = torusIframe;\r\n      this.torusIframe.addEventListener(\"load\", () => {\r\n        // only do this if iframe is not full screen\r\n        if (!this._state.isIFrameFullScreen) this._displayIframe();\r\n      });\r\n      const {\r\n        currentLoginProvider,\r\n        isLoggedIn\r\n      } = await this.request({\r\n        method: _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_2__.COMMUNICATION_JRPC_METHODS.GET_PROVIDER_STATE,\r\n        params: []\r\n      }); // indicate that we've connected, for EIP-1193 compliance\r\n\r\n      this._handleConnect(currentLoginProvider, isLoggedIn);\r\n    } catch (error) {\r\n      log.error(\"Torus: Failed to get initial state. Please report this bug.\", error);\r\n    } finally {\r\n      log.info(\"initialized communication state\");\r\n      this._state.initialized = true;\r\n      this.emit(\"_initialized\");\r\n    }\r\n  }\r\n\r\n  _handleWindow(windowId) {\r\n    let {\r\n      url,\r\n      target,\r\n      features\r\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\r\n    const finalUrl = new URL(url || \"\".concat(this.torusUrl, \"/redirect?windowId=\").concat(windowId));\r\n\r\n    if (this.dappStorageKey) {\r\n      // If multiple instances, it returns the first one\r\n      if (finalUrl.hash) finalUrl.hash += \"&dappStorageKey=\".concat(this.dappStorageKey);else finalUrl.hash = \"#dappStorageKey=\".concat(this.dappStorageKey);\r\n    }\r\n\r\n    const handledWindow = new PopupHandler({\r\n      url: finalUrl,\r\n      target,\r\n      features\r\n    });\r\n    handledWindow.open();\r\n\r\n    if (!handledWindow.window) {\r\n      this._createPopupBlockAlert(windowId, finalUrl.href);\r\n\r\n      return;\r\n    } // Add to collection only if window is opened\r\n\r\n\r\n    this.windowRefs[windowId] = handledWindow; // We tell the iframe that the window has been successfully opened\r\n\r\n    this.request({\r\n      method: _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_2__.COMMUNICATION_JRPC_METHODS.OPENED_WINDOW,\r\n      params: {\r\n        windowId\r\n      }\r\n    });\r\n    handledWindow.once(\"close\", () => {\r\n      // user closed the window\r\n      delete this.windowRefs[windowId];\r\n      this.request({\r\n        method: _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_2__.COMMUNICATION_JRPC_METHODS.CLOSED_WINDOW,\r\n        params: {\r\n          windowId\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  _displayIframe() {\r\n    let {\r\n      isFull = false,\r\n      rid = \"\"\r\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\r\n    const style = {}; // set phase\r\n\r\n    if (!isFull) {\r\n      style.display = this._state.torusWidgetVisibility ? \"block\" : \"none\";\r\n      style.height = \"70px\";\r\n      style.width = \"70px\";\r\n\r\n      switch (this._state.buttonPosition) {\r\n        case BUTTON_POSITION.TOP_LEFT:\r\n          style.top = \"0px\";\r\n          style.left = \"0px\";\r\n          style.right = \"auto\";\r\n          style.bottom = \"auto\";\r\n          break;\r\n\r\n        case BUTTON_POSITION.TOP_RIGHT:\r\n          style.top = \"0px\";\r\n          style.right = \"0px\";\r\n          style.left = \"auto\";\r\n          style.bottom = \"auto\";\r\n          break;\r\n\r\n        case BUTTON_POSITION.BOTTOM_RIGHT:\r\n          style.bottom = \"0px\";\r\n          style.right = \"0px\";\r\n          style.top = \"auto\";\r\n          style.left = \"auto\";\r\n          break;\r\n\r\n        case BUTTON_POSITION.BOTTOM_LEFT:\r\n        default:\r\n          style.bottom = \"0px\";\r\n          style.left = \"0px\";\r\n          style.top = \"auto\";\r\n          style.right = \"auto\";\r\n          break;\r\n      }\r\n    } else {\r\n      style.display = \"block\";\r\n      style.width = \"100%\";\r\n      style.height = \"100%\";\r\n      style.top = \"0px\";\r\n      style.right = \"0px\";\r\n      style.left = \"0px\";\r\n      style.bottom = \"0px\";\r\n    }\r\n\r\n    Object.assign(this.torusIframe.style, style);\r\n    this._state.isIFrameFullScreen = isFull;\r\n    this.request({\r\n      method: _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_2__.COMMUNICATION_JRPC_METHODS.IFRAME_STATUS,\r\n      params: {\r\n        isIFrameFullScreen: isFull,\r\n        rid\r\n      }\r\n    });\r\n  }\r\n\r\n  hideTorusButton() {\r\n    this._state.torusWidgetVisibility = false;\r\n\r\n    this._displayIframe();\r\n  }\r\n\r\n  showTorusButton() {\r\n    this._state.torusWidgetVisibility = true;\r\n\r\n    this._displayIframe();\r\n  }\r\n  /**\r\n   * Internal RPC method. Forwards requests to background via the RPC engine.\r\n   * Also remap ids inbound and outbound\r\n   */\r\n\r\n\r\n  _rpcRequest(payload, callback) {\r\n    const cb = callback;\r\n    const _payload = payload;\r\n\r\n    if (!Array.isArray(_payload)) {\r\n      if (!_payload.jsonrpc) {\r\n        _payload.jsonrpc = \"2.0\";\r\n      }\r\n    }\r\n\r\n    this.tryWindowHandle(_payload, cb);\r\n  }\r\n  /**\r\n   * When the provider becomes connected, updates internal state and emits\r\n   * required events. Idempotent.\r\n   *\r\n   * @param currentLoginProvider - The login Provider\r\n   * emits TorusInpageProvider#connect\r\n   */\r\n\r\n\r\n  _handleConnect(currentLoginProvider, isLoggedIn) {\r\n    if (!this._state.isConnected) {\r\n      this._state.isConnected = true;\r\n      this.emit(\"connect\", {\r\n        currentLoginProvider,\r\n        isLoggedIn\r\n      });\r\n      log.debug(messages.info.connected(currentLoginProvider));\r\n    }\r\n  }\r\n  /**\r\n   * When the provider becomes disconnected, updates internal state and emits\r\n   * required events. Idempotent with respect to the isRecoverable parameter.\r\n   *\r\n   * Error codes per the CloseEvent status codes as required by EIP-1193:\r\n   * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\r\n   *\r\n   * @param isRecoverable - Whether the disconnection is recoverable.\r\n   * @param errorMessage - A custom error message.\r\n   * emits TorusInpageProvider#disconnect\r\n   */\r\n\r\n\r\n  _handleDisconnect(isRecoverable, errorMessage) {\r\n    if (this._state.isConnected || !this._state.isPermanentlyDisconnected && !isRecoverable) {\r\n      this._state.isConnected = false;\r\n      let error;\r\n\r\n      if (isRecoverable) {\r\n        error = new eth_rpc_errors__WEBPACK_IMPORTED_MODULE_5__.EthereumRpcError(1013, // Try again later\r\n        errorMessage || messages.errors.disconnected());\r\n        log.debug(error);\r\n      } else {\r\n        error = new eth_rpc_errors__WEBPACK_IMPORTED_MODULE_5__.EthereumRpcError(1011, // Internal error\r\n        errorMessage || messages.errors.permanentlyDisconnected());\r\n        log.error(error);\r\n        this._state.currentLoginProvider = null;\r\n        this._state.isLoggedIn = false;\r\n        this._state.torusWidgetVisibility = false;\r\n        this._state.isIFrameFullScreen = false;\r\n        this._state.isPermanentlyDisconnected = true;\r\n      }\r\n\r\n      this.emit(\"disconnect\", error);\r\n    }\r\n  } // Called if the iframe wants to close the window cause it is done processing the request\r\n\r\n\r\n  _handleCloseWindow(params) {\r\n    const {\r\n      windowId\r\n    } = params;\r\n\r\n    if (this.windowRefs[windowId]) {\r\n      this.windowRefs[windowId].close();\r\n      delete this.windowRefs[windowId];\r\n    }\r\n  }\r\n\r\n  async _createPopupBlockAlert(windowId, url) {\r\n    const logoUrl = this.getLogoUrl();\r\n    const torusAlert = htmlToElement('<div id=\"torusAlert\" class=\"torus-alert--v2\">' + \"<div id=\\\"torusAlert__logo\\\"><img src=\\\"\".concat(logoUrl, \"\\\" /></div>\") + \"<div>\" + \"<h1 id=\\\"torusAlert__title\\\">\".concat(this.embedTranslations.actionRequired, \"</h1>\") + \"<p id=\\\"torusAlert__desc\\\">\".concat(this.embedTranslations.pendingAction, \"</p>\") + \"</div>\" + \"</div>\");\r\n    const successAlert = htmlToElement(\"<div><a id=\\\"torusAlert__btn\\\">\".concat(this.embedTranslations.continue, \"</a></div>\"));\r\n    const btnContainer = htmlToElement('<div id=\"torusAlert__btn-container\"></div>');\r\n    btnContainer.appendChild(successAlert);\r\n    torusAlert.appendChild(btnContainer);\r\n\r\n    const bindOnLoad = () => {\r\n      successAlert.addEventListener(\"click\", () => {\r\n        this._handleWindow(windowId, {\r\n          url,\r\n          target: \"_blank\",\r\n          features: getPopupFeatures(FEATURES_CONFIRM_WINDOW)\r\n        });\r\n\r\n        torusAlert.remove();\r\n        if (this.torusAlertContainer.children.length === 0) this.torusAlertContainer.style.display = \"none\";\r\n      });\r\n    };\r\n\r\n    const attachOnLoad = () => {\r\n      this.torusAlertContainer.appendChild(torusAlert);\r\n    };\r\n\r\n    await documentReady();\r\n    attachOnLoad();\r\n    bindOnLoad();\r\n    this.torusAlertContainer.style.display = \"block\";\r\n  }\r\n\r\n  getLogoUrl() {\r\n    const logoUrl = \"\".concat(this.torusUrl, \"/images/torus_icon-blue.svg\");\r\n    return logoUrl;\r\n  }\r\n\r\n}\r\n\r\n(0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(TorusCommunicationProvider, \"_defaultState\", {\r\n  buttonPosition: \"bottom-left\",\r\n  currentLoginProvider: null,\r\n  isIFrameFullScreen: false,\r\n  hasEmittedConnection: false,\r\n  torusWidgetVisibility: false,\r\n  initialized: false,\r\n  isLoggedIn: false,\r\n  isPermanentlyDisconnected: false,\r\n  isConnected: false\r\n});\r\n\r\nfunction ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\r\n\r\nfunction _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\r\n\r\nclass TorusInPageProvider extends BaseProvider {\r\n  /**\r\n   * The chain ID of the currently connected Solana chain.\r\n   * See [chainId.network]{@link https://chainid.network} for more information.\r\n   */\r\n\r\n  /**\r\n   * The user's currently selected Solana address.\r\n   * If null, Torus is either locked or the user has not permitted any\r\n   * addresses to be viewed.\r\n   */\r\n  constructor(connectionStream, _ref) {\r\n    let {\r\n      maxEventListeners = 100,\r\n      jsonRpcStreamName = \"provider\"\r\n    } = _ref;\r\n    super(connectionStream, {\r\n      maxEventListeners,\r\n      jsonRpcStreamName\r\n    }); // private state\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"chainId\", void 0);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"selectedAddress\", void 0);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"tryWindowHandle\", void 0);\r\n\r\n    this._state = _objectSpread$1({}, TorusInPageProvider._defaultState); // public state\r\n\r\n    this.selectedAddress = null;\r\n    this.chainId = null;\r\n    this._handleAccountsChanged = this._handleAccountsChanged.bind(this);\r\n    this._handleChainChanged = this._handleChainChanged.bind(this);\r\n    this._handleUnlockStateChanged = this._handleUnlockStateChanged.bind(this); // setup own event listeners\r\n    // EIP-1193 connect\r\n\r\n    this.on(\"connect\", () => {\r\n      this._state.isConnected = true;\r\n    });\r\n\r\n    const jsonRpcNotificationHandler = payload => {\r\n      const {\r\n        method,\r\n        params\r\n      } = payload;\r\n\r\n      if (method === _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_2__.PROVIDER_NOTIFICATIONS.ACCOUNTS_CHANGED) {\r\n        this._handleAccountsChanged(params);\r\n      } else if (method === _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_2__.PROVIDER_NOTIFICATIONS.UNLOCK_STATE_CHANGED) {\r\n        this._handleUnlockStateChanged(params);\r\n      } else if (method === _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_2__.PROVIDER_NOTIFICATIONS.CHAIN_CHANGED) {\r\n        this._handleChainChanged(params);\r\n      }\r\n    }; // json rpc notification listener\r\n\r\n\r\n    this.jsonRpcConnectionEvents.on(\"notification\", jsonRpcNotificationHandler);\r\n  }\r\n  /**\r\n   * Returns whether the inpage provider is connected to Torus.\r\n   */\r\n\r\n\r\n  isConnected() {\r\n    return this._state.isConnected;\r\n  } // Private Methods\r\n  //= ===================\r\n\r\n  /**\r\n   * Constructor helper.\r\n   * Populates initial state by calling 'wallet_getProviderState' and emits\r\n   * necessary events.\r\n   */\r\n\r\n\r\n  async _initializeState() {\r\n    try {\r\n      const {\r\n        accounts,\r\n        chainId,\r\n        isUnlocked\r\n      } = await this.request({\r\n        method: _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_2__.PROVIDER_JRPC_METHODS.GET_PROVIDER_STATE,\r\n        params: []\r\n      }); // indicate that we've connected, for EIP-1193 compliance\r\n\r\n      this.emit(\"connect\", {\r\n        chainId\r\n      });\r\n\r\n      this._handleChainChanged({\r\n        chainId\r\n      });\r\n\r\n      this._handleUnlockStateChanged({\r\n        accounts,\r\n        isUnlocked\r\n      });\r\n\r\n      this._handleAccountsChanged(accounts);\r\n    } catch (error) {\r\n      log.error(\"Torus: Failed to get initial state. Please report this bug.\", error);\r\n    } finally {\r\n      log.info(\"initialized provider state\");\r\n      this._state.initialized = true;\r\n      this.emit(\"_initialized\");\r\n    }\r\n  }\r\n  /**\r\n   * Internal RPC method. Forwards requests to background via the RPC engine.\r\n   * Also remap ids inbound and outbound\r\n   */\r\n\r\n\r\n  _rpcRequest(payload, callback) {\r\n    let isInternal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\r\n    let cb = callback;\r\n    const _payload = payload;\r\n\r\n    if (!Array.isArray(_payload)) {\r\n      if (!_payload.jsonrpc) {\r\n        _payload.jsonrpc = \"2.0\";\r\n      }\r\n\r\n      if (_payload.method === \"solana_accounts\" || _payload.method === \"solana_requestAccounts\") {\r\n        // handle accounts changing\r\n        cb = (err, res) => {\r\n          this._handleAccountsChanged(res.result || [], _payload.method === \"solana_accounts\", isInternal);\r\n\r\n          callback(err, res);\r\n        };\r\n      } else if (_payload.method === \"wallet_getProviderState\") {\r\n        this._rpcEngine.handle(payload, cb);\r\n\r\n        return;\r\n      }\r\n    }\r\n\r\n    this.tryWindowHandle(_payload, cb);\r\n  }\r\n  /**\r\n   * When the provider becomes connected, updates internal state and emits\r\n   * required events. Idempotent.\r\n   *\r\n   * @param chainId - The ID of the newly connected chain.\r\n   * emits TorusInpageProvider#connect\r\n   */\r\n\r\n\r\n  _handleConnect(chainId) {\r\n    if (!this._state.isConnected) {\r\n      this._state.isConnected = true;\r\n      this.emit(\"connect\", {\r\n        chainId\r\n      });\r\n      log.debug(messages.info.connected(chainId));\r\n    }\r\n  }\r\n  /**\r\n   * When the provider becomes disconnected, updates internal state and emits\r\n   * required events. Idempotent with respect to the isRecoverable parameter.\r\n   *\r\n   * Error codes per the CloseEvent status codes as required by EIP-1193:\r\n   * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\r\n   *\r\n   * @param isRecoverable - Whether the disconnection is recoverable.\r\n   * @param errorMessage - A custom error message.\r\n   * emits TorusInpageProvider#disconnect\r\n   */\r\n\r\n\r\n  _handleDisconnect(isRecoverable, errorMessage) {\r\n    if (this._state.isConnected || !this._state.isPermanentlyDisconnected && !isRecoverable) {\r\n      this._state.isConnected = false;\r\n      let error;\r\n\r\n      if (isRecoverable) {\r\n        error = new eth_rpc_errors__WEBPACK_IMPORTED_MODULE_5__.EthereumRpcError(1013, // Try again later\r\n        errorMessage || messages.errors.disconnected());\r\n        log.debug(error);\r\n      } else {\r\n        error = new eth_rpc_errors__WEBPACK_IMPORTED_MODULE_5__.EthereumRpcError(1011, // Internal error\r\n        errorMessage || messages.errors.permanentlyDisconnected());\r\n        log.error(error);\r\n        this.chainId = null;\r\n        this._state.accounts = null;\r\n        this.selectedAddress = null;\r\n        this._state.isUnlocked = false;\r\n        this._state.isPermanentlyDisconnected = true;\r\n      }\r\n\r\n      this.emit(\"disconnect\", error);\r\n    }\r\n  }\r\n  /**\r\n   * Called when accounts may have changed.\r\n   */\r\n\r\n\r\n  _handleAccountsChanged(accounts) {\r\n    let isEthAccounts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\r\n    let isInternal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\r\n    // defensive programming\r\n    let finalAccounts = accounts;\r\n\r\n    if (!Array.isArray(finalAccounts)) {\r\n      log.error(\"Torus: Received non-array accounts parameter. Please report this bug.\", finalAccounts);\r\n      finalAccounts = [];\r\n    }\r\n\r\n    for (const account of accounts) {\r\n      if (typeof account !== \"string\") {\r\n        log.error(\"Torus: Received non-string account. Please report this bug.\", accounts);\r\n        finalAccounts = [];\r\n        break;\r\n      }\r\n    } // emit accountsChanged if anything about the accounts array has changed\r\n\r\n\r\n    if (!fast_deep_equal__WEBPACK_IMPORTED_MODULE_9___default()(this._state.accounts, finalAccounts)) {\r\n      // we should always have the correct accounts even before solana_accounts\r\n      // returns, except in cases where isInternal is true\r\n      if (isEthAccounts && Array.isArray(this._state.accounts) && this._state.accounts.length > 0 && !isInternal) {\r\n        log.error('Torus: \"solana_accounts\" unexpectedly updated accounts. Please report this bug.', finalAccounts);\r\n      }\r\n\r\n      this._state.accounts = finalAccounts;\r\n      this.emit(\"accountsChanged\", finalAccounts);\r\n    } // handle selectedAddress\r\n\r\n\r\n    if (this.selectedAddress !== finalAccounts[0]) {\r\n      this.selectedAddress = finalAccounts[0] || null;\r\n    }\r\n  }\r\n  /**\r\n   * Upon receipt of a new chainId and networkVersion, emits corresponding\r\n   * events and sets relevant public state.\r\n   * Does nothing if neither the chainId nor the networkVersion are different\r\n   * from existing values.\r\n   *\r\n   * emits TorusInpageProvider#chainChanged\r\n   * @param networkInfo - An object with network info.\r\n   */\r\n\r\n\r\n  _handleChainChanged() {\r\n    let {\r\n      chainId\r\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\r\n\r\n    if (!chainId) {\r\n      log.error(\"Torus: Received invalid network parameters. Please report this bug.\", {\r\n        chainId\r\n      });\r\n      return;\r\n    }\r\n\r\n    if (chainId === \"loading\") {\r\n      this._handleDisconnect(true);\r\n    } else {\r\n      this._handleConnect(chainId);\r\n\r\n      if (chainId !== this.chainId) {\r\n        this.chainId = chainId;\r\n\r\n        if (this._state.initialized) {\r\n          this.emit(\"chainChanged\", this.chainId);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * Upon receipt of a new isUnlocked state, sets relevant public state.\r\n   * Calls the accounts changed handler with the received accounts, or an empty\r\n   * array.\r\n   *\r\n   * Does nothing if the received value is equal to the existing value.\r\n   * There are no lock/unlock events.\r\n   *\r\n   * @param opts - Options bag.\r\n   */\r\n\r\n\r\n  _handleUnlockStateChanged() {\r\n    let {\r\n      accounts,\r\n      isUnlocked\r\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\r\n\r\n    if (typeof isUnlocked !== \"boolean\") {\r\n      log.error(\"Torus: Received invalid isUnlocked parameter. Please report this bug.\", {\r\n        isUnlocked\r\n      });\r\n      return;\r\n    }\r\n\r\n    if (isUnlocked !== this._state.isUnlocked) {\r\n      this._state.isUnlocked = isUnlocked;\r\n\r\n      this._handleAccountsChanged(accounts || []);\r\n    }\r\n  }\r\n\r\n}\r\n\r\n(0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(TorusInPageProvider, \"_defaultState\", {\r\n  accounts: null,\r\n  isConnected: false,\r\n  isUnlocked: false,\r\n  initialized: false,\r\n  isPermanentlyDisconnected: false,\r\n  hasEmittedConnection: false\r\n});\r\n\r\n/**\r\n * Returns whether the given image URL exists\r\n */\r\nfunction imgExists(url) {\r\n  return new Promise((resolve, reject) => {\r\n    try {\r\n      const img = document.createElement(\"img\");\r\n\r\n      img.onload = () => resolve(true);\r\n\r\n      img.onerror = () => resolve(false);\r\n\r\n      img.src = url;\r\n    } catch (e) {\r\n      reject(e);\r\n    }\r\n  });\r\n}\r\n/**\r\n * Extracts a name for the site from the DOM\r\n */\r\n\r\n\r\nconst getSiteName = window => {\r\n  const {\r\n    document\r\n  } = window;\r\n  const siteName = document.querySelector('head > meta[property=\"og:site_name\"]');\r\n\r\n  if (siteName) {\r\n    return siteName.content;\r\n  }\r\n\r\n  const metaTitle = document.querySelector('head > meta[name=\"title\"]');\r\n\r\n  if (metaTitle) {\r\n    return metaTitle.content;\r\n  }\r\n\r\n  if (document.title && document.title.length > 0) {\r\n    return document.title;\r\n  }\r\n\r\n  return window.location.hostname;\r\n};\r\n/**\r\n * Extracts an icon for the site from the DOM\r\n */\r\n\r\n\r\nasync function getSiteIcon(window) {\r\n  try {\r\n    const {\r\n      document\r\n    } = window; // Use the site's favicon if it exists\r\n\r\n    let icon = document.querySelector('head > link[rel=\"shortcut icon\"]');\r\n\r\n    if (icon && (await imgExists(icon.href))) {\r\n      return icon.href;\r\n    } // Search through available icons in no particular order\r\n\r\n\r\n    icon = Array.from(document.querySelectorAll('head > link[rel=\"icon\"]')).find(_icon => Boolean(_icon.href));\r\n\r\n    if (icon && (await imgExists(icon.href))) {\r\n      return icon.href;\r\n    }\r\n\r\n    return \"\";\r\n  } catch (error) {\r\n    return \"\";\r\n  }\r\n}\r\n/**\r\n * Gets site metadata and returns it\r\n *\r\n */\r\n\r\n\r\nconst getSiteMetadata = async () => ({\r\n  name: getSiteName(window),\r\n  icon: await getSiteIcon(window)\r\n});\r\n\r\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\r\n\r\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\r\nconst PROVIDER_UNSAFE_METHODS = [\"send_transaction\", \"sign_transaction\", \"sign_all_transactions\", \"sign_message\", \"connect\"];\r\nconst COMMUNICATION_UNSAFE_METHODS = [_toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_2__.COMMUNICATION_JRPC_METHODS.SET_PROVIDER];\r\nconst isLocalStorageAvailable = storageAvailable(\"localStorage\"); // preload for iframe doesn't work https://bugs.chromium.org/p/chromium/issues/detail?id=593267\r\n\r\n(async function preLoadIframe() {\r\n  try {\r\n    if (typeof document === \"undefined\") return;\r\n    const torusIframeHtml = document.createElement(\"link\");\r\n    const {\r\n      torusUrl\r\n    } = await getTorusUrl(\"production\");\r\n    torusIframeHtml.href = \"\".concat(torusUrl, \"/frame\");\r\n    torusIframeHtml.crossOrigin = \"anonymous\";\r\n    torusIframeHtml.type = \"text/html\";\r\n    torusIframeHtml.rel = \"prefetch\";\r\n\r\n    if (torusIframeHtml.relList && torusIframeHtml.relList.supports) {\r\n      if (torusIframeHtml.relList.supports(\"prefetch\")) {\r\n        document.head.appendChild(torusIframeHtml);\r\n      }\r\n    }\r\n  } catch (error) {\r\n    log.warn(error);\r\n  }\r\n})();\r\n\r\nclass Torus {\r\n  constructor() {\r\n    let {\r\n      modalZIndex = 99999\r\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"isInitialized\", void 0);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"torusAlert\", void 0);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"modalZIndex\", void 0);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"alertZIndex\", void 0);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"requestedLoginProvider\", void 0);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"provider\", void 0);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"communicationProvider\", void 0);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"dappStorageKey\", void 0);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"torusAlertContainer\", void 0);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"torusUrl\", void 0);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"torusIframe\", void 0);\r\n\r\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"styleLink\", void 0);\r\n\r\n    this.torusUrl = \"\";\r\n    this.isInitialized = false; // init done\r\n\r\n    this.requestedLoginProvider = null;\r\n    this.modalZIndex = modalZIndex;\r\n    this.alertZIndex = modalZIndex + 1000;\r\n    this.dappStorageKey = \"\";\r\n  }\r\n\r\n  get isLoggedIn() {\r\n    if (!this.communicationProvider) return false;\r\n    return this.communicationProvider.isLoggedIn;\r\n  }\r\n\r\n  async init() {\r\n    let {\r\n      buildEnv = TORUS_BUILD_ENV.PRODUCTION,\r\n      enableLogging = false,\r\n      network,\r\n      showTorusButton = false,\r\n      useLocalStorage = false,\r\n      buttonPosition = BUTTON_POSITION.BOTTOM_LEFT,\r\n      apiKey = \"torus-default\",\r\n      extraParams = {}\r\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\r\n    if (this.isInitialized) throw new Error(\"Already initialized\");\r\n    (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_3__.setAPIKey)(apiKey);\r\n    const {\r\n      torusUrl,\r\n      logLevel\r\n    } = await getTorusUrl(buildEnv);\r\n    log.info(torusUrl, \"url loaded\");\r\n    this.torusUrl = torusUrl;\r\n    log.setDefaultLevel(logLevel);\r\n    if (enableLogging) log.enableAll();else log.disableAll();\r\n    const dappStorageKey = this.handleDappStorageKey(useLocalStorage);\r\n    const torusIframeUrl = new URL(torusUrl);\r\n    if (torusIframeUrl.pathname.endsWith(\"/\")) torusIframeUrl.pathname += \"frame\";else torusIframeUrl.pathname += \"/frame\";\r\n    const hashParams = new URLSearchParams();\r\n    if (dappStorageKey) hashParams.append(\"dappStorageKey\", dappStorageKey);\r\n    hashParams.append(\"origin\", window.location.origin);\r\n    torusIframeUrl.hash = hashParams.toString(); // Iframe code\r\n\r\n    this.torusIframe = htmlToElement(\"<iframe\\n        id=\\\"torusIframe\\\"\\n        class=\\\"torusIframe\\\"\\n        src=\\\"\".concat(torusIframeUrl.href, \"\\\"\\n        style=\\\"display: none; position: fixed; top: 0; right: 0; width: 100%;\\n        height: 100%; border: none; border-radius: 0; z-index: \").concat(this.modalZIndex.toString(), \"\\\"\\n      ></iframe>\"));\r\n    this.torusAlertContainer = htmlToElement(\"<div id=\\\"torusAlertContainer\\\" style=\\\"display:none; z-index: \".concat(this.alertZIndex.toString(), \"\\\"></div>\"));\r\n    this.styleLink = htmlToElement(\"<link href=\\\"\".concat(torusUrl, \"/css/widget.css\\\" rel=\\\"stylesheet\\\" type=\\\"text/css\\\">\"));\r\n\r\n    const handleSetup = async () => {\r\n      return new Promise((resolve, reject) => {\r\n        try {\r\n          window.document.head.appendChild(this.styleLink);\r\n          window.document.body.appendChild(this.torusIframe);\r\n          window.document.body.appendChild(this.torusAlertContainer);\r\n          this.torusIframe.addEventListener(\"load\", async () => {\r\n            const dappMetadata = await getSiteMetadata(); // send init params here\r\n\r\n            this.torusIframe.contentWindow.postMessage({\r\n              buttonPosition,\r\n              apiKey,\r\n              network: typeof network === \"string\" ? getNetworkConfig(network) : network,\r\n              dappMetadata,\r\n              extraParams\r\n            }, torusIframeUrl.origin);\r\n            await this._setupWeb3({\r\n              torusUrl\r\n            });\r\n            if (showTorusButton) this.showTorusButton();else this.hideTorusButton();\r\n            this.isInitialized = true;\r\n            window.torus = this;\r\n            resolve();\r\n          });\r\n        } catch (error) {\r\n          reject(error);\r\n        }\r\n      });\r\n    };\r\n\r\n    await documentReady();\r\n    await handleSetup();\r\n  }\r\n\r\n  async login() {\r\n    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\r\n    if (!this.isInitialized) throw new Error(\"Call init() first\");\r\n\r\n    try {\r\n      this.requestedLoginProvider = params.loginProvider || null;\r\n\r\n      if (!this.requestedLoginProvider) {\r\n        this.communicationProvider._displayIframe({\r\n          isFull: true\r\n        });\r\n      } // If user is already logged in, we assume they have given access to the website\r\n\r\n\r\n      const res = await new Promise((resolve, reject) => {\r\n        // We use this method because we want to update inPage provider state with account info\r\n        this.provider._rpcRequest({\r\n          method: \"solana_requestAccounts\",\r\n          params: [this.requestedLoginProvider, params.login_hint]\r\n        }, (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_4__.getRpcPromiseCallback)(resolve, reject));\r\n      });\r\n\r\n      if (Array.isArray(res) && res.length > 0) {\r\n        return res;\r\n      } // This would never happen, but just in case\r\n\r\n\r\n      throw new Error(\"Login failed\");\r\n    } catch (error) {\r\n      log.error(\"login failed\", error);\r\n      throw error;\r\n    } finally {\r\n      if (this.communicationProvider.isIFrameFullScreen) this.communicationProvider._displayIframe();\r\n    }\r\n  }\r\n\r\n  async logout() {\r\n    if (!this.communicationProvider.isLoggedIn) throw new Error(\"Not logged in\");\r\n    await this.communicationProvider.request({\r\n      method: _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_2__.COMMUNICATION_JRPC_METHODS.LOGOUT,\r\n      params: []\r\n    });\r\n    this.requestedLoginProvider = null;\r\n  }\r\n\r\n  async cleanUp() {\r\n    if (this.communicationProvider.isLoggedIn) {\r\n      await this.logout();\r\n    }\r\n\r\n    this.clearInit();\r\n  }\r\n\r\n  clearInit() {\r\n    function isElement(element) {\r\n      return element instanceof Element || element instanceof Document;\r\n    }\r\n\r\n    if (isElement(this.styleLink) && window.document.body.contains(this.styleLink)) {\r\n      this.styleLink.remove();\r\n      this.styleLink = undefined;\r\n    }\r\n\r\n    if (isElement(this.torusIframe) && window.document.body.contains(this.torusIframe)) {\r\n      this.torusIframe.remove();\r\n      this.torusIframe = undefined;\r\n    }\r\n\r\n    if (isElement(this.torusAlertContainer) && window.document.body.contains(this.torusAlertContainer)) {\r\n      this.torusAlert = undefined;\r\n      this.torusAlertContainer.remove();\r\n      this.torusAlertContainer = undefined;\r\n    }\r\n\r\n    this.isInitialized = false;\r\n  }\r\n\r\n  hideTorusButton() {\r\n    this.communicationProvider.hideTorusButton();\r\n  }\r\n\r\n  showTorusButton() {\r\n    this.communicationProvider.showTorusButton();\r\n  }\r\n\r\n  async setProvider(params) {\r\n    await this.communicationProvider.request({\r\n      method: _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_2__.COMMUNICATION_JRPC_METHODS.SET_PROVIDER,\r\n      params: _objectSpread({}, params)\r\n    });\r\n  }\r\n\r\n  async showWallet(path) {\r\n    let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\r\n    const instanceId = await this.communicationProvider.request({\r\n      method: _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_2__.COMMUNICATION_JRPC_METHODS.WALLET_INSTANCE_ID,\r\n      params: []\r\n    });\r\n    const finalPath = path ? \"/\".concat(path) : \"\";\r\n    const finalUrl = new URL(\"\".concat(this.torusUrl, \"/wallet\").concat(finalPath)); // Using URL constructor to prevent js injection and allow parameter validation.!\r\n\r\n    finalUrl.searchParams.append(\"instanceId\", instanceId);\r\n    Object.keys(params).forEach(x => {\r\n      finalUrl.searchParams.append(x, params[x]);\r\n    });\r\n\r\n    if (this.dappStorageKey) {\r\n      finalUrl.hash = \"#dappStorageKey=\".concat(this.dappStorageKey);\r\n    } // No need to track this window state. Hence, no _handleWindow call.\r\n\r\n\r\n    const walletWindow = new PopupHandler({\r\n      url: finalUrl,\r\n      features: getPopupFeatures(FEATURES_DEFAULT_WALLET_WINDOW)\r\n    });\r\n    walletWindow.open();\r\n  }\r\n\r\n  async getUserInfo() {\r\n    const userInfoResponse = await this.communicationProvider.request({\r\n      method: _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_2__.COMMUNICATION_JRPC_METHODS.USER_INFO,\r\n      params: []\r\n    });\r\n    return userInfoResponse;\r\n  }\r\n\r\n  async initiateTopup(provider, params) {\r\n    if (!this.isInitialized) throw new Error(\"Torus is not initialized\");\r\n    const windowId = getWindowId();\r\n\r\n    this.communicationProvider._handleWindow(windowId);\r\n\r\n    const topupResponse = await this.communicationProvider.request({\r\n      method: _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_2__.COMMUNICATION_JRPC_METHODS.TOPUP,\r\n      params: {\r\n        provider,\r\n        params,\r\n        windowId\r\n      }\r\n    });\r\n    return topupResponse;\r\n  } // Solana specific API\r\n\r\n\r\n  async sendTransaction(transaction) {\r\n    const response = await this.provider.request({\r\n      method: \"send_transaction\",\r\n      // params: { message: transaction.serializeMessage().toString(\"hex\") },\r\n      params: {\r\n        message: transaction.serialize({\r\n          requireAllSignatures: false\r\n        }).toString(\"hex\")\r\n      }\r\n    });\r\n    return response;\r\n  }\r\n\r\n  async signTransaction(transaction) {\r\n    const response = await this.provider.request({\r\n      method: \"sign_transaction\",\r\n      // params: { message: transaction.serializeMessage().toString(\"hex\") },\r\n      params: {\r\n        message: transaction.serialize({\r\n          requireAllSignatures: false\r\n        }).toString(\"hex\")\r\n      }\r\n    });\r\n    const buf = Buffer.from(response, \"hex\");\r\n    const sendTx = _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.Transaction.from(buf);\r\n    return sendTx;\r\n  }\r\n\r\n  async signAllTransactions(transactions) {\r\n    const encodedTransactions = transactions.map(x => x.serialize({\r\n      requireAllSignatures: false\r\n    }).toString(\"hex\"));\r\n    const response = await this.provider.request({\r\n      method: \"sign_all_transactions\",\r\n      params: {\r\n        message: encodedTransactions\r\n      }\r\n    });\r\n    const allSignedTransaction = response.map(msg => _solana_web3_js__WEBPACK_IMPORTED_MODULE_1__.Transaction.from(Buffer.from(msg, \"hex\")));\r\n    return allSignedTransaction;\r\n  }\r\n\r\n  async signMessage(data) {\r\n    const response = await this.provider.request({\r\n      method: \"sign_message\",\r\n      params: {\r\n        data\r\n      }\r\n    });\r\n    return response;\r\n  }\r\n\r\n  async getGaslessPublicKey() {\r\n    const response = await this.provider.request({\r\n      method: \"get_gasless_public_key\",\r\n      params: []\r\n    });\r\n    return response;\r\n  } // async connect(): Promise<boolean> {\r\n  //   const response = (await this.provider.request({\r\n  //     method: \"connect\",\r\n  //     params: {},\r\n  //   })) as boolean;\r\n  //   return response;\r\n  // }\r\n\r\n\r\n  handleDappStorageKey(useLocalStorage) {\r\n    let dappStorageKey = \"\";\r\n\r\n    if (isLocalStorageAvailable && useLocalStorage) {\r\n      const storedKey = window.localStorage.getItem(configuration.localStorageKey);\r\n      if (storedKey) dappStorageKey = storedKey;else {\r\n        const generatedKey = \"torus-app-\".concat(getWindowId());\r\n        window.localStorage.setItem(configuration.localStorageKey, generatedKey);\r\n        dappStorageKey = generatedKey;\r\n      }\r\n    }\r\n\r\n    this.dappStorageKey = dappStorageKey;\r\n    return dappStorageKey;\r\n  }\r\n\r\n  async _setupWeb3(providerParams) {\r\n    log.info(\"setupWeb3 running\"); // setup background connection\r\n\r\n    const providerStream = new _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_4__.BasePostMessageStream({\r\n      name: \"embed_torus\",\r\n      target: \"iframe_torus\",\r\n      targetWindow: this.torusIframe.contentWindow\r\n    }); // We create another LocalMessageDuplexStream for communication between dapp <> iframe\r\n\r\n    const communicationStream = new _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_4__.BasePostMessageStream({\r\n      name: \"embed_communication\",\r\n      target: \"iframe_communication\",\r\n      targetWindow: this.torusIframe.contentWindow\r\n    }); // compose the inPage provider\r\n\r\n    const inPageProvider = new TorusInPageProvider(providerStream, {});\r\n    const communicationProvider = new TorusCommunicationProvider(communicationStream, {});\r\n\r\n    inPageProvider.tryWindowHandle = (payload, cb) => {\r\n      const _payload = payload;\r\n\r\n      if (!Array.isArray(_payload) && PROVIDER_UNSAFE_METHODS.includes(_payload.method)) {\r\n        if (!this.communicationProvider.isLoggedIn) throw new Error(\"User Not Logged In\");\r\n        const windowId = getWindowId();\r\n\r\n        communicationProvider._handleWindow(windowId, {\r\n          target: \"_blank\",\r\n          features: getPopupFeatures(FEATURES_CONFIRM_WINDOW)\r\n        }); // for inPageProvider methods sending windowId in request instead of params\r\n        // as params might be positional.\r\n\r\n\r\n        _payload.windowId = windowId;\r\n      }\r\n\r\n      inPageProvider._rpcEngine.handle(_payload, cb);\r\n    };\r\n\r\n    communicationProvider.tryWindowHandle = (payload, cb) => {\r\n      const _payload = payload;\r\n\r\n      if (!Array.isArray(_payload) && COMMUNICATION_UNSAFE_METHODS.includes(_payload.method)) {\r\n        const windowId = getWindowId();\r\n\r\n        communicationProvider._handleWindow(windowId, {\r\n          target: \"_blank\",\r\n          features: getPopupFeatures(FEATURES_PROVIDER_CHANGE_WINDOW) // todo: are these features generic for all\r\n\r\n        }); // for communication methods sending window id in jrpc req params\r\n\r\n\r\n        _payload.params.windowId = windowId;\r\n      }\r\n\r\n      communicationProvider._rpcEngine.handle(_payload, cb);\r\n    }; // detect solana_requestAccounts and pipe to enable for now\r\n\r\n\r\n    const detectAccountRequestPrototypeModifier = m => {\r\n      const originalMethod = inPageProvider[m]; // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n\r\n      const self = this;\r\n\r\n      inPageProvider[m] = function providerFunc(request, cb) {\r\n        const {\r\n          method,\r\n          params = []\r\n        } = request;\r\n\r\n        if (method === \"solana_requestAccounts\") {\r\n          if (!cb) return self.login({\r\n            loginProvider: params[0]\r\n          });\r\n          self.login({\r\n            loginProvider: params[0]\r\n          }) // eslint-disable-next-line promise/no-callback-in-promise\r\n          .then(res => cb(null, res)) // eslint-disable-next-line promise/no-callback-in-promise\r\n          .catch(err => cb(err));\r\n        }\r\n\r\n        return originalMethod.apply(this, [request, cb]);\r\n      };\r\n    }; // Detects call to solana_requestAccounts in request & sendAsync and passes to login\r\n\r\n\r\n    detectAccountRequestPrototypeModifier(\"request\");\r\n    detectAccountRequestPrototypeModifier(\"sendAsync\");\r\n    detectAccountRequestPrototypeModifier(\"send\");\r\n    const proxiedInPageProvider = new Proxy(inPageProvider, {\r\n      // straight up lie that we deleted the property so that it doesn't\r\n      // throw an error in strict mode\r\n      deleteProperty: () => true\r\n    });\r\n    const proxiedCommunicationProvider = new Proxy(communicationProvider, {\r\n      // straight up lie that we deleted the property so that it doesn't\r\n      // throw an error in strict mode\r\n      deleteProperty: () => true\r\n    });\r\n    this.provider = proxiedInPageProvider;\r\n    this.communicationProvider = proxiedCommunicationProvider;\r\n    await Promise.all([inPageProvider._initializeState(), communicationProvider._initializeState(_objectSpread(_objectSpread({}, providerParams), {}, {\r\n      dappStorageKey: this.dappStorageKey,\r\n      torusAlertContainer: this.torusAlertContainer,\r\n      torusIframe: this.torusIframe\r\n    }))]);\r\n    log.debug(\"Torus - injected provider\");\r\n  }\r\n\r\n}\r\n\r\n\r\n//# sourceMappingURL=solanaEmbed.esm.js.map\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9zb2xhbmEtZW1iZWQvZGlzdC9zb2xhbmFFbWJlZC5lc20uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0U7QUFDdEI7QUFDK0g7QUFDekg7QUFDcUk7QUFDNUg7QUFDbEI7QUFDbkI7QUFDUTtBQUNLO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLGlEQUFpRDtBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHlEQUFrQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0VBQTRCO0FBQzlDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQSwrSEFBK0gscUJBQXFCO0FBQ3BKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3FIO0FBQ3JIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AdG9ydXNsYWJzL3NvbGFuYS1lbWJlZC9kaXN0L3NvbGFuYUVtYmVkLmVzbS5qcz8wMDhiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eSc7XHJcbmltcG9ydCB7IFRyYW5zYWN0aW9uIH0gZnJvbSAnQHNvbGFuYS93ZWIzLmpzJztcclxuaW1wb3J0IHsgY3JlYXRlTG9nZ2VyTWlkZGxld2FyZSwgQ09NTVVOSUNBVElPTl9KUlBDX01FVEhPRFMsIENPTU1VTklDQVRJT05fTk9USUZJQ0FUSU9OUywgUFJPVklERVJfSlJQQ19NRVRIT0RTLCBQUk9WSURFUl9OT1RJRklDQVRJT05TIH0gZnJvbSAnQHRvcnVzbGFicy9iYXNlLWNvbnRyb2xsZXJzJztcclxuaW1wb3J0IHsgc2V0QVBJS2V5IH0gZnJvbSAnQHRvcnVzbGFicy9odHRwLWhlbHBlcnMnO1xyXG5pbXBvcnQgeyBTYWZlRXZlbnRFbWl0dGVyLCBPYmplY3RNdWx0aXBsZXgsIGNyZWF0ZVN0cmVhbU1pZGRsZXdhcmUsIEpSUENFbmdpbmUsIGNyZWF0ZUlkUmVtYXBNaWRkbGV3YXJlLCBnZXRScGNQcm9taXNlQ2FsbGJhY2ssIEJhc2VQb3N0TWVzc2FnZVN0cmVhbSB9IGZyb20gJ0B0b3J1c2xhYnMvb3BlbmxvZ2luLWpycGMnO1xyXG5pbXBvcnQgeyBldGhFcnJvcnMsIEV0aGVyZXVtUnBjRXJyb3IgfSBmcm9tICdldGgtcnBjLWVycm9ycyc7XHJcbmltcG9ydCB7IGlzRHVwbGV4U3RyZWFtIH0gZnJvbSAnaXMtc3RyZWFtJztcclxuaW1wb3J0IHB1bXAgZnJvbSAncHVtcCc7XHJcbmltcG9ydCBsb2dsZXZlbCBmcm9tICdsb2dsZXZlbCc7XHJcbmltcG9ydCBkZXF1YWwgZnJvbSAnZmFzdC1kZWVwLWVxdWFsJztcclxuXHJcbnZhciBtZXNzYWdlcyA9IHtcclxuICBlcnJvcnM6IHtcclxuICAgIGRpc2Nvbm5lY3RlZDogKCkgPT4gXCJUb3J1czogTG9zdCBjb25uZWN0aW9uIHRvIFRvcnVzLlwiLFxyXG4gICAgcGVybWFuZW50bHlEaXNjb25uZWN0ZWQ6ICgpID0+IFwiVG9ydXM6IERpc2Nvbm5lY3RlZCBmcm9tIGlmcmFtZS4gUGFnZSByZWxvYWQgcmVxdWlyZWQuXCIsXHJcbiAgICB1bnN1cHBvcnRlZFN5bmM6IG1ldGhvZCA9PiBcIlRvcnVzOiBUaGUgVG9ydXMgRXRoZXJldW0gcHJvdmlkZXIgZG9lcyBub3Qgc3VwcG9ydCBzeW5jaHJvbm91cyBtZXRob2RzIGxpa2UgXCIuY29uY2F0KG1ldGhvZCwgXCIgd2l0aG91dCBhIGNhbGxiYWNrIHBhcmFtZXRlci5cIiksXHJcbiAgICBpbnZhbGlkRHVwbGV4U3RyZWFtOiAoKSA9PiBcIk11c3QgcHJvdmlkZSBhIE5vZGUuanMtc3R5bGUgZHVwbGV4IHN0cmVhbS5cIixcclxuICAgIGludmFsaWRPcHRpb25zOiBtYXhFdmVudExpc3RlbmVycyA9PiBcIkludmFsaWQgb3B0aW9ucy4gUmVjZWl2ZWQ6IHsgbWF4RXZlbnRMaXN0ZW5lcnM6IFwiLmNvbmNhdChtYXhFdmVudExpc3RlbmVycywgXCJ9XCIpLFxyXG4gICAgaW52YWxpZFJlcXVlc3RBcmdzOiAoKSA9PiBcIkV4cGVjdGVkIGEgc2luZ2xlLCBub24tYXJyYXksIG9iamVjdCBhcmd1bWVudC5cIixcclxuICAgIGludmFsaWRSZXF1ZXN0TWV0aG9kOiAoKSA9PiBcIidhcmdzLm1ldGhvZCcgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcuXCIsXHJcbiAgICBpbnZhbGlkUmVxdWVzdFBhcmFtczogKCkgPT4gXCInYXJncy5wYXJhbXMnIG11c3QgYmUgYW4gb2JqZWN0IG9yIGFycmF5IGlmIHByb3ZpZGVkLlwiLFxyXG4gICAgaW52YWxpZExvZ2dlck9iamVjdDogKCkgPT4gXCInYXJncy5sb2dnZXInIG11c3QgYmUgYW4gb2JqZWN0IGlmIHByb3ZpZGVkLlwiLFxyXG4gICAgaW52YWxpZExvZ2dlck1ldGhvZDogbWV0aG9kID0+IFwiJ2FyZ3MubG9nZ2VyJyBtdXN0IGluY2x1ZGUgcmVxdWlyZWQgbWV0aG9kICdcIi5jb25jYXQobWV0aG9kLCBcIicuXCIpXHJcbiAgfSxcclxuICBpbmZvOiB7XHJcbiAgICBjb25uZWN0ZWQ6IGNoYWluSWQgPT4gXCJUb3J1czogQ29ubmVjdGVkIHRvIGNoYWluIHdpdGggSUQgXFxcIlwiLmNvbmNhdChjaGFpbklkLCBcIlxcXCIuXCIpXHJcbiAgfSxcclxuICB3YXJuaW5nczoge31cclxufTtcclxuXHJcbmNvbnN0IFBBWU1FTlRfUFJPVklERVIgPSB7XHJcbiAgTU9PTlBBWTogXCJtb29ucGF5XCIsXHJcbiAgV1lSRTogXCJ3eXJlXCIsXHJcbiAgUkFNUE5FVFdPUks6IFwicmFtcG5ldHdvcmtcIixcclxuICBYQU5QT09MOiBcInhhbnBvb2xcIixcclxuICBNRVJDVVJZTzogXCJtZXJjdXJ5b1wiLFxyXG4gIFRSQU5TQUs6IFwidHJhbnNha1wiXHJcbn07XHJcbmNvbnN0IFRPUlVTX0JVSUxEX0VOViA9IHtcclxuICBQUk9EVUNUSU9OOiBcInByb2R1Y3Rpb25cIixcclxuICBERVZFTE9QTUVOVDogXCJkZXZlbG9wbWVudFwiLFxyXG4gIFRFU1RJTkc6IFwidGVzdGluZ1wiXHJcbn07XHJcbmNvbnN0IEJVVFRPTl9QT1NJVElPTiA9IHtcclxuICBCT1RUT01fTEVGVDogXCJib3R0b20tbGVmdFwiLFxyXG4gIFRPUF9MRUZUOiBcInRvcC1sZWZ0XCIsXHJcbiAgQk9UVE9NX1JJR0hUOiBcImJvdHRvbS1yaWdodFwiLFxyXG4gIFRPUF9SSUdIVDogXCJ0b3AtcmlnaHRcIlxyXG59O1xyXG5jb25zdCBMT0dJTl9QUk9WSURFUiA9IHtcclxuICBHT09HTEU6IFwiZ29vZ2xlXCIsXHJcbiAgRkFDRUJPT0s6IFwiZmFjZWJvb2tcIixcclxuICBSRURESVQ6IFwicmVkZGl0XCIsXHJcbiAgRElTQ09SRDogXCJkaXNjb3JkXCIsXHJcbiAgVFdJVENIOiBcInR3aXRjaFwiLFxyXG4gIEFQUExFOiBcImFwcGxlXCIsXHJcbiAgTElORTogXCJsaW5lXCIsXHJcbiAgR0lUSFVCOiBcImdpdGh1YlwiLFxyXG4gIEtBS0FPOiBcImtha2FvXCIsXHJcbiAgTElOS0VESU46IFwibGlua2VkaW5cIixcclxuICBUV0lUVEVSOiBcInR3aXR0ZXJcIixcclxuICBXRUlCTzogXCJ3ZWlib1wiLFxyXG4gIFdFQ0hBVDogXCJ3ZWNoYXRcIixcclxuICBFTUFJTF9QQVNTV09SRExFU1M6IFwiZW1haWxfcGFzc3dvcmRsZXNzXCJcclxufTtcclxuXHJcbmNvbnN0IHRyYW5zbGF0aW9ucyA9IHtcclxuICBlbjoge1xyXG4gICAgZW1iZWQ6IHtcclxuICAgICAgY29udGludWU6IFwiQ29udGludWVcIixcclxuICAgICAgYWN0aW9uUmVxdWlyZWQ6IFwiQXV0aG9yaXphdGlvbiByZXF1aXJlZFwiLFxyXG4gICAgICBwZW5kaW5nQWN0aW9uOiBcIkNsaWNrIGNvbnRpbnVlIHRvIHByb2NlZWQgd2l0aCB5b3VyIHJlcXVlc3QgaW4gYSBwb3B1cFwiLFxyXG4gICAgICBjb29raWVzUmVxdWlyZWQ6IFwiQ29va2llcyBSZXF1aXJlZFwiLFxyXG4gICAgICBlbmFibGVDb29raWVzOiBcIlBsZWFzZSBlbmFibGUgY29va2llcyBpbiB5b3VyIGJyb3dzZXIgcHJlZmVyZW5jZXMgdG8gYWNjZXNzIFRvcnVzXCIsXHJcbiAgICAgIGNsaWNrSGVyZTogXCJNb3JlIEluZm9cIlxyXG4gICAgfVxyXG4gIH0sXHJcbiAgZGU6IHtcclxuICAgIGVtYmVkOiB7XHJcbiAgICAgIGNvbnRpbnVlOiBcIkZvcnRzZXR6ZW5cIixcclxuICAgICAgYWN0aW9uUmVxdWlyZWQ6IFwiQXV0b3Jpc2llcnVuZyBlcmZvcmRlcmxpY2hcIixcclxuICAgICAgcGVuZGluZ0FjdGlvbjogXCJLbGlja2VuIFNpZSBpbiBlaW5lbSBQb3B1cCBhdWYgV2VpdGVyLCB1bSBtaXQgSWhyZXIgQW5mcmFnZSBmb3J0enVmYWhyZW5cIixcclxuICAgICAgY29va2llc1JlcXVpcmVkOiBcIkNvb2tpZXMgYmVuw7Z0aWd0XCIsXHJcbiAgICAgIGVuYWJsZUNvb2tpZXM6IFwiQml0dGUgYWt0aXZpZXJlbiBTaWUgQ29va2llcyBpbiBJaHJlbiBCcm93c2VyZWluc3RlbGx1bmdlbiwgdW0gYXVmIFRvcnVzIHp1enVncmVpZmVuXCIsXHJcbiAgICAgIGNsaWNrSGVyZTogXCJNZWhyIEluZm9cIlxyXG4gICAgfVxyXG4gIH0sXHJcbiAgamE6IHtcclxuICAgIGVtYmVkOiB7XHJcbiAgICAgIGNvbnRpbnVlOiBcIue2mee2muOBmeOCi1wiLFxyXG4gICAgICBhY3Rpb25SZXF1aXJlZDogXCLoqo3oqLzjgYzlv4XopoHjgafjgZlcIixcclxuICAgICAgcGVuZGluZ0FjdGlvbjogXCLntprooYzjgpLjgq/jg6rjg4Pjgq/jgZfjgabjgIHjg53jg4Pjg5fjgqLjg4Pjg5fjgafjg6rjgq/jgqjjgrnjg4jjgpLntprooYzjgZfjgb7jgZlcIixcclxuICAgICAgY29va2llc1JlcXVpcmVkOiBcIuW/heimgeOBquOCr+ODg+OCreODvFwiLFxyXG4gICAgICBlbmFibGVDb29raWVzOiBcIlRvcnVz44Gr44Ki44Kv44K744K544GZ44KL44Gr44Gv44CB44OW44Op44Km44K244Gu6Kit5a6a44GnQ29va2ll44KS5pyJ5Yq544Gr44GX44Gm44GP44Gg44GV44GE44CCXCIsXHJcbiAgICAgIGNsaWNrSGVyZTogXCLoqbPjgZfjgY/jga9cIlxyXG4gICAgfVxyXG4gIH0sXHJcbiAga286IHtcclxuICAgIGVtYmVkOiB7XHJcbiAgICAgIGNvbnRpbnVlOiBcIuqzhOyGje2VmOuLpFwiLFxyXG4gICAgICBhY3Rpb25SZXF1aXJlZDogXCLsirnsnbgg7ZWE7JqUXCIsXHJcbiAgICAgIHBlbmRpbmdBY3Rpb246IFwi7Yyd7JeF7JeQ7IScIOyalOyyreydhCDsp4TtlontlZjroKTrqbQg6rOE7IaN7J2EIO2BtOumre2VmOyLreyLnOyYpC5cIixcclxuICAgICAgY29va2llc1JlcXVpcmVkOiBcIuy/oO2CpCDtlYTsmpRcIixcclxuICAgICAgZW5hYmxlQ29va2llczogXCLruIzrnbzsmrDsoIAg7ZmY6rK9IOyEpOygleyXkOyEnCDsv6DtgqTrpbwg7Zmc7ISx7ZmU7ZWY7JesIFRvcnVz7JeQIOyVoeyEuOyKpO2VmOyLreyLnOyYpC5cIixcclxuICAgICAgY2xpY2tIZXJlOiBcIuuNlCDrp47snYAg7KCV67O0XCJcclxuICAgIH1cclxuICB9LFxyXG4gIHpoOiB7XHJcbiAgICBlbWJlZDoge1xyXG4gICAgICBjb250aW51ZTogXCLnu6fnu61cIixcclxuICAgICAgYWN0aW9uUmVxdWlyZWQ6IFwi6ZyA6KaB5o6I5p2DXCIsXHJcbiAgICAgIHBlbmRpbmdBY3Rpb246IFwi5Y2V5Ye757un57ut5Lul5Zyo5by55Ye656qX5Y+j5Lit57un57ut5oKo55qE6K+35rGCXCIsXHJcbiAgICAgIGNvb2tpZXNSZXF1aXJlZDogXCLlv4XloatDb29raWVcIixcclxuICAgICAgZW5hYmxlQ29va2llczogXCLor7flnKjmgqjnmoTmtY/op4jlmajpppbpgInpobnkuK3lkK/nlKhjb29raWXku6Xorr/pl65Ub3J1c+OAglwiLFxyXG4gICAgICBjbGlja0hlcmU6IFwi5pu05aSa5L+h5oGvXCJcclxuICAgIH1cclxuICB9XHJcbn07XHJcbnZhciBjb25maWd1cmF0aW9uID0ge1xyXG4gIHN1cHBvcnRlZFZlcmlmaWVyTGlzdDogW0xPR0lOX1BST1ZJREVSLkdPT0dMRSwgTE9HSU5fUFJPVklERVIuUkVERElULCBMT0dJTl9QUk9WSURFUi5ESVNDT1JEXSxcclxuICBhcGk6IFwiaHR0cHM6Ly9hcGkudG9yLnVzXCIsXHJcbiAgdHJhbnNsYXRpb25zLFxyXG4gIHByb2RUb3J1c1VybDogXCJcIixcclxuICBsb2NhbFN0b3JhZ2VLZXk6IFwidG9ydXMtXCIuY29uY2F0KHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSlcclxufTtcclxuXHJcbnZhciBsb2cgPSBsb2dsZXZlbC5nZXRMb2dnZXIoXCJzb2xhbmEtZW1iZWRcIik7XHJcblxyXG4vKipcclxuICoganNvbi1ycGMtZW5naW5lIG1pZGRsZXdhcmUgdGhhdCBsb2dzIFJQQyBlcnJvcnMgYW5kIGFuZCB2YWxpZGF0ZXMgcmVxLm1ldGhvZC5cclxuICpcclxuICogQHBhcmFtIGxvZyAtIFRoZSBsb2dnaW5nIEFQSSB0byB1c2UuXHJcbiAqIEByZXR1cm5zICBqc29uLXJwYy1lbmdpbmUgbWlkZGxld2FyZSBmdW5jdGlvblxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUVycm9yTWlkZGxld2FyZSgpIHtcclxuICByZXR1cm4gKHJlcSwgcmVzLCBuZXh0KSA9PiB7XHJcbiAgICAvLyBqc29uLXJwYy1lbmdpbmUgd2lsbCB0ZXJtaW5hdGUgdGhlIHJlcXVlc3Qgd2hlbiBpdCBub3RpY2VzIHRoaXMgZXJyb3JcclxuICAgIGlmICh0eXBlb2YgcmVxLm1ldGhvZCAhPT0gXCJzdHJpbmdcIiB8fCAhcmVxLm1ldGhvZCkge1xyXG4gICAgICByZXMuZXJyb3IgPSBldGhFcnJvcnMucnBjLmludmFsaWRSZXF1ZXN0KHtcclxuICAgICAgICBtZXNzYWdlOiBcIlRoZSByZXF1ZXN0ICdtZXRob2QnIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nLlwiLFxyXG4gICAgICAgIGRhdGE6IHJlcVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBuZXh0KGRvbmUgPT4ge1xyXG4gICAgICBjb25zdCB7XHJcbiAgICAgICAgZXJyb3JcclxuICAgICAgfSA9IHJlcztcclxuXHJcbiAgICAgIGlmICghZXJyb3IpIHtcclxuICAgICAgICByZXR1cm4gZG9uZSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBsb2cuZXJyb3IoXCJUb3J1cyAtIFJQQyBFcnJvcjogXCIuY29uY2F0KGVycm9yLm1lc3NhZ2UpLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiBkb25lKCk7XHJcbiAgICB9KTtcclxuICB9O1xyXG59XHJcbi8qKlxyXG4gKiBMb2dzIGEgc3RyZWFtIGRpc2Nvbm5lY3Rpb24gZXJyb3IuIEVtaXRzIGFuICdlcnJvcicgaWYgZ2l2ZW4gYW5cclxuICogRXZlbnRFbWl0dGVyIHRoYXQgaGFzIGxpc3RlbmVycyBmb3IgdGhlICdlcnJvcicgZXZlbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSBsb2cgLSBUaGUgbG9nZ2luZyBBUEkgdG8gdXNlLlxyXG4gKiBAcGFyYW0gcmVtb3RlTGFiZWwgLSBUaGUgbGFiZWwgb2YgdGhlIGRpc2Nvbm5lY3RlZCBzdHJlYW0uXHJcbiAqIEBwYXJhbSBlcnJvciAtIFRoZSBhc3NvY2lhdGVkIGVycm9yIHRvIGxvZy5cclxuICogQHBhcmFtIGVtaXR0ZXIgLSBUaGUgbG9nZ2luZyBBUEkgdG8gdXNlLlxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIGxvZ1N0cmVhbURpc2Nvbm5lY3RXYXJuaW5nKHJlbW90ZUxhYmVsLCBlcnJvciwgZW1pdHRlcikge1xyXG4gIGxldCB3YXJuaW5nTXNnID0gXCJUb3J1czogTG9zdCBjb25uZWN0aW9uIHRvIFxcXCJcIi5jb25jYXQocmVtb3RlTGFiZWwsIFwiXFxcIi5cIik7XHJcblxyXG4gIGlmIChlcnJvciAhPT0gbnVsbCAmJiBlcnJvciAhPT0gdm9pZCAwICYmIGVycm9yLnN0YWNrKSB7XHJcbiAgICB3YXJuaW5nTXNnICs9IFwiXFxuXCIuY29uY2F0KGVycm9yLnN0YWNrKTtcclxuICB9XHJcblxyXG4gIGxvZy53YXJuKHdhcm5pbmdNc2cpO1xyXG5cclxuICBpZiAoZW1pdHRlciAmJiBlbWl0dGVyLmxpc3RlbmVyQ291bnQoXCJlcnJvclwiKSA+IDApIHtcclxuICAgIGVtaXR0ZXIuZW1pdChcImVycm9yXCIsIHdhcm5pbmdNc2cpO1xyXG4gIH1cclxufVxyXG5jb25zdCBnZXRXaW5kb3dJZCA9ICgpID0+IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xyXG5jb25zdCBnZXRUb3J1c1VybCA9IGFzeW5jIGJ1aWxkRW52ID0+IHtcclxuICBsZXQgdG9ydXNVcmw7XHJcbiAgbGV0IGxvZ0xldmVsOyAvLyBjb25zdCB2ZXJzaW9uVXNlZCA9IHZlcnNpb247XHJcbiAgLy8gbG9nLmluZm8oXCJzb2xhbmEgZW1iZWQgdmVyc2lvbiB1c2VkOiBcIiwgdmVyc2lvblVzZWQpO1xyXG5cclxuICBzd2l0Y2ggKGJ1aWxkRW52KSB7XHJcbiAgICBjYXNlIFwidGVzdGluZ1wiOlxyXG4gICAgICB0b3J1c1VybCA9IFwiaHR0cHM6Ly9zb2xhbmEtdGVzdGluZy50b3IudXNcIjtcclxuICAgICAgbG9nTGV2ZWwgPSBcImRlYnVnXCI7XHJcbiAgICAgIGJyZWFrO1xyXG5cclxuICAgIGNhc2UgXCJkZXZlbG9wbWVudFwiOlxyXG4gICAgICB0b3J1c1VybCA9IFwiaHR0cDovL2xvY2FsaG9zdDo4MDgwXCI7XHJcbiAgICAgIGxvZ0xldmVsID0gXCJkZWJ1Z1wiO1xyXG4gICAgICBicmVhaztcclxuXHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICB0b3J1c1VybCA9IFwiaHR0cHM6Ly9zb2xhbmEudG9yLnVzXCI7XHJcbiAgICAgIGxvZ0xldmVsID0gXCJlcnJvclwiO1xyXG4gICAgICBicmVhaztcclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICB0b3J1c1VybCxcclxuICAgIGxvZ0xldmVsXHJcbiAgfTtcclxufTtcclxuY29uc3QgZ2V0VXNlckxhbmd1YWdlID0gKCkgPT4ge1xyXG4gIGxldCB1c2VyTGFuZ3VhZ2UgPSB3aW5kb3cubmF2aWdhdG9yLmxhbmd1YWdlIHx8IFwiZW4tVVNcIjtcclxuICBjb25zdCB1c2VyTGFuZ3VhZ2VzID0gdXNlckxhbmd1YWdlLnNwbGl0KFwiLVwiKTtcclxuICB1c2VyTGFuZ3VhZ2UgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29uZmlndXJhdGlvbi50cmFuc2xhdGlvbnMsIHVzZXJMYW5ndWFnZXNbMF0pID8gdXNlckxhbmd1YWdlc1swXSA6IFwiZW5cIjtcclxuICByZXR1cm4gdXNlckxhbmd1YWdlO1xyXG59O1xyXG5jb25zdCBGRUFUVVJFU19QUk9WSURFUl9DSEFOR0VfV0lORE9XID0ge1xyXG4gIGhlaWdodDogNjYwLFxyXG4gIHdpZHRoOiAzNzVcclxufTtcclxuY29uc3QgRkVBVFVSRVNfREVGQVVMVF9XQUxMRVRfV0lORE9XID0ge1xyXG4gIGhlaWdodDogNzQwLFxyXG4gIHdpZHRoOiAxMzE1XHJcbn07XHJcbmNvbnN0IEZFQVRVUkVTX0RFRkFVTFRfUE9QVVBfV0lORE9XID0ge1xyXG4gIGhlaWdodDogNzAwLFxyXG4gIHdpZHRoOiAxMjAwXHJcbn07XHJcbmNvbnN0IEZFQVRVUkVTX0NPTkZJUk1fV0lORE9XID0ge1xyXG4gIGhlaWdodDogNjAwLFxyXG4gIHdpZHRoOiA0MDBcclxufTtcclxuZnVuY3Rpb24gc3RvcmFnZUF2YWlsYWJsZSh0eXBlKSB7XHJcbiAgbGV0IHN0b3JhZ2U7XHJcblxyXG4gIHRyeSB7XHJcbiAgICBzdG9yYWdlID0gd2luZG93W3R5cGVdO1xyXG4gICAgY29uc3QgeCA9IFwiX19zdG9yYWdlX3Rlc3RfX1wiO1xyXG4gICAgc3RvcmFnZS5zZXRJdGVtKHgsIHgpO1xyXG4gICAgc3RvcmFnZS5yZW1vdmVJdGVtKHgpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgcmV0dXJuIGUgJiYgKCAvLyBldmVyeXRoaW5nIGV4Y2VwdCBGaXJlZm94XHJcbiAgICBlLmNvZGUgPT09IDIyIHx8IC8vIEZpcmVmb3hcclxuICAgIGUuY29kZSA9PT0gMTAxNCB8fCAvLyB0ZXN0IG5hbWUgZmllbGQgdG9vLCBiZWNhdXNlIGNvZGUgbWlnaHQgbm90IGJlIHByZXNlbnRcclxuICAgIC8vIGV2ZXJ5dGhpbmcgZXhjZXB0IEZpcmVmb3hcclxuICAgIGUubmFtZSA9PT0gXCJRdW90YUV4Y2VlZGVkRXJyb3JcIiB8fCAvLyBGaXJlZm94XHJcbiAgICBlLm5hbWUgPT09IFwiTlNfRVJST1JfRE9NX1FVT1RBX1JFQUNIRURcIikgJiYgLy8gYWNrbm93bGVkZ2UgUXVvdGFFeGNlZWRlZEVycm9yIG9ubHkgaWYgdGhlcmUncyBzb21ldGhpbmcgYWxyZWFkeSBzdG9yZWRcclxuICAgIHN0b3JhZ2UgJiYgc3RvcmFnZS5sZW5ndGggIT09IDA7XHJcbiAgfVxyXG59XHJcbi8qKlxyXG4gKiBwb3B1cCBoYW5kbGVyIHV0aWxzXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gZ2V0UG9wdXBGZWF0dXJlcyhfcmVmKSB7XHJcbiAgbGV0IHtcclxuICAgIHdpZHRoOiB3LFxyXG4gICAgaGVpZ2h0OiBoXHJcbiAgfSA9IF9yZWY7XHJcbiAgLy8gRml4ZXMgZHVhbC1zY3JlZW4gcG9zaXRpb24gICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1vc3QgYnJvd3NlcnMgICAgICBGaXJlZm94XHJcbiAgY29uc3QgZHVhbFNjcmVlbkxlZnQgPSB3aW5kb3cuc2NyZWVuTGVmdCAhPT0gdW5kZWZpbmVkID8gd2luZG93LnNjcmVlbkxlZnQgOiB3aW5kb3cuc2NyZWVuWDtcclxuICBjb25zdCBkdWFsU2NyZWVuVG9wID0gd2luZG93LnNjcmVlblRvcCAhPT0gdW5kZWZpbmVkID8gd2luZG93LnNjcmVlblRvcCA6IHdpbmRvdy5zY3JlZW5ZO1xyXG4gIGNvbnN0IHdpZHRoID0gd2luZG93LmlubmVyV2lkdGggPyB3aW5kb3cuaW5uZXJXaWR0aCA6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCA/IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCA6IHdpbmRvdy5zY3JlZW4ud2lkdGg7XHJcbiAgY29uc3QgaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0ID8gd2luZG93LmlubmVySGVpZ2h0IDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCA/IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgOiB3aW5kb3cuc2NyZWVuLmhlaWdodDtcclxuICBjb25zdCBzeXN0ZW1ab29tID0gMTsgLy8gTm8gcmVsaWFibGUgZXN0aW1hdGVcclxuXHJcbiAgY29uc3QgbGVmdCA9IE1hdGguYWJzKCh3aWR0aCAtIHcpIC8gMiAvIHN5c3RlbVpvb20gKyBkdWFsU2NyZWVuTGVmdCk7XHJcbiAgY29uc3QgdG9wID0gTWF0aC5hYnMoKGhlaWdodCAtIGgpIC8gMiAvIHN5c3RlbVpvb20gKyBkdWFsU2NyZWVuVG9wKTtcclxuICBjb25zdCBmZWF0dXJlcyA9IFwidGl0bGViYXI9MCx0b29sYmFyPTAsc3RhdHVzPTAsbG9jYXRpb249MCxtZW51YmFyPTAsaGVpZ2h0PVwiLmNvbmNhdChoIC8gc3lzdGVtWm9vbSwgXCIsd2lkdGg9XCIpLmNvbmNhdCh3IC8gc3lzdGVtWm9vbSwgXCIsdG9wPVwiKS5jb25jYXQodG9wLCBcIixsZWZ0PVwiKS5jb25jYXQobGVmdCk7XHJcbiAgcmV0dXJuIGZlYXR1cmVzO1xyXG59XHJcbmNvbnN0IGdldE5ldHdvcmtDb25maWcgPSBsYWJlbCA9PiB7XHJcbiAgc3dpdGNoIChsYWJlbCkge1xyXG4gICAgY2FzZSBcIm1haW5uZXQtYmV0YVwiOlxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGJsb2NrRXhwbG9yZXJVcmw6IFwiaHR0cHM6Ly9leHBsb3Jlci5zb2xhbmEuY29tXCIsXHJcbiAgICAgICAgY2hhaW5JZDogXCIweDFcIixcclxuICAgICAgICBkaXNwbGF5TmFtZTogXCJTb2xhbmEgTWFpbm5ldFwiLFxyXG4gICAgICAgIGxvZ286IFwic29sYW5hLnN2Z1wiLFxyXG4gICAgICAgIHJwY1RhcmdldDogXCJodHRwczovL2FwaS5tYWlubmV0LWJldGEuc29sYW5hLmNvbVwiLFxyXG4gICAgICAgIHRpY2tlcjogXCJTT0xcIixcclxuICAgICAgICB0aWNrZXJOYW1lOiBcIlNvbGFuYSBUb2tlblwiXHJcbiAgICAgIH07XHJcblxyXG4gICAgY2FzZSBcInRlc3RuZXRcIjpcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBibG9ja0V4cGxvcmVyVXJsOiBcImh0dHBzOi8vZXhwbG9yZXIuc29sYW5hLmNvbVwiLFxyXG4gICAgICAgIGNoYWluSWQ6IFwiMHgyXCIsXHJcbiAgICAgICAgZGlzcGxheU5hbWU6IFwiU29sYW5hIFRlc3RuZXRcIixcclxuICAgICAgICBsb2dvOiBcInNvbGFuYS5zdmdcIixcclxuICAgICAgICBycGNUYXJnZXQ6IFwiaHR0cHM6Ly9hcGkudGVzdG5ldC5zb2xhbmEuY29tXCIsXHJcbiAgICAgICAgdGlja2VyOiBcIlNPTFwiLFxyXG4gICAgICAgIHRpY2tlck5hbWU6IFwiU29sYW5hIFRva2VuXCJcclxuICAgICAgfTtcclxuXHJcbiAgICBjYXNlIFwiZGV2bmV0XCI6XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgYmxvY2tFeHBsb3JlclVybDogXCJodHRwczovL2V4cGxvcmVyLnNvbGFuYS5jb21cIixcclxuICAgICAgICBjaGFpbklkOiBcIjB4M1wiLFxyXG4gICAgICAgIGRpc3BsYXlOYW1lOiBcIlNvbGFuYSBEZXZuZXRcIixcclxuICAgICAgICBsb2dvOiBcInNvbGFuYS5zdmdcIixcclxuICAgICAgICBycGNUYXJnZXQ6IFwiaHR0cHM6Ly9hcGkuZGV2bmV0LnNvbGFuYS5jb21cIixcclxuICAgICAgICB0aWNrZXI6IFwiU09MXCIsXHJcbiAgICAgICAgdGlja2VyTmFtZTogXCJTb2xhbmEgVG9rZW5cIlxyXG4gICAgICB9O1xyXG5cclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgfVxyXG59O1xyXG5cclxuY2xhc3MgQmFzZVByb3ZpZGVyIGV4dGVuZHMgU2FmZUV2ZW50RW1pdHRlciB7XHJcbiAgLyoqXHJcbiAgICogSW5kaWNhdGluZyB0aGF0IHRoaXMgcHJvdmlkZXIgaXMgYSBUb3J1cyBwcm92aWRlci5cclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uU3RyZWFtLCBfcmVmKSB7XHJcbiAgICBsZXQge1xyXG4gICAgICBtYXhFdmVudExpc3RlbmVycyA9IDEwMCxcclxuICAgICAganNvblJwY1N0cmVhbU5hbWUgPSBcInByb3ZpZGVyXCJcclxuICAgIH0gPSBfcmVmO1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpc1RvcnVzXCIsIHZvaWQgMCk7XHJcblxyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3JwY0VuZ2luZVwiLCB2b2lkIDApO1xyXG5cclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImpzb25ScGNDb25uZWN0aW9uRXZlbnRzXCIsIHZvaWQgMCk7XHJcblxyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3N0YXRlXCIsIHZvaWQgMCk7XHJcblxyXG4gICAgaWYgKCFpc0R1cGxleFN0cmVhbShjb25uZWN0aW9uU3RyZWFtKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuZXJyb3JzLmludmFsaWREdXBsZXhTdHJlYW0oKSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5pc1RvcnVzID0gdHJ1ZTtcclxuICAgIHRoaXMuc2V0TWF4TGlzdGVuZXJzKG1heEV2ZW50TGlzdGVuZXJzKTtcclxuICAgIHRoaXMuX2hhbmRsZUNvbm5lY3QgPSB0aGlzLl9oYW5kbGVDb25uZWN0LmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLl9oYW5kbGVEaXNjb25uZWN0ID0gdGhpcy5faGFuZGxlRGlzY29ubmVjdC5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5faGFuZGxlU3RyZWFtRGlzY29ubmVjdCA9IHRoaXMuX2hhbmRsZVN0cmVhbURpc2Nvbm5lY3QuYmluZCh0aGlzKTtcclxuICAgIHRoaXMuX3JwY1JlcXVlc3QgPSB0aGlzLl9ycGNSZXF1ZXN0LmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLl9pbml0aWFsaXplU3RhdGUgPSB0aGlzLl9pbml0aWFsaXplU3RhdGUuYmluZCh0aGlzKTtcclxuICAgIHRoaXMucmVxdWVzdCA9IHRoaXMucmVxdWVzdC5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5zZW5kQXN5bmMgPSB0aGlzLnNlbmRBc3luYy5iaW5kKHRoaXMpOyAvLyB0aGlzLmVuYWJsZSA9IHRoaXMuZW5hYmxlLmJpbmQodGhpcyk7XHJcbiAgICAvLyBzZXR1cCBjb25uZWN0aW9uU3RyZWFtIG11bHRpcGxleGluZ1xyXG5cclxuICAgIGNvbnN0IG11eCA9IG5ldyBPYmplY3RNdWx0aXBsZXgoKTtcclxuICAgIHB1bXAoY29ubmVjdGlvblN0cmVhbSwgbXV4LCBjb25uZWN0aW9uU3RyZWFtLCB0aGlzLl9oYW5kbGVTdHJlYW1EaXNjb25uZWN0LmJpbmQodGhpcywgXCJUb3J1c1wiKSk7IC8vIGlnbm9yZSBwaGlzaGluZyB3YXJuaW5nIG1lc3NhZ2UgKGhhbmRsZWQgZWxzZXdoZXJlKVxyXG5cclxuICAgIG11eC5pZ25vcmVTdHJlYW0oXCJwaGlzaGluZ1wiKTsgLy8gc2V0dXAgb3duIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAgLy8gY29ubmVjdCB0byBhc3luYyBwcm92aWRlclxyXG5cclxuICAgIGNvbnN0IGpzb25ScGNDb25uZWN0aW9uID0gY3JlYXRlU3RyZWFtTWlkZGxld2FyZSgpO1xyXG4gICAgcHVtcChqc29uUnBjQ29ubmVjdGlvbi5zdHJlYW0sIG11eC5jcmVhdGVTdHJlYW0oanNvblJwY1N0cmVhbU5hbWUpLCBqc29uUnBjQ29ubmVjdGlvbi5zdHJlYW0sIHRoaXMuX2hhbmRsZVN0cmVhbURpc2Nvbm5lY3QuYmluZCh0aGlzLCBcIlRvcnVzIFJwY1Byb3ZpZGVyXCIpKTsgLy8gaGFuZGxlIFJQQyByZXF1ZXN0cyB2aWEgZGFwcC1zaWRlIHJwYyBlbmdpbmVcclxuXHJcbiAgICBjb25zdCBycGNFbmdpbmUgPSBuZXcgSlJQQ0VuZ2luZSgpO1xyXG4gICAgcnBjRW5naW5lLnB1c2goY3JlYXRlSWRSZW1hcE1pZGRsZXdhcmUoKSk7XHJcbiAgICBycGNFbmdpbmUucHVzaChjcmVhdGVFcnJvck1pZGRsZXdhcmUoKSk7XHJcbiAgICBycGNFbmdpbmUucHVzaChjcmVhdGVMb2dnZXJNaWRkbGV3YXJlKHtcclxuICAgICAgb3JpZ2luOiBsb2NhdGlvbi5vcmlnaW5cclxuICAgIH0pKTtcclxuICAgIHJwY0VuZ2luZS5wdXNoKGpzb25ScGNDb25uZWN0aW9uLm1pZGRsZXdhcmUpO1xyXG4gICAgdGhpcy5fcnBjRW5naW5lID0gcnBjRW5naW5lO1xyXG4gICAgdGhpcy5qc29uUnBjQ29ubmVjdGlvbkV2ZW50cyA9IGpzb25ScGNDb25uZWN0aW9uLmV2ZW50cztcclxuICB9XHJcbiAgLyoqXHJcbiAgICogU3VibWl0cyBhbiBSUEMgcmVxdWVzdCBmb3IgdGhlIGdpdmVuIG1ldGhvZCwgd2l0aCB0aGUgZ2l2ZW4gcGFyYW1zLlxyXG4gICAqIFJlc29sdmVzIHdpdGggdGhlIHJlc3VsdCBvZiB0aGUgbWV0aG9kIGNhbGwsIG9yIHJlamVjdHMgb24gZXJyb3IuXHJcbiAgICovXHJcblxyXG5cclxuICBhc3luYyByZXF1ZXN0KGFyZ3MpIHtcclxuICAgIGlmICghYXJncyB8fCB0eXBlb2YgYXJncyAhPT0gXCJvYmplY3RcIiB8fCBBcnJheS5pc0FycmF5KGFyZ3MpKSB7XHJcbiAgICAgIHRocm93IGV0aEVycm9ycy5ycGMuaW52YWxpZFJlcXVlc3Qoe1xyXG4gICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VzLmVycm9ycy5pbnZhbGlkUmVxdWVzdEFyZ3MoKSxcclxuICAgICAgICBkYXRhOiBhcmdzXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHtcclxuICAgICAgbWV0aG9kLFxyXG4gICAgICBwYXJhbXNcclxuICAgIH0gPSBhcmdzO1xyXG5cclxuICAgIGlmICh0eXBlb2YgbWV0aG9kICE9PSBcInN0cmluZ1wiIHx8IG1ldGhvZC5sZW5ndGggPT09IDApIHtcclxuICAgICAgdGhyb3cgZXRoRXJyb3JzLnJwYy5pbnZhbGlkUmVxdWVzdCh7XHJcbiAgICAgICAgbWVzc2FnZTogbWVzc2FnZXMuZXJyb3JzLmludmFsaWRSZXF1ZXN0TWV0aG9kKCksXHJcbiAgICAgICAgZGF0YTogYXJnc1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocGFyYW1zICE9PSB1bmRlZmluZWQgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zKSAmJiAodHlwZW9mIHBhcmFtcyAhPT0gXCJvYmplY3RcIiB8fCBwYXJhbXMgPT09IG51bGwpKSB7XHJcbiAgICAgIHRocm93IGV0aEVycm9ycy5ycGMuaW52YWxpZFJlcXVlc3Qoe1xyXG4gICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VzLmVycm9ycy5pbnZhbGlkUmVxdWVzdFBhcmFtcygpLFxyXG4gICAgICAgIGRhdGE6IGFyZ3NcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgdGhpcy5fcnBjUmVxdWVzdCh7XHJcbiAgICAgICAgbWV0aG9kLFxyXG4gICAgICAgIHBhcmFtc1xyXG4gICAgICB9LCBnZXRScGNQcm9taXNlQ2FsbGJhY2socmVzb2x2ZSwgcmVqZWN0KSk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogU3VibWl0cyBhbiBSUEMgcmVxdWVzdCBwZXIgdGhlIGdpdmVuIEpTT04tUlBDIHJlcXVlc3Qgb2JqZWN0LlxyXG4gICAqL1xyXG5cclxuXHJcbiAgc2VuZChwYXlsb2FkLCBjYWxsYmFjaykge1xyXG4gICAgdGhpcy5fcnBjUmVxdWVzdChwYXlsb2FkLCBjYWxsYmFjayk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFN1Ym1pdHMgYW4gUlBDIHJlcXVlc3QgcGVyIHRoZSBnaXZlbiBKU09OLVJQQyByZXF1ZXN0IG9iamVjdC5cclxuICAgKi9cclxuXHJcblxyXG4gIHNlbmRBc3luYyhwYXlsb2FkKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICB0aGlzLl9ycGNSZXF1ZXN0KHBheWxvYWQsIGdldFJwY1Byb21pc2VDYWxsYmFjayhyZXNvbHZlLCByZWplY3QpKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBDYWxsZWQgd2hlbiBjb25uZWN0aW9uIGlzIGxvc3QgdG8gY3JpdGljYWwgc3RyZWFtcy5cclxuICAgKlxyXG4gICAqIGVtaXRzIFRvcnVzSW5wYWdlUHJvdmlkZXIjZGlzY29ubmVjdFxyXG4gICAqL1xyXG5cclxuXHJcbiAgX2hhbmRsZVN0cmVhbURpc2Nvbm5lY3Qoc3RyZWFtTmFtZSwgZXJyb3IpIHtcclxuICAgIGxvZ1N0cmVhbURpc2Nvbm5lY3RXYXJuaW5nKHN0cmVhbU5hbWUsIGVycm9yLCB0aGlzKTtcclxuXHJcbiAgICB0aGlzLl9oYW5kbGVEaXNjb25uZWN0KGZhbHNlLCBlcnJvciA/IGVycm9yLm1lc3NhZ2UgOiB1bmRlZmluZWQpO1xyXG4gIH1cclxuXHJcbn1cclxuXHJcbmNvbnN0IGhhbmRsZUV2ZW50ID0gZnVuY3Rpb24gKGhhbmRsZSwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGhhbmRsZXJBcmdzID0gbmV3IEFycmF5KF9sZW4gPiAzID8gX2xlbiAtIDMgOiAwKSwgX2tleSA9IDM7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcclxuICAgIGhhbmRsZXJBcmdzW19rZXkgLSAzXSA9IGFyZ3VtZW50c1tfa2V5XTtcclxuICB9XHJcblxyXG4gIGNvbnN0IGhhbmRsZXJXcmFwcGVyID0gKCkgPT4ge1xyXG4gICAgaGFuZGxlciguLi5oYW5kbGVyQXJncyk7XHJcbiAgICBoYW5kbGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXJXcmFwcGVyKTtcclxuICB9O1xyXG5cclxuICBoYW5kbGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXJXcmFwcGVyKTtcclxufTtcclxuYXN5bmMgZnVuY3Rpb24gZG9jdW1lbnRSZWFkeSgpIHtcclxuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XHJcbiAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXCJsb2FkaW5nXCIpIHtcclxuICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaGFuZGxlRXZlbnQoZG9jdW1lbnQsIFwiRE9NQ29udGVudExvYWRlZFwiLCByZXNvbHZlKTtcclxuICAgIH1cclxuICB9KTtcclxufVxyXG5jb25zdCBodG1sVG9FbGVtZW50ID0gaHRtbCA9PiB7XHJcbiAgY29uc3QgdGVtcGxhdGUgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpO1xyXG4gIGNvbnN0IHRyaW1tZWRIdG1sID0gaHRtbC50cmltKCk7IC8vIE5ldmVyIHJldHVybiBhIHRleHQgbm9kZSBvZiB3aGl0ZXNwYWNlIGFzIHRoZSByZXN1bHRcclxuXHJcbiAgdGVtcGxhdGUuaW5uZXJIVE1MID0gdHJpbW1lZEh0bWw7XHJcbiAgcmV0dXJuIHRlbXBsYXRlLmNvbnRlbnQuZmlyc3RDaGlsZDtcclxufTtcclxuXHJcbmNsYXNzIFBvcHVwSGFuZGxlciBleHRlbmRzIFNhZmVFdmVudEVtaXR0ZXIge1xyXG4gIGNvbnN0cnVjdG9yKF9yZWYpIHtcclxuICAgIGxldCB7XHJcbiAgICAgIHVybCxcclxuICAgICAgdGFyZ2V0LFxyXG4gICAgICBmZWF0dXJlc1xyXG4gICAgfSA9IF9yZWY7XHJcbiAgICBzdXBlcigpO1xyXG5cclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInVybFwiLCB2b2lkIDApO1xyXG5cclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRhcmdldFwiLCB2b2lkIDApO1xyXG5cclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZlYXR1cmVzXCIsIHZvaWQgMCk7XHJcblxyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwid2luZG93XCIsIHZvaWQgMCk7XHJcblxyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwid2luZG93VGltZXJcIiwgdm9pZCAwKTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpQ2xvc2VkV2luZG93XCIsIHZvaWQgMCk7XHJcblxyXG4gICAgdGhpcy51cmwgPSB1cmw7XHJcbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldCB8fCBcIl9ibGFua1wiO1xyXG4gICAgdGhpcy5mZWF0dXJlcyA9IGZlYXR1cmVzIHx8IGdldFBvcHVwRmVhdHVyZXMoRkVBVFVSRVNfREVGQVVMVF9QT1BVUF9XSU5ET1cpO1xyXG4gICAgdGhpcy53aW5kb3cgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLndpbmRvd1RpbWVyID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5pQ2xvc2VkV2luZG93ID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy5fc2V0dXBUaW1lcigpO1xyXG4gIH1cclxuXHJcbiAgX3NldHVwVGltZXIoKSB7XHJcbiAgICB0aGlzLndpbmRvd1RpbWVyID0gTnVtYmVyKHNldEludGVydmFsKCgpID0+IHtcclxuICAgICAgaWYgKHRoaXMud2luZG93ICYmIHRoaXMud2luZG93LmNsb3NlZCkge1xyXG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy53aW5kb3dUaW1lcik7XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5pQ2xvc2VkV2luZG93KSB7XHJcbiAgICAgICAgICB0aGlzLmVtaXQoXCJjbG9zZVwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuaUNsb3NlZFdpbmRvdyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMud2luZG93ID0gdW5kZWZpbmVkO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGhpcy53aW5kb3cgPT09IHVuZGVmaW5lZCkgY2xlYXJJbnRlcnZhbCh0aGlzLndpbmRvd1RpbWVyKTtcclxuICAgIH0sIDUwMCkpO1xyXG4gIH1cclxuXHJcbiAgb3BlbigpIHtcclxuICAgIHZhciBfdGhpcyR3aW5kb3c7XHJcblxyXG4gICAgdGhpcy53aW5kb3cgPSB3aW5kb3cub3Blbih0aGlzLnVybC5ocmVmLCB0aGlzLnRhcmdldCwgdGhpcy5mZWF0dXJlcyk7XHJcbiAgICBpZiAoKF90aGlzJHdpbmRvdyA9IHRoaXMud2luZG93KSAhPT0gbnVsbCAmJiBfdGhpcyR3aW5kb3cgIT09IHZvaWQgMCAmJiBfdGhpcyR3aW5kb3cuZm9jdXMpIHRoaXMud2luZG93LmZvY3VzKCk7XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgfVxyXG5cclxuICBjbG9zZSgpIHtcclxuICAgIHRoaXMuaUNsb3NlZFdpbmRvdyA9IHRydWU7XHJcbiAgICBpZiAodGhpcy53aW5kb3cpIHRoaXMud2luZG93LmNsb3NlKCk7XHJcbiAgfVxyXG5cclxuICByZWRpcmVjdChsb2NhdGlvblJlcGxhY2VPblJlZGlyZWN0KSB7XHJcbiAgICBpZiAobG9jYXRpb25SZXBsYWNlT25SZWRpcmVjdCkge1xyXG4gICAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZSh0aGlzLnVybC5ocmVmKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdGhpcy51cmwuaHJlZjtcclxuICAgIH1cclxuICB9XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBvd25LZXlzJDIob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XHJcblxyXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDIodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpICUgMiA/IG93bktleXMkMihPYmplY3Qoc291cmNlKSwgITApLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSkgOiBvd25LZXlzJDIoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gcmV0dXJuIHRhcmdldDsgfVxyXG5cclxuY2xhc3MgVG9ydXNDb21tdW5pY2F0aW9uUHJvdmlkZXIgZXh0ZW5kcyBCYXNlUHJvdmlkZXIge1xyXG4gIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb25TdHJlYW0sIF9yZWYpIHtcclxuICAgIGxldCB7XHJcbiAgICAgIG1heEV2ZW50TGlzdGVuZXJzID0gMTAwLFxyXG4gICAgICBqc29uUnBjU3RyZWFtTmFtZSA9IFwicHJvdmlkZXJcIlxyXG4gICAgfSA9IF9yZWY7XHJcbiAgICBzdXBlcihjb25uZWN0aW9uU3RyZWFtLCB7XHJcbiAgICAgIG1heEV2ZW50TGlzdGVuZXJzLFxyXG4gICAgICBqc29uUnBjU3RyZWFtTmFtZVxyXG4gICAgfSk7IC8vIHByaXZhdGUgc3RhdGVcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJlbWJlZFRyYW5zbGF0aW9uc1wiLCB2b2lkIDApO1xyXG5cclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvcnVzVXJsXCIsIHZvaWQgMCk7XHJcblxyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZGFwcFN0b3JhZ2VLZXlcIiwgdm9pZCAwKTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ3aW5kb3dSZWZzXCIsIHZvaWQgMCk7XHJcblxyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidHJ5V2luZG93SGFuZGxlXCIsIHZvaWQgMCk7XHJcblxyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidG9ydXNBbGVydENvbnRhaW5lclwiLCB2b2lkIDApO1xyXG5cclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvcnVzSWZyYW1lXCIsIHZvaWQgMCk7XHJcblxyXG4gICAgdGhpcy5fc3RhdGUgPSBfb2JqZWN0U3ByZWFkJDIoe30sIFRvcnVzQ29tbXVuaWNhdGlvblByb3ZpZGVyLl9kZWZhdWx0U3RhdGUpOyAvLyBwdWJsaWMgc3RhdGVcclxuXHJcbiAgICB0aGlzLnRvcnVzVXJsID0gXCJcIjtcclxuICAgIHRoaXMuZGFwcFN0b3JhZ2VLZXkgPSBcIlwiO1xyXG4gICAgY29uc3QgbGFuZ3VhZ2VUcmFuc2xhdGlvbnMgPSBjb25maWd1cmF0aW9uLnRyYW5zbGF0aW9uc1tnZXRVc2VyTGFuZ3VhZ2UoKV07XHJcbiAgICB0aGlzLmVtYmVkVHJhbnNsYXRpb25zID0gbGFuZ3VhZ2VUcmFuc2xhdGlvbnMuZW1iZWQ7XHJcbiAgICB0aGlzLndpbmRvd1JlZnMgPSB7fTsgLy8gc2V0dXAgb3duIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAgLy8gRUlQLTExOTMgY29ubmVjdFxyXG5cclxuICAgIHRoaXMub24oXCJjb25uZWN0XCIsICgpID0+IHtcclxuICAgICAgdGhpcy5fc3RhdGUuaXNDb25uZWN0ZWQgPSB0cnVlO1xyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3Qgbm90aWZpY2F0aW9uSGFuZGxlciA9IHBheWxvYWQgPT4ge1xyXG4gICAgICBjb25zdCB7XHJcbiAgICAgICAgbWV0aG9kLFxyXG4gICAgICAgIHBhcmFtc1xyXG4gICAgICB9ID0gcGF5bG9hZDtcclxuXHJcbiAgICAgIGlmIChtZXRob2QgPT09IENPTU1VTklDQVRJT05fTk9USUZJQ0FUSU9OUy5JRlJBTUVfU1RBVFVTKSB7XHJcbiAgICAgICAgY29uc3Qge1xyXG4gICAgICAgICAgaXNGdWxsU2NyZWVuLFxyXG4gICAgICAgICAgcmlkXHJcbiAgICAgICAgfSA9IHBhcmFtcztcclxuXHJcbiAgICAgICAgdGhpcy5fZGlzcGxheUlmcmFtZSh7XHJcbiAgICAgICAgICBpc0Z1bGw6IGlzRnVsbFNjcmVlbixcclxuICAgICAgICAgIHJpZDogcmlkXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSBDT01NVU5JQ0FUSU9OX05PVElGSUNBVElPTlMuQ1JFQVRFX1dJTkRPVykge1xyXG4gICAgICAgIGNvbnN0IHtcclxuICAgICAgICAgIHdpbmRvd0lkLFxyXG4gICAgICAgICAgdXJsXHJcbiAgICAgICAgfSA9IHBhcmFtcztcclxuXHJcbiAgICAgICAgdGhpcy5fY3JlYXRlUG9wdXBCbG9ja0FsZXJ0KHdpbmRvd0lkLCB1cmwpO1xyXG4gICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gQ09NTVVOSUNBVElPTl9OT1RJRklDQVRJT05TLkNMT1NFX1dJTkRPVykge1xyXG4gICAgICAgIHRoaXMuX2hhbmRsZUNsb3NlV2luZG93KHBhcmFtcyk7XHJcbiAgICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSBDT01NVU5JQ0FUSU9OX05PVElGSUNBVElPTlMuVVNFUl9MT0dHRURfSU4pIHtcclxuICAgICAgICBjb25zdCB7XHJcbiAgICAgICAgICBjdXJyZW50TG9naW5Qcm92aWRlclxyXG4gICAgICAgIH0gPSBwYXJhbXM7XHJcbiAgICAgICAgdGhpcy5fc3RhdGUuaXNMb2dnZWRJbiA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fc3RhdGUuY3VycmVudExvZ2luUHJvdmlkZXIgPSBjdXJyZW50TG9naW5Qcm92aWRlcjtcclxuICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09IENPTU1VTklDQVRJT05fTk9USUZJQ0FUSU9OUy5VU0VSX0xPR0dFRF9PVVQpIHtcclxuICAgICAgICB0aGlzLl9zdGF0ZS5pc0xvZ2dlZEluID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fc3RhdGUuY3VycmVudExvZ2luUHJvdmlkZXIgPSBudWxsO1xyXG5cclxuICAgICAgICB0aGlzLl9kaXNwbGF5SWZyYW1lKCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5qc29uUnBjQ29ubmVjdGlvbkV2ZW50cy5vbihcIm5vdGlmaWNhdGlvblwiLCBub3RpZmljYXRpb25IYW5kbGVyKTtcclxuICB9XHJcblxyXG4gIGdldCBpc0xvZ2dlZEluKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlLmlzTG9nZ2VkSW47XHJcbiAgfVxyXG5cclxuICBnZXQgaXNJRnJhbWVGdWxsU2NyZWVuKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlLmlzSUZyYW1lRnVsbFNjcmVlbjtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBpblBhZ2UgcHJvdmlkZXIgaXMgY29ubmVjdGVkIHRvIFRvcnVzLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgaXNDb25uZWN0ZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fc3RhdGUuaXNDb25uZWN0ZWQ7XHJcbiAgfVxyXG5cclxuICBhc3luYyBfaW5pdGlhbGl6ZVN0YXRlKHBhcmFtcykge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3Qge1xyXG4gICAgICAgIHRvcnVzVXJsLFxyXG4gICAgICAgIGRhcHBTdG9yYWdlS2V5LFxyXG4gICAgICAgIHRvcnVzQWxlcnRDb250YWluZXIsXHJcbiAgICAgICAgdG9ydXNJZnJhbWVcclxuICAgICAgfSA9IHBhcmFtcztcclxuICAgICAgdGhpcy50b3J1c1VybCA9IHRvcnVzVXJsO1xyXG4gICAgICB0aGlzLmRhcHBTdG9yYWdlS2V5ID0gZGFwcFN0b3JhZ2VLZXk7XHJcbiAgICAgIHRoaXMudG9ydXNBbGVydENvbnRhaW5lciA9IHRvcnVzQWxlcnRDb250YWluZXI7XHJcbiAgICAgIHRoaXMudG9ydXNJZnJhbWUgPSB0b3J1c0lmcmFtZTtcclxuICAgICAgdGhpcy50b3J1c0lmcmFtZS5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCAoKSA9PiB7XHJcbiAgICAgICAgLy8gb25seSBkbyB0aGlzIGlmIGlmcmFtZSBpcyBub3QgZnVsbCBzY3JlZW5cclxuICAgICAgICBpZiAoIXRoaXMuX3N0YXRlLmlzSUZyYW1lRnVsbFNjcmVlbikgdGhpcy5fZGlzcGxheUlmcmFtZSgpO1xyXG4gICAgICB9KTtcclxuICAgICAgY29uc3Qge1xyXG4gICAgICAgIGN1cnJlbnRMb2dpblByb3ZpZGVyLFxyXG4gICAgICAgIGlzTG9nZ2VkSW5cclxuICAgICAgfSA9IGF3YWl0IHRoaXMucmVxdWVzdCh7XHJcbiAgICAgICAgbWV0aG9kOiBDT01NVU5JQ0FUSU9OX0pSUENfTUVUSE9EUy5HRVRfUFJPVklERVJfU1RBVEUsXHJcbiAgICAgICAgcGFyYW1zOiBbXVxyXG4gICAgICB9KTsgLy8gaW5kaWNhdGUgdGhhdCB3ZSd2ZSBjb25uZWN0ZWQsIGZvciBFSVAtMTE5MyBjb21wbGlhbmNlXHJcblxyXG4gICAgICB0aGlzLl9oYW5kbGVDb25uZWN0KGN1cnJlbnRMb2dpblByb3ZpZGVyLCBpc0xvZ2dlZEluKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGxvZy5lcnJvcihcIlRvcnVzOiBGYWlsZWQgdG8gZ2V0IGluaXRpYWwgc3RhdGUuIFBsZWFzZSByZXBvcnQgdGhpcyBidWcuXCIsIGVycm9yKTtcclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIGxvZy5pbmZvKFwiaW5pdGlhbGl6ZWQgY29tbXVuaWNhdGlvbiBzdGF0ZVwiKTtcclxuICAgICAgdGhpcy5fc3RhdGUuaW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgICB0aGlzLmVtaXQoXCJfaW5pdGlhbGl6ZWRcIik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfaGFuZGxlV2luZG93KHdpbmRvd0lkKSB7XHJcbiAgICBsZXQge1xyXG4gICAgICB1cmwsXHJcbiAgICAgIHRhcmdldCxcclxuICAgICAgZmVhdHVyZXNcclxuICAgIH0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xyXG4gICAgY29uc3QgZmluYWxVcmwgPSBuZXcgVVJMKHVybCB8fCBcIlwiLmNvbmNhdCh0aGlzLnRvcnVzVXJsLCBcIi9yZWRpcmVjdD93aW5kb3dJZD1cIikuY29uY2F0KHdpbmRvd0lkKSk7XHJcblxyXG4gICAgaWYgKHRoaXMuZGFwcFN0b3JhZ2VLZXkpIHtcclxuICAgICAgLy8gSWYgbXVsdGlwbGUgaW5zdGFuY2VzLCBpdCByZXR1cm5zIHRoZSBmaXJzdCBvbmVcclxuICAgICAgaWYgKGZpbmFsVXJsLmhhc2gpIGZpbmFsVXJsLmhhc2ggKz0gXCImZGFwcFN0b3JhZ2VLZXk9XCIuY29uY2F0KHRoaXMuZGFwcFN0b3JhZ2VLZXkpO2Vsc2UgZmluYWxVcmwuaGFzaCA9IFwiI2RhcHBTdG9yYWdlS2V5PVwiLmNvbmNhdCh0aGlzLmRhcHBTdG9yYWdlS2V5KTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBoYW5kbGVkV2luZG93ID0gbmV3IFBvcHVwSGFuZGxlcih7XHJcbiAgICAgIHVybDogZmluYWxVcmwsXHJcbiAgICAgIHRhcmdldCxcclxuICAgICAgZmVhdHVyZXNcclxuICAgIH0pO1xyXG4gICAgaGFuZGxlZFdpbmRvdy5vcGVuKCk7XHJcblxyXG4gICAgaWYgKCFoYW5kbGVkV2luZG93LndpbmRvdykge1xyXG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cEJsb2NrQWxlcnQod2luZG93SWQsIGZpbmFsVXJsLmhyZWYpO1xyXG5cclxuICAgICAgcmV0dXJuO1xyXG4gICAgfSAvLyBBZGQgdG8gY29sbGVjdGlvbiBvbmx5IGlmIHdpbmRvdyBpcyBvcGVuZWRcclxuXHJcblxyXG4gICAgdGhpcy53aW5kb3dSZWZzW3dpbmRvd0lkXSA9IGhhbmRsZWRXaW5kb3c7IC8vIFdlIHRlbGwgdGhlIGlmcmFtZSB0aGF0IHRoZSB3aW5kb3cgaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IG9wZW5lZFxyXG5cclxuICAgIHRoaXMucmVxdWVzdCh7XHJcbiAgICAgIG1ldGhvZDogQ09NTVVOSUNBVElPTl9KUlBDX01FVEhPRFMuT1BFTkVEX1dJTkRPVyxcclxuICAgICAgcGFyYW1zOiB7XHJcbiAgICAgICAgd2luZG93SWRcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBoYW5kbGVkV2luZG93Lm9uY2UoXCJjbG9zZVwiLCAoKSA9PiB7XHJcbiAgICAgIC8vIHVzZXIgY2xvc2VkIHRoZSB3aW5kb3dcclxuICAgICAgZGVsZXRlIHRoaXMud2luZG93UmVmc1t3aW5kb3dJZF07XHJcbiAgICAgIHRoaXMucmVxdWVzdCh7XHJcbiAgICAgICAgbWV0aG9kOiBDT01NVU5JQ0FUSU9OX0pSUENfTUVUSE9EUy5DTE9TRURfV0lORE9XLFxyXG4gICAgICAgIHBhcmFtczoge1xyXG4gICAgICAgICAgd2luZG93SWRcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBfZGlzcGxheUlmcmFtZSgpIHtcclxuICAgIGxldCB7XHJcbiAgICAgIGlzRnVsbCA9IGZhbHNlLFxyXG4gICAgICByaWQgPSBcIlwiXHJcbiAgICB9ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcclxuICAgIGNvbnN0IHN0eWxlID0ge307IC8vIHNldCBwaGFzZVxyXG5cclxuICAgIGlmICghaXNGdWxsKSB7XHJcbiAgICAgIHN0eWxlLmRpc3BsYXkgPSB0aGlzLl9zdGF0ZS50b3J1c1dpZGdldFZpc2liaWxpdHkgPyBcImJsb2NrXCIgOiBcIm5vbmVcIjtcclxuICAgICAgc3R5bGUuaGVpZ2h0ID0gXCI3MHB4XCI7XHJcbiAgICAgIHN0eWxlLndpZHRoID0gXCI3MHB4XCI7XHJcblxyXG4gICAgICBzd2l0Y2ggKHRoaXMuX3N0YXRlLmJ1dHRvblBvc2l0aW9uKSB7XHJcbiAgICAgICAgY2FzZSBCVVRUT05fUE9TSVRJT04uVE9QX0xFRlQ6XHJcbiAgICAgICAgICBzdHlsZS50b3AgPSBcIjBweFwiO1xyXG4gICAgICAgICAgc3R5bGUubGVmdCA9IFwiMHB4XCI7XHJcbiAgICAgICAgICBzdHlsZS5yaWdodCA9IFwiYXV0b1wiO1xyXG4gICAgICAgICAgc3R5bGUuYm90dG9tID0gXCJhdXRvXCI7XHJcbiAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSBCVVRUT05fUE9TSVRJT04uVE9QX1JJR0hUOlxyXG4gICAgICAgICAgc3R5bGUudG9wID0gXCIwcHhcIjtcclxuICAgICAgICAgIHN0eWxlLnJpZ2h0ID0gXCIwcHhcIjtcclxuICAgICAgICAgIHN0eWxlLmxlZnQgPSBcImF1dG9cIjtcclxuICAgICAgICAgIHN0eWxlLmJvdHRvbSA9IFwiYXV0b1wiO1xyXG4gICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgQlVUVE9OX1BPU0lUSU9OLkJPVFRPTV9SSUdIVDpcclxuICAgICAgICAgIHN0eWxlLmJvdHRvbSA9IFwiMHB4XCI7XHJcbiAgICAgICAgICBzdHlsZS5yaWdodCA9IFwiMHB4XCI7XHJcbiAgICAgICAgICBzdHlsZS50b3AgPSBcImF1dG9cIjtcclxuICAgICAgICAgIHN0eWxlLmxlZnQgPSBcImF1dG9cIjtcclxuICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIEJVVFRPTl9QT1NJVElPTi5CT1RUT01fTEVGVDpcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgc3R5bGUuYm90dG9tID0gXCIwcHhcIjtcclxuICAgICAgICAgIHN0eWxlLmxlZnQgPSBcIjBweFwiO1xyXG4gICAgICAgICAgc3R5bGUudG9wID0gXCJhdXRvXCI7XHJcbiAgICAgICAgICBzdHlsZS5yaWdodCA9IFwiYXV0b1wiO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XHJcbiAgICAgIHN0eWxlLndpZHRoID0gXCIxMDAlXCI7XHJcbiAgICAgIHN0eWxlLmhlaWdodCA9IFwiMTAwJVwiO1xyXG4gICAgICBzdHlsZS50b3AgPSBcIjBweFwiO1xyXG4gICAgICBzdHlsZS5yaWdodCA9IFwiMHB4XCI7XHJcbiAgICAgIHN0eWxlLmxlZnQgPSBcIjBweFwiO1xyXG4gICAgICBzdHlsZS5ib3R0b20gPSBcIjBweFwiO1xyXG4gICAgfVxyXG5cclxuICAgIE9iamVjdC5hc3NpZ24odGhpcy50b3J1c0lmcmFtZS5zdHlsZSwgc3R5bGUpO1xyXG4gICAgdGhpcy5fc3RhdGUuaXNJRnJhbWVGdWxsU2NyZWVuID0gaXNGdWxsO1xyXG4gICAgdGhpcy5yZXF1ZXN0KHtcclxuICAgICAgbWV0aG9kOiBDT01NVU5JQ0FUSU9OX0pSUENfTUVUSE9EUy5JRlJBTUVfU1RBVFVTLFxyXG4gICAgICBwYXJhbXM6IHtcclxuICAgICAgICBpc0lGcmFtZUZ1bGxTY3JlZW46IGlzRnVsbCxcclxuICAgICAgICByaWRcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBoaWRlVG9ydXNCdXR0b24oKSB7XHJcbiAgICB0aGlzLl9zdGF0ZS50b3J1c1dpZGdldFZpc2liaWxpdHkgPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzLl9kaXNwbGF5SWZyYW1lKCk7XHJcbiAgfVxyXG5cclxuICBzaG93VG9ydXNCdXR0b24oKSB7XHJcbiAgICB0aGlzLl9zdGF0ZS50b3J1c1dpZGdldFZpc2liaWxpdHkgPSB0cnVlO1xyXG5cclxuICAgIHRoaXMuX2Rpc3BsYXlJZnJhbWUoKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogSW50ZXJuYWwgUlBDIG1ldGhvZC4gRm9yd2FyZHMgcmVxdWVzdHMgdG8gYmFja2dyb3VuZCB2aWEgdGhlIFJQQyBlbmdpbmUuXHJcbiAgICogQWxzbyByZW1hcCBpZHMgaW5ib3VuZCBhbmQgb3V0Ym91bmRcclxuICAgKi9cclxuXHJcblxyXG4gIF9ycGNSZXF1ZXN0KHBheWxvYWQsIGNhbGxiYWNrKSB7XHJcbiAgICBjb25zdCBjYiA9IGNhbGxiYWNrO1xyXG4gICAgY29uc3QgX3BheWxvYWQgPSBwYXlsb2FkO1xyXG5cclxuICAgIGlmICghQXJyYXkuaXNBcnJheShfcGF5bG9hZCkpIHtcclxuICAgICAgaWYgKCFfcGF5bG9hZC5qc29ucnBjKSB7XHJcbiAgICAgICAgX3BheWxvYWQuanNvbnJwYyA9IFwiMi4wXCI7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnRyeVdpbmRvd0hhbmRsZShfcGF5bG9hZCwgY2IpO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBXaGVuIHRoZSBwcm92aWRlciBiZWNvbWVzIGNvbm5lY3RlZCwgdXBkYXRlcyBpbnRlcm5hbCBzdGF0ZSBhbmQgZW1pdHNcclxuICAgKiByZXF1aXJlZCBldmVudHMuIElkZW1wb3RlbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gY3VycmVudExvZ2luUHJvdmlkZXIgLSBUaGUgbG9naW4gUHJvdmlkZXJcclxuICAgKiBlbWl0cyBUb3J1c0lucGFnZVByb3ZpZGVyI2Nvbm5lY3RcclxuICAgKi9cclxuXHJcblxyXG4gIF9oYW5kbGVDb25uZWN0KGN1cnJlbnRMb2dpblByb3ZpZGVyLCBpc0xvZ2dlZEluKSB7XHJcbiAgICBpZiAoIXRoaXMuX3N0YXRlLmlzQ29ubmVjdGVkKSB7XHJcbiAgICAgIHRoaXMuX3N0YXRlLmlzQ29ubmVjdGVkID0gdHJ1ZTtcclxuICAgICAgdGhpcy5lbWl0KFwiY29ubmVjdFwiLCB7XHJcbiAgICAgICAgY3VycmVudExvZ2luUHJvdmlkZXIsXHJcbiAgICAgICAgaXNMb2dnZWRJblxyXG4gICAgICB9KTtcclxuICAgICAgbG9nLmRlYnVnKG1lc3NhZ2VzLmluZm8uY29ubmVjdGVkKGN1cnJlbnRMb2dpblByb3ZpZGVyKSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFdoZW4gdGhlIHByb3ZpZGVyIGJlY29tZXMgZGlzY29ubmVjdGVkLCB1cGRhdGVzIGludGVybmFsIHN0YXRlIGFuZCBlbWl0c1xyXG4gICAqIHJlcXVpcmVkIGV2ZW50cy4gSWRlbXBvdGVudCB3aXRoIHJlc3BlY3QgdG8gdGhlIGlzUmVjb3ZlcmFibGUgcGFyYW1ldGVyLlxyXG4gICAqXHJcbiAgICogRXJyb3IgY29kZXMgcGVyIHRoZSBDbG9zZUV2ZW50IHN0YXR1cyBjb2RlcyBhcyByZXF1aXJlZCBieSBFSVAtMTE5MzpcclxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2xvc2VFdmVudCNTdGF0dXNfY29kZXNcclxuICAgKlxyXG4gICAqIEBwYXJhbSBpc1JlY292ZXJhYmxlIC0gV2hldGhlciB0aGUgZGlzY29ubmVjdGlvbiBpcyByZWNvdmVyYWJsZS5cclxuICAgKiBAcGFyYW0gZXJyb3JNZXNzYWdlIC0gQSBjdXN0b20gZXJyb3IgbWVzc2FnZS5cclxuICAgKiBlbWl0cyBUb3J1c0lucGFnZVByb3ZpZGVyI2Rpc2Nvbm5lY3RcclxuICAgKi9cclxuXHJcblxyXG4gIF9oYW5kbGVEaXNjb25uZWN0KGlzUmVjb3ZlcmFibGUsIGVycm9yTWVzc2FnZSkge1xyXG4gICAgaWYgKHRoaXMuX3N0YXRlLmlzQ29ubmVjdGVkIHx8ICF0aGlzLl9zdGF0ZS5pc1Blcm1hbmVudGx5RGlzY29ubmVjdGVkICYmICFpc1JlY292ZXJhYmxlKSB7XHJcbiAgICAgIHRoaXMuX3N0YXRlLmlzQ29ubmVjdGVkID0gZmFsc2U7XHJcbiAgICAgIGxldCBlcnJvcjtcclxuXHJcbiAgICAgIGlmIChpc1JlY292ZXJhYmxlKSB7XHJcbiAgICAgICAgZXJyb3IgPSBuZXcgRXRoZXJldW1ScGNFcnJvcigxMDEzLCAvLyBUcnkgYWdhaW4gbGF0ZXJcclxuICAgICAgICBlcnJvck1lc3NhZ2UgfHwgbWVzc2FnZXMuZXJyb3JzLmRpc2Nvbm5lY3RlZCgpKTtcclxuICAgICAgICBsb2cuZGVidWcoZXJyb3IpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGVycm9yID0gbmV3IEV0aGVyZXVtUnBjRXJyb3IoMTAxMSwgLy8gSW50ZXJuYWwgZXJyb3JcclxuICAgICAgICBlcnJvck1lc3NhZ2UgfHwgbWVzc2FnZXMuZXJyb3JzLnBlcm1hbmVudGx5RGlzY29ubmVjdGVkKCkpO1xyXG4gICAgICAgIGxvZy5lcnJvcihlcnJvcik7XHJcbiAgICAgICAgdGhpcy5fc3RhdGUuY3VycmVudExvZ2luUHJvdmlkZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3N0YXRlLmlzTG9nZ2VkSW4gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9zdGF0ZS50b3J1c1dpZGdldFZpc2liaWxpdHkgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9zdGF0ZS5pc0lGcmFtZUZ1bGxTY3JlZW4gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9zdGF0ZS5pc1Blcm1hbmVudGx5RGlzY29ubmVjdGVkID0gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5lbWl0KFwiZGlzY29ubmVjdFwiLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgfSAvLyBDYWxsZWQgaWYgdGhlIGlmcmFtZSB3YW50cyB0byBjbG9zZSB0aGUgd2luZG93IGNhdXNlIGl0IGlzIGRvbmUgcHJvY2Vzc2luZyB0aGUgcmVxdWVzdFxyXG5cclxuXHJcbiAgX2hhbmRsZUNsb3NlV2luZG93KHBhcmFtcykge1xyXG4gICAgY29uc3Qge1xyXG4gICAgICB3aW5kb3dJZFxyXG4gICAgfSA9IHBhcmFtcztcclxuXHJcbiAgICBpZiAodGhpcy53aW5kb3dSZWZzW3dpbmRvd0lkXSkge1xyXG4gICAgICB0aGlzLndpbmRvd1JlZnNbd2luZG93SWRdLmNsb3NlKCk7XHJcbiAgICAgIGRlbGV0ZSB0aGlzLndpbmRvd1JlZnNbd2luZG93SWRdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgX2NyZWF0ZVBvcHVwQmxvY2tBbGVydCh3aW5kb3dJZCwgdXJsKSB7XHJcbiAgICBjb25zdCBsb2dvVXJsID0gdGhpcy5nZXRMb2dvVXJsKCk7XHJcbiAgICBjb25zdCB0b3J1c0FsZXJ0ID0gaHRtbFRvRWxlbWVudCgnPGRpdiBpZD1cInRvcnVzQWxlcnRcIiBjbGFzcz1cInRvcnVzLWFsZXJ0LS12MlwiPicgKyBcIjxkaXYgaWQ9XFxcInRvcnVzQWxlcnRfX2xvZ29cXFwiPjxpbWcgc3JjPVxcXCJcIi5jb25jYXQobG9nb1VybCwgXCJcXFwiIC8+PC9kaXY+XCIpICsgXCI8ZGl2PlwiICsgXCI8aDEgaWQ9XFxcInRvcnVzQWxlcnRfX3RpdGxlXFxcIj5cIi5jb25jYXQodGhpcy5lbWJlZFRyYW5zbGF0aW9ucy5hY3Rpb25SZXF1aXJlZCwgXCI8L2gxPlwiKSArIFwiPHAgaWQ9XFxcInRvcnVzQWxlcnRfX2Rlc2NcXFwiPlwiLmNvbmNhdCh0aGlzLmVtYmVkVHJhbnNsYXRpb25zLnBlbmRpbmdBY3Rpb24sIFwiPC9wPlwiKSArIFwiPC9kaXY+XCIgKyBcIjwvZGl2PlwiKTtcclxuICAgIGNvbnN0IHN1Y2Nlc3NBbGVydCA9IGh0bWxUb0VsZW1lbnQoXCI8ZGl2PjxhIGlkPVxcXCJ0b3J1c0FsZXJ0X19idG5cXFwiPlwiLmNvbmNhdCh0aGlzLmVtYmVkVHJhbnNsYXRpb25zLmNvbnRpbnVlLCBcIjwvYT48L2Rpdj5cIikpO1xyXG4gICAgY29uc3QgYnRuQ29udGFpbmVyID0gaHRtbFRvRWxlbWVudCgnPGRpdiBpZD1cInRvcnVzQWxlcnRfX2J0bi1jb250YWluZXJcIj48L2Rpdj4nKTtcclxuICAgIGJ0bkNvbnRhaW5lci5hcHBlbmRDaGlsZChzdWNjZXNzQWxlcnQpO1xyXG4gICAgdG9ydXNBbGVydC5hcHBlbmRDaGlsZChidG5Db250YWluZXIpO1xyXG5cclxuICAgIGNvbnN0IGJpbmRPbkxvYWQgPSAoKSA9PiB7XHJcbiAgICAgIHN1Y2Nlc3NBbGVydC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xyXG4gICAgICAgIHRoaXMuX2hhbmRsZVdpbmRvdyh3aW5kb3dJZCwge1xyXG4gICAgICAgICAgdXJsLFxyXG4gICAgICAgICAgdGFyZ2V0OiBcIl9ibGFua1wiLFxyXG4gICAgICAgICAgZmVhdHVyZXM6IGdldFBvcHVwRmVhdHVyZXMoRkVBVFVSRVNfQ09ORklSTV9XSU5ET1cpXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRvcnVzQWxlcnQucmVtb3ZlKCk7XHJcbiAgICAgICAgaWYgKHRoaXMudG9ydXNBbGVydENvbnRhaW5lci5jaGlsZHJlbi5sZW5ndGggPT09IDApIHRoaXMudG9ydXNBbGVydENvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XHJcbiAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBhdHRhY2hPbkxvYWQgPSAoKSA9PiB7XHJcbiAgICAgIHRoaXMudG9ydXNBbGVydENvbnRhaW5lci5hcHBlbmRDaGlsZCh0b3J1c0FsZXJ0KTtcclxuICAgIH07XHJcblxyXG4gICAgYXdhaXQgZG9jdW1lbnRSZWFkeSgpO1xyXG4gICAgYXR0YWNoT25Mb2FkKCk7XHJcbiAgICBiaW5kT25Mb2FkKCk7XHJcbiAgICB0aGlzLnRvcnVzQWxlcnRDb250YWluZXIuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcclxuICB9XHJcblxyXG4gIGdldExvZ29VcmwoKSB7XHJcbiAgICBjb25zdCBsb2dvVXJsID0gXCJcIi5jb25jYXQodGhpcy50b3J1c1VybCwgXCIvaW1hZ2VzL3RvcnVzX2ljb24tYmx1ZS5zdmdcIik7XHJcbiAgICByZXR1cm4gbG9nb1VybDtcclxuICB9XHJcblxyXG59XHJcblxyXG5fZGVmaW5lUHJvcGVydHkoVG9ydXNDb21tdW5pY2F0aW9uUHJvdmlkZXIsIFwiX2RlZmF1bHRTdGF0ZVwiLCB7XHJcbiAgYnV0dG9uUG9zaXRpb246IFwiYm90dG9tLWxlZnRcIixcclxuICBjdXJyZW50TG9naW5Qcm92aWRlcjogbnVsbCxcclxuICBpc0lGcmFtZUZ1bGxTY3JlZW46IGZhbHNlLFxyXG4gIGhhc0VtaXR0ZWRDb25uZWN0aW9uOiBmYWxzZSxcclxuICB0b3J1c1dpZGdldFZpc2liaWxpdHk6IGZhbHNlLFxyXG4gIGluaXRpYWxpemVkOiBmYWxzZSxcclxuICBpc0xvZ2dlZEluOiBmYWxzZSxcclxuICBpc1Blcm1hbmVudGx5RGlzY29ubmVjdGVkOiBmYWxzZSxcclxuICBpc0Nvbm5lY3RlZDogZmFsc2VcclxufSk7XHJcblxyXG5mdW5jdGlvbiBvd25LZXlzJDEob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XHJcblxyXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDEodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpICUgMiA/IG93bktleXMkMShPYmplY3Qoc291cmNlKSwgITApLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSkgOiBvd25LZXlzJDEoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gcmV0dXJuIHRhcmdldDsgfVxyXG5cclxuY2xhc3MgVG9ydXNJblBhZ2VQcm92aWRlciBleHRlbmRzIEJhc2VQcm92aWRlciB7XHJcbiAgLyoqXHJcbiAgICogVGhlIGNoYWluIElEIG9mIHRoZSBjdXJyZW50bHkgY29ubmVjdGVkIFNvbGFuYSBjaGFpbi5cclxuICAgKiBTZWUgW2NoYWluSWQubmV0d29ya117QGxpbmsgaHR0cHM6Ly9jaGFpbmlkLm5ldHdvcmt9IGZvciBtb3JlIGluZm9ybWF0aW9uLlxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBUaGUgdXNlcidzIGN1cnJlbnRseSBzZWxlY3RlZCBTb2xhbmEgYWRkcmVzcy5cclxuICAgKiBJZiBudWxsLCBUb3J1cyBpcyBlaXRoZXIgbG9ja2VkIG9yIHRoZSB1c2VyIGhhcyBub3QgcGVybWl0dGVkIGFueVxyXG4gICAqIGFkZHJlc3NlcyB0byBiZSB2aWV3ZWQuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoY29ubmVjdGlvblN0cmVhbSwgX3JlZikge1xyXG4gICAgbGV0IHtcclxuICAgICAgbWF4RXZlbnRMaXN0ZW5lcnMgPSAxMDAsXHJcbiAgICAgIGpzb25ScGNTdHJlYW1OYW1lID0gXCJwcm92aWRlclwiXHJcbiAgICB9ID0gX3JlZjtcclxuICAgIHN1cGVyKGNvbm5lY3Rpb25TdHJlYW0sIHtcclxuICAgICAgbWF4RXZlbnRMaXN0ZW5lcnMsXHJcbiAgICAgIGpzb25ScGNTdHJlYW1OYW1lXHJcbiAgICB9KTsgLy8gcHJpdmF0ZSBzdGF0ZVxyXG5cclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNoYWluSWRcIiwgdm9pZCAwKTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZWxlY3RlZEFkZHJlc3NcIiwgdm9pZCAwKTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0cnlXaW5kb3dIYW5kbGVcIiwgdm9pZCAwKTtcclxuXHJcbiAgICB0aGlzLl9zdGF0ZSA9IF9vYmplY3RTcHJlYWQkMSh7fSwgVG9ydXNJblBhZ2VQcm92aWRlci5fZGVmYXVsdFN0YXRlKTsgLy8gcHVibGljIHN0YXRlXHJcblxyXG4gICAgdGhpcy5zZWxlY3RlZEFkZHJlc3MgPSBudWxsO1xyXG4gICAgdGhpcy5jaGFpbklkID0gbnVsbDtcclxuICAgIHRoaXMuX2hhbmRsZUFjY291bnRzQ2hhbmdlZCA9IHRoaXMuX2hhbmRsZUFjY291bnRzQ2hhbmdlZC5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5faGFuZGxlQ2hhaW5DaGFuZ2VkID0gdGhpcy5faGFuZGxlQ2hhaW5DaGFuZ2VkLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLl9oYW5kbGVVbmxvY2tTdGF0ZUNoYW5nZWQgPSB0aGlzLl9oYW5kbGVVbmxvY2tTdGF0ZUNoYW5nZWQuYmluZCh0aGlzKTsgLy8gc2V0dXAgb3duIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAgLy8gRUlQLTExOTMgY29ubmVjdFxyXG5cclxuICAgIHRoaXMub24oXCJjb25uZWN0XCIsICgpID0+IHtcclxuICAgICAgdGhpcy5fc3RhdGUuaXNDb25uZWN0ZWQgPSB0cnVlO1xyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QganNvblJwY05vdGlmaWNhdGlvbkhhbmRsZXIgPSBwYXlsb2FkID0+IHtcclxuICAgICAgY29uc3Qge1xyXG4gICAgICAgIG1ldGhvZCxcclxuICAgICAgICBwYXJhbXNcclxuICAgICAgfSA9IHBheWxvYWQ7XHJcblxyXG4gICAgICBpZiAobWV0aG9kID09PSBQUk9WSURFUl9OT1RJRklDQVRJT05TLkFDQ09VTlRTX0NIQU5HRUQpIHtcclxuICAgICAgICB0aGlzLl9oYW5kbGVBY2NvdW50c0NoYW5nZWQocGFyYW1zKTtcclxuICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09IFBST1ZJREVSX05PVElGSUNBVElPTlMuVU5MT0NLX1NUQVRFX0NIQU5HRUQpIHtcclxuICAgICAgICB0aGlzLl9oYW5kbGVVbmxvY2tTdGF0ZUNoYW5nZWQocGFyYW1zKTtcclxuICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09IFBST1ZJREVSX05PVElGSUNBVElPTlMuQ0hBSU5fQ0hBTkdFRCkge1xyXG4gICAgICAgIHRoaXMuX2hhbmRsZUNoYWluQ2hhbmdlZChwYXJhbXMpO1xyXG4gICAgICB9XHJcbiAgICB9OyAvLyBqc29uIHJwYyBub3RpZmljYXRpb24gbGlzdGVuZXJcclxuXHJcblxyXG4gICAgdGhpcy5qc29uUnBjQ29ubmVjdGlvbkV2ZW50cy5vbihcIm5vdGlmaWNhdGlvblwiLCBqc29uUnBjTm90aWZpY2F0aW9uSGFuZGxlcik7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgaW5wYWdlIHByb3ZpZGVyIGlzIGNvbm5lY3RlZCB0byBUb3J1cy5cclxuICAgKi9cclxuXHJcblxyXG4gIGlzQ29ubmVjdGVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlLmlzQ29ubmVjdGVkO1xyXG4gIH0gLy8gUHJpdmF0ZSBNZXRob2RzXHJcbiAgLy89ID09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29uc3RydWN0b3IgaGVscGVyLlxyXG4gICAqIFBvcHVsYXRlcyBpbml0aWFsIHN0YXRlIGJ5IGNhbGxpbmcgJ3dhbGxldF9nZXRQcm92aWRlclN0YXRlJyBhbmQgZW1pdHNcclxuICAgKiBuZWNlc3NhcnkgZXZlbnRzLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgYXN5bmMgX2luaXRpYWxpemVTdGF0ZSgpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHtcclxuICAgICAgICBhY2NvdW50cyxcclxuICAgICAgICBjaGFpbklkLFxyXG4gICAgICAgIGlzVW5sb2NrZWRcclxuICAgICAgfSA9IGF3YWl0IHRoaXMucmVxdWVzdCh7XHJcbiAgICAgICAgbWV0aG9kOiBQUk9WSURFUl9KUlBDX01FVEhPRFMuR0VUX1BST1ZJREVSX1NUQVRFLFxyXG4gICAgICAgIHBhcmFtczogW11cclxuICAgICAgfSk7IC8vIGluZGljYXRlIHRoYXQgd2UndmUgY29ubmVjdGVkLCBmb3IgRUlQLTExOTMgY29tcGxpYW5jZVxyXG5cclxuICAgICAgdGhpcy5lbWl0KFwiY29ubmVjdFwiLCB7XHJcbiAgICAgICAgY2hhaW5JZFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHRoaXMuX2hhbmRsZUNoYWluQ2hhbmdlZCh7XHJcbiAgICAgICAgY2hhaW5JZFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHRoaXMuX2hhbmRsZVVubG9ja1N0YXRlQ2hhbmdlZCh7XHJcbiAgICAgICAgYWNjb3VudHMsXHJcbiAgICAgICAgaXNVbmxvY2tlZFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHRoaXMuX2hhbmRsZUFjY291bnRzQ2hhbmdlZChhY2NvdW50cyk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBsb2cuZXJyb3IoXCJUb3J1czogRmFpbGVkIHRvIGdldCBpbml0aWFsIHN0YXRlLiBQbGVhc2UgcmVwb3J0IHRoaXMgYnVnLlwiLCBlcnJvcik7XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICBsb2cuaW5mbyhcImluaXRpYWxpemVkIHByb3ZpZGVyIHN0YXRlXCIpO1xyXG4gICAgICB0aGlzLl9zdGF0ZS5pbml0aWFsaXplZCA9IHRydWU7XHJcbiAgICAgIHRoaXMuZW1pdChcIl9pbml0aWFsaXplZFwiKTtcclxuICAgIH1cclxuICB9XHJcbiAgLyoqXHJcbiAgICogSW50ZXJuYWwgUlBDIG1ldGhvZC4gRm9yd2FyZHMgcmVxdWVzdHMgdG8gYmFja2dyb3VuZCB2aWEgdGhlIFJQQyBlbmdpbmUuXHJcbiAgICogQWxzbyByZW1hcCBpZHMgaW5ib3VuZCBhbmQgb3V0Ym91bmRcclxuICAgKi9cclxuXHJcblxyXG4gIF9ycGNSZXF1ZXN0KHBheWxvYWQsIGNhbGxiYWNrKSB7XHJcbiAgICBsZXQgaXNJbnRlcm5hbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XHJcbiAgICBsZXQgY2IgPSBjYWxsYmFjaztcclxuICAgIGNvbnN0IF9wYXlsb2FkID0gcGF5bG9hZDtcclxuXHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoX3BheWxvYWQpKSB7XHJcbiAgICAgIGlmICghX3BheWxvYWQuanNvbnJwYykge1xyXG4gICAgICAgIF9wYXlsb2FkLmpzb25ycGMgPSBcIjIuMFwiO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoX3BheWxvYWQubWV0aG9kID09PSBcInNvbGFuYV9hY2NvdW50c1wiIHx8IF9wYXlsb2FkLm1ldGhvZCA9PT0gXCJzb2xhbmFfcmVxdWVzdEFjY291bnRzXCIpIHtcclxuICAgICAgICAvLyBoYW5kbGUgYWNjb3VudHMgY2hhbmdpbmdcclxuICAgICAgICBjYiA9IChlcnIsIHJlcykgPT4ge1xyXG4gICAgICAgICAgdGhpcy5faGFuZGxlQWNjb3VudHNDaGFuZ2VkKHJlcy5yZXN1bHQgfHwgW10sIF9wYXlsb2FkLm1ldGhvZCA9PT0gXCJzb2xhbmFfYWNjb3VudHNcIiwgaXNJbnRlcm5hbCk7XHJcblxyXG4gICAgICAgICAgY2FsbGJhY2soZXJyLCByZXMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgIH0gZWxzZSBpZiAoX3BheWxvYWQubWV0aG9kID09PSBcIndhbGxldF9nZXRQcm92aWRlclN0YXRlXCIpIHtcclxuICAgICAgICB0aGlzLl9ycGNFbmdpbmUuaGFuZGxlKHBheWxvYWQsIGNiKTtcclxuXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy50cnlXaW5kb3dIYW5kbGUoX3BheWxvYWQsIGNiKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogV2hlbiB0aGUgcHJvdmlkZXIgYmVjb21lcyBjb25uZWN0ZWQsIHVwZGF0ZXMgaW50ZXJuYWwgc3RhdGUgYW5kIGVtaXRzXHJcbiAgICogcmVxdWlyZWQgZXZlbnRzLiBJZGVtcG90ZW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGNoYWluSWQgLSBUaGUgSUQgb2YgdGhlIG5ld2x5IGNvbm5lY3RlZCBjaGFpbi5cclxuICAgKiBlbWl0cyBUb3J1c0lucGFnZVByb3ZpZGVyI2Nvbm5lY3RcclxuICAgKi9cclxuXHJcblxyXG4gIF9oYW5kbGVDb25uZWN0KGNoYWluSWQpIHtcclxuICAgIGlmICghdGhpcy5fc3RhdGUuaXNDb25uZWN0ZWQpIHtcclxuICAgICAgdGhpcy5fc3RhdGUuaXNDb25uZWN0ZWQgPSB0cnVlO1xyXG4gICAgICB0aGlzLmVtaXQoXCJjb25uZWN0XCIsIHtcclxuICAgICAgICBjaGFpbklkXHJcbiAgICAgIH0pO1xyXG4gICAgICBsb2cuZGVidWcobWVzc2FnZXMuaW5mby5jb25uZWN0ZWQoY2hhaW5JZCkpO1xyXG4gICAgfVxyXG4gIH1cclxuICAvKipcclxuICAgKiBXaGVuIHRoZSBwcm92aWRlciBiZWNvbWVzIGRpc2Nvbm5lY3RlZCwgdXBkYXRlcyBpbnRlcm5hbCBzdGF0ZSBhbmQgZW1pdHNcclxuICAgKiByZXF1aXJlZCBldmVudHMuIElkZW1wb3RlbnQgd2l0aCByZXNwZWN0IHRvIHRoZSBpc1JlY292ZXJhYmxlIHBhcmFtZXRlci5cclxuICAgKlxyXG4gICAqIEVycm9yIGNvZGVzIHBlciB0aGUgQ2xvc2VFdmVudCBzdGF0dXMgY29kZXMgYXMgcmVxdWlyZWQgYnkgRUlQLTExOTM6XHJcbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Nsb3NlRXZlbnQjU3RhdHVzX2NvZGVzXHJcbiAgICpcclxuICAgKiBAcGFyYW0gaXNSZWNvdmVyYWJsZSAtIFdoZXRoZXIgdGhlIGRpc2Nvbm5lY3Rpb24gaXMgcmVjb3ZlcmFibGUuXHJcbiAgICogQHBhcmFtIGVycm9yTWVzc2FnZSAtIEEgY3VzdG9tIGVycm9yIG1lc3NhZ2UuXHJcbiAgICogZW1pdHMgVG9ydXNJbnBhZ2VQcm92aWRlciNkaXNjb25uZWN0XHJcbiAgICovXHJcblxyXG5cclxuICBfaGFuZGxlRGlzY29ubmVjdChpc1JlY292ZXJhYmxlLCBlcnJvck1lc3NhZ2UpIHtcclxuICAgIGlmICh0aGlzLl9zdGF0ZS5pc0Nvbm5lY3RlZCB8fCAhdGhpcy5fc3RhdGUuaXNQZXJtYW5lbnRseURpc2Nvbm5lY3RlZCAmJiAhaXNSZWNvdmVyYWJsZSkge1xyXG4gICAgICB0aGlzLl9zdGF0ZS5pc0Nvbm5lY3RlZCA9IGZhbHNlO1xyXG4gICAgICBsZXQgZXJyb3I7XHJcblxyXG4gICAgICBpZiAoaXNSZWNvdmVyYWJsZSkge1xyXG4gICAgICAgIGVycm9yID0gbmV3IEV0aGVyZXVtUnBjRXJyb3IoMTAxMywgLy8gVHJ5IGFnYWluIGxhdGVyXHJcbiAgICAgICAgZXJyb3JNZXNzYWdlIHx8IG1lc3NhZ2VzLmVycm9ycy5kaXNjb25uZWN0ZWQoKSk7XHJcbiAgICAgICAgbG9nLmRlYnVnKGVycm9yKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBlcnJvciA9IG5ldyBFdGhlcmV1bVJwY0Vycm9yKDEwMTEsIC8vIEludGVybmFsIGVycm9yXHJcbiAgICAgICAgZXJyb3JNZXNzYWdlIHx8IG1lc3NhZ2VzLmVycm9ycy5wZXJtYW5lbnRseURpc2Nvbm5lY3RlZCgpKTtcclxuICAgICAgICBsb2cuZXJyb3IoZXJyb3IpO1xyXG4gICAgICAgIHRoaXMuY2hhaW5JZCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fc3RhdGUuYWNjb3VudHMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRBZGRyZXNzID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9zdGF0ZS5pc1VubG9ja2VkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fc3RhdGUuaXNQZXJtYW5lbnRseURpc2Nvbm5lY3RlZCA9IHRydWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuZW1pdChcImRpc2Nvbm5lY3RcIiwgZXJyb3IpO1xyXG4gICAgfVxyXG4gIH1cclxuICAvKipcclxuICAgKiBDYWxsZWQgd2hlbiBhY2NvdW50cyBtYXkgaGF2ZSBjaGFuZ2VkLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgX2hhbmRsZUFjY291bnRzQ2hhbmdlZChhY2NvdW50cykge1xyXG4gICAgbGV0IGlzRXRoQWNjb3VudHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xyXG4gICAgbGV0IGlzSW50ZXJuYWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xyXG4gICAgLy8gZGVmZW5zaXZlIHByb2dyYW1taW5nXHJcbiAgICBsZXQgZmluYWxBY2NvdW50cyA9IGFjY291bnRzO1xyXG5cclxuICAgIGlmICghQXJyYXkuaXNBcnJheShmaW5hbEFjY291bnRzKSkge1xyXG4gICAgICBsb2cuZXJyb3IoXCJUb3J1czogUmVjZWl2ZWQgbm9uLWFycmF5IGFjY291bnRzIHBhcmFtZXRlci4gUGxlYXNlIHJlcG9ydCB0aGlzIGJ1Zy5cIiwgZmluYWxBY2NvdW50cyk7XHJcbiAgICAgIGZpbmFsQWNjb3VudHMgPSBbXTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGNvbnN0IGFjY291bnQgb2YgYWNjb3VudHMpIHtcclxuICAgICAgaWYgKHR5cGVvZiBhY2NvdW50ICE9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgbG9nLmVycm9yKFwiVG9ydXM6IFJlY2VpdmVkIG5vbi1zdHJpbmcgYWNjb3VudC4gUGxlYXNlIHJlcG9ydCB0aGlzIGJ1Zy5cIiwgYWNjb3VudHMpO1xyXG4gICAgICAgIGZpbmFsQWNjb3VudHMgPSBbXTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfSAvLyBlbWl0IGFjY291bnRzQ2hhbmdlZCBpZiBhbnl0aGluZyBhYm91dCB0aGUgYWNjb3VudHMgYXJyYXkgaGFzIGNoYW5nZWRcclxuXHJcblxyXG4gICAgaWYgKCFkZXF1YWwodGhpcy5fc3RhdGUuYWNjb3VudHMsIGZpbmFsQWNjb3VudHMpKSB7XHJcbiAgICAgIC8vIHdlIHNob3VsZCBhbHdheXMgaGF2ZSB0aGUgY29ycmVjdCBhY2NvdW50cyBldmVuIGJlZm9yZSBzb2xhbmFfYWNjb3VudHNcclxuICAgICAgLy8gcmV0dXJucywgZXhjZXB0IGluIGNhc2VzIHdoZXJlIGlzSW50ZXJuYWwgaXMgdHJ1ZVxyXG4gICAgICBpZiAoaXNFdGhBY2NvdW50cyAmJiBBcnJheS5pc0FycmF5KHRoaXMuX3N0YXRlLmFjY291bnRzKSAmJiB0aGlzLl9zdGF0ZS5hY2NvdW50cy5sZW5ndGggPiAwICYmICFpc0ludGVybmFsKSB7XHJcbiAgICAgICAgbG9nLmVycm9yKCdUb3J1czogXCJzb2xhbmFfYWNjb3VudHNcIiB1bmV4cGVjdGVkbHkgdXBkYXRlZCBhY2NvdW50cy4gUGxlYXNlIHJlcG9ydCB0aGlzIGJ1Zy4nLCBmaW5hbEFjY291bnRzKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5fc3RhdGUuYWNjb3VudHMgPSBmaW5hbEFjY291bnRzO1xyXG4gICAgICB0aGlzLmVtaXQoXCJhY2NvdW50c0NoYW5nZWRcIiwgZmluYWxBY2NvdW50cyk7XHJcbiAgICB9IC8vIGhhbmRsZSBzZWxlY3RlZEFkZHJlc3NcclxuXHJcblxyXG4gICAgaWYgKHRoaXMuc2VsZWN0ZWRBZGRyZXNzICE9PSBmaW5hbEFjY291bnRzWzBdKSB7XHJcbiAgICAgIHRoaXMuc2VsZWN0ZWRBZGRyZXNzID0gZmluYWxBY2NvdW50c1swXSB8fCBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuICAvKipcclxuICAgKiBVcG9uIHJlY2VpcHQgb2YgYSBuZXcgY2hhaW5JZCBhbmQgbmV0d29ya1ZlcnNpb24sIGVtaXRzIGNvcnJlc3BvbmRpbmdcclxuICAgKiBldmVudHMgYW5kIHNldHMgcmVsZXZhbnQgcHVibGljIHN0YXRlLlxyXG4gICAqIERvZXMgbm90aGluZyBpZiBuZWl0aGVyIHRoZSBjaGFpbklkIG5vciB0aGUgbmV0d29ya1ZlcnNpb24gYXJlIGRpZmZlcmVudFxyXG4gICAqIGZyb20gZXhpc3RpbmcgdmFsdWVzLlxyXG4gICAqXHJcbiAgICogZW1pdHMgVG9ydXNJbnBhZ2VQcm92aWRlciNjaGFpbkNoYW5nZWRcclxuICAgKiBAcGFyYW0gbmV0d29ya0luZm8gLSBBbiBvYmplY3Qgd2l0aCBuZXR3b3JrIGluZm8uXHJcbiAgICovXHJcblxyXG5cclxuICBfaGFuZGxlQ2hhaW5DaGFuZ2VkKCkge1xyXG4gICAgbGV0IHtcclxuICAgICAgY2hhaW5JZFxyXG4gICAgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XHJcblxyXG4gICAgaWYgKCFjaGFpbklkKSB7XHJcbiAgICAgIGxvZy5lcnJvcihcIlRvcnVzOiBSZWNlaXZlZCBpbnZhbGlkIG5ldHdvcmsgcGFyYW1ldGVycy4gUGxlYXNlIHJlcG9ydCB0aGlzIGJ1Zy5cIiwge1xyXG4gICAgICAgIGNoYWluSWRcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY2hhaW5JZCA9PT0gXCJsb2FkaW5nXCIpIHtcclxuICAgICAgdGhpcy5faGFuZGxlRGlzY29ubmVjdCh0cnVlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX2hhbmRsZUNvbm5lY3QoY2hhaW5JZCk7XHJcblxyXG4gICAgICBpZiAoY2hhaW5JZCAhPT0gdGhpcy5jaGFpbklkKSB7XHJcbiAgICAgICAgdGhpcy5jaGFpbklkID0gY2hhaW5JZDtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLmluaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICB0aGlzLmVtaXQoXCJjaGFpbkNoYW5nZWRcIiwgdGhpcy5jaGFpbklkKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgLyoqXHJcbiAgICogVXBvbiByZWNlaXB0IG9mIGEgbmV3IGlzVW5sb2NrZWQgc3RhdGUsIHNldHMgcmVsZXZhbnQgcHVibGljIHN0YXRlLlxyXG4gICAqIENhbGxzIHRoZSBhY2NvdW50cyBjaGFuZ2VkIGhhbmRsZXIgd2l0aCB0aGUgcmVjZWl2ZWQgYWNjb3VudHMsIG9yIGFuIGVtcHR5XHJcbiAgICogYXJyYXkuXHJcbiAgICpcclxuICAgKiBEb2VzIG5vdGhpbmcgaWYgdGhlIHJlY2VpdmVkIHZhbHVlIGlzIGVxdWFsIHRvIHRoZSBleGlzdGluZyB2YWx1ZS5cclxuICAgKiBUaGVyZSBhcmUgbm8gbG9jay91bmxvY2sgZXZlbnRzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIG9wdHMgLSBPcHRpb25zIGJhZy5cclxuICAgKi9cclxuXHJcblxyXG4gIF9oYW5kbGVVbmxvY2tTdGF0ZUNoYW5nZWQoKSB7XHJcbiAgICBsZXQge1xyXG4gICAgICBhY2NvdW50cyxcclxuICAgICAgaXNVbmxvY2tlZFxyXG4gICAgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XHJcblxyXG4gICAgaWYgKHR5cGVvZiBpc1VubG9ja2VkICE9PSBcImJvb2xlYW5cIikge1xyXG4gICAgICBsb2cuZXJyb3IoXCJUb3J1czogUmVjZWl2ZWQgaW52YWxpZCBpc1VubG9ja2VkIHBhcmFtZXRlci4gUGxlYXNlIHJlcG9ydCB0aGlzIGJ1Zy5cIiwge1xyXG4gICAgICAgIGlzVW5sb2NrZWRcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNVbmxvY2tlZCAhPT0gdGhpcy5fc3RhdGUuaXNVbmxvY2tlZCkge1xyXG4gICAgICB0aGlzLl9zdGF0ZS5pc1VubG9ja2VkID0gaXNVbmxvY2tlZDtcclxuXHJcbiAgICAgIHRoaXMuX2hhbmRsZUFjY291bnRzQ2hhbmdlZChhY2NvdW50cyB8fCBbXSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxufVxyXG5cclxuX2RlZmluZVByb3BlcnR5KFRvcnVzSW5QYWdlUHJvdmlkZXIsIFwiX2RlZmF1bHRTdGF0ZVwiLCB7XHJcbiAgYWNjb3VudHM6IG51bGwsXHJcbiAgaXNDb25uZWN0ZWQ6IGZhbHNlLFxyXG4gIGlzVW5sb2NrZWQ6IGZhbHNlLFxyXG4gIGluaXRpYWxpemVkOiBmYWxzZSxcclxuICBpc1Blcm1hbmVudGx5RGlzY29ubmVjdGVkOiBmYWxzZSxcclxuICBoYXNFbWl0dGVkQ29ubmVjdGlvbjogZmFsc2VcclxufSk7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIHRoZSBnaXZlbiBpbWFnZSBVUkwgZXhpc3RzXHJcbiAqL1xyXG5mdW5jdGlvbiBpbWdFeGlzdHModXJsKSB7XHJcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XHJcblxyXG4gICAgICBpbWcub25sb2FkID0gKCkgPT4gcmVzb2x2ZSh0cnVlKTtcclxuXHJcbiAgICAgIGltZy5vbmVycm9yID0gKCkgPT4gcmVzb2x2ZShmYWxzZSk7XHJcblxyXG4gICAgICBpbWcuc3JjID0gdXJsO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICByZWplY3QoZSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIEV4dHJhY3RzIGEgbmFtZSBmb3IgdGhlIHNpdGUgZnJvbSB0aGUgRE9NXHJcbiAqL1xyXG5cclxuXHJcbmNvbnN0IGdldFNpdGVOYW1lID0gd2luZG93ID0+IHtcclxuICBjb25zdCB7XHJcbiAgICBkb2N1bWVudFxyXG4gIH0gPSB3aW5kb3c7XHJcbiAgY29uc3Qgc2l0ZU5hbWUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdoZWFkID4gbWV0YVtwcm9wZXJ0eT1cIm9nOnNpdGVfbmFtZVwiXScpO1xyXG5cclxuICBpZiAoc2l0ZU5hbWUpIHtcclxuICAgIHJldHVybiBzaXRlTmFtZS5jb250ZW50O1xyXG4gIH1cclxuXHJcbiAgY29uc3QgbWV0YVRpdGxlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaGVhZCA+IG1ldGFbbmFtZT1cInRpdGxlXCJdJyk7XHJcblxyXG4gIGlmIChtZXRhVGl0bGUpIHtcclxuICAgIHJldHVybiBtZXRhVGl0bGUuY29udGVudDtcclxuICB9XHJcblxyXG4gIGlmIChkb2N1bWVudC50aXRsZSAmJiBkb2N1bWVudC50aXRsZS5sZW5ndGggPiAwKSB7XHJcbiAgICByZXR1cm4gZG9jdW1lbnQudGl0bGU7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lO1xyXG59O1xyXG4vKipcclxuICogRXh0cmFjdHMgYW4gaWNvbiBmb3IgdGhlIHNpdGUgZnJvbSB0aGUgRE9NXHJcbiAqL1xyXG5cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGdldFNpdGVJY29uKHdpbmRvdykge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgIGRvY3VtZW50XHJcbiAgICB9ID0gd2luZG93OyAvLyBVc2UgdGhlIHNpdGUncyBmYXZpY29uIGlmIGl0IGV4aXN0c1xyXG5cclxuICAgIGxldCBpY29uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaGVhZCA+IGxpbmtbcmVsPVwic2hvcnRjdXQgaWNvblwiXScpO1xyXG5cclxuICAgIGlmIChpY29uICYmIChhd2FpdCBpbWdFeGlzdHMoaWNvbi5ocmVmKSkpIHtcclxuICAgICAgcmV0dXJuIGljb24uaHJlZjtcclxuICAgIH0gLy8gU2VhcmNoIHRocm91Z2ggYXZhaWxhYmxlIGljb25zIGluIG5vIHBhcnRpY3VsYXIgb3JkZXJcclxuXHJcblxyXG4gICAgaWNvbiA9IEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnaGVhZCA+IGxpbmtbcmVsPVwiaWNvblwiXScpKS5maW5kKF9pY29uID0+IEJvb2xlYW4oX2ljb24uaHJlZikpO1xyXG5cclxuICAgIGlmIChpY29uICYmIChhd2FpdCBpbWdFeGlzdHMoaWNvbi5ocmVmKSkpIHtcclxuICAgICAgcmV0dXJuIGljb24uaHJlZjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gXCJcIjtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgcmV0dXJuIFwiXCI7XHJcbiAgfVxyXG59XHJcbi8qKlxyXG4gKiBHZXRzIHNpdGUgbWV0YWRhdGEgYW5kIHJldHVybnMgaXRcclxuICpcclxuICovXHJcblxyXG5cclxuY29uc3QgZ2V0U2l0ZU1ldGFkYXRhID0gYXN5bmMgKCkgPT4gKHtcclxuICBuYW1lOiBnZXRTaXRlTmFtZSh3aW5kb3cpLFxyXG4gIGljb246IGF3YWl0IGdldFNpdGVJY29uKHdpbmRvdylcclxufSk7XHJcblxyXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxyXG5cclxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307IGkgJSAyID8gb3duS2V5cyhPYmplY3Qoc291cmNlKSwgITApLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSkgOiBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IHJldHVybiB0YXJnZXQ7IH1cclxuY29uc3QgUFJPVklERVJfVU5TQUZFX01FVEhPRFMgPSBbXCJzZW5kX3RyYW5zYWN0aW9uXCIsIFwic2lnbl90cmFuc2FjdGlvblwiLCBcInNpZ25fYWxsX3RyYW5zYWN0aW9uc1wiLCBcInNpZ25fbWVzc2FnZVwiLCBcImNvbm5lY3RcIl07XHJcbmNvbnN0IENPTU1VTklDQVRJT05fVU5TQUZFX01FVEhPRFMgPSBbQ09NTVVOSUNBVElPTl9KUlBDX01FVEhPRFMuU0VUX1BST1ZJREVSXTtcclxuY29uc3QgaXNMb2NhbFN0b3JhZ2VBdmFpbGFibGUgPSBzdG9yYWdlQXZhaWxhYmxlKFwibG9jYWxTdG9yYWdlXCIpOyAvLyBwcmVsb2FkIGZvciBpZnJhbWUgZG9lc24ndCB3b3JrIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTU5MzI2N1xyXG5cclxuKGFzeW5jIGZ1bmN0aW9uIHByZUxvYWRJZnJhbWUoKSB7XHJcbiAgdHJ5IHtcclxuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybjtcclxuICAgIGNvbnN0IHRvcnVzSWZyYW1lSHRtbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xyXG4gICAgY29uc3Qge1xyXG4gICAgICB0b3J1c1VybFxyXG4gICAgfSA9IGF3YWl0IGdldFRvcnVzVXJsKFwicHJvZHVjdGlvblwiKTtcclxuICAgIHRvcnVzSWZyYW1lSHRtbC5ocmVmID0gXCJcIi5jb25jYXQodG9ydXNVcmwsIFwiL2ZyYW1lXCIpO1xyXG4gICAgdG9ydXNJZnJhbWVIdG1sLmNyb3NzT3JpZ2luID0gXCJhbm9ueW1vdXNcIjtcclxuICAgIHRvcnVzSWZyYW1lSHRtbC50eXBlID0gXCJ0ZXh0L2h0bWxcIjtcclxuICAgIHRvcnVzSWZyYW1lSHRtbC5yZWwgPSBcInByZWZldGNoXCI7XHJcblxyXG4gICAgaWYgKHRvcnVzSWZyYW1lSHRtbC5yZWxMaXN0ICYmIHRvcnVzSWZyYW1lSHRtbC5yZWxMaXN0LnN1cHBvcnRzKSB7XHJcbiAgICAgIGlmICh0b3J1c0lmcmFtZUh0bWwucmVsTGlzdC5zdXBwb3J0cyhcInByZWZldGNoXCIpKSB7XHJcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCh0b3J1c0lmcmFtZUh0bWwpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGxvZy53YXJuKGVycm9yKTtcclxuICB9XHJcbn0pKCk7XHJcblxyXG5jbGFzcyBUb3J1cyB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBsZXQge1xyXG4gICAgICBtb2RhbFpJbmRleCA9IDk5OTk5XHJcbiAgICB9ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpc0luaXRpYWxpemVkXCIsIHZvaWQgMCk7XHJcblxyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidG9ydXNBbGVydFwiLCB2b2lkIDApO1xyXG5cclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1vZGFsWkluZGV4XCIsIHZvaWQgMCk7XHJcblxyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiYWxlcnRaSW5kZXhcIiwgdm9pZCAwKTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZXF1ZXN0ZWRMb2dpblByb3ZpZGVyXCIsIHZvaWQgMCk7XHJcblxyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicHJvdmlkZXJcIiwgdm9pZCAwKTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb21tdW5pY2F0aW9uUHJvdmlkZXJcIiwgdm9pZCAwKTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJkYXBwU3RvcmFnZUtleVwiLCB2b2lkIDApO1xyXG5cclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvcnVzQWxlcnRDb250YWluZXJcIiwgdm9pZCAwKTtcclxuXHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b3J1c1VybFwiLCB2b2lkIDApO1xyXG5cclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvcnVzSWZyYW1lXCIsIHZvaWQgMCk7XHJcblxyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic3R5bGVMaW5rXCIsIHZvaWQgMCk7XHJcblxyXG4gICAgdGhpcy50b3J1c1VybCA9IFwiXCI7XHJcbiAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSBmYWxzZTsgLy8gaW5pdCBkb25lXHJcblxyXG4gICAgdGhpcy5yZXF1ZXN0ZWRMb2dpblByb3ZpZGVyID0gbnVsbDtcclxuICAgIHRoaXMubW9kYWxaSW5kZXggPSBtb2RhbFpJbmRleDtcclxuICAgIHRoaXMuYWxlcnRaSW5kZXggPSBtb2RhbFpJbmRleCArIDEwMDA7XHJcbiAgICB0aGlzLmRhcHBTdG9yYWdlS2V5ID0gXCJcIjtcclxuICB9XHJcblxyXG4gIGdldCBpc0xvZ2dlZEluKCkge1xyXG4gICAgaWYgKCF0aGlzLmNvbW11bmljYXRpb25Qcm92aWRlcikgcmV0dXJuIGZhbHNlO1xyXG4gICAgcmV0dXJuIHRoaXMuY29tbXVuaWNhdGlvblByb3ZpZGVyLmlzTG9nZ2VkSW47XHJcbiAgfVxyXG5cclxuICBhc3luYyBpbml0KCkge1xyXG4gICAgbGV0IHtcclxuICAgICAgYnVpbGRFbnYgPSBUT1JVU19CVUlMRF9FTlYuUFJPRFVDVElPTixcclxuICAgICAgZW5hYmxlTG9nZ2luZyA9IGZhbHNlLFxyXG4gICAgICBuZXR3b3JrLFxyXG4gICAgICBzaG93VG9ydXNCdXR0b24gPSBmYWxzZSxcclxuICAgICAgdXNlTG9jYWxTdG9yYWdlID0gZmFsc2UsXHJcbiAgICAgIGJ1dHRvblBvc2l0aW9uID0gQlVUVE9OX1BPU0lUSU9OLkJPVFRPTV9MRUZULFxyXG4gICAgICBhcGlLZXkgPSBcInRvcnVzLWRlZmF1bHRcIixcclxuICAgICAgZXh0cmFQYXJhbXMgPSB7fVxyXG4gICAgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XHJcbiAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkKSB0aHJvdyBuZXcgRXJyb3IoXCJBbHJlYWR5IGluaXRpYWxpemVkXCIpO1xyXG4gICAgc2V0QVBJS2V5KGFwaUtleSk7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgIHRvcnVzVXJsLFxyXG4gICAgICBsb2dMZXZlbFxyXG4gICAgfSA9IGF3YWl0IGdldFRvcnVzVXJsKGJ1aWxkRW52KTtcclxuICAgIGxvZy5pbmZvKHRvcnVzVXJsLCBcInVybCBsb2FkZWRcIik7XHJcbiAgICB0aGlzLnRvcnVzVXJsID0gdG9ydXNVcmw7XHJcbiAgICBsb2cuc2V0RGVmYXVsdExldmVsKGxvZ0xldmVsKTtcclxuICAgIGlmIChlbmFibGVMb2dnaW5nKSBsb2cuZW5hYmxlQWxsKCk7ZWxzZSBsb2cuZGlzYWJsZUFsbCgpO1xyXG4gICAgY29uc3QgZGFwcFN0b3JhZ2VLZXkgPSB0aGlzLmhhbmRsZURhcHBTdG9yYWdlS2V5KHVzZUxvY2FsU3RvcmFnZSk7XHJcbiAgICBjb25zdCB0b3J1c0lmcmFtZVVybCA9IG5ldyBVUkwodG9ydXNVcmwpO1xyXG4gICAgaWYgKHRvcnVzSWZyYW1lVXJsLnBhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKSkgdG9ydXNJZnJhbWVVcmwucGF0aG5hbWUgKz0gXCJmcmFtZVwiO2Vsc2UgdG9ydXNJZnJhbWVVcmwucGF0aG5hbWUgKz0gXCIvZnJhbWVcIjtcclxuICAgIGNvbnN0IGhhc2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XHJcbiAgICBpZiAoZGFwcFN0b3JhZ2VLZXkpIGhhc2hQYXJhbXMuYXBwZW5kKFwiZGFwcFN0b3JhZ2VLZXlcIiwgZGFwcFN0b3JhZ2VLZXkpO1xyXG4gICAgaGFzaFBhcmFtcy5hcHBlbmQoXCJvcmlnaW5cIiwgd2luZG93LmxvY2F0aW9uLm9yaWdpbik7XHJcbiAgICB0b3J1c0lmcmFtZVVybC5oYXNoID0gaGFzaFBhcmFtcy50b1N0cmluZygpOyAvLyBJZnJhbWUgY29kZVxyXG5cclxuICAgIHRoaXMudG9ydXNJZnJhbWUgPSBodG1sVG9FbGVtZW50KFwiPGlmcmFtZVxcbiAgICAgICAgaWQ9XFxcInRvcnVzSWZyYW1lXFxcIlxcbiAgICAgICAgY2xhc3M9XFxcInRvcnVzSWZyYW1lXFxcIlxcbiAgICAgICAgc3JjPVxcXCJcIi5jb25jYXQodG9ydXNJZnJhbWVVcmwuaHJlZiwgXCJcXFwiXFxuICAgICAgICBzdHlsZT1cXFwiZGlzcGxheTogbm9uZTsgcG9zaXRpb246IGZpeGVkOyB0b3A6IDA7IHJpZ2h0OiAwOyB3aWR0aDogMTAwJTtcXG4gICAgICAgIGhlaWdodDogMTAwJTsgYm9yZGVyOiBub25lOyBib3JkZXItcmFkaXVzOiAwOyB6LWluZGV4OiBcIikuY29uY2F0KHRoaXMubW9kYWxaSW5kZXgudG9TdHJpbmcoKSwgXCJcXFwiXFxuICAgICAgPjwvaWZyYW1lPlwiKSk7XHJcbiAgICB0aGlzLnRvcnVzQWxlcnRDb250YWluZXIgPSBodG1sVG9FbGVtZW50KFwiPGRpdiBpZD1cXFwidG9ydXNBbGVydENvbnRhaW5lclxcXCIgc3R5bGU9XFxcImRpc3BsYXk6bm9uZTsgei1pbmRleDogXCIuY29uY2F0KHRoaXMuYWxlcnRaSW5kZXgudG9TdHJpbmcoKSwgXCJcXFwiPjwvZGl2PlwiKSk7XHJcbiAgICB0aGlzLnN0eWxlTGluayA9IGh0bWxUb0VsZW1lbnQoXCI8bGluayBocmVmPVxcXCJcIi5jb25jYXQodG9ydXNVcmwsIFwiL2Nzcy93aWRnZXQuY3NzXFxcIiByZWw9XFxcInN0eWxlc2hlZXRcXFwiIHR5cGU9XFxcInRleHQvY3NzXFxcIj5cIikpO1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZVNldHVwID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCh0aGlzLnN0eWxlTGluayk7XHJcbiAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLnRvcnVzSWZyYW1lKTtcclxuICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMudG9ydXNBbGVydENvbnRhaW5lcik7XHJcbiAgICAgICAgICB0aGlzLnRvcnVzSWZyYW1lLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZGFwcE1ldGFkYXRhID0gYXdhaXQgZ2V0U2l0ZU1ldGFkYXRhKCk7IC8vIHNlbmQgaW5pdCBwYXJhbXMgaGVyZVxyXG5cclxuICAgICAgICAgICAgdGhpcy50b3J1c0lmcmFtZS5jb250ZW50V2luZG93LnBvc3RNZXNzYWdlKHtcclxuICAgICAgICAgICAgICBidXR0b25Qb3NpdGlvbixcclxuICAgICAgICAgICAgICBhcGlLZXksXHJcbiAgICAgICAgICAgICAgbmV0d29yazogdHlwZW9mIG5ldHdvcmsgPT09IFwic3RyaW5nXCIgPyBnZXROZXR3b3JrQ29uZmlnKG5ldHdvcmspIDogbmV0d29yayxcclxuICAgICAgICAgICAgICBkYXBwTWV0YWRhdGEsXHJcbiAgICAgICAgICAgICAgZXh0cmFQYXJhbXNcclxuICAgICAgICAgICAgfSwgdG9ydXNJZnJhbWVVcmwub3JpZ2luKTtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2V0dXBXZWIzKHtcclxuICAgICAgICAgICAgICB0b3J1c1VybFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKHNob3dUb3J1c0J1dHRvbikgdGhpcy5zaG93VG9ydXNCdXR0b24oKTtlbHNlIHRoaXMuaGlkZVRvcnVzQnV0dG9uKCk7XHJcbiAgICAgICAgICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHdpbmRvdy50b3J1cyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGF3YWl0IGRvY3VtZW50UmVhZHkoKTtcclxuICAgIGF3YWl0IGhhbmRsZVNldHVwKCk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBsb2dpbigpIHtcclxuICAgIGxldCBwYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xyXG4gICAgaWYgKCF0aGlzLmlzSW5pdGlhbGl6ZWQpIHRocm93IG5ldyBFcnJvcihcIkNhbGwgaW5pdCgpIGZpcnN0XCIpO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIHRoaXMucmVxdWVzdGVkTG9naW5Qcm92aWRlciA9IHBhcmFtcy5sb2dpblByb3ZpZGVyIHx8IG51bGw7XHJcblxyXG4gICAgICBpZiAoIXRoaXMucmVxdWVzdGVkTG9naW5Qcm92aWRlcikge1xyXG4gICAgICAgIHRoaXMuY29tbXVuaWNhdGlvblByb3ZpZGVyLl9kaXNwbGF5SWZyYW1lKHtcclxuICAgICAgICAgIGlzRnVsbDogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IC8vIElmIHVzZXIgaXMgYWxyZWFkeSBsb2dnZWQgaW4sIHdlIGFzc3VtZSB0aGV5IGhhdmUgZ2l2ZW4gYWNjZXNzIHRvIHRoZSB3ZWJzaXRlXHJcblxyXG5cclxuICAgICAgY29uc3QgcmVzID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIC8vIFdlIHVzZSB0aGlzIG1ldGhvZCBiZWNhdXNlIHdlIHdhbnQgdG8gdXBkYXRlIGluUGFnZSBwcm92aWRlciBzdGF0ZSB3aXRoIGFjY291bnQgaW5mb1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXIuX3JwY1JlcXVlc3Qoe1xyXG4gICAgICAgICAgbWV0aG9kOiBcInNvbGFuYV9yZXF1ZXN0QWNjb3VudHNcIixcclxuICAgICAgICAgIHBhcmFtczogW3RoaXMucmVxdWVzdGVkTG9naW5Qcm92aWRlciwgcGFyYW1zLmxvZ2luX2hpbnRdXHJcbiAgICAgICAgfSwgZ2V0UnBjUHJvbWlzZUNhbGxiYWNrKHJlc29sdmUsIHJlamVjdCkpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlcykgJiYgcmVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICB9IC8vIFRoaXMgd291bGQgbmV2ZXIgaGFwcGVuLCBidXQganVzdCBpbiBjYXNlXHJcblxyXG5cclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTG9naW4gZmFpbGVkXCIpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgbG9nLmVycm9yKFwibG9naW4gZmFpbGVkXCIsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICBpZiAodGhpcy5jb21tdW5pY2F0aW9uUHJvdmlkZXIuaXNJRnJhbWVGdWxsU2NyZWVuKSB0aGlzLmNvbW11bmljYXRpb25Qcm92aWRlci5fZGlzcGxheUlmcmFtZSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgbG9nb3V0KCkge1xyXG4gICAgaWYgKCF0aGlzLmNvbW11bmljYXRpb25Qcm92aWRlci5pc0xvZ2dlZEluKSB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgbG9nZ2VkIGluXCIpO1xyXG4gICAgYXdhaXQgdGhpcy5jb21tdW5pY2F0aW9uUHJvdmlkZXIucmVxdWVzdCh7XHJcbiAgICAgIG1ldGhvZDogQ09NTVVOSUNBVElPTl9KUlBDX01FVEhPRFMuTE9HT1VULFxyXG4gICAgICBwYXJhbXM6IFtdXHJcbiAgICB9KTtcclxuICAgIHRoaXMucmVxdWVzdGVkTG9naW5Qcm92aWRlciA9IG51bGw7XHJcbiAgfVxyXG5cclxuICBhc3luYyBjbGVhblVwKCkge1xyXG4gICAgaWYgKHRoaXMuY29tbXVuaWNhdGlvblByb3ZpZGVyLmlzTG9nZ2VkSW4pIHtcclxuICAgICAgYXdhaXQgdGhpcy5sb2dvdXQoKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmNsZWFySW5pdCgpO1xyXG4gIH1cclxuXHJcbiAgY2xlYXJJbml0KCkge1xyXG4gICAgZnVuY3Rpb24gaXNFbGVtZW50KGVsZW1lbnQpIHtcclxuICAgICAgcmV0dXJuIGVsZW1lbnQgaW5zdGFuY2VvZiBFbGVtZW50IHx8IGVsZW1lbnQgaW5zdGFuY2VvZiBEb2N1bWVudDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNFbGVtZW50KHRoaXMuc3R5bGVMaW5rKSAmJiB3aW5kb3cuZG9jdW1lbnQuYm9keS5jb250YWlucyh0aGlzLnN0eWxlTGluaykpIHtcclxuICAgICAgdGhpcy5zdHlsZUxpbmsucmVtb3ZlKCk7XHJcbiAgICAgIHRoaXMuc3R5bGVMaW5rID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc0VsZW1lbnQodGhpcy50b3J1c0lmcmFtZSkgJiYgd2luZG93LmRvY3VtZW50LmJvZHkuY29udGFpbnModGhpcy50b3J1c0lmcmFtZSkpIHtcclxuICAgICAgdGhpcy50b3J1c0lmcmFtZS5yZW1vdmUoKTtcclxuICAgICAgdGhpcy50b3J1c0lmcmFtZSA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNFbGVtZW50KHRoaXMudG9ydXNBbGVydENvbnRhaW5lcikgJiYgd2luZG93LmRvY3VtZW50LmJvZHkuY29udGFpbnModGhpcy50b3J1c0FsZXJ0Q29udGFpbmVyKSkge1xyXG4gICAgICB0aGlzLnRvcnVzQWxlcnQgPSB1bmRlZmluZWQ7XHJcbiAgICAgIHRoaXMudG9ydXNBbGVydENvbnRhaW5lci5yZW1vdmUoKTtcclxuICAgICAgdGhpcy50b3J1c0FsZXJ0Q29udGFpbmVyID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgaGlkZVRvcnVzQnV0dG9uKCkge1xyXG4gICAgdGhpcy5jb21tdW5pY2F0aW9uUHJvdmlkZXIuaGlkZVRvcnVzQnV0dG9uKCk7XHJcbiAgfVxyXG5cclxuICBzaG93VG9ydXNCdXR0b24oKSB7XHJcbiAgICB0aGlzLmNvbW11bmljYXRpb25Qcm92aWRlci5zaG93VG9ydXNCdXR0b24oKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIHNldFByb3ZpZGVyKHBhcmFtcykge1xyXG4gICAgYXdhaXQgdGhpcy5jb21tdW5pY2F0aW9uUHJvdmlkZXIucmVxdWVzdCh7XHJcbiAgICAgIG1ldGhvZDogQ09NTVVOSUNBVElPTl9KUlBDX01FVEhPRFMuU0VUX1BST1ZJREVSLFxyXG4gICAgICBwYXJhbXM6IF9vYmplY3RTcHJlYWQoe30sIHBhcmFtcylcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgc2hvd1dhbGxldChwYXRoKSB7XHJcbiAgICBsZXQgcGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcclxuICAgIGNvbnN0IGluc3RhbmNlSWQgPSBhd2FpdCB0aGlzLmNvbW11bmljYXRpb25Qcm92aWRlci5yZXF1ZXN0KHtcclxuICAgICAgbWV0aG9kOiBDT01NVU5JQ0FUSU9OX0pSUENfTUVUSE9EUy5XQUxMRVRfSU5TVEFOQ0VfSUQsXHJcbiAgICAgIHBhcmFtczogW11cclxuICAgIH0pO1xyXG4gICAgY29uc3QgZmluYWxQYXRoID0gcGF0aCA/IFwiL1wiLmNvbmNhdChwYXRoKSA6IFwiXCI7XHJcbiAgICBjb25zdCBmaW5hbFVybCA9IG5ldyBVUkwoXCJcIi5jb25jYXQodGhpcy50b3J1c1VybCwgXCIvd2FsbGV0XCIpLmNvbmNhdChmaW5hbFBhdGgpKTsgLy8gVXNpbmcgVVJMIGNvbnN0cnVjdG9yIHRvIHByZXZlbnQganMgaW5qZWN0aW9uIGFuZCBhbGxvdyBwYXJhbWV0ZXIgdmFsaWRhdGlvbi4hXHJcblxyXG4gICAgZmluYWxVcmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcImluc3RhbmNlSWRcIiwgaW5zdGFuY2VJZCk7XHJcbiAgICBPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2goeCA9PiB7XHJcbiAgICAgIGZpbmFsVXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoeCwgcGFyYW1zW3hdKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGlmICh0aGlzLmRhcHBTdG9yYWdlS2V5KSB7XHJcbiAgICAgIGZpbmFsVXJsLmhhc2ggPSBcIiNkYXBwU3RvcmFnZUtleT1cIi5jb25jYXQodGhpcy5kYXBwU3RvcmFnZUtleSk7XHJcbiAgICB9IC8vIE5vIG5lZWQgdG8gdHJhY2sgdGhpcyB3aW5kb3cgc3RhdGUuIEhlbmNlLCBubyBfaGFuZGxlV2luZG93IGNhbGwuXHJcblxyXG5cclxuICAgIGNvbnN0IHdhbGxldFdpbmRvdyA9IG5ldyBQb3B1cEhhbmRsZXIoe1xyXG4gICAgICB1cmw6IGZpbmFsVXJsLFxyXG4gICAgICBmZWF0dXJlczogZ2V0UG9wdXBGZWF0dXJlcyhGRUFUVVJFU19ERUZBVUxUX1dBTExFVF9XSU5ET1cpXHJcbiAgICB9KTtcclxuICAgIHdhbGxldFdpbmRvdy5vcGVuKCk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRVc2VySW5mbygpIHtcclxuICAgIGNvbnN0IHVzZXJJbmZvUmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNvbW11bmljYXRpb25Qcm92aWRlci5yZXF1ZXN0KHtcclxuICAgICAgbWV0aG9kOiBDT01NVU5JQ0FUSU9OX0pSUENfTUVUSE9EUy5VU0VSX0lORk8sXHJcbiAgICAgIHBhcmFtczogW11cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHVzZXJJbmZvUmVzcG9uc2U7XHJcbiAgfVxyXG5cclxuICBhc3luYyBpbml0aWF0ZVRvcHVwKHByb3ZpZGVyLCBwYXJhbXMpIHtcclxuICAgIGlmICghdGhpcy5pc0luaXRpYWxpemVkKSB0aHJvdyBuZXcgRXJyb3IoXCJUb3J1cyBpcyBub3QgaW5pdGlhbGl6ZWRcIik7XHJcbiAgICBjb25zdCB3aW5kb3dJZCA9IGdldFdpbmRvd0lkKCk7XHJcblxyXG4gICAgdGhpcy5jb21tdW5pY2F0aW9uUHJvdmlkZXIuX2hhbmRsZVdpbmRvdyh3aW5kb3dJZCk7XHJcblxyXG4gICAgY29uc3QgdG9wdXBSZXNwb25zZSA9IGF3YWl0IHRoaXMuY29tbXVuaWNhdGlvblByb3ZpZGVyLnJlcXVlc3Qoe1xyXG4gICAgICBtZXRob2Q6IENPTU1VTklDQVRJT05fSlJQQ19NRVRIT0RTLlRPUFVQLFxyXG4gICAgICBwYXJhbXM6IHtcclxuICAgICAgICBwcm92aWRlcixcclxuICAgICAgICBwYXJhbXMsXHJcbiAgICAgICAgd2luZG93SWRcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdG9wdXBSZXNwb25zZTtcclxuICB9IC8vIFNvbGFuYSBzcGVjaWZpYyBBUElcclxuXHJcblxyXG4gIGFzeW5jIHNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLnJlcXVlc3Qoe1xyXG4gICAgICBtZXRob2Q6IFwic2VuZF90cmFuc2FjdGlvblwiLFxyXG4gICAgICAvLyBwYXJhbXM6IHsgbWVzc2FnZTogdHJhbnNhY3Rpb24uc2VyaWFsaXplTWVzc2FnZSgpLnRvU3RyaW5nKFwiaGV4XCIpIH0sXHJcbiAgICAgIHBhcmFtczoge1xyXG4gICAgICAgIG1lc3NhZ2U6IHRyYW5zYWN0aW9uLnNlcmlhbGl6ZSh7XHJcbiAgICAgICAgICByZXF1aXJlQWxsU2lnbmF0dXJlczogZmFsc2VcclxuICAgICAgICB9KS50b1N0cmluZyhcImhleFwiKVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXNwb25zZTtcclxuICB9XHJcblxyXG4gIGFzeW5jIHNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLnJlcXVlc3Qoe1xyXG4gICAgICBtZXRob2Q6IFwic2lnbl90cmFuc2FjdGlvblwiLFxyXG4gICAgICAvLyBwYXJhbXM6IHsgbWVzc2FnZTogdHJhbnNhY3Rpb24uc2VyaWFsaXplTWVzc2FnZSgpLnRvU3RyaW5nKFwiaGV4XCIpIH0sXHJcbiAgICAgIHBhcmFtczoge1xyXG4gICAgICAgIG1lc3NhZ2U6IHRyYW5zYWN0aW9uLnNlcmlhbGl6ZSh7XHJcbiAgICAgICAgICByZXF1aXJlQWxsU2lnbmF0dXJlczogZmFsc2VcclxuICAgICAgICB9KS50b1N0cmluZyhcImhleFwiKVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5mcm9tKHJlc3BvbnNlLCBcImhleFwiKTtcclxuICAgIGNvbnN0IHNlbmRUeCA9IFRyYW5zYWN0aW9uLmZyb20oYnVmKTtcclxuICAgIHJldHVybiBzZW5kVHg7XHJcbiAgfVxyXG5cclxuICBhc3luYyBzaWduQWxsVHJhbnNhY3Rpb25zKHRyYW5zYWN0aW9ucykge1xyXG4gICAgY29uc3QgZW5jb2RlZFRyYW5zYWN0aW9ucyA9IHRyYW5zYWN0aW9ucy5tYXAoeCA9PiB4LnNlcmlhbGl6ZSh7XHJcbiAgICAgIHJlcXVpcmVBbGxTaWduYXR1cmVzOiBmYWxzZVxyXG4gICAgfSkudG9TdHJpbmcoXCJoZXhcIikpO1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLnJlcXVlc3Qoe1xyXG4gICAgICBtZXRob2Q6IFwic2lnbl9hbGxfdHJhbnNhY3Rpb25zXCIsXHJcbiAgICAgIHBhcmFtczoge1xyXG4gICAgICAgIG1lc3NhZ2U6IGVuY29kZWRUcmFuc2FjdGlvbnNcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBhbGxTaWduZWRUcmFuc2FjdGlvbiA9IHJlc3BvbnNlLm1hcChtc2cgPT4gVHJhbnNhY3Rpb24uZnJvbShCdWZmZXIuZnJvbShtc2csIFwiaGV4XCIpKSk7XHJcbiAgICByZXR1cm4gYWxsU2lnbmVkVHJhbnNhY3Rpb247XHJcbiAgfVxyXG5cclxuICBhc3luYyBzaWduTWVzc2FnZShkYXRhKSB7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJvdmlkZXIucmVxdWVzdCh7XHJcbiAgICAgIG1ldGhvZDogXCJzaWduX21lc3NhZ2VcIixcclxuICAgICAgcGFyYW1zOiB7XHJcbiAgICAgICAgZGF0YVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXNwb25zZTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGdldEdhc2xlc3NQdWJsaWNLZXkoKSB7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJvdmlkZXIucmVxdWVzdCh7XHJcbiAgICAgIG1ldGhvZDogXCJnZXRfZ2FzbGVzc19wdWJsaWNfa2V5XCIsXHJcbiAgICAgIHBhcmFtczogW11cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xyXG4gIH0gLy8gYXN5bmMgY29ubmVjdCgpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICAvLyAgIGNvbnN0IHJlc3BvbnNlID0gKGF3YWl0IHRoaXMucHJvdmlkZXIucmVxdWVzdCh7XHJcbiAgLy8gICAgIG1ldGhvZDogXCJjb25uZWN0XCIsXHJcbiAgLy8gICAgIHBhcmFtczoge30sXHJcbiAgLy8gICB9KSkgYXMgYm9vbGVhbjtcclxuICAvLyAgIHJldHVybiByZXNwb25zZTtcclxuICAvLyB9XHJcblxyXG5cclxuICBoYW5kbGVEYXBwU3RvcmFnZUtleSh1c2VMb2NhbFN0b3JhZ2UpIHtcclxuICAgIGxldCBkYXBwU3RvcmFnZUtleSA9IFwiXCI7XHJcblxyXG4gICAgaWYgKGlzTG9jYWxTdG9yYWdlQXZhaWxhYmxlICYmIHVzZUxvY2FsU3RvcmFnZSkge1xyXG4gICAgICBjb25zdCBzdG9yZWRLZXkgPSB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oY29uZmlndXJhdGlvbi5sb2NhbFN0b3JhZ2VLZXkpO1xyXG4gICAgICBpZiAoc3RvcmVkS2V5KSBkYXBwU3RvcmFnZUtleSA9IHN0b3JlZEtleTtlbHNlIHtcclxuICAgICAgICBjb25zdCBnZW5lcmF0ZWRLZXkgPSBcInRvcnVzLWFwcC1cIi5jb25jYXQoZ2V0V2luZG93SWQoKSk7XHJcbiAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKGNvbmZpZ3VyYXRpb24ubG9jYWxTdG9yYWdlS2V5LCBnZW5lcmF0ZWRLZXkpO1xyXG4gICAgICAgIGRhcHBTdG9yYWdlS2V5ID0gZ2VuZXJhdGVkS2V5O1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5kYXBwU3RvcmFnZUtleSA9IGRhcHBTdG9yYWdlS2V5O1xyXG4gICAgcmV0dXJuIGRhcHBTdG9yYWdlS2V5O1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgX3NldHVwV2ViMyhwcm92aWRlclBhcmFtcykge1xyXG4gICAgbG9nLmluZm8oXCJzZXR1cFdlYjMgcnVubmluZ1wiKTsgLy8gc2V0dXAgYmFja2dyb3VuZCBjb25uZWN0aW9uXHJcblxyXG4gICAgY29uc3QgcHJvdmlkZXJTdHJlYW0gPSBuZXcgQmFzZVBvc3RNZXNzYWdlU3RyZWFtKHtcclxuICAgICAgbmFtZTogXCJlbWJlZF90b3J1c1wiLFxyXG4gICAgICB0YXJnZXQ6IFwiaWZyYW1lX3RvcnVzXCIsXHJcbiAgICAgIHRhcmdldFdpbmRvdzogdGhpcy50b3J1c0lmcmFtZS5jb250ZW50V2luZG93XHJcbiAgICB9KTsgLy8gV2UgY3JlYXRlIGFub3RoZXIgTG9jYWxNZXNzYWdlRHVwbGV4U3RyZWFtIGZvciBjb21tdW5pY2F0aW9uIGJldHdlZW4gZGFwcCA8PiBpZnJhbWVcclxuXHJcbiAgICBjb25zdCBjb21tdW5pY2F0aW9uU3RyZWFtID0gbmV3IEJhc2VQb3N0TWVzc2FnZVN0cmVhbSh7XHJcbiAgICAgIG5hbWU6IFwiZW1iZWRfY29tbXVuaWNhdGlvblwiLFxyXG4gICAgICB0YXJnZXQ6IFwiaWZyYW1lX2NvbW11bmljYXRpb25cIixcclxuICAgICAgdGFyZ2V0V2luZG93OiB0aGlzLnRvcnVzSWZyYW1lLmNvbnRlbnRXaW5kb3dcclxuICAgIH0pOyAvLyBjb21wb3NlIHRoZSBpblBhZ2UgcHJvdmlkZXJcclxuXHJcbiAgICBjb25zdCBpblBhZ2VQcm92aWRlciA9IG5ldyBUb3J1c0luUGFnZVByb3ZpZGVyKHByb3ZpZGVyU3RyZWFtLCB7fSk7XHJcbiAgICBjb25zdCBjb21tdW5pY2F0aW9uUHJvdmlkZXIgPSBuZXcgVG9ydXNDb21tdW5pY2F0aW9uUHJvdmlkZXIoY29tbXVuaWNhdGlvblN0cmVhbSwge30pO1xyXG5cclxuICAgIGluUGFnZVByb3ZpZGVyLnRyeVdpbmRvd0hhbmRsZSA9IChwYXlsb2FkLCBjYikgPT4ge1xyXG4gICAgICBjb25zdCBfcGF5bG9hZCA9IHBheWxvYWQ7XHJcblxyXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoX3BheWxvYWQpICYmIFBST1ZJREVSX1VOU0FGRV9NRVRIT0RTLmluY2x1ZGVzKF9wYXlsb2FkLm1ldGhvZCkpIHtcclxuICAgICAgICBpZiAoIXRoaXMuY29tbXVuaWNhdGlvblByb3ZpZGVyLmlzTG9nZ2VkSW4pIHRocm93IG5ldyBFcnJvcihcIlVzZXIgTm90IExvZ2dlZCBJblwiKTtcclxuICAgICAgICBjb25zdCB3aW5kb3dJZCA9IGdldFdpbmRvd0lkKCk7XHJcblxyXG4gICAgICAgIGNvbW11bmljYXRpb25Qcm92aWRlci5faGFuZGxlV2luZG93KHdpbmRvd0lkLCB7XHJcbiAgICAgICAgICB0YXJnZXQ6IFwiX2JsYW5rXCIsXHJcbiAgICAgICAgICBmZWF0dXJlczogZ2V0UG9wdXBGZWF0dXJlcyhGRUFUVVJFU19DT05GSVJNX1dJTkRPVylcclxuICAgICAgICB9KTsgLy8gZm9yIGluUGFnZVByb3ZpZGVyIG1ldGhvZHMgc2VuZGluZyB3aW5kb3dJZCBpbiByZXF1ZXN0IGluc3RlYWQgb2YgcGFyYW1zXHJcbiAgICAgICAgLy8gYXMgcGFyYW1zIG1pZ2h0IGJlIHBvc2l0aW9uYWwuXHJcblxyXG5cclxuICAgICAgICBfcGF5bG9hZC53aW5kb3dJZCA9IHdpbmRvd0lkO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpblBhZ2VQcm92aWRlci5fcnBjRW5naW5lLmhhbmRsZShfcGF5bG9hZCwgY2IpO1xyXG4gICAgfTtcclxuXHJcbiAgICBjb21tdW5pY2F0aW9uUHJvdmlkZXIudHJ5V2luZG93SGFuZGxlID0gKHBheWxvYWQsIGNiKSA9PiB7XHJcbiAgICAgIGNvbnN0IF9wYXlsb2FkID0gcGF5bG9hZDtcclxuXHJcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShfcGF5bG9hZCkgJiYgQ09NTVVOSUNBVElPTl9VTlNBRkVfTUVUSE9EUy5pbmNsdWRlcyhfcGF5bG9hZC5tZXRob2QpKSB7XHJcbiAgICAgICAgY29uc3Qgd2luZG93SWQgPSBnZXRXaW5kb3dJZCgpO1xyXG5cclxuICAgICAgICBjb21tdW5pY2F0aW9uUHJvdmlkZXIuX2hhbmRsZVdpbmRvdyh3aW5kb3dJZCwge1xyXG4gICAgICAgICAgdGFyZ2V0OiBcIl9ibGFua1wiLFxyXG4gICAgICAgICAgZmVhdHVyZXM6IGdldFBvcHVwRmVhdHVyZXMoRkVBVFVSRVNfUFJPVklERVJfQ0hBTkdFX1dJTkRPVykgLy8gdG9kbzogYXJlIHRoZXNlIGZlYXR1cmVzIGdlbmVyaWMgZm9yIGFsbFxyXG5cclxuICAgICAgICB9KTsgLy8gZm9yIGNvbW11bmljYXRpb24gbWV0aG9kcyBzZW5kaW5nIHdpbmRvdyBpZCBpbiBqcnBjIHJlcSBwYXJhbXNcclxuXHJcblxyXG4gICAgICAgIF9wYXlsb2FkLnBhcmFtcy53aW5kb3dJZCA9IHdpbmRvd0lkO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb21tdW5pY2F0aW9uUHJvdmlkZXIuX3JwY0VuZ2luZS5oYW5kbGUoX3BheWxvYWQsIGNiKTtcclxuICAgIH07IC8vIGRldGVjdCBzb2xhbmFfcmVxdWVzdEFjY291bnRzIGFuZCBwaXBlIHRvIGVuYWJsZSBmb3Igbm93XHJcblxyXG5cclxuICAgIGNvbnN0IGRldGVjdEFjY291bnRSZXF1ZXN0UHJvdG90eXBlTW9kaWZpZXIgPSBtID0+IHtcclxuICAgICAgY29uc3Qgb3JpZ2luYWxNZXRob2QgPSBpblBhZ2VQcm92aWRlclttXTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXHJcblxyXG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgIGluUGFnZVByb3ZpZGVyW21dID0gZnVuY3Rpb24gcHJvdmlkZXJGdW5jKHJlcXVlc3QsIGNiKSB7XHJcbiAgICAgICAgY29uc3Qge1xyXG4gICAgICAgICAgbWV0aG9kLFxyXG4gICAgICAgICAgcGFyYW1zID0gW11cclxuICAgICAgICB9ID0gcmVxdWVzdDtcclxuXHJcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJzb2xhbmFfcmVxdWVzdEFjY291bnRzXCIpIHtcclxuICAgICAgICAgIGlmICghY2IpIHJldHVybiBzZWxmLmxvZ2luKHtcclxuICAgICAgICAgICAgbG9naW5Qcm92aWRlcjogcGFyYW1zWzBdXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIHNlbGYubG9naW4oe1xyXG4gICAgICAgICAgICBsb2dpblByb3ZpZGVyOiBwYXJhbXNbMF1cclxuICAgICAgICAgIH0pIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcm9taXNlL25vLWNhbGxiYWNrLWluLXByb21pc2VcclxuICAgICAgICAgIC50aGVuKHJlcyA9PiBjYihudWxsLCByZXMpKSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJvbWlzZS9uby1jYWxsYmFjay1pbi1wcm9taXNlXHJcbiAgICAgICAgICAuY2F0Y2goZXJyID0+IGNiKGVycikpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsTWV0aG9kLmFwcGx5KHRoaXMsIFtyZXF1ZXN0LCBjYl0pO1xyXG4gICAgICB9O1xyXG4gICAgfTsgLy8gRGV0ZWN0cyBjYWxsIHRvIHNvbGFuYV9yZXF1ZXN0QWNjb3VudHMgaW4gcmVxdWVzdCAmIHNlbmRBc3luYyBhbmQgcGFzc2VzIHRvIGxvZ2luXHJcblxyXG5cclxuICAgIGRldGVjdEFjY291bnRSZXF1ZXN0UHJvdG90eXBlTW9kaWZpZXIoXCJyZXF1ZXN0XCIpO1xyXG4gICAgZGV0ZWN0QWNjb3VudFJlcXVlc3RQcm90b3R5cGVNb2RpZmllcihcInNlbmRBc3luY1wiKTtcclxuICAgIGRldGVjdEFjY291bnRSZXF1ZXN0UHJvdG90eXBlTW9kaWZpZXIoXCJzZW5kXCIpO1xyXG4gICAgY29uc3QgcHJveGllZEluUGFnZVByb3ZpZGVyID0gbmV3IFByb3h5KGluUGFnZVByb3ZpZGVyLCB7XHJcbiAgICAgIC8vIHN0cmFpZ2h0IHVwIGxpZSB0aGF0IHdlIGRlbGV0ZWQgdGhlIHByb3BlcnR5IHNvIHRoYXQgaXQgZG9lc24ndFxyXG4gICAgICAvLyB0aHJvdyBhbiBlcnJvciBpbiBzdHJpY3QgbW9kZVxyXG4gICAgICBkZWxldGVQcm9wZXJ0eTogKCkgPT4gdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBwcm94aWVkQ29tbXVuaWNhdGlvblByb3ZpZGVyID0gbmV3IFByb3h5KGNvbW11bmljYXRpb25Qcm92aWRlciwge1xyXG4gICAgICAvLyBzdHJhaWdodCB1cCBsaWUgdGhhdCB3ZSBkZWxldGVkIHRoZSBwcm9wZXJ0eSBzbyB0aGF0IGl0IGRvZXNuJ3RcclxuICAgICAgLy8gdGhyb3cgYW4gZXJyb3IgaW4gc3RyaWN0IG1vZGVcclxuICAgICAgZGVsZXRlUHJvcGVydHk6ICgpID0+IHRydWVcclxuICAgIH0pO1xyXG4gICAgdGhpcy5wcm92aWRlciA9IHByb3hpZWRJblBhZ2VQcm92aWRlcjtcclxuICAgIHRoaXMuY29tbXVuaWNhdGlvblByb3ZpZGVyID0gcHJveGllZENvbW11bmljYXRpb25Qcm92aWRlcjtcclxuICAgIGF3YWl0IFByb21pc2UuYWxsKFtpblBhZ2VQcm92aWRlci5faW5pdGlhbGl6ZVN0YXRlKCksIGNvbW11bmljYXRpb25Qcm92aWRlci5faW5pdGlhbGl6ZVN0YXRlKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcHJvdmlkZXJQYXJhbXMpLCB7fSwge1xyXG4gICAgICBkYXBwU3RvcmFnZUtleTogdGhpcy5kYXBwU3RvcmFnZUtleSxcclxuICAgICAgdG9ydXNBbGVydENvbnRhaW5lcjogdGhpcy50b3J1c0FsZXJ0Q29udGFpbmVyLFxyXG4gICAgICB0b3J1c0lmcmFtZTogdGhpcy50b3J1c0lmcmFtZVxyXG4gICAgfSkpXSk7XHJcbiAgICBsb2cuZGVidWcoXCJUb3J1cyAtIGluamVjdGVkIHByb3ZpZGVyXCIpO1xyXG4gIH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IEJVVFRPTl9QT1NJVElPTiwgTE9HSU5fUFJPVklERVIsIFBBWU1FTlRfUFJPVklERVIsIFRPUlVTX0JVSUxEX0VOViwgVG9ydXNJblBhZ2VQcm92aWRlciwgVG9ydXMgYXMgZGVmYXVsdCB9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zb2xhbmFFbWJlZC5lc20uanMubWFwXHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@toruslabs/solana-embed/dist/solanaEmbed.esm.js\n");

/***/ }),

/***/ "./node_modules/assert/build/assert.js":
/*!*********************************************!*\
  !*** ./node_modules/assert/build/assert.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/process/browser.js\");\n// Currently in sync with Node.js lib/assert.js\r\n// https://github.com/nodejs/node/commit/2a51ae424a513ec9a6aa3466baa0cc1d55dd4f3b\r\n// Originally from narwhal.js (http://narwhaljs.org)\r\n// Copyright (c) 2009 Thomas Robinson <280north.com>\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy\r\n// of this software and associated documentation files (the 'Software'), to\r\n// deal in the Software without restriction, including without limitation the\r\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\r\n// sell copies of the Software, and to permit persons to whom the Software is\r\n// furnished to do so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in\r\n// all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\r\n// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n\r\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nvar _require = __webpack_require__(/*! ./internal/errors */ \"./node_modules/assert/build/internal/errors.js\"),\r\n    _require$codes = _require.codes,\r\n    ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT,\r\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\r\n    ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE,\r\n    ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE,\r\n    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;\r\n\r\nvar AssertionError = __webpack_require__(/*! ./internal/assert/assertion_error */ \"./node_modules/assert/build/internal/assert/assertion_error.js\");\r\n\r\nvar _require2 = __webpack_require__(/*! util/ */ \"./node_modules/util/util.js\"),\r\n    inspect = _require2.inspect;\r\n\r\nvar _require$types = (__webpack_require__(/*! util/ */ \"./node_modules/util/util.js\").types),\r\n    isPromise = _require$types.isPromise,\r\n    isRegExp = _require$types.isRegExp;\r\n\r\nvar objectAssign = Object.assign ? Object.assign : (__webpack_require__(/*! es6-object-assign */ \"./node_modules/es6-object-assign/index.js\").assign);\r\nvar objectIs = Object.is ? Object.is : __webpack_require__(/*! object-is */ \"./node_modules/object-is/index.js\");\r\nvar errorCache = new Map();\r\nvar isDeepEqual;\r\nvar isDeepStrictEqual;\r\nvar parseExpressionAt;\r\nvar findNodeAround;\r\nvar decoder;\r\n\r\nfunction lazyLoadComparison() {\r\n  var comparison = __webpack_require__(/*! ./internal/util/comparisons */ \"./node_modules/assert/build/internal/util/comparisons.js\");\r\n\r\n  isDeepEqual = comparison.isDeepEqual;\r\n  isDeepStrictEqual = comparison.isDeepStrictEqual;\r\n} // Escape control characters but not \\n and \\t to keep the line breaks and\r\n// indentation intact.\r\n// eslint-disable-next-line no-control-regex\r\n\r\n\r\nvar escapeSequencesRegExp = /[\\x00-\\x08\\x0b\\x0c\\x0e-\\x1f]/g;\r\nvar meta = [\"\\\\u0000\", \"\\\\u0001\", \"\\\\u0002\", \"\\\\u0003\", \"\\\\u0004\", \"\\\\u0005\", \"\\\\u0006\", \"\\\\u0007\", '\\\\b', '', '', \"\\\\u000b\", '\\\\f', '', \"\\\\u000e\", \"\\\\u000f\", \"\\\\u0010\", \"\\\\u0011\", \"\\\\u0012\", \"\\\\u0013\", \"\\\\u0014\", \"\\\\u0015\", \"\\\\u0016\", \"\\\\u0017\", \"\\\\u0018\", \"\\\\u0019\", \"\\\\u001a\", \"\\\\u001b\", \"\\\\u001c\", \"\\\\u001d\", \"\\\\u001e\", \"\\\\u001f\"];\r\n\r\nvar escapeFn = function escapeFn(str) {\r\n  return meta[str.charCodeAt(0)];\r\n};\r\n\r\nvar warned = false; // The assert module provides functions that throw\r\n// AssertionError's when particular conditions are not met. The\r\n// assert module must conform to the following interface.\r\n\r\nvar assert = module.exports = ok;\r\nvar NO_EXCEPTION_SENTINEL = {}; // All of the following functions must throw an AssertionError\r\n// when a corresponding condition is not met, with a message that\r\n// may be undefined if not provided. All assertion methods provide\r\n// both the actual and expected values to the assertion error for\r\n// display purposes.\r\n\r\nfunction innerFail(obj) {\r\n  if (obj.message instanceof Error) throw obj.message;\r\n  throw new AssertionError(obj);\r\n}\r\n\r\nfunction fail(actual, expected, message, operator, stackStartFn) {\r\n  var argsLen = arguments.length;\r\n  var internalMessage;\r\n\r\n  if (argsLen === 0) {\r\n    internalMessage = 'Failed';\r\n  } else if (argsLen === 1) {\r\n    message = actual;\r\n    actual = undefined;\r\n  } else {\r\n    if (warned === false) {\r\n      warned = true;\r\n      var warn = process.emitWarning ? process.emitWarning : console.warn.bind(console);\r\n      warn('assert.fail() with more than one argument is deprecated. ' + 'Please use assert.strictEqual() instead or only pass a message.', 'DeprecationWarning', 'DEP0094');\r\n    }\r\n\r\n    if (argsLen === 2) operator = '!=';\r\n  }\r\n\r\n  if (message instanceof Error) throw message;\r\n  var errArgs = {\r\n    actual: actual,\r\n    expected: expected,\r\n    operator: operator === undefined ? 'fail' : operator,\r\n    stackStartFn: stackStartFn || fail\r\n  };\r\n\r\n  if (message !== undefined) {\r\n    errArgs.message = message;\r\n  }\r\n\r\n  var err = new AssertionError(errArgs);\r\n\r\n  if (internalMessage) {\r\n    err.message = internalMessage;\r\n    err.generatedMessage = true;\r\n  }\r\n\r\n  throw err;\r\n}\r\n\r\nassert.fail = fail; // The AssertionError is defined in internal/error.\r\n\r\nassert.AssertionError = AssertionError;\r\n\r\nfunction innerOk(fn, argLen, value, message) {\r\n  if (!value) {\r\n    var generatedMessage = false;\r\n\r\n    if (argLen === 0) {\r\n      generatedMessage = true;\r\n      message = 'No value argument passed to `assert.ok()`';\r\n    } else if (message instanceof Error) {\r\n      throw message;\r\n    }\r\n\r\n    var err = new AssertionError({\r\n      actual: value,\r\n      expected: true,\r\n      message: message,\r\n      operator: '==',\r\n      stackStartFn: fn\r\n    });\r\n    err.generatedMessage = generatedMessage;\r\n    throw err;\r\n  }\r\n} // Pure assertion tests whether a value is truthy, as determined\r\n// by !!value.\r\n\r\n\r\nfunction ok() {\r\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\r\n    args[_key] = arguments[_key];\r\n  }\r\n\r\n  innerOk.apply(void 0, [ok, args.length].concat(args));\r\n}\r\n\r\nassert.ok = ok; // The equality assertion tests shallow, coercive equality with ==.\r\n\r\n/* eslint-disable no-restricted-properties */\r\n\r\nassert.equal = function equal(actual, expected, message) {\r\n  if (arguments.length < 2) {\r\n    throw new ERR_MISSING_ARGS('actual', 'expected');\r\n  } // eslint-disable-next-line eqeqeq\r\n\r\n\r\n  if (actual != expected) {\r\n    innerFail({\r\n      actual: actual,\r\n      expected: expected,\r\n      message: message,\r\n      operator: '==',\r\n      stackStartFn: equal\r\n    });\r\n  }\r\n}; // The non-equality assertion tests for whether two objects are not\r\n// equal with !=.\r\n\r\n\r\nassert.notEqual = function notEqual(actual, expected, message) {\r\n  if (arguments.length < 2) {\r\n    throw new ERR_MISSING_ARGS('actual', 'expected');\r\n  } // eslint-disable-next-line eqeqeq\r\n\r\n\r\n  if (actual == expected) {\r\n    innerFail({\r\n      actual: actual,\r\n      expected: expected,\r\n      message: message,\r\n      operator: '!=',\r\n      stackStartFn: notEqual\r\n    });\r\n  }\r\n}; // The equivalence assertion tests a deep equality relation.\r\n\r\n\r\nassert.deepEqual = function deepEqual(actual, expected, message) {\r\n  if (arguments.length < 2) {\r\n    throw new ERR_MISSING_ARGS('actual', 'expected');\r\n  }\r\n\r\n  if (isDeepEqual === undefined) lazyLoadComparison();\r\n\r\n  if (!isDeepEqual(actual, expected)) {\r\n    innerFail({\r\n      actual: actual,\r\n      expected: expected,\r\n      message: message,\r\n      operator: 'deepEqual',\r\n      stackStartFn: deepEqual\r\n    });\r\n  }\r\n}; // The non-equivalence assertion tests for any deep inequality.\r\n\r\n\r\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\r\n  if (arguments.length < 2) {\r\n    throw new ERR_MISSING_ARGS('actual', 'expected');\r\n  }\r\n\r\n  if (isDeepEqual === undefined) lazyLoadComparison();\r\n\r\n  if (isDeepEqual(actual, expected)) {\r\n    innerFail({\r\n      actual: actual,\r\n      expected: expected,\r\n      message: message,\r\n      operator: 'notDeepEqual',\r\n      stackStartFn: notDeepEqual\r\n    });\r\n  }\r\n};\r\n/* eslint-enable */\r\n\r\n\r\nassert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {\r\n  if (arguments.length < 2) {\r\n    throw new ERR_MISSING_ARGS('actual', 'expected');\r\n  }\r\n\r\n  if (isDeepEqual === undefined) lazyLoadComparison();\r\n\r\n  if (!isDeepStrictEqual(actual, expected)) {\r\n    innerFail({\r\n      actual: actual,\r\n      expected: expected,\r\n      message: message,\r\n      operator: 'deepStrictEqual',\r\n      stackStartFn: deepStrictEqual\r\n    });\r\n  }\r\n};\r\n\r\nassert.notDeepStrictEqual = notDeepStrictEqual;\r\n\r\nfunction notDeepStrictEqual(actual, expected, message) {\r\n  if (arguments.length < 2) {\r\n    throw new ERR_MISSING_ARGS('actual', 'expected');\r\n  }\r\n\r\n  if (isDeepEqual === undefined) lazyLoadComparison();\r\n\r\n  if (isDeepStrictEqual(actual, expected)) {\r\n    innerFail({\r\n      actual: actual,\r\n      expected: expected,\r\n      message: message,\r\n      operator: 'notDeepStrictEqual',\r\n      stackStartFn: notDeepStrictEqual\r\n    });\r\n  }\r\n}\r\n\r\nassert.strictEqual = function strictEqual(actual, expected, message) {\r\n  if (arguments.length < 2) {\r\n    throw new ERR_MISSING_ARGS('actual', 'expected');\r\n  }\r\n\r\n  if (!objectIs(actual, expected)) {\r\n    innerFail({\r\n      actual: actual,\r\n      expected: expected,\r\n      message: message,\r\n      operator: 'strictEqual',\r\n      stackStartFn: strictEqual\r\n    });\r\n  }\r\n};\r\n\r\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\r\n  if (arguments.length < 2) {\r\n    throw new ERR_MISSING_ARGS('actual', 'expected');\r\n  }\r\n\r\n  if (objectIs(actual, expected)) {\r\n    innerFail({\r\n      actual: actual,\r\n      expected: expected,\r\n      message: message,\r\n      operator: 'notStrictEqual',\r\n      stackStartFn: notStrictEqual\r\n    });\r\n  }\r\n};\r\n\r\nvar Comparison = function Comparison(obj, keys, actual) {\r\n  var _this = this;\r\n\r\n  _classCallCheck(this, Comparison);\r\n\r\n  keys.forEach(function (key) {\r\n    if (key in obj) {\r\n      if (actual !== undefined && typeof actual[key] === 'string' && isRegExp(obj[key]) && obj[key].test(actual[key])) {\r\n        _this[key] = actual[key];\r\n      } else {\r\n        _this[key] = obj[key];\r\n      }\r\n    }\r\n  });\r\n};\r\n\r\nfunction compareExceptionKey(actual, expected, key, message, keys, fn) {\r\n  if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {\r\n    if (!message) {\r\n      // Create placeholder objects to create a nice output.\r\n      var a = new Comparison(actual, keys);\r\n      var b = new Comparison(expected, keys, actual);\r\n      var err = new AssertionError({\r\n        actual: a,\r\n        expected: b,\r\n        operator: 'deepStrictEqual',\r\n        stackStartFn: fn\r\n      });\r\n      err.actual = actual;\r\n      err.expected = expected;\r\n      err.operator = fn.name;\r\n      throw err;\r\n    }\r\n\r\n    innerFail({\r\n      actual: actual,\r\n      expected: expected,\r\n      message: message,\r\n      operator: fn.name,\r\n      stackStartFn: fn\r\n    });\r\n  }\r\n}\r\n\r\nfunction expectedException(actual, expected, msg, fn) {\r\n  if (typeof expected !== 'function') {\r\n    if (isRegExp(expected)) return expected.test(actual); // assert.doesNotThrow does not accept objects.\r\n\r\n    if (arguments.length === 2) {\r\n      throw new ERR_INVALID_ARG_TYPE('expected', ['Function', 'RegExp'], expected);\r\n    } // Handle primitives properly.\r\n\r\n\r\n    if (_typeof(actual) !== 'object' || actual === null) {\r\n      var err = new AssertionError({\r\n        actual: actual,\r\n        expected: expected,\r\n        message: msg,\r\n        operator: 'deepStrictEqual',\r\n        stackStartFn: fn\r\n      });\r\n      err.operator = fn.name;\r\n      throw err;\r\n    }\r\n\r\n    var keys = Object.keys(expected); // Special handle errors to make sure the name and the message are compared\r\n    // as well.\r\n\r\n    if (expected instanceof Error) {\r\n      keys.push('name', 'message');\r\n    } else if (keys.length === 0) {\r\n      throw new ERR_INVALID_ARG_VALUE('error', expected, 'may not be an empty object');\r\n    }\r\n\r\n    if (isDeepEqual === undefined) lazyLoadComparison();\r\n    keys.forEach(function (key) {\r\n      if (typeof actual[key] === 'string' && isRegExp(expected[key]) && expected[key].test(actual[key])) {\r\n        return;\r\n      }\r\n\r\n      compareExceptionKey(actual, expected, key, msg, keys, fn);\r\n    });\r\n    return true;\r\n  } // Guard instanceof against arrow functions as they don't have a prototype.\r\n\r\n\r\n  if (expected.prototype !== undefined && actual instanceof expected) {\r\n    return true;\r\n  }\r\n\r\n  if (Error.isPrototypeOf(expected)) {\r\n    return false;\r\n  }\r\n\r\n  return expected.call({}, actual) === true;\r\n}\r\n\r\nfunction getActual(fn) {\r\n  if (typeof fn !== 'function') {\r\n    throw new ERR_INVALID_ARG_TYPE('fn', 'Function', fn);\r\n  }\r\n\r\n  try {\r\n    fn();\r\n  } catch (e) {\r\n    return e;\r\n  }\r\n\r\n  return NO_EXCEPTION_SENTINEL;\r\n}\r\n\r\nfunction checkIsPromise(obj) {\r\n  // Accept native ES6 promises and promises that are implemented in a similar\r\n  // way. Do not accept thenables that use a function as `obj` and that have no\r\n  // `catch` handler.\r\n  // TODO: thenables are checked up until they have the correct methods,\r\n  // but according to documentation, the `then` method should receive\r\n  // the `fulfill` and `reject` arguments as well or it may be never resolved.\r\n  return isPromise(obj) || obj !== null && _typeof(obj) === 'object' && typeof obj.then === 'function' && typeof obj.catch === 'function';\r\n}\r\n\r\nfunction waitForActual(promiseFn) {\r\n  return Promise.resolve().then(function () {\r\n    var resultPromise;\r\n\r\n    if (typeof promiseFn === 'function') {\r\n      // Return a rejected promise if `promiseFn` throws synchronously.\r\n      resultPromise = promiseFn(); // Fail in case no promise is returned.\r\n\r\n      if (!checkIsPromise(resultPromise)) {\r\n        throw new ERR_INVALID_RETURN_VALUE('instance of Promise', 'promiseFn', resultPromise);\r\n      }\r\n    } else if (checkIsPromise(promiseFn)) {\r\n      resultPromise = promiseFn;\r\n    } else {\r\n      throw new ERR_INVALID_ARG_TYPE('promiseFn', ['Function', 'Promise'], promiseFn);\r\n    }\r\n\r\n    return Promise.resolve().then(function () {\r\n      return resultPromise;\r\n    }).then(function () {\r\n      return NO_EXCEPTION_SENTINEL;\r\n    }).catch(function (e) {\r\n      return e;\r\n    });\r\n  });\r\n}\r\n\r\nfunction expectsError(stackStartFn, actual, error, message) {\r\n  if (typeof error === 'string') {\r\n    if (arguments.length === 4) {\r\n      throw new ERR_INVALID_ARG_TYPE('error', ['Object', 'Error', 'Function', 'RegExp'], error);\r\n    }\r\n\r\n    if (_typeof(actual) === 'object' && actual !== null) {\r\n      if (actual.message === error) {\r\n        throw new ERR_AMBIGUOUS_ARGUMENT('error/message', \"The error message \\\"\".concat(actual.message, \"\\\" is identical to the message.\"));\r\n      }\r\n    } else if (actual === error) {\r\n      throw new ERR_AMBIGUOUS_ARGUMENT('error/message', \"The error \\\"\".concat(actual, \"\\\" is identical to the message.\"));\r\n    }\r\n\r\n    message = error;\r\n    error = undefined;\r\n  } else if (error != null && _typeof(error) !== 'object' && typeof error !== 'function') {\r\n    throw new ERR_INVALID_ARG_TYPE('error', ['Object', 'Error', 'Function', 'RegExp'], error);\r\n  }\r\n\r\n  if (actual === NO_EXCEPTION_SENTINEL) {\r\n    var details = '';\r\n\r\n    if (error && error.name) {\r\n      details += \" (\".concat(error.name, \")\");\r\n    }\r\n\r\n    details += message ? \": \".concat(message) : '.';\r\n    var fnType = stackStartFn.name === 'rejects' ? 'rejection' : 'exception';\r\n    innerFail({\r\n      actual: undefined,\r\n      expected: error,\r\n      operator: stackStartFn.name,\r\n      message: \"Missing expected \".concat(fnType).concat(details),\r\n      stackStartFn: stackStartFn\r\n    });\r\n  }\r\n\r\n  if (error && !expectedException(actual, error, message, stackStartFn)) {\r\n    throw actual;\r\n  }\r\n}\r\n\r\nfunction expectsNoError(stackStartFn, actual, error, message) {\r\n  if (actual === NO_EXCEPTION_SENTINEL) return;\r\n\r\n  if (typeof error === 'string') {\r\n    message = error;\r\n    error = undefined;\r\n  }\r\n\r\n  if (!error || expectedException(actual, error)) {\r\n    var details = message ? \": \".concat(message) : '.';\r\n    var fnType = stackStartFn.name === 'doesNotReject' ? 'rejection' : 'exception';\r\n    innerFail({\r\n      actual: actual,\r\n      expected: error,\r\n      operator: stackStartFn.name,\r\n      message: \"Got unwanted \".concat(fnType).concat(details, \"\\n\") + \"Actual message: \\\"\".concat(actual && actual.message, \"\\\"\"),\r\n      stackStartFn: stackStartFn\r\n    });\r\n  }\r\n\r\n  throw actual;\r\n}\r\n\r\nassert.throws = function throws(promiseFn) {\r\n  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\r\n    args[_key2 - 1] = arguments[_key2];\r\n  }\r\n\r\n  expectsError.apply(void 0, [throws, getActual(promiseFn)].concat(args));\r\n};\r\n\r\nassert.rejects = function rejects(promiseFn) {\r\n  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\r\n    args[_key3 - 1] = arguments[_key3];\r\n  }\r\n\r\n  return waitForActual(promiseFn).then(function (result) {\r\n    return expectsError.apply(void 0, [rejects, result].concat(args));\r\n  });\r\n};\r\n\r\nassert.doesNotThrow = function doesNotThrow(fn) {\r\n  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\r\n    args[_key4 - 1] = arguments[_key4];\r\n  }\r\n\r\n  expectsNoError.apply(void 0, [doesNotThrow, getActual(fn)].concat(args));\r\n};\r\n\r\nassert.doesNotReject = function doesNotReject(fn) {\r\n  for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\r\n    args[_key5 - 1] = arguments[_key5];\r\n  }\r\n\r\n  return waitForActual(fn).then(function (result) {\r\n    return expectsNoError.apply(void 0, [doesNotReject, result].concat(args));\r\n  });\r\n};\r\n\r\nassert.ifError = function ifError(err) {\r\n  if (err !== null && err !== undefined) {\r\n    var message = 'ifError got unwanted exception: ';\r\n\r\n    if (_typeof(err) === 'object' && typeof err.message === 'string') {\r\n      if (err.message.length === 0 && err.constructor) {\r\n        message += err.constructor.name;\r\n      } else {\r\n        message += err.message;\r\n      }\r\n    } else {\r\n      message += inspect(err);\r\n    }\r\n\r\n    var newErr = new AssertionError({\r\n      actual: err,\r\n      expected: null,\r\n      operator: 'ifError',\r\n      message: message,\r\n      stackStartFn: ifError\r\n    }); // Make sure we actually have a stack trace!\r\n\r\n    var origStack = err.stack;\r\n\r\n    if (typeof origStack === 'string') {\r\n      // This will remove any duplicated frames from the error frames taken\r\n      // from within `ifError` and add the original error frames to the newly\r\n      // created ones.\r\n      var tmp2 = origStack.split('\\n');\r\n      tmp2.shift(); // Filter all frames existing in err.stack.\r\n\r\n      var tmp1 = newErr.stack.split('\\n');\r\n\r\n      for (var i = 0; i < tmp2.length; i++) {\r\n        // Find the first occurrence of the frame.\r\n        var pos = tmp1.indexOf(tmp2[i]);\r\n\r\n        if (pos !== -1) {\r\n          // Only keep new frames.\r\n          tmp1 = tmp1.slice(0, pos);\r\n          break;\r\n        }\r\n      }\r\n\r\n      newErr.stack = \"\".concat(tmp1.join('\\n'), \"\\n\").concat(tmp2.join('\\n'));\r\n    }\r\n\r\n    throw newErr;\r\n  }\r\n}; // Expose a strict only variant of assert\r\n\r\n\r\nfunction strict() {\r\n  for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\r\n    args[_key6] = arguments[_key6];\r\n  }\r\n\r\n  innerOk.apply(void 0, [strict, args.length].concat(args));\r\n}\r\n\r\nassert.strict = objectAssign(strict, assert, {\r\n  equal: assert.strictEqual,\r\n  deepEqual: assert.deepStrictEqual,\r\n  notEqual: assert.notStrictEqual,\r\n  notDeepEqual: assert.notDeepStrictEqual\r\n});\r\nassert.strict.strict = assert.strict;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLGVBQWU7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkYsZUFBZTtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RixlQUFlO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLGVBQWU7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUc7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxlQUFlO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2Fzc2VydC9idWlsZC9hc3NlcnQuanM/YmJkNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDdXJyZW50bHkgaW4gc3luYyB3aXRoIE5vZGUuanMgbGliL2Fzc2VydC5qc1xyXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvY29tbWl0LzJhNTFhZTQyNGE1MTNlYzlhNmFhMzQ2NmJhYTBjYzFkNTVkZDRmM2JcclxuLy8gT3JpZ2luYWxseSBmcm9tIG5hcndoYWwuanMgKGh0dHA6Ly9uYXJ3aGFsanMub3JnKVxyXG4vLyBDb3B5cmlnaHQgKGMpIDIwMDkgVGhvbWFzIFJvYmluc29uIDwyODBub3J0aC5jb20+XHJcbi8vXHJcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcclxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgJ1NvZnR3YXJlJyksIHRvXHJcbi8vIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXHJcbi8vIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vclxyXG4vLyBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xyXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG4vL1xyXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxyXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuLy9cclxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICdBUyBJUycsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcclxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXHJcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxyXG4vLyBBVVRIT1JTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxyXG4vLyBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXHJcbi8vIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxyXG5cclxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cclxuXHJcbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvZXJyb3JzJyksXHJcbiAgICBfcmVxdWlyZSRjb2RlcyA9IF9yZXF1aXJlLmNvZGVzLFxyXG4gICAgRVJSX0FNQklHVU9VU19BUkdVTUVOVCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9BTUJJR1VPVVNfQVJHVU1FTlQsXHJcbiAgICBFUlJfSU5WQUxJRF9BUkdfVFlQRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9JTlZBTElEX0FSR19UWVBFLFxyXG4gICAgRVJSX0lOVkFMSURfQVJHX1ZBTFVFID0gX3JlcXVpcmUkY29kZXMuRVJSX0lOVkFMSURfQVJHX1ZBTFVFLFxyXG4gICAgRVJSX0lOVkFMSURfUkVUVVJOX1ZBTFVFID0gX3JlcXVpcmUkY29kZXMuRVJSX0lOVkFMSURfUkVUVVJOX1ZBTFVFLFxyXG4gICAgRVJSX01JU1NJTkdfQVJHUyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NSVNTSU5HX0FSR1M7XHJcblxyXG52YXIgQXNzZXJ0aW9uRXJyb3IgPSByZXF1aXJlKCcuL2ludGVybmFsL2Fzc2VydC9hc3NlcnRpb25fZXJyb3InKTtcclxuXHJcbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKCd1dGlsLycpLFxyXG4gICAgaW5zcGVjdCA9IF9yZXF1aXJlMi5pbnNwZWN0O1xyXG5cclxudmFyIF9yZXF1aXJlJHR5cGVzID0gcmVxdWlyZSgndXRpbC8nKS50eXBlcyxcclxuICAgIGlzUHJvbWlzZSA9IF9yZXF1aXJlJHR5cGVzLmlzUHJvbWlzZSxcclxuICAgIGlzUmVnRXhwID0gX3JlcXVpcmUkdHlwZXMuaXNSZWdFeHA7XHJcblxyXG52YXIgb2JqZWN0QXNzaWduID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24gOiByZXF1aXJlKCdlczYtb2JqZWN0LWFzc2lnbicpLmFzc2lnbjtcclxudmFyIG9iamVjdElzID0gT2JqZWN0LmlzID8gT2JqZWN0LmlzIDogcmVxdWlyZSgnb2JqZWN0LWlzJyk7XHJcbnZhciBlcnJvckNhY2hlID0gbmV3IE1hcCgpO1xyXG52YXIgaXNEZWVwRXF1YWw7XHJcbnZhciBpc0RlZXBTdHJpY3RFcXVhbDtcclxudmFyIHBhcnNlRXhwcmVzc2lvbkF0O1xyXG52YXIgZmluZE5vZGVBcm91bmQ7XHJcbnZhciBkZWNvZGVyO1xyXG5cclxuZnVuY3Rpb24gbGF6eUxvYWRDb21wYXJpc29uKCkge1xyXG4gIHZhciBjb21wYXJpc29uID0gcmVxdWlyZSgnLi9pbnRlcm5hbC91dGlsL2NvbXBhcmlzb25zJyk7XHJcblxyXG4gIGlzRGVlcEVxdWFsID0gY29tcGFyaXNvbi5pc0RlZXBFcXVhbDtcclxuICBpc0RlZXBTdHJpY3RFcXVhbCA9IGNvbXBhcmlzb24uaXNEZWVwU3RyaWN0RXF1YWw7XHJcbn0gLy8gRXNjYXBlIGNvbnRyb2wgY2hhcmFjdGVycyBidXQgbm90IFxcbiBhbmQgXFx0IHRvIGtlZXAgdGhlIGxpbmUgYnJlYWtzIGFuZFxyXG4vLyBpbmRlbnRhdGlvbiBpbnRhY3QuXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250cm9sLXJlZ2V4XHJcblxyXG5cclxudmFyIGVzY2FwZVNlcXVlbmNlc1JlZ0V4cCA9IC9bXFx4MDAtXFx4MDhcXHgwYlxceDBjXFx4MGUtXFx4MWZdL2c7XHJcbnZhciBtZXRhID0gW1wiXFxcXHUwMDAwXCIsIFwiXFxcXHUwMDAxXCIsIFwiXFxcXHUwMDAyXCIsIFwiXFxcXHUwMDAzXCIsIFwiXFxcXHUwMDA0XCIsIFwiXFxcXHUwMDA1XCIsIFwiXFxcXHUwMDA2XCIsIFwiXFxcXHUwMDA3XCIsICdcXFxcYicsICcnLCAnJywgXCJcXFxcdTAwMGJcIiwgJ1xcXFxmJywgJycsIFwiXFxcXHUwMDBlXCIsIFwiXFxcXHUwMDBmXCIsIFwiXFxcXHUwMDEwXCIsIFwiXFxcXHUwMDExXCIsIFwiXFxcXHUwMDEyXCIsIFwiXFxcXHUwMDEzXCIsIFwiXFxcXHUwMDE0XCIsIFwiXFxcXHUwMDE1XCIsIFwiXFxcXHUwMDE2XCIsIFwiXFxcXHUwMDE3XCIsIFwiXFxcXHUwMDE4XCIsIFwiXFxcXHUwMDE5XCIsIFwiXFxcXHUwMDFhXCIsIFwiXFxcXHUwMDFiXCIsIFwiXFxcXHUwMDFjXCIsIFwiXFxcXHUwMDFkXCIsIFwiXFxcXHUwMDFlXCIsIFwiXFxcXHUwMDFmXCJdO1xyXG5cclxudmFyIGVzY2FwZUZuID0gZnVuY3Rpb24gZXNjYXBlRm4oc3RyKSB7XHJcbiAgcmV0dXJuIG1ldGFbc3RyLmNoYXJDb2RlQXQoMCldO1xyXG59O1xyXG5cclxudmFyIHdhcm5lZCA9IGZhbHNlOyAvLyBUaGUgYXNzZXJ0IG1vZHVsZSBwcm92aWRlcyBmdW5jdGlvbnMgdGhhdCB0aHJvd1xyXG4vLyBBc3NlcnRpb25FcnJvcidzIHdoZW4gcGFydGljdWxhciBjb25kaXRpb25zIGFyZSBub3QgbWV0LiBUaGVcclxuLy8gYXNzZXJ0IG1vZHVsZSBtdXN0IGNvbmZvcm0gdG8gdGhlIGZvbGxvd2luZyBpbnRlcmZhY2UuXHJcblxyXG52YXIgYXNzZXJ0ID0gbW9kdWxlLmV4cG9ydHMgPSBvaztcclxudmFyIE5PX0VYQ0VQVElPTl9TRU5USU5FTCA9IHt9OyAvLyBBbGwgb2YgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgbXVzdCB0aHJvdyBhbiBBc3NlcnRpb25FcnJvclxyXG4vLyB3aGVuIGEgY29ycmVzcG9uZGluZyBjb25kaXRpb24gaXMgbm90IG1ldCwgd2l0aCBhIG1lc3NhZ2UgdGhhdFxyXG4vLyBtYXkgYmUgdW5kZWZpbmVkIGlmIG5vdCBwcm92aWRlZC4gQWxsIGFzc2VydGlvbiBtZXRob2RzIHByb3ZpZGVcclxuLy8gYm90aCB0aGUgYWN0dWFsIGFuZCBleHBlY3RlZCB2YWx1ZXMgdG8gdGhlIGFzc2VydGlvbiBlcnJvciBmb3JcclxuLy8gZGlzcGxheSBwdXJwb3Nlcy5cclxuXHJcbmZ1bmN0aW9uIGlubmVyRmFpbChvYmopIHtcclxuICBpZiAob2JqLm1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikgdGhyb3cgb2JqLm1lc3NhZ2U7XHJcbiAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKG9iaik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgb3BlcmF0b3IsIHN0YWNrU3RhcnRGbikge1xyXG4gIHZhciBhcmdzTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcclxuICB2YXIgaW50ZXJuYWxNZXNzYWdlO1xyXG5cclxuICBpZiAoYXJnc0xlbiA9PT0gMCkge1xyXG4gICAgaW50ZXJuYWxNZXNzYWdlID0gJ0ZhaWxlZCc7XHJcbiAgfSBlbHNlIGlmIChhcmdzTGVuID09PSAxKSB7XHJcbiAgICBtZXNzYWdlID0gYWN0dWFsO1xyXG4gICAgYWN0dWFsID0gdW5kZWZpbmVkO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAod2FybmVkID09PSBmYWxzZSkge1xyXG4gICAgICB3YXJuZWQgPSB0cnVlO1xyXG4gICAgICB2YXIgd2FybiA9IHByb2Nlc3MuZW1pdFdhcm5pbmcgPyBwcm9jZXNzLmVtaXRXYXJuaW5nIDogY29uc29sZS53YXJuLmJpbmQoY29uc29sZSk7XHJcbiAgICAgIHdhcm4oJ2Fzc2VydC5mYWlsKCkgd2l0aCBtb3JlIHRoYW4gb25lIGFyZ3VtZW50IGlzIGRlcHJlY2F0ZWQuICcgKyAnUGxlYXNlIHVzZSBhc3NlcnQuc3RyaWN0RXF1YWwoKSBpbnN0ZWFkIG9yIG9ubHkgcGFzcyBhIG1lc3NhZ2UuJywgJ0RlcHJlY2F0aW9uV2FybmluZycsICdERVAwMDk0Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGFyZ3NMZW4gPT09IDIpIG9wZXJhdG9yID0gJyE9JztcclxuICB9XHJcblxyXG4gIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHRocm93IG1lc3NhZ2U7XHJcbiAgdmFyIGVyckFyZ3MgPSB7XHJcbiAgICBhY3R1YWw6IGFjdHVhbCxcclxuICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcclxuICAgIG9wZXJhdG9yOiBvcGVyYXRvciA9PT0gdW5kZWZpbmVkID8gJ2ZhaWwnIDogb3BlcmF0b3IsXHJcbiAgICBzdGFja1N0YXJ0Rm46IHN0YWNrU3RhcnRGbiB8fCBmYWlsXHJcbiAgfTtcclxuXHJcbiAgaWYgKG1lc3NhZ2UgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgZXJyQXJncy5tZXNzYWdlID0gbWVzc2FnZTtcclxuICB9XHJcblxyXG4gIHZhciBlcnIgPSBuZXcgQXNzZXJ0aW9uRXJyb3IoZXJyQXJncyk7XHJcblxyXG4gIGlmIChpbnRlcm5hbE1lc3NhZ2UpIHtcclxuICAgIGVyci5tZXNzYWdlID0gaW50ZXJuYWxNZXNzYWdlO1xyXG4gICAgZXJyLmdlbmVyYXRlZE1lc3NhZ2UgPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgdGhyb3cgZXJyO1xyXG59XHJcblxyXG5hc3NlcnQuZmFpbCA9IGZhaWw7IC8vIFRoZSBBc3NlcnRpb25FcnJvciBpcyBkZWZpbmVkIGluIGludGVybmFsL2Vycm9yLlxyXG5cclxuYXNzZXJ0LkFzc2VydGlvbkVycm9yID0gQXNzZXJ0aW9uRXJyb3I7XHJcblxyXG5mdW5jdGlvbiBpbm5lck9rKGZuLCBhcmdMZW4sIHZhbHVlLCBtZXNzYWdlKSB7XHJcbiAgaWYgKCF2YWx1ZSkge1xyXG4gICAgdmFyIGdlbmVyYXRlZE1lc3NhZ2UgPSBmYWxzZTtcclxuXHJcbiAgICBpZiAoYXJnTGVuID09PSAwKSB7XHJcbiAgICAgIGdlbmVyYXRlZE1lc3NhZ2UgPSB0cnVlO1xyXG4gICAgICBtZXNzYWdlID0gJ05vIHZhbHVlIGFyZ3VtZW50IHBhc3NlZCB0byBgYXNzZXJ0Lm9rKClgJztcclxuICAgIH0gZWxzZSBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICAgIHRocm93IG1lc3NhZ2U7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGVyciA9IG5ldyBBc3NlcnRpb25FcnJvcih7XHJcbiAgICAgIGFjdHVhbDogdmFsdWUsXHJcbiAgICAgIGV4cGVjdGVkOiB0cnVlLFxyXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxyXG4gICAgICBvcGVyYXRvcjogJz09JyxcclxuICAgICAgc3RhY2tTdGFydEZuOiBmblxyXG4gICAgfSk7XHJcbiAgICBlcnIuZ2VuZXJhdGVkTWVzc2FnZSA9IGdlbmVyYXRlZE1lc3NhZ2U7XHJcbiAgICB0aHJvdyBlcnI7XHJcbiAgfVxyXG59IC8vIFB1cmUgYXNzZXJ0aW9uIHRlc3RzIHdoZXRoZXIgYSB2YWx1ZSBpcyB0cnV0aHksIGFzIGRldGVybWluZWRcclxuLy8gYnkgISF2YWx1ZS5cclxuXHJcblxyXG5mdW5jdGlvbiBvaygpIHtcclxuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcclxuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XHJcbiAgfVxyXG5cclxuICBpbm5lck9rLmFwcGx5KHZvaWQgMCwgW29rLCBhcmdzLmxlbmd0aF0uY29uY2F0KGFyZ3MpKTtcclxufVxyXG5cclxuYXNzZXJ0Lm9rID0gb2s7IC8vIFRoZSBlcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgc2hhbGxvdywgY29lcmNpdmUgZXF1YWxpdHkgd2l0aCA9PS5cclxuXHJcbi8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtcHJvcGVydGllcyAqL1xyXG5cclxuYXNzZXJ0LmVxdWFsID0gZnVuY3Rpb24gZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xyXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xyXG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpO1xyXG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxyXG5cclxuXHJcbiAgaWYgKGFjdHVhbCAhPSBleHBlY3RlZCkge1xyXG4gICAgaW5uZXJGYWlsKHtcclxuICAgICAgYWN0dWFsOiBhY3R1YWwsXHJcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcclxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcclxuICAgICAgb3BlcmF0b3I6ICc9PScsXHJcbiAgICAgIHN0YWNrU3RhcnRGbjogZXF1YWxcclxuICAgIH0pO1xyXG4gIH1cclxufTsgLy8gVGhlIG5vbi1lcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgZm9yIHdoZXRoZXIgdHdvIG9iamVjdHMgYXJlIG5vdFxyXG4vLyBlcXVhbCB3aXRoICE9LlxyXG5cclxuXHJcbmFzc2VydC5ub3RFcXVhbCA9IGZ1bmN0aW9uIG5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcclxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcclxuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcclxuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcclxuXHJcblxyXG4gIGlmIChhY3R1YWwgPT0gZXhwZWN0ZWQpIHtcclxuICAgIGlubmVyRmFpbCh7XHJcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxyXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXHJcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXHJcbiAgICAgIG9wZXJhdG9yOiAnIT0nLFxyXG4gICAgICBzdGFja1N0YXJ0Rm46IG5vdEVxdWFsXHJcbiAgICB9KTtcclxuICB9XHJcbn07IC8vIFRoZSBlcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgYSBkZWVwIGVxdWFsaXR5IHJlbGF0aW9uLlxyXG5cclxuXHJcbmFzc2VydC5kZWVwRXF1YWwgPSBmdW5jdGlvbiBkZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xyXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xyXG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGlzRGVlcEVxdWFsID09PSB1bmRlZmluZWQpIGxhenlMb2FkQ29tcGFyaXNvbigpO1xyXG5cclxuICBpZiAoIWlzRGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XHJcbiAgICBpbm5lckZhaWwoe1xyXG4gICAgICBhY3R1YWw6IGFjdHVhbCxcclxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxyXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxyXG4gICAgICBvcGVyYXRvcjogJ2RlZXBFcXVhbCcsXHJcbiAgICAgIHN0YWNrU3RhcnRGbjogZGVlcEVxdWFsXHJcbiAgICB9KTtcclxuICB9XHJcbn07IC8vIFRoZSBub24tZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGZvciBhbnkgZGVlcCBpbmVxdWFsaXR5LlxyXG5cclxuXHJcbmFzc2VydC5ub3REZWVwRXF1YWwgPSBmdW5jdGlvbiBub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xyXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xyXG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGlzRGVlcEVxdWFsID09PSB1bmRlZmluZWQpIGxhenlMb2FkQ29tcGFyaXNvbigpO1xyXG5cclxuICBpZiAoaXNEZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCkpIHtcclxuICAgIGlubmVyRmFpbCh7XHJcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxyXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXHJcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXHJcbiAgICAgIG9wZXJhdG9yOiAnbm90RGVlcEVxdWFsJyxcclxuICAgICAgc3RhY2tTdGFydEZuOiBub3REZWVwRXF1YWxcclxuICAgIH0pO1xyXG4gIH1cclxufTtcclxuLyogZXNsaW50LWVuYWJsZSAqL1xyXG5cclxuXHJcbmFzc2VydC5kZWVwU3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBkZWVwU3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xyXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xyXG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGlzRGVlcEVxdWFsID09PSB1bmRlZmluZWQpIGxhenlMb2FkQ29tcGFyaXNvbigpO1xyXG5cclxuICBpZiAoIWlzRGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XHJcbiAgICBpbm5lckZhaWwoe1xyXG4gICAgICBhY3R1YWw6IGFjdHVhbCxcclxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxyXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxyXG4gICAgICBvcGVyYXRvcjogJ2RlZXBTdHJpY3RFcXVhbCcsXHJcbiAgICAgIHN0YWNrU3RhcnRGbjogZGVlcFN0cmljdEVxdWFsXHJcbiAgICB9KTtcclxuICB9XHJcbn07XHJcblxyXG5hc3NlcnQubm90RGVlcFN0cmljdEVxdWFsID0gbm90RGVlcFN0cmljdEVxdWFsO1xyXG5cclxuZnVuY3Rpb24gbm90RGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcclxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcclxuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcclxuICB9XHJcblxyXG4gIGlmIChpc0RlZXBFcXVhbCA9PT0gdW5kZWZpbmVkKSBsYXp5TG9hZENvbXBhcmlzb24oKTtcclxuXHJcbiAgaWYgKGlzRGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XHJcbiAgICBpbm5lckZhaWwoe1xyXG4gICAgICBhY3R1YWw6IGFjdHVhbCxcclxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxyXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxyXG4gICAgICBvcGVyYXRvcjogJ25vdERlZXBTdHJpY3RFcXVhbCcsXHJcbiAgICAgIHN0YWNrU3RhcnRGbjogbm90RGVlcFN0cmljdEVxdWFsXHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbmFzc2VydC5zdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIHN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcclxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcclxuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcclxuICB9XHJcblxyXG4gIGlmICghb2JqZWN0SXMoYWN0dWFsLCBleHBlY3RlZCkpIHtcclxuICAgIGlubmVyRmFpbCh7XHJcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxyXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXHJcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXHJcbiAgICAgIG9wZXJhdG9yOiAnc3RyaWN0RXF1YWwnLFxyXG4gICAgICBzdGFja1N0YXJ0Rm46IHN0cmljdEVxdWFsXHJcbiAgICB9KTtcclxuICB9XHJcbn07XHJcblxyXG5hc3NlcnQubm90U3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XHJcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XHJcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XHJcbiAgfVxyXG5cclxuICBpZiAob2JqZWN0SXMoYWN0dWFsLCBleHBlY3RlZCkpIHtcclxuICAgIGlubmVyRmFpbCh7XHJcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxyXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXHJcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXHJcbiAgICAgIG9wZXJhdG9yOiAnbm90U3RyaWN0RXF1YWwnLFxyXG4gICAgICBzdGFja1N0YXJ0Rm46IG5vdFN0cmljdEVxdWFsXHJcbiAgICB9KTtcclxuICB9XHJcbn07XHJcblxyXG52YXIgQ29tcGFyaXNvbiA9IGZ1bmN0aW9uIENvbXBhcmlzb24ob2JqLCBrZXlzLCBhY3R1YWwpIHtcclxuICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cclxuICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29tcGFyaXNvbik7XHJcblxyXG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICBpZiAoa2V5IGluIG9iaikge1xyXG4gICAgICBpZiAoYWN0dWFsICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGFjdHVhbFtrZXldID09PSAnc3RyaW5nJyAmJiBpc1JlZ0V4cChvYmpba2V5XSkgJiYgb2JqW2tleV0udGVzdChhY3R1YWxba2V5XSkpIHtcclxuICAgICAgICBfdGhpc1trZXldID0gYWN0dWFsW2tleV07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgX3RoaXNba2V5XSA9IG9ialtrZXldO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBjb21wYXJlRXhjZXB0aW9uS2V5KGFjdHVhbCwgZXhwZWN0ZWQsIGtleSwgbWVzc2FnZSwga2V5cywgZm4pIHtcclxuICBpZiAoIShrZXkgaW4gYWN0dWFsKSB8fCAhaXNEZWVwU3RyaWN0RXF1YWwoYWN0dWFsW2tleV0sIGV4cGVjdGVkW2tleV0pKSB7XHJcbiAgICBpZiAoIW1lc3NhZ2UpIHtcclxuICAgICAgLy8gQ3JlYXRlIHBsYWNlaG9sZGVyIG9iamVjdHMgdG8gY3JlYXRlIGEgbmljZSBvdXRwdXQuXHJcbiAgICAgIHZhciBhID0gbmV3IENvbXBhcmlzb24oYWN0dWFsLCBrZXlzKTtcclxuICAgICAgdmFyIGIgPSBuZXcgQ29tcGFyaXNvbihleHBlY3RlZCwga2V5cywgYWN0dWFsKTtcclxuICAgICAgdmFyIGVyciA9IG5ldyBBc3NlcnRpb25FcnJvcih7XHJcbiAgICAgICAgYWN0dWFsOiBhLFxyXG4gICAgICAgIGV4cGVjdGVkOiBiLFxyXG4gICAgICAgIG9wZXJhdG9yOiAnZGVlcFN0cmljdEVxdWFsJyxcclxuICAgICAgICBzdGFja1N0YXJ0Rm46IGZuXHJcbiAgICAgIH0pO1xyXG4gICAgICBlcnIuYWN0dWFsID0gYWN0dWFsO1xyXG4gICAgICBlcnIuZXhwZWN0ZWQgPSBleHBlY3RlZDtcclxuICAgICAgZXJyLm9wZXJhdG9yID0gZm4ubmFtZTtcclxuICAgICAgdGhyb3cgZXJyO1xyXG4gICAgfVxyXG5cclxuICAgIGlubmVyRmFpbCh7XHJcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxyXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXHJcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXHJcbiAgICAgIG9wZXJhdG9yOiBmbi5uYW1lLFxyXG4gICAgICBzdGFja1N0YXJ0Rm46IGZuXHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQsIG1zZywgZm4pIHtcclxuICBpZiAodHlwZW9mIGV4cGVjdGVkICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICBpZiAoaXNSZWdFeHAoZXhwZWN0ZWQpKSByZXR1cm4gZXhwZWN0ZWQudGVzdChhY3R1YWwpOyAvLyBhc3NlcnQuZG9lc05vdFRocm93IGRvZXMgbm90IGFjY2VwdCBvYmplY3RzLlxyXG5cclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnZXhwZWN0ZWQnLCBbJ0Z1bmN0aW9uJywgJ1JlZ0V4cCddLCBleHBlY3RlZCk7XHJcbiAgICB9IC8vIEhhbmRsZSBwcmltaXRpdmVzIHByb3Blcmx5LlxyXG5cclxuXHJcbiAgICBpZiAoX3R5cGVvZihhY3R1YWwpICE9PSAnb2JqZWN0JyB8fCBhY3R1YWwgPT09IG51bGwpIHtcclxuICAgICAgdmFyIGVyciA9IG5ldyBBc3NlcnRpb25FcnJvcih7XHJcbiAgICAgICAgYWN0dWFsOiBhY3R1YWwsXHJcbiAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxyXG4gICAgICAgIG1lc3NhZ2U6IG1zZyxcclxuICAgICAgICBvcGVyYXRvcjogJ2RlZXBTdHJpY3RFcXVhbCcsXHJcbiAgICAgICAgc3RhY2tTdGFydEZuOiBmblxyXG4gICAgICB9KTtcclxuICAgICAgZXJyLm9wZXJhdG9yID0gZm4ubmFtZTtcclxuICAgICAgdGhyb3cgZXJyO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXhwZWN0ZWQpOyAvLyBTcGVjaWFsIGhhbmRsZSBlcnJvcnMgdG8gbWFrZSBzdXJlIHRoZSBuYW1lIGFuZCB0aGUgbWVzc2FnZSBhcmUgY29tcGFyZWRcclxuICAgIC8vIGFzIHdlbGwuXHJcblxyXG4gICAgaWYgKGV4cGVjdGVkIGluc3RhbmNlb2YgRXJyb3IpIHtcclxuICAgICAga2V5cy5wdXNoKCduYW1lJywgJ21lc3NhZ2UnKTtcclxuICAgIH0gZWxzZSBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19WQUxVRSgnZXJyb3InLCBleHBlY3RlZCwgJ21heSBub3QgYmUgYW4gZW1wdHkgb2JqZWN0Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzRGVlcEVxdWFsID09PSB1bmRlZmluZWQpIGxhenlMb2FkQ29tcGFyaXNvbigpO1xyXG4gICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgaWYgKHR5cGVvZiBhY3R1YWxba2V5XSA9PT0gJ3N0cmluZycgJiYgaXNSZWdFeHAoZXhwZWN0ZWRba2V5XSkgJiYgZXhwZWN0ZWRba2V5XS50ZXN0KGFjdHVhbFtrZXldKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29tcGFyZUV4Y2VwdGlvbktleShhY3R1YWwsIGV4cGVjdGVkLCBrZXksIG1zZywga2V5cywgZm4pO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9IC8vIEd1YXJkIGluc3RhbmNlb2YgYWdhaW5zdCBhcnJvdyBmdW5jdGlvbnMgYXMgdGhleSBkb24ndCBoYXZlIGEgcHJvdG90eXBlLlxyXG5cclxuXHJcbiAgaWYgKGV4cGVjdGVkLnByb3RvdHlwZSAhPT0gdW5kZWZpbmVkICYmIGFjdHVhbCBpbnN0YW5jZW9mIGV4cGVjdGVkKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGlmIChFcnJvci5pc1Byb3RvdHlwZU9mKGV4cGVjdGVkKSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGV4cGVjdGVkLmNhbGwoe30sIGFjdHVhbCkgPT09IHRydWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEFjdHVhbChmbikge1xyXG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcclxuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnZm4nLCAnRnVuY3Rpb24nLCBmbik7XHJcbiAgfVxyXG5cclxuICB0cnkge1xyXG4gICAgZm4oKTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICByZXR1cm4gZTtcclxuICB9XHJcblxyXG4gIHJldHVybiBOT19FWENFUFRJT05fU0VOVElORUw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoZWNrSXNQcm9taXNlKG9iaikge1xyXG4gIC8vIEFjY2VwdCBuYXRpdmUgRVM2IHByb21pc2VzIGFuZCBwcm9taXNlcyB0aGF0IGFyZSBpbXBsZW1lbnRlZCBpbiBhIHNpbWlsYXJcclxuICAvLyB3YXkuIERvIG5vdCBhY2NlcHQgdGhlbmFibGVzIHRoYXQgdXNlIGEgZnVuY3Rpb24gYXMgYG9iamAgYW5kIHRoYXQgaGF2ZSBub1xyXG4gIC8vIGBjYXRjaGAgaGFuZGxlci5cclxuICAvLyBUT0RPOiB0aGVuYWJsZXMgYXJlIGNoZWNrZWQgdXAgdW50aWwgdGhleSBoYXZlIHRoZSBjb3JyZWN0IG1ldGhvZHMsXHJcbiAgLy8gYnV0IGFjY29yZGluZyB0byBkb2N1bWVudGF0aW9uLCB0aGUgYHRoZW5gIG1ldGhvZCBzaG91bGQgcmVjZWl2ZVxyXG4gIC8vIHRoZSBgZnVsZmlsbGAgYW5kIGByZWplY3RgIGFyZ3VtZW50cyBhcyB3ZWxsIG9yIGl0IG1heSBiZSBuZXZlciByZXNvbHZlZC5cclxuICByZXR1cm4gaXNQcm9taXNlKG9iaikgfHwgb2JqICE9PSBudWxsICYmIF90eXBlb2Yob2JqKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iai50aGVuID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouY2F0Y2ggPT09ICdmdW5jdGlvbic7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHdhaXRGb3JBY3R1YWwocHJvbWlzZUZuKSB7XHJcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHJlc3VsdFByb21pc2U7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBwcm9taXNlRm4gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgLy8gUmV0dXJuIGEgcmVqZWN0ZWQgcHJvbWlzZSBpZiBgcHJvbWlzZUZuYCB0aHJvd3Mgc3luY2hyb25vdXNseS5cclxuICAgICAgcmVzdWx0UHJvbWlzZSA9IHByb21pc2VGbigpOyAvLyBGYWlsIGluIGNhc2Ugbm8gcHJvbWlzZSBpcyByZXR1cm5lZC5cclxuXHJcbiAgICAgIGlmICghY2hlY2tJc1Byb21pc2UocmVzdWx0UHJvbWlzZSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfUkVUVVJOX1ZBTFVFKCdpbnN0YW5jZSBvZiBQcm9taXNlJywgJ3Byb21pc2VGbicsIHJlc3VsdFByb21pc2UpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGNoZWNrSXNQcm9taXNlKHByb21pc2VGbikpIHtcclxuICAgICAgcmVzdWx0UHJvbWlzZSA9IHByb21pc2VGbjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgncHJvbWlzZUZuJywgWydGdW5jdGlvbicsICdQcm9taXNlJ10sIHByb21pc2VGbik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gcmVzdWx0UHJvbWlzZTtcclxuICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gTk9fRVhDRVBUSU9OX1NFTlRJTkVMO1xyXG4gICAgfSkuY2F0Y2goZnVuY3Rpb24gKGUpIHtcclxuICAgICAgcmV0dXJuIGU7XHJcbiAgICB9KTtcclxuICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gZXhwZWN0c0Vycm9yKHN0YWNrU3RhcnRGbiwgYWN0dWFsLCBlcnJvciwgbWVzc2FnZSkge1xyXG4gIGlmICh0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnKSB7XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCkge1xyXG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2Vycm9yJywgWydPYmplY3QnLCAnRXJyb3InLCAnRnVuY3Rpb24nLCAnUmVnRXhwJ10sIGVycm9yKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoX3R5cGVvZihhY3R1YWwpID09PSAnb2JqZWN0JyAmJiBhY3R1YWwgIT09IG51bGwpIHtcclxuICAgICAgaWYgKGFjdHVhbC5tZXNzYWdlID09PSBlcnJvcikge1xyXG4gICAgICAgIHRocm93IG5ldyBFUlJfQU1CSUdVT1VTX0FSR1VNRU5UKCdlcnJvci9tZXNzYWdlJywgXCJUaGUgZXJyb3IgbWVzc2FnZSBcXFwiXCIuY29uY2F0KGFjdHVhbC5tZXNzYWdlLCBcIlxcXCIgaXMgaWRlbnRpY2FsIHRvIHRoZSBtZXNzYWdlLlwiKSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoYWN0dWFsID09PSBlcnJvcikge1xyXG4gICAgICB0aHJvdyBuZXcgRVJSX0FNQklHVU9VU19BUkdVTUVOVCgnZXJyb3IvbWVzc2FnZScsIFwiVGhlIGVycm9yIFxcXCJcIi5jb25jYXQoYWN0dWFsLCBcIlxcXCIgaXMgaWRlbnRpY2FsIHRvIHRoZSBtZXNzYWdlLlwiKSk7XHJcbiAgICB9XHJcblxyXG4gICAgbWVzc2FnZSA9IGVycm9yO1xyXG4gICAgZXJyb3IgPSB1bmRlZmluZWQ7XHJcbiAgfSBlbHNlIGlmIChlcnJvciAhPSBudWxsICYmIF90eXBlb2YoZXJyb3IpICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgZXJyb3IgIT09ICdmdW5jdGlvbicpIHtcclxuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnZXJyb3InLCBbJ09iamVjdCcsICdFcnJvcicsICdGdW5jdGlvbicsICdSZWdFeHAnXSwgZXJyb3IpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGFjdHVhbCA9PT0gTk9fRVhDRVBUSU9OX1NFTlRJTkVMKSB7XHJcbiAgICB2YXIgZGV0YWlscyA9ICcnO1xyXG5cclxuICAgIGlmIChlcnJvciAmJiBlcnJvci5uYW1lKSB7XHJcbiAgICAgIGRldGFpbHMgKz0gXCIgKFwiLmNvbmNhdChlcnJvci5uYW1lLCBcIilcIik7XHJcbiAgICB9XHJcblxyXG4gICAgZGV0YWlscyArPSBtZXNzYWdlID8gXCI6IFwiLmNvbmNhdChtZXNzYWdlKSA6ICcuJztcclxuICAgIHZhciBmblR5cGUgPSBzdGFja1N0YXJ0Rm4ubmFtZSA9PT0gJ3JlamVjdHMnID8gJ3JlamVjdGlvbicgOiAnZXhjZXB0aW9uJztcclxuICAgIGlubmVyRmFpbCh7XHJcbiAgICAgIGFjdHVhbDogdW5kZWZpbmVkLFxyXG4gICAgICBleHBlY3RlZDogZXJyb3IsXHJcbiAgICAgIG9wZXJhdG9yOiBzdGFja1N0YXJ0Rm4ubmFtZSxcclxuICAgICAgbWVzc2FnZTogXCJNaXNzaW5nIGV4cGVjdGVkIFwiLmNvbmNhdChmblR5cGUpLmNvbmNhdChkZXRhaWxzKSxcclxuICAgICAgc3RhY2tTdGFydEZuOiBzdGFja1N0YXJ0Rm5cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgaWYgKGVycm9yICYmICFleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGVycm9yLCBtZXNzYWdlLCBzdGFja1N0YXJ0Rm4pKSB7XHJcbiAgICB0aHJvdyBhY3R1YWw7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBleHBlY3RzTm9FcnJvcihzdGFja1N0YXJ0Rm4sIGFjdHVhbCwgZXJyb3IsIG1lc3NhZ2UpIHtcclxuICBpZiAoYWN0dWFsID09PSBOT19FWENFUFRJT05fU0VOVElORUwpIHJldHVybjtcclxuXHJcbiAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycpIHtcclxuICAgIG1lc3NhZ2UgPSBlcnJvcjtcclxuICAgIGVycm9yID0gdW5kZWZpbmVkO1xyXG4gIH1cclxuXHJcbiAgaWYgKCFlcnJvciB8fCBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGVycm9yKSkge1xyXG4gICAgdmFyIGRldGFpbHMgPSBtZXNzYWdlID8gXCI6IFwiLmNvbmNhdChtZXNzYWdlKSA6ICcuJztcclxuICAgIHZhciBmblR5cGUgPSBzdGFja1N0YXJ0Rm4ubmFtZSA9PT0gJ2RvZXNOb3RSZWplY3QnID8gJ3JlamVjdGlvbicgOiAnZXhjZXB0aW9uJztcclxuICAgIGlubmVyRmFpbCh7XHJcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxyXG4gICAgICBleHBlY3RlZDogZXJyb3IsXHJcbiAgICAgIG9wZXJhdG9yOiBzdGFja1N0YXJ0Rm4ubmFtZSxcclxuICAgICAgbWVzc2FnZTogXCJHb3QgdW53YW50ZWQgXCIuY29uY2F0KGZuVHlwZSkuY29uY2F0KGRldGFpbHMsIFwiXFxuXCIpICsgXCJBY3R1YWwgbWVzc2FnZTogXFxcIlwiLmNvbmNhdChhY3R1YWwgJiYgYWN0dWFsLm1lc3NhZ2UsIFwiXFxcIlwiKSxcclxuICAgICAgc3RhY2tTdGFydEZuOiBzdGFja1N0YXJ0Rm5cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgdGhyb3cgYWN0dWFsO1xyXG59XHJcblxyXG5hc3NlcnQudGhyb3dzID0gZnVuY3Rpb24gdGhyb3dzKHByb21pc2VGbikge1xyXG4gIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XHJcbiAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xyXG4gIH1cclxuXHJcbiAgZXhwZWN0c0Vycm9yLmFwcGx5KHZvaWQgMCwgW3Rocm93cywgZ2V0QWN0dWFsKHByb21pc2VGbildLmNvbmNhdChhcmdzKSk7XHJcbn07XHJcblxyXG5hc3NlcnQucmVqZWN0cyA9IGZ1bmN0aW9uIHJlamVjdHMocHJvbWlzZUZuKSB7XHJcbiAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zID4gMSA/IF9sZW4zIC0gMSA6IDApLCBfa2V5MyA9IDE7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcclxuICAgIGFyZ3NbX2tleTMgLSAxXSA9IGFyZ3VtZW50c1tfa2V5M107XHJcbiAgfVxyXG5cclxuICByZXR1cm4gd2FpdEZvckFjdHVhbChwcm9taXNlRm4pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgcmV0dXJuIGV4cGVjdHNFcnJvci5hcHBseSh2b2lkIDAsIFtyZWplY3RzLCByZXN1bHRdLmNvbmNhdChhcmdzKSk7XHJcbiAgfSk7XHJcbn07XHJcblxyXG5hc3NlcnQuZG9lc05vdFRocm93ID0gZnVuY3Rpb24gZG9lc05vdFRocm93KGZuKSB7XHJcbiAgZm9yICh2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40ID4gMSA/IF9sZW40IC0gMSA6IDApLCBfa2V5NCA9IDE7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcclxuICAgIGFyZ3NbX2tleTQgLSAxXSA9IGFyZ3VtZW50c1tfa2V5NF07XHJcbiAgfVxyXG5cclxuICBleHBlY3RzTm9FcnJvci5hcHBseSh2b2lkIDAsIFtkb2VzTm90VGhyb3csIGdldEFjdHVhbChmbildLmNvbmNhdChhcmdzKSk7XHJcbn07XHJcblxyXG5hc3NlcnQuZG9lc05vdFJlamVjdCA9IGZ1bmN0aW9uIGRvZXNOb3RSZWplY3QoZm4pIHtcclxuICBmb3IgKHZhciBfbGVuNSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjUgPiAxID8gX2xlbjUgLSAxIDogMCksIF9rZXk1ID0gMTsgX2tleTUgPCBfbGVuNTsgX2tleTUrKykge1xyXG4gICAgYXJnc1tfa2V5NSAtIDFdID0gYXJndW1lbnRzW19rZXk1XTtcclxuICB9XHJcblxyXG4gIHJldHVybiB3YWl0Rm9yQWN0dWFsKGZuKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgIHJldHVybiBleHBlY3RzTm9FcnJvci5hcHBseSh2b2lkIDAsIFtkb2VzTm90UmVqZWN0LCByZXN1bHRdLmNvbmNhdChhcmdzKSk7XHJcbiAgfSk7XHJcbn07XHJcblxyXG5hc3NlcnQuaWZFcnJvciA9IGZ1bmN0aW9uIGlmRXJyb3IoZXJyKSB7XHJcbiAgaWYgKGVyciAhPT0gbnVsbCAmJiBlcnIgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgdmFyIG1lc3NhZ2UgPSAnaWZFcnJvciBnb3QgdW53YW50ZWQgZXhjZXB0aW9uOiAnO1xyXG5cclxuICAgIGlmIChfdHlwZW9mKGVycikgPT09ICdvYmplY3QnICYmIHR5cGVvZiBlcnIubWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgaWYgKGVyci5tZXNzYWdlLmxlbmd0aCA9PT0gMCAmJiBlcnIuY29uc3RydWN0b3IpIHtcclxuICAgICAgICBtZXNzYWdlICs9IGVyci5jb25zdHJ1Y3Rvci5uYW1lO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG1lc3NhZ2UgKz0gZXJyLm1lc3NhZ2U7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG1lc3NhZ2UgKz0gaW5zcGVjdChlcnIpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBuZXdFcnIgPSBuZXcgQXNzZXJ0aW9uRXJyb3Ioe1xyXG4gICAgICBhY3R1YWw6IGVycixcclxuICAgICAgZXhwZWN0ZWQ6IG51bGwsXHJcbiAgICAgIG9wZXJhdG9yOiAnaWZFcnJvcicsXHJcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXHJcbiAgICAgIHN0YWNrU3RhcnRGbjogaWZFcnJvclxyXG4gICAgfSk7IC8vIE1ha2Ugc3VyZSB3ZSBhY3R1YWxseSBoYXZlIGEgc3RhY2sgdHJhY2UhXHJcblxyXG4gICAgdmFyIG9yaWdTdGFjayA9IGVyci5zdGFjaztcclxuXHJcbiAgICBpZiAodHlwZW9mIG9yaWdTdGFjayA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgLy8gVGhpcyB3aWxsIHJlbW92ZSBhbnkgZHVwbGljYXRlZCBmcmFtZXMgZnJvbSB0aGUgZXJyb3IgZnJhbWVzIHRha2VuXHJcbiAgICAgIC8vIGZyb20gd2l0aGluIGBpZkVycm9yYCBhbmQgYWRkIHRoZSBvcmlnaW5hbCBlcnJvciBmcmFtZXMgdG8gdGhlIG5ld2x5XHJcbiAgICAgIC8vIGNyZWF0ZWQgb25lcy5cclxuICAgICAgdmFyIHRtcDIgPSBvcmlnU3RhY2suc3BsaXQoJ1xcbicpO1xyXG4gICAgICB0bXAyLnNoaWZ0KCk7IC8vIEZpbHRlciBhbGwgZnJhbWVzIGV4aXN0aW5nIGluIGVyci5zdGFjay5cclxuXHJcbiAgICAgIHZhciB0bXAxID0gbmV3RXJyLnN0YWNrLnNwbGl0KCdcXG4nKTtcclxuXHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG1wMi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIC8vIEZpbmQgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgdGhlIGZyYW1lLlxyXG4gICAgICAgIHZhciBwb3MgPSB0bXAxLmluZGV4T2YodG1wMltpXSk7XHJcblxyXG4gICAgICAgIGlmIChwb3MgIT09IC0xKSB7XHJcbiAgICAgICAgICAvLyBPbmx5IGtlZXAgbmV3IGZyYW1lcy5cclxuICAgICAgICAgIHRtcDEgPSB0bXAxLnNsaWNlKDAsIHBvcyk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIG5ld0Vyci5zdGFjayA9IFwiXCIuY29uY2F0KHRtcDEuam9pbignXFxuJyksIFwiXFxuXCIpLmNvbmNhdCh0bXAyLmpvaW4oJ1xcbicpKTtcclxuICAgIH1cclxuXHJcbiAgICB0aHJvdyBuZXdFcnI7XHJcbiAgfVxyXG59OyAvLyBFeHBvc2UgYSBzdHJpY3Qgb25seSB2YXJpYW50IG9mIGFzc2VydFxyXG5cclxuXHJcbmZ1bmN0aW9uIHN0cmljdCgpIHtcclxuICBmb3IgKHZhciBfbGVuNiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjYpLCBfa2V5NiA9IDA7IF9rZXk2IDwgX2xlbjY7IF9rZXk2KyspIHtcclxuICAgIGFyZ3NbX2tleTZdID0gYXJndW1lbnRzW19rZXk2XTtcclxuICB9XHJcblxyXG4gIGlubmVyT2suYXBwbHkodm9pZCAwLCBbc3RyaWN0LCBhcmdzLmxlbmd0aF0uY29uY2F0KGFyZ3MpKTtcclxufVxyXG5cclxuYXNzZXJ0LnN0cmljdCA9IG9iamVjdEFzc2lnbihzdHJpY3QsIGFzc2VydCwge1xyXG4gIGVxdWFsOiBhc3NlcnQuc3RyaWN0RXF1YWwsXHJcbiAgZGVlcEVxdWFsOiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsLFxyXG4gIG5vdEVxdWFsOiBhc3NlcnQubm90U3RyaWN0RXF1YWwsXHJcbiAgbm90RGVlcEVxdWFsOiBhc3NlcnQubm90RGVlcFN0cmljdEVxdWFsXHJcbn0pO1xyXG5hc3NlcnQuc3RyaWN0LnN0cmljdCA9IGFzc2VydC5zdHJpY3Q7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/assert/build/assert.js\n");

/***/ }),

/***/ "./node_modules/assert/build/internal/assert/assertion_error.js":
/*!**********************************************************************!*\
  !*** ./node_modules/assert/build/internal/assert/assertion_error.js ***!
  \**********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/process/browser.js\");\n// Currently in sync with Node.js lib/internal/assert/assertion_error.js\r\n// https://github.com/nodejs/node/commit/0817840f775032169ddd70c85ac059f18ffcc81c\r\n\r\n\r\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\r\n\r\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\r\n\r\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\r\n\r\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\r\n\r\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\r\n\r\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\r\n\r\nfunction isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\r\n\r\nfunction _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\r\n\r\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\r\n\r\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\r\n\r\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\r\n\r\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\r\n\r\nvar _require = __webpack_require__(/*! util/ */ \"./node_modules/util/util.js\"),\r\n    inspect = _require.inspect;\r\n\r\nvar _require2 = __webpack_require__(/*! ../errors */ \"./node_modules/assert/build/internal/errors.js\"),\r\n    ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE; // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith\r\n\r\n\r\nfunction endsWith(str, search, this_len) {\r\n  if (this_len === undefined || this_len > str.length) {\r\n    this_len = str.length;\r\n  }\r\n\r\n  return str.substring(this_len - search.length, this_len) === search;\r\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat\r\n\r\n\r\nfunction repeat(str, count) {\r\n  count = Math.floor(count);\r\n  if (str.length == 0 || count == 0) return '';\r\n  var maxCount = str.length * count;\r\n  count = Math.floor(Math.log(count) / Math.log(2));\r\n\r\n  while (count) {\r\n    str += str;\r\n    count--;\r\n  }\r\n\r\n  str += str.substring(0, maxCount - str.length);\r\n  return str;\r\n}\r\n\r\nvar blue = '';\r\nvar green = '';\r\nvar red = '';\r\nvar white = '';\r\nvar kReadableOperator = {\r\n  deepStrictEqual: 'Expected values to be strictly deep-equal:',\r\n  strictEqual: 'Expected values to be strictly equal:',\r\n  strictEqualObject: 'Expected \"actual\" to be reference-equal to \"expected\":',\r\n  deepEqual: 'Expected values to be loosely deep-equal:',\r\n  equal: 'Expected values to be loosely equal:',\r\n  notDeepStrictEqual: 'Expected \"actual\" not to be strictly deep-equal to:',\r\n  notStrictEqual: 'Expected \"actual\" to be strictly unequal to:',\r\n  notStrictEqualObject: 'Expected \"actual\" not to be reference-equal to \"expected\":',\r\n  notDeepEqual: 'Expected \"actual\" not to be loosely deep-equal to:',\r\n  notEqual: 'Expected \"actual\" to be loosely unequal to:',\r\n  notIdentical: 'Values identical but not reference-equal:'\r\n}; // Comparing short primitives should just show === / !== instead of using the\r\n// diff.\r\n\r\nvar kMaxShortLength = 10;\r\n\r\nfunction copyError(source) {\r\n  var keys = Object.keys(source);\r\n  var target = Object.create(Object.getPrototypeOf(source));\r\n  keys.forEach(function (key) {\r\n    target[key] = source[key];\r\n  });\r\n  Object.defineProperty(target, 'message', {\r\n    value: source.message\r\n  });\r\n  return target;\r\n}\r\n\r\nfunction inspectValue(val) {\r\n  // The util.inspect default values could be changed. This makes sure the\r\n  // error messages contain the necessary information nevertheless.\r\n  return inspect(val, {\r\n    compact: false,\r\n    customInspect: false,\r\n    depth: 1000,\r\n    maxArrayLength: Infinity,\r\n    // Assert compares only enumerable properties (with a few exceptions).\r\n    showHidden: false,\r\n    // Having a long line as error is better than wrapping the line for\r\n    // comparison for now.\r\n    // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we\r\n    // have meta information about the inspected properties (i.e., know where\r\n    // in what line the property starts and ends).\r\n    breakLength: Infinity,\r\n    // Assert does not detect proxies currently.\r\n    showProxy: false,\r\n    sorted: true,\r\n    // Inspect getters as we also check them when comparing entries.\r\n    getters: true\r\n  });\r\n}\r\n\r\nfunction createErrDiff(actual, expected, operator) {\r\n  var other = '';\r\n  var res = '';\r\n  var lastPos = 0;\r\n  var end = '';\r\n  var skipped = false;\r\n  var actualInspected = inspectValue(actual);\r\n  var actualLines = actualInspected.split('\\n');\r\n  var expectedLines = inspectValue(expected).split('\\n');\r\n  var i = 0;\r\n  var indicator = ''; // In case both values are objects explicitly mark them as not reference equal\r\n  // for the `strictEqual` operator.\r\n\r\n  if (operator === 'strictEqual' && _typeof(actual) === 'object' && _typeof(expected) === 'object' && actual !== null && expected !== null) {\r\n    operator = 'strictEqualObject';\r\n  } // If \"actual\" and \"expected\" fit on a single line and they are not strictly\r\n  // equal, check further special handling.\r\n\r\n\r\n  if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {\r\n    var inputLength = actualLines[0].length + expectedLines[0].length; // If the character length of \"actual\" and \"expected\" together is less than\r\n    // kMaxShortLength and if neither is an object and at least one of them is\r\n    // not `zero`, use the strict equal comparison to visualize the output.\r\n\r\n    if (inputLength <= kMaxShortLength) {\r\n      if ((_typeof(actual) !== 'object' || actual === null) && (_typeof(expected) !== 'object' || expected === null) && (actual !== 0 || expected !== 0)) {\r\n        // -0 === +0\r\n        return \"\".concat(kReadableOperator[operator], \"\\n\\n\") + \"\".concat(actualLines[0], \" !== \").concat(expectedLines[0], \"\\n\");\r\n      }\r\n    } else if (operator !== 'strictEqualObject') {\r\n      // If the stderr is a tty and the input length is lower than the current\r\n      // columns per line, add a mismatch indicator below the output. If it is\r\n      // not a tty, use a default value of 80 characters.\r\n      var maxLength = process.stderr && process.stderr.isTTY ? process.stderr.columns : 80;\r\n\r\n      if (inputLength < maxLength) {\r\n        while (actualLines[0][i] === expectedLines[0][i]) {\r\n          i++;\r\n        } // Ignore the first characters.\r\n\r\n\r\n        if (i > 2) {\r\n          // Add position indicator for the first mismatch in case it is a\r\n          // single line and the input length is less than the column length.\r\n          indicator = \"\\n  \".concat(repeat(' ', i), \"^\");\r\n          i = 0;\r\n        }\r\n      }\r\n    }\r\n  } // Remove all ending lines that match (this optimizes the output for\r\n  // readability by reducing the number of total changed lines).\r\n\r\n\r\n  var a = actualLines[actualLines.length - 1];\r\n  var b = expectedLines[expectedLines.length - 1];\r\n\r\n  while (a === b) {\r\n    if (i++ < 2) {\r\n      end = \"\\n  \".concat(a).concat(end);\r\n    } else {\r\n      other = a;\r\n    }\r\n\r\n    actualLines.pop();\r\n    expectedLines.pop();\r\n    if (actualLines.length === 0 || expectedLines.length === 0) break;\r\n    a = actualLines[actualLines.length - 1];\r\n    b = expectedLines[expectedLines.length - 1];\r\n  }\r\n\r\n  var maxLines = Math.max(actualLines.length, expectedLines.length); // Strict equal with identical objects that are not identical by reference.\r\n  // E.g., assert.deepStrictEqual({ a: Symbol() }, { a: Symbol() })\r\n\r\n  if (maxLines === 0) {\r\n    // We have to get the result again. The lines were all removed before.\r\n    var _actualLines = actualInspected.split('\\n'); // Only remove lines in case it makes sense to collapse those.\r\n    // TODO: Accept env to always show the full error.\r\n\r\n\r\n    if (_actualLines.length > 30) {\r\n      _actualLines[26] = \"\".concat(blue, \"...\").concat(white);\r\n\r\n      while (_actualLines.length > 27) {\r\n        _actualLines.pop();\r\n      }\r\n    }\r\n\r\n    return \"\".concat(kReadableOperator.notIdentical, \"\\n\\n\").concat(_actualLines.join('\\n'), \"\\n\");\r\n  }\r\n\r\n  if (i > 3) {\r\n    end = \"\\n\".concat(blue, \"...\").concat(white).concat(end);\r\n    skipped = true;\r\n  }\r\n\r\n  if (other !== '') {\r\n    end = \"\\n  \".concat(other).concat(end);\r\n    other = '';\r\n  }\r\n\r\n  var printedLines = 0;\r\n  var msg = kReadableOperator[operator] + \"\\n\".concat(green, \"+ actual\").concat(white, \" \").concat(red, \"- expected\").concat(white);\r\n  var skippedMsg = \" \".concat(blue, \"...\").concat(white, \" Lines skipped\");\r\n\r\n  for (i = 0; i < maxLines; i++) {\r\n    // Only extra expected lines exist\r\n    var cur = i - lastPos;\r\n\r\n    if (actualLines.length < i + 1) {\r\n      // If the last diverging line is more than one line above and the\r\n      // current line is at least line three, add some of the former lines and\r\n      // also add dots to indicate skipped entries.\r\n      if (cur > 1 && i > 2) {\r\n        if (cur > 4) {\r\n          res += \"\\n\".concat(blue, \"...\").concat(white);\r\n          skipped = true;\r\n        } else if (cur > 3) {\r\n          res += \"\\n  \".concat(expectedLines[i - 2]);\r\n          printedLines++;\r\n        }\r\n\r\n        res += \"\\n  \".concat(expectedLines[i - 1]);\r\n        printedLines++;\r\n      } // Mark the current line as the last diverging one.\r\n\r\n\r\n      lastPos = i; // Add the expected line to the cache.\r\n\r\n      other += \"\\n\".concat(red, \"-\").concat(white, \" \").concat(expectedLines[i]);\r\n      printedLines++; // Only extra actual lines exist\r\n    } else if (expectedLines.length < i + 1) {\r\n      // If the last diverging line is more than one line above and the\r\n      // current line is at least line three, add some of the former lines and\r\n      // also add dots to indicate skipped entries.\r\n      if (cur > 1 && i > 2) {\r\n        if (cur > 4) {\r\n          res += \"\\n\".concat(blue, \"...\").concat(white);\r\n          skipped = true;\r\n        } else if (cur > 3) {\r\n          res += \"\\n  \".concat(actualLines[i - 2]);\r\n          printedLines++;\r\n        }\r\n\r\n        res += \"\\n  \".concat(actualLines[i - 1]);\r\n        printedLines++;\r\n      } // Mark the current line as the last diverging one.\r\n\r\n\r\n      lastPos = i; // Add the actual line to the result.\r\n\r\n      res += \"\\n\".concat(green, \"+\").concat(white, \" \").concat(actualLines[i]);\r\n      printedLines++; // Lines diverge\r\n    } else {\r\n      var expectedLine = expectedLines[i];\r\n      var actualLine = actualLines[i]; // If the lines diverge, specifically check for lines that only diverge by\r\n      // a trailing comma. In that case it is actually identical and we should\r\n      // mark it as such.\r\n\r\n      var divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, ',') || actualLine.slice(0, -1) !== expectedLine); // If the expected line has a trailing comma but is otherwise identical,\r\n      // add a comma at the end of the actual line. Otherwise the output could\r\n      // look weird as in:\r\n      //\r\n      //   [\r\n      //     1         // No comma at the end!\r\n      // +   2\r\n      //   ]\r\n      //\r\n\r\n      if (divergingLines && endsWith(expectedLine, ',') && expectedLine.slice(0, -1) === actualLine) {\r\n        divergingLines = false;\r\n        actualLine += ',';\r\n      }\r\n\r\n      if (divergingLines) {\r\n        // If the last diverging line is more than one line above and the\r\n        // current line is at least line three, add some of the former lines and\r\n        // also add dots to indicate skipped entries.\r\n        if (cur > 1 && i > 2) {\r\n          if (cur > 4) {\r\n            res += \"\\n\".concat(blue, \"...\").concat(white);\r\n            skipped = true;\r\n          } else if (cur > 3) {\r\n            res += \"\\n  \".concat(actualLines[i - 2]);\r\n            printedLines++;\r\n          }\r\n\r\n          res += \"\\n  \".concat(actualLines[i - 1]);\r\n          printedLines++;\r\n        } // Mark the current line as the last diverging one.\r\n\r\n\r\n        lastPos = i; // Add the actual line to the result and cache the expected diverging\r\n        // line so consecutive diverging lines show up as +++--- and not +-+-+-.\r\n\r\n        res += \"\\n\".concat(green, \"+\").concat(white, \" \").concat(actualLine);\r\n        other += \"\\n\".concat(red, \"-\").concat(white, \" \").concat(expectedLine);\r\n        printedLines += 2; // Lines are identical\r\n      } else {\r\n        // Add all cached information to the result before adding other things\r\n        // and reset the cache.\r\n        res += other;\r\n        other = ''; // If the last diverging line is exactly one line above or if it is the\r\n        // very first line, add the line to the result.\r\n\r\n        if (cur === 1 || i === 0) {\r\n          res += \"\\n  \".concat(actualLine);\r\n          printedLines++;\r\n        }\r\n      }\r\n    } // Inspected object to big (Show ~20 rows max)\r\n\r\n\r\n    if (printedLines > 20 && i < maxLines - 2) {\r\n      return \"\".concat(msg).concat(skippedMsg, \"\\n\").concat(res, \"\\n\").concat(blue, \"...\").concat(white).concat(other, \"\\n\") + \"\".concat(blue, \"...\").concat(white);\r\n    }\r\n  }\r\n\r\n  return \"\".concat(msg).concat(skipped ? skippedMsg : '', \"\\n\").concat(res).concat(other).concat(end).concat(indicator);\r\n}\r\n\r\nvar AssertionError =\r\n/*#__PURE__*/\r\nfunction (_Error) {\r\n  _inherits(AssertionError, _Error);\r\n\r\n  function AssertionError(options) {\r\n    var _this;\r\n\r\n    _classCallCheck(this, AssertionError);\r\n\r\n    if (_typeof(options) !== 'object' || options === null) {\r\n      throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);\r\n    }\r\n\r\n    var message = options.message,\r\n        operator = options.operator,\r\n        stackStartFn = options.stackStartFn;\r\n    var actual = options.actual,\r\n        expected = options.expected;\r\n    var limit = Error.stackTraceLimit;\r\n    Error.stackTraceLimit = 0;\r\n\r\n    if (message != null) {\r\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, String(message)));\r\n    } else {\r\n      if (process.stderr && process.stderr.isTTY) {\r\n        // Reset on each call to make sure we handle dynamically set environment\r\n        // variables correct.\r\n        if (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1) {\r\n          blue = \"\\x1B[34m\";\r\n          green = \"\\x1B[32m\";\r\n          white = \"\\x1B[39m\";\r\n          red = \"\\x1B[31m\";\r\n        } else {\r\n          blue = '';\r\n          green = '';\r\n          white = '';\r\n          red = '';\r\n        }\r\n      } // Prevent the error stack from being visible by duplicating the error\r\n      // in a very close way to the original in case both sides are actually\r\n      // instances of Error.\r\n\r\n\r\n      if (_typeof(actual) === 'object' && actual !== null && _typeof(expected) === 'object' && expected !== null && 'stack' in actual && actual instanceof Error && 'stack' in expected && expected instanceof Error) {\r\n        actual = copyError(actual);\r\n        expected = copyError(expected);\r\n      }\r\n\r\n      if (operator === 'deepStrictEqual' || operator === 'strictEqual') {\r\n        _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, createErrDiff(actual, expected, operator)));\r\n      } else if (operator === 'notDeepStrictEqual' || operator === 'notStrictEqual') {\r\n        // In case the objects are equal but the operator requires unequal, show\r\n        // the first object and say A equals B\r\n        var base = kReadableOperator[operator];\r\n        var res = inspectValue(actual).split('\\n'); // In case \"actual\" is an object, it should not be reference equal.\r\n\r\n        if (operator === 'notStrictEqual' && _typeof(actual) === 'object' && actual !== null) {\r\n          base = kReadableOperator.notStrictEqualObject;\r\n        } // Only remove lines in case it makes sense to collapse those.\r\n        // TODO: Accept env to always show the full error.\r\n\r\n\r\n        if (res.length > 30) {\r\n          res[26] = \"\".concat(blue, \"...\").concat(white);\r\n\r\n          while (res.length > 27) {\r\n            res.pop();\r\n          }\r\n        } // Only print a single input.\r\n\r\n\r\n        if (res.length === 1) {\r\n          _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, \"\".concat(base, \" \").concat(res[0])));\r\n        } else {\r\n          _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, \"\".concat(base, \"\\n\\n\").concat(res.join('\\n'), \"\\n\")));\r\n        }\r\n      } else {\r\n        var _res = inspectValue(actual);\r\n\r\n        var other = '';\r\n        var knownOperators = kReadableOperator[operator];\r\n\r\n        if (operator === 'notDeepEqual' || operator === 'notEqual') {\r\n          _res = \"\".concat(kReadableOperator[operator], \"\\n\\n\").concat(_res);\r\n\r\n          if (_res.length > 1024) {\r\n            _res = \"\".concat(_res.slice(0, 1021), \"...\");\r\n          }\r\n        } else {\r\n          other = \"\".concat(inspectValue(expected));\r\n\r\n          if (_res.length > 512) {\r\n            _res = \"\".concat(_res.slice(0, 509), \"...\");\r\n          }\r\n\r\n          if (other.length > 512) {\r\n            other = \"\".concat(other.slice(0, 509), \"...\");\r\n          }\r\n\r\n          if (operator === 'deepEqual' || operator === 'equal') {\r\n            _res = \"\".concat(knownOperators, \"\\n\\n\").concat(_res, \"\\n\\nshould equal\\n\\n\");\r\n          } else {\r\n            other = \" \".concat(operator, \" \").concat(other);\r\n          }\r\n        }\r\n\r\n        _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, \"\".concat(_res).concat(other)));\r\n      }\r\n    }\r\n\r\n    Error.stackTraceLimit = limit;\r\n    _this.generatedMessage = !message;\r\n    Object.defineProperty(_assertThisInitialized(_this), 'name', {\r\n      value: 'AssertionError [ERR_ASSERTION]',\r\n      enumerable: false,\r\n      writable: true,\r\n      configurable: true\r\n    });\r\n    _this.code = 'ERR_ASSERTION';\r\n    _this.actual = actual;\r\n    _this.expected = expected;\r\n    _this.operator = operator;\r\n\r\n    if (Error.captureStackTrace) {\r\n      // eslint-disable-next-line no-restricted-syntax\r\n      Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);\r\n    } // Create error message including the error code in the name.\r\n\r\n\r\n    _this.stack; // Reset the name.\r\n\r\n    _this.name = 'AssertionError';\r\n    return _possibleConstructorReturn(_this);\r\n  }\r\n\r\n  _createClass(AssertionError, [{\r\n    key: \"toString\",\r\n    value: function toString() {\r\n      return \"\".concat(this.name, \" [\").concat(this.code, \"]: \").concat(this.message);\r\n    }\r\n  }, {\r\n    key: inspect.custom,\r\n    value: function value(recurseTimes, ctx) {\r\n      // This limits the `actual` and `expected` property default inspection to\r\n      // the minimum depth. Otherwise those values would be too verbose compared\r\n      // to the actual error message which contains a combined view of these two\r\n      // input values.\r\n      return inspect(this, _objectSpread({}, ctx, {\r\n        customInspect: false,\r\n        depth: 0\r\n      }));\r\n    }\r\n  }]);\r\n\r\n  return AssertionError;\r\n}(_wrapNativeSuper(Error));\r\n\r\nmodule.exports = AssertionError;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXNzZXJ0L2J1aWxkL2ludGVybmFsL2Fzc2VydC9hc3NlcnRpb25fZXJyb3IuanMuanMiLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDYTtBQUNiO0FBQ0EsaUNBQWlDLGdCQUFnQixzQkFBc0IsT0FBTyx1REFBdUQsbUNBQW1DLDBEQUEwRCxzRkFBc0YsaUVBQWlFLE1BQU0saUNBQWlDLDRDQUE0QyxLQUFLO0FBQ2pkO0FBQ0EsNENBQTRDLGtCQUFrQixrQ0FBa0Msb0VBQW9FLEtBQUssT0FBTyxvQkFBb0I7QUFDcE07QUFDQSxrREFBa0QsMENBQTBDO0FBQzVGO0FBQ0EsNENBQTRDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQ7QUFDL1A7QUFDQSw4REFBOEQsc0VBQXNFLDhEQUE4RDtBQUNsTTtBQUNBLGtEQUFrRCwwRUFBMEUsZUFBZTtBQUMzSTtBQUNBLHdDQUF3Qyx1QkFBdUIseUZBQXlGO0FBQ3hKO0FBQ0EsMkNBQTJDLCtEQUErRCw2RUFBNkUseUVBQXlFLGVBQWUsdURBQXVELEdBQUc7QUFDelU7QUFDQSxtQ0FBbUMsZ0VBQWdFLHNEQUFzRCwrREFBK0QsbUNBQW1DLDZFQUE2RSxxQ0FBcUMsaURBQWlELDhCQUE4QixxQkFBcUIsMEVBQTBFLHFEQUFxRCxlQUFlLHlFQUF5RSxHQUFHLDJDQUEyQztBQUN0dEI7QUFDQSxzQ0FBc0Msd0VBQXdFLDBDQUEwQyw4Q0FBOEMsTUFBTSx1RUFBdUUsSUFBSSxlQUFlLFlBQVk7QUFDbFQ7QUFDQSwyQ0FBMkMsa0NBQWtDLGtDQUFrQyxPQUFPLHdEQUF3RCxnQkFBZ0IsdUJBQXVCLGtEQUFrRCxrQ0FBa0MsdURBQXVELHNCQUFzQjtBQUN0WDtBQUNBLGlDQUFpQztBQUNqQztBQUNBLGlDQUFpQyw0RUFBNEUsaUJBQWlCLGFBQWE7QUFDM0k7QUFDQSw4QkFBOEIsZ0dBQWdHLG1EQUFtRDtBQUNqTDtBQUNBLHdCQUF3QiwyRUFBMkUsa0NBQWtDLHdC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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYXNzZXJ0L2J1aWxkL2ludGVybmFsL2Fzc2VydC9hc3NlcnRpb25fZXJyb3IuanM/YWU0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDdXJyZW50bHkgaW4gc3luYyB3aXRoIE5vZGUuanMgbGliL2ludGVybmFsL2Fzc2VydC9hc3NlcnRpb25fZXJyb3IuanNcclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2NvbW1pdC8wODE3ODQwZjc3NTAzMjE2OWRkZDcwYzg1YWMwNTlmMThmZmNjODFjXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyB2YXIgb3duS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gJ2Z1bmN0aW9uJykgeyBvd25LZXlzID0gb3duS2V5cy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwgc3ltKS5lbnVtZXJhYmxlOyB9KSk7IH0gb3duS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IHJldHVybiB0YXJnZXQ7IH1cclxuXHJcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XHJcblxyXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxyXG5cclxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxyXG5cclxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cclxuXHJcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cclxuXHJcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxyXG5cclxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cclxuXHJcbmZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHsgdmFyIF9jYWNoZSA9IHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDsgX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHsgaWYgKENsYXNzID09PSBudWxsIHx8ICFfaXNOYXRpdmVGdW5jdGlvbihDbGFzcykpIHJldHVybiBDbGFzczsgaWYgKHR5cGVvZiBDbGFzcyAhPT0gXCJmdW5jdGlvblwiKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBpZiAodHlwZW9mIF9jYWNoZSAhPT0gXCJ1bmRlZmluZWRcIikgeyBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKTsgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7IH0gZnVuY3Rpb24gV3JhcHBlcigpIHsgcmV0dXJuIF9jb25zdHJ1Y3QoQ2xhc3MsIGFyZ3VtZW50cywgX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTsgfSBXcmFwcGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBXcmFwcGVyLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyByZXR1cm4gX3NldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKTsgfTsgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpOyB9XHJcblxyXG5mdW5jdGlvbiBpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cclxuXHJcbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyBpZiAoaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHsgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0OyB9IGVsc2UgeyBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7IHZhciBhID0gW251bGxdOyBhLnB1c2guYXBwbHkoYSwgYXJncyk7IHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTsgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7IGlmIChDbGFzcykgX3NldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpOyByZXR1cm4gaW5zdGFuY2U7IH07IH0gcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTsgfVxyXG5cclxuZnVuY3Rpb24gX2lzTmF0aXZlRnVuY3Rpb24oZm4pIHsgcmV0dXJuIEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoZm4pLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpICE9PSAtMTsgfVxyXG5cclxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cclxuXHJcbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cclxuXHJcbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XHJcblxyXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCd1dGlsLycpLFxyXG4gICAgaW5zcGVjdCA9IF9yZXF1aXJlLmluc3BlY3Q7XHJcblxyXG52YXIgX3JlcXVpcmUyID0gcmVxdWlyZSgnLi4vZXJyb3JzJyksXHJcbiAgICBFUlJfSU5WQUxJRF9BUkdfVFlQRSA9IF9yZXF1aXJlMi5jb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVFlQRTsgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2VuZHNXaXRoXHJcblxyXG5cclxuZnVuY3Rpb24gZW5kc1dpdGgoc3RyLCBzZWFyY2gsIHRoaXNfbGVuKSB7XHJcbiAgaWYgKHRoaXNfbGVuID09PSB1bmRlZmluZWQgfHwgdGhpc19sZW4gPiBzdHIubGVuZ3RoKSB7XHJcbiAgICB0aGlzX2xlbiA9IHN0ci5sZW5ndGg7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3RyLnN1YnN0cmluZyh0aGlzX2xlbiAtIHNlYXJjaC5sZW5ndGgsIHRoaXNfbGVuKSA9PT0gc2VhcmNoO1xyXG59IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9yZXBlYXRcclxuXHJcblxyXG5mdW5jdGlvbiByZXBlYXQoc3RyLCBjb3VudCkge1xyXG4gIGNvdW50ID0gTWF0aC5mbG9vcihjb3VudCk7XHJcbiAgaWYgKHN0ci5sZW5ndGggPT0gMCB8fCBjb3VudCA9PSAwKSByZXR1cm4gJyc7XHJcbiAgdmFyIG1heENvdW50ID0gc3RyLmxlbmd0aCAqIGNvdW50O1xyXG4gIGNvdW50ID0gTWF0aC5mbG9vcihNYXRoLmxvZyhjb3VudCkgLyBNYXRoLmxvZygyKSk7XHJcblxyXG4gIHdoaWxlIChjb3VudCkge1xyXG4gICAgc3RyICs9IHN0cjtcclxuICAgIGNvdW50LS07XHJcbiAgfVxyXG5cclxuICBzdHIgKz0gc3RyLnN1YnN0cmluZygwLCBtYXhDb3VudCAtIHN0ci5sZW5ndGgpO1xyXG4gIHJldHVybiBzdHI7XHJcbn1cclxuXHJcbnZhciBibHVlID0gJyc7XHJcbnZhciBncmVlbiA9ICcnO1xyXG52YXIgcmVkID0gJyc7XHJcbnZhciB3aGl0ZSA9ICcnO1xyXG52YXIga1JlYWRhYmxlT3BlcmF0b3IgPSB7XHJcbiAgZGVlcFN0cmljdEVxdWFsOiAnRXhwZWN0ZWQgdmFsdWVzIHRvIGJlIHN0cmljdGx5IGRlZXAtZXF1YWw6JyxcclxuICBzdHJpY3RFcXVhbDogJ0V4cGVjdGVkIHZhbHVlcyB0byBiZSBzdHJpY3RseSBlcXVhbDonLFxyXG4gIHN0cmljdEVxdWFsT2JqZWN0OiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiB0byBiZSByZWZlcmVuY2UtZXF1YWwgdG8gXCJleHBlY3RlZFwiOicsXHJcbiAgZGVlcEVxdWFsOiAnRXhwZWN0ZWQgdmFsdWVzIHRvIGJlIGxvb3NlbHkgZGVlcC1lcXVhbDonLFxyXG4gIGVxdWFsOiAnRXhwZWN0ZWQgdmFsdWVzIHRvIGJlIGxvb3NlbHkgZXF1YWw6JyxcclxuICBub3REZWVwU3RyaWN0RXF1YWw6ICdFeHBlY3RlZCBcImFjdHVhbFwiIG5vdCB0byBiZSBzdHJpY3RseSBkZWVwLWVxdWFsIHRvOicsXHJcbiAgbm90U3RyaWN0RXF1YWw6ICdFeHBlY3RlZCBcImFjdHVhbFwiIHRvIGJlIHN0cmljdGx5IHVuZXF1YWwgdG86JyxcclxuICBub3RTdHJpY3RFcXVhbE9iamVjdDogJ0V4cGVjdGVkIFwiYWN0dWFsXCIgbm90IHRvIGJlIHJlZmVyZW5jZS1lcXVhbCB0byBcImV4cGVjdGVkXCI6JyxcclxuICBub3REZWVwRXF1YWw6ICdFeHBlY3RlZCBcImFjdHVhbFwiIG5vdCB0byBiZSBsb29zZWx5IGRlZXAtZXF1YWwgdG86JyxcclxuICBub3RFcXVhbDogJ0V4cGVjdGVkIFwiYWN0dWFsXCIgdG8gYmUgbG9vc2VseSB1bmVxdWFsIHRvOicsXHJcbiAgbm90SWRlbnRpY2FsOiAnVmFsdWVzIGlkZW50aWNhbCBidXQgbm90IHJlZmVyZW5jZS1lcXVhbDonXHJcbn07IC8vIENvbXBhcmluZyBzaG9ydCBwcmltaXRpdmVzIHNob3VsZCBqdXN0IHNob3cgPT09IC8gIT09IGluc3RlYWQgb2YgdXNpbmcgdGhlXHJcbi8vIGRpZmYuXHJcblxyXG52YXIga01heFNob3J0TGVuZ3RoID0gMTA7XHJcblxyXG5mdW5jdGlvbiBjb3B5RXJyb3Ioc291cmNlKSB7XHJcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xyXG4gIHZhciB0YXJnZXQgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihzb3VyY2UpKTtcclxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcclxuICB9KTtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCAnbWVzc2FnZScsIHtcclxuICAgIHZhbHVlOiBzb3VyY2UubWVzc2FnZVxyXG4gIH0pO1xyXG4gIHJldHVybiB0YXJnZXQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluc3BlY3RWYWx1ZSh2YWwpIHtcclxuICAvLyBUaGUgdXRpbC5pbnNwZWN0IGRlZmF1bHQgdmFsdWVzIGNvdWxkIGJlIGNoYW5nZWQuIFRoaXMgbWFrZXMgc3VyZSB0aGVcclxuICAvLyBlcnJvciBtZXNzYWdlcyBjb250YWluIHRoZSBuZWNlc3NhcnkgaW5mb3JtYXRpb24gbmV2ZXJ0aGVsZXNzLlxyXG4gIHJldHVybiBpbnNwZWN0KHZhbCwge1xyXG4gICAgY29tcGFjdDogZmFsc2UsXHJcbiAgICBjdXN0b21JbnNwZWN0OiBmYWxzZSxcclxuICAgIGRlcHRoOiAxMDAwLFxyXG4gICAgbWF4QXJyYXlMZW5ndGg6IEluZmluaXR5LFxyXG4gICAgLy8gQXNzZXJ0IGNvbXBhcmVzIG9ubHkgZW51bWVyYWJsZSBwcm9wZXJ0aWVzICh3aXRoIGEgZmV3IGV4Y2VwdGlvbnMpLlxyXG4gICAgc2hvd0hpZGRlbjogZmFsc2UsXHJcbiAgICAvLyBIYXZpbmcgYSBsb25nIGxpbmUgYXMgZXJyb3IgaXMgYmV0dGVyIHRoYW4gd3JhcHBpbmcgdGhlIGxpbmUgZm9yXHJcbiAgICAvLyBjb21wYXJpc29uIGZvciBub3cuXHJcbiAgICAvLyBUT0RPKEJyaWRnZUFSKTogYGJyZWFrTGVuZ3RoYCBzaG91bGQgYmUgbGltaXRlZCBhcyBzb29uIGFzIHNvb24gYXMgd2VcclxuICAgIC8vIGhhdmUgbWV0YSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgaW5zcGVjdGVkIHByb3BlcnRpZXMgKGkuZS4sIGtub3cgd2hlcmVcclxuICAgIC8vIGluIHdoYXQgbGluZSB0aGUgcHJvcGVydHkgc3RhcnRzIGFuZCBlbmRzKS5cclxuICAgIGJyZWFrTGVuZ3RoOiBJbmZpbml0eSxcclxuICAgIC8vIEFzc2VydCBkb2VzIG5vdCBkZXRlY3QgcHJveGllcyBjdXJyZW50bHkuXHJcbiAgICBzaG93UHJveHk6IGZhbHNlLFxyXG4gICAgc29ydGVkOiB0cnVlLFxyXG4gICAgLy8gSW5zcGVjdCBnZXR0ZXJzIGFzIHdlIGFsc28gY2hlY2sgdGhlbSB3aGVuIGNvbXBhcmluZyBlbnRyaWVzLlxyXG4gICAgZ2V0dGVyczogdHJ1ZVxyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVFcnJEaWZmKGFjdHVhbCwgZXhwZWN0ZWQsIG9wZXJhdG9yKSB7XHJcbiAgdmFyIG90aGVyID0gJyc7XHJcbiAgdmFyIHJlcyA9ICcnO1xyXG4gIHZhciBsYXN0UG9zID0gMDtcclxuICB2YXIgZW5kID0gJyc7XHJcbiAgdmFyIHNraXBwZWQgPSBmYWxzZTtcclxuICB2YXIgYWN0dWFsSW5zcGVjdGVkID0gaW5zcGVjdFZhbHVlKGFjdHVhbCk7XHJcbiAgdmFyIGFjdHVhbExpbmVzID0gYWN0dWFsSW5zcGVjdGVkLnNwbGl0KCdcXG4nKTtcclxuICB2YXIgZXhwZWN0ZWRMaW5lcyA9IGluc3BlY3RWYWx1ZShleHBlY3RlZCkuc3BsaXQoJ1xcbicpO1xyXG4gIHZhciBpID0gMDtcclxuICB2YXIgaW5kaWNhdG9yID0gJyc7IC8vIEluIGNhc2UgYm90aCB2YWx1ZXMgYXJlIG9iamVjdHMgZXhwbGljaXRseSBtYXJrIHRoZW0gYXMgbm90IHJlZmVyZW5jZSBlcXVhbFxyXG4gIC8vIGZvciB0aGUgYHN0cmljdEVxdWFsYCBvcGVyYXRvci5cclxuXHJcbiAgaWYgKG9wZXJhdG9yID09PSAnc3RyaWN0RXF1YWwnICYmIF90eXBlb2YoYWN0dWFsKSA9PT0gJ29iamVjdCcgJiYgX3R5cGVvZihleHBlY3RlZCkgPT09ICdvYmplY3QnICYmIGFjdHVhbCAhPT0gbnVsbCAmJiBleHBlY3RlZCAhPT0gbnVsbCkge1xyXG4gICAgb3BlcmF0b3IgPSAnc3RyaWN0RXF1YWxPYmplY3QnO1xyXG4gIH0gLy8gSWYgXCJhY3R1YWxcIiBhbmQgXCJleHBlY3RlZFwiIGZpdCBvbiBhIHNpbmdsZSBsaW5lIGFuZCB0aGV5IGFyZSBub3Qgc3RyaWN0bHlcclxuICAvLyBlcXVhbCwgY2hlY2sgZnVydGhlciBzcGVjaWFsIGhhbmRsaW5nLlxyXG5cclxuXHJcbiAgaWYgKGFjdHVhbExpbmVzLmxlbmd0aCA9PT0gMSAmJiBleHBlY3RlZExpbmVzLmxlbmd0aCA9PT0gMSAmJiBhY3R1YWxMaW5lc1swXSAhPT0gZXhwZWN0ZWRMaW5lc1swXSkge1xyXG4gICAgdmFyIGlucHV0TGVuZ3RoID0gYWN0dWFsTGluZXNbMF0ubGVuZ3RoICsgZXhwZWN0ZWRMaW5lc1swXS5sZW5ndGg7IC8vIElmIHRoZSBjaGFyYWN0ZXIgbGVuZ3RoIG9mIFwiYWN0dWFsXCIgYW5kIFwiZXhwZWN0ZWRcIiB0b2dldGhlciBpcyBsZXNzIHRoYW5cclxuICAgIC8vIGtNYXhTaG9ydExlbmd0aCBhbmQgaWYgbmVpdGhlciBpcyBhbiBvYmplY3QgYW5kIGF0IGxlYXN0IG9uZSBvZiB0aGVtIGlzXHJcbiAgICAvLyBub3QgYHplcm9gLCB1c2UgdGhlIHN0cmljdCBlcXVhbCBjb21wYXJpc29uIHRvIHZpc3VhbGl6ZSB0aGUgb3V0cHV0LlxyXG5cclxuICAgIGlmIChpbnB1dExlbmd0aCA8PSBrTWF4U2hvcnRMZW5ndGgpIHtcclxuICAgICAgaWYgKChfdHlwZW9mKGFjdHVhbCkgIT09ICdvYmplY3QnIHx8IGFjdHVhbCA9PT0gbnVsbCkgJiYgKF90eXBlb2YoZXhwZWN0ZWQpICE9PSAnb2JqZWN0JyB8fCBleHBlY3RlZCA9PT0gbnVsbCkgJiYgKGFjdHVhbCAhPT0gMCB8fCBleHBlY3RlZCAhPT0gMCkpIHtcclxuICAgICAgICAvLyAtMCA9PT0gKzBcclxuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoa1JlYWRhYmxlT3BlcmF0b3Jbb3BlcmF0b3JdLCBcIlxcblxcblwiKSArIFwiXCIuY29uY2F0KGFjdHVhbExpbmVzWzBdLCBcIiAhPT0gXCIpLmNvbmNhdChleHBlY3RlZExpbmVzWzBdLCBcIlxcblwiKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChvcGVyYXRvciAhPT0gJ3N0cmljdEVxdWFsT2JqZWN0Jykge1xyXG4gICAgICAvLyBJZiB0aGUgc3RkZXJyIGlzIGEgdHR5IGFuZCB0aGUgaW5wdXQgbGVuZ3RoIGlzIGxvd2VyIHRoYW4gdGhlIGN1cnJlbnRcclxuICAgICAgLy8gY29sdW1ucyBwZXIgbGluZSwgYWRkIGEgbWlzbWF0Y2ggaW5kaWNhdG9yIGJlbG93IHRoZSBvdXRwdXQuIElmIGl0IGlzXHJcbiAgICAgIC8vIG5vdCBhIHR0eSwgdXNlIGEgZGVmYXVsdCB2YWx1ZSBvZiA4MCBjaGFyYWN0ZXJzLlxyXG4gICAgICB2YXIgbWF4TGVuZ3RoID0gcHJvY2Vzcy5zdGRlcnIgJiYgcHJvY2Vzcy5zdGRlcnIuaXNUVFkgPyBwcm9jZXNzLnN0ZGVyci5jb2x1bW5zIDogODA7XHJcblxyXG4gICAgICBpZiAoaW5wdXRMZW5ndGggPCBtYXhMZW5ndGgpIHtcclxuICAgICAgICB3aGlsZSAoYWN0dWFsTGluZXNbMF1baV0gPT09IGV4cGVjdGVkTGluZXNbMF1baV0pIHtcclxuICAgICAgICAgIGkrKztcclxuICAgICAgICB9IC8vIElnbm9yZSB0aGUgZmlyc3QgY2hhcmFjdGVycy5cclxuXHJcblxyXG4gICAgICAgIGlmIChpID4gMikge1xyXG4gICAgICAgICAgLy8gQWRkIHBvc2l0aW9uIGluZGljYXRvciBmb3IgdGhlIGZpcnN0IG1pc21hdGNoIGluIGNhc2UgaXQgaXMgYVxyXG4gICAgICAgICAgLy8gc2luZ2xlIGxpbmUgYW5kIHRoZSBpbnB1dCBsZW5ndGggaXMgbGVzcyB0aGFuIHRoZSBjb2x1bW4gbGVuZ3RoLlxyXG4gICAgICAgICAgaW5kaWNhdG9yID0gXCJcXG4gIFwiLmNvbmNhdChyZXBlYXQoJyAnLCBpKSwgXCJeXCIpO1xyXG4gICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSAvLyBSZW1vdmUgYWxsIGVuZGluZyBsaW5lcyB0aGF0IG1hdGNoICh0aGlzIG9wdGltaXplcyB0aGUgb3V0cHV0IGZvclxyXG4gIC8vIHJlYWRhYmlsaXR5IGJ5IHJlZHVjaW5nIHRoZSBudW1iZXIgb2YgdG90YWwgY2hhbmdlZCBsaW5lcykuXHJcblxyXG5cclxuICB2YXIgYSA9IGFjdHVhbExpbmVzW2FjdHVhbExpbmVzLmxlbmd0aCAtIDFdO1xyXG4gIHZhciBiID0gZXhwZWN0ZWRMaW5lc1tleHBlY3RlZExpbmVzLmxlbmd0aCAtIDFdO1xyXG5cclxuICB3aGlsZSAoYSA9PT0gYikge1xyXG4gICAgaWYgKGkrKyA8IDIpIHtcclxuICAgICAgZW5kID0gXCJcXG4gIFwiLmNvbmNhdChhKS5jb25jYXQoZW5kKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG90aGVyID0gYTtcclxuICAgIH1cclxuXHJcbiAgICBhY3R1YWxMaW5lcy5wb3AoKTtcclxuICAgIGV4cGVjdGVkTGluZXMucG9wKCk7XHJcbiAgICBpZiAoYWN0dWFsTGluZXMubGVuZ3RoID09PSAwIHx8IGV4cGVjdGVkTGluZXMubGVuZ3RoID09PSAwKSBicmVhaztcclxuICAgIGEgPSBhY3R1YWxMaW5lc1thY3R1YWxMaW5lcy5sZW5ndGggLSAxXTtcclxuICAgIGIgPSBleHBlY3RlZExpbmVzW2V4cGVjdGVkTGluZXMubGVuZ3RoIC0gMV07XHJcbiAgfVxyXG5cclxuICB2YXIgbWF4TGluZXMgPSBNYXRoLm1heChhY3R1YWxMaW5lcy5sZW5ndGgsIGV4cGVjdGVkTGluZXMubGVuZ3RoKTsgLy8gU3RyaWN0IGVxdWFsIHdpdGggaWRlbnRpY2FsIG9iamVjdHMgdGhhdCBhcmUgbm90IGlkZW50aWNhbCBieSByZWZlcmVuY2UuXHJcbiAgLy8gRS5nLiwgYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCh7IGE6IFN5bWJvbCgpIH0sIHsgYTogU3ltYm9sKCkgfSlcclxuXHJcbiAgaWYgKG1heExpbmVzID09PSAwKSB7XHJcbiAgICAvLyBXZSBoYXZlIHRvIGdldCB0aGUgcmVzdWx0IGFnYWluLiBUaGUgbGluZXMgd2VyZSBhbGwgcmVtb3ZlZCBiZWZvcmUuXHJcbiAgICB2YXIgX2FjdHVhbExpbmVzID0gYWN0dWFsSW5zcGVjdGVkLnNwbGl0KCdcXG4nKTsgLy8gT25seSByZW1vdmUgbGluZXMgaW4gY2FzZSBpdCBtYWtlcyBzZW5zZSB0byBjb2xsYXBzZSB0aG9zZS5cclxuICAgIC8vIFRPRE86IEFjY2VwdCBlbnYgdG8gYWx3YXlzIHNob3cgdGhlIGZ1bGwgZXJyb3IuXHJcblxyXG5cclxuICAgIGlmIChfYWN0dWFsTGluZXMubGVuZ3RoID4gMzApIHtcclxuICAgICAgX2FjdHVhbExpbmVzWzI2XSA9IFwiXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSk7XHJcblxyXG4gICAgICB3aGlsZSAoX2FjdHVhbExpbmVzLmxlbmd0aCA+IDI3KSB7XHJcbiAgICAgICAgX2FjdHVhbExpbmVzLnBvcCgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KGtSZWFkYWJsZU9wZXJhdG9yLm5vdElkZW50aWNhbCwgXCJcXG5cXG5cIikuY29uY2F0KF9hY3R1YWxMaW5lcy5qb2luKCdcXG4nKSwgXCJcXG5cIik7XHJcbiAgfVxyXG5cclxuICBpZiAoaSA+IDMpIHtcclxuICAgIGVuZCA9IFwiXFxuXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSkuY29uY2F0KGVuZCk7XHJcbiAgICBza2lwcGVkID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGlmIChvdGhlciAhPT0gJycpIHtcclxuICAgIGVuZCA9IFwiXFxuICBcIi5jb25jYXQob3RoZXIpLmNvbmNhdChlbmQpO1xyXG4gICAgb3RoZXIgPSAnJztcclxuICB9XHJcblxyXG4gIHZhciBwcmludGVkTGluZXMgPSAwO1xyXG4gIHZhciBtc2cgPSBrUmVhZGFibGVPcGVyYXRvcltvcGVyYXRvcl0gKyBcIlxcblwiLmNvbmNhdChncmVlbiwgXCIrIGFjdHVhbFwiKS5jb25jYXQod2hpdGUsIFwiIFwiKS5jb25jYXQocmVkLCBcIi0gZXhwZWN0ZWRcIikuY29uY2F0KHdoaXRlKTtcclxuICB2YXIgc2tpcHBlZE1zZyA9IFwiIFwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUsIFwiIExpbmVzIHNraXBwZWRcIik7XHJcblxyXG4gIGZvciAoaSA9IDA7IGkgPCBtYXhMaW5lczsgaSsrKSB7XHJcbiAgICAvLyBPbmx5IGV4dHJhIGV4cGVjdGVkIGxpbmVzIGV4aXN0XHJcbiAgICB2YXIgY3VyID0gaSAtIGxhc3RQb3M7XHJcblxyXG4gICAgaWYgKGFjdHVhbExpbmVzLmxlbmd0aCA8IGkgKyAxKSB7XHJcbiAgICAgIC8vIElmIHRoZSBsYXN0IGRpdmVyZ2luZyBsaW5lIGlzIG1vcmUgdGhhbiBvbmUgbGluZSBhYm92ZSBhbmQgdGhlXHJcbiAgICAgIC8vIGN1cnJlbnQgbGluZSBpcyBhdCBsZWFzdCBsaW5lIHRocmVlLCBhZGQgc29tZSBvZiB0aGUgZm9ybWVyIGxpbmVzIGFuZFxyXG4gICAgICAvLyBhbHNvIGFkZCBkb3RzIHRvIGluZGljYXRlIHNraXBwZWQgZW50cmllcy5cclxuICAgICAgaWYgKGN1ciA+IDEgJiYgaSA+IDIpIHtcclxuICAgICAgICBpZiAoY3VyID4gNCkge1xyXG4gICAgICAgICAgcmVzICs9IFwiXFxuXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSk7XHJcbiAgICAgICAgICBza2lwcGVkID0gdHJ1ZTtcclxuICAgICAgICB9IGVsc2UgaWYgKGN1ciA+IDMpIHtcclxuICAgICAgICAgIHJlcyArPSBcIlxcbiAgXCIuY29uY2F0KGV4cGVjdGVkTGluZXNbaSAtIDJdKTtcclxuICAgICAgICAgIHByaW50ZWRMaW5lcysrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoZXhwZWN0ZWRMaW5lc1tpIC0gMV0pO1xyXG4gICAgICAgIHByaW50ZWRMaW5lcysrO1xyXG4gICAgICB9IC8vIE1hcmsgdGhlIGN1cnJlbnQgbGluZSBhcyB0aGUgbGFzdCBkaXZlcmdpbmcgb25lLlxyXG5cclxuXHJcbiAgICAgIGxhc3RQb3MgPSBpOyAvLyBBZGQgdGhlIGV4cGVjdGVkIGxpbmUgdG8gdGhlIGNhY2hlLlxyXG5cclxuICAgICAgb3RoZXIgKz0gXCJcXG5cIi5jb25jYXQocmVkLCBcIi1cIikuY29uY2F0KHdoaXRlLCBcIiBcIikuY29uY2F0KGV4cGVjdGVkTGluZXNbaV0pO1xyXG4gICAgICBwcmludGVkTGluZXMrKzsgLy8gT25seSBleHRyYSBhY3R1YWwgbGluZXMgZXhpc3RcclxuICAgIH0gZWxzZSBpZiAoZXhwZWN0ZWRMaW5lcy5sZW5ndGggPCBpICsgMSkge1xyXG4gICAgICAvLyBJZiB0aGUgbGFzdCBkaXZlcmdpbmcgbGluZSBpcyBtb3JlIHRoYW4gb25lIGxpbmUgYWJvdmUgYW5kIHRoZVxyXG4gICAgICAvLyBjdXJyZW50IGxpbmUgaXMgYXQgbGVhc3QgbGluZSB0aHJlZSwgYWRkIHNvbWUgb2YgdGhlIGZvcm1lciBsaW5lcyBhbmRcclxuICAgICAgLy8gYWxzbyBhZGQgZG90cyB0byBpbmRpY2F0ZSBza2lwcGVkIGVudHJpZXMuXHJcbiAgICAgIGlmIChjdXIgPiAxICYmIGkgPiAyKSB7XHJcbiAgICAgICAgaWYgKGN1ciA+IDQpIHtcclxuICAgICAgICAgIHJlcyArPSBcIlxcblwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpO1xyXG4gICAgICAgICAgc2tpcHBlZCA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjdXIgPiAzKSB7XHJcbiAgICAgICAgICByZXMgKz0gXCJcXG4gIFwiLmNvbmNhdChhY3R1YWxMaW5lc1tpIC0gMl0pO1xyXG4gICAgICAgICAgcHJpbnRlZExpbmVzKys7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXMgKz0gXCJcXG4gIFwiLmNvbmNhdChhY3R1YWxMaW5lc1tpIC0gMV0pO1xyXG4gICAgICAgIHByaW50ZWRMaW5lcysrO1xyXG4gICAgICB9IC8vIE1hcmsgdGhlIGN1cnJlbnQgbGluZSBhcyB0aGUgbGFzdCBkaXZlcmdpbmcgb25lLlxyXG5cclxuXHJcbiAgICAgIGxhc3RQb3MgPSBpOyAvLyBBZGQgdGhlIGFjdHVhbCBsaW5lIHRvIHRoZSByZXN1bHQuXHJcblxyXG4gICAgICByZXMgKz0gXCJcXG5cIi5jb25jYXQoZ3JlZW4sIFwiK1wiKS5jb25jYXQod2hpdGUsIFwiIFwiKS5jb25jYXQoYWN0dWFsTGluZXNbaV0pO1xyXG4gICAgICBwcmludGVkTGluZXMrKzsgLy8gTGluZXMgZGl2ZXJnZVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFyIGV4cGVjdGVkTGluZSA9IGV4cGVjdGVkTGluZXNbaV07XHJcbiAgICAgIHZhciBhY3R1YWxMaW5lID0gYWN0dWFsTGluZXNbaV07IC8vIElmIHRoZSBsaW5lcyBkaXZlcmdlLCBzcGVjaWZpY2FsbHkgY2hlY2sgZm9yIGxpbmVzIHRoYXQgb25seSBkaXZlcmdlIGJ5XHJcbiAgICAgIC8vIGEgdHJhaWxpbmcgY29tbWEuIEluIHRoYXQgY2FzZSBpdCBpcyBhY3R1YWxseSBpZGVudGljYWwgYW5kIHdlIHNob3VsZFxyXG4gICAgICAvLyBtYXJrIGl0IGFzIHN1Y2guXHJcblxyXG4gICAgICB2YXIgZGl2ZXJnaW5nTGluZXMgPSBhY3R1YWxMaW5lICE9PSBleHBlY3RlZExpbmUgJiYgKCFlbmRzV2l0aChhY3R1YWxMaW5lLCAnLCcpIHx8IGFjdHVhbExpbmUuc2xpY2UoMCwgLTEpICE9PSBleHBlY3RlZExpbmUpOyAvLyBJZiB0aGUgZXhwZWN0ZWQgbGluZSBoYXMgYSB0cmFpbGluZyBjb21tYSBidXQgaXMgb3RoZXJ3aXNlIGlkZW50aWNhbCxcclxuICAgICAgLy8gYWRkIGEgY29tbWEgYXQgdGhlIGVuZCBvZiB0aGUgYWN0dWFsIGxpbmUuIE90aGVyd2lzZSB0aGUgb3V0cHV0IGNvdWxkXHJcbiAgICAgIC8vIGxvb2sgd2VpcmQgYXMgaW46XHJcbiAgICAgIC8vXHJcbiAgICAgIC8vICAgW1xyXG4gICAgICAvLyAgICAgMSAgICAgICAgIC8vIE5vIGNvbW1hIGF0IHRoZSBlbmQhXHJcbiAgICAgIC8vICsgICAyXHJcbiAgICAgIC8vICAgXVxyXG4gICAgICAvL1xyXG5cclxuICAgICAgaWYgKGRpdmVyZ2luZ0xpbmVzICYmIGVuZHNXaXRoKGV4cGVjdGVkTGluZSwgJywnKSAmJiBleHBlY3RlZExpbmUuc2xpY2UoMCwgLTEpID09PSBhY3R1YWxMaW5lKSB7XHJcbiAgICAgICAgZGl2ZXJnaW5nTGluZXMgPSBmYWxzZTtcclxuICAgICAgICBhY3R1YWxMaW5lICs9ICcsJztcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGRpdmVyZ2luZ0xpbmVzKSB7XHJcbiAgICAgICAgLy8gSWYgdGhlIGxhc3QgZGl2ZXJnaW5nIGxpbmUgaXMgbW9yZSB0aGFuIG9uZSBsaW5lIGFib3ZlIGFuZCB0aGVcclxuICAgICAgICAvLyBjdXJyZW50IGxpbmUgaXMgYXQgbGVhc3QgbGluZSB0aHJlZSwgYWRkIHNvbWUgb2YgdGhlIGZvcm1lciBsaW5lcyBhbmRcclxuICAgICAgICAvLyBhbHNvIGFkZCBkb3RzIHRvIGluZGljYXRlIHNraXBwZWQgZW50cmllcy5cclxuICAgICAgICBpZiAoY3VyID4gMSAmJiBpID4gMikge1xyXG4gICAgICAgICAgaWYgKGN1ciA+IDQpIHtcclxuICAgICAgICAgICAgcmVzICs9IFwiXFxuXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSk7XHJcbiAgICAgICAgICAgIHNraXBwZWQgPSB0cnVlO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChjdXIgPiAzKSB7XHJcbiAgICAgICAgICAgIHJlcyArPSBcIlxcbiAgXCIuY29uY2F0KGFjdHVhbExpbmVzW2kgLSAyXSk7XHJcbiAgICAgICAgICAgIHByaW50ZWRMaW5lcysrO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJlcyArPSBcIlxcbiAgXCIuY29uY2F0KGFjdHVhbExpbmVzW2kgLSAxXSk7XHJcbiAgICAgICAgICBwcmludGVkTGluZXMrKztcclxuICAgICAgICB9IC8vIE1hcmsgdGhlIGN1cnJlbnQgbGluZSBhcyB0aGUgbGFzdCBkaXZlcmdpbmcgb25lLlxyXG5cclxuXHJcbiAgICAgICAgbGFzdFBvcyA9IGk7IC8vIEFkZCB0aGUgYWN0dWFsIGxpbmUgdG8gdGhlIHJlc3VsdCBhbmQgY2FjaGUgdGhlIGV4cGVjdGVkIGRpdmVyZ2luZ1xyXG4gICAgICAgIC8vIGxpbmUgc28gY29uc2VjdXRpdmUgZGl2ZXJnaW5nIGxpbmVzIHNob3cgdXAgYXMgKysrLS0tIGFuZCBub3QgKy0rLSstLlxyXG5cclxuICAgICAgICByZXMgKz0gXCJcXG5cIi5jb25jYXQoZ3JlZW4sIFwiK1wiKS5jb25jYXQod2hpdGUsIFwiIFwiKS5jb25jYXQoYWN0dWFsTGluZSk7XHJcbiAgICAgICAgb3RoZXIgKz0gXCJcXG5cIi5jb25jYXQocmVkLCBcIi1cIikuY29uY2F0KHdoaXRlLCBcIiBcIikuY29uY2F0KGV4cGVjdGVkTGluZSk7XHJcbiAgICAgICAgcHJpbnRlZExpbmVzICs9IDI7IC8vIExpbmVzIGFyZSBpZGVudGljYWxcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBBZGQgYWxsIGNhY2hlZCBpbmZvcm1hdGlvbiB0byB0aGUgcmVzdWx0IGJlZm9yZSBhZGRpbmcgb3RoZXIgdGhpbmdzXHJcbiAgICAgICAgLy8gYW5kIHJlc2V0IHRoZSBjYWNoZS5cclxuICAgICAgICByZXMgKz0gb3RoZXI7XHJcbiAgICAgICAgb3RoZXIgPSAnJzsgLy8gSWYgdGhlIGxhc3QgZGl2ZXJnaW5nIGxpbmUgaXMgZXhhY3RseSBvbmUgbGluZSBhYm92ZSBvciBpZiBpdCBpcyB0aGVcclxuICAgICAgICAvLyB2ZXJ5IGZpcnN0IGxpbmUsIGFkZCB0aGUgbGluZSB0byB0aGUgcmVzdWx0LlxyXG5cclxuICAgICAgICBpZiAoY3VyID09PSAxIHx8IGkgPT09IDApIHtcclxuICAgICAgICAgIHJlcyArPSBcIlxcbiAgXCIuY29uY2F0KGFjdHVhbExpbmUpO1xyXG4gICAgICAgICAgcHJpbnRlZExpbmVzKys7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IC8vIEluc3BlY3RlZCBvYmplY3QgdG8gYmlnIChTaG93IH4yMCByb3dzIG1heClcclxuXHJcblxyXG4gICAgaWYgKHByaW50ZWRMaW5lcyA+IDIwICYmIGkgPCBtYXhMaW5lcyAtIDIpIHtcclxuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KG1zZykuY29uY2F0KHNraXBwZWRNc2csIFwiXFxuXCIpLmNvbmNhdChyZXMsIFwiXFxuXCIpLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpLmNvbmNhdChvdGhlciwgXCJcXG5cIikgKyBcIlwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIFwiXCIuY29uY2F0KG1zZykuY29uY2F0KHNraXBwZWQgPyBza2lwcGVkTXNnIDogJycsIFwiXFxuXCIpLmNvbmNhdChyZXMpLmNvbmNhdChvdGhlcikuY29uY2F0KGVuZCkuY29uY2F0KGluZGljYXRvcik7XHJcbn1cclxuXHJcbnZhciBBc3NlcnRpb25FcnJvciA9XHJcbi8qI19fUFVSRV9fKi9cclxuZnVuY3Rpb24gKF9FcnJvcikge1xyXG4gIF9pbmhlcml0cyhBc3NlcnRpb25FcnJvciwgX0Vycm9yKTtcclxuXHJcbiAgZnVuY3Rpb24gQXNzZXJ0aW9uRXJyb3Iob3B0aW9ucykge1xyXG4gICAgdmFyIF90aGlzO1xyXG5cclxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBc3NlcnRpb25FcnJvcik7XHJcblxyXG4gICAgaWYgKF90eXBlb2Yob3B0aW9ucykgIT09ICdvYmplY3QnIHx8IG9wdGlvbnMgPT09IG51bGwpIHtcclxuICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdvcHRpb25zJywgJ09iamVjdCcsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBtZXNzYWdlID0gb3B0aW9ucy5tZXNzYWdlLFxyXG4gICAgICAgIG9wZXJhdG9yID0gb3B0aW9ucy5vcGVyYXRvcixcclxuICAgICAgICBzdGFja1N0YXJ0Rm4gPSBvcHRpb25zLnN0YWNrU3RhcnRGbjtcclxuICAgIHZhciBhY3R1YWwgPSBvcHRpb25zLmFjdHVhbCxcclxuICAgICAgICBleHBlY3RlZCA9IG9wdGlvbnMuZXhwZWN0ZWQ7XHJcbiAgICB2YXIgbGltaXQgPSBFcnJvci5zdGFja1RyYWNlTGltaXQ7XHJcbiAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSAwO1xyXG5cclxuICAgIGlmIChtZXNzYWdlICE9IG51bGwpIHtcclxuICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQXNzZXJ0aW9uRXJyb3IpLmNhbGwodGhpcywgU3RyaW5nKG1lc3NhZ2UpKSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAocHJvY2Vzcy5zdGRlcnIgJiYgcHJvY2Vzcy5zdGRlcnIuaXNUVFkpIHtcclxuICAgICAgICAvLyBSZXNldCBvbiBlYWNoIGNhbGwgdG8gbWFrZSBzdXJlIHdlIGhhbmRsZSBkeW5hbWljYWxseSBzZXQgZW52aXJvbm1lbnRcclxuICAgICAgICAvLyB2YXJpYWJsZXMgY29ycmVjdC5cclxuICAgICAgICBpZiAocHJvY2Vzcy5zdGRlcnIgJiYgcHJvY2Vzcy5zdGRlcnIuZ2V0Q29sb3JEZXB0aCAmJiBwcm9jZXNzLnN0ZGVyci5nZXRDb2xvckRlcHRoKCkgIT09IDEpIHtcclxuICAgICAgICAgIGJsdWUgPSBcIlxceDFCWzM0bVwiO1xyXG4gICAgICAgICAgZ3JlZW4gPSBcIlxceDFCWzMybVwiO1xyXG4gICAgICAgICAgd2hpdGUgPSBcIlxceDFCWzM5bVwiO1xyXG4gICAgICAgICAgcmVkID0gXCJcXHgxQlszMW1cIjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYmx1ZSA9ICcnO1xyXG4gICAgICAgICAgZ3JlZW4gPSAnJztcclxuICAgICAgICAgIHdoaXRlID0gJyc7XHJcbiAgICAgICAgICByZWQgPSAnJztcclxuICAgICAgICB9XHJcbiAgICAgIH0gLy8gUHJldmVudCB0aGUgZXJyb3Igc3RhY2sgZnJvbSBiZWluZyB2aXNpYmxlIGJ5IGR1cGxpY2F0aW5nIHRoZSBlcnJvclxyXG4gICAgICAvLyBpbiBhIHZlcnkgY2xvc2Ugd2F5IHRvIHRoZSBvcmlnaW5hbCBpbiBjYXNlIGJvdGggc2lkZXMgYXJlIGFjdHVhbGx5XHJcbiAgICAgIC8vIGluc3RhbmNlcyBvZiBFcnJvci5cclxuXHJcblxyXG4gICAgICBpZiAoX3R5cGVvZihhY3R1YWwpID09PSAnb2JqZWN0JyAmJiBhY3R1YWwgIT09IG51bGwgJiYgX3R5cGVvZihleHBlY3RlZCkgPT09ICdvYmplY3QnICYmIGV4cGVjdGVkICE9PSBudWxsICYmICdzdGFjaycgaW4gYWN0dWFsICYmIGFjdHVhbCBpbnN0YW5jZW9mIEVycm9yICYmICdzdGFjaycgaW4gZXhwZWN0ZWQgJiYgZXhwZWN0ZWQgaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgICAgIGFjdHVhbCA9IGNvcHlFcnJvcihhY3R1YWwpO1xyXG4gICAgICAgIGV4cGVjdGVkID0gY29weUVycm9yKGV4cGVjdGVkKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG9wZXJhdG9yID09PSAnZGVlcFN0cmljdEVxdWFsJyB8fCBvcGVyYXRvciA9PT0gJ3N0cmljdEVxdWFsJykge1xyXG4gICAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEFzc2VydGlvbkVycm9yKS5jYWxsKHRoaXMsIGNyZWF0ZUVyckRpZmYoYWN0dWFsLCBleHBlY3RlZCwgb3BlcmF0b3IpKSk7XHJcbiAgICAgIH0gZWxzZSBpZiAob3BlcmF0b3IgPT09ICdub3REZWVwU3RyaWN0RXF1YWwnIHx8IG9wZXJhdG9yID09PSAnbm90U3RyaWN0RXF1YWwnKSB7XHJcbiAgICAgICAgLy8gSW4gY2FzZSB0aGUgb2JqZWN0cyBhcmUgZXF1YWwgYnV0IHRoZSBvcGVyYXRvciByZXF1aXJlcyB1bmVxdWFsLCBzaG93XHJcbiAgICAgICAgLy8gdGhlIGZpcnN0IG9iamVjdCBhbmQgc2F5IEEgZXF1YWxzIEJcclxuICAgICAgICB2YXIgYmFzZSA9IGtSZWFkYWJsZU9wZXJhdG9yW29wZXJhdG9yXTtcclxuICAgICAgICB2YXIgcmVzID0gaW5zcGVjdFZhbHVlKGFjdHVhbCkuc3BsaXQoJ1xcbicpOyAvLyBJbiBjYXNlIFwiYWN0dWFsXCIgaXMgYW4gb2JqZWN0LCBpdCBzaG91bGQgbm90IGJlIHJlZmVyZW5jZSBlcXVhbC5cclxuXHJcbiAgICAgICAgaWYgKG9wZXJhdG9yID09PSAnbm90U3RyaWN0RXF1YWwnICYmIF90eXBlb2YoYWN0dWFsKSA9PT0gJ29iamVjdCcgJiYgYWN0dWFsICE9PSBudWxsKSB7XHJcbiAgICAgICAgICBiYXNlID0ga1JlYWRhYmxlT3BlcmF0b3Iubm90U3RyaWN0RXF1YWxPYmplY3Q7XHJcbiAgICAgICAgfSAvLyBPbmx5IHJlbW92ZSBsaW5lcyBpbiBjYXNlIGl0IG1ha2VzIHNlbnNlIHRvIGNvbGxhcHNlIHRob3NlLlxyXG4gICAgICAgIC8vIFRPRE86IEFjY2VwdCBlbnYgdG8gYWx3YXlzIHNob3cgdGhlIGZ1bGwgZXJyb3IuXHJcblxyXG5cclxuICAgICAgICBpZiAocmVzLmxlbmd0aCA+IDMwKSB7XHJcbiAgICAgICAgICByZXNbMjZdID0gXCJcIi5jb25jYXQoYmx1ZSwgXCIuLi5cIikuY29uY2F0KHdoaXRlKTtcclxuXHJcbiAgICAgICAgICB3aGlsZSAocmVzLmxlbmd0aCA+IDI3KSB7XHJcbiAgICAgICAgICAgIHJlcy5wb3AoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IC8vIE9ubHkgcHJpbnQgYSBzaW5nbGUgaW5wdXQuXHJcblxyXG5cclxuICAgICAgICBpZiAocmVzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQXNzZXJ0aW9uRXJyb3IpLmNhbGwodGhpcywgXCJcIi5jb25jYXQoYmFzZSwgXCIgXCIpLmNvbmNhdChyZXNbMF0pKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEFzc2VydGlvbkVycm9yKS5jYWxsKHRoaXMsIFwiXCIuY29uY2F0KGJhc2UsIFwiXFxuXFxuXCIpLmNvbmNhdChyZXMuam9pbignXFxuJyksIFwiXFxuXCIpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhciBfcmVzID0gaW5zcGVjdFZhbHVlKGFjdHVhbCk7XHJcblxyXG4gICAgICAgIHZhciBvdGhlciA9ICcnO1xyXG4gICAgICAgIHZhciBrbm93bk9wZXJhdG9ycyA9IGtSZWFkYWJsZU9wZXJhdG9yW29wZXJhdG9yXTtcclxuXHJcbiAgICAgICAgaWYgKG9wZXJhdG9yID09PSAnbm90RGVlcEVxdWFsJyB8fCBvcGVyYXRvciA9PT0gJ25vdEVxdWFsJykge1xyXG4gICAgICAgICAgX3JlcyA9IFwiXCIuY29uY2F0KGtSZWFkYWJsZU9wZXJhdG9yW29wZXJhdG9yXSwgXCJcXG5cXG5cIikuY29uY2F0KF9yZXMpO1xyXG5cclxuICAgICAgICAgIGlmIChfcmVzLmxlbmd0aCA+IDEwMjQpIHtcclxuICAgICAgICAgICAgX3JlcyA9IFwiXCIuY29uY2F0KF9yZXMuc2xpY2UoMCwgMTAyMSksIFwiLi4uXCIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBvdGhlciA9IFwiXCIuY29uY2F0KGluc3BlY3RWYWx1ZShleHBlY3RlZCkpO1xyXG5cclxuICAgICAgICAgIGlmIChfcmVzLmxlbmd0aCA+IDUxMikge1xyXG4gICAgICAgICAgICBfcmVzID0gXCJcIi5jb25jYXQoX3Jlcy5zbGljZSgwLCA1MDkpLCBcIi4uLlwiKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAob3RoZXIubGVuZ3RoID4gNTEyKSB7XHJcbiAgICAgICAgICAgIG90aGVyID0gXCJcIi5jb25jYXQob3RoZXIuc2xpY2UoMCwgNTA5KSwgXCIuLi5cIik7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKG9wZXJhdG9yID09PSAnZGVlcEVxdWFsJyB8fCBvcGVyYXRvciA9PT0gJ2VxdWFsJykge1xyXG4gICAgICAgICAgICBfcmVzID0gXCJcIi5jb25jYXQoa25vd25PcGVyYXRvcnMsIFwiXFxuXFxuXCIpLmNvbmNhdChfcmVzLCBcIlxcblxcbnNob3VsZCBlcXVhbFxcblxcblwiKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG90aGVyID0gXCIgXCIuY29uY2F0KG9wZXJhdG9yLCBcIiBcIikuY29uY2F0KG90aGVyKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEFzc2VydGlvbkVycm9yKS5jYWxsKHRoaXMsIFwiXCIuY29uY2F0KF9yZXMpLmNvbmNhdChvdGhlcikpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IGxpbWl0O1xyXG4gICAgX3RoaXMuZ2VuZXJhdGVkTWVzc2FnZSA9ICFtZXNzYWdlO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCAnbmFtZScsIHtcclxuICAgICAgdmFsdWU6ICdBc3NlcnRpb25FcnJvciBbRVJSX0FTU0VSVElPTl0nLFxyXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBfdGhpcy5jb2RlID0gJ0VSUl9BU1NFUlRJT04nO1xyXG4gICAgX3RoaXMuYWN0dWFsID0gYWN0dWFsO1xyXG4gICAgX3RoaXMuZXhwZWN0ZWQgPSBleHBlY3RlZDtcclxuICAgIF90aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XHJcblxyXG4gICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XHJcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxyXG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgc3RhY2tTdGFydEZuKTtcclxuICAgIH0gLy8gQ3JlYXRlIGVycm9yIG1lc3NhZ2UgaW5jbHVkaW5nIHRoZSBlcnJvciBjb2RlIGluIHRoZSBuYW1lLlxyXG5cclxuXHJcbiAgICBfdGhpcy5zdGFjazsgLy8gUmVzZXQgdGhlIG5hbWUuXHJcblxyXG4gICAgX3RoaXMubmFtZSA9ICdBc3NlcnRpb25FcnJvcic7XHJcbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMpO1xyXG4gIH1cclxuXHJcbiAgX2NyZWF0ZUNsYXNzKEFzc2VydGlvbkVycm9yLCBbe1xyXG4gICAga2V5OiBcInRvU3RyaW5nXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XHJcbiAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh0aGlzLm5hbWUsIFwiIFtcIikuY29uY2F0KHRoaXMuY29kZSwgXCJdOiBcIikuY29uY2F0KHRoaXMubWVzc2FnZSk7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBpbnNwZWN0LmN1c3RvbSxcclxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShyZWN1cnNlVGltZXMsIGN0eCkge1xyXG4gICAgICAvLyBUaGlzIGxpbWl0cyB0aGUgYGFjdHVhbGAgYW5kIGBleHBlY3RlZGAgcHJvcGVydHkgZGVmYXVsdCBpbnNwZWN0aW9uIHRvXHJcbiAgICAgIC8vIHRoZSBtaW5pbXVtIGRlcHRoLiBPdGhlcndpc2UgdGhvc2UgdmFsdWVzIHdvdWxkIGJlIHRvbyB2ZXJib3NlIGNvbXBhcmVkXHJcbiAgICAgIC8vIHRvIHRoZSBhY3R1YWwgZXJyb3IgbWVzc2FnZSB3aGljaCBjb250YWlucyBhIGNvbWJpbmVkIHZpZXcgb2YgdGhlc2UgdHdvXHJcbiAgICAgIC8vIGlucHV0IHZhbHVlcy5cclxuICAgICAgcmV0dXJuIGluc3BlY3QodGhpcywgX29iamVjdFNwcmVhZCh7fSwgY3R4LCB7XHJcbiAgICAgICAgY3VzdG9tSW5zcGVjdDogZmFsc2UsXHJcbiAgICAgICAgZGVwdGg6IDBcclxuICAgICAgfSkpO1xyXG4gICAgfVxyXG4gIH1dKTtcclxuXHJcbiAgcmV0dXJuIEFzc2VydGlvbkVycm9yO1xyXG59KF93cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQXNzZXJ0aW9uRXJyb3I7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/assert/build/internal/assert/assertion_error.js\n");

/***/ }),

/***/ "./node_modules/assert/build/internal/errors.js":
/*!******************************************************!*\
  !*** ./node_modules/assert/build/internal/errors.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("// Currently in sync with Node.js lib/internal/errors.js\r\n// https://github.com/nodejs/node/commit/3b044962c48fe313905877a96b5d0894a5404f6f\r\n\r\n/* eslint node-core/documented-errors: \"error\" */\r\n\r\n/* eslint node-core/alphabetize-errors: \"error\" */\r\n\r\n/* eslint node-core/prefer-util-format-errors: \"error\" */\r\n // The whole point behind this internal module is to allow Node.js to no\r\n// longer be forced to treat every error message change as a semver-major\r\n// change. The NodeError classes here all expose a `code` property whose\r\n// value statically and permanently identifies the error. While the error\r\n// message may change, the code should not.\r\n\r\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\r\n\r\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\r\n\r\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\r\n\r\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\r\n\r\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\r\n\r\nvar codes = {}; // Lazy loaded\r\n\r\nvar assert;\r\nvar util;\r\n\r\nfunction createErrorType(code, message, Base) {\r\n  if (!Base) {\r\n    Base = Error;\r\n  }\r\n\r\n  function getMessage(arg1, arg2, arg3) {\r\n    if (typeof message === 'string') {\r\n      return message;\r\n    } else {\r\n      return message(arg1, arg2, arg3);\r\n    }\r\n  }\r\n\r\n  var NodeError =\r\n  /*#__PURE__*/\r\n  function (_Base) {\r\n    _inherits(NodeError, _Base);\r\n\r\n    function NodeError(arg1, arg2, arg3) {\r\n      var _this;\r\n\r\n      _classCallCheck(this, NodeError);\r\n\r\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(NodeError).call(this, getMessage(arg1, arg2, arg3)));\r\n      _this.code = code;\r\n      return _this;\r\n    }\r\n\r\n    return NodeError;\r\n  }(Base);\r\n\r\n  codes[code] = NodeError;\r\n} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js\r\n\r\n\r\nfunction oneOf(expected, thing) {\r\n  if (Array.isArray(expected)) {\r\n    var len = expected.length;\r\n    expected = expected.map(function (i) {\r\n      return String(i);\r\n    });\r\n\r\n    if (len > 2) {\r\n      return \"one of \".concat(thing, \" \").concat(expected.slice(0, len - 1).join(', '), \", or \") + expected[len - 1];\r\n    } else if (len === 2) {\r\n      return \"one of \".concat(thing, \" \").concat(expected[0], \" or \").concat(expected[1]);\r\n    } else {\r\n      return \"of \".concat(thing, \" \").concat(expected[0]);\r\n    }\r\n  } else {\r\n    return \"of \".concat(thing, \" \").concat(String(expected));\r\n  }\r\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith\r\n\r\n\r\nfunction startsWith(str, search, pos) {\r\n  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;\r\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith\r\n\r\n\r\nfunction endsWith(str, search, this_len) {\r\n  if (this_len === undefined || this_len > str.length) {\r\n    this_len = str.length;\r\n  }\r\n\r\n  return str.substring(this_len - search.length, this_len) === search;\r\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes\r\n\r\n\r\nfunction includes(str, search, start) {\r\n  if (typeof start !== 'number') {\r\n    start = 0;\r\n  }\r\n\r\n  if (start + search.length > str.length) {\r\n    return false;\r\n  } else {\r\n    return str.indexOf(search, start) !== -1;\r\n  }\r\n}\r\n\r\ncreateErrorType('ERR_AMBIGUOUS_ARGUMENT', 'The \"%s\" argument is ambiguous. %s', TypeError);\r\ncreateErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {\r\n  if (assert === undefined) assert = __webpack_require__(/*! ../assert */ \"./node_modules/assert/build/assert.js\");\r\n  assert(typeof name === 'string', \"'name' must be a string\"); // determiner: 'must be' or 'must not be'\r\n\r\n  var determiner;\r\n\r\n  if (typeof expected === 'string' && startsWith(expected, 'not ')) {\r\n    determiner = 'must not be';\r\n    expected = expected.replace(/^not /, '');\r\n  } else {\r\n    determiner = 'must be';\r\n  }\r\n\r\n  var msg;\r\n\r\n  if (endsWith(name, ' argument')) {\r\n    // For cases like 'first argument'\r\n    msg = \"The \".concat(name, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\r\n  } else {\r\n    var type = includes(name, '.') ? 'property' : 'argument';\r\n    msg = \"The \\\"\".concat(name, \"\\\" \").concat(type, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\r\n  } // TODO(BridgeAR): Improve the output by showing `null` and similar.\r\n\r\n\r\n  msg += \". Received type \".concat(_typeof(actual));\r\n  return msg;\r\n}, TypeError);\r\ncreateErrorType('ERR_INVALID_ARG_VALUE', function (name, value) {\r\n  var reason = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'is invalid';\r\n  if (util === undefined) util = __webpack_require__(/*! util/ */ \"./node_modules/util/util.js\");\r\n  var inspected = util.inspect(value);\r\n\r\n  if (inspected.length > 128) {\r\n    inspected = \"\".concat(inspected.slice(0, 128), \"...\");\r\n  }\r\n\r\n  return \"The argument '\".concat(name, \"' \").concat(reason, \". Received \").concat(inspected);\r\n}, TypeError, RangeError);\r\ncreateErrorType('ERR_INVALID_RETURN_VALUE', function (input, name, value) {\r\n  var type;\r\n\r\n  if (value && value.constructor && value.constructor.name) {\r\n    type = \"instance of \".concat(value.constructor.name);\r\n  } else {\r\n    type = \"type \".concat(_typeof(value));\r\n  }\r\n\r\n  return \"Expected \".concat(input, \" to be returned from the \\\"\").concat(name, \"\\\"\") + \" function but got \".concat(type, \".\");\r\n}, TypeError);\r\ncreateErrorType('ERR_MISSING_ARGS', function () {\r\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\r\n    args[_key] = arguments[_key];\r\n  }\r\n\r\n  if (assert === undefined) assert = __webpack_require__(/*! ../assert */ \"./node_modules/assert/build/assert.js\");\r\n  assert(args.length > 0, 'At least one arg needs to be specified');\r\n  var msg = 'The ';\r\n  var len = args.length;\r\n  args = args.map(function (a) {\r\n    return \"\\\"\".concat(a, \"\\\"\");\r\n  });\r\n\r\n  switch (len) {\r\n    case 1:\r\n      msg += \"\".concat(args[0], \" argument\");\r\n      break;\r\n\r\n    case 2:\r\n      msg += \"\".concat(args[0], \" and \").concat(args[1], \" arguments\");\r\n      break;\r\n\r\n    default:\r\n      msg += args.slice(0, len - 1).join(', ');\r\n      msg += \", and \".concat(args[len - 1], \" arguments\");\r\n      break;\r\n  }\r\n\r\n  return \"\".concat(msg, \" must be specified\");\r\n}, TypeError);\r\nmodule.exports.codes = codes;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXNzZXJ0L2J1aWxkL2ludGVybmFsL2Vycm9ycy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2EsQ0FBQztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkVBQTJFLGtDQUFrQyx3QkFBd0IsT0FBTyxrQ0FBa0MsbUlBQW1JO0FBQ3pVO0FBQ0Esa0RBQWtELDBDQUEwQztBQUM1RjtBQUNBLGtEQUFrRCwwRUFBMEUsZUFBZTtBQUMzSTtBQUNBLHdDQUF3Qyx1QkFBdUIseUZBQXlGO0FBQ3hKO0FBQ0EsOEJBQThCLGdHQUFnRyxtREFBbUQ7QUFDakw7QUFDQSwyQ0FBMkMsK0RBQStELDZFQUE2RSx5RUFBeUUsZUFBZSx1REFBdUQsR0FBRztBQUN6VTtBQUNBLGlDQUFpQyw0RUFBNEUsaUJBQWlCLGFBQWE7QUFDM0k7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxtQkFBTyxDQUFDLHdEQUFXO0FBQ3hELCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxpQ0FBaUMsbUJBQU8sQ0FBQywwQ0FBTztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esc0VBQXNFLGFBQWE7QUFDbkY7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG1CQUFPLENBQUMsd0RBQVc7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG9CQUFvQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYXNzZXJ0L2J1aWxkL2ludGVybmFsL2Vycm9ycy5qcz80NTIwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEN1cnJlbnRseSBpbiBzeW5jIHdpdGggTm9kZS5qcyBsaWIvaW50ZXJuYWwvZXJyb3JzLmpzXHJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9jb21taXQvM2IwNDQ5NjJjNDhmZTMxMzkwNTg3N2E5NmI1ZDA4OTRhNTQwNGY2ZlxyXG5cclxuLyogZXNsaW50IG5vZGUtY29yZS9kb2N1bWVudGVkLWVycm9yczogXCJlcnJvclwiICovXHJcblxyXG4vKiBlc2xpbnQgbm9kZS1jb3JlL2FscGhhYmV0aXplLWVycm9yczogXCJlcnJvclwiICovXHJcblxyXG4vKiBlc2xpbnQgbm9kZS1jb3JlL3ByZWZlci11dGlsLWZvcm1hdC1lcnJvcnM6IFwiZXJyb3JcIiAqL1xyXG4ndXNlIHN0cmljdCc7IC8vIFRoZSB3aG9sZSBwb2ludCBiZWhpbmQgdGhpcyBpbnRlcm5hbCBtb2R1bGUgaXMgdG8gYWxsb3cgTm9kZS5qcyB0byBub1xyXG4vLyBsb25nZXIgYmUgZm9yY2VkIHRvIHRyZWF0IGV2ZXJ5IGVycm9yIG1lc3NhZ2UgY2hhbmdlIGFzIGEgc2VtdmVyLW1ham9yXHJcbi8vIGNoYW5nZS4gVGhlIE5vZGVFcnJvciBjbGFzc2VzIGhlcmUgYWxsIGV4cG9zZSBhIGBjb2RlYCBwcm9wZXJ0eSB3aG9zZVxyXG4vLyB2YWx1ZSBzdGF0aWNhbGx5IGFuZCBwZXJtYW5lbnRseSBpZGVudGlmaWVzIHRoZSBlcnJvci4gV2hpbGUgdGhlIGVycm9yXHJcbi8vIG1lc3NhZ2UgbWF5IGNoYW5nZSwgdGhlIGNvZGUgc2hvdWxkIG5vdC5cclxuXHJcbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XHJcblxyXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxyXG5cclxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxyXG5cclxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XHJcblxyXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XHJcblxyXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxyXG5cclxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cclxuXHJcbnZhciBjb2RlcyA9IHt9OyAvLyBMYXp5IGxvYWRlZFxyXG5cclxudmFyIGFzc2VydDtcclxudmFyIHV0aWw7XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVFcnJvclR5cGUoY29kZSwgbWVzc2FnZSwgQmFzZSkge1xyXG4gIGlmICghQmFzZSkge1xyXG4gICAgQmFzZSA9IEVycm9yO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0TWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKSB7XHJcbiAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIHJldHVybiBtZXNzYWdlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIG1lc3NhZ2UoYXJnMSwgYXJnMiwgYXJnMyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB2YXIgTm9kZUVycm9yID1cclxuICAvKiNfX1BVUkVfXyovXHJcbiAgZnVuY3Rpb24gKF9CYXNlKSB7XHJcbiAgICBfaW5oZXJpdHMoTm9kZUVycm9yLCBfQmFzZSk7XHJcblxyXG4gICAgZnVuY3Rpb24gTm9kZUVycm9yKGFyZzEsIGFyZzIsIGFyZzMpIHtcclxuICAgICAgdmFyIF90aGlzO1xyXG5cclxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5vZGVFcnJvcik7XHJcblxyXG4gICAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihOb2RlRXJyb3IpLmNhbGwodGhpcywgZ2V0TWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKSkpO1xyXG4gICAgICBfdGhpcy5jb2RlID0gY29kZTtcclxuICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBOb2RlRXJyb3I7XHJcbiAgfShCYXNlKTtcclxuXHJcbiAgY29kZXNbY29kZV0gPSBOb2RlRXJyb3I7XHJcbn0gLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvdjEwLjguMC9saWIvaW50ZXJuYWwvZXJyb3JzLmpzXHJcblxyXG5cclxuZnVuY3Rpb24gb25lT2YoZXhwZWN0ZWQsIHRoaW5nKSB7XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkoZXhwZWN0ZWQpKSB7XHJcbiAgICB2YXIgbGVuID0gZXhwZWN0ZWQubGVuZ3RoO1xyXG4gICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5tYXAoZnVuY3Rpb24gKGkpIHtcclxuICAgICAgcmV0dXJuIFN0cmluZyhpKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGlmIChsZW4gPiAyKSB7XHJcbiAgICAgIHJldHVybiBcIm9uZSBvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWQuc2xpY2UoMCwgbGVuIC0gMSkuam9pbignLCAnKSwgXCIsIG9yIFwiKSArIGV4cGVjdGVkW2xlbiAtIDFdO1xyXG4gICAgfSBlbHNlIGlmIChsZW4gPT09IDIpIHtcclxuICAgICAgcmV0dXJuIFwib25lIG9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChleHBlY3RlZFswXSwgXCIgb3IgXCIpLmNvbmNhdChleHBlY3RlZFsxXSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gXCJvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRbMF0pO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gXCJvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoU3RyaW5nKGV4cGVjdGVkKSk7XHJcbiAgfVxyXG59IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9zdGFydHNXaXRoXHJcblxyXG5cclxuZnVuY3Rpb24gc3RhcnRzV2l0aChzdHIsIHNlYXJjaCwgcG9zKSB7XHJcbiAgcmV0dXJuIHN0ci5zdWJzdHIoIXBvcyB8fCBwb3MgPCAwID8gMCA6ICtwb3MsIHNlYXJjaC5sZW5ndGgpID09PSBzZWFyY2g7XHJcbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2VuZHNXaXRoXHJcblxyXG5cclxuZnVuY3Rpb24gZW5kc1dpdGgoc3RyLCBzZWFyY2gsIHRoaXNfbGVuKSB7XHJcbiAgaWYgKHRoaXNfbGVuID09PSB1bmRlZmluZWQgfHwgdGhpc19sZW4gPiBzdHIubGVuZ3RoKSB7XHJcbiAgICB0aGlzX2xlbiA9IHN0ci5sZW5ndGg7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3RyLnN1YnN0cmluZyh0aGlzX2xlbiAtIHNlYXJjaC5sZW5ndGgsIHRoaXNfbGVuKSA9PT0gc2VhcmNoO1xyXG59IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9pbmNsdWRlc1xyXG5cclxuXHJcbmZ1bmN0aW9uIGluY2x1ZGVzKHN0ciwgc2VhcmNoLCBzdGFydCkge1xyXG4gIGlmICh0eXBlb2Ygc3RhcnQgIT09ICdudW1iZXInKSB7XHJcbiAgICBzdGFydCA9IDA7XHJcbiAgfVxyXG5cclxuICBpZiAoc3RhcnQgKyBzZWFyY2gubGVuZ3RoID4gc3RyLmxlbmd0aCkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gc3RyLmluZGV4T2Yoc2VhcmNoLCBzdGFydCkgIT09IC0xO1xyXG4gIH1cclxufVxyXG5cclxuY3JlYXRlRXJyb3JUeXBlKCdFUlJfQU1CSUdVT1VTX0FSR1VNRU5UJywgJ1RoZSBcIiVzXCIgYXJndW1lbnQgaXMgYW1iaWd1b3VzLiAlcycsIFR5cGVFcnJvcik7XHJcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0lOVkFMSURfQVJHX1RZUEUnLCBmdW5jdGlvbiAobmFtZSwgZXhwZWN0ZWQsIGFjdHVhbCkge1xyXG4gIGlmIChhc3NlcnQgPT09IHVuZGVmaW5lZCkgYXNzZXJ0ID0gcmVxdWlyZSgnLi4vYXNzZXJ0Jyk7XHJcbiAgYXNzZXJ0KHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJywgXCInbmFtZScgbXVzdCBiZSBhIHN0cmluZ1wiKTsgLy8gZGV0ZXJtaW5lcjogJ211c3QgYmUnIG9yICdtdXN0IG5vdCBiZSdcclxuXHJcbiAgdmFyIGRldGVybWluZXI7XHJcblxyXG4gIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT09ICdzdHJpbmcnICYmIHN0YXJ0c1dpdGgoZXhwZWN0ZWQsICdub3QgJykpIHtcclxuICAgIGRldGVybWluZXIgPSAnbXVzdCBub3QgYmUnO1xyXG4gICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5yZXBsYWNlKC9ebm90IC8sICcnKTtcclxuICB9IGVsc2Uge1xyXG4gICAgZGV0ZXJtaW5lciA9ICdtdXN0IGJlJztcclxuICB9XHJcblxyXG4gIHZhciBtc2c7XHJcblxyXG4gIGlmIChlbmRzV2l0aChuYW1lLCAnIGFyZ3VtZW50JykpIHtcclxuICAgIC8vIEZvciBjYXNlcyBsaWtlICdmaXJzdCBhcmd1bWVudCdcclxuICAgIG1zZyA9IFwiVGhlIFwiLmNvbmNhdChuYW1lLCBcIiBcIikuY29uY2F0KGRldGVybWluZXIsIFwiIFwiKS5jb25jYXQob25lT2YoZXhwZWN0ZWQsICd0eXBlJykpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB2YXIgdHlwZSA9IGluY2x1ZGVzKG5hbWUsICcuJykgPyAncHJvcGVydHknIDogJ2FyZ3VtZW50JztcclxuICAgIG1zZyA9IFwiVGhlIFxcXCJcIi5jb25jYXQobmFtZSwgXCJcXFwiIFwiKS5jb25jYXQodHlwZSwgXCIgXCIpLmNvbmNhdChkZXRlcm1pbmVyLCBcIiBcIikuY29uY2F0KG9uZU9mKGV4cGVjdGVkLCAndHlwZScpKTtcclxuICB9IC8vIFRPRE8oQnJpZGdlQVIpOiBJbXByb3ZlIHRoZSBvdXRwdXQgYnkgc2hvd2luZyBgbnVsbGAgYW5kIHNpbWlsYXIuXHJcblxyXG5cclxuICBtc2cgKz0gXCIuIFJlY2VpdmVkIHR5cGUgXCIuY29uY2F0KF90eXBlb2YoYWN0dWFsKSk7XHJcbiAgcmV0dXJuIG1zZztcclxufSwgVHlwZUVycm9yKTtcclxuY3JlYXRlRXJyb3JUeXBlKCdFUlJfSU5WQUxJRF9BUkdfVkFMVUUnLCBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcclxuICB2YXIgcmVhc29uID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAnaXMgaW52YWxpZCc7XHJcbiAgaWYgKHV0aWwgPT09IHVuZGVmaW5lZCkgdXRpbCA9IHJlcXVpcmUoJ3V0aWwvJyk7XHJcbiAgdmFyIGluc3BlY3RlZCA9IHV0aWwuaW5zcGVjdCh2YWx1ZSk7XHJcblxyXG4gIGlmIChpbnNwZWN0ZWQubGVuZ3RoID4gMTI4KSB7XHJcbiAgICBpbnNwZWN0ZWQgPSBcIlwiLmNvbmNhdChpbnNwZWN0ZWQuc2xpY2UoMCwgMTI4KSwgXCIuLi5cIik7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gXCJUaGUgYXJndW1lbnQgJ1wiLmNvbmNhdChuYW1lLCBcIicgXCIpLmNvbmNhdChyZWFzb24sIFwiLiBSZWNlaXZlZCBcIikuY29uY2F0KGluc3BlY3RlZCk7XHJcbn0sIFR5cGVFcnJvciwgUmFuZ2VFcnJvcik7XHJcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0lOVkFMSURfUkVUVVJOX1ZBTFVFJywgZnVuY3Rpb24gKGlucHV0LCBuYW1lLCB2YWx1ZSkge1xyXG4gIHZhciB0eXBlO1xyXG5cclxuICBpZiAodmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IubmFtZSkge1xyXG4gICAgdHlwZSA9IFwiaW5zdGFuY2Ugb2YgXCIuY29uY2F0KHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0eXBlID0gXCJ0eXBlIFwiLmNvbmNhdChfdHlwZW9mKHZhbHVlKSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gXCJFeHBlY3RlZCBcIi5jb25jYXQoaW5wdXQsIFwiIHRvIGJlIHJldHVybmVkIGZyb20gdGhlIFxcXCJcIikuY29uY2F0KG5hbWUsIFwiXFxcIlwiKSArIFwiIGZ1bmN0aW9uIGJ1dCBnb3QgXCIuY29uY2F0KHR5cGUsIFwiLlwiKTtcclxufSwgVHlwZUVycm9yKTtcclxuY3JlYXRlRXJyb3JUeXBlKCdFUlJfTUlTU0lOR19BUkdTJywgZnVuY3Rpb24gKCkge1xyXG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xyXG4gICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcclxuICB9XHJcblxyXG4gIGlmIChhc3NlcnQgPT09IHVuZGVmaW5lZCkgYXNzZXJ0ID0gcmVxdWlyZSgnLi4vYXNzZXJ0Jyk7XHJcbiAgYXNzZXJ0KGFyZ3MubGVuZ3RoID4gMCwgJ0F0IGxlYXN0IG9uZSBhcmcgbmVlZHMgdG8gYmUgc3BlY2lmaWVkJyk7XHJcbiAgdmFyIG1zZyA9ICdUaGUgJztcclxuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XHJcbiAgYXJncyA9IGFyZ3MubWFwKGZ1bmN0aW9uIChhKSB7XHJcbiAgICByZXR1cm4gXCJcXFwiXCIuY29uY2F0KGEsIFwiXFxcIlwiKTtcclxuICB9KTtcclxuXHJcbiAgc3dpdGNoIChsZW4pIHtcclxuICAgIGNhc2UgMTpcclxuICAgICAgbXNnICs9IFwiXCIuY29uY2F0KGFyZ3NbMF0sIFwiIGFyZ3VtZW50XCIpO1xyXG4gICAgICBicmVhaztcclxuXHJcbiAgICBjYXNlIDI6XHJcbiAgICAgIG1zZyArPSBcIlwiLmNvbmNhdChhcmdzWzBdLCBcIiBhbmQgXCIpLmNvbmNhdChhcmdzWzFdLCBcIiBhcmd1bWVudHNcIik7XHJcbiAgICAgIGJyZWFrO1xyXG5cclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIG1zZyArPSBhcmdzLnNsaWNlKDAsIGxlbiAtIDEpLmpvaW4oJywgJyk7XHJcbiAgICAgIG1zZyArPSBcIiwgYW5kIFwiLmNvbmNhdChhcmdzW2xlbiAtIDFdLCBcIiBhcmd1bWVudHNcIik7XHJcbiAgICAgIGJyZWFrO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIFwiXCIuY29uY2F0KG1zZywgXCIgbXVzdCBiZSBzcGVjaWZpZWRcIik7XHJcbn0sIFR5cGVFcnJvcik7XHJcbm1vZHVsZS5leHBvcnRzLmNvZGVzID0gY29kZXM7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/assert/build/internal/errors.js\n");

/***/ }),

/***/ "./node_modules/assert/build/internal/util/comparisons.js":
/*!****************************************************************!*\
  !*** ./node_modules/assert/build/internal/util/comparisons.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("// Currently in sync with Node.js lib/internal/util/comparisons.js\r\n// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9\r\n\r\n\r\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\r\n\r\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\r\n\r\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\r\n\r\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\r\n\r\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\r\n\r\nvar regexFlagsSupported = /a/g.flags !== undefined;\r\n\r\nvar arrayFromSet = function arrayFromSet(set) {\r\n  var array = [];\r\n  set.forEach(function (value) {\r\n    return array.push(value);\r\n  });\r\n  return array;\r\n};\r\n\r\nvar arrayFromMap = function arrayFromMap(map) {\r\n  var array = [];\r\n  map.forEach(function (value, key) {\r\n    return array.push([key, value]);\r\n  });\r\n  return array;\r\n};\r\n\r\nvar objectIs = Object.is ? Object.is : __webpack_require__(/*! object-is */ \"./node_modules/object-is/index.js\");\r\nvar objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function () {\r\n  return [];\r\n};\r\nvar numberIsNaN = Number.isNaN ? Number.isNaN : __webpack_require__(/*! is-nan */ \"./node_modules/is-nan/index.js\");\r\n\r\nfunction uncurryThis(f) {\r\n  return f.call.bind(f);\r\n}\r\n\r\nvar hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);\r\nvar propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);\r\nvar objectToString = uncurryThis(Object.prototype.toString);\r\n\r\nvar _require$types = (__webpack_require__(/*! util/ */ \"./node_modules/util/util.js\").types),\r\n    isAnyArrayBuffer = _require$types.isAnyArrayBuffer,\r\n    isArrayBufferView = _require$types.isArrayBufferView,\r\n    isDate = _require$types.isDate,\r\n    isMap = _require$types.isMap,\r\n    isRegExp = _require$types.isRegExp,\r\n    isSet = _require$types.isSet,\r\n    isNativeError = _require$types.isNativeError,\r\n    isBoxedPrimitive = _require$types.isBoxedPrimitive,\r\n    isNumberObject = _require$types.isNumberObject,\r\n    isStringObject = _require$types.isStringObject,\r\n    isBooleanObject = _require$types.isBooleanObject,\r\n    isBigIntObject = _require$types.isBigIntObject,\r\n    isSymbolObject = _require$types.isSymbolObject,\r\n    isFloat32Array = _require$types.isFloat32Array,\r\n    isFloat64Array = _require$types.isFloat64Array;\r\n\r\nfunction isNonIndex(key) {\r\n  if (key.length === 0 || key.length > 10) return true;\r\n\r\n  for (var i = 0; i < key.length; i++) {\r\n    var code = key.charCodeAt(i);\r\n    if (code < 48 || code > 57) return true;\r\n  } // The maximum size for an array is 2 ** 32 -1.\r\n\r\n\r\n  return key.length === 10 && key >= Math.pow(2, 32);\r\n}\r\n\r\nfunction getOwnNonIndexProperties(value) {\r\n  return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));\r\n} // Taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js\r\n// original notice:\r\n\r\n/*!\r\n * The buffer module from node.js, for the browser.\r\n *\r\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\r\n * @license  MIT\r\n */\r\n\r\n\r\nfunction compare(a, b) {\r\n  if (a === b) {\r\n    return 0;\r\n  }\r\n\r\n  var x = a.length;\r\n  var y = b.length;\r\n\r\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\r\n    if (a[i] !== b[i]) {\r\n      x = a[i];\r\n      y = b[i];\r\n      break;\r\n    }\r\n  }\r\n\r\n  if (x < y) {\r\n    return -1;\r\n  }\r\n\r\n  if (y < x) {\r\n    return 1;\r\n  }\r\n\r\n  return 0;\r\n}\r\n\r\nvar ONLY_ENUMERABLE = undefined;\r\nvar kStrict = true;\r\nvar kLoose = false;\r\nvar kNoIterator = 0;\r\nvar kIsArray = 1;\r\nvar kIsSet = 2;\r\nvar kIsMap = 3; // Check if they have the same source and flags\r\n\r\nfunction areSimilarRegExps(a, b) {\r\n  return regexFlagsSupported ? a.source === b.source && a.flags === b.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b);\r\n}\r\n\r\nfunction areSimilarFloatArrays(a, b) {\r\n  if (a.byteLength !== b.byteLength) {\r\n    return false;\r\n  }\r\n\r\n  for (var offset = 0; offset < a.byteLength; offset++) {\r\n    if (a[offset] !== b[offset]) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction areSimilarTypedArrays(a, b) {\r\n  if (a.byteLength !== b.byteLength) {\r\n    return false;\r\n  }\r\n\r\n  return compare(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;\r\n}\r\n\r\nfunction areEqualArrayBuffers(buf1, buf2) {\r\n  return buf1.byteLength === buf2.byteLength && compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;\r\n}\r\n\r\nfunction isEqualBoxedPrimitive(val1, val2) {\r\n  if (isNumberObject(val1)) {\r\n    return isNumberObject(val2) && objectIs(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));\r\n  }\r\n\r\n  if (isStringObject(val1)) {\r\n    return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);\r\n  }\r\n\r\n  if (isBooleanObject(val1)) {\r\n    return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);\r\n  }\r\n\r\n  if (isBigIntObject(val1)) {\r\n    return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);\r\n  }\r\n\r\n  return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);\r\n} // Notes: Type tags are historical [[Class]] properties that can be set by\r\n// FunctionTemplate::SetClassName() in C++ or Symbol.toStringTag in JS\r\n// and retrieved using Object.prototype.toString.call(obj) in JS\r\n// See https://tc39.github.io/ecma262/#sec-object.prototype.tostring\r\n// for a list of tags pre-defined in the spec.\r\n// There are some unspecified tags in the wild too (e.g. typed array tags).\r\n// Since tags can be altered, they only serve fast failures\r\n//\r\n// Typed arrays and buffers are checked by comparing the content in their\r\n// underlying ArrayBuffer. This optimization requires that it's\r\n// reasonable to interpret their underlying memory in the same way,\r\n// which is checked by comparing their type tags.\r\n// (e.g. a Uint8Array and a Uint16Array with the same memory content\r\n// could still be different because they will be interpreted differently).\r\n//\r\n// For strict comparison, objects should have\r\n// a) The same built-in type tags\r\n// b) The same prototypes.\r\n\r\n\r\nfunction innerDeepEqual(val1, val2, strict, memos) {\r\n  // All identical values are equivalent, as determined by ===.\r\n  if (val1 === val2) {\r\n    if (val1 !== 0) return true;\r\n    return strict ? objectIs(val1, val2) : true;\r\n  } // Check more closely if val1 and val2 are equal.\r\n\r\n\r\n  if (strict) {\r\n    if (_typeof(val1) !== 'object') {\r\n      return typeof val1 === 'number' && numberIsNaN(val1) && numberIsNaN(val2);\r\n    }\r\n\r\n    if (_typeof(val2) !== 'object' || val1 === null || val2 === null) {\r\n      return false;\r\n    }\r\n\r\n    if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {\r\n      return false;\r\n    }\r\n  } else {\r\n    if (val1 === null || _typeof(val1) !== 'object') {\r\n      if (val2 === null || _typeof(val2) !== 'object') {\r\n        // eslint-disable-next-line eqeqeq\r\n        return val1 == val2;\r\n      }\r\n\r\n      return false;\r\n    }\r\n\r\n    if (val2 === null || _typeof(val2) !== 'object') {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  var val1Tag = objectToString(val1);\r\n  var val2Tag = objectToString(val2);\r\n\r\n  if (val1Tag !== val2Tag) {\r\n    return false;\r\n  }\r\n\r\n  if (Array.isArray(val1)) {\r\n    // Check for sparse arrays and general fast path\r\n    if (val1.length !== val2.length) {\r\n      return false;\r\n    }\r\n\r\n    var keys1 = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);\r\n    var keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);\r\n\r\n    if (keys1.length !== keys2.length) {\r\n      return false;\r\n    }\r\n\r\n    return keyCheck(val1, val2, strict, memos, kIsArray, keys1);\r\n  } // [browserify] This triggers on certain types in IE (Map/Set) so we don't\r\n  // wan't to early return out of the rest of the checks. However we can check\r\n  // if the second value is one of these values and the first isn't.\r\n\r\n\r\n  if (val1Tag === '[object Object]') {\r\n    // return keyCheck(val1, val2, strict, memos, kNoIterator);\r\n    if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2)) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  if (isDate(val1)) {\r\n    if (!isDate(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) {\r\n      return false;\r\n    }\r\n  } else if (isRegExp(val1)) {\r\n    if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) {\r\n      return false;\r\n    }\r\n  } else if (isNativeError(val1) || val1 instanceof Error) {\r\n    // Do not compare the stack as it might differ even though the error itself\r\n    // is otherwise identical.\r\n    if (val1.message !== val2.message || val1.name !== val2.name) {\r\n      return false;\r\n    }\r\n  } else if (isArrayBufferView(val1)) {\r\n    if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {\r\n      if (!areSimilarFloatArrays(val1, val2)) {\r\n        return false;\r\n      }\r\n    } else if (!areSimilarTypedArrays(val1, val2)) {\r\n      return false;\r\n    } // Buffer.compare returns true, so val1.length === val2.length. If they both\r\n    // only contain numeric keys, we don't need to exam further than checking\r\n    // the symbols.\r\n\r\n\r\n    var _keys = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);\r\n\r\n    var _keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);\r\n\r\n    if (_keys.length !== _keys2.length) {\r\n      return false;\r\n    }\r\n\r\n    return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);\r\n  } else if (isSet(val1)) {\r\n    if (!isSet(val2) || val1.size !== val2.size) {\r\n      return false;\r\n    }\r\n\r\n    return keyCheck(val1, val2, strict, memos, kIsSet);\r\n  } else if (isMap(val1)) {\r\n    if (!isMap(val2) || val1.size !== val2.size) {\r\n      return false;\r\n    }\r\n\r\n    return keyCheck(val1, val2, strict, memos, kIsMap);\r\n  } else if (isAnyArrayBuffer(val1)) {\r\n    if (!areEqualArrayBuffers(val1, val2)) {\r\n      return false;\r\n    }\r\n  } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) {\r\n    return false;\r\n  }\r\n\r\n  return keyCheck(val1, val2, strict, memos, kNoIterator);\r\n}\r\n\r\nfunction getEnumerables(val, keys) {\r\n  return keys.filter(function (k) {\r\n    return propertyIsEnumerable(val, k);\r\n  });\r\n}\r\n\r\nfunction keyCheck(val1, val2, strict, memos, iterationType, aKeys) {\r\n  // For all remaining Object pairs, including Array, objects and Maps,\r\n  // equivalence is determined by having:\r\n  // a) The same number of owned enumerable properties\r\n  // b) The same set of keys/indexes (although not necessarily the same order)\r\n  // c) Equivalent values for every corresponding key/index\r\n  // d) For Sets and Maps, equal contents\r\n  // Note: this accounts for both named and indexed properties on Arrays.\r\n  if (arguments.length === 5) {\r\n    aKeys = Object.keys(val1);\r\n    var bKeys = Object.keys(val2); // The pair must have the same number of owned properties.\r\n\r\n    if (aKeys.length !== bKeys.length) {\r\n      return false;\r\n    }\r\n  } // Cheap key test\r\n\r\n\r\n  var i = 0;\r\n\r\n  for (; i < aKeys.length; i++) {\r\n    if (!hasOwnProperty(val2, aKeys[i])) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  if (strict && arguments.length === 5) {\r\n    var symbolKeysA = objectGetOwnPropertySymbols(val1);\r\n\r\n    if (symbolKeysA.length !== 0) {\r\n      var count = 0;\r\n\r\n      for (i = 0; i < symbolKeysA.length; i++) {\r\n        var key = symbolKeysA[i];\r\n\r\n        if (propertyIsEnumerable(val1, key)) {\r\n          if (!propertyIsEnumerable(val2, key)) {\r\n            return false;\r\n          }\r\n\r\n          aKeys.push(key);\r\n          count++;\r\n        } else if (propertyIsEnumerable(val2, key)) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      var symbolKeysB = objectGetOwnPropertySymbols(val2);\r\n\r\n      if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {\r\n        return false;\r\n      }\r\n    } else {\r\n      var _symbolKeysB = objectGetOwnPropertySymbols(val2);\r\n\r\n      if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) {\r\n    return true;\r\n  } // Use memos to handle cycles.\r\n\r\n\r\n  if (memos === undefined) {\r\n    memos = {\r\n      val1: new Map(),\r\n      val2: new Map(),\r\n      position: 0\r\n    };\r\n  } else {\r\n    // We prevent up to two map.has(x) calls by directly retrieving the value\r\n    // and checking for undefined. The map can only contain numbers, so it is\r\n    // safe to check for undefined only.\r\n    var val2MemoA = memos.val1.get(val1);\r\n\r\n    if (val2MemoA !== undefined) {\r\n      var val2MemoB = memos.val2.get(val2);\r\n\r\n      if (val2MemoB !== undefined) {\r\n        return val2MemoA === val2MemoB;\r\n      }\r\n    }\r\n\r\n    memos.position++;\r\n  }\r\n\r\n  memos.val1.set(val1, memos.position);\r\n  memos.val2.set(val2, memos.position);\r\n  var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);\r\n  memos.val1.delete(val1);\r\n  memos.val2.delete(val2);\r\n  return areEq;\r\n}\r\n\r\nfunction setHasEqualElement(set, val1, strict, memo) {\r\n  // Go looking.\r\n  var setValues = arrayFromSet(set);\r\n\r\n  for (var i = 0; i < setValues.length; i++) {\r\n    var val2 = setValues[i];\r\n\r\n    if (innerDeepEqual(val1, val2, strict, memo)) {\r\n      // Remove the matching element to make sure we do not check that again.\r\n      set.delete(val2);\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n} // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#Loose_equality_using\r\n// Sadly it is not possible to detect corresponding values properly in case the\r\n// type is a string, number, bigint or boolean. The reason is that those values\r\n// can match lots of different string values (e.g., 1n == '+00001').\r\n\r\n\r\nfunction findLooseMatchingPrimitives(prim) {\r\n  switch (_typeof(prim)) {\r\n    case 'undefined':\r\n      return null;\r\n\r\n    case 'object':\r\n      // Only pass in null as object!\r\n      return undefined;\r\n\r\n    case 'symbol':\r\n      return false;\r\n\r\n    case 'string':\r\n      prim = +prim;\r\n    // Loose equal entries exist only if the string is possible to convert to\r\n    // a regular number and not NaN.\r\n    // Fall through\r\n\r\n    case 'number':\r\n      if (numberIsNaN(prim)) {\r\n        return false;\r\n      }\r\n\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction setMightHaveLoosePrim(a, b, prim) {\r\n  var altValue = findLooseMatchingPrimitives(prim);\r\n  if (altValue != null) return altValue;\r\n  return b.has(altValue) && !a.has(altValue);\r\n}\r\n\r\nfunction mapMightHaveLoosePrim(a, b, prim, item, memo) {\r\n  var altValue = findLooseMatchingPrimitives(prim);\r\n\r\n  if (altValue != null) {\r\n    return altValue;\r\n  }\r\n\r\n  var curB = b.get(altValue);\r\n\r\n  if (curB === undefined && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {\r\n    return false;\r\n  }\r\n\r\n  return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);\r\n}\r\n\r\nfunction setEquiv(a, b, strict, memo) {\r\n  // This is a lazily initiated Set of entries which have to be compared\r\n  // pairwise.\r\n  var set = null;\r\n  var aValues = arrayFromSet(a);\r\n\r\n  for (var i = 0; i < aValues.length; i++) {\r\n    var val = aValues[i]; // Note: Checking for the objects first improves the performance for object\r\n    // heavy sets but it is a minor slow down for primitives. As they are fast\r\n    // to check this improves the worst case scenario instead.\r\n\r\n    if (_typeof(val) === 'object' && val !== null) {\r\n      if (set === null) {\r\n        set = new Set();\r\n      } // If the specified value doesn't exist in the second set its an not null\r\n      // object (or non strict only: a not matching primitive) we'll need to go\r\n      // hunting for something thats deep-(strict-)equal to it. To make this\r\n      // O(n log n) complexity we have to copy these values in a new set first.\r\n\r\n\r\n      set.add(val);\r\n    } else if (!b.has(val)) {\r\n      if (strict) return false; // Fast path to detect missing string, symbol, undefined and null values.\r\n\r\n      if (!setMightHaveLoosePrim(a, b, val)) {\r\n        return false;\r\n      }\r\n\r\n      if (set === null) {\r\n        set = new Set();\r\n      }\r\n\r\n      set.add(val);\r\n    }\r\n  }\r\n\r\n  if (set !== null) {\r\n    var bValues = arrayFromSet(b);\r\n\r\n    for (var _i = 0; _i < bValues.length; _i++) {\r\n      var _val = bValues[_i]; // We have to check if a primitive value is already\r\n      // matching and only if it's not, go hunting for it.\r\n\r\n      if (_typeof(_val) === 'object' && _val !== null) {\r\n        if (!setHasEqualElement(set, _val, strict, memo)) return false;\r\n      } else if (!strict && !a.has(_val) && !setHasEqualElement(set, _val, strict, memo)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return set.size === 0;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction mapHasEqualEntry(set, map, key1, item1, strict, memo) {\r\n  // To be able to handle cases like:\r\n  //   Map([[{}, 'a'], [{}, 'b']]) vs Map([[{}, 'b'], [{}, 'a']])\r\n  // ... we need to consider *all* matching keys, not just the first we find.\r\n  var setValues = arrayFromSet(set);\r\n\r\n  for (var i = 0; i < setValues.length; i++) {\r\n    var key2 = setValues[i];\r\n\r\n    if (innerDeepEqual(key1, key2, strict, memo) && innerDeepEqual(item1, map.get(key2), strict, memo)) {\r\n      set.delete(key2);\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction mapEquiv(a, b, strict, memo) {\r\n  var set = null;\r\n  var aEntries = arrayFromMap(a);\r\n\r\n  for (var i = 0; i < aEntries.length; i++) {\r\n    var _aEntries$i = _slicedToArray(aEntries[i], 2),\r\n        key = _aEntries$i[0],\r\n        item1 = _aEntries$i[1];\r\n\r\n    if (_typeof(key) === 'object' && key !== null) {\r\n      if (set === null) {\r\n        set = new Set();\r\n      }\r\n\r\n      set.add(key);\r\n    } else {\r\n      // By directly retrieving the value we prevent another b.has(key) check in\r\n      // almost all possible cases.\r\n      var item2 = b.get(key);\r\n\r\n      if (item2 === undefined && !b.has(key) || !innerDeepEqual(item1, item2, strict, memo)) {\r\n        if (strict) return false; // Fast path to detect missing string, symbol, undefined and null\r\n        // keys.\r\n\r\n        if (!mapMightHaveLoosePrim(a, b, key, item1, memo)) return false;\r\n\r\n        if (set === null) {\r\n          set = new Set();\r\n        }\r\n\r\n        set.add(key);\r\n      }\r\n    }\r\n  }\r\n\r\n  if (set !== null) {\r\n    var bEntries = arrayFromMap(b);\r\n\r\n    for (var _i2 = 0; _i2 < bEntries.length; _i2++) {\r\n      var _bEntries$_i = _slicedToArray(bEntries[_i2], 2),\r\n          key = _bEntries$_i[0],\r\n          item = _bEntries$_i[1];\r\n\r\n      if (_typeof(key) === 'object' && key !== null) {\r\n        if (!mapHasEqualEntry(set, a, key, item, strict, memo)) return false;\r\n      } else if (!strict && (!a.has(key) || !innerDeepEqual(a.get(key), item, false, memo)) && !mapHasEqualEntry(set, a, key, item, false, memo)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return set.size === 0;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction objEquiv(a, b, strict, keys, memos, iterationType) {\r\n  // Sets and maps don't have their entries accessible via normal object\r\n  // properties.\r\n  var i = 0;\r\n\r\n  if (iterationType === kIsSet) {\r\n    if (!setEquiv(a, b, strict, memos)) {\r\n      return false;\r\n    }\r\n  } else if (iterationType === kIsMap) {\r\n    if (!mapEquiv(a, b, strict, memos)) {\r\n      return false;\r\n    }\r\n  } else if (iterationType === kIsArray) {\r\n    for (; i < a.length; i++) {\r\n      if (hasOwnProperty(a, i)) {\r\n        if (!hasOwnProperty(b, i) || !innerDeepEqual(a[i], b[i], strict, memos)) {\r\n          return false;\r\n        }\r\n      } else if (hasOwnProperty(b, i)) {\r\n        return false;\r\n      } else {\r\n        // Array is sparse.\r\n        var keysA = Object.keys(a);\r\n\r\n        for (; i < keysA.length; i++) {\r\n          var key = keysA[i];\r\n\r\n          if (!hasOwnProperty(b, key) || !innerDeepEqual(a[key], b[key], strict, memos)) {\r\n            return false;\r\n          }\r\n        }\r\n\r\n        if (keysA.length !== Object.keys(b).length) {\r\n          return false;\r\n        }\r\n\r\n        return true;\r\n      }\r\n    }\r\n  } // The pair must have equivalent values for every corresponding key.\r\n  // Possibly expensive deep test:\r\n\r\n\r\n  for (i = 0; i < keys.length; i++) {\r\n    var _key = keys[i];\r\n\r\n    if (!innerDeepEqual(a[_key], b[_key], strict, memos)) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction isDeepEqual(val1, val2) {\r\n  return innerDeepEqual(val1, val2, kLoose);\r\n}\r\n\r\nfunction isDeepStrictEqual(val1, val2) {\r\n  return innerDeepEqual(val1, val2, kStrict);\r\n}\r\n\r\nmodule.exports = {\r\n  isDeepEqual: isDeepEqual,\r\n  isDeepStrictEqual: isDeepStrictEqual\r\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXNzZXJ0L2J1aWxkL2ludGVybmFsL3V0aWwvY29tcGFyaXNvbnMuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNhO0FBQ2I7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSx5Q0FBeUMsZUFBZSxlQUFlLGdCQUFnQixvQkFBb0IsTUFBTSwwQ0FBMEMsK0JBQStCLGFBQWEscUJBQXFCLHVDQUF1QyxjQUFjLFdBQVcsWUFBWSxVQUFVLE1BQU0sbURBQW1ELFVBQVUsc0JBQXNCO0FBQzNZO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0Esd0JBQXdCLDJFQUEyRSxrQ0FBa0Msd0JBQXdCLE9BQU8sa0NBQWtDLG1JQUFtSTtBQUN6VTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsbUJBQU8sQ0FBQyxvREFBVztBQUMxRDtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsbUJBQU8sQ0FBQyw4Q0FBUTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUVBQXNCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNB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QUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2Fzc2VydC9idWlsZC9pbnRlcm5hbC91dGlsL2NvbXBhcmlzb25zLmpzPzIyZWMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ3VycmVudGx5IGluIHN5bmMgd2l0aCBOb2RlLmpzIGxpYi9pbnRlcm5hbC91dGlsL2NvbXBhcmlzb25zLmpzXHJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9jb21taXQvMTEyY2M3YzI3NTUxMjU0YWEyYjE3MDk4ZmI3NzQ4NjdmMDVlZDBkOVxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxyXG5cclxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH1cclxuXHJcbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9XHJcblxyXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7IH1cclxuXHJcbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XHJcblxyXG52YXIgcmVnZXhGbGFnc1N1cHBvcnRlZCA9IC9hL2cuZmxhZ3MgIT09IHVuZGVmaW5lZDtcclxuXHJcbnZhciBhcnJheUZyb21TZXQgPSBmdW5jdGlvbiBhcnJheUZyb21TZXQoc2V0KSB7XHJcbiAgdmFyIGFycmF5ID0gW107XHJcbiAgc2V0LmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gYXJyYXkucHVzaCh2YWx1ZSk7XHJcbiAgfSk7XHJcbiAgcmV0dXJuIGFycmF5O1xyXG59O1xyXG5cclxudmFyIGFycmF5RnJvbU1hcCA9IGZ1bmN0aW9uIGFycmF5RnJvbU1hcChtYXApIHtcclxuICB2YXIgYXJyYXkgPSBbXTtcclxuICBtYXAuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xyXG4gICAgcmV0dXJuIGFycmF5LnB1c2goW2tleSwgdmFsdWVdKTtcclxuICB9KTtcclxuICByZXR1cm4gYXJyYXk7XHJcbn07XHJcblxyXG52YXIgb2JqZWN0SXMgPSBPYmplY3QuaXMgPyBPYmplY3QuaXMgOiByZXF1aXJlKCdvYmplY3QtaXMnKTtcclxudmFyIG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzIDogZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiBbXTtcclxufTtcclxudmFyIG51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOID8gTnVtYmVyLmlzTmFOIDogcmVxdWlyZSgnaXMtbmFuJyk7XHJcblxyXG5mdW5jdGlvbiB1bmN1cnJ5VGhpcyhmKSB7XHJcbiAgcmV0dXJuIGYuY2FsbC5iaW5kKGYpO1xyXG59XHJcblxyXG52YXIgaGFzT3duUHJvcGVydHkgPSB1bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcclxudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gdW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZSk7XHJcbnZhciBvYmplY3RUb1N0cmluZyA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpO1xyXG5cclxudmFyIF9yZXF1aXJlJHR5cGVzID0gcmVxdWlyZSgndXRpbC8nKS50eXBlcyxcclxuICAgIGlzQW55QXJyYXlCdWZmZXIgPSBfcmVxdWlyZSR0eXBlcy5pc0FueUFycmF5QnVmZmVyLFxyXG4gICAgaXNBcnJheUJ1ZmZlclZpZXcgPSBfcmVxdWlyZSR0eXBlcy5pc0FycmF5QnVmZmVyVmlldyxcclxuICAgIGlzRGF0ZSA9IF9yZXF1aXJlJHR5cGVzLmlzRGF0ZSxcclxuICAgIGlzTWFwID0gX3JlcXVpcmUkdHlwZXMuaXNNYXAsXHJcbiAgICBpc1JlZ0V4cCA9IF9yZXF1aXJlJHR5cGVzLmlzUmVnRXhwLFxyXG4gICAgaXNTZXQgPSBfcmVxdWlyZSR0eXBlcy5pc1NldCxcclxuICAgIGlzTmF0aXZlRXJyb3IgPSBfcmVxdWlyZSR0eXBlcy5pc05hdGl2ZUVycm9yLFxyXG4gICAgaXNCb3hlZFByaW1pdGl2ZSA9IF9yZXF1aXJlJHR5cGVzLmlzQm94ZWRQcmltaXRpdmUsXHJcbiAgICBpc051bWJlck9iamVjdCA9IF9yZXF1aXJlJHR5cGVzLmlzTnVtYmVyT2JqZWN0LFxyXG4gICAgaXNTdHJpbmdPYmplY3QgPSBfcmVxdWlyZSR0eXBlcy5pc1N0cmluZ09iamVjdCxcclxuICAgIGlzQm9vbGVhbk9iamVjdCA9IF9yZXF1aXJlJHR5cGVzLmlzQm9vbGVhbk9iamVjdCxcclxuICAgIGlzQmlnSW50T2JqZWN0ID0gX3JlcXVpcmUkdHlwZXMuaXNCaWdJbnRPYmplY3QsXHJcbiAgICBpc1N5bWJvbE9iamVjdCA9IF9yZXF1aXJlJHR5cGVzLmlzU3ltYm9sT2JqZWN0LFxyXG4gICAgaXNGbG9hdDMyQXJyYXkgPSBfcmVxdWlyZSR0eXBlcy5pc0Zsb2F0MzJBcnJheSxcclxuICAgIGlzRmxvYXQ2NEFycmF5ID0gX3JlcXVpcmUkdHlwZXMuaXNGbG9hdDY0QXJyYXk7XHJcblxyXG5mdW5jdGlvbiBpc05vbkluZGV4KGtleSkge1xyXG4gIGlmIChrZXkubGVuZ3RoID09PSAwIHx8IGtleS5sZW5ndGggPiAxMCkgcmV0dXJuIHRydWU7XHJcblxyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICB2YXIgY29kZSA9IGtleS5jaGFyQ29kZUF0KGkpO1xyXG4gICAgaWYgKGNvZGUgPCA0OCB8fCBjb2RlID4gNTcpIHJldHVybiB0cnVlO1xyXG4gIH0gLy8gVGhlIG1heGltdW0gc2l6ZSBmb3IgYW4gYXJyYXkgaXMgMiAqKiAzMiAtMS5cclxuXHJcblxyXG4gIHJldHVybiBrZXkubGVuZ3RoID09PSAxMCAmJiBrZXkgPj0gTWF0aC5wb3coMiwgMzIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRPd25Ob25JbmRleFByb3BlcnRpZXModmFsdWUpIHtcclxuICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpLmZpbHRlcihpc05vbkluZGV4KS5jb25jYXQob2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzKHZhbHVlKS5maWx0ZXIoT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5iaW5kKHZhbHVlKSkpO1xyXG59IC8vIFRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvYmxvYi82ODBlOWU1ZTQ4OGYyMmFhYzI3NTk5YTU3ZGM4NDRhNjMxNTkyOGRkL2luZGV4LmpzXHJcbi8vIG9yaWdpbmFsIG5vdGljZTpcclxuXHJcbi8qIVxyXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cclxuICpcclxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XHJcbiAqIEBsaWNlbnNlICBNSVRcclxuICovXHJcblxyXG5cclxuZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XHJcbiAgaWYgKGEgPT09IGIpIHtcclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxuXHJcbiAgdmFyIHggPSBhLmxlbmd0aDtcclxuICB2YXIgeSA9IGIubGVuZ3RoO1xyXG5cclxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xyXG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcclxuICAgICAgeCA9IGFbaV07XHJcbiAgICAgIHkgPSBiW2ldO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmICh4IDwgeSkge1xyXG4gICAgcmV0dXJuIC0xO1xyXG4gIH1cclxuXHJcbiAgaWYgKHkgPCB4KSB7XHJcbiAgICByZXR1cm4gMTtcclxuICB9XHJcblxyXG4gIHJldHVybiAwO1xyXG59XHJcblxyXG52YXIgT05MWV9FTlVNRVJBQkxFID0gdW5kZWZpbmVkO1xyXG52YXIga1N0cmljdCA9IHRydWU7XHJcbnZhciBrTG9vc2UgPSBmYWxzZTtcclxudmFyIGtOb0l0ZXJhdG9yID0gMDtcclxudmFyIGtJc0FycmF5ID0gMTtcclxudmFyIGtJc1NldCA9IDI7XHJcbnZhciBrSXNNYXAgPSAzOyAvLyBDaGVjayBpZiB0aGV5IGhhdmUgdGhlIHNhbWUgc291cmNlIGFuZCBmbGFnc1xyXG5cclxuZnVuY3Rpb24gYXJlU2ltaWxhclJlZ0V4cHMoYSwgYikge1xyXG4gIHJldHVybiByZWdleEZsYWdzU3VwcG9ydGVkID8gYS5zb3VyY2UgPT09IGIuc291cmNlICYmIGEuZmxhZ3MgPT09IGIuZmxhZ3MgOiBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYSkgPT09IFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChiKTtcclxufVxyXG5cclxuZnVuY3Rpb24gYXJlU2ltaWxhckZsb2F0QXJyYXlzKGEsIGIpIHtcclxuICBpZiAoYS5ieXRlTGVuZ3RoICE9PSBiLmJ5dGVMZW5ndGgpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIGZvciAodmFyIG9mZnNldCA9IDA7IG9mZnNldCA8IGEuYnl0ZUxlbmd0aDsgb2Zmc2V0KyspIHtcclxuICAgIGlmIChhW29mZnNldF0gIT09IGJbb2Zmc2V0XSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gYXJlU2ltaWxhclR5cGVkQXJyYXlzKGEsIGIpIHtcclxuICBpZiAoYS5ieXRlTGVuZ3RoICE9PSBiLmJ5dGVMZW5ndGgpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIHJldHVybiBjb21wYXJlKG5ldyBVaW50OEFycmF5KGEuYnVmZmVyLCBhLmJ5dGVPZmZzZXQsIGEuYnl0ZUxlbmd0aCksIG5ldyBVaW50OEFycmF5KGIuYnVmZmVyLCBiLmJ5dGVPZmZzZXQsIGIuYnl0ZUxlbmd0aCkpID09PSAwO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhcmVFcXVhbEFycmF5QnVmZmVycyhidWYxLCBidWYyKSB7XHJcbiAgcmV0dXJuIGJ1ZjEuYnl0ZUxlbmd0aCA9PT0gYnVmMi5ieXRlTGVuZ3RoICYmIGNvbXBhcmUobmV3IFVpbnQ4QXJyYXkoYnVmMSksIG5ldyBVaW50OEFycmF5KGJ1ZjIpKSA9PT0gMDtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNFcXVhbEJveGVkUHJpbWl0aXZlKHZhbDEsIHZhbDIpIHtcclxuICBpZiAoaXNOdW1iZXJPYmplY3QodmFsMSkpIHtcclxuICAgIHJldHVybiBpc051bWJlck9iamVjdCh2YWwyKSAmJiBvYmplY3RJcyhOdW1iZXIucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwxKSwgTnVtYmVyLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMikpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGlzU3RyaW5nT2JqZWN0KHZhbDEpKSB7XHJcbiAgICByZXR1cm4gaXNTdHJpbmdPYmplY3QodmFsMikgJiYgU3RyaW5nLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMSkgPT09IFN0cmluZy5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDIpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGlzQm9vbGVhbk9iamVjdCh2YWwxKSkge1xyXG4gICAgcmV0dXJuIGlzQm9vbGVhbk9iamVjdCh2YWwyKSAmJiBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMSkgPT09IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwyKTtcclxuICB9XHJcblxyXG4gIGlmIChpc0JpZ0ludE9iamVjdCh2YWwxKSkge1xyXG4gICAgcmV0dXJuIGlzQmlnSW50T2JqZWN0KHZhbDIpICYmIEJpZ0ludC5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDEpID09PSBCaWdJbnQucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwyKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBpc1N5bWJvbE9iamVjdCh2YWwyKSAmJiBTeW1ib2wucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwxKSA9PT0gU3ltYm9sLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMik7XHJcbn0gLy8gTm90ZXM6IFR5cGUgdGFncyBhcmUgaGlzdG9yaWNhbCBbW0NsYXNzXV0gcHJvcGVydGllcyB0aGF0IGNhbiBiZSBzZXQgYnlcclxuLy8gRnVuY3Rpb25UZW1wbGF0ZTo6U2V0Q2xhc3NOYW1lKCkgaW4gQysrIG9yIFN5bWJvbC50b1N0cmluZ1RhZyBpbiBKU1xyXG4vLyBhbmQgcmV0cmlldmVkIHVzaW5nIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopIGluIEpTXHJcbi8vIFNlZSBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nXHJcbi8vIGZvciBhIGxpc3Qgb2YgdGFncyBwcmUtZGVmaW5lZCBpbiB0aGUgc3BlYy5cclxuLy8gVGhlcmUgYXJlIHNvbWUgdW5zcGVjaWZpZWQgdGFncyBpbiB0aGUgd2lsZCB0b28gKGUuZy4gdHlwZWQgYXJyYXkgdGFncykuXHJcbi8vIFNpbmNlIHRhZ3MgY2FuIGJlIGFsdGVyZWQsIHRoZXkgb25seSBzZXJ2ZSBmYXN0IGZhaWx1cmVzXHJcbi8vXHJcbi8vIFR5cGVkIGFycmF5cyBhbmQgYnVmZmVycyBhcmUgY2hlY2tlZCBieSBjb21wYXJpbmcgdGhlIGNvbnRlbnQgaW4gdGhlaXJcclxuLy8gdW5kZXJseWluZyBBcnJheUJ1ZmZlci4gVGhpcyBvcHRpbWl6YXRpb24gcmVxdWlyZXMgdGhhdCBpdCdzXHJcbi8vIHJlYXNvbmFibGUgdG8gaW50ZXJwcmV0IHRoZWlyIHVuZGVybHlpbmcgbWVtb3J5IGluIHRoZSBzYW1lIHdheSxcclxuLy8gd2hpY2ggaXMgY2hlY2tlZCBieSBjb21wYXJpbmcgdGhlaXIgdHlwZSB0YWdzLlxyXG4vLyAoZS5nLiBhIFVpbnQ4QXJyYXkgYW5kIGEgVWludDE2QXJyYXkgd2l0aCB0aGUgc2FtZSBtZW1vcnkgY29udGVudFxyXG4vLyBjb3VsZCBzdGlsbCBiZSBkaWZmZXJlbnQgYmVjYXVzZSB0aGV5IHdpbGwgYmUgaW50ZXJwcmV0ZWQgZGlmZmVyZW50bHkpLlxyXG4vL1xyXG4vLyBGb3Igc3RyaWN0IGNvbXBhcmlzb24sIG9iamVjdHMgc2hvdWxkIGhhdmVcclxuLy8gYSkgVGhlIHNhbWUgYnVpbHQtaW4gdHlwZSB0YWdzXHJcbi8vIGIpIFRoZSBzYW1lIHByb3RvdHlwZXMuXHJcblxyXG5cclxuZnVuY3Rpb24gaW5uZXJEZWVwRXF1YWwodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vcykge1xyXG4gIC8vIEFsbCBpZGVudGljYWwgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cclxuICBpZiAodmFsMSA9PT0gdmFsMikge1xyXG4gICAgaWYgKHZhbDEgIT09IDApIHJldHVybiB0cnVlO1xyXG4gICAgcmV0dXJuIHN0cmljdCA/IG9iamVjdElzKHZhbDEsIHZhbDIpIDogdHJ1ZTtcclxuICB9IC8vIENoZWNrIG1vcmUgY2xvc2VseSBpZiB2YWwxIGFuZCB2YWwyIGFyZSBlcXVhbC5cclxuXHJcblxyXG4gIGlmIChzdHJpY3QpIHtcclxuICAgIGlmIChfdHlwZW9mKHZhbDEpICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICByZXR1cm4gdHlwZW9mIHZhbDEgPT09ICdudW1iZXInICYmIG51bWJlcklzTmFOKHZhbDEpICYmIG51bWJlcklzTmFOKHZhbDIpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChfdHlwZW9mKHZhbDIpICE9PSAnb2JqZWN0JyB8fCB2YWwxID09PSBudWxsIHx8IHZhbDIgPT09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsMSkgIT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWwyKSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIGlmICh2YWwxID09PSBudWxsIHx8IF90eXBlb2YodmFsMSkgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgIGlmICh2YWwyID09PSBudWxsIHx8IF90eXBlb2YodmFsMikgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxyXG4gICAgICAgIHJldHVybiB2YWwxID09IHZhbDI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodmFsMiA9PT0gbnVsbCB8fCBfdHlwZW9mKHZhbDIpICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB2YXIgdmFsMVRhZyA9IG9iamVjdFRvU3RyaW5nKHZhbDEpO1xyXG4gIHZhciB2YWwyVGFnID0gb2JqZWN0VG9TdHJpbmcodmFsMik7XHJcblxyXG4gIGlmICh2YWwxVGFnICE9PSB2YWwyVGFnKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwxKSkge1xyXG4gICAgLy8gQ2hlY2sgZm9yIHNwYXJzZSBhcnJheXMgYW5kIGdlbmVyYWwgZmFzdCBwYXRoXHJcbiAgICBpZiAodmFsMS5sZW5ndGggIT09IHZhbDIubGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIga2V5czEgPSBnZXRPd25Ob25JbmRleFByb3BlcnRpZXModmFsMSwgT05MWV9FTlVNRVJBQkxFKTtcclxuICAgIHZhciBrZXlzMiA9IGdldE93bk5vbkluZGV4UHJvcGVydGllcyh2YWwyLCBPTkxZX0VOVU1FUkFCTEUpO1xyXG5cclxuICAgIGlmIChrZXlzMS5sZW5ndGggIT09IGtleXMyLmxlbmd0aCkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGtJc0FycmF5LCBrZXlzMSk7XHJcbiAgfSAvLyBbYnJvd3NlcmlmeV0gVGhpcyB0cmlnZ2VycyBvbiBjZXJ0YWluIHR5cGVzIGluIElFIChNYXAvU2V0KSBzbyB3ZSBkb24ndFxyXG4gIC8vIHdhbid0IHRvIGVhcmx5IHJldHVybiBvdXQgb2YgdGhlIHJlc3Qgb2YgdGhlIGNoZWNrcy4gSG93ZXZlciB3ZSBjYW4gY2hlY2tcclxuICAvLyBpZiB0aGUgc2Vjb25kIHZhbHVlIGlzIG9uZSBvZiB0aGVzZSB2YWx1ZXMgYW5kIHRoZSBmaXJzdCBpc24ndC5cclxuXHJcblxyXG4gIGlmICh2YWwxVGFnID09PSAnW29iamVjdCBPYmplY3RdJykge1xyXG4gICAgLy8gcmV0dXJuIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGtOb0l0ZXJhdG9yKTtcclxuICAgIGlmICghaXNNYXAodmFsMSkgJiYgaXNNYXAodmFsMikgfHwgIWlzU2V0KHZhbDEpICYmIGlzU2V0KHZhbDIpKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChpc0RhdGUodmFsMSkpIHtcclxuICAgIGlmICghaXNEYXRlKHZhbDIpIHx8IERhdGUucHJvdG90eXBlLmdldFRpbWUuY2FsbCh2YWwxKSAhPT0gRGF0ZS5wcm90b3R5cGUuZ2V0VGltZS5jYWxsKHZhbDIpKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKGlzUmVnRXhwKHZhbDEpKSB7XHJcbiAgICBpZiAoIWlzUmVnRXhwKHZhbDIpIHx8ICFhcmVTaW1pbGFyUmVnRXhwcyh2YWwxLCB2YWwyKSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmIChpc05hdGl2ZUVycm9yKHZhbDEpIHx8IHZhbDEgaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgLy8gRG8gbm90IGNvbXBhcmUgdGhlIHN0YWNrIGFzIGl0IG1pZ2h0IGRpZmZlciBldmVuIHRob3VnaCB0aGUgZXJyb3IgaXRzZWxmXHJcbiAgICAvLyBpcyBvdGhlcndpc2UgaWRlbnRpY2FsLlxyXG4gICAgaWYgKHZhbDEubWVzc2FnZSAhPT0gdmFsMi5tZXNzYWdlIHx8IHZhbDEubmFtZSAhPT0gdmFsMi5uYW1lKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKGlzQXJyYXlCdWZmZXJWaWV3KHZhbDEpKSB7XHJcbiAgICBpZiAoIXN0cmljdCAmJiAoaXNGbG9hdDMyQXJyYXkodmFsMSkgfHwgaXNGbG9hdDY0QXJyYXkodmFsMSkpKSB7XHJcbiAgICAgIGlmICghYXJlU2ltaWxhckZsb2F0QXJyYXlzKHZhbDEsIHZhbDIpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKCFhcmVTaW1pbGFyVHlwZWRBcnJheXModmFsMSwgdmFsMikpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSAvLyBCdWZmZXIuY29tcGFyZSByZXR1cm5zIHRydWUsIHNvIHZhbDEubGVuZ3RoID09PSB2YWwyLmxlbmd0aC4gSWYgdGhleSBib3RoXHJcbiAgICAvLyBvbmx5IGNvbnRhaW4gbnVtZXJpYyBrZXlzLCB3ZSBkb24ndCBuZWVkIHRvIGV4YW0gZnVydGhlciB0aGFuIGNoZWNraW5nXHJcbiAgICAvLyB0aGUgc3ltYm9scy5cclxuXHJcblxyXG4gICAgdmFyIF9rZXlzID0gZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzKHZhbDEsIE9OTFlfRU5VTUVSQUJMRSk7XHJcblxyXG4gICAgdmFyIF9rZXlzMiA9IGdldE93bk5vbkluZGV4UHJvcGVydGllcyh2YWwyLCBPTkxZX0VOVU1FUkFCTEUpO1xyXG5cclxuICAgIGlmIChfa2V5cy5sZW5ndGggIT09IF9rZXlzMi5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrTm9JdGVyYXRvciwgX2tleXMpO1xyXG4gIH0gZWxzZSBpZiAoaXNTZXQodmFsMSkpIHtcclxuICAgIGlmICghaXNTZXQodmFsMikgfHwgdmFsMS5zaXplICE9PSB2YWwyLnNpemUpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrSXNTZXQpO1xyXG4gIH0gZWxzZSBpZiAoaXNNYXAodmFsMSkpIHtcclxuICAgIGlmICghaXNNYXAodmFsMikgfHwgdmFsMS5zaXplICE9PSB2YWwyLnNpemUpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrSXNNYXApO1xyXG4gIH0gZWxzZSBpZiAoaXNBbnlBcnJheUJ1ZmZlcih2YWwxKSkge1xyXG4gICAgaWYgKCFhcmVFcXVhbEFycmF5QnVmZmVycyh2YWwxLCB2YWwyKSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmIChpc0JveGVkUHJpbWl0aXZlKHZhbDEpICYmICFpc0VxdWFsQm94ZWRQcmltaXRpdmUodmFsMSwgdmFsMikpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrTm9JdGVyYXRvcik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEVudW1lcmFibGVzKHZhbCwga2V5cykge1xyXG4gIHJldHVybiBrZXlzLmZpbHRlcihmdW5jdGlvbiAoaykge1xyXG4gICAgcmV0dXJuIHByb3BlcnR5SXNFbnVtZXJhYmxlKHZhbCwgayk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGl0ZXJhdGlvblR5cGUsIGFLZXlzKSB7XHJcbiAgLy8gRm9yIGFsbCByZW1haW5pbmcgT2JqZWN0IHBhaXJzLCBpbmNsdWRpbmcgQXJyYXksIG9iamVjdHMgYW5kIE1hcHMsXHJcbiAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSBoYXZpbmc6XHJcbiAgLy8gYSkgVGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIGVudW1lcmFibGUgcHJvcGVydGllc1xyXG4gIC8vIGIpIFRoZSBzYW1lIHNldCBvZiBrZXlzL2luZGV4ZXMgKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlcilcclxuICAvLyBjKSBFcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXkvaW5kZXhcclxuICAvLyBkKSBGb3IgU2V0cyBhbmQgTWFwcywgZXF1YWwgY29udGVudHNcclxuICAvLyBOb3RlOiB0aGlzIGFjY291bnRzIGZvciBib3RoIG5hbWVkIGFuZCBpbmRleGVkIHByb3BlcnRpZXMgb24gQXJyYXlzLlxyXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA1KSB7XHJcbiAgICBhS2V5cyA9IE9iamVjdC5rZXlzKHZhbDEpO1xyXG4gICAgdmFyIGJLZXlzID0gT2JqZWN0LmtleXModmFsMik7IC8vIFRoZSBwYWlyIG11c3QgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcy5cclxuXHJcbiAgICBpZiAoYUtleXMubGVuZ3RoICE9PSBiS2V5cy5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH0gLy8gQ2hlYXAga2V5IHRlc3RcclxuXHJcblxyXG4gIHZhciBpID0gMDtcclxuXHJcbiAgZm9yICg7IGkgPCBhS2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2YWwyLCBhS2V5c1tpXSkpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKHN0cmljdCAmJiBhcmd1bWVudHMubGVuZ3RoID09PSA1KSB7XHJcbiAgICB2YXIgc3ltYm9sS2V5c0EgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsMSk7XHJcblxyXG4gICAgaWYgKHN5bWJvbEtleXNBLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICB2YXIgY291bnQgPSAwO1xyXG5cclxuICAgICAgZm9yIChpID0gMDsgaSA8IHN5bWJvbEtleXNBLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIGtleSA9IHN5bWJvbEtleXNBW2ldO1xyXG5cclxuICAgICAgICBpZiAocHJvcGVydHlJc0VudW1lcmFibGUodmFsMSwga2V5KSkge1xyXG4gICAgICAgICAgaWYgKCFwcm9wZXJ0eUlzRW51bWVyYWJsZSh2YWwyLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBhS2V5cy5wdXNoKGtleSk7XHJcbiAgICAgICAgICBjb3VudCsrO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocHJvcGVydHlJc0VudW1lcmFibGUodmFsMiwga2V5KSkge1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHN5bWJvbEtleXNCID0gb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzKHZhbDIpO1xyXG5cclxuICAgICAgaWYgKHN5bWJvbEtleXNBLmxlbmd0aCAhPT0gc3ltYm9sS2V5c0IubGVuZ3RoICYmIGdldEVudW1lcmFibGVzKHZhbDIsIHN5bWJvbEtleXNCKS5sZW5ndGggIT09IGNvdW50KSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YXIgX3N5bWJvbEtleXNCID0gb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzKHZhbDIpO1xyXG5cclxuICAgICAgaWYgKF9zeW1ib2xLZXlzQi5sZW5ndGggIT09IDAgJiYgZ2V0RW51bWVyYWJsZXModmFsMiwgX3N5bWJvbEtleXNCKS5sZW5ndGggIT09IDApIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChhS2V5cy5sZW5ndGggPT09IDAgJiYgKGl0ZXJhdGlvblR5cGUgPT09IGtOb0l0ZXJhdG9yIHx8IGl0ZXJhdGlvblR5cGUgPT09IGtJc0FycmF5ICYmIHZhbDEubGVuZ3RoID09PSAwIHx8IHZhbDEuc2l6ZSA9PT0gMCkpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH0gLy8gVXNlIG1lbW9zIHRvIGhhbmRsZSBjeWNsZXMuXHJcblxyXG5cclxuICBpZiAobWVtb3MgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgbWVtb3MgPSB7XHJcbiAgICAgIHZhbDE6IG5ldyBNYXAoKSxcclxuICAgICAgdmFsMjogbmV3IE1hcCgpLFxyXG4gICAgICBwb3NpdGlvbjogMFxyXG4gICAgfTtcclxuICB9IGVsc2Uge1xyXG4gICAgLy8gV2UgcHJldmVudCB1cCB0byB0d28gbWFwLmhhcyh4KSBjYWxscyBieSBkaXJlY3RseSByZXRyaWV2aW5nIHRoZSB2YWx1ZVxyXG4gICAgLy8gYW5kIGNoZWNraW5nIGZvciB1bmRlZmluZWQuIFRoZSBtYXAgY2FuIG9ubHkgY29udGFpbiBudW1iZXJzLCBzbyBpdCBpc1xyXG4gICAgLy8gc2FmZSB0byBjaGVjayBmb3IgdW5kZWZpbmVkIG9ubHkuXHJcbiAgICB2YXIgdmFsMk1lbW9BID0gbWVtb3MudmFsMS5nZXQodmFsMSk7XHJcblxyXG4gICAgaWYgKHZhbDJNZW1vQSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHZhciB2YWwyTWVtb0IgPSBtZW1vcy52YWwyLmdldCh2YWwyKTtcclxuXHJcbiAgICAgIGlmICh2YWwyTWVtb0IgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiB2YWwyTWVtb0EgPT09IHZhbDJNZW1vQjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG1lbW9zLnBvc2l0aW9uKys7XHJcbiAgfVxyXG5cclxuICBtZW1vcy52YWwxLnNldCh2YWwxLCBtZW1vcy5wb3NpdGlvbik7XHJcbiAgbWVtb3MudmFsMi5zZXQodmFsMiwgbWVtb3MucG9zaXRpb24pO1xyXG4gIHZhciBhcmVFcSA9IG9iakVxdWl2KHZhbDEsIHZhbDIsIHN0cmljdCwgYUtleXMsIG1lbW9zLCBpdGVyYXRpb25UeXBlKTtcclxuICBtZW1vcy52YWwxLmRlbGV0ZSh2YWwxKTtcclxuICBtZW1vcy52YWwyLmRlbGV0ZSh2YWwyKTtcclxuICByZXR1cm4gYXJlRXE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldEhhc0VxdWFsRWxlbWVudChzZXQsIHZhbDEsIHN0cmljdCwgbWVtbykge1xyXG4gIC8vIEdvIGxvb2tpbmcuXHJcbiAgdmFyIHNldFZhbHVlcyA9IGFycmF5RnJvbVNldChzZXQpO1xyXG5cclxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNldFZhbHVlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgdmFyIHZhbDIgPSBzZXRWYWx1ZXNbaV07XHJcblxyXG4gICAgaWYgKGlubmVyRGVlcEVxdWFsKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtbykpIHtcclxuICAgICAgLy8gUmVtb3ZlIHRoZSBtYXRjaGluZyBlbGVtZW50IHRvIG1ha2Ugc3VyZSB3ZSBkbyBub3QgY2hlY2sgdGhhdCBhZ2Fpbi5cclxuICAgICAgc2V0LmRlbGV0ZSh2YWwyKTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZmFsc2U7XHJcbn0gLy8gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvRXF1YWxpdHlfY29tcGFyaXNvbnNfYW5kX3NhbWVuZXNzI0xvb3NlX2VxdWFsaXR5X3VzaW5nXHJcbi8vIFNhZGx5IGl0IGlzIG5vdCBwb3NzaWJsZSB0byBkZXRlY3QgY29ycmVzcG9uZGluZyB2YWx1ZXMgcHJvcGVybHkgaW4gY2FzZSB0aGVcclxuLy8gdHlwZSBpcyBhIHN0cmluZywgbnVtYmVyLCBiaWdpbnQgb3IgYm9vbGVhbi4gVGhlIHJlYXNvbiBpcyB0aGF0IHRob3NlIHZhbHVlc1xyXG4vLyBjYW4gbWF0Y2ggbG90cyBvZiBkaWZmZXJlbnQgc3RyaW5nIHZhbHVlcyAoZS5nLiwgMW4gPT0gJyswMDAwMScpLlxyXG5cclxuXHJcbmZ1bmN0aW9uIGZpbmRMb29zZU1hdGNoaW5nUHJpbWl0aXZlcyhwcmltKSB7XHJcbiAgc3dpdGNoIChfdHlwZW9mKHByaW0pKSB7XHJcbiAgICBjYXNlICd1bmRlZmluZWQnOlxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICBjYXNlICdvYmplY3QnOlxyXG4gICAgICAvLyBPbmx5IHBhc3MgaW4gbnVsbCBhcyBvYmplY3QhXHJcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcblxyXG4gICAgY2FzZSAnc3ltYm9sJzpcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgIGNhc2UgJ3N0cmluZyc6XHJcbiAgICAgIHByaW0gPSArcHJpbTtcclxuICAgIC8vIExvb3NlIGVxdWFsIGVudHJpZXMgZXhpc3Qgb25seSBpZiB0aGUgc3RyaW5nIGlzIHBvc3NpYmxlIHRvIGNvbnZlcnQgdG9cclxuICAgIC8vIGEgcmVndWxhciBudW1iZXIgYW5kIG5vdCBOYU4uXHJcbiAgICAvLyBGYWxsIHRocm91Z2hcclxuXHJcbiAgICBjYXNlICdudW1iZXInOlxyXG4gICAgICBpZiAobnVtYmVySXNOYU4ocHJpbSkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgfVxyXG5cclxuICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2V0TWlnaHRIYXZlTG9vc2VQcmltKGEsIGIsIHByaW0pIHtcclxuICB2YXIgYWx0VmFsdWUgPSBmaW5kTG9vc2VNYXRjaGluZ1ByaW1pdGl2ZXMocHJpbSk7XHJcbiAgaWYgKGFsdFZhbHVlICE9IG51bGwpIHJldHVybiBhbHRWYWx1ZTtcclxuICByZXR1cm4gYi5oYXMoYWx0VmFsdWUpICYmICFhLmhhcyhhbHRWYWx1ZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1hcE1pZ2h0SGF2ZUxvb3NlUHJpbShhLCBiLCBwcmltLCBpdGVtLCBtZW1vKSB7XHJcbiAgdmFyIGFsdFZhbHVlID0gZmluZExvb3NlTWF0Y2hpbmdQcmltaXRpdmVzKHByaW0pO1xyXG5cclxuICBpZiAoYWx0VmFsdWUgIT0gbnVsbCkge1xyXG4gICAgcmV0dXJuIGFsdFZhbHVlO1xyXG4gIH1cclxuXHJcbiAgdmFyIGN1ckIgPSBiLmdldChhbHRWYWx1ZSk7XHJcblxyXG4gIGlmIChjdXJCID09PSB1bmRlZmluZWQgJiYgIWIuaGFzKGFsdFZhbHVlKSB8fCAhaW5uZXJEZWVwRXF1YWwoaXRlbSwgY3VyQiwgZmFsc2UsIG1lbW8pKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gIWEuaGFzKGFsdFZhbHVlKSAmJiBpbm5lckRlZXBFcXVhbChpdGVtLCBjdXJCLCBmYWxzZSwgbWVtbyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldEVxdWl2KGEsIGIsIHN0cmljdCwgbWVtbykge1xyXG4gIC8vIFRoaXMgaXMgYSBsYXppbHkgaW5pdGlhdGVkIFNldCBvZiBlbnRyaWVzIHdoaWNoIGhhdmUgdG8gYmUgY29tcGFyZWRcclxuICAvLyBwYWlyd2lzZS5cclxuICB2YXIgc2V0ID0gbnVsbDtcclxuICB2YXIgYVZhbHVlcyA9IGFycmF5RnJvbVNldChhKTtcclxuXHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhVmFsdWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICB2YXIgdmFsID0gYVZhbHVlc1tpXTsgLy8gTm90ZTogQ2hlY2tpbmcgZm9yIHRoZSBvYmplY3RzIGZpcnN0IGltcHJvdmVzIHRoZSBwZXJmb3JtYW5jZSBmb3Igb2JqZWN0XHJcbiAgICAvLyBoZWF2eSBzZXRzIGJ1dCBpdCBpcyBhIG1pbm9yIHNsb3cgZG93biBmb3IgcHJpbWl0aXZlcy4gQXMgdGhleSBhcmUgZmFzdFxyXG4gICAgLy8gdG8gY2hlY2sgdGhpcyBpbXByb3ZlcyB0aGUgd29yc3QgY2FzZSBzY2VuYXJpbyBpbnN0ZWFkLlxyXG5cclxuICAgIGlmIChfdHlwZW9mKHZhbCkgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCkge1xyXG4gICAgICBpZiAoc2V0ID09PSBudWxsKSB7XHJcbiAgICAgICAgc2V0ID0gbmV3IFNldCgpO1xyXG4gICAgICB9IC8vIElmIHRoZSBzcGVjaWZpZWQgdmFsdWUgZG9lc24ndCBleGlzdCBpbiB0aGUgc2Vjb25kIHNldCBpdHMgYW4gbm90IG51bGxcclxuICAgICAgLy8gb2JqZWN0IChvciBub24gc3RyaWN0IG9ubHk6IGEgbm90IG1hdGNoaW5nIHByaW1pdGl2ZSkgd2UnbGwgbmVlZCB0byBnb1xyXG4gICAgICAvLyBodW50aW5nIGZvciBzb21ldGhpbmcgdGhhdHMgZGVlcC0oc3RyaWN0LSllcXVhbCB0byBpdC4gVG8gbWFrZSB0aGlzXHJcbiAgICAgIC8vIE8obiBsb2cgbikgY29tcGxleGl0eSB3ZSBoYXZlIHRvIGNvcHkgdGhlc2UgdmFsdWVzIGluIGEgbmV3IHNldCBmaXJzdC5cclxuXHJcblxyXG4gICAgICBzZXQuYWRkKHZhbCk7XHJcbiAgICB9IGVsc2UgaWYgKCFiLmhhcyh2YWwpKSB7XHJcbiAgICAgIGlmIChzdHJpY3QpIHJldHVybiBmYWxzZTsgLy8gRmFzdCBwYXRoIHRvIGRldGVjdCBtaXNzaW5nIHN0cmluZywgc3ltYm9sLCB1bmRlZmluZWQgYW5kIG51bGwgdmFsdWVzLlxyXG5cclxuICAgICAgaWYgKCFzZXRNaWdodEhhdmVMb29zZVByaW0oYSwgYiwgdmFsKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHNldCA9PT0gbnVsbCkge1xyXG4gICAgICAgIHNldCA9IG5ldyBTZXQoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgc2V0LmFkZCh2YWwpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKHNldCAhPT0gbnVsbCkge1xyXG4gICAgdmFyIGJWYWx1ZXMgPSBhcnJheUZyb21TZXQoYik7XHJcblxyXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGJWYWx1ZXMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgIHZhciBfdmFsID0gYlZhbHVlc1tfaV07IC8vIFdlIGhhdmUgdG8gY2hlY2sgaWYgYSBwcmltaXRpdmUgdmFsdWUgaXMgYWxyZWFkeVxyXG4gICAgICAvLyBtYXRjaGluZyBhbmQgb25seSBpZiBpdCdzIG5vdCwgZ28gaHVudGluZyBmb3IgaXQuXHJcblxyXG4gICAgICBpZiAoX3R5cGVvZihfdmFsKSA9PT0gJ29iamVjdCcgJiYgX3ZhbCAhPT0gbnVsbCkge1xyXG4gICAgICAgIGlmICghc2V0SGFzRXF1YWxFbGVtZW50KHNldCwgX3ZhbCwgc3RyaWN0LCBtZW1vKSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgIWEuaGFzKF92YWwpICYmICFzZXRIYXNFcXVhbEVsZW1lbnQoc2V0LCBfdmFsLCBzdHJpY3QsIG1lbW8pKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHNldC5zaXplID09PSAwO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1hcEhhc0VxdWFsRW50cnkoc2V0LCBtYXAsIGtleTEsIGl0ZW0xLCBzdHJpY3QsIG1lbW8pIHtcclxuICAvLyBUbyBiZSBhYmxlIHRvIGhhbmRsZSBjYXNlcyBsaWtlOlxyXG4gIC8vICAgTWFwKFtbe30sICdhJ10sIFt7fSwgJ2InXV0pIHZzIE1hcChbW3t9LCAnYiddLCBbe30sICdhJ11dKVxyXG4gIC8vIC4uLiB3ZSBuZWVkIHRvIGNvbnNpZGVyICphbGwqIG1hdGNoaW5nIGtleXMsIG5vdCBqdXN0IHRoZSBmaXJzdCB3ZSBmaW5kLlxyXG4gIHZhciBzZXRWYWx1ZXMgPSBhcnJheUZyb21TZXQoc2V0KTtcclxuXHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgIHZhciBrZXkyID0gc2V0VmFsdWVzW2ldO1xyXG5cclxuICAgIGlmIChpbm5lckRlZXBFcXVhbChrZXkxLCBrZXkyLCBzdHJpY3QsIG1lbW8pICYmIGlubmVyRGVlcEVxdWFsKGl0ZW0xLCBtYXAuZ2V0KGtleTIpLCBzdHJpY3QsIG1lbW8pKSB7XHJcbiAgICAgIHNldC5kZWxldGUoa2V5Mik7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBtYXBFcXVpdihhLCBiLCBzdHJpY3QsIG1lbW8pIHtcclxuICB2YXIgc2V0ID0gbnVsbDtcclxuICB2YXIgYUVudHJpZXMgPSBhcnJheUZyb21NYXAoYSk7XHJcblxyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYUVudHJpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgIHZhciBfYUVudHJpZXMkaSA9IF9zbGljZWRUb0FycmF5KGFFbnRyaWVzW2ldLCAyKSxcclxuICAgICAgICBrZXkgPSBfYUVudHJpZXMkaVswXSxcclxuICAgICAgICBpdGVtMSA9IF9hRW50cmllcyRpWzFdO1xyXG5cclxuICAgIGlmIChfdHlwZW9mKGtleSkgPT09ICdvYmplY3QnICYmIGtleSAhPT0gbnVsbCkge1xyXG4gICAgICBpZiAoc2V0ID09PSBudWxsKSB7XHJcbiAgICAgICAgc2V0ID0gbmV3IFNldCgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzZXQuYWRkKGtleSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBCeSBkaXJlY3RseSByZXRyaWV2aW5nIHRoZSB2YWx1ZSB3ZSBwcmV2ZW50IGFub3RoZXIgYi5oYXMoa2V5KSBjaGVjayBpblxyXG4gICAgICAvLyBhbG1vc3QgYWxsIHBvc3NpYmxlIGNhc2VzLlxyXG4gICAgICB2YXIgaXRlbTIgPSBiLmdldChrZXkpO1xyXG5cclxuICAgICAgaWYgKGl0ZW0yID09PSB1bmRlZmluZWQgJiYgIWIuaGFzKGtleSkgfHwgIWlubmVyRGVlcEVxdWFsKGl0ZW0xLCBpdGVtMiwgc3RyaWN0LCBtZW1vKSkge1xyXG4gICAgICAgIGlmIChzdHJpY3QpIHJldHVybiBmYWxzZTsgLy8gRmFzdCBwYXRoIHRvIGRldGVjdCBtaXNzaW5nIHN0cmluZywgc3ltYm9sLCB1bmRlZmluZWQgYW5kIG51bGxcclxuICAgICAgICAvLyBrZXlzLlxyXG5cclxuICAgICAgICBpZiAoIW1hcE1pZ2h0SGF2ZUxvb3NlUHJpbShhLCBiLCBrZXksIGl0ZW0xLCBtZW1vKSkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICBpZiAoc2V0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICBzZXQgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzZXQuYWRkKGtleSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChzZXQgIT09IG51bGwpIHtcclxuICAgIHZhciBiRW50cmllcyA9IGFycmF5RnJvbU1hcChiKTtcclxuXHJcbiAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBiRW50cmllcy5sZW5ndGg7IF9pMisrKSB7XHJcbiAgICAgIHZhciBfYkVudHJpZXMkX2kgPSBfc2xpY2VkVG9BcnJheShiRW50cmllc1tfaTJdLCAyKSxcclxuICAgICAgICAgIGtleSA9IF9iRW50cmllcyRfaVswXSxcclxuICAgICAgICAgIGl0ZW0gPSBfYkVudHJpZXMkX2lbMV07XHJcblxyXG4gICAgICBpZiAoX3R5cGVvZihrZXkpID09PSAnb2JqZWN0JyAmJiBrZXkgIT09IG51bGwpIHtcclxuICAgICAgICBpZiAoIW1hcEhhc0VxdWFsRW50cnkoc2V0LCBhLCBrZXksIGl0ZW0sIHN0cmljdCwgbWVtbykpIHJldHVybiBmYWxzZTtcclxuICAgICAgfSBlbHNlIGlmICghc3RyaWN0ICYmICghYS5oYXMoa2V5KSB8fCAhaW5uZXJEZWVwRXF1YWwoYS5nZXQoa2V5KSwgaXRlbSwgZmFsc2UsIG1lbW8pKSAmJiAhbWFwSGFzRXF1YWxFbnRyeShzZXQsIGEsIGtleSwgaXRlbSwgZmFsc2UsIG1lbW8pKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHNldC5zaXplID09PSAwO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG9iakVxdWl2KGEsIGIsIHN0cmljdCwga2V5cywgbWVtb3MsIGl0ZXJhdGlvblR5cGUpIHtcclxuICAvLyBTZXRzIGFuZCBtYXBzIGRvbid0IGhhdmUgdGhlaXIgZW50cmllcyBhY2Nlc3NpYmxlIHZpYSBub3JtYWwgb2JqZWN0XHJcbiAgLy8gcHJvcGVydGllcy5cclxuICB2YXIgaSA9IDA7XHJcblxyXG4gIGlmIChpdGVyYXRpb25UeXBlID09PSBrSXNTZXQpIHtcclxuICAgIGlmICghc2V0RXF1aXYoYSwgYiwgc3RyaWN0LCBtZW1vcykpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoaXRlcmF0aW9uVHlwZSA9PT0ga0lzTWFwKSB7XHJcbiAgICBpZiAoIW1hcEVxdWl2KGEsIGIsIHN0cmljdCwgbWVtb3MpKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKGl0ZXJhdGlvblR5cGUgPT09IGtJc0FycmF5KSB7XHJcbiAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgaWYgKGhhc093blByb3BlcnR5KGEsIGkpKSB7XHJcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShiLCBpKSB8fCAhaW5uZXJEZWVwRXF1YWwoYVtpXSwgYltpXSwgc3RyaWN0LCBtZW1vcykpIHtcclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAoaGFzT3duUHJvcGVydHkoYiwgaSkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gQXJyYXkgaXMgc3BhcnNlLlxyXG4gICAgICAgIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKGEpO1xyXG5cclxuICAgICAgICBmb3IgKDsgaSA8IGtleXNBLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICB2YXIga2V5ID0ga2V5c0FbaV07XHJcblxyXG4gICAgICAgICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShiLCBrZXkpIHx8ICFpbm5lckRlZXBFcXVhbChhW2tleV0sIGJba2V5XSwgc3RyaWN0LCBtZW1vcykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGtleXNBLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKSB7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0gLy8gVGhlIHBhaXIgbXVzdCBoYXZlIGVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleS5cclxuICAvLyBQb3NzaWJseSBleHBlbnNpdmUgZGVlcCB0ZXN0OlxyXG5cclxuXHJcbiAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgIHZhciBfa2V5ID0ga2V5c1tpXTtcclxuXHJcbiAgICBpZiAoIWlubmVyRGVlcEVxdWFsKGFbX2tleV0sIGJbX2tleV0sIHN0cmljdCwgbWVtb3MpKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB0cnVlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc0RlZXBFcXVhbCh2YWwxLCB2YWwyKSB7XHJcbiAgcmV0dXJuIGlubmVyRGVlcEVxdWFsKHZhbDEsIHZhbDIsIGtMb29zZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzRGVlcFN0cmljdEVxdWFsKHZhbDEsIHZhbDIpIHtcclxuICByZXR1cm4gaW5uZXJEZWVwRXF1YWwodmFsMSwgdmFsMiwga1N0cmljdCk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gIGlzRGVlcEVxdWFsOiBpc0RlZXBFcXVhbCxcclxuICBpc0RlZXBTdHJpY3RFcXVhbDogaXNEZWVwU3RyaWN0RXF1YWxcclxufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/assert/build/internal/util/comparisons.js\n");

/***/ }),

/***/ "./node_modules/base64url/dist/base64url.js":
/*!**************************************************!*\
  !*** ./node_modules/base64url/dist/base64url.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nvar pad_string_1 = __webpack_require__(/*! ./pad-string */ \"./node_modules/base64url/dist/pad-string.js\");\r\nfunction encode(input, encoding) {\r\n    if (encoding === void 0) { encoding = \"utf8\"; }\r\n    if (Buffer.isBuffer(input)) {\r\n        return fromBase64(input.toString(\"base64\"));\r\n    }\r\n    return fromBase64(Buffer.from(input, encoding).toString(\"base64\"));\r\n}\r\n;\r\nfunction decode(base64url, encoding) {\r\n    if (encoding === void 0) { encoding = \"utf8\"; }\r\n    return Buffer.from(toBase64(base64url), \"base64\").toString(encoding);\r\n}\r\nfunction toBase64(base64url) {\r\n    base64url = base64url.toString();\r\n    return pad_string_1.default(base64url)\r\n        .replace(/\\-/g, \"+\")\r\n        .replace(/_/g, \"/\");\r\n}\r\nfunction fromBase64(base64) {\r\n    return base64\r\n        .replace(/=/g, \"\")\r\n        .replace(/\\+/g, \"-\")\r\n        .replace(/\\//g, \"_\");\r\n}\r\nfunction toBuffer(base64url) {\r\n    return Buffer.from(toBase64(base64url), \"base64\");\r\n}\r\nvar base64url = encode;\r\nbase64url.encode = encode;\r\nbase64url.decode = decode;\r\nbase64url.toBase64 = toBase64;\r\nbase64url.fromBase64 = fromBase64;\r\nbase64url.toBuffer = toBuffer;\r\nexports[\"default\"] = base64url;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFzZTY0dXJsL2Rpc3QvYmFzZTY0dXJsLmpzLmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsbUJBQU8sQ0FBQyxpRUFBYztBQUN6QztBQUNBLCtCQUErQjtBQUMvQixRQUFRLE1BQU07QUFDZDtBQUNBO0FBQ0Esc0JBQXNCLE1BQU07QUFDNUI7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2Jhc2U2NHVybC9kaXN0L2Jhc2U2NHVybC5qcz85N2I4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBwYWRfc3RyaW5nXzEgPSByZXF1aXJlKFwiLi9wYWQtc3RyaW5nXCIpO1xyXG5mdW5jdGlvbiBlbmNvZGUoaW5wdXQsIGVuY29kaW5nKSB7XHJcbiAgICBpZiAoZW5jb2RpbmcgPT09IHZvaWQgMCkgeyBlbmNvZGluZyA9IFwidXRmOFwiOyB9XHJcbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGlucHV0KSkge1xyXG4gICAgICAgIHJldHVybiBmcm9tQmFzZTY0KGlucHV0LnRvU3RyaW5nKFwiYmFzZTY0XCIpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmcm9tQmFzZTY0KEJ1ZmZlci5mcm9tKGlucHV0LCBlbmNvZGluZykudG9TdHJpbmcoXCJiYXNlNjRcIikpO1xyXG59XHJcbjtcclxuZnVuY3Rpb24gZGVjb2RlKGJhc2U2NHVybCwgZW5jb2RpbmcpIHtcclxuICAgIGlmIChlbmNvZGluZyA9PT0gdm9pZCAwKSB7IGVuY29kaW5nID0gXCJ1dGY4XCI7IH1cclxuICAgIHJldHVybiBCdWZmZXIuZnJvbSh0b0Jhc2U2NChiYXNlNjR1cmwpLCBcImJhc2U2NFwiKS50b1N0cmluZyhlbmNvZGluZyk7XHJcbn1cclxuZnVuY3Rpb24gdG9CYXNlNjQoYmFzZTY0dXJsKSB7XHJcbiAgICBiYXNlNjR1cmwgPSBiYXNlNjR1cmwudG9TdHJpbmcoKTtcclxuICAgIHJldHVybiBwYWRfc3RyaW5nXzEuZGVmYXVsdChiYXNlNjR1cmwpXHJcbiAgICAgICAgLnJlcGxhY2UoL1xcLS9nLCBcIitcIilcclxuICAgICAgICAucmVwbGFjZSgvXy9nLCBcIi9cIik7XHJcbn1cclxuZnVuY3Rpb24gZnJvbUJhc2U2NChiYXNlNjQpIHtcclxuICAgIHJldHVybiBiYXNlNjRcclxuICAgICAgICAucmVwbGFjZSgvPS9nLCBcIlwiKVxyXG4gICAgICAgIC5yZXBsYWNlKC9cXCsvZywgXCItXCIpXHJcbiAgICAgICAgLnJlcGxhY2UoL1xcLy9nLCBcIl9cIik7XHJcbn1cclxuZnVuY3Rpb24gdG9CdWZmZXIoYmFzZTY0dXJsKSB7XHJcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odG9CYXNlNjQoYmFzZTY0dXJsKSwgXCJiYXNlNjRcIik7XHJcbn1cclxudmFyIGJhc2U2NHVybCA9IGVuY29kZTtcclxuYmFzZTY0dXJsLmVuY29kZSA9IGVuY29kZTtcclxuYmFzZTY0dXJsLmRlY29kZSA9IGRlY29kZTtcclxuYmFzZTY0dXJsLnRvQmFzZTY0ID0gdG9CYXNlNjQ7XHJcbmJhc2U2NHVybC5mcm9tQmFzZTY0ID0gZnJvbUJhc2U2NDtcclxuYmFzZTY0dXJsLnRvQnVmZmVyID0gdG9CdWZmZXI7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IGJhc2U2NHVybDtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/base64url/dist/base64url.js\n");

/***/ }),

/***/ "./node_modules/base64url/dist/pad-string.js":
/*!***************************************************!*\
  !*** ./node_modules/base64url/dist/pad-string.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nfunction padString(input) {\r\n    var segmentLength = 4;\r\n    var stringLength = input.length;\r\n    var diff = stringLength % segmentLength;\r\n    if (!diff) {\r\n        return input;\r\n    }\r\n    var position = stringLength;\r\n    var padLength = segmentLength - diff;\r\n    var paddedStringLength = stringLength + padLength;\r\n    var buffer = Buffer.alloc(paddedStringLength);\r\n    buffer.write(input);\r\n    while (padLength--) {\r\n        buffer.write(\"=\", position++);\r\n    }\r\n    return buffer.toString();\r\n}\r\nexports[\"default\"] = padString;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFzZTY0dXJsL2Rpc3QvcGFkLXN0cmluZy5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYmFzZTY0dXJsL2Rpc3QvcGFkLXN0cmluZy5qcz8wY2E2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmZ1bmN0aW9uIHBhZFN0cmluZyhpbnB1dCkge1xyXG4gICAgdmFyIHNlZ21lbnRMZW5ndGggPSA0O1xyXG4gICAgdmFyIHN0cmluZ0xlbmd0aCA9IGlucHV0Lmxlbmd0aDtcclxuICAgIHZhciBkaWZmID0gc3RyaW5nTGVuZ3RoICUgc2VnbWVudExlbmd0aDtcclxuICAgIGlmICghZGlmZikge1xyXG4gICAgICAgIHJldHVybiBpbnB1dDtcclxuICAgIH1cclxuICAgIHZhciBwb3NpdGlvbiA9IHN0cmluZ0xlbmd0aDtcclxuICAgIHZhciBwYWRMZW5ndGggPSBzZWdtZW50TGVuZ3RoIC0gZGlmZjtcclxuICAgIHZhciBwYWRkZWRTdHJpbmdMZW5ndGggPSBzdHJpbmdMZW5ndGggKyBwYWRMZW5ndGg7XHJcbiAgICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKHBhZGRlZFN0cmluZ0xlbmd0aCk7XHJcbiAgICBidWZmZXIud3JpdGUoaW5wdXQpO1xyXG4gICAgd2hpbGUgKHBhZExlbmd0aC0tKSB7XHJcbiAgICAgICAgYnVmZmVyLndyaXRlKFwiPVwiLCBwb3NpdGlvbisrKTtcclxuICAgIH1cclxuICAgIHJldHVybiBidWZmZXIudG9TdHJpbmcoKTtcclxufVxyXG5leHBvcnRzLmRlZmF1bHQgPSBwYWRTdHJpbmc7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/base64url/dist/pad-string.js\n");

/***/ }),

/***/ "./node_modules/base64url/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64url/index.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./dist/base64url */ \"./node_modules/base64url/dist/base64url.js\")[\"default\"];\r\nmodule.exports[\"default\"] = module.exports;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFzZTY0dXJsL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLHFIQUFvRDtBQUNwRCx5QkFBc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2Jhc2U2NHVybC9pbmRleC5qcz85ZTg3Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L2Jhc2U2NHVybCcpLmRlZmF1bHQ7XHJcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBtb2R1bGUuZXhwb3J0cztcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/base64url/index.js\n");

/***/ }),

/***/ "./node_modules/bignumber.js/bignumber.js":
/*!************************************************!*\
  !*** ./node_modules/bignumber.js/bignumber.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;;(function (globalObject) {\r\n  'use strict';\r\n\r\n/*\r\n *      bignumber.js v9.0.2\r\n *      A JavaScript library for arbitrary-precision arithmetic.\r\n *      https://github.com/MikeMcl/bignumber.js\r\n *      Copyright (c) 2021 Michael Mclaughlin <M8ch88l@gmail.com>\r\n *      MIT Licensed.\r\n *\r\n *      BigNumber.prototype methods     |  BigNumber methods\r\n *                                      |\r\n *      absoluteValue            abs    |  clone\r\n *      comparedTo                      |  config               set\r\n *      decimalPlaces            dp     |      DECIMAL_PLACES\r\n *      dividedBy                div    |      ROUNDING_MODE\r\n *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT\r\n *      exponentiatedBy          pow    |      RANGE\r\n *      integerValue                    |      CRYPTO\r\n *      isEqualTo                eq     |      MODULO_MODE\r\n *      isFinite                        |      POW_PRECISION\r\n *      isGreaterThan            gt     |      FORMAT\r\n *      isGreaterThanOrEqualTo   gte    |      ALPHABET\r\n *      isInteger                       |  isBigNumber\r\n *      isLessThan               lt     |  maximum              max\r\n *      isLessThanOrEqualTo      lte    |  minimum              min\r\n *      isNaN                           |  random\r\n *      isNegative                      |  sum\r\n *      isPositive                      |\r\n *      isZero                          |\r\n *      minus                           |\r\n *      modulo                   mod    |\r\n *      multipliedBy             times  |\r\n *      negated                         |\r\n *      plus                            |\r\n *      precision                sd     |\r\n *      shiftedBy                       |\r\n *      squareRoot               sqrt   |\r\n *      toExponential                   |\r\n *      toFixed                         |\r\n *      toFormat                        |\r\n *      toFraction                      |\r\n *      toJSON                          |\r\n *      toNumber                        |\r\n *      toPrecision                     |\r\n *      toString                        |\r\n *      valueOf                         |\r\n *\r\n */\r\n\r\n\r\n  var BigNumber,\r\n    isNumeric = /^-?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?$/i,\r\n    mathceil = Math.ceil,\r\n    mathfloor = Math.floor,\r\n\r\n    bignumberError = '[BigNumber Error] ',\r\n    tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',\r\n\r\n    BASE = 1e14,\r\n    LOG_BASE = 14,\r\n    MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1\r\n    // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1\r\n    POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],\r\n    SQRT_BASE = 1e7,\r\n\r\n    // EDITABLE\r\n    // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and\r\n    // the arguments to toExponential, toFixed, toFormat, and toPrecision.\r\n    MAX = 1E9;                                   // 0 to MAX_INT32\r\n\r\n\r\n  /*\r\n   * Create and return a BigNumber constructor.\r\n   */\r\n  function clone(configObject) {\r\n    var div, convertBase, parseNumeric,\r\n      P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },\r\n      ONE = new BigNumber(1),\r\n\r\n\r\n      //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------\r\n\r\n\r\n      // The default values below must be integers within the inclusive ranges stated.\r\n      // The values can also be changed at run-time using BigNumber.set.\r\n\r\n      // The maximum number of decimal places for operations involving division.\r\n      DECIMAL_PLACES = 20,                     // 0 to MAX\r\n\r\n      // The rounding mode used when rounding to the above decimal places, and when using\r\n      // toExponential, toFixed, toFormat and toPrecision, and round (default value).\r\n      // UP         0 Away from zero.\r\n      // DOWN       1 Towards zero.\r\n      // CEIL       2 Towards +Infinity.\r\n      // FLOOR      3 Towards -Infinity.\r\n      // HALF_UP    4 Towards nearest neighbour. If equidistant, up.\r\n      // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.\r\n      // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.\r\n      // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.\r\n      // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.\r\n      ROUNDING_MODE = 4,                       // 0 to 8\r\n\r\n      // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]\r\n\r\n      // The exponent value at and beneath which toString returns exponential notation.\r\n      // Number type: -7\r\n      TO_EXP_NEG = -7,                         // 0 to -MAX\r\n\r\n      // The exponent value at and above which toString returns exponential notation.\r\n      // Number type: 21\r\n      TO_EXP_POS = 21,                         // 0 to MAX\r\n\r\n      // RANGE : [MIN_EXP, MAX_EXP]\r\n\r\n      // The minimum exponent value, beneath which underflow to zero occurs.\r\n      // Number type: -324  (5e-324)\r\n      MIN_EXP = -1e7,                          // -1 to -MAX\r\n\r\n      // The maximum exponent value, above which overflow to Infinity occurs.\r\n      // Number type:  308  (1.7976931348623157e+308)\r\n      // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.\r\n      MAX_EXP = 1e7,                           // 1 to MAX\r\n\r\n      // Whether to use cryptographically-secure random number generation, if available.\r\n      CRYPTO = false,                          // true or false\r\n\r\n      // The modulo mode used when calculating the modulus: a mod n.\r\n      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.\r\n      // The remainder (r) is calculated as: r = a - n * q.\r\n      //\r\n      // UP        0 The remainder is positive if the dividend is negative, else is negative.\r\n      // DOWN      1 The remainder has the same sign as the dividend.\r\n      //             This modulo mode is commonly known as 'truncated division' and is\r\n      //             equivalent to (a % n) in JavaScript.\r\n      // FLOOR     3 The remainder has the same sign as the divisor (Python %).\r\n      // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.\r\n      // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).\r\n      //             The remainder is always positive.\r\n      //\r\n      // The truncated division, floored division, Euclidian division and IEEE 754 remainder\r\n      // modes are commonly used for the modulus operation.\r\n      // Although the other rounding modes can also be used, they may not give useful results.\r\n      MODULO_MODE = 1,                         // 0 to 9\r\n\r\n      // The maximum number of significant digits of the result of the exponentiatedBy operation.\r\n      // If POW_PRECISION is 0, there will be unlimited significant digits.\r\n      POW_PRECISION = 0,                       // 0 to MAX\r\n\r\n      // The format specification used by the BigNumber.prototype.toFormat method.\r\n      FORMAT = {\r\n        prefix: '',\r\n        groupSize: 3,\r\n        secondaryGroupSize: 0,\r\n        groupSeparator: ',',\r\n        decimalSeparator: '.',\r\n        fractionGroupSize: 0,\r\n        fractionGroupSeparator: '\\xA0',        // non-breaking space\r\n        suffix: ''\r\n      },\r\n\r\n      // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',\r\n      // '-', '.', whitespace, or repeated character.\r\n      // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'\r\n      ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz',\r\n      alphabetHasNormalDecimalDigits = true;\r\n\r\n\r\n    //------------------------------------------------------------------------------------------\r\n\r\n\r\n    // CONSTRUCTOR\r\n\r\n\r\n    /*\r\n     * The BigNumber constructor and exported function.\r\n     * Create and return a new instance of a BigNumber object.\r\n     *\r\n     * v {number|string|BigNumber} A numeric value.\r\n     * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.\r\n     */\r\n    function BigNumber(v, b) {\r\n      var alphabet, c, caseChanged, e, i, isNum, len, str,\r\n        x = this;\r\n\r\n      // Enable constructor call without `new`.\r\n      if (!(x instanceof BigNumber)) return new BigNumber(v, b);\r\n\r\n      if (b == null) {\r\n\r\n        if (v && v._isBigNumber === true) {\r\n          x.s = v.s;\r\n\r\n          if (!v.c || v.e > MAX_EXP) {\r\n            x.c = x.e = null;\r\n          } else if (v.e < MIN_EXP) {\r\n            x.c = [x.e = 0];\r\n          } else {\r\n            x.e = v.e;\r\n            x.c = v.c.slice();\r\n          }\r\n\r\n          return;\r\n        }\r\n\r\n        if ((isNum = typeof v == 'number') && v * 0 == 0) {\r\n\r\n          // Use `1 / n` to handle minus zero also.\r\n          x.s = 1 / v < 0 ? (v = -v, -1) : 1;\r\n\r\n          // Fast path for integers, where n < 2147483648 (2**31).\r\n          if (v === ~~v) {\r\n            for (e = 0, i = v; i >= 10; i /= 10, e++);\r\n\r\n            if (e > MAX_EXP) {\r\n              x.c = x.e = null;\r\n            } else {\r\n              x.e = e;\r\n              x.c = [v];\r\n            }\r\n\r\n            return;\r\n          }\r\n\r\n          str = String(v);\r\n        } else {\r\n\r\n          if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);\r\n\r\n          x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;\r\n        }\r\n\r\n        // Decimal point?\r\n        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n\r\n        // Exponential form?\r\n        if ((i = str.search(/e/i)) > 0) {\r\n\r\n          // Determine exponent.\r\n          if (e < 0) e = i;\r\n          e += +str.slice(i + 1);\r\n          str = str.substring(0, i);\r\n        } else if (e < 0) {\r\n\r\n          // Integer.\r\n          e = str.length;\r\n        }\r\n\r\n      } else {\r\n\r\n        // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\r\n        intCheck(b, 2, ALPHABET.length, 'Base');\r\n\r\n        // Allow exponential notation to be used with base 10 argument, while\r\n        // also rounding to DECIMAL_PLACES as with other bases.\r\n        if (b == 10 && alphabetHasNormalDecimalDigits) {\r\n          x = new BigNumber(v);\r\n          return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);\r\n        }\r\n\r\n        str = String(v);\r\n\r\n        if (isNum = typeof v == 'number') {\r\n\r\n          // Avoid potential interpretation of Infinity and NaN as base 44+ values.\r\n          if (v * 0 != 0) return parseNumeric(x, str, isNum, b);\r\n\r\n          x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;\r\n\r\n          // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\r\n          if (BigNumber.DEBUG && str.replace(/^0\\.0*|\\./, '').length > 15) {\r\n            throw Error\r\n             (tooManyDigits + v);\r\n          }\r\n        } else {\r\n          x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;\r\n        }\r\n\r\n        alphabet = ALPHABET.slice(0, b);\r\n        e = i = 0;\r\n\r\n        // Check that str is a valid base b number.\r\n        // Don't use RegExp, so alphabet can contain special characters.\r\n        for (len = str.length; i < len; i++) {\r\n          if (alphabet.indexOf(c = str.charAt(i)) < 0) {\r\n            if (c == '.') {\r\n\r\n              // If '.' is not the first character and it has not be found before.\r\n              if (i > e) {\r\n                e = len;\r\n                continue;\r\n              }\r\n            } else if (!caseChanged) {\r\n\r\n              // Allow e.g. hexadecimal 'FF' as well as 'ff'.\r\n              if (str == str.toUpperCase() && (str = str.toLowerCase()) ||\r\n                  str == str.toLowerCase() && (str = str.toUpperCase())) {\r\n                caseChanged = true;\r\n                i = -1;\r\n                e = 0;\r\n                continue;\r\n              }\r\n            }\r\n\r\n            return parseNumeric(x, String(v), isNum, b);\r\n          }\r\n        }\r\n\r\n        // Prevent later check for length on converted number.\r\n        isNum = false;\r\n        str = convertBase(str, b, 10, x.s);\r\n\r\n        // Decimal point?\r\n        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n        else e = str.length;\r\n      }\r\n\r\n      // Determine leading zeros.\r\n      for (i = 0; str.charCodeAt(i) === 48; i++);\r\n\r\n      // Determine trailing zeros.\r\n      for (len = str.length; str.charCodeAt(--len) === 48;);\r\n\r\n      if (str = str.slice(i, ++len)) {\r\n        len -= i;\r\n\r\n        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\r\n        if (isNum && BigNumber.DEBUG &&\r\n          len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {\r\n            throw Error\r\n             (tooManyDigits + (x.s * v));\r\n        }\r\n\r\n         // Overflow?\r\n        if ((e = e - i - 1) > MAX_EXP) {\r\n\r\n          // Infinity.\r\n          x.c = x.e = null;\r\n\r\n        // Underflow?\r\n        } else if (e < MIN_EXP) {\r\n\r\n          // Zero.\r\n          x.c = [x.e = 0];\r\n        } else {\r\n          x.e = e;\r\n          x.c = [];\r\n\r\n          // Transform base\r\n\r\n          // e is the base 10 exponent.\r\n          // i is where to slice str to get the first element of the coefficient array.\r\n          i = (e + 1) % LOG_BASE;\r\n          if (e < 0) i += LOG_BASE;  // i < 1\r\n\r\n          if (i < len) {\r\n            if (i) x.c.push(+str.slice(0, i));\r\n\r\n            for (len -= LOG_BASE; i < len;) {\r\n              x.c.push(+str.slice(i, i += LOG_BASE));\r\n            }\r\n\r\n            i = LOG_BASE - (str = str.slice(i)).length;\r\n          } else {\r\n            i -= len;\r\n          }\r\n\r\n          for (; i--; str += '0');\r\n          x.c.push(+str);\r\n        }\r\n      } else {\r\n\r\n        // Zero.\r\n        x.c = [x.e = 0];\r\n      }\r\n    }\r\n\r\n\r\n    // CONSTRUCTOR PROPERTIES\r\n\r\n\r\n    BigNumber.clone = clone;\r\n\r\n    BigNumber.ROUND_UP = 0;\r\n    BigNumber.ROUND_DOWN = 1;\r\n    BigNumber.ROUND_CEIL = 2;\r\n    BigNumber.ROUND_FLOOR = 3;\r\n    BigNumber.ROUND_HALF_UP = 4;\r\n    BigNumber.ROUND_HALF_DOWN = 5;\r\n    BigNumber.ROUND_HALF_EVEN = 6;\r\n    BigNumber.ROUND_HALF_CEIL = 7;\r\n    BigNumber.ROUND_HALF_FLOOR = 8;\r\n    BigNumber.EUCLID = 9;\r\n\r\n\r\n    /*\r\n     * Configure infrequently-changing library-wide settings.\r\n     *\r\n     * Accept an object with the following optional properties (if the value of a property is\r\n     * a number, it must be an integer within the inclusive range stated):\r\n     *\r\n     *   DECIMAL_PLACES   {number}           0 to MAX\r\n     *   ROUNDING_MODE    {number}           0 to 8\r\n     *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]\r\n     *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]\r\n     *   CRYPTO           {boolean}          true or false\r\n     *   MODULO_MODE      {number}           0 to 9\r\n     *   POW_PRECISION       {number}           0 to MAX\r\n     *   ALPHABET         {string}           A string of two or more unique characters which does\r\n     *                                       not contain '.'.\r\n     *   FORMAT           {object}           An object with some of the following properties:\r\n     *     prefix                 {string}\r\n     *     groupSize              {number}\r\n     *     secondaryGroupSize     {number}\r\n     *     groupSeparator         {string}\r\n     *     decimalSeparator       {string}\r\n     *     fractionGroupSize      {number}\r\n     *     fractionGroupSeparator {string}\r\n     *     suffix                 {string}\r\n     *\r\n     * (The values assigned to the above FORMAT object properties are not checked for validity.)\r\n     *\r\n     * E.g.\r\n     * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })\r\n     *\r\n     * Ignore properties/parameters set to null or undefined, except for ALPHABET.\r\n     *\r\n     * Return an object with the properties current values.\r\n     */\r\n    BigNumber.config = BigNumber.set = function (obj) {\r\n      var p, v;\r\n\r\n      if (obj != null) {\r\n\r\n        if (typeof obj == 'object') {\r\n\r\n          // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.\r\n          // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {\r\n            v = obj[p];\r\n            intCheck(v, 0, MAX, p);\r\n            DECIMAL_PLACES = v;\r\n          }\r\n\r\n          // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.\r\n          // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {\r\n            v = obj[p];\r\n            intCheck(v, 0, 8, p);\r\n            ROUNDING_MODE = v;\r\n          }\r\n\r\n          // EXPONENTIAL_AT {number|number[]}\r\n          // Integer, -MAX to MAX inclusive or\r\n          // [integer -MAX to 0 inclusive, 0 to MAX inclusive].\r\n          // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {\r\n            v = obj[p];\r\n            if (v && v.pop) {\r\n              intCheck(v[0], -MAX, 0, p);\r\n              intCheck(v[1], 0, MAX, p);\r\n              TO_EXP_NEG = v[0];\r\n              TO_EXP_POS = v[1];\r\n            } else {\r\n              intCheck(v, -MAX, MAX, p);\r\n              TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);\r\n            }\r\n          }\r\n\r\n          // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or\r\n          // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].\r\n          // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'\r\n          if (obj.hasOwnProperty(p = 'RANGE')) {\r\n            v = obj[p];\r\n            if (v && v.pop) {\r\n              intCheck(v[0], -MAX, -1, p);\r\n              intCheck(v[1], 1, MAX, p);\r\n              MIN_EXP = v[0];\r\n              MAX_EXP = v[1];\r\n            } else {\r\n              intCheck(v, -MAX, MAX, p);\r\n              if (v) {\r\n                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);\r\n              } else {\r\n                throw Error\r\n                 (bignumberError + p + ' cannot be zero: ' + v);\r\n              }\r\n            }\r\n          }\r\n\r\n          // CRYPTO {boolean} true or false.\r\n          // '[BigNumber Error] CRYPTO not true or false: {v}'\r\n          // '[BigNumber Error] crypto unavailable'\r\n          if (obj.hasOwnProperty(p = 'CRYPTO')) {\r\n            v = obj[p];\r\n            if (v === !!v) {\r\n              if (v) {\r\n                if (typeof crypto != 'undefined' && crypto &&\r\n                 (crypto.getRandomValues || crypto.randomBytes)) {\r\n                  CRYPTO = v;\r\n                } else {\r\n                  CRYPTO = !v;\r\n                  throw Error\r\n                   (bignumberError + 'crypto unavailable');\r\n                }\r\n              } else {\r\n                CRYPTO = v;\r\n              }\r\n            } else {\r\n              throw Error\r\n               (bignumberError + p + ' not true or false: ' + v);\r\n            }\r\n          }\r\n\r\n          // MODULO_MODE {number} Integer, 0 to 9 inclusive.\r\n          // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'MODULO_MODE')) {\r\n            v = obj[p];\r\n            intCheck(v, 0, 9, p);\r\n            MODULO_MODE = v;\r\n          }\r\n\r\n          // POW_PRECISION {number} Integer, 0 to MAX inclusive.\r\n          // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'POW_PRECISION')) {\r\n            v = obj[p];\r\n            intCheck(v, 0, MAX, p);\r\n            POW_PRECISION = v;\r\n          }\r\n\r\n          // FORMAT {object}\r\n          // '[BigNumber Error] FORMAT not an object: {v}'\r\n          if (obj.hasOwnProperty(p = 'FORMAT')) {\r\n            v = obj[p];\r\n            if (typeof v == 'object') FORMAT = v;\r\n            else throw Error\r\n             (bignumberError + p + ' not an object: ' + v);\r\n          }\r\n\r\n          // ALPHABET {string}\r\n          // '[BigNumber Error] ALPHABET invalid: {v}'\r\n          if (obj.hasOwnProperty(p = 'ALPHABET')) {\r\n            v = obj[p];\r\n\r\n            // Disallow if less than two characters,\r\n            // or if it contains '+', '-', '.', whitespace, or a repeated character.\r\n            if (typeof v == 'string' && !/^.?$|[+\\-.\\s]|(.).*\\1/.test(v)) {\r\n              alphabetHasNormalDecimalDigits = v.slice(0, 10) == '0123456789';\r\n              ALPHABET = v;\r\n            } else {\r\n              throw Error\r\n               (bignumberError + p + ' invalid: ' + v);\r\n            }\r\n          }\r\n\r\n        } else {\r\n\r\n          // '[BigNumber Error] Object expected: {v}'\r\n          throw Error\r\n           (bignumberError + 'Object expected: ' + obj);\r\n        }\r\n      }\r\n\r\n      return {\r\n        DECIMAL_PLACES: DECIMAL_PLACES,\r\n        ROUNDING_MODE: ROUNDING_MODE,\r\n        EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],\r\n        RANGE: [MIN_EXP, MAX_EXP],\r\n        CRYPTO: CRYPTO,\r\n        MODULO_MODE: MODULO_MODE,\r\n        POW_PRECISION: POW_PRECISION,\r\n        FORMAT: FORMAT,\r\n        ALPHABET: ALPHABET\r\n      };\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if v is a BigNumber instance, otherwise return false.\r\n     *\r\n     * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.\r\n     *\r\n     * v {any}\r\n     *\r\n     * '[BigNumber Error] Invalid BigNumber: {v}'\r\n     */\r\n    BigNumber.isBigNumber = function (v) {\r\n      if (!v || v._isBigNumber !== true) return false;\r\n      if (!BigNumber.DEBUG) return true;\r\n\r\n      var i, n,\r\n        c = v.c,\r\n        e = v.e,\r\n        s = v.s;\r\n\r\n      out: if ({}.toString.call(c) == '[object Array]') {\r\n\r\n        if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {\r\n\r\n          // If the first element is zero, the BigNumber value must be zero.\r\n          if (c[0] === 0) {\r\n            if (e === 0 && c.length === 1) return true;\r\n            break out;\r\n          }\r\n\r\n          // Calculate number of digits that c[0] should have, based on the exponent.\r\n          i = (e + 1) % LOG_BASE;\r\n          if (i < 1) i += LOG_BASE;\r\n\r\n          // Calculate number of digits of c[0].\r\n          //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {\r\n          if (String(c[0]).length == i) {\r\n\r\n            for (i = 0; i < c.length; i++) {\r\n              n = c[i];\r\n              if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;\r\n            }\r\n\r\n            // Last element cannot be zero, unless it is the only element.\r\n            if (n !== 0) return true;\r\n          }\r\n        }\r\n\r\n      // Infinity/NaN\r\n      } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {\r\n        return true;\r\n      }\r\n\r\n      throw Error\r\n        (bignumberError + 'Invalid BigNumber: ' + v);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the maximum of the arguments.\r\n     *\r\n     * arguments {number|string|BigNumber}\r\n     */\r\n    BigNumber.maximum = BigNumber.max = function () {\r\n      return maxOrMin(arguments, P.lt);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the minimum of the arguments.\r\n     *\r\n     * arguments {number|string|BigNumber}\r\n     */\r\n    BigNumber.minimum = BigNumber.min = function () {\r\n      return maxOrMin(arguments, P.gt);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,\r\n     * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing\r\n     * zeros are produced).\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'\r\n     * '[BigNumber Error] crypto unavailable'\r\n     */\r\n    BigNumber.random = (function () {\r\n      var pow2_53 = 0x20000000000000;\r\n\r\n      // Return a 53 bit integer n, where 0 <= n < 9007199254740992.\r\n      // Check if Math.random() produces more than 32 bits of randomness.\r\n      // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.\r\n      // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.\r\n      var random53bitInt = (Math.random() * pow2_53) & 0x1fffff\r\n       ? function () { return mathfloor(Math.random() * pow2_53); }\r\n       : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +\r\n         (Math.random() * 0x800000 | 0); };\r\n\r\n      return function (dp) {\r\n        var a, b, e, k, v,\r\n          i = 0,\r\n          c = [],\r\n          rand = new BigNumber(ONE);\r\n\r\n        if (dp == null) dp = DECIMAL_PLACES;\r\n        else intCheck(dp, 0, MAX);\r\n\r\n        k = mathceil(dp / LOG_BASE);\r\n\r\n        if (CRYPTO) {\r\n\r\n          // Browsers supporting crypto.getRandomValues.\r\n          if (crypto.getRandomValues) {\r\n\r\n            a = crypto.getRandomValues(new Uint32Array(k *= 2));\r\n\r\n            for (; i < k;) {\r\n\r\n              // 53 bits:\r\n              // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)\r\n              // 11111 11111111 11111111 11111111 11100000 00000000 00000000\r\n              // ((Math.pow(2, 32) - 1) >>> 11).toString(2)\r\n              //                                     11111 11111111 11111111\r\n              // 0x20000 is 2^21.\r\n              v = a[i] * 0x20000 + (a[i + 1] >>> 11);\r\n\r\n              // Rejection sampling:\r\n              // 0 <= v < 9007199254740992\r\n              // Probability that v >= 9e15, is\r\n              // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251\r\n              if (v >= 9e15) {\r\n                b = crypto.getRandomValues(new Uint32Array(2));\r\n                a[i] = b[0];\r\n                a[i + 1] = b[1];\r\n              } else {\r\n\r\n                // 0 <= v <= 8999999999999999\r\n                // 0 <= (v % 1e14) <= 99999999999999\r\n                c.push(v % 1e14);\r\n                i += 2;\r\n              }\r\n            }\r\n            i = k / 2;\r\n\r\n          // Node.js supporting crypto.randomBytes.\r\n          } else if (crypto.randomBytes) {\r\n\r\n            // buffer\r\n            a = crypto.randomBytes(k *= 7);\r\n\r\n            for (; i < k;) {\r\n\r\n              // 0x1000000000000 is 2^48, 0x10000000000 is 2^40\r\n              // 0x100000000 is 2^32, 0x1000000 is 2^24\r\n              // 11111 11111111 11111111 11111111 11111111 11111111 11111111\r\n              // 0 <= v < 9007199254740992\r\n              v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +\r\n                 (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +\r\n                 (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];\r\n\r\n              if (v >= 9e15) {\r\n                crypto.randomBytes(7).copy(a, i);\r\n              } else {\r\n\r\n                // 0 <= (v % 1e14) <= 99999999999999\r\n                c.push(v % 1e14);\r\n                i += 7;\r\n              }\r\n            }\r\n            i = k / 7;\r\n          } else {\r\n            CRYPTO = false;\r\n            throw Error\r\n             (bignumberError + 'crypto unavailable');\r\n          }\r\n        }\r\n\r\n        // Use Math.random.\r\n        if (!CRYPTO) {\r\n\r\n          for (; i < k;) {\r\n            v = random53bitInt();\r\n            if (v < 9e15) c[i++] = v % 1e14;\r\n          }\r\n        }\r\n\r\n        k = c[--i];\r\n        dp %= LOG_BASE;\r\n\r\n        // Convert trailing digits to zeros according to dp.\r\n        if (k && dp) {\r\n          v = POWS_TEN[LOG_BASE - dp];\r\n          c[i] = mathfloor(k / v) * v;\r\n        }\r\n\r\n        // Remove trailing elements which are zero.\r\n        for (; c[i] === 0; c.pop(), i--);\r\n\r\n        // Zero?\r\n        if (i < 0) {\r\n          c = [e = 0];\r\n        } else {\r\n\r\n          // Remove leading elements which are zero and adjust exponent accordingly.\r\n          for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);\r\n\r\n          // Count the digits of the first element of c to determine leading zeros, and...\r\n          for (i = 1, v = c[0]; v >= 10; v /= 10, i++);\r\n\r\n          // adjust the exponent accordingly.\r\n          if (i < LOG_BASE) e -= LOG_BASE - i;\r\n        }\r\n\r\n        rand.e = e;\r\n        rand.c = c;\r\n        return rand;\r\n      };\r\n    })();\r\n\r\n\r\n    /*\r\n     * Return a BigNumber whose value is the sum of the arguments.\r\n     *\r\n     * arguments {number|string|BigNumber}\r\n     */\r\n    BigNumber.sum = function () {\r\n      var i = 1,\r\n        args = arguments,\r\n        sum = new BigNumber(args[0]);\r\n      for (; i < args.length;) sum = sum.plus(args[i++]);\r\n      return sum;\r\n    };\r\n\r\n\r\n    // PRIVATE FUNCTIONS\r\n\r\n\r\n    // Called by BigNumber and BigNumber.prototype.toString.\r\n    convertBase = (function () {\r\n      var decimal = '0123456789';\r\n\r\n      /*\r\n       * Convert string of baseIn to an array of numbers of baseOut.\r\n       * Eg. toBaseOut('255', 10, 16) returns [15, 15].\r\n       * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].\r\n       */\r\n      function toBaseOut(str, baseIn, baseOut, alphabet) {\r\n        var j,\r\n          arr = [0],\r\n          arrL,\r\n          i = 0,\r\n          len = str.length;\r\n\r\n        for (; i < len;) {\r\n          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);\r\n\r\n          arr[0] += alphabet.indexOf(str.charAt(i++));\r\n\r\n          for (j = 0; j < arr.length; j++) {\r\n\r\n            if (arr[j] > baseOut - 1) {\r\n              if (arr[j + 1] == null) arr[j + 1] = 0;\r\n              arr[j + 1] += arr[j] / baseOut | 0;\r\n              arr[j] %= baseOut;\r\n            }\r\n          }\r\n        }\r\n\r\n        return arr.reverse();\r\n      }\r\n\r\n      // Convert a numeric string of baseIn to a numeric string of baseOut.\r\n      // If the caller is toString, we are converting from base 10 to baseOut.\r\n      // If the caller is BigNumber, we are converting from baseIn to base 10.\r\n      return function (str, baseIn, baseOut, sign, callerIsToString) {\r\n        var alphabet, d, e, k, r, x, xc, y,\r\n          i = str.indexOf('.'),\r\n          dp = DECIMAL_PLACES,\r\n          rm = ROUNDING_MODE;\r\n\r\n        // Non-integer.\r\n        if (i >= 0) {\r\n          k = POW_PRECISION;\r\n\r\n          // Unlimited precision.\r\n          POW_PRECISION = 0;\r\n          str = str.replace('.', '');\r\n          y = new BigNumber(baseIn);\r\n          x = y.pow(str.length - i);\r\n          POW_PRECISION = k;\r\n\r\n          // Convert str as if an integer, then restore the fraction part by dividing the\r\n          // result by its base raised to a power.\r\n\r\n          y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),\r\n           10, baseOut, decimal);\r\n          y.e = y.c.length;\r\n        }\r\n\r\n        // Convert the number as integer.\r\n\r\n        xc = toBaseOut(str, baseIn, baseOut, callerIsToString\r\n         ? (alphabet = ALPHABET, decimal)\r\n         : (alphabet = decimal, ALPHABET));\r\n\r\n        // xc now represents str as an integer and converted to baseOut. e is the exponent.\r\n        e = k = xc.length;\r\n\r\n        // Remove trailing zeros.\r\n        for (; xc[--k] == 0; xc.pop());\r\n\r\n        // Zero?\r\n        if (!xc[0]) return alphabet.charAt(0);\r\n\r\n        // Does str represent an integer? If so, no need for the division.\r\n        if (i < 0) {\r\n          --e;\r\n        } else {\r\n          x.c = xc;\r\n          x.e = e;\r\n\r\n          // The sign is needed for correct rounding.\r\n          x.s = sign;\r\n          x = div(x, y, dp, rm, baseOut);\r\n          xc = x.c;\r\n          r = x.r;\r\n          e = x.e;\r\n        }\r\n\r\n        // xc now represents str converted to baseOut.\r\n\r\n        // THe index of the rounding digit.\r\n        d = e + dp + 1;\r\n\r\n        // The rounding digit: the digit to the right of the digit that may be rounded up.\r\n        i = xc[d];\r\n\r\n        // Look at the rounding digits and mode to determine whether to round up.\r\n\r\n        k = baseOut / 2;\r\n        r = r || d < 0 || xc[d + 1] != null;\r\n\r\n        r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n              : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||\r\n               rm == (x.s < 0 ? 8 : 7));\r\n\r\n        // If the index of the rounding digit is not greater than zero, or xc represents\r\n        // zero, then the result of the base conversion is zero or, if rounding up, a value\r\n        // such as 0.00001.\r\n        if (d < 1 || !xc[0]) {\r\n\r\n          // 1^-dp or 0\r\n          str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);\r\n        } else {\r\n\r\n          // Truncate xc to the required number of decimal places.\r\n          xc.length = d;\r\n\r\n          // Round up?\r\n          if (r) {\r\n\r\n            // Rounding up may mean the previous digit has to be rounded up and so on.\r\n            for (--baseOut; ++xc[--d] > baseOut;) {\r\n              xc[d] = 0;\r\n\r\n              if (!d) {\r\n                ++e;\r\n                xc = [1].concat(xc);\r\n              }\r\n            }\r\n          }\r\n\r\n          // Determine trailing zeros.\r\n          for (k = xc.length; !xc[--k];);\r\n\r\n          // E.g. [4, 11, 15] becomes 4bf.\r\n          for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));\r\n\r\n          // Add leading zeros, decimal point and trailing zeros as required.\r\n          str = toFixedPoint(str, e, alphabet.charAt(0));\r\n        }\r\n\r\n        // The caller will add the sign.\r\n        return str;\r\n      };\r\n    })();\r\n\r\n\r\n    // Perform division in the specified base. Called by div and convertBase.\r\n    div = (function () {\r\n\r\n      // Assume non-zero x and k.\r\n      function multiply(x, k, base) {\r\n        var m, temp, xlo, xhi,\r\n          carry = 0,\r\n          i = x.length,\r\n          klo = k % SQRT_BASE,\r\n          khi = k / SQRT_BASE | 0;\r\n\r\n        for (x = x.slice(); i--;) {\r\n          xlo = x[i] % SQRT_BASE;\r\n          xhi = x[i] / SQRT_BASE | 0;\r\n          m = khi * xlo + xhi * klo;\r\n          temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;\r\n          carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;\r\n          x[i] = temp % base;\r\n        }\r\n\r\n        if (carry) x = [carry].concat(x);\r\n\r\n        return x;\r\n      }\r\n\r\n      function compare(a, b, aL, bL) {\r\n        var i, cmp;\r\n\r\n        if (aL != bL) {\r\n          cmp = aL > bL ? 1 : -1;\r\n        } else {\r\n\r\n          for (i = cmp = 0; i < aL; i++) {\r\n\r\n            if (a[i] != b[i]) {\r\n              cmp = a[i] > b[i] ? 1 : -1;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n\r\n        return cmp;\r\n      }\r\n\r\n      function subtract(a, b, aL, base) {\r\n        var i = 0;\r\n\r\n        // Subtract b from a.\r\n        for (; aL--;) {\r\n          a[aL] -= i;\r\n          i = a[aL] < b[aL] ? 1 : 0;\r\n          a[aL] = i * base + a[aL] - b[aL];\r\n        }\r\n\r\n        // Remove leading zeros.\r\n        for (; !a[0] && a.length > 1; a.splice(0, 1));\r\n      }\r\n\r\n      // x: dividend, y: divisor.\r\n      return function (x, y, dp, rm, base) {\r\n        var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,\r\n          yL, yz,\r\n          s = x.s == y.s ? 1 : -1,\r\n          xc = x.c,\r\n          yc = y.c;\r\n\r\n        // Either NaN, Infinity or 0?\r\n        if (!xc || !xc[0] || !yc || !yc[0]) {\r\n\r\n          return new BigNumber(\r\n\r\n           // Return NaN if either NaN, or both Infinity or 0.\r\n           !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :\r\n\r\n            // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.\r\n            xc && xc[0] == 0 || !yc ? s * 0 : s / 0\r\n         );\r\n        }\r\n\r\n        q = new BigNumber(s);\r\n        qc = q.c = [];\r\n        e = x.e - y.e;\r\n        s = dp + e + 1;\r\n\r\n        if (!base) {\r\n          base = BASE;\r\n          e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);\r\n          s = s / LOG_BASE | 0;\r\n        }\r\n\r\n        // Result exponent may be one less then the current value of e.\r\n        // The coefficients of the BigNumbers from convertBase may have trailing zeros.\r\n        for (i = 0; yc[i] == (xc[i] || 0); i++);\r\n\r\n        if (yc[i] > (xc[i] || 0)) e--;\r\n\r\n        if (s < 0) {\r\n          qc.push(1);\r\n          more = true;\r\n        } else {\r\n          xL = xc.length;\r\n          yL = yc.length;\r\n          i = 0;\r\n          s += 2;\r\n\r\n          // Normalise xc and yc so highest order digit of yc is >= base / 2.\r\n\r\n          n = mathfloor(base / (yc[0] + 1));\r\n\r\n          // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.\r\n          // if (n > 1 || n++ == 1 && yc[0] < base / 2) {\r\n          if (n > 1) {\r\n            yc = multiply(yc, n, base);\r\n            xc = multiply(xc, n, base);\r\n            yL = yc.length;\r\n            xL = xc.length;\r\n          }\r\n\r\n          xi = yL;\r\n          rem = xc.slice(0, yL);\r\n          remL = rem.length;\r\n\r\n          // Add zeros to make remainder as long as divisor.\r\n          for (; remL < yL; rem[remL++] = 0);\r\n          yz = yc.slice();\r\n          yz = [0].concat(yz);\r\n          yc0 = yc[0];\r\n          if (yc[1] >= base / 2) yc0++;\r\n          // Not necessary, but to prevent trial digit n > base, when using base 3.\r\n          // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;\r\n\r\n          do {\r\n            n = 0;\r\n\r\n            // Compare divisor and remainder.\r\n            cmp = compare(yc, rem, yL, remL);\r\n\r\n            // If divisor < remainder.\r\n            if (cmp < 0) {\r\n\r\n              // Calculate trial digit, n.\r\n\r\n              rem0 = rem[0];\r\n              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);\r\n\r\n              // n is how many times the divisor goes into the current remainder.\r\n              n = mathfloor(rem0 / yc0);\r\n\r\n              //  Algorithm:\r\n              //  product = divisor multiplied by trial digit (n).\r\n              //  Compare product and remainder.\r\n              //  If product is greater than remainder:\r\n              //    Subtract divisor from product, decrement trial digit.\r\n              //  Subtract product from remainder.\r\n              //  If product was less than remainder at the last compare:\r\n              //    Compare new remainder and divisor.\r\n              //    If remainder is greater than divisor:\r\n              //      Subtract divisor from remainder, increment trial digit.\r\n\r\n              if (n > 1) {\r\n\r\n                // n may be > base only when base is 3.\r\n                if (n >= base) n = base - 1;\r\n\r\n                // product = divisor * trial digit.\r\n                prod = multiply(yc, n, base);\r\n                prodL = prod.length;\r\n                remL = rem.length;\r\n\r\n                // Compare product and remainder.\r\n                // If product > remainder then trial digit n too high.\r\n                // n is 1 too high about 5% of the time, and is not known to have\r\n                // ever been more than 1 too high.\r\n                while (compare(prod, rem, prodL, remL) == 1) {\r\n                  n--;\r\n\r\n                  // Subtract divisor from product.\r\n                  subtract(prod, yL < prodL ? yz : yc, prodL, base);\r\n                  prodL = prod.length;\r\n                  cmp = 1;\r\n                }\r\n              } else {\r\n\r\n                // n is 0 or 1, cmp is -1.\r\n                // If n is 0, there is no need to compare yc and rem again below,\r\n                // so change cmp to 1 to avoid it.\r\n                // If n is 1, leave cmp as -1, so yc and rem are compared again.\r\n                if (n == 0) {\r\n\r\n                  // divisor < remainder, so n must be at least 1.\r\n                  cmp = n = 1;\r\n                }\r\n\r\n                // product = divisor\r\n                prod = yc.slice();\r\n                prodL = prod.length;\r\n              }\r\n\r\n              if (prodL < remL) prod = [0].concat(prod);\r\n\r\n              // Subtract product from remainder.\r\n              subtract(rem, prod, remL, base);\r\n              remL = rem.length;\r\n\r\n               // If product was < remainder.\r\n              if (cmp == -1) {\r\n\r\n                // Compare divisor and new remainder.\r\n                // If divisor < new remainder, subtract divisor from remainder.\r\n                // Trial digit n too low.\r\n                // n is 1 too low about 5% of the time, and very rarely 2 too low.\r\n                while (compare(yc, rem, yL, remL) < 1) {\r\n                  n++;\r\n\r\n                  // Subtract divisor from remainder.\r\n                  subtract(rem, yL < remL ? yz : yc, remL, base);\r\n                  remL = rem.length;\r\n                }\r\n              }\r\n            } else if (cmp === 0) {\r\n              n++;\r\n              rem = [0];\r\n            } // else cmp === 1 and n will be 0\r\n\r\n            // Add the next digit, n, to the result array.\r\n            qc[i++] = n;\r\n\r\n            // Update the remainder.\r\n            if (rem[0]) {\r\n              rem[remL++] = xc[xi] || 0;\r\n            } else {\r\n              rem = [xc[xi]];\r\n              remL = 1;\r\n            }\r\n          } while ((xi++ < xL || rem[0] != null) && s--);\r\n\r\n          more = rem[0] != null;\r\n\r\n          // Leading zero?\r\n          if (!qc[0]) qc.splice(0, 1);\r\n        }\r\n\r\n        if (base == BASE) {\r\n\r\n          // To calculate q.e, first get the number of digits of qc[0].\r\n          for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);\r\n\r\n          round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);\r\n\r\n        // Caller is convertBase.\r\n        } else {\r\n          q.e = e;\r\n          q.r = +more;\r\n        }\r\n\r\n        return q;\r\n      };\r\n    })();\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of BigNumber n in fixed-point or exponential\r\n     * notation rounded to the specified decimal places or significant digits.\r\n     *\r\n     * n: a BigNumber.\r\n     * i: the index of the last digit required (i.e. the digit that may be rounded up).\r\n     * rm: the rounding mode.\r\n     * id: 1 (toExponential) or 2 (toPrecision).\r\n     */\r\n    function format(n, i, rm, id) {\r\n      var c0, e, ne, len, str;\r\n\r\n      if (rm == null) rm = ROUNDING_MODE;\r\n      else intCheck(rm, 0, 8);\r\n\r\n      if (!n.c) return n.toString();\r\n\r\n      c0 = n.c[0];\r\n      ne = n.e;\r\n\r\n      if (i == null) {\r\n        str = coeffToString(n.c);\r\n        str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)\r\n         ? toExponential(str, ne)\r\n         : toFixedPoint(str, ne, '0');\r\n      } else {\r\n        n = round(new BigNumber(n), i, rm);\r\n\r\n        // n.e may have changed if the value was rounded up.\r\n        e = n.e;\r\n\r\n        str = coeffToString(n.c);\r\n        len = str.length;\r\n\r\n        // toPrecision returns exponential notation if the number of significant digits\r\n        // specified is less than the number of digits necessary to represent the integer\r\n        // part of the value in fixed-point notation.\r\n\r\n        // Exponential notation.\r\n        if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {\r\n\r\n          // Append zeros?\r\n          for (; len < i; str += '0', len++);\r\n          str = toExponential(str, e);\r\n\r\n        // Fixed-point notation.\r\n        } else {\r\n          i -= ne;\r\n          str = toFixedPoint(str, e, '0');\r\n\r\n          // Append zeros?\r\n          if (e + 1 > len) {\r\n            if (--i > 0) for (str += '.'; i--; str += '0');\r\n          } else {\r\n            i += e - len;\r\n            if (i > 0) {\r\n              if (e + 1 == len) str += '.';\r\n              for (; i--; str += '0');\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return n.s < 0 && c0 ? '-' + str : str;\r\n    }\r\n\r\n\r\n    // Handle BigNumber.max and BigNumber.min.\r\n    function maxOrMin(args, method) {\r\n      var n,\r\n        i = 1,\r\n        m = new BigNumber(args[0]);\r\n\r\n      for (; i < args.length; i++) {\r\n        n = new BigNumber(args[i]);\r\n\r\n        // If any number is NaN, return NaN.\r\n        if (!n.s) {\r\n          m = n;\r\n          break;\r\n        } else if (method.call(m, n)) {\r\n          m = n;\r\n        }\r\n      }\r\n\r\n      return m;\r\n    }\r\n\r\n\r\n    /*\r\n     * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.\r\n     * Called by minus, plus and times.\r\n     */\r\n    function normalise(n, c, e) {\r\n      var i = 1,\r\n        j = c.length;\r\n\r\n       // Remove trailing zeros.\r\n      for (; !c[--j]; c.pop());\r\n\r\n      // Calculate the base 10 exponent. First get the number of digits of c[0].\r\n      for (j = c[0]; j >= 10; j /= 10, i++);\r\n\r\n      // Overflow?\r\n      if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {\r\n\r\n        // Infinity.\r\n        n.c = n.e = null;\r\n\r\n      // Underflow?\r\n      } else if (e < MIN_EXP) {\r\n\r\n        // Zero.\r\n        n.c = [n.e = 0];\r\n      } else {\r\n        n.e = e;\r\n        n.c = c;\r\n      }\r\n\r\n      return n;\r\n    }\r\n\r\n\r\n    // Handle values that fail the validity test in BigNumber.\r\n    parseNumeric = (function () {\r\n      var basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i,\r\n        dotAfter = /^([^.]+)\\.$/,\r\n        dotBefore = /^\\.([^.]+)$/,\r\n        isInfinityOrNaN = /^-?(Infinity|NaN)$/,\r\n        whitespaceOrPlus = /^\\s*\\+(?=[\\w.])|^\\s+|\\s+$/g;\r\n\r\n      return function (x, str, isNum, b) {\r\n        var base,\r\n          s = isNum ? str : str.replace(whitespaceOrPlus, '');\r\n\r\n        // No exception on ±Infinity or NaN.\r\n        if (isInfinityOrNaN.test(s)) {\r\n          x.s = isNaN(s) ? null : s < 0 ? -1 : 1;\r\n        } else {\r\n          if (!isNum) {\r\n\r\n            // basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i\r\n            s = s.replace(basePrefix, function (m, p1, p2) {\r\n              base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;\r\n              return !b || b == base ? p1 : m;\r\n            });\r\n\r\n            if (b) {\r\n              base = b;\r\n\r\n              // E.g. '1.' to '1', '.1' to '0.1'\r\n              s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');\r\n            }\r\n\r\n            if (str != s) return new BigNumber(s, base);\r\n          }\r\n\r\n          // '[BigNumber Error] Not a number: {n}'\r\n          // '[BigNumber Error] Not a base {b} number: {n}'\r\n          if (BigNumber.DEBUG) {\r\n            throw Error\r\n              (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);\r\n          }\r\n\r\n          // NaN\r\n          x.s = null;\r\n        }\r\n\r\n        x.c = x.e = null;\r\n      }\r\n    })();\r\n\r\n\r\n    /*\r\n     * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.\r\n     * If r is truthy, it is known that there are more digits after the rounding digit.\r\n     */\r\n    function round(x, sd, rm, r) {\r\n      var d, i, j, k, n, ni, rd,\r\n        xc = x.c,\r\n        pows10 = POWS_TEN;\r\n\r\n      // if x is not Infinity or NaN...\r\n      if (xc) {\r\n\r\n        // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.\r\n        // n is a base 1e14 number, the value of the element of array x.c containing rd.\r\n        // ni is the index of n within x.c.\r\n        // d is the number of digits of n.\r\n        // i is the index of rd within n including leading zeros.\r\n        // j is the actual index of rd within n (if < 0, rd is a leading zero).\r\n        out: {\r\n\r\n          // Get the number of digits of the first element of xc.\r\n          for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);\r\n          i = sd - d;\r\n\r\n          // If the rounding digit is in the first element of xc...\r\n          if (i < 0) {\r\n            i += LOG_BASE;\r\n            j = sd;\r\n            n = xc[ni = 0];\r\n\r\n            // Get the rounding digit at index j of n.\r\n            rd = n / pows10[d - j - 1] % 10 | 0;\r\n          } else {\r\n            ni = mathceil((i + 1) / LOG_BASE);\r\n\r\n            if (ni >= xc.length) {\r\n\r\n              if (r) {\r\n\r\n                // Needed by sqrt.\r\n                for (; xc.length <= ni; xc.push(0));\r\n                n = rd = 0;\r\n                d = 1;\r\n                i %= LOG_BASE;\r\n                j = i - LOG_BASE + 1;\r\n              } else {\r\n                break out;\r\n              }\r\n            } else {\r\n              n = k = xc[ni];\r\n\r\n              // Get the number of digits of n.\r\n              for (d = 1; k >= 10; k /= 10, d++);\r\n\r\n              // Get the index of rd within n.\r\n              i %= LOG_BASE;\r\n\r\n              // Get the index of rd within n, adjusted for leading zeros.\r\n              // The number of leading zeros of n is given by LOG_BASE - d.\r\n              j = i - LOG_BASE + d;\r\n\r\n              // Get the rounding digit at index j of n.\r\n              rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;\r\n            }\r\n          }\r\n\r\n          r = r || sd < 0 ||\r\n\r\n          // Are there any non-zero digits after the rounding digit?\r\n          // The expression  n % pows10[d - j - 1]  returns all digits of n to the right\r\n          // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.\r\n           xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);\r\n\r\n          r = rm < 4\r\n           ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n           : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&\r\n\r\n            // Check whether the digit to the left of the rounding digit is odd.\r\n            ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||\r\n             rm == (x.s < 0 ? 8 : 7));\r\n\r\n          if (sd < 1 || !xc[0]) {\r\n            xc.length = 0;\r\n\r\n            if (r) {\r\n\r\n              // Convert sd to decimal places.\r\n              sd -= x.e + 1;\r\n\r\n              // 1, 0.1, 0.01, 0.001, 0.0001 etc.\r\n              xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];\r\n              x.e = -sd || 0;\r\n            } else {\r\n\r\n              // Zero.\r\n              xc[0] = x.e = 0;\r\n            }\r\n\r\n            return x;\r\n          }\r\n\r\n          // Remove excess digits.\r\n          if (i == 0) {\r\n            xc.length = ni;\r\n            k = 1;\r\n            ni--;\r\n          } else {\r\n            xc.length = ni + 1;\r\n            k = pows10[LOG_BASE - i];\r\n\r\n            // E.g. 56700 becomes 56000 if 7 is the rounding digit.\r\n            // j > 0 means i > number of leading zeros of n.\r\n            xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;\r\n          }\r\n\r\n          // Round up?\r\n          if (r) {\r\n\r\n            for (; ;) {\r\n\r\n              // If the digit to be rounded up is in the first element of xc...\r\n              if (ni == 0) {\r\n\r\n                // i will be the length of xc[0] before k is added.\r\n                for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);\r\n                j = xc[0] += k;\r\n                for (k = 1; j >= 10; j /= 10, k++);\r\n\r\n                // if i != k the length has increased.\r\n                if (i != k) {\r\n                  x.e++;\r\n                  if (xc[0] == BASE) xc[0] = 1;\r\n                }\r\n\r\n                break;\r\n              } else {\r\n                xc[ni] += k;\r\n                if (xc[ni] != BASE) break;\r\n                xc[ni--] = 0;\r\n                k = 1;\r\n              }\r\n            }\r\n          }\r\n\r\n          // Remove trailing zeros.\r\n          for (i = xc.length; xc[--i] === 0; xc.pop());\r\n        }\r\n\r\n        // Overflow? Infinity.\r\n        if (x.e > MAX_EXP) {\r\n          x.c = x.e = null;\r\n\r\n        // Underflow? Zero.\r\n        } else if (x.e < MIN_EXP) {\r\n          x.c = [x.e = 0];\r\n        }\r\n      }\r\n\r\n      return x;\r\n    }\r\n\r\n\r\n    function valueOf(n) {\r\n      var str,\r\n        e = n.e;\r\n\r\n      if (e === null) return n.toString();\r\n\r\n      str = coeffToString(n.c);\r\n\r\n      str = e <= TO_EXP_NEG || e >= TO_EXP_POS\r\n        ? toExponential(str, e)\r\n        : toFixedPoint(str, e, '0');\r\n\r\n      return n.s < 0 ? '-' + str : str;\r\n    }\r\n\r\n\r\n    // PROTOTYPE/INSTANCE METHODS\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the absolute value of this BigNumber.\r\n     */\r\n    P.absoluteValue = P.abs = function () {\r\n      var x = new BigNumber(this);\r\n      if (x.s < 0) x.s = 1;\r\n      return x;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return\r\n     *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),\r\n     *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),\r\n     *   0 if they have the same value,\r\n     *   or null if the value of either is NaN.\r\n     */\r\n    P.comparedTo = function (y, b) {\r\n      return compare(this, new BigNumber(y, b));\r\n    };\r\n\r\n\r\n    /*\r\n     * If dp is undefined or null or true or false, return the number of decimal places of the\r\n     * value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.\r\n     *\r\n     * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this\r\n     * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or\r\n     * ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * [dp] {number} Decimal places: integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     */\r\n    P.decimalPlaces = P.dp = function (dp, rm) {\r\n      var c, n, v,\r\n        x = this;\r\n\r\n      if (dp != null) {\r\n        intCheck(dp, 0, MAX);\r\n        if (rm == null) rm = ROUNDING_MODE;\r\n        else intCheck(rm, 0, 8);\r\n\r\n        return round(new BigNumber(x), dp + x.e + 1, rm);\r\n      }\r\n\r\n      if (!(c = x.c)) return null;\r\n      n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;\r\n\r\n      // Subtract the number of trailing zeros of the last number.\r\n      if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);\r\n      if (n < 0) n = 0;\r\n\r\n      return n;\r\n    };\r\n\r\n\r\n    /*\r\n     *  n / 0 = I\r\n     *  n / N = N\r\n     *  n / I = 0\r\n     *  0 / n = 0\r\n     *  0 / 0 = N\r\n     *  0 / N = N\r\n     *  0 / I = 0\r\n     *  N / n = N\r\n     *  N / 0 = N\r\n     *  N / N = N\r\n     *  N / I = N\r\n     *  I / n = I\r\n     *  I / 0 = I\r\n     *  I / N = N\r\n     *  I / I = N\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber divided by the value of\r\n     * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.\r\n     */\r\n    P.dividedBy = P.div = function (y, b) {\r\n      return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the integer part of dividing the value of this\r\n     * BigNumber by the value of BigNumber(y, b).\r\n     */\r\n    P.dividedToIntegerBy = P.idiv = function (y, b) {\r\n      return div(this, new BigNumber(y, b), 0, 1);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.\r\n     *\r\n     * If m is present, return the result modulo m.\r\n     * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.\r\n     * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.\r\n     *\r\n     * The modular power operation works efficiently when x, n, and m are integers, otherwise it\r\n     * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.\r\n     *\r\n     * n {number|string|BigNumber} The exponent. An integer.\r\n     * [m] {number|string|BigNumber} The modulus.\r\n     *\r\n     * '[BigNumber Error] Exponent not an integer: {n}'\r\n     */\r\n    P.exponentiatedBy = P.pow = function (n, m) {\r\n      var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,\r\n        x = this;\r\n\r\n      n = new BigNumber(n);\r\n\r\n      // Allow NaN and ±Infinity, but not other non-integers.\r\n      if (n.c && !n.isInteger()) {\r\n        throw Error\r\n          (bignumberError + 'Exponent not an integer: ' + valueOf(n));\r\n      }\r\n\r\n      if (m != null) m = new BigNumber(m);\r\n\r\n      // Exponent of MAX_SAFE_INTEGER is 15.\r\n      nIsBig = n.e > 14;\r\n\r\n      // If x is NaN, ±Infinity, ±0 or ±1, or n is ±Infinity, NaN or ±0.\r\n      if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {\r\n\r\n        // The sign of the result of pow when x is negative depends on the evenness of n.\r\n        // If +n overflows to ±Infinity, the evenness of n would be not be known.\r\n        y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));\r\n        return m ? y.mod(m) : y;\r\n      }\r\n\r\n      nIsNeg = n.s < 0;\r\n\r\n      if (m) {\r\n\r\n        // x % m returns NaN if abs(m) is zero, or m is NaN.\r\n        if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);\r\n\r\n        isModExp = !nIsNeg && x.isInteger() && m.isInteger();\r\n\r\n        if (isModExp) x = x.mod(m);\r\n\r\n      // Overflow to ±Infinity: >=2**1e10 or >=1.0000024**1e15.\r\n      // Underflow to ±0: <=0.79**1e10 or <=0.9999975**1e15.\r\n      } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0\r\n        // [1, 240000000]\r\n        ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7\r\n        // [80000000000000]  [99999750000000]\r\n        : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {\r\n\r\n        // If x is negative and n is odd, k = -0, else k = 0.\r\n        k = x.s < 0 && isOdd(n) ? -0 : 0;\r\n\r\n        // If x >= 1, k = ±Infinity.\r\n        if (x.e > -1) k = 1 / k;\r\n\r\n        // If n is negative return ±0, else return ±Infinity.\r\n        return new BigNumber(nIsNeg ? 1 / k : k);\r\n\r\n      } else if (POW_PRECISION) {\r\n\r\n        // Truncating each coefficient array to a length of k after each multiplication\r\n        // equates to truncating significant digits to POW_PRECISION + [28, 41],\r\n        // i.e. there will be a minimum of 28 guard digits retained.\r\n        k = mathceil(POW_PRECISION / LOG_BASE + 2);\r\n      }\r\n\r\n      if (nIsBig) {\r\n        half = new BigNumber(0.5);\r\n        if (nIsNeg) n.s = 1;\r\n        nIsOdd = isOdd(n);\r\n      } else {\r\n        i = Math.abs(+valueOf(n));\r\n        nIsOdd = i % 2;\r\n      }\r\n\r\n      y = new BigNumber(ONE);\r\n\r\n      // Performs 54 loop iterations for n of 9007199254740991.\r\n      for (; ;) {\r\n\r\n        if (nIsOdd) {\r\n          y = y.times(x);\r\n          if (!y.c) break;\r\n\r\n          if (k) {\r\n            if (y.c.length > k) y.c.length = k;\r\n          } else if (isModExp) {\r\n            y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));\r\n          }\r\n        }\r\n\r\n        if (i) {\r\n          i = mathfloor(i / 2);\r\n          if (i === 0) break;\r\n          nIsOdd = i % 2;\r\n        } else {\r\n          n = n.times(half);\r\n          round(n, n.e + 1, 1);\r\n\r\n          if (n.e > 14) {\r\n            nIsOdd = isOdd(n);\r\n          } else {\r\n            i = +valueOf(n);\r\n            if (i === 0) break;\r\n            nIsOdd = i % 2;\r\n          }\r\n        }\r\n\r\n        x = x.times(x);\r\n\r\n        if (k) {\r\n          if (x.c && x.c.length > k) x.c.length = k;\r\n        } else if (isModExp) {\r\n          x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));\r\n        }\r\n      }\r\n\r\n      if (isModExp) return y;\r\n      if (nIsNeg) y = ONE.div(y);\r\n\r\n      return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer\r\n     * using rounding mode rm, or ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'\r\n     */\r\n    P.integerValue = function (rm) {\r\n      var n = new BigNumber(this);\r\n      if (rm == null) rm = ROUNDING_MODE;\r\n      else intCheck(rm, 0, 8);\r\n      return round(n, n.e + 1, rm);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),\r\n     * otherwise return false.\r\n     */\r\n    P.isEqualTo = P.eq = function (y, b) {\r\n      return compare(this, new BigNumber(y, b)) === 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is a finite number, otherwise return false.\r\n     */\r\n    P.isFinite = function () {\r\n      return !!this.c;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),\r\n     * otherwise return false.\r\n     */\r\n    P.isGreaterThan = P.gt = function (y, b) {\r\n      return compare(this, new BigNumber(y, b)) > 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is greater than or equal to the value of\r\n     * BigNumber(y, b), otherwise return false.\r\n     */\r\n    P.isGreaterThanOrEqualTo = P.gte = function (y, b) {\r\n      return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;\r\n\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is an integer, otherwise return false.\r\n     */\r\n    P.isInteger = function () {\r\n      return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),\r\n     * otherwise return false.\r\n     */\r\n    P.isLessThan = P.lt = function (y, b) {\r\n      return compare(this, new BigNumber(y, b)) < 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is less than or equal to the value of\r\n     * BigNumber(y, b), otherwise return false.\r\n     */\r\n    P.isLessThanOrEqualTo = P.lte = function (y, b) {\r\n      return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is NaN, otherwise return false.\r\n     */\r\n    P.isNaN = function () {\r\n      return !this.s;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is negative, otherwise return false.\r\n     */\r\n    P.isNegative = function () {\r\n      return this.s < 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is positive, otherwise return false.\r\n     */\r\n    P.isPositive = function () {\r\n      return this.s > 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is 0 or -0, otherwise return false.\r\n     */\r\n    P.isZero = function () {\r\n      return !!this.c && this.c[0] == 0;\r\n    };\r\n\r\n\r\n    /*\r\n     *  n - 0 = n\r\n     *  n - N = N\r\n     *  n - I = -I\r\n     *  0 - n = -n\r\n     *  0 - 0 = 0\r\n     *  0 - N = N\r\n     *  0 - I = -I\r\n     *  N - n = N\r\n     *  N - 0 = N\r\n     *  N - N = N\r\n     *  N - I = N\r\n     *  I - n = I\r\n     *  I - 0 = I\r\n     *  I - N = N\r\n     *  I - I = N\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber minus the value of\r\n     * BigNumber(y, b).\r\n     */\r\n    P.minus = function (y, b) {\r\n      var i, j, t, xLTy,\r\n        x = this,\r\n        a = x.s;\r\n\r\n      y = new BigNumber(y, b);\r\n      b = y.s;\r\n\r\n      // Either NaN?\r\n      if (!a || !b) return new BigNumber(NaN);\r\n\r\n      // Signs differ?\r\n      if (a != b) {\r\n        y.s = -b;\r\n        return x.plus(y);\r\n      }\r\n\r\n      var xe = x.e / LOG_BASE,\r\n        ye = y.e / LOG_BASE,\r\n        xc = x.c,\r\n        yc = y.c;\r\n\r\n      if (!xe || !ye) {\r\n\r\n        // Either Infinity?\r\n        if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);\r\n\r\n        // Either zero?\r\n        if (!xc[0] || !yc[0]) {\r\n\r\n          // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\r\n          return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :\r\n\r\n           // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity\r\n           ROUNDING_MODE == 3 ? -0 : 0);\r\n        }\r\n      }\r\n\r\n      xe = bitFloor(xe);\r\n      ye = bitFloor(ye);\r\n      xc = xc.slice();\r\n\r\n      // Determine which is the bigger number.\r\n      if (a = xe - ye) {\r\n\r\n        if (xLTy = a < 0) {\r\n          a = -a;\r\n          t = xc;\r\n        } else {\r\n          ye = xe;\r\n          t = yc;\r\n        }\r\n\r\n        t.reverse();\r\n\r\n        // Prepend zeros to equalise exponents.\r\n        for (b = a; b--; t.push(0));\r\n        t.reverse();\r\n      } else {\r\n\r\n        // Exponents equal. Check digit by digit.\r\n        j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;\r\n\r\n        for (a = b = 0; b < j; b++) {\r\n\r\n          if (xc[b] != yc[b]) {\r\n            xLTy = xc[b] < yc[b];\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      // x < y? Point xc to the array of the bigger number.\r\n      if (xLTy) t = xc, xc = yc, yc = t, y.s = -y.s;\r\n\r\n      b = (j = yc.length) - (i = xc.length);\r\n\r\n      // Append zeros to xc if shorter.\r\n      // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.\r\n      if (b > 0) for (; b--; xc[i++] = 0);\r\n      b = BASE - 1;\r\n\r\n      // Subtract yc from xc.\r\n      for (; j > a;) {\r\n\r\n        if (xc[--j] < yc[j]) {\r\n          for (i = j; i && !xc[--i]; xc[i] = b);\r\n          --xc[i];\r\n          xc[j] += BASE;\r\n        }\r\n\r\n        xc[j] -= yc[j];\r\n      }\r\n\r\n      // Remove leading zeros and adjust exponent accordingly.\r\n      for (; xc[0] == 0; xc.splice(0, 1), --ye);\r\n\r\n      // Zero?\r\n      if (!xc[0]) {\r\n\r\n        // Following IEEE 754 (2008) 6.3,\r\n        // n - n = +0  but  n - n = -0  when rounding towards -Infinity.\r\n        y.s = ROUNDING_MODE == 3 ? -1 : 1;\r\n        y.c = [y.e = 0];\r\n        return y;\r\n      }\r\n\r\n      // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity\r\n      // for finite x and y.\r\n      return normalise(y, xc, ye);\r\n    };\r\n\r\n\r\n    /*\r\n     *   n % 0 =  N\r\n     *   n % N =  N\r\n     *   n % I =  n\r\n     *   0 % n =  0\r\n     *  -0 % n = -0\r\n     *   0 % 0 =  N\r\n     *   0 % N =  N\r\n     *   0 % I =  0\r\n     *   N % n =  N\r\n     *   N % 0 =  N\r\n     *   N % N =  N\r\n     *   N % I =  N\r\n     *   I % n =  N\r\n     *   I % 0 =  N\r\n     *   I % N =  N\r\n     *   I % I =  N\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber modulo the value of\r\n     * BigNumber(y, b). The result depends on the value of MODULO_MODE.\r\n     */\r\n    P.modulo = P.mod = function (y, b) {\r\n      var q, s,\r\n        x = this;\r\n\r\n      y = new BigNumber(y, b);\r\n\r\n      // Return NaN if x is Infinity or NaN, or y is NaN or zero.\r\n      if (!x.c || !y.s || y.c && !y.c[0]) {\r\n        return new BigNumber(NaN);\r\n\r\n      // Return x if y is Infinity or x is zero.\r\n      } else if (!y.c || x.c && !x.c[0]) {\r\n        return new BigNumber(x);\r\n      }\r\n\r\n      if (MODULO_MODE == 9) {\r\n\r\n        // Euclidian division: q = sign(y) * floor(x / abs(y))\r\n        // r = x - qy    where  0 <= r < abs(y)\r\n        s = y.s;\r\n        y.s = 1;\r\n        q = div(x, y, 0, 3);\r\n        y.s = s;\r\n        q.s *= s;\r\n      } else {\r\n        q = div(x, y, 0, MODULO_MODE);\r\n      }\r\n\r\n      y = x.minus(q.times(y));\r\n\r\n      // To match JavaScript %, ensure sign of zero is sign of dividend.\r\n      if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;\r\n\r\n      return y;\r\n    };\r\n\r\n\r\n    /*\r\n     *  n * 0 = 0\r\n     *  n * N = N\r\n     *  n * I = I\r\n     *  0 * n = 0\r\n     *  0 * 0 = 0\r\n     *  0 * N = N\r\n     *  0 * I = N\r\n     *  N * n = N\r\n     *  N * 0 = N\r\n     *  N * N = N\r\n     *  N * I = N\r\n     *  I * n = I\r\n     *  I * 0 = N\r\n     *  I * N = N\r\n     *  I * I = I\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value\r\n     * of BigNumber(y, b).\r\n     */\r\n    P.multipliedBy = P.times = function (y, b) {\r\n      var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,\r\n        base, sqrtBase,\r\n        x = this,\r\n        xc = x.c,\r\n        yc = (y = new BigNumber(y, b)).c;\r\n\r\n      // Either NaN, ±Infinity or ±0?\r\n      if (!xc || !yc || !xc[0] || !yc[0]) {\r\n\r\n        // Return NaN if either is NaN, or one is 0 and the other is Infinity.\r\n        if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {\r\n          y.c = y.e = y.s = null;\r\n        } else {\r\n          y.s *= x.s;\r\n\r\n          // Return ±Infinity if either is ±Infinity.\r\n          if (!xc || !yc) {\r\n            y.c = y.e = null;\r\n\r\n          // Return ±0 if either is ±0.\r\n          } else {\r\n            y.c = [0];\r\n            y.e = 0;\r\n          }\r\n        }\r\n\r\n        return y;\r\n      }\r\n\r\n      e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);\r\n      y.s *= x.s;\r\n      xcL = xc.length;\r\n      ycL = yc.length;\r\n\r\n      // Ensure xc points to longer array and xcL to its length.\r\n      if (xcL < ycL) zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;\r\n\r\n      // Initialise the result array with zeros.\r\n      for (i = xcL + ycL, zc = []; i--; zc.push(0));\r\n\r\n      base = BASE;\r\n      sqrtBase = SQRT_BASE;\r\n\r\n      for (i = ycL; --i >= 0;) {\r\n        c = 0;\r\n        ylo = yc[i] % sqrtBase;\r\n        yhi = yc[i] / sqrtBase | 0;\r\n\r\n        for (k = xcL, j = i + k; j > i;) {\r\n          xlo = xc[--k] % sqrtBase;\r\n          xhi = xc[k] / sqrtBase | 0;\r\n          m = yhi * xlo + xhi * ylo;\r\n          xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;\r\n          c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;\r\n          zc[j--] = xlo % base;\r\n        }\r\n\r\n        zc[j] = c;\r\n      }\r\n\r\n      if (c) {\r\n        ++e;\r\n      } else {\r\n        zc.splice(0, 1);\r\n      }\r\n\r\n      return normalise(y, zc, e);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the value of this BigNumber negated,\r\n     * i.e. multiplied by -1.\r\n     */\r\n    P.negated = function () {\r\n      var x = new BigNumber(this);\r\n      x.s = -x.s || null;\r\n      return x;\r\n    };\r\n\r\n\r\n    /*\r\n     *  n + 0 = n\r\n     *  n + N = N\r\n     *  n + I = I\r\n     *  0 + n = n\r\n     *  0 + 0 = 0\r\n     *  0 + N = N\r\n     *  0 + I = I\r\n     *  N + n = N\r\n     *  N + 0 = N\r\n     *  N + N = N\r\n     *  N + I = N\r\n     *  I + n = I\r\n     *  I + 0 = I\r\n     *  I + N = N\r\n     *  I + I = I\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber plus the value of\r\n     * BigNumber(y, b).\r\n     */\r\n    P.plus = function (y, b) {\r\n      var t,\r\n        x = this,\r\n        a = x.s;\r\n\r\n      y = new BigNumber(y, b);\r\n      b = y.s;\r\n\r\n      // Either NaN?\r\n      if (!a || !b) return new BigNumber(NaN);\r\n\r\n      // Signs differ?\r\n       if (a != b) {\r\n        y.s = -b;\r\n        return x.minus(y);\r\n      }\r\n\r\n      var xe = x.e / LOG_BASE,\r\n        ye = y.e / LOG_BASE,\r\n        xc = x.c,\r\n        yc = y.c;\r\n\r\n      if (!xe || !ye) {\r\n\r\n        // Return ±Infinity if either ±Infinity.\r\n        if (!xc || !yc) return new BigNumber(a / 0);\r\n\r\n        // Either zero?\r\n        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\r\n        if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);\r\n      }\r\n\r\n      xe = bitFloor(xe);\r\n      ye = bitFloor(ye);\r\n      xc = xc.slice();\r\n\r\n      // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.\r\n      if (a = xe - ye) {\r\n        if (a > 0) {\r\n          ye = xe;\r\n          t = yc;\r\n        } else {\r\n          a = -a;\r\n          t = xc;\r\n        }\r\n\r\n        t.reverse();\r\n        for (; a--; t.push(0));\r\n        t.reverse();\r\n      }\r\n\r\n      a = xc.length;\r\n      b = yc.length;\r\n\r\n      // Point xc to the longer array, and b to the shorter length.\r\n      if (a - b < 0) t = yc, yc = xc, xc = t, b = a;\r\n\r\n      // Only start adding at yc.length - 1 as the further digits of xc can be ignored.\r\n      for (a = 0; b;) {\r\n        a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;\r\n        xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;\r\n      }\r\n\r\n      if (a) {\r\n        xc = [a].concat(xc);\r\n        ++ye;\r\n      }\r\n\r\n      // No need to check for zero, as +x + +y != 0 && -x + -y != 0\r\n      // ye = MAX_EXP + 1 possible\r\n      return normalise(y, xc, ye);\r\n    };\r\n\r\n\r\n    /*\r\n     * If sd is undefined or null or true or false, return the number of significant digits of\r\n     * the value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.\r\n     * If sd is true include integer-part trailing zeros in the count.\r\n     *\r\n     * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this\r\n     * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or\r\n     * ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.\r\n     *                     boolean: whether to count integer-part trailing zeros: true or false.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\r\n     */\r\n    P.precision = P.sd = function (sd, rm) {\r\n      var c, n, v,\r\n        x = this;\r\n\r\n      if (sd != null && sd !== !!sd) {\r\n        intCheck(sd, 1, MAX);\r\n        if (rm == null) rm = ROUNDING_MODE;\r\n        else intCheck(rm, 0, 8);\r\n\r\n        return round(new BigNumber(x), sd, rm);\r\n      }\r\n\r\n      if (!(c = x.c)) return null;\r\n      v = c.length - 1;\r\n      n = v * LOG_BASE + 1;\r\n\r\n      if (v = c[v]) {\r\n\r\n        // Subtract the number of trailing zeros of the last element.\r\n        for (; v % 10 == 0; v /= 10, n--);\r\n\r\n        // Add the number of digits of the first element.\r\n        for (v = c[0]; v >= 10; v /= 10, n++);\r\n      }\r\n\r\n      if (sd && x.e + 1 > n) n = x.e + 1;\r\n\r\n      return n;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the value of this BigNumber shifted by k places\r\n     * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.\r\n     *\r\n     * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'\r\n     */\r\n    P.shiftedBy = function (k) {\r\n      intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);\r\n      return this.times('1e' + k);\r\n    };\r\n\r\n\r\n    /*\r\n     *  sqrt(-n) =  N\r\n     *  sqrt(N) =  N\r\n     *  sqrt(-I) =  N\r\n     *  sqrt(I) =  I\r\n     *  sqrt(0) =  0\r\n     *  sqrt(-0) = -0\r\n     *\r\n     * Return a new BigNumber whose value is the square root of the value of this BigNumber,\r\n     * rounded according to DECIMAL_PLACES and ROUNDING_MODE.\r\n     */\r\n    P.squareRoot = P.sqrt = function () {\r\n      var m, n, r, rep, t,\r\n        x = this,\r\n        c = x.c,\r\n        s = x.s,\r\n        e = x.e,\r\n        dp = DECIMAL_PLACES + 4,\r\n        half = new BigNumber('0.5');\r\n\r\n      // Negative/NaN/Infinity/zero?\r\n      if (s !== 1 || !c || !c[0]) {\r\n        return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);\r\n      }\r\n\r\n      // Initial estimate.\r\n      s = Math.sqrt(+valueOf(x));\r\n\r\n      // Math.sqrt underflow/overflow?\r\n      // Pass x to Math.sqrt as integer, then adjust the exponent of the result.\r\n      if (s == 0 || s == 1 / 0) {\r\n        n = coeffToString(c);\r\n        if ((n.length + e) % 2 == 0) n += '0';\r\n        s = Math.sqrt(+n);\r\n        e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);\r\n\r\n        if (s == 1 / 0) {\r\n          n = '5e' + e;\r\n        } else {\r\n          n = s.toExponential();\r\n          n = n.slice(0, n.indexOf('e') + 1) + e;\r\n        }\r\n\r\n        r = new BigNumber(n);\r\n      } else {\r\n        r = new BigNumber(s + '');\r\n      }\r\n\r\n      // Check for zero.\r\n      // r could be zero if MIN_EXP is changed after the this value was created.\r\n      // This would cause a division by zero (x/t) and hence Infinity below, which would cause\r\n      // coeffToString to throw.\r\n      if (r.c[0]) {\r\n        e = r.e;\r\n        s = e + dp;\r\n        if (s < 3) s = 0;\r\n\r\n        // Newton-Raphson iteration.\r\n        for (; ;) {\r\n          t = r;\r\n          r = half.times(t.plus(div(x, t, dp, 1)));\r\n\r\n          if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {\r\n\r\n            // The exponent of r may here be one less than the final result exponent,\r\n            // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits\r\n            // are indexed correctly.\r\n            if (r.e < e) --s;\r\n            n = n.slice(s - 3, s + 1);\r\n\r\n            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits\r\n            // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the\r\n            // iteration.\r\n            if (n == '9999' || !rep && n == '4999') {\r\n\r\n              // On the first iteration only, check to see if rounding up gives the\r\n              // exact result as the nines may infinitely repeat.\r\n              if (!rep) {\r\n                round(t, t.e + DECIMAL_PLACES + 2, 0);\r\n\r\n                if (t.times(t).eq(x)) {\r\n                  r = t;\r\n                  break;\r\n                }\r\n              }\r\n\r\n              dp += 4;\r\n              s += 4;\r\n              rep = 1;\r\n            } else {\r\n\r\n              // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact\r\n              // result. If not, then there are further digits and m will be truthy.\r\n              if (!+n || !+n.slice(1) && n.charAt(0) == '5') {\r\n\r\n                // Truncate to the first rounding digit.\r\n                round(r, r.e + DECIMAL_PLACES + 2, 1);\r\n                m = !r.times(r).eq(x);\r\n              }\r\n\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber in exponential notation and\r\n     * rounded using ROUNDING_MODE to dp fixed decimal places.\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     */\r\n    P.toExponential = function (dp, rm) {\r\n      if (dp != null) {\r\n        intCheck(dp, 0, MAX);\r\n        dp++;\r\n      }\r\n      return format(this, dp, rm, 1);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber in fixed-point notation rounding\r\n     * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',\r\n     * but e.g. (-0.00001).toFixed(0) is '-0'.\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     */\r\n    P.toFixed = function (dp, rm) {\r\n      if (dp != null) {\r\n        intCheck(dp, 0, MAX);\r\n        dp = dp + this.e + 1;\r\n      }\r\n      return format(this, dp, rm);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber in fixed-point notation rounded\r\n     * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties\r\n     * of the format or FORMAT object (see BigNumber.set).\r\n     *\r\n     * The formatting object may contain some or all of the properties shown below.\r\n     *\r\n     * FORMAT = {\r\n     *   prefix: '',\r\n     *   groupSize: 3,\r\n     *   secondaryGroupSize: 0,\r\n     *   groupSeparator: ',',\r\n     *   decimalSeparator: '.',\r\n     *   fractionGroupSize: 0,\r\n     *   fractionGroupSeparator: '\\xA0',      // non-breaking space\r\n     *   suffix: ''\r\n     * };\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     * [format] {object} Formatting options. See FORMAT pbject above.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     * '[BigNumber Error] Argument not an object: {format}'\r\n     */\r\n    P.toFormat = function (dp, rm, format) {\r\n      var str,\r\n        x = this;\r\n\r\n      if (format == null) {\r\n        if (dp != null && rm && typeof rm == 'object') {\r\n          format = rm;\r\n          rm = null;\r\n        } else if (dp && typeof dp == 'object') {\r\n          format = dp;\r\n          dp = rm = null;\r\n        } else {\r\n          format = FORMAT;\r\n        }\r\n      } else if (typeof format != 'object') {\r\n        throw Error\r\n          (bignumberError + 'Argument not an object: ' + format);\r\n      }\r\n\r\n      str = x.toFixed(dp, rm);\r\n\r\n      if (x.c) {\r\n        var i,\r\n          arr = str.split('.'),\r\n          g1 = +format.groupSize,\r\n          g2 = +format.secondaryGroupSize,\r\n          groupSeparator = format.groupSeparator || '',\r\n          intPart = arr[0],\r\n          fractionPart = arr[1],\r\n          isNeg = x.s < 0,\r\n          intDigits = isNeg ? intPart.slice(1) : intPart,\r\n          len = intDigits.length;\r\n\r\n        if (g2) i = g1, g1 = g2, g2 = i, len -= i;\r\n\r\n        if (g1 > 0 && len > 0) {\r\n          i = len % g1 || g1;\r\n          intPart = intDigits.substr(0, i);\r\n          for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);\r\n          if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);\r\n          if (isNeg) intPart = '-' + intPart;\r\n        }\r\n\r\n        str = fractionPart\r\n         ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)\r\n          ? fractionPart.replace(new RegExp('\\\\d{' + g2 + '}\\\\B', 'g'),\r\n           '$&' + (format.fractionGroupSeparator || ''))\r\n          : fractionPart)\r\n         : intPart;\r\n      }\r\n\r\n      return (format.prefix || '') + str + (format.suffix || '');\r\n    };\r\n\r\n\r\n    /*\r\n     * Return an array of two BigNumbers representing the value of this BigNumber as a simple\r\n     * fraction with an integer numerator and an integer denominator.\r\n     * The denominator will be a positive non-zero value less than or equal to the specified\r\n     * maximum denominator. If a maximum denominator is not specified, the denominator will be\r\n     * the lowest value necessary to represent the number exactly.\r\n     *\r\n     * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.\r\n     *\r\n     * '[BigNumber Error] Argument {not an integer|out of range} : {md}'\r\n     */\r\n    P.toFraction = function (md) {\r\n      var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,\r\n        x = this,\r\n        xc = x.c;\r\n\r\n      if (md != null) {\r\n        n = new BigNumber(md);\r\n\r\n        // Throw if md is less than one or is not an integer, unless it is Infinity.\r\n        if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {\r\n          throw Error\r\n            (bignumberError + 'Argument ' +\r\n              (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));\r\n        }\r\n      }\r\n\r\n      if (!xc) return new BigNumber(x);\r\n\r\n      d = new BigNumber(ONE);\r\n      n1 = d0 = new BigNumber(ONE);\r\n      d1 = n0 = new BigNumber(ONE);\r\n      s = coeffToString(xc);\r\n\r\n      // Determine initial denominator.\r\n      // d is a power of 10 and the minimum max denominator that specifies the value exactly.\r\n      e = d.e = s.length - x.e - 1;\r\n      d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];\r\n      md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;\r\n\r\n      exp = MAX_EXP;\r\n      MAX_EXP = 1 / 0;\r\n      n = new BigNumber(s);\r\n\r\n      // n0 = d1 = 0\r\n      n0.c[0] = 0;\r\n\r\n      for (; ;)  {\r\n        q = div(n, d, 0, 1);\r\n        d2 = d0.plus(q.times(d1));\r\n        if (d2.comparedTo(md) == 1) break;\r\n        d0 = d1;\r\n        d1 = d2;\r\n        n1 = n0.plus(q.times(d2 = n1));\r\n        n0 = d2;\r\n        d = n.minus(q.times(d2 = d));\r\n        n = d2;\r\n      }\r\n\r\n      d2 = div(md.minus(d0), d1, 0, 1);\r\n      n0 = n0.plus(d2.times(n1));\r\n      d0 = d0.plus(d2.times(d1));\r\n      n0.s = n1.s = x.s;\r\n      e = e * 2;\r\n\r\n      // Determine which fraction is closer to x, n0/d0 or n1/d1\r\n      r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(\r\n          div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];\r\n\r\n      MAX_EXP = exp;\r\n\r\n      return r;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return the value of this BigNumber converted to a number primitive.\r\n     */\r\n    P.toNumber = function () {\r\n      return +valueOf(this);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber rounded to sd significant digits\r\n     * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits\r\n     * necessary to represent the integer part of the value in fixed-point notation, then use\r\n     * exponential notation.\r\n     *\r\n     * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\r\n     */\r\n    P.toPrecision = function (sd, rm) {\r\n      if (sd != null) intCheck(sd, 1, MAX);\r\n      return format(this, sd, rm, 2);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber in base b, or base 10 if b is\r\n     * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and\r\n     * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent\r\n     * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than\r\n     * TO_EXP_NEG, return exponential notation.\r\n     *\r\n     * [b] {number} Integer, 2 to ALPHABET.length inclusive.\r\n     *\r\n     * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\r\n     */\r\n    P.toString = function (b) {\r\n      var str,\r\n        n = this,\r\n        s = n.s,\r\n        e = n.e;\r\n\r\n      // Infinity or NaN?\r\n      if (e === null) {\r\n        if (s) {\r\n          str = 'Infinity';\r\n          if (s < 0) str = '-' + str;\r\n        } else {\r\n          str = 'NaN';\r\n        }\r\n      } else {\r\n        if (b == null) {\r\n          str = e <= TO_EXP_NEG || e >= TO_EXP_POS\r\n           ? toExponential(coeffToString(n.c), e)\r\n           : toFixedPoint(coeffToString(n.c), e, '0');\r\n        } else if (b === 10 && alphabetHasNormalDecimalDigits) {\r\n          n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);\r\n          str = toFixedPoint(coeffToString(n.c), n.e, '0');\r\n        } else {\r\n          intCheck(b, 2, ALPHABET.length, 'Base');\r\n          str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);\r\n        }\r\n\r\n        if (s < 0 && n.c[0]) str = '-' + str;\r\n      }\r\n\r\n      return str;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return as toString, but do not accept a base argument, and include the minus sign for\r\n     * negative zero.\r\n     */\r\n    P.valueOf = P.toJSON = function () {\r\n      return valueOf(this);\r\n    };\r\n\r\n\r\n    P._isBigNumber = true;\r\n\r\n    if (configObject != null) BigNumber.set(configObject);\r\n\r\n    return BigNumber;\r\n  }\r\n\r\n\r\n  // PRIVATE HELPER FUNCTIONS\r\n\r\n  // These functions don't need access to variables,\r\n  // e.g. DECIMAL_PLACES, in the scope of the `clone` function above.\r\n\r\n\r\n  function bitFloor(n) {\r\n    var i = n | 0;\r\n    return n > 0 || n === i ? i : i - 1;\r\n  }\r\n\r\n\r\n  // Return a coefficient array as a string of base 10 digits.\r\n  function coeffToString(a) {\r\n    var s, z,\r\n      i = 1,\r\n      j = a.length,\r\n      r = a[0] + '';\r\n\r\n    for (; i < j;) {\r\n      s = a[i++] + '';\r\n      z = LOG_BASE - s.length;\r\n      for (; z--; s = '0' + s);\r\n      r += s;\r\n    }\r\n\r\n    // Determine trailing zeros.\r\n    for (j = r.length; r.charCodeAt(--j) === 48;);\r\n\r\n    return r.slice(0, j + 1 || 1);\r\n  }\r\n\r\n\r\n  // Compare the value of BigNumbers x and y.\r\n  function compare(x, y) {\r\n    var a, b,\r\n      xc = x.c,\r\n      yc = y.c,\r\n      i = x.s,\r\n      j = y.s,\r\n      k = x.e,\r\n      l = y.e;\r\n\r\n    // Either NaN?\r\n    if (!i || !j) return null;\r\n\r\n    a = xc && !xc[0];\r\n    b = yc && !yc[0];\r\n\r\n    // Either zero?\r\n    if (a || b) return a ? b ? 0 : -j : i;\r\n\r\n    // Signs differ?\r\n    if (i != j) return i;\r\n\r\n    a = i < 0;\r\n    b = k == l;\r\n\r\n    // Either Infinity?\r\n    if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;\r\n\r\n    // Compare exponents.\r\n    if (!b) return k > l ^ a ? 1 : -1;\r\n\r\n    j = (k = xc.length) < (l = yc.length) ? k : l;\r\n\r\n    // Compare digit by digit.\r\n    for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;\r\n\r\n    // Compare lengths.\r\n    return k == l ? 0 : k > l ^ a ? 1 : -1;\r\n  }\r\n\r\n\r\n  /*\r\n   * Check that n is a primitive number, an integer, and in range, otherwise throw.\r\n   */\r\n  function intCheck(n, min, max, name) {\r\n    if (n < min || n > max || n !== mathfloor(n)) {\r\n      throw Error\r\n       (bignumberError + (name || 'Argument') + (typeof n == 'number'\r\n         ? n < min || n > max ? ' out of range: ' : ' not an integer: '\r\n         : ' not a primitive number: ') + String(n));\r\n    }\r\n  }\r\n\r\n\r\n  // Assumes finite n.\r\n  function isOdd(n) {\r\n    var k = n.c.length - 1;\r\n    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;\r\n  }\r\n\r\n\r\n  function toExponential(str, e) {\r\n    return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +\r\n     (e < 0 ? 'e' : 'e+') + e;\r\n  }\r\n\r\n\r\n  function toFixedPoint(str, e, z) {\r\n    var len, zs;\r\n\r\n    // Negative exponent?\r\n    if (e < 0) {\r\n\r\n      // Prepend zeros.\r\n      for (zs = z + '.'; ++e; zs += z);\r\n      str = zs + str;\r\n\r\n    // Positive exponent\r\n    } else {\r\n      len = str.length;\r\n\r\n      // Append zeros.\r\n      if (++e > len) {\r\n        for (zs = z, e -= len; --e; zs += z);\r\n        str += zs;\r\n      } else if (e < len) {\r\n        str = str.slice(0, e) + '.' + str.slice(e);\r\n      }\r\n    }\r\n\r\n    return str;\r\n  }\r\n\r\n\r\n  // EXPORT\r\n\r\n\r\n  BigNumber = clone();\r\n  BigNumber['default'] = BigNumber.BigNumber = BigNumber;\r\n\r\n  // AMD.\r\n  if (true) {\r\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () { return BigNumber; }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\r\n  // Node.js and other environments that support module.exports.\r\n  } else {}\r\n})(this);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmlnbnVtYmVyLmpzL2JpZ251bWJlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxtQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsdURBQXVEO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFdBQVc7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFNBQVM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLEtBQUs7QUFDL0MsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixLQUFLO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FB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QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx5QkFBeUI7QUFDbkMsWUFBWSx5QkFBeUI7QUFDckM7QUFDQSxvREFBb0QsRUFBRTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxvQ0FBb0MsbURBQW1ELEdBQUcsR0FBRztBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsS0FBSztBQUN6QjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixLQUFLO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsS0FBSztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE1BQU07QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixFQUFFO0FBQ3BCO0FBQ0E7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O0FBQy9DLElBQUksbUNBQU8sY0FBYyxtQkFBbUI7QUFBQSxrR0FBQztBQUM3QztBQUNBO0FBQ0EsSUFBSSxLQUFLLEVBVU47QUFDSCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9iaWdudW1iZXIuanMvYmlnbnVtYmVyLmpzP2U0N2MiXSwic291cmNlc0NvbnRlbnQiOlsiOyhmdW5jdGlvbiAoZ2xvYmFsT2JqZWN0KSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuLypcclxuICogICAgICBiaWdudW1iZXIuanMgdjkuMC4yXHJcbiAqICAgICAgQSBKYXZhU2NyaXB0IGxpYnJhcnkgZm9yIGFyYml0cmFyeS1wcmVjaXNpb24gYXJpdGhtZXRpYy5cclxuICogICAgICBodHRwczovL2dpdGh1Yi5jb20vTWlrZU1jbC9iaWdudW1iZXIuanNcclxuICogICAgICBDb3B5cmlnaHQgKGMpIDIwMjEgTWljaGFlbCBNY2xhdWdobGluIDxNOGNoODhsQGdtYWlsLmNvbT5cclxuICogICAgICBNSVQgTGljZW5zZWQuXHJcbiAqXHJcbiAqICAgICAgQmlnTnVtYmVyLnByb3RvdHlwZSBtZXRob2RzICAgICB8ICBCaWdOdW1iZXIgbWV0aG9kc1xyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIGFic29sdXRlVmFsdWUgICAgICAgICAgICBhYnMgICAgfCAgY2xvbmVcclxuICogICAgICBjb21wYXJlZFRvICAgICAgICAgICAgICAgICAgICAgIHwgIGNvbmZpZyAgICAgICAgICAgICAgIHNldFxyXG4gKiAgICAgIGRlY2ltYWxQbGFjZXMgICAgICAgICAgICBkcCAgICAgfCAgICAgIERFQ0lNQUxfUExBQ0VTXHJcbiAqICAgICAgZGl2aWRlZEJ5ICAgICAgICAgICAgICAgIGRpdiAgICB8ICAgICAgUk9VTkRJTkdfTU9ERVxyXG4gKiAgICAgIGRpdmlkZWRUb0ludGVnZXJCeSAgICAgICBpZGl2ICAgfCAgICAgIEVYUE9ORU5USUFMX0FUXHJcbiAqICAgICAgZXhwb25lbnRpYXRlZEJ5ICAgICAgICAgIHBvdyAgICB8ICAgICAgUkFOR0VcclxuICogICAgICBpbnRlZ2VyVmFsdWUgICAgICAgICAgICAgICAgICAgIHwgICAgICBDUllQVE9cclxuICogICAgICBpc0VxdWFsVG8gICAgICAgICAgICAgICAgZXEgICAgIHwgICAgICBNT0RVTE9fTU9ERVxyXG4gKiAgICAgIGlzRmluaXRlICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgIFBPV19QUkVDSVNJT05cclxuICogICAgICBpc0dyZWF0ZXJUaGFuICAgICAgICAgICAgZ3QgICAgIHwgICAgICBGT1JNQVRcclxuICogICAgICBpc0dyZWF0ZXJUaGFuT3JFcXVhbFRvICAgZ3RlICAgIHwgICAgICBBTFBIQUJFVFxyXG4gKiAgICAgIGlzSW50ZWdlciAgICAgICAgICAgICAgICAgICAgICAgfCAgaXNCaWdOdW1iZXJcclxuICogICAgICBpc0xlc3NUaGFuICAgICAgICAgICAgICAgbHQgICAgIHwgIG1heGltdW0gICAgICAgICAgICAgIG1heFxyXG4gKiAgICAgIGlzTGVzc1RoYW5PckVxdWFsVG8gICAgICBsdGUgICAgfCAgbWluaW11bSAgICAgICAgICAgICAgbWluXHJcbiAqICAgICAgaXNOYU4gICAgICAgICAgICAgICAgICAgICAgICAgICB8ICByYW5kb21cclxuICogICAgICBpc05lZ2F0aXZlICAgICAgICAgICAgICAgICAgICAgIHwgIHN1bVxyXG4gKiAgICAgIGlzUG9zaXRpdmUgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIGlzWmVybyAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIG1pbnVzICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIG1vZHVsbyAgICAgICAgICAgICAgICAgICBtb2QgICAgfFxyXG4gKiAgICAgIG11bHRpcGxpZWRCeSAgICAgICAgICAgICB0aW1lcyAgfFxyXG4gKiAgICAgIG5lZ2F0ZWQgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHBsdXMgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHByZWNpc2lvbiAgICAgICAgICAgICAgICBzZCAgICAgfFxyXG4gKiAgICAgIHNoaWZ0ZWRCeSAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHNxdWFyZVJvb3QgICAgICAgICAgICAgICBzcXJ0ICAgfFxyXG4gKiAgICAgIHRvRXhwb25lbnRpYWwgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvRml4ZWQgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvRm9ybWF0ICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvRnJhY3Rpb24gICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvSlNPTiAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvTnVtYmVyICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvUHJlY2lzaW9uICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvU3RyaW5nICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHZhbHVlT2YgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKlxyXG4gKi9cclxuXHJcblxyXG4gIHZhciBCaWdOdW1iZXIsXHJcbiAgICBpc051bWVyaWMgPSAvXi0/KD86XFxkKyg/OlxcLlxcZCopP3xcXC5cXGQrKSg/OmVbKy1dP1xcZCspPyQvaSxcclxuICAgIG1hdGhjZWlsID0gTWF0aC5jZWlsLFxyXG4gICAgbWF0aGZsb29yID0gTWF0aC5mbG9vcixcclxuXHJcbiAgICBiaWdudW1iZXJFcnJvciA9ICdbQmlnTnVtYmVyIEVycm9yXSAnLFxyXG4gICAgdG9vTWFueURpZ2l0cyA9IGJpZ251bWJlckVycm9yICsgJ051bWJlciBwcmltaXRpdmUgaGFzIG1vcmUgdGhhbiAxNSBzaWduaWZpY2FudCBkaWdpdHM6ICcsXHJcblxyXG4gICAgQkFTRSA9IDFlMTQsXHJcbiAgICBMT0dfQkFTRSA9IDE0LFxyXG4gICAgTUFYX1NBRkVfSU5URUdFUiA9IDB4MWZmZmZmZmZmZmZmZmYsICAgICAgICAgLy8gMl41MyAtIDFcclxuICAgIC8vIE1BWF9JTlQzMiA9IDB4N2ZmZmZmZmYsICAgICAgICAgICAgICAgICAgIC8vIDJeMzEgLSAxXHJcbiAgICBQT1dTX1RFTiA9IFsxLCAxMCwgMTAwLCAxZTMsIDFlNCwgMWU1LCAxZTYsIDFlNywgMWU4LCAxZTksIDFlMTAsIDFlMTEsIDFlMTIsIDFlMTNdLFxyXG4gICAgU1FSVF9CQVNFID0gMWU3LFxyXG5cclxuICAgIC8vIEVESVRBQkxFXHJcbiAgICAvLyBUaGUgbGltaXQgb24gdGhlIHZhbHVlIG9mIERFQ0lNQUxfUExBQ0VTLCBUT19FWFBfTkVHLCBUT19FWFBfUE9TLCBNSU5fRVhQLCBNQVhfRVhQLCBhbmRcclxuICAgIC8vIHRoZSBhcmd1bWVudHMgdG8gdG9FeHBvbmVudGlhbCwgdG9GaXhlZCwgdG9Gb3JtYXQsIGFuZCB0b1ByZWNpc2lvbi5cclxuICAgIE1BWCA9IDFFOTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYX0lOVDMyXHJcblxyXG5cclxuICAvKlxyXG4gICAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgQmlnTnVtYmVyIGNvbnN0cnVjdG9yLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGNsb25lKGNvbmZpZ09iamVjdCkge1xyXG4gICAgdmFyIGRpdiwgY29udmVydEJhc2UsIHBhcnNlTnVtZXJpYyxcclxuICAgICAgUCA9IEJpZ051bWJlci5wcm90b3R5cGUgPSB7IGNvbnN0cnVjdG9yOiBCaWdOdW1iZXIsIHRvU3RyaW5nOiBudWxsLCB2YWx1ZU9mOiBudWxsIH0sXHJcbiAgICAgIE9ORSA9IG5ldyBCaWdOdW1iZXIoMSksXHJcblxyXG5cclxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFRElUQUJMRSBDT05GSUcgREVGQVVMVFMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuXHJcbiAgICAgIC8vIFRoZSBkZWZhdWx0IHZhbHVlcyBiZWxvdyBtdXN0IGJlIGludGVnZXJzIHdpdGhpbiB0aGUgaW5jbHVzaXZlIHJhbmdlcyBzdGF0ZWQuXHJcbiAgICAgIC8vIFRoZSB2YWx1ZXMgY2FuIGFsc28gYmUgY2hhbmdlZCBhdCBydW4tdGltZSB1c2luZyBCaWdOdW1iZXIuc2V0LlxyXG5cclxuICAgICAgLy8gVGhlIG1heGltdW0gbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIGZvciBvcGVyYXRpb25zIGludm9sdmluZyBkaXZpc2lvbi5cclxuICAgICAgREVDSU1BTF9QTEFDRVMgPSAyMCwgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWFxyXG5cclxuICAgICAgLy8gVGhlIHJvdW5kaW5nIG1vZGUgdXNlZCB3aGVuIHJvdW5kaW5nIHRvIHRoZSBhYm92ZSBkZWNpbWFsIHBsYWNlcywgYW5kIHdoZW4gdXNpbmdcclxuICAgICAgLy8gdG9FeHBvbmVudGlhbCwgdG9GaXhlZCwgdG9Gb3JtYXQgYW5kIHRvUHJlY2lzaW9uLCBhbmQgcm91bmQgKGRlZmF1bHQgdmFsdWUpLlxyXG4gICAgICAvLyBVUCAgICAgICAgIDAgQXdheSBmcm9tIHplcm8uXHJcbiAgICAgIC8vIERPV04gICAgICAgMSBUb3dhcmRzIHplcm8uXHJcbiAgICAgIC8vIENFSUwgICAgICAgMiBUb3dhcmRzICtJbmZpbml0eS5cclxuICAgICAgLy8gRkxPT1IgICAgICAzIFRvd2FyZHMgLUluZmluaXR5LlxyXG4gICAgICAvLyBIQUxGX1VQICAgIDQgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHVwLlxyXG4gICAgICAvLyBIQUxGX0RPV04gIDUgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIGRvd24uXHJcbiAgICAgIC8vIEhBTEZfRVZFTiAgNiBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG93YXJkcyBldmVuIG5laWdoYm91ci5cclxuICAgICAgLy8gSEFMRl9DRUlMICA3IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzICtJbmZpbml0eS5cclxuICAgICAgLy8gSEFMRl9GTE9PUiA4IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzIC1JbmZpbml0eS5cclxuICAgICAgUk9VTkRJTkdfTU9ERSA9IDQsICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIDhcclxuXHJcbiAgICAgIC8vIEVYUE9ORU5USUFMX0FUIDogW1RPX0VYUF9ORUcgLCBUT19FWFBfUE9TXVxyXG5cclxuICAgICAgLy8gVGhlIGV4cG9uZW50IHZhbHVlIGF0IGFuZCBiZW5lYXRoIHdoaWNoIHRvU3RyaW5nIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgIC8vIE51bWJlciB0eXBlOiAtN1xyXG4gICAgICBUT19FWFBfTkVHID0gLTcsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gLU1BWFxyXG5cclxuICAgICAgLy8gVGhlIGV4cG9uZW50IHZhbHVlIGF0IGFuZCBhYm92ZSB3aGljaCB0b1N0cmluZyByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICAvLyBOdW1iZXIgdHlwZTogMjFcclxuICAgICAgVE9fRVhQX1BPUyA9IDIxLCAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWFxyXG5cclxuICAgICAgLy8gUkFOR0UgOiBbTUlOX0VYUCwgTUFYX0VYUF1cclxuXHJcbiAgICAgIC8vIFRoZSBtaW5pbXVtIGV4cG9uZW50IHZhbHVlLCBiZW5lYXRoIHdoaWNoIHVuZGVyZmxvdyB0byB6ZXJvIG9jY3Vycy5cclxuICAgICAgLy8gTnVtYmVyIHR5cGU6IC0zMjQgICg1ZS0zMjQpXHJcbiAgICAgIE1JTl9FWFAgPSAtMWU3LCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLTEgdG8gLU1BWFxyXG5cclxuICAgICAgLy8gVGhlIG1heGltdW0gZXhwb25lbnQgdmFsdWUsIGFib3ZlIHdoaWNoIG92ZXJmbG93IHRvIEluZmluaXR5IG9jY3Vycy5cclxuICAgICAgLy8gTnVtYmVyIHR5cGU6ICAzMDggICgxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOClcclxuICAgICAgLy8gRm9yIE1BWF9FWFAgPiAxZTcsIGUuZy4gbmV3IEJpZ051bWJlcignMWUxMDAwMDAwMDAnKS5wbHVzKDEpIG1heSBiZSBzbG93LlxyXG4gICAgICBNQVhfRVhQID0gMWU3LCAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDEgdG8gTUFYXHJcblxyXG4gICAgICAvLyBXaGV0aGVyIHRvIHVzZSBjcnlwdG9ncmFwaGljYWxseS1zZWN1cmUgcmFuZG9tIG51bWJlciBnZW5lcmF0aW9uLCBpZiBhdmFpbGFibGUuXHJcbiAgICAgIENSWVBUTyA9IGZhbHNlLCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ1ZSBvciBmYWxzZVxyXG5cclxuICAgICAgLy8gVGhlIG1vZHVsbyBtb2RlIHVzZWQgd2hlbiBjYWxjdWxhdGluZyB0aGUgbW9kdWx1czogYSBtb2Qgbi5cclxuICAgICAgLy8gVGhlIHF1b3RpZW50IChxID0gYSAvIG4pIGlzIGNhbGN1bGF0ZWQgYWNjb3JkaW5nIHRvIHRoZSBjb3JyZXNwb25kaW5nIHJvdW5kaW5nIG1vZGUuXHJcbiAgICAgIC8vIFRoZSByZW1haW5kZXIgKHIpIGlzIGNhbGN1bGF0ZWQgYXM6IHIgPSBhIC0gbiAqIHEuXHJcbiAgICAgIC8vXHJcbiAgICAgIC8vIFVQICAgICAgICAwIFRoZSByZW1haW5kZXIgaXMgcG9zaXRpdmUgaWYgdGhlIGRpdmlkZW5kIGlzIG5lZ2F0aXZlLCBlbHNlIGlzIG5lZ2F0aXZlLlxyXG4gICAgICAvLyBET1dOICAgICAgMSBUaGUgcmVtYWluZGVyIGhhcyB0aGUgc2FtZSBzaWduIGFzIHRoZSBkaXZpZGVuZC5cclxuICAgICAgLy8gICAgICAgICAgICAgVGhpcyBtb2R1bG8gbW9kZSBpcyBjb21tb25seSBrbm93biBhcyAndHJ1bmNhdGVkIGRpdmlzaW9uJyBhbmQgaXNcclxuICAgICAgLy8gICAgICAgICAgICAgZXF1aXZhbGVudCB0byAoYSAlIG4pIGluIEphdmFTY3JpcHQuXHJcbiAgICAgIC8vIEZMT09SICAgICAzIFRoZSByZW1haW5kZXIgaGFzIHRoZSBzYW1lIHNpZ24gYXMgdGhlIGRpdmlzb3IgKFB5dGhvbiAlKS5cclxuICAgICAgLy8gSEFMRl9FVkVOIDYgVGhpcyBtb2R1bG8gbW9kZSBpbXBsZW1lbnRzIHRoZSBJRUVFIDc1NCByZW1haW5kZXIgZnVuY3Rpb24uXHJcbiAgICAgIC8vIEVVQ0xJRCAgICA5IEV1Y2xpZGlhbiBkaXZpc2lvbi4gcSA9IHNpZ24obikgKiBmbG9vcihhIC8gYWJzKG4pKS5cclxuICAgICAgLy8gICAgICAgICAgICAgVGhlIHJlbWFpbmRlciBpcyBhbHdheXMgcG9zaXRpdmUuXHJcbiAgICAgIC8vXHJcbiAgICAgIC8vIFRoZSB0cnVuY2F0ZWQgZGl2aXNpb24sIGZsb29yZWQgZGl2aXNpb24sIEV1Y2xpZGlhbiBkaXZpc2lvbiBhbmQgSUVFRSA3NTQgcmVtYWluZGVyXHJcbiAgICAgIC8vIG1vZGVzIGFyZSBjb21tb25seSB1c2VkIGZvciB0aGUgbW9kdWx1cyBvcGVyYXRpb24uXHJcbiAgICAgIC8vIEFsdGhvdWdoIHRoZSBvdGhlciByb3VuZGluZyBtb2RlcyBjYW4gYWxzbyBiZSB1c2VkLCB0aGV5IG1heSBub3QgZ2l2ZSB1c2VmdWwgcmVzdWx0cy5cclxuICAgICAgTU9EVUxPX01PREUgPSAxLCAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIDlcclxuXHJcbiAgICAgIC8vIFRoZSBtYXhpbXVtIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHMgb2YgdGhlIHJlc3VsdCBvZiB0aGUgZXhwb25lbnRpYXRlZEJ5IG9wZXJhdGlvbi5cclxuICAgICAgLy8gSWYgUE9XX1BSRUNJU0lPTiBpcyAwLCB0aGVyZSB3aWxsIGJlIHVubGltaXRlZCBzaWduaWZpY2FudCBkaWdpdHMuXHJcbiAgICAgIFBPV19QUkVDSVNJT04gPSAwLCAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhcclxuXHJcbiAgICAgIC8vIFRoZSBmb3JtYXQgc3BlY2lmaWNhdGlvbiB1c2VkIGJ5IHRoZSBCaWdOdW1iZXIucHJvdG90eXBlLnRvRm9ybWF0IG1ldGhvZC5cclxuICAgICAgRk9STUFUID0ge1xyXG4gICAgICAgIHByZWZpeDogJycsXHJcbiAgICAgICAgZ3JvdXBTaXplOiAzLFxyXG4gICAgICAgIHNlY29uZGFyeUdyb3VwU2l6ZTogMCxcclxuICAgICAgICBncm91cFNlcGFyYXRvcjogJywnLFxyXG4gICAgICAgIGRlY2ltYWxTZXBhcmF0b3I6ICcuJyxcclxuICAgICAgICBmcmFjdGlvbkdyb3VwU2l6ZTogMCxcclxuICAgICAgICBmcmFjdGlvbkdyb3VwU2VwYXJhdG9yOiAnXFx4QTAnLCAgICAgICAgLy8gbm9uLWJyZWFraW5nIHNwYWNlXHJcbiAgICAgICAgc3VmZml4OiAnJ1xyXG4gICAgICB9LFxyXG5cclxuICAgICAgLy8gVGhlIGFscGhhYmV0IHVzZWQgZm9yIGJhc2UgY29udmVyc2lvbi4gSXQgbXVzdCBiZSBhdCBsZWFzdCAyIGNoYXJhY3RlcnMgbG9uZywgd2l0aCBubyAnKycsXHJcbiAgICAgIC8vICctJywgJy4nLCB3aGl0ZXNwYWNlLCBvciByZXBlYXRlZCBjaGFyYWN0ZXIuXHJcbiAgICAgIC8vICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWiRfJ1xyXG4gICAgICBBTFBIQUJFVCA9ICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonLFxyXG4gICAgICBhbHBoYWJldEhhc05vcm1hbERlY2ltYWxEaWdpdHMgPSB0cnVlO1xyXG5cclxuXHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuXHJcbiAgICAvLyBDT05TVFJVQ1RPUlxyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogVGhlIEJpZ051bWJlciBjb25zdHJ1Y3RvciBhbmQgZXhwb3J0ZWQgZnVuY3Rpb24uXHJcbiAgICAgKiBDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBpbnN0YW5jZSBvZiBhIEJpZ051bWJlciBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogdiB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IEEgbnVtZXJpYyB2YWx1ZS5cclxuICAgICAqIFtiXSB7bnVtYmVyfSBUaGUgYmFzZSBvZiB2LiBJbnRlZ2VyLCAyIHRvIEFMUEhBQkVULmxlbmd0aCBpbmNsdXNpdmUuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEJpZ051bWJlcih2LCBiKSB7XHJcbiAgICAgIHZhciBhbHBoYWJldCwgYywgY2FzZUNoYW5nZWQsIGUsIGksIGlzTnVtLCBsZW4sIHN0cixcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIC8vIEVuYWJsZSBjb25zdHJ1Y3RvciBjYWxsIHdpdGhvdXQgYG5ld2AuXHJcbiAgICAgIGlmICghKHggaW5zdGFuY2VvZiBCaWdOdW1iZXIpKSByZXR1cm4gbmV3IEJpZ051bWJlcih2LCBiKTtcclxuXHJcbiAgICAgIGlmIChiID09IG51bGwpIHtcclxuXHJcbiAgICAgICAgaWYgKHYgJiYgdi5faXNCaWdOdW1iZXIgPT09IHRydWUpIHtcclxuICAgICAgICAgIHgucyA9IHYucztcclxuXHJcbiAgICAgICAgICBpZiAoIXYuYyB8fCB2LmUgPiBNQVhfRVhQKSB7XHJcbiAgICAgICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHYuZSA8IE1JTl9FWFApIHtcclxuICAgICAgICAgICAgeC5jID0gW3guZSA9IDBdO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgeC5lID0gdi5lO1xyXG4gICAgICAgICAgICB4LmMgPSB2LmMuc2xpY2UoKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoKGlzTnVtID0gdHlwZW9mIHYgPT0gJ251bWJlcicpICYmIHYgKiAwID09IDApIHtcclxuXHJcbiAgICAgICAgICAvLyBVc2UgYDEgLyBuYCB0byBoYW5kbGUgbWludXMgemVybyBhbHNvLlxyXG4gICAgICAgICAgeC5zID0gMSAvIHYgPCAwID8gKHYgPSAtdiwgLTEpIDogMTtcclxuXHJcbiAgICAgICAgICAvLyBGYXN0IHBhdGggZm9yIGludGVnZXJzLCB3aGVyZSBuIDwgMjE0NzQ4MzY0OCAoMioqMzEpLlxyXG4gICAgICAgICAgaWYgKHYgPT09IH5+dikge1xyXG4gICAgICAgICAgICBmb3IgKGUgPSAwLCBpID0gdjsgaSA+PSAxMDsgaSAvPSAxMCwgZSsrKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChlID4gTUFYX0VYUCkge1xyXG4gICAgICAgICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgeC5lID0gZTtcclxuICAgICAgICAgICAgICB4LmMgPSBbdl07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBzdHIgPSBTdHJpbmcodik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICBpZiAoIWlzTnVtZXJpYy50ZXN0KHN0ciA9IFN0cmluZyh2KSkpIHJldHVybiBwYXJzZU51bWVyaWMoeCwgc3RyLCBpc051bSk7XHJcblxyXG4gICAgICAgICAgeC5zID0gc3RyLmNoYXJDb2RlQXQoMCkgPT0gNDUgPyAoc3RyID0gc3RyLnNsaWNlKDEpLCAtMSkgOiAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRGVjaW1hbCBwb2ludD9cclxuICAgICAgICBpZiAoKGUgPSBzdHIuaW5kZXhPZignLicpKSA+IC0xKSBzdHIgPSBzdHIucmVwbGFjZSgnLicsICcnKTtcclxuXHJcbiAgICAgICAgLy8gRXhwb25lbnRpYWwgZm9ybT9cclxuICAgICAgICBpZiAoKGkgPSBzdHIuc2VhcmNoKC9lL2kpKSA+IDApIHtcclxuXHJcbiAgICAgICAgICAvLyBEZXRlcm1pbmUgZXhwb25lbnQuXHJcbiAgICAgICAgICBpZiAoZSA8IDApIGUgPSBpO1xyXG4gICAgICAgICAgZSArPSArc3RyLnNsaWNlKGkgKyAxKTtcclxuICAgICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgaSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChlIDwgMCkge1xyXG5cclxuICAgICAgICAgIC8vIEludGVnZXIuXHJcbiAgICAgICAgICBlID0gc3RyLmxlbmd0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gQmFzZSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7Yn0nXHJcbiAgICAgICAgaW50Q2hlY2soYiwgMiwgQUxQSEFCRVQubGVuZ3RoLCAnQmFzZScpO1xyXG5cclxuICAgICAgICAvLyBBbGxvdyBleHBvbmVudGlhbCBub3RhdGlvbiB0byBiZSB1c2VkIHdpdGggYmFzZSAxMCBhcmd1bWVudCwgd2hpbGVcclxuICAgICAgICAvLyBhbHNvIHJvdW5kaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFzIHdpdGggb3RoZXIgYmFzZXMuXHJcbiAgICAgICAgaWYgKGIgPT0gMTAgJiYgYWxwaGFiZXRIYXNOb3JtYWxEZWNpbWFsRGlnaXRzKSB7XHJcbiAgICAgICAgICB4ID0gbmV3IEJpZ051bWJlcih2KTtcclxuICAgICAgICAgIHJldHVybiByb3VuZCh4LCBERUNJTUFMX1BMQUNFUyArIHguZSArIDEsIFJPVU5ESU5HX01PREUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RyID0gU3RyaW5nKHYpO1xyXG5cclxuICAgICAgICBpZiAoaXNOdW0gPSB0eXBlb2YgdiA9PSAnbnVtYmVyJykge1xyXG5cclxuICAgICAgICAgIC8vIEF2b2lkIHBvdGVudGlhbCBpbnRlcnByZXRhdGlvbiBvZiBJbmZpbml0eSBhbmQgTmFOIGFzIGJhc2UgNDQrIHZhbHVlcy5cclxuICAgICAgICAgIGlmICh2ICogMCAhPSAwKSByZXR1cm4gcGFyc2VOdW1lcmljKHgsIHN0ciwgaXNOdW0sIGIpO1xyXG5cclxuICAgICAgICAgIHgucyA9IDEgLyB2IDwgMCA/IChzdHIgPSBzdHIuc2xpY2UoMSksIC0xKSA6IDE7XHJcblxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE51bWJlciBwcmltaXRpdmUgaGFzIG1vcmUgdGhhbiAxNSBzaWduaWZpY2FudCBkaWdpdHM6IHtufSdcclxuICAgICAgICAgIGlmIChCaWdOdW1iZXIuREVCVUcgJiYgc3RyLnJlcGxhY2UoL14wXFwuMCp8XFwuLywgJycpLmxlbmd0aCA+IDE1KSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAodG9vTWFueURpZ2l0cyArIHYpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4LnMgPSBzdHIuY2hhckNvZGVBdCgwKSA9PT0gNDUgPyAoc3RyID0gc3RyLnNsaWNlKDEpLCAtMSkgOiAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYWxwaGFiZXQgPSBBTFBIQUJFVC5zbGljZSgwLCBiKTtcclxuICAgICAgICBlID0gaSA9IDA7XHJcblxyXG4gICAgICAgIC8vIENoZWNrIHRoYXQgc3RyIGlzIGEgdmFsaWQgYmFzZSBiIG51bWJlci5cclxuICAgICAgICAvLyBEb24ndCB1c2UgUmVnRXhwLCBzbyBhbHBoYWJldCBjYW4gY29udGFpbiBzcGVjaWFsIGNoYXJhY3RlcnMuXHJcbiAgICAgICAgZm9yIChsZW4gPSBzdHIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgIGlmIChhbHBoYWJldC5pbmRleE9mKGMgPSBzdHIuY2hhckF0KGkpKSA8IDApIHtcclxuICAgICAgICAgICAgaWYgKGMgPT0gJy4nKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIElmICcuJyBpcyBub3QgdGhlIGZpcnN0IGNoYXJhY3RlciBhbmQgaXQgaGFzIG5vdCBiZSBmb3VuZCBiZWZvcmUuXHJcbiAgICAgICAgICAgICAgaWYgKGkgPiBlKSB7XHJcbiAgICAgICAgICAgICAgICBlID0gbGVuO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFjYXNlQ2hhbmdlZCkge1xyXG5cclxuICAgICAgICAgICAgICAvLyBBbGxvdyBlLmcuIGhleGFkZWNpbWFsICdGRicgYXMgd2VsbCBhcyAnZmYnLlxyXG4gICAgICAgICAgICAgIGlmIChzdHIgPT0gc3RyLnRvVXBwZXJDYXNlKCkgJiYgKHN0ciA9IHN0ci50b0xvd2VyQ2FzZSgpKSB8fFxyXG4gICAgICAgICAgICAgICAgICBzdHIgPT0gc3RyLnRvTG93ZXJDYXNlKCkgJiYgKHN0ciA9IHN0ci50b1VwcGVyQ2FzZSgpKSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZUNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaSA9IC0xO1xyXG4gICAgICAgICAgICAgICAgZSA9IDA7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZU51bWVyaWMoeCwgU3RyaW5nKHYpLCBpc051bSwgYik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBQcmV2ZW50IGxhdGVyIGNoZWNrIGZvciBsZW5ndGggb24gY29udmVydGVkIG51bWJlci5cclxuICAgICAgICBpc051bSA9IGZhbHNlO1xyXG4gICAgICAgIHN0ciA9IGNvbnZlcnRCYXNlKHN0ciwgYiwgMTAsIHgucyk7XHJcblxyXG4gICAgICAgIC8vIERlY2ltYWwgcG9pbnQ/XHJcbiAgICAgICAgaWYgKChlID0gc3RyLmluZGV4T2YoJy4nKSkgPiAtMSkgc3RyID0gc3RyLnJlcGxhY2UoJy4nLCAnJyk7XHJcbiAgICAgICAgZWxzZSBlID0gc3RyLmxlbmd0aDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgIGZvciAoaSA9IDA7IHN0ci5jaGFyQ29kZUF0KGkpID09PSA0ODsgaSsrKTtcclxuXHJcbiAgICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgZm9yIChsZW4gPSBzdHIubGVuZ3RoOyBzdHIuY2hhckNvZGVBdCgtLWxlbikgPT09IDQ4Oyk7XHJcblxyXG4gICAgICBpZiAoc3RyID0gc3RyLnNsaWNlKGksICsrbGVuKSkge1xyXG4gICAgICAgIGxlbiAtPSBpO1xyXG5cclxuICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTnVtYmVyIHByaW1pdGl2ZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czoge259J1xyXG4gICAgICAgIGlmIChpc051bSAmJiBCaWdOdW1iZXIuREVCVUcgJiZcclxuICAgICAgICAgIGxlbiA+IDE1ICYmICh2ID4gTUFYX1NBRkVfSU5URUdFUiB8fCB2ICE9PSBtYXRoZmxvb3IodikpKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAodG9vTWFueURpZ2l0cyArICh4LnMgKiB2KSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAgLy8gT3ZlcmZsb3c/XHJcbiAgICAgICAgaWYgKChlID0gZSAtIGkgLSAxKSA+IE1BWF9FWFApIHtcclxuXHJcbiAgICAgICAgICAvLyBJbmZpbml0eS5cclxuICAgICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcblxyXG4gICAgICAgIC8vIFVuZGVyZmxvdz9cclxuICAgICAgICB9IGVsc2UgaWYgKGUgPCBNSU5fRVhQKSB7XHJcblxyXG4gICAgICAgICAgLy8gWmVyby5cclxuICAgICAgICAgIHguYyA9IFt4LmUgPSAwXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeC5lID0gZTtcclxuICAgICAgICAgIHguYyA9IFtdO1xyXG5cclxuICAgICAgICAgIC8vIFRyYW5zZm9ybSBiYXNlXHJcblxyXG4gICAgICAgICAgLy8gZSBpcyB0aGUgYmFzZSAxMCBleHBvbmVudC5cclxuICAgICAgICAgIC8vIGkgaXMgd2hlcmUgdG8gc2xpY2Ugc3RyIHRvIGdldCB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgY29lZmZpY2llbnQgYXJyYXkuXHJcbiAgICAgICAgICBpID0gKGUgKyAxKSAlIExPR19CQVNFO1xyXG4gICAgICAgICAgaWYgKGUgPCAwKSBpICs9IExPR19CQVNFOyAgLy8gaSA8IDFcclxuXHJcbiAgICAgICAgICBpZiAoaSA8IGxlbikge1xyXG4gICAgICAgICAgICBpZiAoaSkgeC5jLnB1c2goK3N0ci5zbGljZSgwLCBpKSk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGxlbiAtPSBMT0dfQkFTRTsgaSA8IGxlbjspIHtcclxuICAgICAgICAgICAgICB4LmMucHVzaCgrc3RyLnNsaWNlKGksIGkgKz0gTE9HX0JBU0UpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaSA9IExPR19CQVNFIC0gKHN0ciA9IHN0ci5zbGljZShpKSkubGVuZ3RoO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaSAtPSBsZW47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZm9yICg7IGktLTsgc3RyICs9ICcwJyk7XHJcbiAgICAgICAgICB4LmMucHVzaCgrc3RyKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgeC5jID0gW3guZSA9IDBdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIENPTlNUUlVDVE9SIFBST1BFUlRJRVNcclxuXHJcblxyXG4gICAgQmlnTnVtYmVyLmNsb25lID0gY2xvbmU7XHJcblxyXG4gICAgQmlnTnVtYmVyLlJPVU5EX1VQID0gMDtcclxuICAgIEJpZ051bWJlci5ST1VORF9ET1dOID0gMTtcclxuICAgIEJpZ051bWJlci5ST1VORF9DRUlMID0gMjtcclxuICAgIEJpZ051bWJlci5ST1VORF9GTE9PUiA9IDM7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9VUCA9IDQ7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9ET1dOID0gNTtcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX0VWRU4gPSA2O1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfQ0VJTCA9IDc7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9GTE9PUiA9IDg7XHJcbiAgICBCaWdOdW1iZXIuRVVDTElEID0gOTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIENvbmZpZ3VyZSBpbmZyZXF1ZW50bHktY2hhbmdpbmcgbGlicmFyeS13aWRlIHNldHRpbmdzLlxyXG4gICAgICpcclxuICAgICAqIEFjY2VwdCBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIG9wdGlvbmFsIHByb3BlcnRpZXMgKGlmIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5IGlzXHJcbiAgICAgKiBhIG51bWJlciwgaXQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdpdGhpbiB0aGUgaW5jbHVzaXZlIHJhbmdlIHN0YXRlZCk6XHJcbiAgICAgKlxyXG4gICAgICogICBERUNJTUFMX1BMQUNFUyAgIHtudW1iZXJ9ICAgICAgICAgICAwIHRvIE1BWFxyXG4gICAgICogICBST1VORElOR19NT0RFICAgIHtudW1iZXJ9ICAgICAgICAgICAwIHRvIDhcclxuICAgICAqICAgRVhQT05FTlRJQUxfQVQgICB7bnVtYmVyfG51bWJlcltdfSAgLU1BWCB0byBNQVggIG9yICBbLU1BWCB0byAwLCAwIHRvIE1BWF1cclxuICAgICAqICAgUkFOR0UgICAgICAgICAgICB7bnVtYmVyfG51bWJlcltdfSAgLU1BWCB0byBNQVggKG5vdCB6ZXJvKSAgb3IgIFstTUFYIHRvIC0xLCAxIHRvIE1BWF1cclxuICAgICAqICAgQ1JZUFRPICAgICAgICAgICB7Ym9vbGVhbn0gICAgICAgICAgdHJ1ZSBvciBmYWxzZVxyXG4gICAgICogICBNT0RVTE9fTU9ERSAgICAgIHtudW1iZXJ9ICAgICAgICAgICAwIHRvIDlcclxuICAgICAqICAgUE9XX1BSRUNJU0lPTiAgICAgICB7bnVtYmVyfSAgICAgICAgICAgMCB0byBNQVhcclxuICAgICAqICAgQUxQSEFCRVQgICAgICAgICB7c3RyaW5nfSAgICAgICAgICAgQSBzdHJpbmcgb2YgdHdvIG9yIG1vcmUgdW5pcXVlIGNoYXJhY3RlcnMgd2hpY2ggZG9lc1xyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3QgY29udGFpbiAnLicuXHJcbiAgICAgKiAgIEZPUk1BVCAgICAgICAgICAge29iamVjdH0gICAgICAgICAgIEFuIG9iamVjdCB3aXRoIHNvbWUgb2YgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxyXG4gICAgICogICAgIHByZWZpeCAgICAgICAgICAgICAgICAge3N0cmluZ31cclxuICAgICAqICAgICBncm91cFNpemUgICAgICAgICAgICAgIHtudW1iZXJ9XHJcbiAgICAgKiAgICAgc2Vjb25kYXJ5R3JvdXBTaXplICAgICB7bnVtYmVyfVxyXG4gICAgICogICAgIGdyb3VwU2VwYXJhdG9yICAgICAgICAge3N0cmluZ31cclxuICAgICAqICAgICBkZWNpbWFsU2VwYXJhdG9yICAgICAgIHtzdHJpbmd9XHJcbiAgICAgKiAgICAgZnJhY3Rpb25Hcm91cFNpemUgICAgICB7bnVtYmVyfVxyXG4gICAgICogICAgIGZyYWN0aW9uR3JvdXBTZXBhcmF0b3Ige3N0cmluZ31cclxuICAgICAqICAgICBzdWZmaXggICAgICAgICAgICAgICAgIHtzdHJpbmd9XHJcbiAgICAgKlxyXG4gICAgICogKFRoZSB2YWx1ZXMgYXNzaWduZWQgdG8gdGhlIGFib3ZlIEZPUk1BVCBvYmplY3QgcHJvcGVydGllcyBhcmUgbm90IGNoZWNrZWQgZm9yIHZhbGlkaXR5LilcclxuICAgICAqXHJcbiAgICAgKiBFLmcuXHJcbiAgICAgKiBCaWdOdW1iZXIuY29uZmlnKHsgREVDSU1BTF9QTEFDRVMgOiAyMCwgUk9VTkRJTkdfTU9ERSA6IDQgfSlcclxuICAgICAqXHJcbiAgICAgKiBJZ25vcmUgcHJvcGVydGllcy9wYXJhbWV0ZXJzIHNldCB0byBudWxsIG9yIHVuZGVmaW5lZCwgZXhjZXB0IGZvciBBTFBIQUJFVC5cclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYW4gb2JqZWN0IHdpdGggdGhlIHByb3BlcnRpZXMgY3VycmVudCB2YWx1ZXMuXHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5jb25maWcgPSBCaWdOdW1iZXIuc2V0ID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICB2YXIgcCwgdjtcclxuXHJcbiAgICAgIGlmIChvYmogIT0gbnVsbCkge1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIG9iaiA9PSAnb2JqZWN0Jykge1xyXG5cclxuICAgICAgICAgIC8vIERFQ0lNQUxfUExBQ0VTIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBERUNJTUFMX1BMQUNFUyB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnREVDSU1BTF9QTEFDRVMnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2LCAwLCBNQVgsIHApO1xyXG4gICAgICAgICAgICBERUNJTUFMX1BMQUNFUyA9IHY7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUk9VTkRJTkdfTU9ERSB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIFJPVU5ESU5HX01PREUge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ1JPVU5ESU5HX01PREUnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2LCAwLCA4LCBwKTtcclxuICAgICAgICAgICAgUk9VTkRJTkdfTU9ERSA9IHY7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gRVhQT05FTlRJQUxfQVQge251bWJlcnxudW1iZXJbXX1cclxuICAgICAgICAgIC8vIEludGVnZXIsIC1NQVggdG8gTUFYIGluY2x1c2l2ZSBvclxyXG4gICAgICAgICAgLy8gW2ludGVnZXIgLU1BWCB0byAwIGluY2x1c2l2ZSwgMCB0byBNQVggaW5jbHVzaXZlXS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBFWFBPTkVOVElBTF9BVCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnRVhQT05FTlRJQUxfQVQnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpZiAodiAmJiB2LnBvcCkge1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHZbMF0sIC1NQVgsIDAsIHApO1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHZbMV0sIDAsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgICAgVE9fRVhQX05FRyA9IHZbMF07XHJcbiAgICAgICAgICAgICAgVE9fRVhQX1BPUyA9IHZbMV07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodiwgLU1BWCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgICBUT19FWFBfTkVHID0gLShUT19FWFBfUE9TID0gdiA8IDAgPyAtdiA6IHYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUkFOR0Uge251bWJlcnxudW1iZXJbXX0gTm9uLXplcm8gaW50ZWdlciwgLU1BWCB0byBNQVggaW5jbHVzaXZlIG9yXHJcbiAgICAgICAgICAvLyBbaW50ZWdlciAtTUFYIHRvIC0xIGluY2x1c2l2ZSwgaW50ZWdlciAxIHRvIE1BWCBpbmNsdXNpdmVdLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIFJBTkdFIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZXxjYW5ub3QgYmUgemVyb306IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdSQU5HRScpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGlmICh2ICYmIHYucG9wKSB7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodlswXSwgLU1BWCwgLTEsIHApO1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHZbMV0sIDEsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgICAgTUlOX0VYUCA9IHZbMF07XHJcbiAgICAgICAgICAgICAgTUFYX0VYUCA9IHZbMV07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodiwgLU1BWCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgICBpZiAodikge1xyXG4gICAgICAgICAgICAgICAgTUlOX0VYUCA9IC0oTUFYX0VYUCA9IHYgPCAwID8gLXYgOiB2KTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyBwICsgJyBjYW5ub3QgYmUgemVybzogJyArIHYpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIENSWVBUTyB7Ym9vbGVhbn0gdHJ1ZSBvciBmYWxzZS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBDUllQVE8gbm90IHRydWUgb3IgZmFsc2U6IHt2fSdcclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBjcnlwdG8gdW5hdmFpbGFibGUnXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnQ1JZUFRPJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaWYgKHYgPT09ICEhdikge1xyXG4gICAgICAgICAgICAgIGlmICh2KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNyeXB0byAhPSAndW5kZWZpbmVkJyAmJiBjcnlwdG8gJiZcclxuICAgICAgICAgICAgICAgICAoY3J5cHRvLmdldFJhbmRvbVZhbHVlcyB8fCBjcnlwdG8ucmFuZG9tQnl0ZXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgIENSWVBUTyA9IHY7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICBDUllQVE8gPSAhdjtcclxuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdjcnlwdG8gdW5hdmFpbGFibGUnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgQ1JZUFRPID0gdjtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgbm90IHRydWUgb3IgZmFsc2U6ICcgKyB2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIE1PRFVMT19NT0RFIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gOSBpbmNsdXNpdmUuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTU9EVUxPX01PREUge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ01PRFVMT19NT0RFJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaW50Q2hlY2sodiwgMCwgOSwgcCk7XHJcbiAgICAgICAgICAgIE1PRFVMT19NT0RFID0gdjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBQT1dfUFJFQ0lTSU9OIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBQT1dfUFJFQ0lTSU9OIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdQT1dfUFJFQ0lTSU9OJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaW50Q2hlY2sodiwgMCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgUE9XX1BSRUNJU0lPTiA9IHY7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gRk9STUFUIHtvYmplY3R9XHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gRk9STUFUIG5vdCBhbiBvYmplY3Q6IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdGT1JNQVQnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHYgPT0gJ29iamVjdCcpIEZPUk1BVCA9IHY7XHJcbiAgICAgICAgICAgIGVsc2UgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArIHAgKyAnIG5vdCBhbiBvYmplY3Q6ICcgKyB2KTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBBTFBIQUJFVCB7c3RyaW5nfVxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIEFMUEhBQkVUIGludmFsaWQ6IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdBTFBIQUJFVCcpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcblxyXG4gICAgICAgICAgICAvLyBEaXNhbGxvdyBpZiBsZXNzIHRoYW4gdHdvIGNoYXJhY3RlcnMsXHJcbiAgICAgICAgICAgIC8vIG9yIGlmIGl0IGNvbnRhaW5zICcrJywgJy0nLCAnLicsIHdoaXRlc3BhY2UsIG9yIGEgcmVwZWF0ZWQgY2hhcmFjdGVyLlxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHYgPT0gJ3N0cmluZycgJiYgIS9eLj8kfFsrXFwtLlxcc118KC4pLipcXDEvLnRlc3QodikpIHtcclxuICAgICAgICAgICAgICBhbHBoYWJldEhhc05vcm1hbERlY2ltYWxEaWdpdHMgPSB2LnNsaWNlKDAsIDEwKSA9PSAnMDEyMzQ1Njc4OSc7XHJcbiAgICAgICAgICAgICAgQUxQSEFCRVQgPSB2O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArIHAgKyAnIGludmFsaWQ6ICcgKyB2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBPYmplY3QgZXhwZWN0ZWQ6IHt2fSdcclxuICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ09iamVjdCBleHBlY3RlZDogJyArIG9iaik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIERFQ0lNQUxfUExBQ0VTOiBERUNJTUFMX1BMQUNFUyxcclxuICAgICAgICBST1VORElOR19NT0RFOiBST1VORElOR19NT0RFLFxyXG4gICAgICAgIEVYUE9ORU5USUFMX0FUOiBbVE9fRVhQX05FRywgVE9fRVhQX1BPU10sXHJcbiAgICAgICAgUkFOR0U6IFtNSU5fRVhQLCBNQVhfRVhQXSxcclxuICAgICAgICBDUllQVE86IENSWVBUTyxcclxuICAgICAgICBNT0RVTE9fTU9ERTogTU9EVUxPX01PREUsXHJcbiAgICAgICAgUE9XX1BSRUNJU0lPTjogUE9XX1BSRUNJU0lPTixcclxuICAgICAgICBGT1JNQVQ6IEZPUk1BVCxcclxuICAgICAgICBBTFBIQUJFVDogQUxQSEFCRVRcclxuICAgICAgfTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB2IGlzIGEgQmlnTnVtYmVyIGluc3RhbmNlLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICpcclxuICAgICAqIElmIEJpZ051bWJlci5ERUJVRyBpcyB0cnVlLCB0aHJvdyBpZiBhIEJpZ051bWJlciBpbnN0YW5jZSBpcyBub3Qgd2VsbC1mb3JtZWQuXHJcbiAgICAgKlxyXG4gICAgICogdiB7YW55fVxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBJbnZhbGlkIEJpZ051bWJlcjoge3Z9J1xyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIuaXNCaWdOdW1iZXIgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICBpZiAoIXYgfHwgdi5faXNCaWdOdW1iZXIgIT09IHRydWUpIHJldHVybiBmYWxzZTtcclxuICAgICAgaWYgKCFCaWdOdW1iZXIuREVCVUcpIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgdmFyIGksIG4sXHJcbiAgICAgICAgYyA9IHYuYyxcclxuICAgICAgICBlID0gdi5lLFxyXG4gICAgICAgIHMgPSB2LnM7XHJcblxyXG4gICAgICBvdXQ6IGlmICh7fS50b1N0cmluZy5jYWxsKGMpID09ICdbb2JqZWN0IEFycmF5XScpIHtcclxuXHJcbiAgICAgICAgaWYgKChzID09PSAxIHx8IHMgPT09IC0xKSAmJiBlID49IC1NQVggJiYgZSA8PSBNQVggJiYgZSA9PT0gbWF0aGZsb29yKGUpKSB7XHJcblxyXG4gICAgICAgICAgLy8gSWYgdGhlIGZpcnN0IGVsZW1lbnQgaXMgemVybywgdGhlIEJpZ051bWJlciB2YWx1ZSBtdXN0IGJlIHplcm8uXHJcbiAgICAgICAgICBpZiAoY1swXSA9PT0gMCkge1xyXG4gICAgICAgICAgICBpZiAoZSA9PT0gMCAmJiBjLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIGJyZWFrIG91dDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBDYWxjdWxhdGUgbnVtYmVyIG9mIGRpZ2l0cyB0aGF0IGNbMF0gc2hvdWxkIGhhdmUsIGJhc2VkIG9uIHRoZSBleHBvbmVudC5cclxuICAgICAgICAgIGkgPSAoZSArIDEpICUgTE9HX0JBU0U7XHJcbiAgICAgICAgICBpZiAoaSA8IDEpIGkgKz0gTE9HX0JBU0U7XHJcblxyXG4gICAgICAgICAgLy8gQ2FsY3VsYXRlIG51bWJlciBvZiBkaWdpdHMgb2YgY1swXS5cclxuICAgICAgICAgIC8vaWYgKE1hdGguY2VpbChNYXRoLmxvZyhjWzBdICsgMSkgLyBNYXRoLkxOMTApID09IGkpIHtcclxuICAgICAgICAgIGlmIChTdHJpbmcoY1swXSkubGVuZ3RoID09IGkpIHtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgbiA9IGNbaV07XHJcbiAgICAgICAgICAgICAgaWYgKG4gPCAwIHx8IG4gPj0gQkFTRSB8fCBuICE9PSBtYXRoZmxvb3IobikpIGJyZWFrIG91dDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTGFzdCBlbGVtZW50IGNhbm5vdCBiZSB6ZXJvLCB1bmxlc3MgaXQgaXMgdGhlIG9ubHkgZWxlbWVudC5cclxuICAgICAgICAgICAgaWYgKG4gIT09IDApIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIC8vIEluZmluaXR5L05hTlxyXG4gICAgICB9IGVsc2UgaWYgKGMgPT09IG51bGwgJiYgZSA9PT0gbnVsbCAmJiAocyA9PT0gbnVsbCB8fCBzID09PSAxIHx8IHMgPT09IC0xKSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgIChiaWdudW1iZXJFcnJvciArICdJbnZhbGlkIEJpZ051bWJlcjogJyArIHYpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIG1heGltdW0gb2YgdGhlIGFyZ3VtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIubWF4aW11bSA9IEJpZ051bWJlci5tYXggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBtYXhPck1pbihhcmd1bWVudHMsIFAubHQpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIG1pbmltdW0gb2YgdGhlIGFyZ3VtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIubWluaW11bSA9IEJpZ051bWJlci5taW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBtYXhPck1pbihhcmd1bWVudHMsIFAuZ3QpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2l0aCBhIHJhbmRvbSB2YWx1ZSBlcXVhbCB0byBvciBncmVhdGVyIHRoYW4gMCBhbmQgbGVzcyB0aGFuIDEsXHJcbiAgICAgKiBhbmQgd2l0aCBkcCwgb3IgREVDSU1BTF9QTEFDRVMgaWYgZHAgaXMgb21pdHRlZCwgZGVjaW1hbCBwbGFjZXMgKG9yIGxlc3MgaWYgdHJhaWxpbmdcclxuICAgICAqIHplcm9zIGFyZSBwcm9kdWNlZCkuXHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB9J1xyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIGNyeXB0byB1bmF2YWlsYWJsZSdcclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLnJhbmRvbSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBwb3cyXzUzID0gMHgyMDAwMDAwMDAwMDAwMDtcclxuXHJcbiAgICAgIC8vIFJldHVybiBhIDUzIGJpdCBpbnRlZ2VyIG4sIHdoZXJlIDAgPD0gbiA8IDkwMDcxOTkyNTQ3NDA5OTIuXHJcbiAgICAgIC8vIENoZWNrIGlmIE1hdGgucmFuZG9tKCkgcHJvZHVjZXMgbW9yZSB0aGFuIDMyIGJpdHMgb2YgcmFuZG9tbmVzcy5cclxuICAgICAgLy8gSWYgaXQgZG9lcywgYXNzdW1lIGF0IGxlYXN0IDUzIGJpdHMgYXJlIHByb2R1Y2VkLCBvdGhlcndpc2UgYXNzdW1lIGF0IGxlYXN0IDMwIGJpdHMuXHJcbiAgICAgIC8vIDB4NDAwMDAwMDAgaXMgMl4zMCwgMHg4MDAwMDAgaXMgMl4yMywgMHgxZmZmZmYgaXMgMl4yMSAtIDEuXHJcbiAgICAgIHZhciByYW5kb201M2JpdEludCA9IChNYXRoLnJhbmRvbSgpICogcG93Ml81MykgJiAweDFmZmZmZlxyXG4gICAgICAgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBtYXRoZmxvb3IoTWF0aC5yYW5kb20oKSAqIHBvdzJfNTMpOyB9XHJcbiAgICAgICA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICgoTWF0aC5yYW5kb20oKSAqIDB4NDAwMDAwMDAgfCAwKSAqIDB4ODAwMDAwKSArXHJcbiAgICAgICAgIChNYXRoLnJhbmRvbSgpICogMHg4MDAwMDAgfCAwKTsgfTtcclxuXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZHApIHtcclxuICAgICAgICB2YXIgYSwgYiwgZSwgaywgdixcclxuICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgYyA9IFtdLFxyXG4gICAgICAgICAgcmFuZCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuXHJcbiAgICAgICAgaWYgKGRwID09IG51bGwpIGRwID0gREVDSU1BTF9QTEFDRVM7XHJcbiAgICAgICAgZWxzZSBpbnRDaGVjayhkcCwgMCwgTUFYKTtcclxuXHJcbiAgICAgICAgayA9IG1hdGhjZWlsKGRwIC8gTE9HX0JBU0UpO1xyXG5cclxuICAgICAgICBpZiAoQ1JZUFRPKSB7XHJcblxyXG4gICAgICAgICAgLy8gQnJvd3NlcnMgc3VwcG9ydGluZyBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLlxyXG4gICAgICAgICAgaWYgKGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcclxuXHJcbiAgICAgICAgICAgIGEgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheShrICo9IDIpKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoOyBpIDwgazspIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gNTMgYml0czpcclxuICAgICAgICAgICAgICAvLyAoKE1hdGgucG93KDIsIDMyKSAtIDEpICogTWF0aC5wb3coMiwgMjEpKS50b1N0cmluZygyKVxyXG4gICAgICAgICAgICAgIC8vIDExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExIDExMTAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwXHJcbiAgICAgICAgICAgICAgLy8gKChNYXRoLnBvdygyLCAzMikgLSAxKSA+Pj4gMTEpLnRvU3RyaW5nKDIpXHJcbiAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTExMTEgMTExMTExMTEgMTExMTExMTFcclxuICAgICAgICAgICAgICAvLyAweDIwMDAwIGlzIDJeMjEuXHJcbiAgICAgICAgICAgICAgdiA9IGFbaV0gKiAweDIwMDAwICsgKGFbaSArIDFdID4+PiAxMSk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIFJlamVjdGlvbiBzYW1wbGluZzpcclxuICAgICAgICAgICAgICAvLyAwIDw9IHYgPCA5MDA3MTk5MjU0NzQwOTkyXHJcbiAgICAgICAgICAgICAgLy8gUHJvYmFiaWxpdHkgdGhhdCB2ID49IDllMTUsIGlzXHJcbiAgICAgICAgICAgICAgLy8gNzE5OTI1NDc0MDk5MiAvIDkwMDcxOTkyNTQ3NDA5OTIgfj0gMC4wMDA4LCBpLmUuIDEgaW4gMTI1MVxyXG4gICAgICAgICAgICAgIGlmICh2ID49IDllMTUpIHtcclxuICAgICAgICAgICAgICAgIGIgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheSgyKSk7XHJcbiAgICAgICAgICAgICAgICBhW2ldID0gYlswXTtcclxuICAgICAgICAgICAgICAgIGFbaSArIDFdID0gYlsxXTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIDAgPD0gdiA8PSA4OTk5OTk5OTk5OTk5OTk5XHJcbiAgICAgICAgICAgICAgICAvLyAwIDw9ICh2ICUgMWUxNCkgPD0gOTk5OTk5OTk5OTk5OTlcclxuICAgICAgICAgICAgICAgIGMucHVzaCh2ICUgMWUxNCk7XHJcbiAgICAgICAgICAgICAgICBpICs9IDI7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGkgPSBrIC8gMjtcclxuXHJcbiAgICAgICAgICAvLyBOb2RlLmpzIHN1cHBvcnRpbmcgY3J5cHRvLnJhbmRvbUJ5dGVzLlxyXG4gICAgICAgICAgfSBlbHNlIGlmIChjcnlwdG8ucmFuZG9tQnl0ZXMpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIGJ1ZmZlclxyXG4gICAgICAgICAgICBhID0gY3J5cHRvLnJhbmRvbUJ5dGVzKGsgKj0gNyk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKDsgaSA8IGs7KSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIDB4MTAwMDAwMDAwMDAwMCBpcyAyXjQ4LCAweDEwMDAwMDAwMDAwIGlzIDJeNDBcclxuICAgICAgICAgICAgICAvLyAweDEwMDAwMDAwMCBpcyAyXjMyLCAweDEwMDAwMDAgaXMgMl4yNFxyXG4gICAgICAgICAgICAgIC8vIDExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExXHJcbiAgICAgICAgICAgICAgLy8gMCA8PSB2IDwgOTAwNzE5OTI1NDc0MDk5MlxyXG4gICAgICAgICAgICAgIHYgPSAoKGFbaV0gJiAzMSkgKiAweDEwMDAwMDAwMDAwMDApICsgKGFbaSArIDFdICogMHgxMDAwMDAwMDAwMCkgK1xyXG4gICAgICAgICAgICAgICAgIChhW2kgKyAyXSAqIDB4MTAwMDAwMDAwKSArIChhW2kgKyAzXSAqIDB4MTAwMDAwMCkgK1xyXG4gICAgICAgICAgICAgICAgIChhW2kgKyA0XSA8PCAxNikgKyAoYVtpICsgNV0gPDwgOCkgKyBhW2kgKyA2XTtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKHYgPj0gOWUxNSkge1xyXG4gICAgICAgICAgICAgICAgY3J5cHRvLnJhbmRvbUJ5dGVzKDcpLmNvcHkoYSwgaSk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAwIDw9ICh2ICUgMWUxNCkgPD0gOTk5OTk5OTk5OTk5OTlcclxuICAgICAgICAgICAgICAgIGMucHVzaCh2ICUgMWUxNCk7XHJcbiAgICAgICAgICAgICAgICBpICs9IDc7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGkgPSBrIC8gNztcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIENSWVBUTyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ2NyeXB0byB1bmF2YWlsYWJsZScpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVXNlIE1hdGgucmFuZG9tLlxyXG4gICAgICAgIGlmICghQ1JZUFRPKSB7XHJcblxyXG4gICAgICAgICAgZm9yICg7IGkgPCBrOykge1xyXG4gICAgICAgICAgICB2ID0gcmFuZG9tNTNiaXRJbnQoKTtcclxuICAgICAgICAgICAgaWYgKHYgPCA5ZTE1KSBjW2krK10gPSB2ICUgMWUxNDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGsgPSBjWy0taV07XHJcbiAgICAgICAgZHAgJT0gTE9HX0JBU0U7XHJcblxyXG4gICAgICAgIC8vIENvbnZlcnQgdHJhaWxpbmcgZGlnaXRzIHRvIHplcm9zIGFjY29yZGluZyB0byBkcC5cclxuICAgICAgICBpZiAoayAmJiBkcCkge1xyXG4gICAgICAgICAgdiA9IFBPV1NfVEVOW0xPR19CQVNFIC0gZHBdO1xyXG4gICAgICAgICAgY1tpXSA9IG1hdGhmbG9vcihrIC8gdikgKiB2O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIGVsZW1lbnRzIHdoaWNoIGFyZSB6ZXJvLlxyXG4gICAgICAgIGZvciAoOyBjW2ldID09PSAwOyBjLnBvcCgpLCBpLS0pO1xyXG5cclxuICAgICAgICAvLyBaZXJvP1xyXG4gICAgICAgIGlmIChpIDwgMCkge1xyXG4gICAgICAgICAgYyA9IFtlID0gMF07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAvLyBSZW1vdmUgbGVhZGluZyBlbGVtZW50cyB3aGljaCBhcmUgemVybyBhbmQgYWRqdXN0IGV4cG9uZW50IGFjY29yZGluZ2x5LlxyXG4gICAgICAgICAgZm9yIChlID0gLTEgOyBjWzBdID09PSAwOyBjLnNwbGljZSgwLCAxKSwgZSAtPSBMT0dfQkFTRSk7XHJcblxyXG4gICAgICAgICAgLy8gQ291bnQgdGhlIGRpZ2l0cyBvZiB0aGUgZmlyc3QgZWxlbWVudCBvZiBjIHRvIGRldGVybWluZSBsZWFkaW5nIHplcm9zLCBhbmQuLi5cclxuICAgICAgICAgIGZvciAoaSA9IDEsIHYgPSBjWzBdOyB2ID49IDEwOyB2IC89IDEwLCBpKyspO1xyXG5cclxuICAgICAgICAgIC8vIGFkanVzdCB0aGUgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgICAgICAgICBpZiAoaSA8IExPR19CQVNFKSBlIC09IExPR19CQVNFIC0gaTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJhbmQuZSA9IGU7XHJcbiAgICAgICAgcmFuZC5jID0gYztcclxuICAgICAgICByZXR1cm4gcmFuZDtcclxuICAgICAgfTtcclxuICAgIH0pKCk7XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHN1bSBvZiB0aGUgYXJndW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5zdW0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBpID0gMSxcclxuICAgICAgICBhcmdzID0gYXJndW1lbnRzLFxyXG4gICAgICAgIHN1bSA9IG5ldyBCaWdOdW1iZXIoYXJnc1swXSk7XHJcbiAgICAgIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7KSBzdW0gPSBzdW0ucGx1cyhhcmdzW2krK10pO1xyXG4gICAgICByZXR1cm4gc3VtO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLy8gUFJJVkFURSBGVU5DVElPTlNcclxuXHJcblxyXG4gICAgLy8gQ2FsbGVkIGJ5IEJpZ051bWJlciBhbmQgQmlnTnVtYmVyLnByb3RvdHlwZS50b1N0cmluZy5cclxuICAgIGNvbnZlcnRCYXNlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGRlY2ltYWwgPSAnMDEyMzQ1Njc4OSc7XHJcblxyXG4gICAgICAvKlxyXG4gICAgICAgKiBDb252ZXJ0IHN0cmluZyBvZiBiYXNlSW4gdG8gYW4gYXJyYXkgb2YgbnVtYmVycyBvZiBiYXNlT3V0LlxyXG4gICAgICAgKiBFZy4gdG9CYXNlT3V0KCcyNTUnLCAxMCwgMTYpIHJldHVybnMgWzE1LCAxNV0uXHJcbiAgICAgICAqIEVnLiB0b0Jhc2VPdXQoJ2ZmJywgMTYsIDEwKSByZXR1cm5zIFsyLCA1LCA1XS5cclxuICAgICAgICovXHJcbiAgICAgIGZ1bmN0aW9uIHRvQmFzZU91dChzdHIsIGJhc2VJbiwgYmFzZU91dCwgYWxwaGFiZXQpIHtcclxuICAgICAgICB2YXIgaixcclxuICAgICAgICAgIGFyciA9IFswXSxcclxuICAgICAgICAgIGFyckwsXHJcbiAgICAgICAgICBpID0gMCxcclxuICAgICAgICAgIGxlbiA9IHN0ci5sZW5ndGg7XHJcblxyXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOykge1xyXG4gICAgICAgICAgZm9yIChhcnJMID0gYXJyLmxlbmd0aDsgYXJyTC0tOyBhcnJbYXJyTF0gKj0gYmFzZUluKTtcclxuXHJcbiAgICAgICAgICBhcnJbMF0gKz0gYWxwaGFiZXQuaW5kZXhPZihzdHIuY2hhckF0KGkrKykpO1xyXG5cclxuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBhcnIubGVuZ3RoOyBqKyspIHtcclxuXHJcbiAgICAgICAgICAgIGlmIChhcnJbal0gPiBiYXNlT3V0IC0gMSkge1xyXG4gICAgICAgICAgICAgIGlmIChhcnJbaiArIDFdID09IG51bGwpIGFycltqICsgMV0gPSAwO1xyXG4gICAgICAgICAgICAgIGFycltqICsgMV0gKz0gYXJyW2pdIC8gYmFzZU91dCB8IDA7XHJcbiAgICAgICAgICAgICAgYXJyW2pdICU9IGJhc2VPdXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBhcnIucmV2ZXJzZSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDb252ZXJ0IGEgbnVtZXJpYyBzdHJpbmcgb2YgYmFzZUluIHRvIGEgbnVtZXJpYyBzdHJpbmcgb2YgYmFzZU91dC5cclxuICAgICAgLy8gSWYgdGhlIGNhbGxlciBpcyB0b1N0cmluZywgd2UgYXJlIGNvbnZlcnRpbmcgZnJvbSBiYXNlIDEwIHRvIGJhc2VPdXQuXHJcbiAgICAgIC8vIElmIHRoZSBjYWxsZXIgaXMgQmlnTnVtYmVyLCB3ZSBhcmUgY29udmVydGluZyBmcm9tIGJhc2VJbiB0byBiYXNlIDEwLlxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHN0ciwgYmFzZUluLCBiYXNlT3V0LCBzaWduLCBjYWxsZXJJc1RvU3RyaW5nKSB7XHJcbiAgICAgICAgdmFyIGFscGhhYmV0LCBkLCBlLCBrLCByLCB4LCB4YywgeSxcclxuICAgICAgICAgIGkgPSBzdHIuaW5kZXhPZignLicpLFxyXG4gICAgICAgICAgZHAgPSBERUNJTUFMX1BMQUNFUyxcclxuICAgICAgICAgIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuXHJcbiAgICAgICAgLy8gTm9uLWludGVnZXIuXHJcbiAgICAgICAgaWYgKGkgPj0gMCkge1xyXG4gICAgICAgICAgayA9IFBPV19QUkVDSVNJT047XHJcblxyXG4gICAgICAgICAgLy8gVW5saW1pdGVkIHByZWNpc2lvbi5cclxuICAgICAgICAgIFBPV19QUkVDSVNJT04gPSAwO1xyXG4gICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoJy4nLCAnJyk7XHJcbiAgICAgICAgICB5ID0gbmV3IEJpZ051bWJlcihiYXNlSW4pO1xyXG4gICAgICAgICAgeCA9IHkucG93KHN0ci5sZW5ndGggLSBpKTtcclxuICAgICAgICAgIFBPV19QUkVDSVNJT04gPSBrO1xyXG5cclxuICAgICAgICAgIC8vIENvbnZlcnQgc3RyIGFzIGlmIGFuIGludGVnZXIsIHRoZW4gcmVzdG9yZSB0aGUgZnJhY3Rpb24gcGFydCBieSBkaXZpZGluZyB0aGVcclxuICAgICAgICAgIC8vIHJlc3VsdCBieSBpdHMgYmFzZSByYWlzZWQgdG8gYSBwb3dlci5cclxuXHJcbiAgICAgICAgICB5LmMgPSB0b0Jhc2VPdXQodG9GaXhlZFBvaW50KGNvZWZmVG9TdHJpbmcoeC5jKSwgeC5lLCAnMCcpLFxyXG4gICAgICAgICAgIDEwLCBiYXNlT3V0LCBkZWNpbWFsKTtcclxuICAgICAgICAgIHkuZSA9IHkuYy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDb252ZXJ0IHRoZSBudW1iZXIgYXMgaW50ZWdlci5cclxuXHJcbiAgICAgICAgeGMgPSB0b0Jhc2VPdXQoc3RyLCBiYXNlSW4sIGJhc2VPdXQsIGNhbGxlcklzVG9TdHJpbmdcclxuICAgICAgICAgPyAoYWxwaGFiZXQgPSBBTFBIQUJFVCwgZGVjaW1hbClcclxuICAgICAgICAgOiAoYWxwaGFiZXQgPSBkZWNpbWFsLCBBTFBIQUJFVCkpO1xyXG5cclxuICAgICAgICAvLyB4YyBub3cgcmVwcmVzZW50cyBzdHIgYXMgYW4gaW50ZWdlciBhbmQgY29udmVydGVkIHRvIGJhc2VPdXQuIGUgaXMgdGhlIGV4cG9uZW50LlxyXG4gICAgICAgIGUgPSBrID0geGMubGVuZ3RoO1xyXG5cclxuICAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgZm9yICg7IHhjWy0ta10gPT0gMDsgeGMucG9wKCkpO1xyXG5cclxuICAgICAgICAvLyBaZXJvP1xyXG4gICAgICAgIGlmICgheGNbMF0pIHJldHVybiBhbHBoYWJldC5jaGFyQXQoMCk7XHJcblxyXG4gICAgICAgIC8vIERvZXMgc3RyIHJlcHJlc2VudCBhbiBpbnRlZ2VyPyBJZiBzbywgbm8gbmVlZCBmb3IgdGhlIGRpdmlzaW9uLlxyXG4gICAgICAgIGlmIChpIDwgMCkge1xyXG4gICAgICAgICAgLS1lO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4LmMgPSB4YztcclxuICAgICAgICAgIHguZSA9IGU7XHJcblxyXG4gICAgICAgICAgLy8gVGhlIHNpZ24gaXMgbmVlZGVkIGZvciBjb3JyZWN0IHJvdW5kaW5nLlxyXG4gICAgICAgICAgeC5zID0gc2lnbjtcclxuICAgICAgICAgIHggPSBkaXYoeCwgeSwgZHAsIHJtLCBiYXNlT3V0KTtcclxuICAgICAgICAgIHhjID0geC5jO1xyXG4gICAgICAgICAgciA9IHgucjtcclxuICAgICAgICAgIGUgPSB4LmU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB4YyBub3cgcmVwcmVzZW50cyBzdHIgY29udmVydGVkIHRvIGJhc2VPdXQuXHJcblxyXG4gICAgICAgIC8vIFRIZSBpbmRleCBvZiB0aGUgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgICAgZCA9IGUgKyBkcCArIDE7XHJcblxyXG4gICAgICAgIC8vIFRoZSByb3VuZGluZyBkaWdpdDogdGhlIGRpZ2l0IHRvIHRoZSByaWdodCBvZiB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cC5cclxuICAgICAgICBpID0geGNbZF07XHJcblxyXG4gICAgICAgIC8vIExvb2sgYXQgdGhlIHJvdW5kaW5nIGRpZ2l0cyBhbmQgbW9kZSB0byBkZXRlcm1pbmUgd2hldGhlciB0byByb3VuZCB1cC5cclxuXHJcbiAgICAgICAgayA9IGJhc2VPdXQgLyAyO1xyXG4gICAgICAgIHIgPSByIHx8IGQgPCAwIHx8IHhjW2QgKyAxXSAhPSBudWxsO1xyXG5cclxuICAgICAgICByID0gcm0gPCA0ID8gKGkgIT0gbnVsbCB8fCByKSAmJiAocm0gPT0gMCB8fCBybSA9PSAoeC5zIDwgMCA/IDMgOiAyKSlcclxuICAgICAgICAgICAgICA6IGkgPiBrIHx8IGkgPT0gayAmJihybSA9PSA0IHx8IHIgfHwgcm0gPT0gNiAmJiB4Y1tkIC0gMV0gJiAxIHx8XHJcbiAgICAgICAgICAgICAgIHJtID09ICh4LnMgPCAwID8gOCA6IDcpKTtcclxuXHJcbiAgICAgICAgLy8gSWYgdGhlIGluZGV4IG9mIHRoZSByb3VuZGluZyBkaWdpdCBpcyBub3QgZ3JlYXRlciB0aGFuIHplcm8sIG9yIHhjIHJlcHJlc2VudHNcclxuICAgICAgICAvLyB6ZXJvLCB0aGVuIHRoZSByZXN1bHQgb2YgdGhlIGJhc2UgY29udmVyc2lvbiBpcyB6ZXJvIG9yLCBpZiByb3VuZGluZyB1cCwgYSB2YWx1ZVxyXG4gICAgICAgIC8vIHN1Y2ggYXMgMC4wMDAwMS5cclxuICAgICAgICBpZiAoZCA8IDEgfHwgIXhjWzBdKSB7XHJcblxyXG4gICAgICAgICAgLy8gMV4tZHAgb3IgMFxyXG4gICAgICAgICAgc3RyID0gciA/IHRvRml4ZWRQb2ludChhbHBoYWJldC5jaGFyQXQoMSksIC1kcCwgYWxwaGFiZXQuY2hhckF0KDApKSA6IGFscGhhYmV0LmNoYXJBdCgwKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIC8vIFRydW5jYXRlIHhjIHRvIHRoZSByZXF1aXJlZCBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgICAgICB4Yy5sZW5ndGggPSBkO1xyXG5cclxuICAgICAgICAgIC8vIFJvdW5kIHVwP1xyXG4gICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFJvdW5kaW5nIHVwIG1heSBtZWFuIHRoZSBwcmV2aW91cyBkaWdpdCBoYXMgdG8gYmUgcm91bmRlZCB1cCBhbmQgc28gb24uXHJcbiAgICAgICAgICAgIGZvciAoLS1iYXNlT3V0OyArK3hjWy0tZF0gPiBiYXNlT3V0Oykge1xyXG4gICAgICAgICAgICAgIHhjW2RdID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKCFkKSB7XHJcbiAgICAgICAgICAgICAgICArK2U7XHJcbiAgICAgICAgICAgICAgICB4YyA9IFsxXS5jb25jYXQoeGMpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICAgIGZvciAoayA9IHhjLmxlbmd0aDsgIXhjWy0ta107KTtcclxuXHJcbiAgICAgICAgICAvLyBFLmcuIFs0LCAxMSwgMTVdIGJlY29tZXMgNGJmLlxyXG4gICAgICAgICAgZm9yIChpID0gMCwgc3RyID0gJyc7IGkgPD0gazsgc3RyICs9IGFscGhhYmV0LmNoYXJBdCh4Y1tpKytdKSk7XHJcblxyXG4gICAgICAgICAgLy8gQWRkIGxlYWRpbmcgemVyb3MsIGRlY2ltYWwgcG9pbnQgYW5kIHRyYWlsaW5nIHplcm9zIGFzIHJlcXVpcmVkLlxyXG4gICAgICAgICAgc3RyID0gdG9GaXhlZFBvaW50KHN0ciwgZSwgYWxwaGFiZXQuY2hhckF0KDApKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRoZSBjYWxsZXIgd2lsbCBhZGQgdGhlIHNpZ24uXHJcbiAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgICAgfTtcclxuICAgIH0pKCk7XHJcblxyXG5cclxuICAgIC8vIFBlcmZvcm0gZGl2aXNpb24gaW4gdGhlIHNwZWNpZmllZCBiYXNlLiBDYWxsZWQgYnkgZGl2IGFuZCBjb252ZXJ0QmFzZS5cclxuICAgIGRpdiA9IChmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAvLyBBc3N1bWUgbm9uLXplcm8geCBhbmQgay5cclxuICAgICAgZnVuY3Rpb24gbXVsdGlwbHkoeCwgaywgYmFzZSkge1xyXG4gICAgICAgIHZhciBtLCB0ZW1wLCB4bG8sIHhoaSxcclxuICAgICAgICAgIGNhcnJ5ID0gMCxcclxuICAgICAgICAgIGkgPSB4Lmxlbmd0aCxcclxuICAgICAgICAgIGtsbyA9IGsgJSBTUVJUX0JBU0UsXHJcbiAgICAgICAgICBraGkgPSBrIC8gU1FSVF9CQVNFIHwgMDtcclxuXHJcbiAgICAgICAgZm9yICh4ID0geC5zbGljZSgpOyBpLS07KSB7XHJcbiAgICAgICAgICB4bG8gPSB4W2ldICUgU1FSVF9CQVNFO1xyXG4gICAgICAgICAgeGhpID0geFtpXSAvIFNRUlRfQkFTRSB8IDA7XHJcbiAgICAgICAgICBtID0ga2hpICogeGxvICsgeGhpICoga2xvO1xyXG4gICAgICAgICAgdGVtcCA9IGtsbyAqIHhsbyArICgobSAlIFNRUlRfQkFTRSkgKiBTUVJUX0JBU0UpICsgY2Fycnk7XHJcbiAgICAgICAgICBjYXJyeSA9ICh0ZW1wIC8gYmFzZSB8IDApICsgKG0gLyBTUVJUX0JBU0UgfCAwKSArIGtoaSAqIHhoaTtcclxuICAgICAgICAgIHhbaV0gPSB0ZW1wICUgYmFzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChjYXJyeSkgeCA9IFtjYXJyeV0uY29uY2F0KHgpO1xyXG5cclxuICAgICAgICByZXR1cm4geDtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gY29tcGFyZShhLCBiLCBhTCwgYkwpIHtcclxuICAgICAgICB2YXIgaSwgY21wO1xyXG5cclxuICAgICAgICBpZiAoYUwgIT0gYkwpIHtcclxuICAgICAgICAgIGNtcCA9IGFMID4gYkwgPyAxIDogLTE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICBmb3IgKGkgPSBjbXAgPSAwOyBpIDwgYUw7IGkrKykge1xyXG5cclxuICAgICAgICAgICAgaWYgKGFbaV0gIT0gYltpXSkge1xyXG4gICAgICAgICAgICAgIGNtcCA9IGFbaV0gPiBiW2ldID8gMSA6IC0xO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gY21wO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBzdWJ0cmFjdChhLCBiLCBhTCwgYmFzZSkge1xyXG4gICAgICAgIHZhciBpID0gMDtcclxuXHJcbiAgICAgICAgLy8gU3VidHJhY3QgYiBmcm9tIGEuXHJcbiAgICAgICAgZm9yICg7IGFMLS07KSB7XHJcbiAgICAgICAgICBhW2FMXSAtPSBpO1xyXG4gICAgICAgICAgaSA9IGFbYUxdIDwgYlthTF0gPyAxIDogMDtcclxuICAgICAgICAgIGFbYUxdID0gaSAqIGJhc2UgKyBhW2FMXSAtIGJbYUxdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgICAgZm9yICg7ICFhWzBdICYmIGEubGVuZ3RoID4gMTsgYS5zcGxpY2UoMCwgMSkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyB4OiBkaXZpZGVuZCwgeTogZGl2aXNvci5cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4LCB5LCBkcCwgcm0sIGJhc2UpIHtcclxuICAgICAgICB2YXIgY21wLCBlLCBpLCBtb3JlLCBuLCBwcm9kLCBwcm9kTCwgcSwgcWMsIHJlbSwgcmVtTCwgcmVtMCwgeGksIHhMLCB5YzAsXHJcbiAgICAgICAgICB5TCwgeXosXHJcbiAgICAgICAgICBzID0geC5zID09IHkucyA/IDEgOiAtMSxcclxuICAgICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgICAgeWMgPSB5LmM7XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciBOYU4sIEluZmluaXR5IG9yIDA/XHJcbiAgICAgICAgaWYgKCF4YyB8fCAheGNbMF0gfHwgIXljIHx8ICF5Y1swXSkge1xyXG5cclxuICAgICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKFxyXG5cclxuICAgICAgICAgICAvLyBSZXR1cm4gTmFOIGlmIGVpdGhlciBOYU4sIG9yIGJvdGggSW5maW5pdHkgb3IgMC5cclxuICAgICAgICAgICAheC5zIHx8ICF5LnMgfHwgKHhjID8geWMgJiYgeGNbMF0gPT0geWNbMF0gOiAheWMpID8gTmFOIDpcclxuXHJcbiAgICAgICAgICAgIC8vIFJldHVybiDCsTAgaWYgeCBpcyDCsTAgb3IgeSBpcyDCsUluZmluaXR5LCBvciByZXR1cm4gwrFJbmZpbml0eSBhcyB5IGlzIMKxMC5cclxuICAgICAgICAgICAgeGMgJiYgeGNbMF0gPT0gMCB8fCAheWMgPyBzICogMCA6IHMgLyAwXHJcbiAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBxID0gbmV3IEJpZ051bWJlcihzKTtcclxuICAgICAgICBxYyA9IHEuYyA9IFtdO1xyXG4gICAgICAgIGUgPSB4LmUgLSB5LmU7XHJcbiAgICAgICAgcyA9IGRwICsgZSArIDE7XHJcblxyXG4gICAgICAgIGlmICghYmFzZSkge1xyXG4gICAgICAgICAgYmFzZSA9IEJBU0U7XHJcbiAgICAgICAgICBlID0gYml0Rmxvb3IoeC5lIC8gTE9HX0JBU0UpIC0gYml0Rmxvb3IoeS5lIC8gTE9HX0JBU0UpO1xyXG4gICAgICAgICAgcyA9IHMgLyBMT0dfQkFTRSB8IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZXN1bHQgZXhwb25lbnQgbWF5IGJlIG9uZSBsZXNzIHRoZW4gdGhlIGN1cnJlbnQgdmFsdWUgb2YgZS5cclxuICAgICAgICAvLyBUaGUgY29lZmZpY2llbnRzIG9mIHRoZSBCaWdOdW1iZXJzIGZyb20gY29udmVydEJhc2UgbWF5IGhhdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgZm9yIChpID0gMDsgeWNbaV0gPT0gKHhjW2ldIHx8IDApOyBpKyspO1xyXG5cclxuICAgICAgICBpZiAoeWNbaV0gPiAoeGNbaV0gfHwgMCkpIGUtLTtcclxuXHJcbiAgICAgICAgaWYgKHMgPCAwKSB7XHJcbiAgICAgICAgICBxYy5wdXNoKDEpO1xyXG4gICAgICAgICAgbW9yZSA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHhMID0geGMubGVuZ3RoO1xyXG4gICAgICAgICAgeUwgPSB5Yy5sZW5ndGg7XHJcbiAgICAgICAgICBpID0gMDtcclxuICAgICAgICAgIHMgKz0gMjtcclxuXHJcbiAgICAgICAgICAvLyBOb3JtYWxpc2UgeGMgYW5kIHljIHNvIGhpZ2hlc3Qgb3JkZXIgZGlnaXQgb2YgeWMgaXMgPj0gYmFzZSAvIDIuXHJcblxyXG4gICAgICAgICAgbiA9IG1hdGhmbG9vcihiYXNlIC8gKHljWzBdICsgMSkpO1xyXG5cclxuICAgICAgICAgIC8vIE5vdCBuZWNlc3NhcnksIGJ1dCB0byBoYW5kbGUgb2RkIGJhc2VzIHdoZXJlIHljWzBdID09IChiYXNlIC8gMikgLSAxLlxyXG4gICAgICAgICAgLy8gaWYgKG4gPiAxIHx8IG4rKyA9PSAxICYmIHljWzBdIDwgYmFzZSAvIDIpIHtcclxuICAgICAgICAgIGlmIChuID4gMSkge1xyXG4gICAgICAgICAgICB5YyA9IG11bHRpcGx5KHljLCBuLCBiYXNlKTtcclxuICAgICAgICAgICAgeGMgPSBtdWx0aXBseSh4YywgbiwgYmFzZSk7XHJcbiAgICAgICAgICAgIHlMID0geWMubGVuZ3RoO1xyXG4gICAgICAgICAgICB4TCA9IHhjLmxlbmd0aDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB4aSA9IHlMO1xyXG4gICAgICAgICAgcmVtID0geGMuc2xpY2UoMCwgeUwpO1xyXG4gICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgLy8gQWRkIHplcm9zIHRvIG1ha2UgcmVtYWluZGVyIGFzIGxvbmcgYXMgZGl2aXNvci5cclxuICAgICAgICAgIGZvciAoOyByZW1MIDwgeUw7IHJlbVtyZW1MKytdID0gMCk7XHJcbiAgICAgICAgICB5eiA9IHljLnNsaWNlKCk7XHJcbiAgICAgICAgICB5eiA9IFswXS5jb25jYXQoeXopO1xyXG4gICAgICAgICAgeWMwID0geWNbMF07XHJcbiAgICAgICAgICBpZiAoeWNbMV0gPj0gYmFzZSAvIDIpIHljMCsrO1xyXG4gICAgICAgICAgLy8gTm90IG5lY2Vzc2FyeSwgYnV0IHRvIHByZXZlbnQgdHJpYWwgZGlnaXQgbiA+IGJhc2UsIHdoZW4gdXNpbmcgYmFzZSAzLlxyXG4gICAgICAgICAgLy8gZWxzZSBpZiAoYmFzZSA9PSAzICYmIHljMCA9PSAxKSB5YzAgPSAxICsgMWUtMTU7XHJcblxyXG4gICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBuID0gMDtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbXBhcmUgZGl2aXNvciBhbmQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICBjbXAgPSBjb21wYXJlKHljLCByZW0sIHlMLCByZW1MKTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIGRpdmlzb3IgPCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgIGlmIChjbXAgPCAwKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0cmlhbCBkaWdpdCwgbi5cclxuXHJcbiAgICAgICAgICAgICAgcmVtMCA9IHJlbVswXTtcclxuICAgICAgICAgICAgICBpZiAoeUwgIT0gcmVtTCkgcmVtMCA9IHJlbTAgKiBiYXNlICsgKHJlbVsxXSB8fCAwKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gbiBpcyBob3cgbWFueSB0aW1lcyB0aGUgZGl2aXNvciBnb2VzIGludG8gdGhlIGN1cnJlbnQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIG4gPSBtYXRoZmxvb3IocmVtMCAvIHljMCk7XHJcblxyXG4gICAgICAgICAgICAgIC8vICBBbGdvcml0aG06XHJcbiAgICAgICAgICAgICAgLy8gIHByb2R1Y3QgPSBkaXZpc29yIG11bHRpcGxpZWQgYnkgdHJpYWwgZGlnaXQgKG4pLlxyXG4gICAgICAgICAgICAgIC8vICBDb21wYXJlIHByb2R1Y3QgYW5kIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAvLyAgSWYgcHJvZHVjdCBpcyBncmVhdGVyIHRoYW4gcmVtYWluZGVyOlxyXG4gICAgICAgICAgICAgIC8vICAgIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSBwcm9kdWN0LCBkZWNyZW1lbnQgdHJpYWwgZGlnaXQuXHJcbiAgICAgICAgICAgICAgLy8gIFN1YnRyYWN0IHByb2R1Y3QgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgLy8gIElmIHByb2R1Y3Qgd2FzIGxlc3MgdGhhbiByZW1haW5kZXIgYXQgdGhlIGxhc3QgY29tcGFyZTpcclxuICAgICAgICAgICAgICAvLyAgICBDb21wYXJlIG5ldyByZW1haW5kZXIgYW5kIGRpdmlzb3IuXHJcbiAgICAgICAgICAgICAgLy8gICAgSWYgcmVtYWluZGVyIGlzIGdyZWF0ZXIgdGhhbiBkaXZpc29yOlxyXG4gICAgICAgICAgICAgIC8vICAgICAgU3VidHJhY3QgZGl2aXNvciBmcm9tIHJlbWFpbmRlciwgaW5jcmVtZW50IHRyaWFsIGRpZ2l0LlxyXG5cclxuICAgICAgICAgICAgICBpZiAobiA+IDEpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBuIG1heSBiZSA+IGJhc2Ugb25seSB3aGVuIGJhc2UgaXMgMy5cclxuICAgICAgICAgICAgICAgIGlmIChuID49IGJhc2UpIG4gPSBiYXNlIC0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBwcm9kdWN0ID0gZGl2aXNvciAqIHRyaWFsIGRpZ2l0LlxyXG4gICAgICAgICAgICAgICAgcHJvZCA9IG11bHRpcGx5KHljLCBuLCBiYXNlKTtcclxuICAgICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb21wYXJlIHByb2R1Y3QgYW5kIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgIC8vIElmIHByb2R1Y3QgPiByZW1haW5kZXIgdGhlbiB0cmlhbCBkaWdpdCBuIHRvbyBoaWdoLlxyXG4gICAgICAgICAgICAgICAgLy8gbiBpcyAxIHRvbyBoaWdoIGFib3V0IDUlIG9mIHRoZSB0aW1lLCBhbmQgaXMgbm90IGtub3duIHRvIGhhdmVcclxuICAgICAgICAgICAgICAgIC8vIGV2ZXIgYmVlbiBtb3JlIHRoYW4gMSB0b28gaGlnaC5cclxuICAgICAgICAgICAgICAgIHdoaWxlIChjb21wYXJlKHByb2QsIHJlbSwgcHJvZEwsIHJlbUwpID09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgbi0tO1xyXG5cclxuICAgICAgICAgICAgICAgICAgLy8gU3VidHJhY3QgZGl2aXNvciBmcm9tIHByb2R1Y3QuXHJcbiAgICAgICAgICAgICAgICAgIHN1YnRyYWN0KHByb2QsIHlMIDwgcHJvZEwgPyB5eiA6IHljLCBwcm9kTCwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgIGNtcCA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBuIGlzIDAgb3IgMSwgY21wIGlzIC0xLlxyXG4gICAgICAgICAgICAgICAgLy8gSWYgbiBpcyAwLCB0aGVyZSBpcyBubyBuZWVkIHRvIGNvbXBhcmUgeWMgYW5kIHJlbSBhZ2FpbiBiZWxvdyxcclxuICAgICAgICAgICAgICAgIC8vIHNvIGNoYW5nZSBjbXAgdG8gMSB0byBhdm9pZCBpdC5cclxuICAgICAgICAgICAgICAgIC8vIElmIG4gaXMgMSwgbGVhdmUgY21wIGFzIC0xLCBzbyB5YyBhbmQgcmVtIGFyZSBjb21wYXJlZCBhZ2Fpbi5cclxuICAgICAgICAgICAgICAgIGlmIChuID09IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgIC8vIGRpdmlzb3IgPCByZW1haW5kZXIsIHNvIG4gbXVzdCBiZSBhdCBsZWFzdCAxLlxyXG4gICAgICAgICAgICAgICAgICBjbXAgPSBuID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBwcm9kdWN0ID0gZGl2aXNvclxyXG4gICAgICAgICAgICAgICAgcHJvZCA9IHljLnNsaWNlKCk7XHJcbiAgICAgICAgICAgICAgICBwcm9kTCA9IHByb2QubGVuZ3RoO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgaWYgKHByb2RMIDwgcmVtTCkgcHJvZCA9IFswXS5jb25jYXQocHJvZCk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIFN1YnRyYWN0IHByb2R1Y3QgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgc3VidHJhY3QocmVtLCBwcm9kLCByZW1MLCBiYXNlKTtcclxuICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgIC8vIElmIHByb2R1Y3Qgd2FzIDwgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIGlmIChjbXAgPT0gLTEpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb21wYXJlIGRpdmlzb3IgYW5kIG5ldyByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBkaXZpc29yIDwgbmV3IHJlbWFpbmRlciwgc3VidHJhY3QgZGl2aXNvciBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgIC8vIFRyaWFsIGRpZ2l0IG4gdG9vIGxvdy5cclxuICAgICAgICAgICAgICAgIC8vIG4gaXMgMSB0b28gbG93IGFib3V0IDUlIG9mIHRoZSB0aW1lLCBhbmQgdmVyeSByYXJlbHkgMiB0b28gbG93LlxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUoeWMsIHJlbSwgeUwsIHJlbUwpIDwgMSkge1xyXG4gICAgICAgICAgICAgICAgICBuKys7XHJcblxyXG4gICAgICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgICBzdWJ0cmFjdChyZW0sIHlMIDwgcmVtTCA/IHl6IDogeWMsIHJlbUwsIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY21wID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgbisrO1xyXG4gICAgICAgICAgICAgIHJlbSA9IFswXTtcclxuICAgICAgICAgICAgfSAvLyBlbHNlIGNtcCA9PT0gMSBhbmQgbiB3aWxsIGJlIDBcclxuXHJcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgbmV4dCBkaWdpdCwgbiwgdG8gdGhlIHJlc3VsdCBhcnJheS5cclxuICAgICAgICAgICAgcWNbaSsrXSA9IG47XHJcblxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgaWYgKHJlbVswXSkge1xyXG4gICAgICAgICAgICAgIHJlbVtyZW1MKytdID0geGNbeGldIHx8IDA7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgcmVtID0gW3hjW3hpXV07XHJcbiAgICAgICAgICAgICAgcmVtTCA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gd2hpbGUgKCh4aSsrIDwgeEwgfHwgcmVtWzBdICE9IG51bGwpICYmIHMtLSk7XHJcblxyXG4gICAgICAgICAgbW9yZSA9IHJlbVswXSAhPSBudWxsO1xyXG5cclxuICAgICAgICAgIC8vIExlYWRpbmcgemVybz9cclxuICAgICAgICAgIGlmICghcWNbMF0pIHFjLnNwbGljZSgwLCAxKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChiYXNlID09IEJBU0UpIHtcclxuXHJcbiAgICAgICAgICAvLyBUbyBjYWxjdWxhdGUgcS5lLCBmaXJzdCBnZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgcWNbMF0uXHJcbiAgICAgICAgICBmb3IgKGkgPSAxLCBzID0gcWNbMF07IHMgPj0gMTA7IHMgLz0gMTAsIGkrKyk7XHJcblxyXG4gICAgICAgICAgcm91bmQocSwgZHAgKyAocS5lID0gaSArIGUgKiBMT0dfQkFTRSAtIDEpICsgMSwgcm0sIG1vcmUpO1xyXG5cclxuICAgICAgICAvLyBDYWxsZXIgaXMgY29udmVydEJhc2UuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHEuZSA9IGU7XHJcbiAgICAgICAgICBxLnIgPSArbW9yZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBxO1xyXG4gICAgICB9O1xyXG4gICAgfSkoKTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIEJpZ051bWJlciBuIGluIGZpeGVkLXBvaW50IG9yIGV4cG9uZW50aWFsXHJcbiAgICAgKiBub3RhdGlvbiByb3VuZGVkIHRvIHRoZSBzcGVjaWZpZWQgZGVjaW1hbCBwbGFjZXMgb3Igc2lnbmlmaWNhbnQgZGlnaXRzLlxyXG4gICAgICpcclxuICAgICAqIG46IGEgQmlnTnVtYmVyLlxyXG4gICAgICogaTogdGhlIGluZGV4IG9mIHRoZSBsYXN0IGRpZ2l0IHJlcXVpcmVkIChpLmUuIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwKS5cclxuICAgICAqIHJtOiB0aGUgcm91bmRpbmcgbW9kZS5cclxuICAgICAqIGlkOiAxICh0b0V4cG9uZW50aWFsKSBvciAyICh0b1ByZWNpc2lvbikuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZvcm1hdChuLCBpLCBybSwgaWQpIHtcclxuICAgICAgdmFyIGMwLCBlLCBuZSwgbGVuLCBzdHI7XHJcblxyXG4gICAgICBpZiAocm0gPT0gbnVsbCkgcm0gPSBST1VORElOR19NT0RFO1xyXG4gICAgICBlbHNlIGludENoZWNrKHJtLCAwLCA4KTtcclxuXHJcbiAgICAgIGlmICghbi5jKSByZXR1cm4gbi50b1N0cmluZygpO1xyXG5cclxuICAgICAgYzAgPSBuLmNbMF07XHJcbiAgICAgIG5lID0gbi5lO1xyXG5cclxuICAgICAgaWYgKGkgPT0gbnVsbCkge1xyXG4gICAgICAgIHN0ciA9IGNvZWZmVG9TdHJpbmcobi5jKTtcclxuICAgICAgICBzdHIgPSBpZCA9PSAxIHx8IGlkID09IDIgJiYgKG5lIDw9IFRPX0VYUF9ORUcgfHwgbmUgPj0gVE9fRVhQX1BPUylcclxuICAgICAgICAgPyB0b0V4cG9uZW50aWFsKHN0ciwgbmUpXHJcbiAgICAgICAgIDogdG9GaXhlZFBvaW50KHN0ciwgbmUsICcwJyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbiA9IHJvdW5kKG5ldyBCaWdOdW1iZXIobiksIGksIHJtKTtcclxuXHJcbiAgICAgICAgLy8gbi5lIG1heSBoYXZlIGNoYW5nZWQgaWYgdGhlIHZhbHVlIHdhcyByb3VuZGVkIHVwLlxyXG4gICAgICAgIGUgPSBuLmU7XHJcblxyXG4gICAgICAgIHN0ciA9IGNvZWZmVG9TdHJpbmcobi5jKTtcclxuICAgICAgICBsZW4gPSBzdHIubGVuZ3RoO1xyXG5cclxuICAgICAgICAvLyB0b1ByZWNpc2lvbiByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uIGlmIHRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzXHJcbiAgICAgICAgLy8gc3BlY2lmaWVkIGlzIGxlc3MgdGhhbiB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBuZWNlc3NhcnkgdG8gcmVwcmVzZW50IHRoZSBpbnRlZ2VyXHJcbiAgICAgICAgLy8gcGFydCBvZiB0aGUgdmFsdWUgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24uXHJcblxyXG4gICAgICAgIC8vIEV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICAgIGlmIChpZCA9PSAxIHx8IGlkID09IDIgJiYgKGkgPD0gZSB8fCBlIDw9IFRPX0VYUF9ORUcpKSB7XHJcblxyXG4gICAgICAgICAgLy8gQXBwZW5kIHplcm9zP1xyXG4gICAgICAgICAgZm9yICg7IGxlbiA8IGk7IHN0ciArPSAnMCcsIGxlbisrKTtcclxuICAgICAgICAgIHN0ciA9IHRvRXhwb25lbnRpYWwoc3RyLCBlKTtcclxuXHJcbiAgICAgICAgLy8gRml4ZWQtcG9pbnQgbm90YXRpb24uXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGkgLT0gbmU7XHJcbiAgICAgICAgICBzdHIgPSB0b0ZpeGVkUG9pbnQoc3RyLCBlLCAnMCcpO1xyXG5cclxuICAgICAgICAgIC8vIEFwcGVuZCB6ZXJvcz9cclxuICAgICAgICAgIGlmIChlICsgMSA+IGxlbikge1xyXG4gICAgICAgICAgICBpZiAoLS1pID4gMCkgZm9yIChzdHIgKz0gJy4nOyBpLS07IHN0ciArPSAnMCcpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaSArPSBlIC0gbGVuO1xyXG4gICAgICAgICAgICBpZiAoaSA+IDApIHtcclxuICAgICAgICAgICAgICBpZiAoZSArIDEgPT0gbGVuKSBzdHIgKz0gJy4nO1xyXG4gICAgICAgICAgICAgIGZvciAoOyBpLS07IHN0ciArPSAnMCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbi5zIDwgMCAmJiBjMCA/ICctJyArIHN0ciA6IHN0cjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gSGFuZGxlIEJpZ051bWJlci5tYXggYW5kIEJpZ051bWJlci5taW4uXHJcbiAgICBmdW5jdGlvbiBtYXhPck1pbihhcmdzLCBtZXRob2QpIHtcclxuICAgICAgdmFyIG4sXHJcbiAgICAgICAgaSA9IDEsXHJcbiAgICAgICAgbSA9IG5ldyBCaWdOdW1iZXIoYXJnc1swXSk7XHJcblxyXG4gICAgICBmb3IgKDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBuID0gbmV3IEJpZ051bWJlcihhcmdzW2ldKTtcclxuXHJcbiAgICAgICAgLy8gSWYgYW55IG51bWJlciBpcyBOYU4sIHJldHVybiBOYU4uXHJcbiAgICAgICAgaWYgKCFuLnMpIHtcclxuICAgICAgICAgIG0gPSBuO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2QuY2FsbChtLCBuKSkge1xyXG4gICAgICAgICAgbSA9IG47XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFN0cmlwIHRyYWlsaW5nIHplcm9zLCBjYWxjdWxhdGUgYmFzZSAxMCBleHBvbmVudCBhbmQgY2hlY2sgYWdhaW5zdCBNSU5fRVhQIGFuZCBNQVhfRVhQLlxyXG4gICAgICogQ2FsbGVkIGJ5IG1pbnVzLCBwbHVzIGFuZCB0aW1lcy5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gbm9ybWFsaXNlKG4sIGMsIGUpIHtcclxuICAgICAgdmFyIGkgPSAxLFxyXG4gICAgICAgIGogPSBjLmxlbmd0aDtcclxuXHJcbiAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgIGZvciAoOyAhY1stLWpdOyBjLnBvcCgpKTtcclxuXHJcbiAgICAgIC8vIENhbGN1bGF0ZSB0aGUgYmFzZSAxMCBleHBvbmVudC4gRmlyc3QgZ2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIGNbMF0uXHJcbiAgICAgIGZvciAoaiA9IGNbMF07IGogPj0gMTA7IGogLz0gMTAsIGkrKyk7XHJcblxyXG4gICAgICAvLyBPdmVyZmxvdz9cclxuICAgICAgaWYgKChlID0gaSArIGUgKiBMT0dfQkFTRSAtIDEpID4gTUFYX0VYUCkge1xyXG5cclxuICAgICAgICAvLyBJbmZpbml0eS5cclxuICAgICAgICBuLmMgPSBuLmUgPSBudWxsO1xyXG5cclxuICAgICAgLy8gVW5kZXJmbG93P1xyXG4gICAgICB9IGVsc2UgaWYgKGUgPCBNSU5fRVhQKSB7XHJcblxyXG4gICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgbi5jID0gW24uZSA9IDBdO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG4uZSA9IGU7XHJcbiAgICAgICAgbi5jID0gYztcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG47XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIEhhbmRsZSB2YWx1ZXMgdGhhdCBmYWlsIHRoZSB2YWxpZGl0eSB0ZXN0IGluIEJpZ051bWJlci5cclxuICAgIHBhcnNlTnVtZXJpYyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBiYXNlUHJlZml4ID0gL14oLT8pMChbeGJvXSkoPz1cXHdbXFx3Ll0qJCkvaSxcclxuICAgICAgICBkb3RBZnRlciA9IC9eKFteLl0rKVxcLiQvLFxyXG4gICAgICAgIGRvdEJlZm9yZSA9IC9eXFwuKFteLl0rKSQvLFxyXG4gICAgICAgIGlzSW5maW5pdHlPck5hTiA9IC9eLT8oSW5maW5pdHl8TmFOKSQvLFxyXG4gICAgICAgIHdoaXRlc3BhY2VPclBsdXMgPSAvXlxccypcXCsoPz1bXFx3Ll0pfF5cXHMrfFxccyskL2c7XHJcblxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHgsIHN0ciwgaXNOdW0sIGIpIHtcclxuICAgICAgICB2YXIgYmFzZSxcclxuICAgICAgICAgIHMgPSBpc051bSA/IHN0ciA6IHN0ci5yZXBsYWNlKHdoaXRlc3BhY2VPclBsdXMsICcnKTtcclxuXHJcbiAgICAgICAgLy8gTm8gZXhjZXB0aW9uIG9uIMKxSW5maW5pdHkgb3IgTmFOLlxyXG4gICAgICAgIGlmIChpc0luZmluaXR5T3JOYU4udGVzdChzKSkge1xyXG4gICAgICAgICAgeC5zID0gaXNOYU4ocykgPyBudWxsIDogcyA8IDAgPyAtMSA6IDE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGlmICghaXNOdW0pIHtcclxuXHJcbiAgICAgICAgICAgIC8vIGJhc2VQcmVmaXggPSAvXigtPykwKFt4Ym9dKSg/PVxcd1tcXHcuXSokKS9pXHJcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoYmFzZVByZWZpeCwgZnVuY3Rpb24gKG0sIHAxLCBwMikge1xyXG4gICAgICAgICAgICAgIGJhc2UgPSAocDIgPSBwMi50b0xvd2VyQ2FzZSgpKSA9PSAneCcgPyAxNiA6IHAyID09ICdiJyA/IDIgOiA4O1xyXG4gICAgICAgICAgICAgIHJldHVybiAhYiB8fCBiID09IGJhc2UgPyBwMSA6IG07XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaWYgKGIpIHtcclxuICAgICAgICAgICAgICBiYXNlID0gYjtcclxuXHJcbiAgICAgICAgICAgICAgLy8gRS5nLiAnMS4nIHRvICcxJywgJy4xJyB0byAnMC4xJ1xyXG4gICAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoZG90QWZ0ZXIsICckMScpLnJlcGxhY2UoZG90QmVmb3JlLCAnMC4kMScpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc3RyICE9IHMpIHJldHVybiBuZXcgQmlnTnVtYmVyKHMsIGJhc2UpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBOb3QgYSBudW1iZXI6IHtufSdcclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBOb3QgYSBiYXNlIHtifSBudW1iZXI6IHtufSdcclxuICAgICAgICAgIGlmIChCaWdOdW1iZXIuREVCVUcpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnTm90IGEnICsgKGIgPyAnIGJhc2UgJyArIGIgOiAnJykgKyAnIG51bWJlcjogJyArIHN0cik7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gTmFOXHJcbiAgICAgICAgICB4LnMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfSkoKTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJvdW5kIHggdG8gc2Qgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0uIENoZWNrIGZvciBvdmVyL3VuZGVyLWZsb3cuXHJcbiAgICAgKiBJZiByIGlzIHRydXRoeSwgaXQgaXMga25vd24gdGhhdCB0aGVyZSBhcmUgbW9yZSBkaWdpdHMgYWZ0ZXIgdGhlIHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiByb3VuZCh4LCBzZCwgcm0sIHIpIHtcclxuICAgICAgdmFyIGQsIGksIGosIGssIG4sIG5pLCByZCxcclxuICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICBwb3dzMTAgPSBQT1dTX1RFTjtcclxuXHJcbiAgICAgIC8vIGlmIHggaXMgbm90IEluZmluaXR5IG9yIE5hTi4uLlxyXG4gICAgICBpZiAoeGMpIHtcclxuXHJcbiAgICAgICAgLy8gcmQgaXMgdGhlIHJvdW5kaW5nIGRpZ2l0LCBpLmUuIHRoZSBkaWdpdCBhZnRlciB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cC5cclxuICAgICAgICAvLyBuIGlzIGEgYmFzZSAxZTE0IG51bWJlciwgdGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50IG9mIGFycmF5IHguYyBjb250YWluaW5nIHJkLlxyXG4gICAgICAgIC8vIG5pIGlzIHRoZSBpbmRleCBvZiBuIHdpdGhpbiB4LmMuXHJcbiAgICAgICAgLy8gZCBpcyB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBuLlxyXG4gICAgICAgIC8vIGkgaXMgdGhlIGluZGV4IG9mIHJkIHdpdGhpbiBuIGluY2x1ZGluZyBsZWFkaW5nIHplcm9zLlxyXG4gICAgICAgIC8vIGogaXMgdGhlIGFjdHVhbCBpbmRleCBvZiByZCB3aXRoaW4gbiAoaWYgPCAwLCByZCBpcyBhIGxlYWRpbmcgemVybykuXHJcbiAgICAgICAgb3V0OiB7XHJcblxyXG4gICAgICAgICAgLy8gR2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHRoZSBmaXJzdCBlbGVtZW50IG9mIHhjLlxyXG4gICAgICAgICAgZm9yIChkID0gMSwgayA9IHhjWzBdOyBrID49IDEwOyBrIC89IDEwLCBkKyspO1xyXG4gICAgICAgICAgaSA9IHNkIC0gZDtcclxuXHJcbiAgICAgICAgICAvLyBJZiB0aGUgcm91bmRpbmcgZGlnaXQgaXMgaW4gdGhlIGZpcnN0IGVsZW1lbnQgb2YgeGMuLi5cclxuICAgICAgICAgIGlmIChpIDwgMCkge1xyXG4gICAgICAgICAgICBpICs9IExPR19CQVNFO1xyXG4gICAgICAgICAgICBqID0gc2Q7XHJcbiAgICAgICAgICAgIG4gPSB4Y1tuaSA9IDBdO1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0IHRoZSByb3VuZGluZyBkaWdpdCBhdCBpbmRleCBqIG9mIG4uXHJcbiAgICAgICAgICAgIHJkID0gbiAvIHBvd3MxMFtkIC0gaiAtIDFdICUgMTAgfCAwO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbmkgPSBtYXRoY2VpbCgoaSArIDEpIC8gTE9HX0JBU0UpO1xyXG5cclxuICAgICAgICAgICAgaWYgKG5pID49IHhjLmxlbmd0aCkge1xyXG5cclxuICAgICAgICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIE5lZWRlZCBieSBzcXJ0LlxyXG4gICAgICAgICAgICAgICAgZm9yICg7IHhjLmxlbmd0aCA8PSBuaTsgeGMucHVzaCgwKSk7XHJcbiAgICAgICAgICAgICAgICBuID0gcmQgPSAwO1xyXG4gICAgICAgICAgICAgICAgZCA9IDE7XHJcbiAgICAgICAgICAgICAgICBpICU9IExPR19CQVNFO1xyXG4gICAgICAgICAgICAgICAgaiA9IGkgLSBMT0dfQkFTRSArIDE7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrIG91dDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgbiA9IGsgPSB4Y1tuaV07XHJcblxyXG4gICAgICAgICAgICAgIC8vIEdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBuLlxyXG4gICAgICAgICAgICAgIGZvciAoZCA9IDE7IGsgPj0gMTA7IGsgLz0gMTAsIGQrKyk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEdldCB0aGUgaW5kZXggb2YgcmQgd2l0aGluIG4uXHJcbiAgICAgICAgICAgICAgaSAlPSBMT0dfQkFTRTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gR2V0IHRoZSBpbmRleCBvZiByZCB3aXRoaW4gbiwgYWRqdXN0ZWQgZm9yIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgICAgICAgICAgLy8gVGhlIG51bWJlciBvZiBsZWFkaW5nIHplcm9zIG9mIG4gaXMgZ2l2ZW4gYnkgTE9HX0JBU0UgLSBkLlxyXG4gICAgICAgICAgICAgIGogPSBpIC0gTE9HX0JBU0UgKyBkO1xyXG5cclxuICAgICAgICAgICAgICAvLyBHZXQgdGhlIHJvdW5kaW5nIGRpZ2l0IGF0IGluZGV4IGogb2Ygbi5cclxuICAgICAgICAgICAgICByZCA9IGogPCAwID8gMCA6IG4gLyBwb3dzMTBbZCAtIGogLSAxXSAlIDEwIHwgMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHIgPSByIHx8IHNkIDwgMCB8fFxyXG5cclxuICAgICAgICAgIC8vIEFyZSB0aGVyZSBhbnkgbm9uLXplcm8gZGlnaXRzIGFmdGVyIHRoZSByb3VuZGluZyBkaWdpdD9cclxuICAgICAgICAgIC8vIFRoZSBleHByZXNzaW9uICBuICUgcG93czEwW2QgLSBqIC0gMV0gIHJldHVybnMgYWxsIGRpZ2l0cyBvZiBuIHRvIHRoZSByaWdodFxyXG4gICAgICAgICAgLy8gb2YgdGhlIGRpZ2l0IGF0IGosIGUuZy4gaWYgbiBpcyA5MDg3MTQgYW5kIGogaXMgMiwgdGhlIGV4cHJlc3Npb24gZ2l2ZXMgNzE0LlxyXG4gICAgICAgICAgIHhjW25pICsgMV0gIT0gbnVsbCB8fCAoaiA8IDAgPyBuIDogbiAlIHBvd3MxMFtkIC0gaiAtIDFdKTtcclxuXHJcbiAgICAgICAgICByID0gcm0gPCA0XHJcbiAgICAgICAgICAgPyAocmQgfHwgcikgJiYgKHJtID09IDAgfHwgcm0gPT0gKHgucyA8IDAgPyAzIDogMikpXHJcbiAgICAgICAgICAgOiByZCA+IDUgfHwgcmQgPT0gNSAmJiAocm0gPT0gNCB8fCByIHx8IHJtID09IDYgJiZcclxuXHJcbiAgICAgICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIGRpZ2l0IHRvIHRoZSBsZWZ0IG9mIHRoZSByb3VuZGluZyBkaWdpdCBpcyBvZGQuXHJcbiAgICAgICAgICAgICgoaSA+IDAgPyBqID4gMCA/IG4gLyBwb3dzMTBbZCAtIGpdIDogMCA6IHhjW25pIC0gMV0pICUgMTApICYgMSB8fFxyXG4gICAgICAgICAgICAgcm0gPT0gKHgucyA8IDAgPyA4IDogNykpO1xyXG5cclxuICAgICAgICAgIGlmIChzZCA8IDEgfHwgIXhjWzBdKSB7XHJcbiAgICAgICAgICAgIHhjLmxlbmd0aCA9IDA7XHJcblxyXG4gICAgICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgICAgICAvLyBDb252ZXJ0IHNkIHRvIGRlY2ltYWwgcGxhY2VzLlxyXG4gICAgICAgICAgICAgIHNkIC09IHguZSArIDE7XHJcblxyXG4gICAgICAgICAgICAgIC8vIDEsIDAuMSwgMC4wMSwgMC4wMDEsIDAuMDAwMSBldGMuXHJcbiAgICAgICAgICAgICAgeGNbMF0gPSBwb3dzMTBbKExPR19CQVNFIC0gc2QgJSBMT0dfQkFTRSkgJSBMT0dfQkFTRV07XHJcbiAgICAgICAgICAgICAgeC5lID0gLXNkIHx8IDA7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgICAgICAgeGNbMF0gPSB4LmUgPSAwO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4geDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBSZW1vdmUgZXhjZXNzIGRpZ2l0cy5cclxuICAgICAgICAgIGlmIChpID09IDApIHtcclxuICAgICAgICAgICAgeGMubGVuZ3RoID0gbmk7XHJcbiAgICAgICAgICAgIGsgPSAxO1xyXG4gICAgICAgICAgICBuaS0tO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgeGMubGVuZ3RoID0gbmkgKyAxO1xyXG4gICAgICAgICAgICBrID0gcG93czEwW0xPR19CQVNFIC0gaV07XHJcblxyXG4gICAgICAgICAgICAvLyBFLmcuIDU2NzAwIGJlY29tZXMgNTYwMDAgaWYgNyBpcyB0aGUgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgICAgICAgIC8vIGogPiAwIG1lYW5zIGkgPiBudW1iZXIgb2YgbGVhZGluZyB6ZXJvcyBvZiBuLlxyXG4gICAgICAgICAgICB4Y1tuaV0gPSBqID4gMCA/IG1hdGhmbG9vcihuIC8gcG93czEwW2QgLSBqXSAlIHBvd3MxMFtqXSkgKiBrIDogMDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBSb3VuZCB1cD9cclxuICAgICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgICBmb3IgKDsgOykge1xyXG5cclxuICAgICAgICAgICAgICAvLyBJZiB0aGUgZGlnaXQgdG8gYmUgcm91bmRlZCB1cCBpcyBpbiB0aGUgZmlyc3QgZWxlbWVudCBvZiB4Yy4uLlxyXG4gICAgICAgICAgICAgIGlmIChuaSA9PSAwKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gaSB3aWxsIGJlIHRoZSBsZW5ndGggb2YgeGNbMF0gYmVmb3JlIGsgaXMgYWRkZWQuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAxLCBqID0geGNbMF07IGogPj0gMTA7IGogLz0gMTAsIGkrKyk7XHJcbiAgICAgICAgICAgICAgICBqID0geGNbMF0gKz0gaztcclxuICAgICAgICAgICAgICAgIGZvciAoayA9IDE7IGogPj0gMTA7IGogLz0gMTAsIGsrKyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gaWYgaSAhPSBrIHRoZSBsZW5ndGggaGFzIGluY3JlYXNlZC5cclxuICAgICAgICAgICAgICAgIGlmIChpICE9IGspIHtcclxuICAgICAgICAgICAgICAgICAgeC5lKys7XHJcbiAgICAgICAgICAgICAgICAgIGlmICh4Y1swXSA9PSBCQVNFKSB4Y1swXSA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHhjW25pXSArPSBrO1xyXG4gICAgICAgICAgICAgICAgaWYgKHhjW25pXSAhPSBCQVNFKSBicmVhaztcclxuICAgICAgICAgICAgICAgIHhjW25pLS1dID0gMDtcclxuICAgICAgICAgICAgICAgIGsgPSAxO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICAgIGZvciAoaSA9IHhjLmxlbmd0aDsgeGNbLS1pXSA9PT0gMDsgeGMucG9wKCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gT3ZlcmZsb3c/IEluZmluaXR5LlxyXG4gICAgICAgIGlmICh4LmUgPiBNQVhfRVhQKSB7XHJcbiAgICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG5cclxuICAgICAgICAvLyBVbmRlcmZsb3c/IFplcm8uXHJcbiAgICAgICAgfSBlbHNlIGlmICh4LmUgPCBNSU5fRVhQKSB7XHJcbiAgICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4geDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gdmFsdWVPZihuKSB7XHJcbiAgICAgIHZhciBzdHIsXHJcbiAgICAgICAgZSA9IG4uZTtcclxuXHJcbiAgICAgIGlmIChlID09PSBudWxsKSByZXR1cm4gbi50b1N0cmluZygpO1xyXG5cclxuICAgICAgc3RyID0gY29lZmZUb1N0cmluZyhuLmMpO1xyXG5cclxuICAgICAgc3RyID0gZSA8PSBUT19FWFBfTkVHIHx8IGUgPj0gVE9fRVhQX1BPU1xyXG4gICAgICAgID8gdG9FeHBvbmVudGlhbChzdHIsIGUpXHJcbiAgICAgICAgOiB0b0ZpeGVkUG9pbnQoc3RyLCBlLCAnMCcpO1xyXG5cclxuICAgICAgcmV0dXJuIG4ucyA8IDAgPyAnLScgKyBzdHIgOiBzdHI7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIFBST1RPVFlQRS9JTlNUQU5DRSBNRVRIT0RTXHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlci5cclxuICAgICAqL1xyXG4gICAgUC5hYnNvbHV0ZVZhbHVlID0gUC5hYnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciB4ID0gbmV3IEJpZ051bWJlcih0aGlzKTtcclxuICAgICAgaWYgKHgucyA8IDApIHgucyA9IDE7XHJcbiAgICAgIHJldHVybiB4O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVyblxyXG4gICAgICogICAxIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBncmVhdGVyIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAqICAgLTEgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGxlc3MgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICogICAwIGlmIHRoZXkgaGF2ZSB0aGUgc2FtZSB2YWx1ZSxcclxuICAgICAqICAgb3IgbnVsbCBpZiB0aGUgdmFsdWUgb2YgZWl0aGVyIGlzIE5hTi5cclxuICAgICAqL1xyXG4gICAgUC5jb21wYXJlZFRvID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogSWYgZHAgaXMgdW5kZWZpbmVkIG9yIG51bGwgb3IgdHJ1ZSBvciBmYWxzZSwgcmV0dXJuIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgb2YgdGhlXHJcbiAgICAgKiB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciwgb3IgbnVsbCBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgwrFJbmZpbml0eSBvciBOYU4uXHJcbiAgICAgKlxyXG4gICAgICogT3RoZXJ3aXNlLCBpZiBkcCBpcyBhIG51bWJlciwgcmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpc1xyXG4gICAgICogQmlnTnVtYmVyIHJvdW5kZWQgdG8gYSBtYXhpbXVtIG9mIGRwIGRlY2ltYWwgcGxhY2VzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yXHJcbiAgICAgKiBST1VORElOR19NT0RFIGlmIHJtIGlzIG9taXR0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlczogaW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB8cm19J1xyXG4gICAgICovXHJcbiAgICBQLmRlY2ltYWxQbGFjZXMgPSBQLmRwID0gZnVuY3Rpb24gKGRwLCBybSkge1xyXG4gICAgICB2YXIgYywgbiwgdixcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIGlmIChkcCAhPSBudWxsKSB7XHJcbiAgICAgICAgaW50Q2hlY2soZHAsIDAsIE1BWCk7XHJcbiAgICAgICAgaWYgKHJtID09IG51bGwpIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuICAgICAgICBlbHNlIGludENoZWNrKHJtLCAwLCA4KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJvdW5kKG5ldyBCaWdOdW1iZXIoeCksIGRwICsgeC5lICsgMSwgcm0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIShjID0geC5jKSkgcmV0dXJuIG51bGw7XHJcbiAgICAgIG4gPSAoKHYgPSBjLmxlbmd0aCAtIDEpIC0gYml0Rmxvb3IodGhpcy5lIC8gTE9HX0JBU0UpKSAqIExPR19CQVNFO1xyXG5cclxuICAgICAgLy8gU3VidHJhY3QgdGhlIG51bWJlciBvZiB0cmFpbGluZyB6ZXJvcyBvZiB0aGUgbGFzdCBudW1iZXIuXHJcbiAgICAgIGlmICh2ID0gY1t2XSkgZm9yICg7IHYgJSAxMCA9PSAwOyB2IC89IDEwLCBuLS0pO1xyXG4gICAgICBpZiAobiA8IDApIG4gPSAwO1xyXG5cclxuICAgICAgcmV0dXJuIG47XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIG4gLyAwID0gSVxyXG4gICAgICogIG4gLyBOID0gTlxyXG4gICAgICogIG4gLyBJID0gMFxyXG4gICAgICogIDAgLyBuID0gMFxyXG4gICAgICogIDAgLyAwID0gTlxyXG4gICAgICogIDAgLyBOID0gTlxyXG4gICAgICogIDAgLyBJID0gMFxyXG4gICAgICogIE4gLyBuID0gTlxyXG4gICAgICogIE4gLyAwID0gTlxyXG4gICAgICogIE4gLyBOID0gTlxyXG4gICAgICogIE4gLyBJID0gTlxyXG4gICAgICogIEkgLyBuID0gSVxyXG4gICAgICogIEkgLyAwID0gSVxyXG4gICAgICogIEkgLyBOID0gTlxyXG4gICAgICogIEkgLyBJID0gTlxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGRpdmlkZWQgYnkgdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYiksIHJvdW5kZWQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZCBST1VORElOR19NT0RFLlxyXG4gICAgICovXHJcbiAgICBQLmRpdmlkZWRCeSA9IFAuZGl2ID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGRpdih0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpLCBERUNJTUFMX1BMQUNFUywgUk9VTkRJTkdfTU9ERSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgaW50ZWdlciBwYXJ0IG9mIGRpdmlkaW5nIHRoZSB2YWx1ZSBvZiB0aGlzXHJcbiAgICAgKiBCaWdOdW1iZXIgYnkgdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKS5cclxuICAgICAqL1xyXG4gICAgUC5kaXZpZGVkVG9JbnRlZ2VyQnkgPSBQLmlkaXYgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gZGl2KHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYiksIDAsIDEpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgZXhwb25lbnRpYXRlZCBieSBuLlxyXG4gICAgICpcclxuICAgICAqIElmIG0gaXMgcHJlc2VudCwgcmV0dXJuIHRoZSByZXN1bHQgbW9kdWxvIG0uXHJcbiAgICAgKiBJZiBuIGlzIG5lZ2F0aXZlIHJvdW5kIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmQgUk9VTkRJTkdfTU9ERS5cclxuICAgICAqIElmIFBPV19QUkVDSVNJT04gaXMgbm9uLXplcm8gYW5kIG0gaXMgbm90IHByZXNlbnQsIHJvdW5kIHRvIFBPV19QUkVDSVNJT04gdXNpbmcgUk9VTkRJTkdfTU9ERS5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgbW9kdWxhciBwb3dlciBvcGVyYXRpb24gd29ya3MgZWZmaWNpZW50bHkgd2hlbiB4LCBuLCBhbmQgbSBhcmUgaW50ZWdlcnMsIG90aGVyd2lzZSBpdFxyXG4gICAgICogaXMgZXF1aXZhbGVudCB0byBjYWxjdWxhdGluZyB4LmV4cG9uZW50aWF0ZWRCeShuKS5tb2R1bG8obSkgd2l0aCBhIFBPV19QUkVDSVNJT04gb2YgMC5cclxuICAgICAqXHJcbiAgICAgKiBuIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gVGhlIGV4cG9uZW50LiBBbiBpbnRlZ2VyLlxyXG4gICAgICogW21dIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gVGhlIG1vZHVsdXMuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEV4cG9uZW50IG5vdCBhbiBpbnRlZ2VyOiB7bn0nXHJcbiAgICAgKi9cclxuICAgIFAuZXhwb25lbnRpYXRlZEJ5ID0gUC5wb3cgPSBmdW5jdGlvbiAobiwgbSkge1xyXG4gICAgICB2YXIgaGFsZiwgaXNNb2RFeHAsIGksIGssIG1vcmUsIG5Jc0JpZywgbklzTmVnLCBuSXNPZGQsIHksXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICBuID0gbmV3IEJpZ051bWJlcihuKTtcclxuXHJcbiAgICAgIC8vIEFsbG93IE5hTiBhbmQgwrFJbmZpbml0eSwgYnV0IG5vdCBvdGhlciBub24taW50ZWdlcnMuXHJcbiAgICAgIGlmIChuLmMgJiYgIW4uaXNJbnRlZ2VyKCkpIHtcclxuICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ0V4cG9uZW50IG5vdCBhbiBpbnRlZ2VyOiAnICsgdmFsdWVPZihuKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChtICE9IG51bGwpIG0gPSBuZXcgQmlnTnVtYmVyKG0pO1xyXG5cclxuICAgICAgLy8gRXhwb25lbnQgb2YgTUFYX1NBRkVfSU5URUdFUiBpcyAxNS5cclxuICAgICAgbklzQmlnID0gbi5lID4gMTQ7XHJcblxyXG4gICAgICAvLyBJZiB4IGlzIE5hTiwgwrFJbmZpbml0eSwgwrEwIG9yIMKxMSwgb3IgbiBpcyDCsUluZmluaXR5LCBOYU4gb3IgwrEwLlxyXG4gICAgICBpZiAoIXguYyB8fCAheC5jWzBdIHx8IHguY1swXSA9PSAxICYmICF4LmUgJiYgeC5jLmxlbmd0aCA9PSAxIHx8ICFuLmMgfHwgIW4uY1swXSkge1xyXG5cclxuICAgICAgICAvLyBUaGUgc2lnbiBvZiB0aGUgcmVzdWx0IG9mIHBvdyB3aGVuIHggaXMgbmVnYXRpdmUgZGVwZW5kcyBvbiB0aGUgZXZlbm5lc3Mgb2Ygbi5cclxuICAgICAgICAvLyBJZiArbiBvdmVyZmxvd3MgdG8gwrFJbmZpbml0eSwgdGhlIGV2ZW5uZXNzIG9mIG4gd291bGQgYmUgbm90IGJlIGtub3duLlxyXG4gICAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKE1hdGgucG93KCt2YWx1ZU9mKHgpLCBuSXNCaWcgPyAyIC0gaXNPZGQobikgOiArdmFsdWVPZihuKSkpO1xyXG4gICAgICAgIHJldHVybiBtID8geS5tb2QobSkgOiB5O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBuSXNOZWcgPSBuLnMgPCAwO1xyXG5cclxuICAgICAgaWYgKG0pIHtcclxuXHJcbiAgICAgICAgLy8geCAlIG0gcmV0dXJucyBOYU4gaWYgYWJzKG0pIGlzIHplcm8sIG9yIG0gaXMgTmFOLlxyXG4gICAgICAgIGlmIChtLmMgPyAhbS5jWzBdIDogIW0ucykgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAgICAgaXNNb2RFeHAgPSAhbklzTmVnICYmIHguaXNJbnRlZ2VyKCkgJiYgbS5pc0ludGVnZXIoKTtcclxuXHJcbiAgICAgICAgaWYgKGlzTW9kRXhwKSB4ID0geC5tb2QobSk7XHJcblxyXG4gICAgICAvLyBPdmVyZmxvdyB0byDCsUluZmluaXR5OiA+PTIqKjFlMTAgb3IgPj0xLjAwMDAwMjQqKjFlMTUuXHJcbiAgICAgIC8vIFVuZGVyZmxvdyB0byDCsTA6IDw9MC43OSoqMWUxMCBvciA8PTAuOTk5OTk3NSoqMWUxNS5cclxuICAgICAgfSBlbHNlIGlmIChuLmUgPiA5ICYmICh4LmUgPiAwIHx8IHguZSA8IC0xIHx8ICh4LmUgPT0gMFxyXG4gICAgICAgIC8vIFsxLCAyNDAwMDAwMDBdXHJcbiAgICAgICAgPyB4LmNbMF0gPiAxIHx8IG5Jc0JpZyAmJiB4LmNbMV0gPj0gMjRlN1xyXG4gICAgICAgIC8vIFs4MDAwMDAwMDAwMDAwMF0gIFs5OTk5OTc1MDAwMDAwMF1cclxuICAgICAgICA6IHguY1swXSA8IDhlMTMgfHwgbklzQmlnICYmIHguY1swXSA8PSA5OTk5OTc1ZTcpKSkge1xyXG5cclxuICAgICAgICAvLyBJZiB4IGlzIG5lZ2F0aXZlIGFuZCBuIGlzIG9kZCwgayA9IC0wLCBlbHNlIGsgPSAwLlxyXG4gICAgICAgIGsgPSB4LnMgPCAwICYmIGlzT2RkKG4pID8gLTAgOiAwO1xyXG5cclxuICAgICAgICAvLyBJZiB4ID49IDEsIGsgPSDCsUluZmluaXR5LlxyXG4gICAgICAgIGlmICh4LmUgPiAtMSkgayA9IDEgLyBrO1xyXG5cclxuICAgICAgICAvLyBJZiBuIGlzIG5lZ2F0aXZlIHJldHVybiDCsTAsIGVsc2UgcmV0dXJuIMKxSW5maW5pdHkuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIobklzTmVnID8gMSAvIGsgOiBrKTtcclxuXHJcbiAgICAgIH0gZWxzZSBpZiAoUE9XX1BSRUNJU0lPTikge1xyXG5cclxuICAgICAgICAvLyBUcnVuY2F0aW5nIGVhY2ggY29lZmZpY2llbnQgYXJyYXkgdG8gYSBsZW5ndGggb2YgayBhZnRlciBlYWNoIG11bHRpcGxpY2F0aW9uXHJcbiAgICAgICAgLy8gZXF1YXRlcyB0byB0cnVuY2F0aW5nIHNpZ25pZmljYW50IGRpZ2l0cyB0byBQT1dfUFJFQ0lTSU9OICsgWzI4LCA0MV0sXHJcbiAgICAgICAgLy8gaS5lLiB0aGVyZSB3aWxsIGJlIGEgbWluaW11bSBvZiAyOCBndWFyZCBkaWdpdHMgcmV0YWluZWQuXHJcbiAgICAgICAgayA9IG1hdGhjZWlsKFBPV19QUkVDSVNJT04gLyBMT0dfQkFTRSArIDIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAobklzQmlnKSB7XHJcbiAgICAgICAgaGFsZiA9IG5ldyBCaWdOdW1iZXIoMC41KTtcclxuICAgICAgICBpZiAobklzTmVnKSBuLnMgPSAxO1xyXG4gICAgICAgIG5Jc09kZCA9IGlzT2RkKG4pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGkgPSBNYXRoLmFicygrdmFsdWVPZihuKSk7XHJcbiAgICAgICAgbklzT2RkID0gaSAlIDI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcblxyXG4gICAgICAvLyBQZXJmb3JtcyA1NCBsb29wIGl0ZXJhdGlvbnMgZm9yIG4gb2YgOTAwNzE5OTI1NDc0MDk5MS5cclxuICAgICAgZm9yICg7IDspIHtcclxuXHJcbiAgICAgICAgaWYgKG5Jc09kZCkge1xyXG4gICAgICAgICAgeSA9IHkudGltZXMoeCk7XHJcbiAgICAgICAgICBpZiAoIXkuYykgYnJlYWs7XHJcblxyXG4gICAgICAgICAgaWYgKGspIHtcclxuICAgICAgICAgICAgaWYgKHkuYy5sZW5ndGggPiBrKSB5LmMubGVuZ3RoID0gaztcclxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNNb2RFeHApIHtcclxuICAgICAgICAgICAgeSA9IHkubW9kKG0pOyAgICAvL3kgPSB5Lm1pbnVzKGRpdih5LCBtLCAwLCBNT0RVTE9fTU9ERSkudGltZXMobSkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGkpIHtcclxuICAgICAgICAgIGkgPSBtYXRoZmxvb3IoaSAvIDIpO1xyXG4gICAgICAgICAgaWYgKGkgPT09IDApIGJyZWFrO1xyXG4gICAgICAgICAgbklzT2RkID0gaSAlIDI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG4gPSBuLnRpbWVzKGhhbGYpO1xyXG4gICAgICAgICAgcm91bmQobiwgbi5lICsgMSwgMSk7XHJcblxyXG4gICAgICAgICAgaWYgKG4uZSA+IDE0KSB7XHJcbiAgICAgICAgICAgIG5Jc09kZCA9IGlzT2RkKG4pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaSA9ICt2YWx1ZU9mKG4pO1xyXG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkgYnJlYWs7XHJcbiAgICAgICAgICAgIG5Jc09kZCA9IGkgJSAyO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgeCA9IHgudGltZXMoeCk7XHJcblxyXG4gICAgICAgIGlmIChrKSB7XHJcbiAgICAgICAgICBpZiAoeC5jICYmIHguYy5sZW5ndGggPiBrKSB4LmMubGVuZ3RoID0gaztcclxuICAgICAgICB9IGVsc2UgaWYgKGlzTW9kRXhwKSB7XHJcbiAgICAgICAgICB4ID0geC5tb2QobSk7ICAgIC8veCA9IHgubWludXMoZGl2KHgsIG0sIDAsIE1PRFVMT19NT0RFKS50aW1lcyhtKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaXNNb2RFeHApIHJldHVybiB5O1xyXG4gICAgICBpZiAobklzTmVnKSB5ID0gT05FLmRpdih5KTtcclxuXHJcbiAgICAgIHJldHVybiBtID8geS5tb2QobSkgOiBrID8gcm91bmQoeSwgUE9XX1BSRUNJU0lPTiwgUk9VTkRJTkdfTU9ERSwgbW9yZSkgOiB5O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHJvdW5kZWQgdG8gYW4gaW50ZWdlclxyXG4gICAgICogdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3IgUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAgICpcclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3JtfSdcclxuICAgICAqL1xyXG4gICAgUC5pbnRlZ2VyVmFsdWUgPSBmdW5jdGlvbiAocm0pIHtcclxuICAgICAgdmFyIG4gPSBuZXcgQmlnTnVtYmVyKHRoaXMpO1xyXG4gICAgICBpZiAocm0gPT0gbnVsbCkgcm0gPSBST1VORElOR19NT0RFO1xyXG4gICAgICBlbHNlIGludENoZWNrKHJtLCAwLCA4KTtcclxuICAgICAgcmV0dXJuIHJvdW5kKG4sIG4uZSArIDEsIHJtKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZXF1YWwgdG8gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAqIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNFcXVhbFRvID0gUC5lcSA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpID09PSAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBhIGZpbml0ZSBudW1iZXIsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNGaW5pdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiAhIXRoaXMuYztcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZ3JlYXRlciB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgKiBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzR3JlYXRlclRoYW4gPSBQLmd0ID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkgPiAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYiksIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNHcmVhdGVyVGhhbk9yRXF1YWxUbyA9IFAuZ3RlID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIChiID0gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSkgPT09IDEgfHwgYiA9PT0gMDtcclxuXHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGFuIGludGVnZXIsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNJbnRlZ2VyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gISF0aGlzLmMgJiYgYml0Rmxvb3IodGhpcy5lIC8gTE9HX0JBU0UpID4gdGhpcy5jLmxlbmd0aCAtIDI7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGxlc3MgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICogb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0xlc3NUaGFuID0gUC5sdCA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpIDwgMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzTGVzc1RoYW5PckVxdWFsVG8gPSBQLmx0ZSA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiAoYiA9IGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkpID09PSAtMSB8fCBiID09PSAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBOYU4sIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNOYU4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiAhdGhpcy5zO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBuZWdhdGl2ZSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc05lZ2F0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5zIDwgMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgcG9zaXRpdmUsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNQb3NpdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucyA+IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIDAgb3IgLTAsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNaZXJvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gISF0aGlzLmMgJiYgdGhpcy5jWzBdID09IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIG4gLSAwID0gblxyXG4gICAgICogIG4gLSBOID0gTlxyXG4gICAgICogIG4gLSBJID0gLUlcclxuICAgICAqICAwIC0gbiA9IC1uXHJcbiAgICAgKiAgMCAtIDAgPSAwXHJcbiAgICAgKiAgMCAtIE4gPSBOXHJcbiAgICAgKiAgMCAtIEkgPSAtSVxyXG4gICAgICogIE4gLSBuID0gTlxyXG4gICAgICogIE4gLSAwID0gTlxyXG4gICAgICogIE4gLSBOID0gTlxyXG4gICAgICogIE4gLSBJID0gTlxyXG4gICAgICogIEkgLSBuID0gSVxyXG4gICAgICogIEkgLSAwID0gSVxyXG4gICAgICogIEkgLSBOID0gTlxyXG4gICAgICogIEkgLSBJID0gTlxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG1pbnVzIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLlxyXG4gICAgICovXHJcbiAgICBQLm1pbnVzID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgdmFyIGksIGosIHQsIHhMVHksXHJcbiAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgYSA9IHgucztcclxuXHJcbiAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKHksIGIpO1xyXG4gICAgICBiID0geS5zO1xyXG5cclxuICAgICAgLy8gRWl0aGVyIE5hTj9cclxuICAgICAgaWYgKCFhIHx8ICFiKSByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgICAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gICAgICBpZiAoYSAhPSBiKSB7XHJcbiAgICAgICAgeS5zID0gLWI7XHJcbiAgICAgICAgcmV0dXJuIHgucGx1cyh5KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHhlID0geC5lIC8gTE9HX0JBU0UsXHJcbiAgICAgICAgeWUgPSB5LmUgLyBMT0dfQkFTRSxcclxuICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICB5YyA9IHkuYztcclxuXHJcbiAgICAgIGlmICgheGUgfHwgIXllKSB7XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciBJbmZpbml0eT9cclxuICAgICAgICBpZiAoIXhjIHx8ICF5YykgcmV0dXJuIHhjID8gKHkucyA9IC1iLCB5KSA6IG5ldyBCaWdOdW1iZXIoeWMgPyB4IDogTmFOKTtcclxuXHJcbiAgICAgICAgLy8gRWl0aGVyIHplcm8/XHJcbiAgICAgICAgaWYgKCF4Y1swXSB8fCAheWNbMF0pIHtcclxuXHJcbiAgICAgICAgICAvLyBSZXR1cm4geSBpZiB5IGlzIG5vbi16ZXJvLCB4IGlmIHggaXMgbm9uLXplcm8sIG9yIHplcm8gaWYgYm90aCBhcmUgemVyby5cclxuICAgICAgICAgIHJldHVybiB5Y1swXSA/ICh5LnMgPSAtYiwgeSkgOiBuZXcgQmlnTnVtYmVyKHhjWzBdID8geCA6XHJcblxyXG4gICAgICAgICAgIC8vIElFRUUgNzU0ICgyMDA4KSA2LjM6IG4gLSBuID0gLTAgd2hlbiByb3VuZGluZyB0byAtSW5maW5pdHlcclxuICAgICAgICAgICBST1VORElOR19NT0RFID09IDMgPyAtMCA6IDApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgeGUgPSBiaXRGbG9vcih4ZSk7XHJcbiAgICAgIHllID0gYml0Rmxvb3IoeWUpO1xyXG4gICAgICB4YyA9IHhjLnNsaWNlKCk7XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggaXMgdGhlIGJpZ2dlciBudW1iZXIuXHJcbiAgICAgIGlmIChhID0geGUgLSB5ZSkge1xyXG5cclxuICAgICAgICBpZiAoeExUeSA9IGEgPCAwKSB7XHJcbiAgICAgICAgICBhID0gLWE7XHJcbiAgICAgICAgICB0ID0geGM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHllID0geGU7XHJcbiAgICAgICAgICB0ID0geWM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0LnJldmVyc2UoKTtcclxuXHJcbiAgICAgICAgLy8gUHJlcGVuZCB6ZXJvcyB0byBlcXVhbGlzZSBleHBvbmVudHMuXHJcbiAgICAgICAgZm9yIChiID0gYTsgYi0tOyB0LnB1c2goMCkpO1xyXG4gICAgICAgIHQucmV2ZXJzZSgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBFeHBvbmVudHMgZXF1YWwuIENoZWNrIGRpZ2l0IGJ5IGRpZ2l0LlxyXG4gICAgICAgIGogPSAoeExUeSA9IChhID0geGMubGVuZ3RoKSA8IChiID0geWMubGVuZ3RoKSkgPyBhIDogYjtcclxuXHJcbiAgICAgICAgZm9yIChhID0gYiA9IDA7IGIgPCBqOyBiKyspIHtcclxuXHJcbiAgICAgICAgICBpZiAoeGNbYl0gIT0geWNbYl0pIHtcclxuICAgICAgICAgICAgeExUeSA9IHhjW2JdIDwgeWNbYl07XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8geCA8IHk/IFBvaW50IHhjIHRvIHRoZSBhcnJheSBvZiB0aGUgYmlnZ2VyIG51bWJlci5cclxuICAgICAgaWYgKHhMVHkpIHQgPSB4YywgeGMgPSB5YywgeWMgPSB0LCB5LnMgPSAteS5zO1xyXG5cclxuICAgICAgYiA9IChqID0geWMubGVuZ3RoKSAtIChpID0geGMubGVuZ3RoKTtcclxuXHJcbiAgICAgIC8vIEFwcGVuZCB6ZXJvcyB0byB4YyBpZiBzaG9ydGVyLlxyXG4gICAgICAvLyBObyBuZWVkIHRvIGFkZCB6ZXJvcyB0byB5YyBpZiBzaG9ydGVyIGFzIHN1YnRyYWN0IG9ubHkgbmVlZHMgdG8gc3RhcnQgYXQgeWMubGVuZ3RoLlxyXG4gICAgICBpZiAoYiA+IDApIGZvciAoOyBiLS07IHhjW2krK10gPSAwKTtcclxuICAgICAgYiA9IEJBU0UgLSAxO1xyXG5cclxuICAgICAgLy8gU3VidHJhY3QgeWMgZnJvbSB4Yy5cclxuICAgICAgZm9yICg7IGogPiBhOykge1xyXG5cclxuICAgICAgICBpZiAoeGNbLS1qXSA8IHljW2pdKSB7XHJcbiAgICAgICAgICBmb3IgKGkgPSBqOyBpICYmICF4Y1stLWldOyB4Y1tpXSA9IGIpO1xyXG4gICAgICAgICAgLS14Y1tpXTtcclxuICAgICAgICAgIHhjW2pdICs9IEJBU0U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB4Y1tqXSAtPSB5Y1tqXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgemVyb3MgYW5kIGFkanVzdCBleHBvbmVudCBhY2NvcmRpbmdseS5cclxuICAgICAgZm9yICg7IHhjWzBdID09IDA7IHhjLnNwbGljZSgwLCAxKSwgLS15ZSk7XHJcblxyXG4gICAgICAvLyBaZXJvP1xyXG4gICAgICBpZiAoIXhjWzBdKSB7XHJcblxyXG4gICAgICAgIC8vIEZvbGxvd2luZyBJRUVFIDc1NCAoMjAwOCkgNi4zLFxyXG4gICAgICAgIC8vIG4gLSBuID0gKzAgIGJ1dCAgbiAtIG4gPSAtMCAgd2hlbiByb3VuZGluZyB0b3dhcmRzIC1JbmZpbml0eS5cclxuICAgICAgICB5LnMgPSBST1VORElOR19NT0RFID09IDMgPyAtMSA6IDE7XHJcbiAgICAgICAgeS5jID0gW3kuZSA9IDBdO1xyXG4gICAgICAgIHJldHVybiB5O1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBObyBuZWVkIHRvIGNoZWNrIGZvciBJbmZpbml0eSBhcyAreCAtICt5ICE9IEluZmluaXR5ICYmIC14IC0gLXkgIT0gSW5maW5pdHlcclxuICAgICAgLy8gZm9yIGZpbml0ZSB4IGFuZCB5LlxyXG4gICAgICByZXR1cm4gbm9ybWFsaXNlKHksIHhjLCB5ZSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogICBuICUgMCA9ICBOXHJcbiAgICAgKiAgIG4gJSBOID0gIE5cclxuICAgICAqICAgbiAlIEkgPSAgblxyXG4gICAgICogICAwICUgbiA9ICAwXHJcbiAgICAgKiAgLTAgJSBuID0gLTBcclxuICAgICAqICAgMCAlIDAgPSAgTlxyXG4gICAgICogICAwICUgTiA9ICBOXHJcbiAgICAgKiAgIDAgJSBJID0gIDBcclxuICAgICAqICAgTiAlIG4gPSAgTlxyXG4gICAgICogICBOICUgMCA9ICBOXHJcbiAgICAgKiAgIE4gJSBOID0gIE5cclxuICAgICAqICAgTiAlIEkgPSAgTlxyXG4gICAgICogICBJICUgbiA9ICBOXHJcbiAgICAgKiAgIEkgJSAwID0gIE5cclxuICAgICAqICAgSSAlIE4gPSAgTlxyXG4gICAgICogICBJICUgSSA9ICBOXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbW9kdWxvIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLiBUaGUgcmVzdWx0IGRlcGVuZHMgb24gdGhlIHZhbHVlIG9mIE1PRFVMT19NT0RFLlxyXG4gICAgICovXHJcbiAgICBQLm1vZHVsbyA9IFAubW9kID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgdmFyIHEsIHMsXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICB5ID0gbmV3IEJpZ051bWJlcih5LCBiKTtcclxuXHJcbiAgICAgIC8vIFJldHVybiBOYU4gaWYgeCBpcyBJbmZpbml0eSBvciBOYU4sIG9yIHkgaXMgTmFOIG9yIHplcm8uXHJcbiAgICAgIGlmICgheC5jIHx8ICF5LnMgfHwgeS5jICYmICF5LmNbMF0pIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgICAgLy8gUmV0dXJuIHggaWYgeSBpcyBJbmZpbml0eSBvciB4IGlzIHplcm8uXHJcbiAgICAgIH0gZWxzZSBpZiAoIXkuYyB8fCB4LmMgJiYgIXguY1swXSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKHgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoTU9EVUxPX01PREUgPT0gOSkge1xyXG5cclxuICAgICAgICAvLyBFdWNsaWRpYW4gZGl2aXNpb246IHEgPSBzaWduKHkpICogZmxvb3IoeCAvIGFicyh5KSlcclxuICAgICAgICAvLyByID0geCAtIHF5ICAgIHdoZXJlICAwIDw9IHIgPCBhYnMoeSlcclxuICAgICAgICBzID0geS5zO1xyXG4gICAgICAgIHkucyA9IDE7XHJcbiAgICAgICAgcSA9IGRpdih4LCB5LCAwLCAzKTtcclxuICAgICAgICB5LnMgPSBzO1xyXG4gICAgICAgIHEucyAqPSBzO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHEgPSBkaXYoeCwgeSwgMCwgTU9EVUxPX01PREUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB5ID0geC5taW51cyhxLnRpbWVzKHkpKTtcclxuXHJcbiAgICAgIC8vIFRvIG1hdGNoIEphdmFTY3JpcHQgJSwgZW5zdXJlIHNpZ24gb2YgemVybyBpcyBzaWduIG9mIGRpdmlkZW5kLlxyXG4gICAgICBpZiAoIXkuY1swXSAmJiBNT0RVTE9fTU9ERSA9PSAxKSB5LnMgPSB4LnM7XHJcblxyXG4gICAgICByZXR1cm4geTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgbiAqIDAgPSAwXHJcbiAgICAgKiAgbiAqIE4gPSBOXHJcbiAgICAgKiAgbiAqIEkgPSBJXHJcbiAgICAgKiAgMCAqIG4gPSAwXHJcbiAgICAgKiAgMCAqIDAgPSAwXHJcbiAgICAgKiAgMCAqIE4gPSBOXHJcbiAgICAgKiAgMCAqIEkgPSBOXHJcbiAgICAgKiAgTiAqIG4gPSBOXHJcbiAgICAgKiAgTiAqIDAgPSBOXHJcbiAgICAgKiAgTiAqIE4gPSBOXHJcbiAgICAgKiAgTiAqIEkgPSBOXHJcbiAgICAgKiAgSSAqIG4gPSBJXHJcbiAgICAgKiAgSSAqIDAgPSBOXHJcbiAgICAgKiAgSSAqIE4gPSBOXHJcbiAgICAgKiAgSSAqIEkgPSBJXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbXVsdGlwbGllZCBieSB0aGUgdmFsdWVcclxuICAgICAqIG9mIEJpZ051bWJlcih5LCBiKS5cclxuICAgICAqL1xyXG4gICAgUC5tdWx0aXBsaWVkQnkgPSBQLnRpbWVzID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgdmFyIGMsIGUsIGksIGosIGssIG0sIHhjTCwgeGxvLCB4aGksIHljTCwgeWxvLCB5aGksIHpjLFxyXG4gICAgICAgIGJhc2UsIHNxcnRCYXNlLFxyXG4gICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgIHljID0gKHkgPSBuZXcgQmlnTnVtYmVyKHksIGIpKS5jO1xyXG5cclxuICAgICAgLy8gRWl0aGVyIE5hTiwgwrFJbmZpbml0eSBvciDCsTA/XHJcbiAgICAgIGlmICgheGMgfHwgIXljIHx8ICF4Y1swXSB8fCAheWNbMF0pIHtcclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIE5hTiBpZiBlaXRoZXIgaXMgTmFOLCBvciBvbmUgaXMgMCBhbmQgdGhlIG90aGVyIGlzIEluZmluaXR5LlxyXG4gICAgICAgIGlmICgheC5zIHx8ICF5LnMgfHwgeGMgJiYgIXhjWzBdICYmICF5YyB8fCB5YyAmJiAheWNbMF0gJiYgIXhjKSB7XHJcbiAgICAgICAgICB5LmMgPSB5LmUgPSB5LnMgPSBudWxsO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB5LnMgKj0geC5zO1xyXG5cclxuICAgICAgICAgIC8vIFJldHVybiDCsUluZmluaXR5IGlmIGVpdGhlciBpcyDCsUluZmluaXR5LlxyXG4gICAgICAgICAgaWYgKCF4YyB8fCAheWMpIHtcclxuICAgICAgICAgICAgeS5jID0geS5lID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAvLyBSZXR1cm4gwrEwIGlmIGVpdGhlciBpcyDCsTAuXHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB5LmMgPSBbMF07XHJcbiAgICAgICAgICAgIHkuZSA9IDA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4geTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZSA9IGJpdEZsb29yKHguZSAvIExPR19CQVNFKSArIGJpdEZsb29yKHkuZSAvIExPR19CQVNFKTtcclxuICAgICAgeS5zICo9IHgucztcclxuICAgICAgeGNMID0geGMubGVuZ3RoO1xyXG4gICAgICB5Y0wgPSB5Yy5sZW5ndGg7XHJcblxyXG4gICAgICAvLyBFbnN1cmUgeGMgcG9pbnRzIHRvIGxvbmdlciBhcnJheSBhbmQgeGNMIHRvIGl0cyBsZW5ndGguXHJcbiAgICAgIGlmICh4Y0wgPCB5Y0wpIHpjID0geGMsIHhjID0geWMsIHljID0gemMsIGkgPSB4Y0wsIHhjTCA9IHljTCwgeWNMID0gaTtcclxuXHJcbiAgICAgIC8vIEluaXRpYWxpc2UgdGhlIHJlc3VsdCBhcnJheSB3aXRoIHplcm9zLlxyXG4gICAgICBmb3IgKGkgPSB4Y0wgKyB5Y0wsIHpjID0gW107IGktLTsgemMucHVzaCgwKSk7XHJcblxyXG4gICAgICBiYXNlID0gQkFTRTtcclxuICAgICAgc3FydEJhc2UgPSBTUVJUX0JBU0U7XHJcblxyXG4gICAgICBmb3IgKGkgPSB5Y0w7IC0taSA+PSAwOykge1xyXG4gICAgICAgIGMgPSAwO1xyXG4gICAgICAgIHlsbyA9IHljW2ldICUgc3FydEJhc2U7XHJcbiAgICAgICAgeWhpID0geWNbaV0gLyBzcXJ0QmFzZSB8IDA7XHJcblxyXG4gICAgICAgIGZvciAoayA9IHhjTCwgaiA9IGkgKyBrOyBqID4gaTspIHtcclxuICAgICAgICAgIHhsbyA9IHhjWy0ta10gJSBzcXJ0QmFzZTtcclxuICAgICAgICAgIHhoaSA9IHhjW2tdIC8gc3FydEJhc2UgfCAwO1xyXG4gICAgICAgICAgbSA9IHloaSAqIHhsbyArIHhoaSAqIHlsbztcclxuICAgICAgICAgIHhsbyA9IHlsbyAqIHhsbyArICgobSAlIHNxcnRCYXNlKSAqIHNxcnRCYXNlKSArIHpjW2pdICsgYztcclxuICAgICAgICAgIGMgPSAoeGxvIC8gYmFzZSB8IDApICsgKG0gLyBzcXJ0QmFzZSB8IDApICsgeWhpICogeGhpO1xyXG4gICAgICAgICAgemNbai0tXSA9IHhsbyAlIGJhc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB6Y1tqXSA9IGM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChjKSB7XHJcbiAgICAgICAgKytlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHpjLnNwbGljZSgwLCAxKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG5vcm1hbGlzZSh5LCB6YywgZSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbmVnYXRlZCxcclxuICAgICAqIGkuZS4gbXVsdGlwbGllZCBieSAtMS5cclxuICAgICAqL1xyXG4gICAgUC5uZWdhdGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgeCA9IG5ldyBCaWdOdW1iZXIodGhpcyk7XHJcbiAgICAgIHgucyA9IC14LnMgfHwgbnVsbDtcclxuICAgICAgcmV0dXJuIHg7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIG4gKyAwID0gblxyXG4gICAgICogIG4gKyBOID0gTlxyXG4gICAgICogIG4gKyBJID0gSVxyXG4gICAgICogIDAgKyBuID0gblxyXG4gICAgICogIDAgKyAwID0gMFxyXG4gICAgICogIDAgKyBOID0gTlxyXG4gICAgICogIDAgKyBJID0gSVxyXG4gICAgICogIE4gKyBuID0gTlxyXG4gICAgICogIE4gKyAwID0gTlxyXG4gICAgICogIE4gKyBOID0gTlxyXG4gICAgICogIE4gKyBJID0gTlxyXG4gICAgICogIEkgKyBuID0gSVxyXG4gICAgICogIEkgKyAwID0gSVxyXG4gICAgICogIEkgKyBOID0gTlxyXG4gICAgICogIEkgKyBJID0gSVxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHBsdXMgdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICAgKi9cclxuICAgIFAucGx1cyA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHZhciB0LFxyXG4gICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgIGEgPSB4LnM7XHJcblxyXG4gICAgICB5ID0gbmV3IEJpZ051bWJlcih5LCBiKTtcclxuICAgICAgYiA9IHkucztcclxuXHJcbiAgICAgIC8vIEVpdGhlciBOYU4/XHJcbiAgICAgIGlmICghYSB8fCAhYikgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAgIC8vIFNpZ25zIGRpZmZlcj9cclxuICAgICAgIGlmIChhICE9IGIpIHtcclxuICAgICAgICB5LnMgPSAtYjtcclxuICAgICAgICByZXR1cm4geC5taW51cyh5KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHhlID0geC5lIC8gTE9HX0JBU0UsXHJcbiAgICAgICAgeWUgPSB5LmUgLyBMT0dfQkFTRSxcclxuICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICB5YyA9IHkuYztcclxuXHJcbiAgICAgIGlmICgheGUgfHwgIXllKSB7XHJcblxyXG4gICAgICAgIC8vIFJldHVybiDCsUluZmluaXR5IGlmIGVpdGhlciDCsUluZmluaXR5LlxyXG4gICAgICAgIGlmICgheGMgfHwgIXljKSByZXR1cm4gbmV3IEJpZ051bWJlcihhIC8gMCk7XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciB6ZXJvP1xyXG4gICAgICAgIC8vIFJldHVybiB5IGlmIHkgaXMgbm9uLXplcm8sIHggaWYgeCBpcyBub24temVybywgb3IgemVybyBpZiBib3RoIGFyZSB6ZXJvLlxyXG4gICAgICAgIGlmICgheGNbMF0gfHwgIXljWzBdKSByZXR1cm4geWNbMF0gPyB5IDogbmV3IEJpZ051bWJlcih4Y1swXSA/IHggOiBhICogMCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHhlID0gYml0Rmxvb3IoeGUpO1xyXG4gICAgICB5ZSA9IGJpdEZsb29yKHllKTtcclxuICAgICAgeGMgPSB4Yy5zbGljZSgpO1xyXG5cclxuICAgICAgLy8gUHJlcGVuZCB6ZXJvcyB0byBlcXVhbGlzZSBleHBvbmVudHMuIEZhc3RlciB0byB1c2UgcmV2ZXJzZSB0aGVuIGRvIHVuc2hpZnRzLlxyXG4gICAgICBpZiAoYSA9IHhlIC0geWUpIHtcclxuICAgICAgICBpZiAoYSA+IDApIHtcclxuICAgICAgICAgIHllID0geGU7XHJcbiAgICAgICAgICB0ID0geWM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGEgPSAtYTtcclxuICAgICAgICAgIHQgPSB4YztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHQucmV2ZXJzZSgpO1xyXG4gICAgICAgIGZvciAoOyBhLS07IHQucHVzaCgwKSk7XHJcbiAgICAgICAgdC5yZXZlcnNlKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGEgPSB4Yy5sZW5ndGg7XHJcbiAgICAgIGIgPSB5Yy5sZW5ndGg7XHJcblxyXG4gICAgICAvLyBQb2ludCB4YyB0byB0aGUgbG9uZ2VyIGFycmF5LCBhbmQgYiB0byB0aGUgc2hvcnRlciBsZW5ndGguXHJcbiAgICAgIGlmIChhIC0gYiA8IDApIHQgPSB5YywgeWMgPSB4YywgeGMgPSB0LCBiID0gYTtcclxuXHJcbiAgICAgIC8vIE9ubHkgc3RhcnQgYWRkaW5nIGF0IHljLmxlbmd0aCAtIDEgYXMgdGhlIGZ1cnRoZXIgZGlnaXRzIG9mIHhjIGNhbiBiZSBpZ25vcmVkLlxyXG4gICAgICBmb3IgKGEgPSAwOyBiOykge1xyXG4gICAgICAgIGEgPSAoeGNbLS1iXSA9IHhjW2JdICsgeWNbYl0gKyBhKSAvIEJBU0UgfCAwO1xyXG4gICAgICAgIHhjW2JdID0gQkFTRSA9PT0geGNbYl0gPyAwIDogeGNbYl0gJSBCQVNFO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoYSkge1xyXG4gICAgICAgIHhjID0gW2FdLmNvbmNhdCh4Yyk7XHJcbiAgICAgICAgKyt5ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayBmb3IgemVybywgYXMgK3ggKyAreSAhPSAwICYmIC14ICsgLXkgIT0gMFxyXG4gICAgICAvLyB5ZSA9IE1BWF9FWFAgKyAxIHBvc3NpYmxlXHJcbiAgICAgIHJldHVybiBub3JtYWxpc2UoeSwgeGMsIHllKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBJZiBzZCBpcyB1bmRlZmluZWQgb3IgbnVsbCBvciB0cnVlIG9yIGZhbHNlLCByZXR1cm4gdGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHMgb2ZcclxuICAgICAqIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciwgb3IgbnVsbCBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgwrFJbmZpbml0eSBvciBOYU4uXHJcbiAgICAgKiBJZiBzZCBpcyB0cnVlIGluY2x1ZGUgaW50ZWdlci1wYXJ0IHRyYWlsaW5nIHplcm9zIGluIHRoZSBjb3VudC5cclxuICAgICAqXHJcbiAgICAgKiBPdGhlcndpc2UsIGlmIHNkIGlzIGEgbnVtYmVyLCByZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzXHJcbiAgICAgKiBCaWdOdW1iZXIgcm91bmRlZCB0byBhIG1heGltdW0gb2Ygc2Qgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yXHJcbiAgICAgKiBST1VORElOR19NT0RFIGlmIHJtIGlzIG9taXR0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogc2Qge251bWJlcnxib29sZWFufSBudW1iZXI6IHNpZ25pZmljYW50IGRpZ2l0czogaW50ZWdlciwgMSB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICBib29sZWFuOiB3aGV0aGVyIHRvIGNvdW50IGludGVnZXItcGFydCB0cmFpbGluZyB6ZXJvczogdHJ1ZSBvciBmYWxzZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3NkfHJtfSdcclxuICAgICAqL1xyXG4gICAgUC5wcmVjaXNpb24gPSBQLnNkID0gZnVuY3Rpb24gKHNkLCBybSkge1xyXG4gICAgICB2YXIgYywgbiwgdixcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIGlmIChzZCAhPSBudWxsICYmIHNkICE9PSAhIXNkKSB7XHJcbiAgICAgICAgaW50Q2hlY2soc2QsIDEsIE1BWCk7XHJcbiAgICAgICAgaWYgKHJtID09IG51bGwpIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuICAgICAgICBlbHNlIGludENoZWNrKHJtLCAwLCA4KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJvdW5kKG5ldyBCaWdOdW1iZXIoeCksIHNkLCBybSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghKGMgPSB4LmMpKSByZXR1cm4gbnVsbDtcclxuICAgICAgdiA9IGMubGVuZ3RoIC0gMTtcclxuICAgICAgbiA9IHYgKiBMT0dfQkFTRSArIDE7XHJcblxyXG4gICAgICBpZiAodiA9IGNbdl0pIHtcclxuXHJcbiAgICAgICAgLy8gU3VidHJhY3QgdGhlIG51bWJlciBvZiB0cmFpbGluZyB6ZXJvcyBvZiB0aGUgbGFzdCBlbGVtZW50LlxyXG4gICAgICAgIGZvciAoOyB2ICUgMTAgPT0gMDsgdiAvPSAxMCwgbi0tKTtcclxuXHJcbiAgICAgICAgLy8gQWRkIHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHRoZSBmaXJzdCBlbGVtZW50LlxyXG4gICAgICAgIGZvciAodiA9IGNbMF07IHYgPj0gMTA7IHYgLz0gMTAsIG4rKyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChzZCAmJiB4LmUgKyAxID4gbikgbiA9IHguZSArIDE7XHJcblxyXG4gICAgICByZXR1cm4gbjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBzaGlmdGVkIGJ5IGsgcGxhY2VzXHJcbiAgICAgKiAocG93ZXJzIG9mIDEwKS4gU2hpZnQgdG8gdGhlIHJpZ2h0IGlmIG4gPiAwLCBhbmQgdG8gdGhlIGxlZnQgaWYgbiA8IDAuXHJcbiAgICAgKlxyXG4gICAgICogayB7bnVtYmVyfSBJbnRlZ2VyLCAtTUFYX1NBRkVfSU5URUdFUiB0byBNQVhfU0FGRV9JTlRFR0VSIGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2t9J1xyXG4gICAgICovXHJcbiAgICBQLnNoaWZ0ZWRCeSA9IGZ1bmN0aW9uIChrKSB7XHJcbiAgICAgIGludENoZWNrKGssIC1NQVhfU0FGRV9JTlRFR0VSLCBNQVhfU0FGRV9JTlRFR0VSKTtcclxuICAgICAgcmV0dXJuIHRoaXMudGltZXMoJzFlJyArIGspO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICBzcXJ0KC1uKSA9ICBOXHJcbiAgICAgKiAgc3FydChOKSA9ICBOXHJcbiAgICAgKiAgc3FydCgtSSkgPSAgTlxyXG4gICAgICogIHNxcnQoSSkgPSAgSVxyXG4gICAgICogIHNxcnQoMCkgPSAgMFxyXG4gICAgICogIHNxcnQoLTApID0gLTBcclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBzcXVhcmUgcm9vdCBvZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIsXHJcbiAgICAgKiByb3VuZGVkIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmQgUk9VTkRJTkdfTU9ERS5cclxuICAgICAqL1xyXG4gICAgUC5zcXVhcmVSb290ID0gUC5zcXJ0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgbSwgbiwgciwgcmVwLCB0LFxyXG4gICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgIGMgPSB4LmMsXHJcbiAgICAgICAgcyA9IHgucyxcclxuICAgICAgICBlID0geC5lLFxyXG4gICAgICAgIGRwID0gREVDSU1BTF9QTEFDRVMgKyA0LFxyXG4gICAgICAgIGhhbGYgPSBuZXcgQmlnTnVtYmVyKCcwLjUnKTtcclxuXHJcbiAgICAgIC8vIE5lZ2F0aXZlL05hTi9JbmZpbml0eS96ZXJvP1xyXG4gICAgICBpZiAocyAhPT0gMSB8fCAhYyB8fCAhY1swXSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKCFzIHx8IHMgPCAwICYmICghYyB8fCBjWzBdKSA/IE5hTiA6IGMgPyB4IDogMSAvIDApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBJbml0aWFsIGVzdGltYXRlLlxyXG4gICAgICBzID0gTWF0aC5zcXJ0KCt2YWx1ZU9mKHgpKTtcclxuXHJcbiAgICAgIC8vIE1hdGguc3FydCB1bmRlcmZsb3cvb3ZlcmZsb3c/XHJcbiAgICAgIC8vIFBhc3MgeCB0byBNYXRoLnNxcnQgYXMgaW50ZWdlciwgdGhlbiBhZGp1c3QgdGhlIGV4cG9uZW50IG9mIHRoZSByZXN1bHQuXHJcbiAgICAgIGlmIChzID09IDAgfHwgcyA9PSAxIC8gMCkge1xyXG4gICAgICAgIG4gPSBjb2VmZlRvU3RyaW5nKGMpO1xyXG4gICAgICAgIGlmICgobi5sZW5ndGggKyBlKSAlIDIgPT0gMCkgbiArPSAnMCc7XHJcbiAgICAgICAgcyA9IE1hdGguc3FydCgrbik7XHJcbiAgICAgICAgZSA9IGJpdEZsb29yKChlICsgMSkgLyAyKSAtIChlIDwgMCB8fCBlICUgMik7XHJcblxyXG4gICAgICAgIGlmIChzID09IDEgLyAwKSB7XHJcbiAgICAgICAgICBuID0gJzVlJyArIGU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG4gPSBzLnRvRXhwb25lbnRpYWwoKTtcclxuICAgICAgICAgIG4gPSBuLnNsaWNlKDAsIG4uaW5kZXhPZignZScpICsgMSkgKyBlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgciA9IG5ldyBCaWdOdW1iZXIobik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgciA9IG5ldyBCaWdOdW1iZXIocyArICcnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2hlY2sgZm9yIHplcm8uXHJcbiAgICAgIC8vIHIgY291bGQgYmUgemVybyBpZiBNSU5fRVhQIGlzIGNoYW5nZWQgYWZ0ZXIgdGhlIHRoaXMgdmFsdWUgd2FzIGNyZWF0ZWQuXHJcbiAgICAgIC8vIFRoaXMgd291bGQgY2F1c2UgYSBkaXZpc2lvbiBieSB6ZXJvICh4L3QpIGFuZCBoZW5jZSBJbmZpbml0eSBiZWxvdywgd2hpY2ggd291bGQgY2F1c2VcclxuICAgICAgLy8gY29lZmZUb1N0cmluZyB0byB0aHJvdy5cclxuICAgICAgaWYgKHIuY1swXSkge1xyXG4gICAgICAgIGUgPSByLmU7XHJcbiAgICAgICAgcyA9IGUgKyBkcDtcclxuICAgICAgICBpZiAocyA8IDMpIHMgPSAwO1xyXG5cclxuICAgICAgICAvLyBOZXd0b24tUmFwaHNvbiBpdGVyYXRpb24uXHJcbiAgICAgICAgZm9yICg7IDspIHtcclxuICAgICAgICAgIHQgPSByO1xyXG4gICAgICAgICAgciA9IGhhbGYudGltZXModC5wbHVzKGRpdih4LCB0LCBkcCwgMSkpKTtcclxuXHJcbiAgICAgICAgICBpZiAoY29lZmZUb1N0cmluZyh0LmMpLnNsaWNlKDAsIHMpID09PSAobiA9IGNvZWZmVG9TdHJpbmcoci5jKSkuc2xpY2UoMCwgcykpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFRoZSBleHBvbmVudCBvZiByIG1heSBoZXJlIGJlIG9uZSBsZXNzIHRoYW4gdGhlIGZpbmFsIHJlc3VsdCBleHBvbmVudCxcclxuICAgICAgICAgICAgLy8gZS5nIDAuMDAwOTk5OSAoZS00KSAtLT4gMC4wMDEgKGUtMyksIHNvIGFkanVzdCBzIHNvIHRoZSByb3VuZGluZyBkaWdpdHNcclxuICAgICAgICAgICAgLy8gYXJlIGluZGV4ZWQgY29ycmVjdGx5LlxyXG4gICAgICAgICAgICBpZiAoci5lIDwgZSkgLS1zO1xyXG4gICAgICAgICAgICBuID0gbi5zbGljZShzIC0gMywgcyArIDEpO1xyXG5cclxuICAgICAgICAgICAgLy8gVGhlIDR0aCByb3VuZGluZyBkaWdpdCBtYXkgYmUgaW4gZXJyb3IgYnkgLTEgc28gaWYgdGhlIDQgcm91bmRpbmcgZGlnaXRzXHJcbiAgICAgICAgICAgIC8vIGFyZSA5OTk5IG9yIDQ5OTkgKGkuZS4gYXBwcm9hY2hpbmcgYSByb3VuZGluZyBib3VuZGFyeSkgY29udGludWUgdGhlXHJcbiAgICAgICAgICAgIC8vIGl0ZXJhdGlvbi5cclxuICAgICAgICAgICAgaWYgKG4gPT0gJzk5OTknIHx8ICFyZXAgJiYgbiA9PSAnNDk5OScpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gT24gdGhlIGZpcnN0IGl0ZXJhdGlvbiBvbmx5LCBjaGVjayB0byBzZWUgaWYgcm91bmRpbmcgdXAgZ2l2ZXMgdGhlXHJcbiAgICAgICAgICAgICAgLy8gZXhhY3QgcmVzdWx0IGFzIHRoZSBuaW5lcyBtYXkgaW5maW5pdGVseSByZXBlYXQuXHJcbiAgICAgICAgICAgICAgaWYgKCFyZXApIHtcclxuICAgICAgICAgICAgICAgIHJvdW5kKHQsIHQuZSArIERFQ0lNQUxfUExBQ0VTICsgMiwgMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHQudGltZXModCkuZXEoeCkpIHtcclxuICAgICAgICAgICAgICAgICAgciA9IHQ7XHJcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgZHAgKz0gNDtcclxuICAgICAgICAgICAgICBzICs9IDQ7XHJcbiAgICAgICAgICAgICAgcmVwID0gMTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gSWYgcm91bmRpbmcgZGlnaXRzIGFyZSBudWxsLCAwezAsNH0gb3IgNTB7MCwzfSwgY2hlY2sgZm9yIGV4YWN0XHJcbiAgICAgICAgICAgICAgLy8gcmVzdWx0LiBJZiBub3QsIHRoZW4gdGhlcmUgYXJlIGZ1cnRoZXIgZGlnaXRzIGFuZCBtIHdpbGwgYmUgdHJ1dGh5LlxyXG4gICAgICAgICAgICAgIGlmICghK24gfHwgIStuLnNsaWNlKDEpICYmIG4uY2hhckF0KDApID09ICc1Jykge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRydW5jYXRlIHRvIHRoZSBmaXJzdCByb3VuZGluZyBkaWdpdC5cclxuICAgICAgICAgICAgICAgIHJvdW5kKHIsIHIuZSArIERFQ0lNQUxfUExBQ0VTICsgMiwgMSk7XHJcbiAgICAgICAgICAgICAgICBtID0gIXIudGltZXMocikuZXEoeCk7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJvdW5kKHIsIHIuZSArIERFQ0lNQUxfUExBQ0VTICsgMSwgUk9VTkRJTkdfTU9ERSwgbSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gZXhwb25lbnRpYWwgbm90YXRpb24gYW5kXHJcbiAgICAgKiByb3VuZGVkIHVzaW5nIFJPVU5ESU5HX01PREUgdG8gZHAgZml4ZWQgZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB8cm19J1xyXG4gICAgICovXHJcbiAgICBQLnRvRXhwb25lbnRpYWwgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgICAgIGlmIChkcCAhPSBudWxsKSB7XHJcbiAgICAgICAgaW50Q2hlY2soZHAsIDAsIE1BWCk7XHJcbiAgICAgICAgZHArKztcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZm9ybWF0KHRoaXMsIGRwLCBybSwgMSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24gcm91bmRpbmdcclxuICAgICAqIHRvIGRwIGZpeGVkIGRlY2ltYWwgcGxhY2VzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgICAqXHJcbiAgICAgKiBOb3RlOiBhcyB3aXRoIEphdmFTY3JpcHQncyBudW1iZXIgdHlwZSwgKC0wKS50b0ZpeGVkKDApIGlzICcwJyxcclxuICAgICAqIGJ1dCBlLmcuICgtMC4wMDAwMSkudG9GaXhlZCgwKSBpcyAnLTAnLlxyXG4gICAgICpcclxuICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfHJtfSdcclxuICAgICAqL1xyXG4gICAgUC50b0ZpeGVkID0gZnVuY3Rpb24gKGRwLCBybSkge1xyXG4gICAgICBpZiAoZHAgIT0gbnVsbCkge1xyXG4gICAgICAgIGludENoZWNrKGRwLCAwLCBNQVgpO1xyXG4gICAgICAgIGRwID0gZHAgKyB0aGlzLmUgKyAxO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmb3JtYXQodGhpcywgZHAsIHJtKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBmaXhlZC1wb2ludCBub3RhdGlvbiByb3VuZGVkXHJcbiAgICAgKiB1c2luZyBybSBvciBST1VORElOR19NT0RFIHRvIGRwIGRlY2ltYWwgcGxhY2VzLCBhbmQgZm9ybWF0dGVkIGFjY29yZGluZyB0byB0aGUgcHJvcGVydGllc1xyXG4gICAgICogb2YgdGhlIGZvcm1hdCBvciBGT1JNQVQgb2JqZWN0IChzZWUgQmlnTnVtYmVyLnNldCkuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGZvcm1hdHRpbmcgb2JqZWN0IG1heSBjb250YWluIHNvbWUgb3IgYWxsIG9mIHRoZSBwcm9wZXJ0aWVzIHNob3duIGJlbG93LlxyXG4gICAgICpcclxuICAgICAqIEZPUk1BVCA9IHtcclxuICAgICAqICAgcHJlZml4OiAnJyxcclxuICAgICAqICAgZ3JvdXBTaXplOiAzLFxyXG4gICAgICogICBzZWNvbmRhcnlHcm91cFNpemU6IDAsXHJcbiAgICAgKiAgIGdyb3VwU2VwYXJhdG9yOiAnLCcsXHJcbiAgICAgKiAgIGRlY2ltYWxTZXBhcmF0b3I6ICcuJyxcclxuICAgICAqICAgZnJhY3Rpb25Hcm91cFNpemU6IDAsXHJcbiAgICAgKiAgIGZyYWN0aW9uR3JvdXBTZXBhcmF0b3I6ICdcXHhBMCcsICAgICAgLy8gbm9uLWJyZWFraW5nIHNwYWNlXHJcbiAgICAgKiAgIHN1ZmZpeDogJydcclxuICAgICAqIH07XHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICogW2Zvcm1hdF0ge29iamVjdH0gRm9ybWF0dGluZyBvcHRpb25zLiBTZWUgRk9STUFUIHBiamVjdCBhYm92ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfHJtfSdcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCBub3QgYW4gb2JqZWN0OiB7Zm9ybWF0fSdcclxuICAgICAqL1xyXG4gICAgUC50b0Zvcm1hdCA9IGZ1bmN0aW9uIChkcCwgcm0sIGZvcm1hdCkge1xyXG4gICAgICB2YXIgc3RyLFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgaWYgKGZvcm1hdCA9PSBudWxsKSB7XHJcbiAgICAgICAgaWYgKGRwICE9IG51bGwgJiYgcm0gJiYgdHlwZW9mIHJtID09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICBmb3JtYXQgPSBybTtcclxuICAgICAgICAgIHJtID0gbnVsbDtcclxuICAgICAgICB9IGVsc2UgaWYgKGRwICYmIHR5cGVvZiBkcCA9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgZm9ybWF0ID0gZHA7XHJcbiAgICAgICAgICBkcCA9IHJtID0gbnVsbDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZm9ybWF0ID0gRk9STUFUO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZm9ybWF0ICE9ICdvYmplY3QnKSB7XHJcbiAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdBcmd1bWVudCBub3QgYW4gb2JqZWN0OiAnICsgZm9ybWF0KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgc3RyID0geC50b0ZpeGVkKGRwLCBybSk7XHJcblxyXG4gICAgICBpZiAoeC5jKSB7XHJcbiAgICAgICAgdmFyIGksXHJcbiAgICAgICAgICBhcnIgPSBzdHIuc3BsaXQoJy4nKSxcclxuICAgICAgICAgIGcxID0gK2Zvcm1hdC5ncm91cFNpemUsXHJcbiAgICAgICAgICBnMiA9ICtmb3JtYXQuc2Vjb25kYXJ5R3JvdXBTaXplLFxyXG4gICAgICAgICAgZ3JvdXBTZXBhcmF0b3IgPSBmb3JtYXQuZ3JvdXBTZXBhcmF0b3IgfHwgJycsXHJcbiAgICAgICAgICBpbnRQYXJ0ID0gYXJyWzBdLFxyXG4gICAgICAgICAgZnJhY3Rpb25QYXJ0ID0gYXJyWzFdLFxyXG4gICAgICAgICAgaXNOZWcgPSB4LnMgPCAwLFxyXG4gICAgICAgICAgaW50RGlnaXRzID0gaXNOZWcgPyBpbnRQYXJ0LnNsaWNlKDEpIDogaW50UGFydCxcclxuICAgICAgICAgIGxlbiA9IGludERpZ2l0cy5sZW5ndGg7XHJcblxyXG4gICAgICAgIGlmIChnMikgaSA9IGcxLCBnMSA9IGcyLCBnMiA9IGksIGxlbiAtPSBpO1xyXG5cclxuICAgICAgICBpZiAoZzEgPiAwICYmIGxlbiA+IDApIHtcclxuICAgICAgICAgIGkgPSBsZW4gJSBnMSB8fCBnMTtcclxuICAgICAgICAgIGludFBhcnQgPSBpbnREaWdpdHMuc3Vic3RyKDAsIGkpO1xyXG4gICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkgKz0gZzEpIGludFBhcnQgKz0gZ3JvdXBTZXBhcmF0b3IgKyBpbnREaWdpdHMuc3Vic3RyKGksIGcxKTtcclxuICAgICAgICAgIGlmIChnMiA+IDApIGludFBhcnQgKz0gZ3JvdXBTZXBhcmF0b3IgKyBpbnREaWdpdHMuc2xpY2UoaSk7XHJcbiAgICAgICAgICBpZiAoaXNOZWcpIGludFBhcnQgPSAnLScgKyBpbnRQYXJ0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RyID0gZnJhY3Rpb25QYXJ0XHJcbiAgICAgICAgID8gaW50UGFydCArIChmb3JtYXQuZGVjaW1hbFNlcGFyYXRvciB8fCAnJykgKyAoKGcyID0gK2Zvcm1hdC5mcmFjdGlvbkdyb3VwU2l6ZSlcclxuICAgICAgICAgID8gZnJhY3Rpb25QYXJ0LnJlcGxhY2UobmV3IFJlZ0V4cCgnXFxcXGR7JyArIGcyICsgJ31cXFxcQicsICdnJyksXHJcbiAgICAgICAgICAgJyQmJyArIChmb3JtYXQuZnJhY3Rpb25Hcm91cFNlcGFyYXRvciB8fCAnJykpXHJcbiAgICAgICAgICA6IGZyYWN0aW9uUGFydClcclxuICAgICAgICAgOiBpbnRQYXJ0O1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gKGZvcm1hdC5wcmVmaXggfHwgJycpICsgc3RyICsgKGZvcm1hdC5zdWZmaXggfHwgJycpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhbiBhcnJheSBvZiB0d28gQmlnTnVtYmVycyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGFzIGEgc2ltcGxlXHJcbiAgICAgKiBmcmFjdGlvbiB3aXRoIGFuIGludGVnZXIgbnVtZXJhdG9yIGFuZCBhbiBpbnRlZ2VyIGRlbm9taW5hdG9yLlxyXG4gICAgICogVGhlIGRlbm9taW5hdG9yIHdpbGwgYmUgYSBwb3NpdGl2ZSBub24temVybyB2YWx1ZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHNwZWNpZmllZFxyXG4gICAgICogbWF4aW11bSBkZW5vbWluYXRvci4gSWYgYSBtYXhpbXVtIGRlbm9taW5hdG9yIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBkZW5vbWluYXRvciB3aWxsIGJlXHJcbiAgICAgKiB0aGUgbG93ZXN0IHZhbHVlIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlIG51bWJlciBleGFjdGx5LlxyXG4gICAgICpcclxuICAgICAqIFttZF0ge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBJbnRlZ2VyID49IDEsIG9yIEluZmluaXR5LiBUaGUgbWF4aW11bSBkZW5vbWluYXRvci5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX0gOiB7bWR9J1xyXG4gICAgICovXHJcbiAgICBQLnRvRnJhY3Rpb24gPSBmdW5jdGlvbiAobWQpIHtcclxuICAgICAgdmFyIGQsIGQwLCBkMSwgZDIsIGUsIGV4cCwgbiwgbjAsIG4xLCBxLCByLCBzLFxyXG4gICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgIHhjID0geC5jO1xyXG5cclxuICAgICAgaWYgKG1kICE9IG51bGwpIHtcclxuICAgICAgICBuID0gbmV3IEJpZ051bWJlcihtZCk7XHJcblxyXG4gICAgICAgIC8vIFRocm93IGlmIG1kIGlzIGxlc3MgdGhhbiBvbmUgb3IgaXMgbm90IGFuIGludGVnZXIsIHVubGVzcyBpdCBpcyBJbmZpbml0eS5cclxuICAgICAgICBpZiAoIW4uaXNJbnRlZ2VyKCkgJiYgKG4uYyB8fCBuLnMgIT09IDEpIHx8IG4ubHQoT05FKSkge1xyXG4gICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ0FyZ3VtZW50ICcgK1xyXG4gICAgICAgICAgICAgIChuLmlzSW50ZWdlcigpID8gJ291dCBvZiByYW5nZTogJyA6ICdub3QgYW4gaW50ZWdlcjogJykgKyB2YWx1ZU9mKG4pKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICgheGMpIHJldHVybiBuZXcgQmlnTnVtYmVyKHgpO1xyXG5cclxuICAgICAgZCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuICAgICAgbjEgPSBkMCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuICAgICAgZDEgPSBuMCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuICAgICAgcyA9IGNvZWZmVG9TdHJpbmcoeGMpO1xyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIGluaXRpYWwgZGVub21pbmF0b3IuXHJcbiAgICAgIC8vIGQgaXMgYSBwb3dlciBvZiAxMCBhbmQgdGhlIG1pbmltdW0gbWF4IGRlbm9taW5hdG9yIHRoYXQgc3BlY2lmaWVzIHRoZSB2YWx1ZSBleGFjdGx5LlxyXG4gICAgICBlID0gZC5lID0gcy5sZW5ndGggLSB4LmUgLSAxO1xyXG4gICAgICBkLmNbMF0gPSBQT1dTX1RFTlsoZXhwID0gZSAlIExPR19CQVNFKSA8IDAgPyBMT0dfQkFTRSArIGV4cCA6IGV4cF07XHJcbiAgICAgIG1kID0gIW1kIHx8IG4uY29tcGFyZWRUbyhkKSA+IDAgPyAoZSA+IDAgPyBkIDogbjEpIDogbjtcclxuXHJcbiAgICAgIGV4cCA9IE1BWF9FWFA7XHJcbiAgICAgIE1BWF9FWFAgPSAxIC8gMDtcclxuICAgICAgbiA9IG5ldyBCaWdOdW1iZXIocyk7XHJcblxyXG4gICAgICAvLyBuMCA9IGQxID0gMFxyXG4gICAgICBuMC5jWzBdID0gMDtcclxuXHJcbiAgICAgIGZvciAoOyA7KSAge1xyXG4gICAgICAgIHEgPSBkaXYobiwgZCwgMCwgMSk7XHJcbiAgICAgICAgZDIgPSBkMC5wbHVzKHEudGltZXMoZDEpKTtcclxuICAgICAgICBpZiAoZDIuY29tcGFyZWRUbyhtZCkgPT0gMSkgYnJlYWs7XHJcbiAgICAgICAgZDAgPSBkMTtcclxuICAgICAgICBkMSA9IGQyO1xyXG4gICAgICAgIG4xID0gbjAucGx1cyhxLnRpbWVzKGQyID0gbjEpKTtcclxuICAgICAgICBuMCA9IGQyO1xyXG4gICAgICAgIGQgPSBuLm1pbnVzKHEudGltZXMoZDIgPSBkKSk7XHJcbiAgICAgICAgbiA9IGQyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBkMiA9IGRpdihtZC5taW51cyhkMCksIGQxLCAwLCAxKTtcclxuICAgICAgbjAgPSBuMC5wbHVzKGQyLnRpbWVzKG4xKSk7XHJcbiAgICAgIGQwID0gZDAucGx1cyhkMi50aW1lcyhkMSkpO1xyXG4gICAgICBuMC5zID0gbjEucyA9IHgucztcclxuICAgICAgZSA9IGUgKiAyO1xyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGZyYWN0aW9uIGlzIGNsb3NlciB0byB4LCBuMC9kMCBvciBuMS9kMVxyXG4gICAgICByID0gZGl2KG4xLCBkMSwgZSwgUk9VTkRJTkdfTU9ERSkubWludXMoeCkuYWJzKCkuY29tcGFyZWRUbyhcclxuICAgICAgICAgIGRpdihuMCwgZDAsIGUsIFJPVU5ESU5HX01PREUpLm1pbnVzKHgpLmFicygpKSA8IDEgPyBbbjEsIGQxXSA6IFtuMCwgZDBdO1xyXG5cclxuICAgICAgTUFYX0VYUCA9IGV4cDtcclxuXHJcbiAgICAgIHJldHVybiByO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgY29udmVydGVkIHRvIGEgbnVtYmVyIHByaW1pdGl2ZS5cclxuICAgICAqL1xyXG4gICAgUC50b051bWJlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICt2YWx1ZU9mKHRoaXMpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHJvdW5kZWQgdG8gc2Qgc2lnbmlmaWNhbnQgZGlnaXRzXHJcbiAgICAgKiB1c2luZyByb3VuZGluZyBtb2RlIHJtIG9yIFJPVU5ESU5HX01PREUuIElmIHNkIGlzIGxlc3MgdGhhbiB0aGUgbnVtYmVyIG9mIGRpZ2l0c1xyXG4gICAgICogbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCB0aGUgaW50ZWdlciBwYXJ0IG9mIHRoZSB2YWx1ZSBpbiBmaXhlZC1wb2ludCBub3RhdGlvbiwgdGhlbiB1c2VcclxuICAgICAqIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIFtzZF0ge251bWJlcn0gU2lnbmlmaWNhbnQgZGlnaXRzLiBJbnRlZ2VyLCAxIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtzZHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAudG9QcmVjaXNpb24gPSBmdW5jdGlvbiAoc2QsIHJtKSB7XHJcbiAgICAgIGlmIChzZCAhPSBudWxsKSBpbnRDaGVjayhzZCwgMSwgTUFYKTtcclxuICAgICAgcmV0dXJuIGZvcm1hdCh0aGlzLCBzZCwgcm0sIDIpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGJhc2UgYiwgb3IgYmFzZSAxMCBpZiBiIGlzXHJcbiAgICAgKiBvbWl0dGVkLiBJZiBhIGJhc2UgaXMgc3BlY2lmaWVkLCBpbmNsdWRpbmcgYmFzZSAxMCwgcm91bmQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZFxyXG4gICAgICogUk9VTkRJTkdfTU9ERS4gSWYgYSBiYXNlIGlzIG5vdCBzcGVjaWZpZWQsIGFuZCB0aGlzIEJpZ051bWJlciBoYXMgYSBwb3NpdGl2ZSBleHBvbmVudFxyXG4gICAgICogdGhhdCBpcyBlcXVhbCB0byBvciBncmVhdGVyIHRoYW4gVE9fRVhQX1BPUywgb3IgYSBuZWdhdGl2ZSBleHBvbmVudCBlcXVhbCB0byBvciBsZXNzIHRoYW5cclxuICAgICAqIFRPX0VYUF9ORUcsIHJldHVybiBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBbYl0ge251bWJlcn0gSW50ZWdlciwgMiB0byBBTFBIQUJFVC5sZW5ndGggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBCYXNlIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtifSdcclxuICAgICAqL1xyXG4gICAgUC50b1N0cmluZyA9IGZ1bmN0aW9uIChiKSB7XHJcbiAgICAgIHZhciBzdHIsXHJcbiAgICAgICAgbiA9IHRoaXMsXHJcbiAgICAgICAgcyA9IG4ucyxcclxuICAgICAgICBlID0gbi5lO1xyXG5cclxuICAgICAgLy8gSW5maW5pdHkgb3IgTmFOP1xyXG4gICAgICBpZiAoZSA9PT0gbnVsbCkge1xyXG4gICAgICAgIGlmIChzKSB7XHJcbiAgICAgICAgICBzdHIgPSAnSW5maW5pdHknO1xyXG4gICAgICAgICAgaWYgKHMgPCAwKSBzdHIgPSAnLScgKyBzdHI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHN0ciA9ICdOYU4nO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoYiA9PSBudWxsKSB7XHJcbiAgICAgICAgICBzdHIgPSBlIDw9IFRPX0VYUF9ORUcgfHwgZSA+PSBUT19FWFBfUE9TXHJcbiAgICAgICAgICAgPyB0b0V4cG9uZW50aWFsKGNvZWZmVG9TdHJpbmcobi5jKSwgZSlcclxuICAgICAgICAgICA6IHRvRml4ZWRQb2ludChjb2VmZlRvU3RyaW5nKG4uYyksIGUsICcwJyk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChiID09PSAxMCAmJiBhbHBoYWJldEhhc05vcm1hbERlY2ltYWxEaWdpdHMpIHtcclxuICAgICAgICAgIG4gPSByb3VuZChuZXcgQmlnTnVtYmVyKG4pLCBERUNJTUFMX1BMQUNFUyArIGUgKyAxLCBST1VORElOR19NT0RFKTtcclxuICAgICAgICAgIHN0ciA9IHRvRml4ZWRQb2ludChjb2VmZlRvU3RyaW5nKG4uYyksIG4uZSwgJzAnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaW50Q2hlY2soYiwgMiwgQUxQSEFCRVQubGVuZ3RoLCAnQmFzZScpO1xyXG4gICAgICAgICAgc3RyID0gY29udmVydEJhc2UodG9GaXhlZFBvaW50KGNvZWZmVG9TdHJpbmcobi5jKSwgZSwgJzAnKSwgMTAsIGIsIHMsIHRydWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHMgPCAwICYmIG4uY1swXSkgc3RyID0gJy0nICsgc3RyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gc3RyO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhcyB0b1N0cmluZywgYnV0IGRvIG5vdCBhY2NlcHQgYSBiYXNlIGFyZ3VtZW50LCBhbmQgaW5jbHVkZSB0aGUgbWludXMgc2lnbiBmb3JcclxuICAgICAqIG5lZ2F0aXZlIHplcm8uXHJcbiAgICAgKi9cclxuICAgIFAudmFsdWVPZiA9IFAudG9KU09OID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdmFsdWVPZih0aGlzKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIFAuX2lzQmlnTnVtYmVyID0gdHJ1ZTtcclxuXHJcbiAgICBpZiAoY29uZmlnT2JqZWN0ICE9IG51bGwpIEJpZ051bWJlci5zZXQoY29uZmlnT2JqZWN0KTtcclxuXHJcbiAgICByZXR1cm4gQmlnTnVtYmVyO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIFBSSVZBVEUgSEVMUEVSIEZVTkNUSU9OU1xyXG5cclxuICAvLyBUaGVzZSBmdW5jdGlvbnMgZG9uJ3QgbmVlZCBhY2Nlc3MgdG8gdmFyaWFibGVzLFxyXG4gIC8vIGUuZy4gREVDSU1BTF9QTEFDRVMsIGluIHRoZSBzY29wZSBvZiB0aGUgYGNsb25lYCBmdW5jdGlvbiBhYm92ZS5cclxuXHJcblxyXG4gIGZ1bmN0aW9uIGJpdEZsb29yKG4pIHtcclxuICAgIHZhciBpID0gbiB8IDA7XHJcbiAgICByZXR1cm4gbiA+IDAgfHwgbiA9PT0gaSA/IGkgOiBpIC0gMTtcclxuICB9XHJcblxyXG5cclxuICAvLyBSZXR1cm4gYSBjb2VmZmljaWVudCBhcnJheSBhcyBhIHN0cmluZyBvZiBiYXNlIDEwIGRpZ2l0cy5cclxuICBmdW5jdGlvbiBjb2VmZlRvU3RyaW5nKGEpIHtcclxuICAgIHZhciBzLCB6LFxyXG4gICAgICBpID0gMSxcclxuICAgICAgaiA9IGEubGVuZ3RoLFxyXG4gICAgICByID0gYVswXSArICcnO1xyXG5cclxuICAgIGZvciAoOyBpIDwgajspIHtcclxuICAgICAgcyA9IGFbaSsrXSArICcnO1xyXG4gICAgICB6ID0gTE9HX0JBU0UgLSBzLmxlbmd0aDtcclxuICAgICAgZm9yICg7IHotLTsgcyA9ICcwJyArIHMpO1xyXG4gICAgICByICs9IHM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgZm9yIChqID0gci5sZW5ndGg7IHIuY2hhckNvZGVBdCgtLWopID09PSA0ODspO1xyXG5cclxuICAgIHJldHVybiByLnNsaWNlKDAsIGogKyAxIHx8IDEpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIENvbXBhcmUgdGhlIHZhbHVlIG9mIEJpZ051bWJlcnMgeCBhbmQgeS5cclxuICBmdW5jdGlvbiBjb21wYXJlKHgsIHkpIHtcclxuICAgIHZhciBhLCBiLFxyXG4gICAgICB4YyA9IHguYyxcclxuICAgICAgeWMgPSB5LmMsXHJcbiAgICAgIGkgPSB4LnMsXHJcbiAgICAgIGogPSB5LnMsXHJcbiAgICAgIGsgPSB4LmUsXHJcbiAgICAgIGwgPSB5LmU7XHJcblxyXG4gICAgLy8gRWl0aGVyIE5hTj9cclxuICAgIGlmICghaSB8fCAhaikgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgYSA9IHhjICYmICF4Y1swXTtcclxuICAgIGIgPSB5YyAmJiAheWNbMF07XHJcblxyXG4gICAgLy8gRWl0aGVyIHplcm8/XHJcbiAgICBpZiAoYSB8fCBiKSByZXR1cm4gYSA/IGIgPyAwIDogLWogOiBpO1xyXG5cclxuICAgIC8vIFNpZ25zIGRpZmZlcj9cclxuICAgIGlmIChpICE9IGopIHJldHVybiBpO1xyXG5cclxuICAgIGEgPSBpIDwgMDtcclxuICAgIGIgPSBrID09IGw7XHJcblxyXG4gICAgLy8gRWl0aGVyIEluZmluaXR5P1xyXG4gICAgaWYgKCF4YyB8fCAheWMpIHJldHVybiBiID8gMCA6ICF4YyBeIGEgPyAxIDogLTE7XHJcblxyXG4gICAgLy8gQ29tcGFyZSBleHBvbmVudHMuXHJcbiAgICBpZiAoIWIpIHJldHVybiBrID4gbCBeIGEgPyAxIDogLTE7XHJcblxyXG4gICAgaiA9IChrID0geGMubGVuZ3RoKSA8IChsID0geWMubGVuZ3RoKSA/IGsgOiBsO1xyXG5cclxuICAgIC8vIENvbXBhcmUgZGlnaXQgYnkgZGlnaXQuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgajsgaSsrKSBpZiAoeGNbaV0gIT0geWNbaV0pIHJldHVybiB4Y1tpXSA+IHljW2ldIF4gYSA/IDEgOiAtMTtcclxuXHJcbiAgICAvLyBDb21wYXJlIGxlbmd0aHMuXHJcbiAgICByZXR1cm4gayA9PSBsID8gMCA6IGsgPiBsIF4gYSA/IDEgOiAtMTtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIENoZWNrIHRoYXQgbiBpcyBhIHByaW1pdGl2ZSBudW1iZXIsIGFuIGludGVnZXIsIGFuZCBpbiByYW5nZSwgb3RoZXJ3aXNlIHRocm93LlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGludENoZWNrKG4sIG1pbiwgbWF4LCBuYW1lKSB7XHJcbiAgICBpZiAobiA8IG1pbiB8fCBuID4gbWF4IHx8IG4gIT09IG1hdGhmbG9vcihuKSkge1xyXG4gICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgKGJpZ251bWJlckVycm9yICsgKG5hbWUgfHwgJ0FyZ3VtZW50JykgKyAodHlwZW9mIG4gPT0gJ251bWJlcidcclxuICAgICAgICAgPyBuIDwgbWluIHx8IG4gPiBtYXggPyAnIG91dCBvZiByYW5nZTogJyA6ICcgbm90IGFuIGludGVnZXI6ICdcclxuICAgICAgICAgOiAnIG5vdCBhIHByaW1pdGl2ZSBudW1iZXI6ICcpICsgU3RyaW5nKG4pKTtcclxuICAgIH1cclxuICB9XHJcblxyXG5cclxuICAvLyBBc3N1bWVzIGZpbml0ZSBuLlxyXG4gIGZ1bmN0aW9uIGlzT2RkKG4pIHtcclxuICAgIHZhciBrID0gbi5jLmxlbmd0aCAtIDE7XHJcbiAgICByZXR1cm4gYml0Rmxvb3Iobi5lIC8gTE9HX0JBU0UpID09IGsgJiYgbi5jW2tdICUgMiAhPSAwO1xyXG4gIH1cclxuXHJcblxyXG4gIGZ1bmN0aW9uIHRvRXhwb25lbnRpYWwoc3RyLCBlKSB7XHJcbiAgICByZXR1cm4gKHN0ci5sZW5ndGggPiAxID8gc3RyLmNoYXJBdCgwKSArICcuJyArIHN0ci5zbGljZSgxKSA6IHN0cikgK1xyXG4gICAgIChlIDwgMCA/ICdlJyA6ICdlKycpICsgZTtcclxuICB9XHJcblxyXG5cclxuICBmdW5jdGlvbiB0b0ZpeGVkUG9pbnQoc3RyLCBlLCB6KSB7XHJcbiAgICB2YXIgbGVuLCB6cztcclxuXHJcbiAgICAvLyBOZWdhdGl2ZSBleHBvbmVudD9cclxuICAgIGlmIChlIDwgMCkge1xyXG5cclxuICAgICAgLy8gUHJlcGVuZCB6ZXJvcy5cclxuICAgICAgZm9yICh6cyA9IHogKyAnLic7ICsrZTsgenMgKz0geik7XHJcbiAgICAgIHN0ciA9IHpzICsgc3RyO1xyXG5cclxuICAgIC8vIFBvc2l0aXZlIGV4cG9uZW50XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBsZW4gPSBzdHIubGVuZ3RoO1xyXG5cclxuICAgICAgLy8gQXBwZW5kIHplcm9zLlxyXG4gICAgICBpZiAoKytlID4gbGVuKSB7XHJcbiAgICAgICAgZm9yICh6cyA9IHosIGUgLT0gbGVuOyAtLWU7IHpzICs9IHopO1xyXG4gICAgICAgIHN0ciArPSB6cztcclxuICAgICAgfSBlbHNlIGlmIChlIDwgbGVuKSB7XHJcbiAgICAgICAgc3RyID0gc3RyLnNsaWNlKDAsIGUpICsgJy4nICsgc3RyLnNsaWNlKGUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHN0cjtcclxuICB9XHJcblxyXG5cclxuICAvLyBFWFBPUlRcclxuXHJcblxyXG4gIEJpZ051bWJlciA9IGNsb25lKCk7XHJcbiAgQmlnTnVtYmVyWydkZWZhdWx0J10gPSBCaWdOdW1iZXIuQmlnTnVtYmVyID0gQmlnTnVtYmVyO1xyXG5cclxuICAvLyBBTUQuXHJcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICBkZWZpbmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gQmlnTnVtYmVyOyB9KTtcclxuXHJcbiAgLy8gTm9kZS5qcyBhbmQgb3RoZXIgZW52aXJvbm1lbnRzIHRoYXQgc3VwcG9ydCBtb2R1bGUuZXhwb3J0cy5cclxuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gQmlnTnVtYmVyO1xyXG5cclxuICAvLyBCcm93c2VyLlxyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAoIWdsb2JhbE9iamVjdCkge1xyXG4gICAgICBnbG9iYWxPYmplY3QgPSB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmID8gc2VsZiA6IHdpbmRvdztcclxuICAgIH1cclxuXHJcbiAgICBnbG9iYWxPYmplY3QuQmlnTnVtYmVyID0gQmlnTnVtYmVyO1xyXG4gIH1cclxufSkodGhpcyk7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/bignumber.js/bignumber.js\n");

/***/ }),

/***/ "./node_modules/bowser/es5.js":
/*!************************************!*\
  !*** ./node_modules/bowser/es5.js ***!
  \************************************/
/***/ (function(module) {

eval("!function(e,t){ true?module.exports=t():0}(this,(function(){return function(e){var t={};function r(n){if(t[n])return t[n].exports;var i=t[n]={i:n,l:!1,exports:{}};return e[n].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&\"object\"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,\"default\",{enumerable:!0,value:e}),2&t&&\"string\"!=typeof e)for(var i in e)r.d(n,i,function(t){return e[t]}.bind(null,i));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,\"a\",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p=\"\",r(r.s=90)}({17:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n=r(18),i=function(){function e(){}return e.getFirstMatch=function(e,t){var r=t.match(e);return r&&r.length>0&&r[1]||\"\"},e.getSecondMatch=function(e,t){var r=t.match(e);return r&&r.length>1&&r[2]||\"\"},e.matchAndReturnConst=function(e,t,r){if(e.test(t))return r},e.getWindowsVersionName=function(e){switch(e){case\"NT\":return\"NT\";case\"XP\":return\"XP\";case\"NT 5.0\":return\"2000\";case\"NT 5.1\":return\"XP\";case\"NT 5.2\":return\"2003\";case\"NT 6.0\":return\"Vista\";case\"NT 6.1\":return\"7\";case\"NT 6.2\":return\"8\";case\"NT 6.3\":return\"8.1\";case\"NT 10.0\":return\"10\";default:return}},e.getMacOSVersionName=function(e){var t=e.split(\".\").splice(0,2).map((function(e){return parseInt(e,10)||0}));if(t.push(0),10===t[0])switch(t[1]){case 5:return\"Leopard\";case 6:return\"Snow Leopard\";case 7:return\"Lion\";case 8:return\"Mountain Lion\";case 9:return\"Mavericks\";case 10:return\"Yosemite\";case 11:return\"El Capitan\";case 12:return\"Sierra\";case 13:return\"High Sierra\";case 14:return\"Mojave\";case 15:return\"Catalina\";default:return}},e.getAndroidVersionName=function(e){var t=e.split(\".\").splice(0,2).map((function(e){return parseInt(e,10)||0}));if(t.push(0),!(1===t[0]&&t[1]<5))return 1===t[0]&&t[1]<6?\"Cupcake\":1===t[0]&&t[1]>=6?\"Donut\":2===t[0]&&t[1]<2?\"Eclair\":2===t[0]&&2===t[1]?\"Froyo\":2===t[0]&&t[1]>2?\"Gingerbread\":3===t[0]?\"Honeycomb\":4===t[0]&&t[1]<1?\"Ice Cream Sandwich\":4===t[0]&&t[1]<4?\"Jelly Bean\":4===t[0]&&t[1]>=4?\"KitKat\":5===t[0]?\"Lollipop\":6===t[0]?\"Marshmallow\":7===t[0]?\"Nougat\":8===t[0]?\"Oreo\":9===t[0]?\"Pie\":void 0},e.getVersionPrecision=function(e){return e.split(\".\").length},e.compareVersions=function(t,r,n){void 0===n&&(n=!1);var i=e.getVersionPrecision(t),s=e.getVersionPrecision(r),a=Math.max(i,s),o=0,u=e.map([t,r],(function(t){var r=a-e.getVersionPrecision(t),n=t+new Array(r+1).join(\".0\");return e.map(n.split(\".\"),(function(e){return new Array(20-e.length).join(\"0\")+e})).reverse()}));for(n&&(o=a-Math.min(i,s)),a-=1;a>=o;){if(u[0][a]>u[1][a])return 1;if(u[0][a]===u[1][a]){if(a===o)return 0;a-=1}else if(u[0][a]<u[1][a])return-1}},e.map=function(e,t){var r,n=[];if(Array.prototype.map)return Array.prototype.map.call(e,t);for(r=0;r<e.length;r+=1)n.push(t(e[r]));return n},e.find=function(e,t){var r,n;if(Array.prototype.find)return Array.prototype.find.call(e,t);for(r=0,n=e.length;r<n;r+=1){var i=e[r];if(t(i,r))return i}},e.assign=function(e){for(var t,r,n=e,i=arguments.length,s=new Array(i>1?i-1:0),a=1;a<i;a++)s[a-1]=arguments[a];if(Object.assign)return Object.assign.apply(Object,[e].concat(s));var o=function(){var e=s[t];\"object\"==typeof e&&null!==e&&Object.keys(e).forEach((function(t){n[t]=e[t]}))};for(t=0,r=s.length;t<r;t+=1)o();return e},e.getBrowserAlias=function(e){return n.BROWSER_ALIASES_MAP[e]},e.getBrowserTypeByAlias=function(e){return n.BROWSER_MAP[e]||\"\"},e}();t.default=i,e.exports=t.default},18:function(e,t,r){\"use strict\";t.__esModule=!0,t.ENGINE_MAP=t.OS_MAP=t.PLATFORMS_MAP=t.BROWSER_MAP=t.BROWSER_ALIASES_MAP=void 0;t.BROWSER_ALIASES_MAP={\"Amazon Silk\":\"amazon_silk\",\"Android Browser\":\"android\",Bada:\"bada\",BlackBerry:\"blackberry\",Chrome:\"chrome\",Chromium:\"chromium\",Electron:\"electron\",Epiphany:\"epiphany\",Firefox:\"firefox\",Focus:\"focus\",Generic:\"generic\",\"Google Search\":\"google_search\",Googlebot:\"googlebot\",\"Internet Explorer\":\"ie\",\"K-Meleon\":\"k_meleon\",Maxthon:\"maxthon\",\"Microsoft Edge\":\"edge\",\"MZ Browser\":\"mz\",\"NAVER Whale Browser\":\"naver\",Opera:\"opera\",\"Opera Coast\":\"opera_coast\",PhantomJS:\"phantomjs\",Puffin:\"puffin\",QupZilla:\"qupzilla\",QQ:\"qq\",QQLite:\"qqlite\",Safari:\"safari\",Sailfish:\"sailfish\",\"Samsung Internet for Android\":\"samsung_internet\",SeaMonkey:\"seamonkey\",Sleipnir:\"sleipnir\",Swing:\"swing\",Tizen:\"tizen\",\"UC Browser\":\"uc\",Vivaldi:\"vivaldi\",\"WebOS Browser\":\"webos\",WeChat:\"wechat\",\"Yandex Browser\":\"yandex\",Roku:\"roku\"};t.BROWSER_MAP={amazon_silk:\"Amazon Silk\",android:\"Android Browser\",bada:\"Bada\",blackberry:\"BlackBerry\",chrome:\"Chrome\",chromium:\"Chromium\",electron:\"Electron\",epiphany:\"Epiphany\",firefox:\"Firefox\",focus:\"Focus\",generic:\"Generic\",googlebot:\"Googlebot\",google_search:\"Google Search\",ie:\"Internet Explorer\",k_meleon:\"K-Meleon\",maxthon:\"Maxthon\",edge:\"Microsoft Edge\",mz:\"MZ Browser\",naver:\"NAVER Whale Browser\",opera:\"Opera\",opera_coast:\"Opera Coast\",phantomjs:\"PhantomJS\",puffin:\"Puffin\",qupzilla:\"QupZilla\",qq:\"QQ Browser\",qqlite:\"QQ Browser Lite\",safari:\"Safari\",sailfish:\"Sailfish\",samsung_internet:\"Samsung Internet for Android\",seamonkey:\"SeaMonkey\",sleipnir:\"Sleipnir\",swing:\"Swing\",tizen:\"Tizen\",uc:\"UC Browser\",vivaldi:\"Vivaldi\",webos:\"WebOS Browser\",wechat:\"WeChat\",yandex:\"Yandex Browser\"};t.PLATFORMS_MAP={tablet:\"tablet\",mobile:\"mobile\",desktop:\"desktop\",tv:\"tv\"};t.OS_MAP={WindowsPhone:\"Windows Phone\",Windows:\"Windows\",MacOS:\"macOS\",iOS:\"iOS\",Android:\"Android\",WebOS:\"WebOS\",BlackBerry:\"BlackBerry\",Bada:\"Bada\",Tizen:\"Tizen\",Linux:\"Linux\",ChromeOS:\"Chrome OS\",PlayStation4:\"PlayStation 4\",Roku:\"Roku\"};t.ENGINE_MAP={EdgeHTML:\"EdgeHTML\",Blink:\"Blink\",Trident:\"Trident\",Presto:\"Presto\",Gecko:\"Gecko\",WebKit:\"WebKit\"}},90:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n,i=(n=r(91))&&n.__esModule?n:{default:n},s=r(18);function a(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}var o=function(){function e(){}var t,r,n;return e.getParser=function(e,t){if(void 0===t&&(t=!1),\"string\"!=typeof e)throw new Error(\"UserAgent should be a string\");return new i.default(e,t)},e.parse=function(e){return new i.default(e).getResult()},t=e,n=[{key:\"BROWSER_MAP\",get:function(){return s.BROWSER_MAP}},{key:\"ENGINE_MAP\",get:function(){return s.ENGINE_MAP}},{key:\"OS_MAP\",get:function(){return s.OS_MAP}},{key:\"PLATFORMS_MAP\",get:function(){return s.PLATFORMS_MAP}}],(r=null)&&a(t.prototype,r),n&&a(t,n),e}();t.default=o,e.exports=t.default},91:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n=u(r(92)),i=u(r(93)),s=u(r(94)),a=u(r(95)),o=u(r(17));function u(e){return e&&e.__esModule?e:{default:e}}var d=function(){function e(e,t){if(void 0===t&&(t=!1),null==e||\"\"===e)throw new Error(\"UserAgent parameter can't be empty\");this._ua=e,this.parsedResult={},!0!==t&&this.parse()}var t=e.prototype;return t.getUA=function(){return this._ua},t.test=function(e){return e.test(this._ua)},t.parseBrowser=function(){var e=this;this.parsedResult.browser={};var t=o.default.find(n.default,(function(t){if(\"function\"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error(\"Browser's test function is not valid\")}));return t&&(this.parsedResult.browser=t.describe(this.getUA())),this.parsedResult.browser},t.getBrowser=function(){return this.parsedResult.browser?this.parsedResult.browser:this.parseBrowser()},t.getBrowserName=function(e){return e?String(this.getBrowser().name).toLowerCase()||\"\":this.getBrowser().name||\"\"},t.getBrowserVersion=function(){return this.getBrowser().version},t.getOS=function(){return this.parsedResult.os?this.parsedResult.os:this.parseOS()},t.parseOS=function(){var e=this;this.parsedResult.os={};var t=o.default.find(i.default,(function(t){if(\"function\"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error(\"Browser's test function is not valid\")}));return t&&(this.parsedResult.os=t.describe(this.getUA())),this.parsedResult.os},t.getOSName=function(e){var t=this.getOS().name;return e?String(t).toLowerCase()||\"\":t||\"\"},t.getOSVersion=function(){return this.getOS().version},t.getPlatform=function(){return this.parsedResult.platform?this.parsedResult.platform:this.parsePlatform()},t.getPlatformType=function(e){void 0===e&&(e=!1);var t=this.getPlatform().type;return e?String(t).toLowerCase()||\"\":t||\"\"},t.parsePlatform=function(){var e=this;this.parsedResult.platform={};var t=o.default.find(s.default,(function(t){if(\"function\"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error(\"Browser's test function is not valid\")}));return t&&(this.parsedResult.platform=t.describe(this.getUA())),this.parsedResult.platform},t.getEngine=function(){return this.parsedResult.engine?this.parsedResult.engine:this.parseEngine()},t.getEngineName=function(e){return e?String(this.getEngine().name).toLowerCase()||\"\":this.getEngine().name||\"\"},t.parseEngine=function(){var e=this;this.parsedResult.engine={};var t=o.default.find(a.default,(function(t){if(\"function\"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error(\"Browser's test function is not valid\")}));return t&&(this.parsedResult.engine=t.describe(this.getUA())),this.parsedResult.engine},t.parse=function(){return this.parseBrowser(),this.parseOS(),this.parsePlatform(),this.parseEngine(),this},t.getResult=function(){return o.default.assign({},this.parsedResult)},t.satisfies=function(e){var t=this,r={},n=0,i={},s=0;if(Object.keys(e).forEach((function(t){var a=e[t];\"string\"==typeof a?(i[t]=a,s+=1):\"object\"==typeof a&&(r[t]=a,n+=1)})),n>0){var a=Object.keys(r),u=o.default.find(a,(function(e){return t.isOS(e)}));if(u){var d=this.satisfies(r[u]);if(void 0!==d)return d}var c=o.default.find(a,(function(e){return t.isPlatform(e)}));if(c){var f=this.satisfies(r[c]);if(void 0!==f)return f}}if(s>0){var l=Object.keys(i),h=o.default.find(l,(function(e){return t.isBrowser(e,!0)}));if(void 0!==h)return this.compareVersion(i[h])}},t.isBrowser=function(e,t){void 0===t&&(t=!1);var r=this.getBrowserName().toLowerCase(),n=e.toLowerCase(),i=o.default.getBrowserTypeByAlias(n);return t&&i&&(n=i.toLowerCase()),n===r},t.compareVersion=function(e){var t=[0],r=e,n=!1,i=this.getBrowserVersion();if(\"string\"==typeof i)return\">\"===e[0]||\"<\"===e[0]?(r=e.substr(1),\"=\"===e[1]?(n=!0,r=e.substr(2)):t=[],\">\"===e[0]?t.push(1):t.push(-1)):\"=\"===e[0]?r=e.substr(1):\"~\"===e[0]&&(n=!0,r=e.substr(1)),t.indexOf(o.default.compareVersions(i,r,n))>-1},t.isOS=function(e){return this.getOSName(!0)===String(e).toLowerCase()},t.isPlatform=function(e){return this.getPlatformType(!0)===String(e).toLowerCase()},t.isEngine=function(e){return this.getEngineName(!0)===String(e).toLowerCase()},t.is=function(e,t){return void 0===t&&(t=!1),this.isBrowser(e,t)||this.isOS(e)||this.isPlatform(e)},t.some=function(e){var t=this;return void 0===e&&(e=[]),e.some((function(e){return t.is(e)}))},e}();t.default=d,e.exports=t.default},92:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n};var s=/version\\/(\\d+(\\.?_?\\d+)+)/i,a=[{test:[/googlebot/i],describe:function(e){var t={name:\"Googlebot\"},r=i.default.getFirstMatch(/googlebot\\/(\\d+(\\.\\d+))/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/opera/i],describe:function(e){var t={name:\"Opera\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:opera)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/opr\\/|opios/i],describe:function(e){var t={name:\"Opera\"},r=i.default.getFirstMatch(/(?:opr|opios)[\\s/](\\S+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/SamsungBrowser/i],describe:function(e){var t={name:\"Samsung Internet for Android\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:SamsungBrowser)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/Whale/i],describe:function(e){var t={name:\"NAVER Whale Browser\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:whale)[\\s/](\\d+(?:\\.\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/MZBrowser/i],describe:function(e){var t={name:\"MZ Browser\"},r=i.default.getFirstMatch(/(?:MZBrowser)[\\s/](\\d+(?:\\.\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/focus/i],describe:function(e){var t={name:\"Focus\"},r=i.default.getFirstMatch(/(?:focus)[\\s/](\\d+(?:\\.\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/swing/i],describe:function(e){var t={name:\"Swing\"},r=i.default.getFirstMatch(/(?:swing)[\\s/](\\d+(?:\\.\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/coast/i],describe:function(e){var t={name:\"Opera Coast\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:coast)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/opt\\/\\d+(?:.?_?\\d+)+/i],describe:function(e){var t={name:\"Opera Touch\"},r=i.default.getFirstMatch(/(?:opt)[\\s/](\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/yabrowser/i],describe:function(e){var t={name:\"Yandex Browser\"},r=i.default.getFirstMatch(/(?:yabrowser)[\\s/](\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/ucbrowser/i],describe:function(e){var t={name:\"UC Browser\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:ucbrowser)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/Maxthon|mxios/i],describe:function(e){var t={name:\"Maxthon\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:Maxthon|mxios)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/epiphany/i],describe:function(e){var t={name:\"Epiphany\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:epiphany)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/puffin/i],describe:function(e){var t={name:\"Puffin\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:puffin)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/sleipnir/i],describe:function(e){var t={name:\"Sleipnir\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:sleipnir)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/k-meleon/i],describe:function(e){var t={name:\"K-Meleon\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:k-meleon)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/micromessenger/i],describe:function(e){var t={name:\"WeChat\"},r=i.default.getFirstMatch(/(?:micromessenger)[\\s/](\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/qqbrowser/i],describe:function(e){var t={name:/qqbrowserlite/i.test(e)?\"QQ Browser Lite\":\"QQ Browser\"},r=i.default.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/msie|trident/i],describe:function(e){var t={name:\"Internet Explorer\"},r=i.default.getFirstMatch(/(?:msie |rv:)(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/\\sedg\\//i],describe:function(e){var t={name:\"Microsoft Edge\"},r=i.default.getFirstMatch(/\\sedg\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/edg([ea]|ios)/i],describe:function(e){var t={name:\"Microsoft Edge\"},r=i.default.getSecondMatch(/edg([ea]|ios)\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/vivaldi/i],describe:function(e){var t={name:\"Vivaldi\"},r=i.default.getFirstMatch(/vivaldi\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/seamonkey/i],describe:function(e){var t={name:\"SeaMonkey\"},r=i.default.getFirstMatch(/seamonkey\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/sailfish/i],describe:function(e){var t={name:\"Sailfish\"},r=i.default.getFirstMatch(/sailfish\\s?browser\\/(\\d+(\\.\\d+)?)/i,e);return r&&(t.version=r),t}},{test:[/silk/i],describe:function(e){var t={name:\"Amazon Silk\"},r=i.default.getFirstMatch(/silk\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/phantom/i],describe:function(e){var t={name:\"PhantomJS\"},r=i.default.getFirstMatch(/phantomjs\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/slimerjs/i],describe:function(e){var t={name:\"SlimerJS\"},r=i.default.getFirstMatch(/slimerjs\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/blackberry|\\bbb\\d+/i,/rim\\stablet/i],describe:function(e){var t={name:\"BlackBerry\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/blackberry[\\d]+\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/(web|hpw)[o0]s/i],describe:function(e){var t={name:\"WebOS Browser\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/w(?:eb)?[o0]sbrowser\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/bada/i],describe:function(e){var t={name:\"Bada\"},r=i.default.getFirstMatch(/dolfin\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/tizen/i],describe:function(e){var t={name:\"Tizen\"},r=i.default.getFirstMatch(/(?:tizen\\s?)?browser\\/(\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/qupzilla/i],describe:function(e){var t={name:\"QupZilla\"},r=i.default.getFirstMatch(/(?:qupzilla)[\\s/](\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/firefox|iceweasel|fxios/i],describe:function(e){var t={name:\"Firefox\"},r=i.default.getFirstMatch(/(?:firefox|iceweasel|fxios)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/electron/i],describe:function(e){var t={name:\"Electron\"},r=i.default.getFirstMatch(/(?:electron)\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/MiuiBrowser/i],describe:function(e){var t={name:\"Miui\"},r=i.default.getFirstMatch(/(?:MiuiBrowser)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/chromium/i],describe:function(e){var t={name:\"Chromium\"},r=i.default.getFirstMatch(/(?:chromium)[\\s/](\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/chrome|crios|crmo/i],describe:function(e){var t={name:\"Chrome\"},r=i.default.getFirstMatch(/(?:chrome|crios|crmo)\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/GSA/i],describe:function(e){var t={name:\"Google Search\"},r=i.default.getFirstMatch(/(?:GSA)\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:function(e){var t=!e.test(/like android/i),r=e.test(/android/i);return t&&r},describe:function(e){var t={name:\"Android Browser\"},r=i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/playstation 4/i],describe:function(e){var t={name:\"PlayStation 4\"},r=i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/safari|applewebkit/i],describe:function(e){var t={name:\"Safari\"},r=i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/.*/i],describe:function(e){var t=-1!==e.search(\"\\\\(\")?/^(.*)\\/(.*)[ \\t]\\((.*)/:/^(.*)\\/(.*) /;return{name:i.default.getFirstMatch(t,e),version:i.default.getSecondMatch(t,e)}}}];t.default=a,e.exports=t.default},93:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n},s=r(18);var a=[{test:[/Roku\\/DVP/],describe:function(e){var t=i.default.getFirstMatch(/Roku\\/DVP-(\\d+\\.\\d+)/i,e);return{name:s.OS_MAP.Roku,version:t}}},{test:[/windows phone/i],describe:function(e){var t=i.default.getFirstMatch(/windows phone (?:os)?\\s?(\\d+(\\.\\d+)*)/i,e);return{name:s.OS_MAP.WindowsPhone,version:t}}},{test:[/windows /i],describe:function(e){var t=i.default.getFirstMatch(/Windows ((NT|XP)( \\d\\d?.\\d)?)/i,e),r=i.default.getWindowsVersionName(t);return{name:s.OS_MAP.Windows,version:t,versionName:r}}},{test:[/Macintosh(.*?) FxiOS(.*?)\\//],describe:function(e){var t={name:s.OS_MAP.iOS},r=i.default.getSecondMatch(/(Version\\/)(\\d[\\d.]+)/,e);return r&&(t.version=r),t}},{test:[/macintosh/i],describe:function(e){var t=i.default.getFirstMatch(/mac os x (\\d+(\\.?_?\\d+)+)/i,e).replace(/[_\\s]/g,\".\"),r=i.default.getMacOSVersionName(t),n={name:s.OS_MAP.MacOS,version:t};return r&&(n.versionName=r),n}},{test:[/(ipod|iphone|ipad)/i],describe:function(e){var t=i.default.getFirstMatch(/os (\\d+([_\\s]\\d+)*) like mac os x/i,e).replace(/[_\\s]/g,\".\");return{name:s.OS_MAP.iOS,version:t}}},{test:function(e){var t=!e.test(/like android/i),r=e.test(/android/i);return t&&r},describe:function(e){var t=i.default.getFirstMatch(/android[\\s/-](\\d+(\\.\\d+)*)/i,e),r=i.default.getAndroidVersionName(t),n={name:s.OS_MAP.Android,version:t};return r&&(n.versionName=r),n}},{test:[/(web|hpw)[o0]s/i],describe:function(e){var t=i.default.getFirstMatch(/(?:web|hpw)[o0]s\\/(\\d+(\\.\\d+)*)/i,e),r={name:s.OS_MAP.WebOS};return t&&t.length&&(r.version=t),r}},{test:[/blackberry|\\bbb\\d+/i,/rim\\stablet/i],describe:function(e){var t=i.default.getFirstMatch(/rim\\stablet\\sos\\s(\\d+(\\.\\d+)*)/i,e)||i.default.getFirstMatch(/blackberry\\d+\\/(\\d+([_\\s]\\d+)*)/i,e)||i.default.getFirstMatch(/\\bbb(\\d+)/i,e);return{name:s.OS_MAP.BlackBerry,version:t}}},{test:[/bada/i],describe:function(e){var t=i.default.getFirstMatch(/bada\\/(\\d+(\\.\\d+)*)/i,e);return{name:s.OS_MAP.Bada,version:t}}},{test:[/tizen/i],describe:function(e){var t=i.default.getFirstMatch(/tizen[/\\s](\\d+(\\.\\d+)*)/i,e);return{name:s.OS_MAP.Tizen,version:t}}},{test:[/linux/i],describe:function(){return{name:s.OS_MAP.Linux}}},{test:[/CrOS/],describe:function(){return{name:s.OS_MAP.ChromeOS}}},{test:[/PlayStation 4/],describe:function(e){var t=i.default.getFirstMatch(/PlayStation 4[/\\s](\\d+(\\.\\d+)*)/i,e);return{name:s.OS_MAP.PlayStation4,version:t}}}];t.default=a,e.exports=t.default},94:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n},s=r(18);var a=[{test:[/googlebot/i],describe:function(){return{type:\"bot\",vendor:\"Google\"}}},{test:[/huawei/i],describe:function(e){var t=i.default.getFirstMatch(/(can-l01)/i,e)&&\"Nova\",r={type:s.PLATFORMS_MAP.mobile,vendor:\"Huawei\"};return t&&(r.model=t),r}},{test:[/nexus\\s*(?:7|8|9|10).*/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:\"Nexus\"}}},{test:[/ipad/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:\"Apple\",model:\"iPad\"}}},{test:[/Macintosh(.*?) FxiOS(.*?)\\//],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:\"Apple\",model:\"iPad\"}}},{test:[/kftt build/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:\"Amazon\",model:\"Kindle Fire HD 7\"}}},{test:[/silk/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:\"Amazon\"}}},{test:[/tablet(?! pc)/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet}}},{test:function(e){var t=e.test(/ipod|iphone/i),r=e.test(/like (ipod|iphone)/i);return t&&!r},describe:function(e){var t=i.default.getFirstMatch(/(ipod|iphone)/i,e);return{type:s.PLATFORMS_MAP.mobile,vendor:\"Apple\",model:t}}},{test:[/nexus\\s*[0-6].*/i,/galaxy nexus/i],describe:function(){return{type:s.PLATFORMS_MAP.mobile,vendor:\"Nexus\"}}},{test:[/[^-]mobi/i],describe:function(){return{type:s.PLATFORMS_MAP.mobile}}},{test:function(e){return\"blackberry\"===e.getBrowserName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.mobile,vendor:\"BlackBerry\"}}},{test:function(e){return\"bada\"===e.getBrowserName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.mobile}}},{test:function(e){return\"windows phone\"===e.getBrowserName()},describe:function(){return{type:s.PLATFORMS_MAP.mobile,vendor:\"Microsoft\"}}},{test:function(e){var t=Number(String(e.getOSVersion()).split(\".\")[0]);return\"android\"===e.getOSName(!0)&&t>=3},describe:function(){return{type:s.PLATFORMS_MAP.tablet}}},{test:function(e){return\"android\"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.mobile}}},{test:function(e){return\"macos\"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.desktop,vendor:\"Apple\"}}},{test:function(e){return\"windows\"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.desktop}}},{test:function(e){return\"linux\"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.desktop}}},{test:function(e){return\"playstation 4\"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.tv}}},{test:function(e){return\"roku\"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.tv}}}];t.default=a,e.exports=t.default},95:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n},s=r(18);var a=[{test:function(e){return\"microsoft edge\"===e.getBrowserName(!0)},describe:function(e){if(/\\sedg\\//i.test(e))return{name:s.ENGINE_MAP.Blink};var t=i.default.getFirstMatch(/edge\\/(\\d+(\\.?_?\\d+)+)/i,e);return{name:s.ENGINE_MAP.EdgeHTML,version:t}}},{test:[/trident/i],describe:function(e){var t={name:s.ENGINE_MAP.Trident},r=i.default.getFirstMatch(/trident\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:function(e){return e.test(/presto/i)},describe:function(e){var t={name:s.ENGINE_MAP.Presto},r=i.default.getFirstMatch(/presto\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:function(e){var t=e.test(/gecko/i),r=e.test(/like gecko/i);return t&&!r},describe:function(e){var t={name:s.ENGINE_MAP.Gecko},r=i.default.getFirstMatch(/gecko\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/(apple)?webkit\\/537\\.36/i],describe:function(){return{name:s.ENGINE_MAP.Blink}}},{test:[/(apple)?webkit/i],describe:function(e){var t={name:s.ENGINE_MAP.WebKit},r=i.default.getFirstMatch(/webkit\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}}];t.default=a,e.exports=t.default}})}));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYm93c2VyL2VzNS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLEtBQWlELG9CQUFvQixDQUEyRyxDQUFDLGtCQUFrQixtQkFBbUIsU0FBUyxjQUFjLDRCQUE0QixZQUFZLHFCQUFxQiwyREFBMkQsdUNBQXVDLHFDQUFxQyxvQkFBb0IsRUFBRSxpQkFBaUIsNEZBQTRGLGVBQWUsd0NBQXdDLFNBQVMsRUFBRSxtQkFBbUIsOEJBQThCLHFEQUFxRCwwQkFBMEIsNkNBQTZDLHNCQUFzQiw2REFBNkQsWUFBWSxlQUFlLFNBQVMsaUJBQWlCLGlDQUFpQyxpQkFBaUIsWUFBWSxVQUFVLHNCQUFzQixtQkFBbUIsaURBQWlELGtCQUFrQixFQUFFLG1CQUFtQixhQUFhLGlDQUFpQyx5QkFBeUIsY0FBYyxxQ0FBcUMsaUJBQWlCLCtCQUErQixnQ0FBZ0MsaUJBQWlCLCtCQUErQix1Q0FBdUMsc0JBQXNCLHFDQUFxQyxVQUFVLG9CQUFvQixvQkFBb0IsMEJBQTBCLHdCQUF3QiwwQkFBMEIsMkJBQTJCLHVCQUF1Qix1QkFBdUIseUJBQXlCLHlCQUF5QixnQkFBZ0IsbUNBQW1DLGdEQUFnRCx5QkFBeUIsR0FBRyxvQ0FBb0MsdUJBQXVCLDRCQUE0QixvQkFBb0IsNkJBQTZCLHlCQUF5Qix5QkFBeUIsMkJBQTJCLHVCQUF1Qiw0QkFBNEIsdUJBQXVCLHlCQUF5QixnQkFBZ0IscUNBQXFDLGdEQUFnRCx5QkFBeUIsR0FBRyx3WUFBd1ksbUNBQW1DLDJCQUEyQixtQ0FBbUMsbUJBQW1CLHlHQUF5RywrREFBK0QsdUNBQXVDLDBDQUEwQyxhQUFhLEdBQUcsZ0NBQWdDLEtBQUssRUFBRSw0QkFBNEIsc0JBQXNCLGtCQUFrQixLQUFLLGtDQUFrQyxxQkFBcUIsV0FBVyw0REFBNEQsUUFBUSxXQUFXLHFCQUFxQixTQUFTLHNCQUFzQixRQUFRLDhEQUE4RCxtQkFBbUIsSUFBSSxNQUFNLFdBQVcsb0JBQW9CLHNCQUFzQiw4REFBOEQsSUFBSSx3QkFBd0Isa0VBQWtFLGlCQUFpQixXQUFXLGtFQUFrRSxVQUFVLElBQUksbUJBQW1CLElBQUksU0FBUyxTQUFTLCtCQUErQixnQ0FBZ0MscUNBQXFDLDRCQUE0QixHQUFHLEdBQUcsZ0NBQWdDLG9CQUFvQixhQUFhLGlHQUFpRyx1QkFBdUIsb3lCQUFveUIsZUFBZSwrd0JBQSt3QixpQkFBaUIsMkRBQTJELFVBQVUsc09BQXNPLGNBQWMsbUdBQW1HLG9CQUFvQixhQUFhLGlDQUFpQyxtQ0FBbUMsVUFBVSxTQUFTLGdCQUFnQixZQUFZLFdBQVcsS0FBSyxXQUFXLCtHQUErRyxpQkFBaUIsY0FBYyxVQUFVLGlDQUFpQyx5RkFBeUYsMEJBQTBCLHFCQUFxQixvQ0FBb0MsU0FBUyxpQ0FBaUMsc0JBQXNCLEVBQUUsZ0NBQWdDLHFCQUFxQixFQUFFLDRCQUE0QixpQkFBaUIsRUFBRSxtQ0FBbUMsd0JBQXdCLHlDQUF5QyxHQUFHLGdDQUFnQyxvQkFBb0IsYUFBYSxpQ0FBaUMsMkRBQTJELGNBQWMsMEJBQTBCLFdBQVcsaUJBQWlCLGdCQUFnQiw0RkFBNEYsK0JBQStCLHNCQUFzQixrQkFBa0IsMEJBQTBCLGdCQUFnQixvQkFBb0Isd0JBQXdCLDJCQUEyQixXQUFXLDZCQUE2Qiw0Q0FBNEMsOENBQThDLDJEQUEyRCxpQkFBaUIsR0FBRyx3REFBd0QsR0FBRyx5RkFBeUYseUJBQXlCLCtFQUErRSw4QkFBOEIscUZBQXFGLGdDQUFnQyxpQ0FBaUMsb0JBQW9CLGdFQUFnRSxzQkFBc0IsV0FBVyx3QkFBd0IsNENBQTRDLDhDQUE4QywyREFBMkQsaUJBQWlCLEdBQUcsd0RBQXdELEdBQUcsK0VBQStFLHlCQUF5Qix3QkFBd0IsMkNBQTJDLDJCQUEyQiw0QkFBNEIsMEJBQTBCLGtGQUFrRiwrQkFBK0IsbUJBQW1CLDhCQUE4QiwyQ0FBMkMsNEJBQTRCLFdBQVcsOEJBQThCLDRDQUE0Qyw4Q0FBOEMsMkRBQTJELGlCQUFpQixHQUFHLHdEQUF3RCxHQUFHLDJGQUEyRix3QkFBd0IsNEVBQTRFLDZCQUE2QixtRkFBbUYsMEJBQTBCLFdBQVcsNEJBQTRCLDRDQUE0Qyw4Q0FBOEMsMkRBQTJELGlCQUFpQixHQUFHLHdEQUF3RCxHQUFHLHVGQUF1RixvQkFBb0IsdUZBQXVGLHdCQUF3QiwwQkFBMEIsb0JBQW9CLHlCQUF5QixlQUFlLFNBQVMsS0FBSyx1Q0FBdUMsV0FBVyxtRUFBbUUsUUFBUSxxREFBcUQsaUJBQWlCLEdBQUcsTUFBTSwyQkFBMkIsdUJBQXVCLG9DQUFvQyx1QkFBdUIsR0FBRyxNQUFNLDJCQUEyQix3QkFBd0IsUUFBUSxxREFBcUQseUJBQXlCLEdBQUcsZ0RBQWdELDJCQUEyQixtQkFBbUIsaUdBQWlHLHVDQUF1Qyw4QkFBOEIsOENBQThDLGlQQUFpUCxvQkFBb0Isb0RBQW9ELDBCQUEwQiwwREFBMEQsd0JBQXdCLHdEQUF3RCxvQkFBb0IsZ0ZBQWdGLG9CQUFvQixXQUFXLDhDQUE4QyxlQUFlLEdBQUcsR0FBRyxHQUFHLGdDQUFnQyxvQkFBb0IsYUFBYSxpQ0FBaUMsbUNBQW1DLFdBQVcsdUNBQXVDLHlDQUF5QyxPQUFPLGlCQUFpQix1RkFBdUYsMkJBQTJCLEVBQUUscUNBQXFDLE9BQU8sYUFBYSw4RkFBOEYsMkJBQTJCLEVBQUUsMkNBQTJDLE9BQU8sYUFBYSx1RkFBdUYsMkJBQTJCLEVBQUUsOENBQThDLE9BQU8sb0NBQW9DLHVHQUF1RywyQkFBMkIsRUFBRSxxQ0FBcUMsT0FBTywyQkFBMkIsNkZBQTZGLDJCQUEyQixFQUFFLHlDQUF5QyxPQUFPLGtCQUFrQixpR0FBaUcsMkJBQTJCLEVBQUUscUNBQXFDLE9BQU8sYUFBYSw2RkFBNkYsMkJBQTJCLEVBQUUscUNBQXFDLE9BQU8sYUFBYSw2RkFBNkYsMkJBQTJCLEVBQUUscUNBQXFDLE9BQU8sbUJBQW1CLDhGQUE4RiwyQkFBMkIsRUFBRSxvREFBb0QsT0FBTyxtQkFBbUIsNEZBQTRGLDJCQUEyQixFQUFFLHlDQUF5QyxPQUFPLHNCQUFzQixrR0FBa0csMkJBQTJCLEVBQUUseUNBQXlDLE9BQU8sa0JBQWtCLGtHQUFrRywyQkFBMkIsRUFBRSw2Q0FBNkMsT0FBTyxlQUFlLHNHQUFzRywyQkFBMkIsRUFBRSx3Q0FBd0MsT0FBTyxnQkFBZ0IsaUdBQWlHLDJCQUEyQixFQUFFLHNDQUFzQyxPQUFPLGNBQWMsK0ZBQStGLDJCQUEyQixFQUFFLHdDQUF3QyxPQUFPLGdCQUFnQixpR0FBaUcsMkJBQTJCLEVBQUUsd0NBQXdDLE9BQU8sZ0JBQWdCLGlHQUFpRywyQkFBMkIsRUFBRSw4Q0FBOEMsT0FBTyxjQUFjLHVHQUF1RywyQkFBMkIsRUFBRSx5Q0FBeUMsT0FBTyw2REFBNkQsOEdBQThHLDJCQUEyQixFQUFFLDRDQUE0QyxPQUFPLHlCQUF5QiwrREFBK0QsMkJBQTJCLEVBQUUsdUNBQXVDLE9BQU8sc0JBQXNCLHlEQUF5RCwyQkFBMkIsRUFBRSw2Q0FBNkMsT0FBTyxzQkFBc0Isa0VBQWtFLDJCQUEyQixFQUFFLHVDQUF1QyxPQUFPLGVBQWUsMkRBQTJELDJCQUEyQixFQUFFLHlDQUF5QyxPQUFPLGlCQUFpQiw2REFBNkQsMkJBQTJCLEVBQUUsd0NBQXdDLE9BQU8sZ0JBQWdCLG1FQUFtRSwyQkFBMkIsRUFBRSxvQ0FBb0MsT0FBTyxtQkFBbUIsd0RBQXdELDJCQUEyQixFQUFFLHVDQUF1QyxPQUFPLGlCQUFpQiw2REFBNkQsMkJBQTJCLEVBQUUsd0NBQXdDLE9BQU8sZ0JBQWdCLDREQUE0RCwyQkFBMkIsRUFBRSxpRUFBaUUsT0FBTyxrQkFBa0IsaUdBQWlHLDJCQUEyQixFQUFFLDhDQUE4QyxPQUFPLHFCQUFxQixzR0FBc0csMkJBQTJCLEVBQUUsb0NBQW9DLE9BQU8sWUFBWSwwREFBMEQsMkJBQTJCLEVBQUUscUNBQXFDLE9BQU8sYUFBYSxzR0FBc0csMkJBQTJCLEVBQUUsd0NBQXdDLE9BQU8sZ0JBQWdCLGlHQUFpRywyQkFBMkIsRUFBRSx1REFBdUQsT0FBTyxlQUFlLGtGQUFrRiwyQkFBMkIsRUFBRSx3Q0FBd0MsT0FBTyxnQkFBZ0IsZ0VBQWdFLDJCQUEyQixFQUFFLDJDQUEyQyxPQUFPLFlBQVksc0VBQXNFLDJCQUEyQixFQUFFLHdDQUF3QyxPQUFPLGdCQUFnQixpR0FBaUcsMkJBQTJCLEVBQUUsaURBQWlELE9BQU8sY0FBYyx5RUFBeUUsMkJBQTJCLEVBQUUsbUNBQW1DLE9BQU8scUJBQXFCLDJEQUEyRCwyQkFBMkIsRUFBRSxpQkFBaUIsb0RBQW9ELFlBQVksc0JBQXNCLE9BQU8sdUJBQXVCLGdDQUFnQywyQkFBMkIsRUFBRSw2Q0FBNkMsT0FBTyxxQkFBcUIsZ0NBQWdDLDJCQUEyQixFQUFFLGtEQUFrRCxPQUFPLGNBQWMsZ0NBQWdDLDJCQUEyQixFQUFFLGtDQUFrQyxtRUFBbUUsT0FBTywwRUFBMEUsRUFBRSxnQ0FBZ0Msb0JBQW9CLGFBQWEsaUNBQWlDLG1DQUFtQyxVQUFVLFNBQVMsUUFBUSx3Q0FBd0MseURBQXlELE9BQU8sK0JBQStCLEVBQUUsNkNBQTZDLDBFQUEwRSxPQUFPLHVDQUF1QyxFQUFFLHdDQUF3Qyx1R0FBdUcsT0FBTyxnREFBZ0QsRUFBRSwwREFBMEQsT0FBTyxrQkFBa0IsdURBQXVELDJCQUEyQixFQUFFLHlDQUF5QywwSEFBMEgsK0JBQStCLCtCQUErQixFQUFFLGtEQUFrRCw0RkFBNEYsT0FBTyw4QkFBOEIsRUFBRSxpQkFBaUIsb0RBQW9ELFlBQVksc0JBQXNCLHVHQUF1RyxpQ0FBaUMsK0JBQStCLEVBQUUsOENBQThDLHVFQUF1RSxxQkFBcUIscUNBQXFDLEVBQUUsaUVBQWlFLDJLQUEySyxPQUFPLHFDQUFxQyxFQUFFLG9DQUFvQyx3REFBd0QsT0FBTywrQkFBK0IsRUFBRSxxQ0FBcUMsNERBQTRELE9BQU8sZ0NBQWdDLEVBQUUsb0NBQW9DLE9BQU8sc0JBQXNCLEVBQUUsa0NBQWtDLE9BQU8seUJBQXlCLEVBQUUsNENBQTRDLG9FQUFvRSxPQUFPLHVDQUF1QyxFQUFFLGdDQUFnQyxvQkFBb0IsYUFBYSxpQ0FBaUMsbUNBQW1DLFVBQVUsU0FBUyxRQUFRLHdDQUF3QyxPQUFPLDZCQUE2QixFQUFFLHNDQUFzQyx5REFBeUQsNkNBQTZDLHlCQUF5QixFQUFFLHFEQUFxRCxPQUFPLDZDQUE2QyxFQUFFLG1DQUFtQyxPQUFPLDBEQUEwRCxFQUFFLHlEQUF5RCxPQUFPLDBEQUEwRCxFQUFFLHlDQUF5QyxPQUFPLHVFQUF1RSxFQUFFLG1DQUFtQyxPQUFPLDhDQUE4QyxFQUFFLDRDQUE0QyxPQUFPLDhCQUE4QixFQUFFLGlCQUFpQiw2REFBNkQsYUFBYSxzQkFBc0Isa0RBQWtELE9BQU8scURBQXFELEVBQUUsOERBQThELE9BQU8sNkNBQTZDLEVBQUUsdUNBQXVDLE9BQU8sOEJBQThCLEVBQUUsaUJBQWlCLDBDQUEwQyxxQkFBcUIsT0FBTyxrREFBa0QsRUFBRSxpQkFBaUIsb0NBQW9DLHFCQUFxQixPQUFPLDhCQUE4QixFQUFFLGlCQUFpQiwyQ0FBMkMscUJBQXFCLE9BQU8saURBQWlELEVBQUUsaUJBQWlCLHFEQUFxRCx3Q0FBd0MscUJBQXFCLE9BQU8sOEJBQThCLEVBQUUsaUJBQWlCLGtDQUFrQyxxQkFBcUIsT0FBTyw4QkFBOEIsRUFBRSxpQkFBaUIsZ0NBQWdDLHFCQUFxQixPQUFPLDhDQUE4QyxFQUFFLGlCQUFpQixrQ0FBa0MscUJBQXFCLE9BQU8sK0JBQStCLEVBQUUsaUJBQWlCLGdDQUFnQyxxQkFBcUIsT0FBTywrQkFBK0IsRUFBRSxpQkFBaUIsd0NBQXdDLHFCQUFxQixPQUFPLDBCQUEwQixFQUFFLGlCQUFpQiwrQkFBK0IscUJBQXFCLE9BQU8sMEJBQTBCLEVBQUUsZ0NBQWdDLG9CQUFvQixhQUFhLGlDQUFpQyxtQ0FBbUMsVUFBVSxTQUFTLFFBQVEsaUJBQWlCLDhDQUE4QyxzQkFBc0IsNkJBQTZCLHlCQUF5QiwyREFBMkQsT0FBTyx1Q0FBdUMsRUFBRSx1Q0FBdUMsT0FBTywwQkFBMEIsMkRBQTJELDJCQUEyQixFQUFFLGlCQUFpQix5QkFBeUIsc0JBQXNCLE9BQU8seUJBQXlCLDBEQUEwRCwyQkFBMkIsRUFBRSxpQkFBaUIsK0NBQStDLGFBQWEsc0JBQXNCLE9BQU8sd0JBQXdCLHlEQUF5RCwyQkFBMkIsRUFBRSxzREFBc0QsT0FBTywwQkFBMEIsRUFBRSw4Q0FBOEMsT0FBTyx5QkFBeUIsMERBQTBELDJCQUEyQixFQUFFLGlDQUFpQyxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9ib3dzZXIvZXM1LmpzP2U4MmMiXSwic291cmNlc0NvbnRlbnQiOlsiIWZ1bmN0aW9uKGUsdCl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9dCgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW10sdCk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/ZXhwb3J0cy5ib3dzZXI9dCgpOmUuYm93c2VyPXQoKX0odGhpcywoZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oZSl7dmFyIHQ9e307ZnVuY3Rpb24gcihuKXtpZih0W25dKXJldHVybiB0W25dLmV4cG9ydHM7dmFyIGk9dFtuXT17aTpuLGw6ITEsZXhwb3J0czp7fX07cmV0dXJuIGVbbl0uY2FsbChpLmV4cG9ydHMsaSxpLmV4cG9ydHMsciksaS5sPSEwLGkuZXhwb3J0c31yZXR1cm4gci5tPWUsci5jPXQsci5kPWZ1bmN0aW9uKGUsdCxuKXtyLm8oZSx0KXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7ZW51bWVyYWJsZTohMCxnZXQ6bn0pfSxyLnI9ZnVuY3Rpb24oZSl7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLnRvU3RyaW5nVGFnJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOlwiTW9kdWxlXCJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX0sci50PWZ1bmN0aW9uKGUsdCl7aWYoMSZ0JiYoZT1yKGUpKSw4JnQpcmV0dXJuIGU7aWYoNCZ0JiZcIm9iamVjdFwiPT10eXBlb2YgZSYmZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciBuPU9iamVjdC5jcmVhdGUobnVsbCk7aWYoci5yKG4pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOiEwLHZhbHVlOmV9KSwyJnQmJlwic3RyaW5nXCIhPXR5cGVvZiBlKWZvcih2YXIgaSBpbiBlKXIuZChuLGksZnVuY3Rpb24odCl7cmV0dXJuIGVbdF19LmJpbmQobnVsbCxpKSk7cmV0dXJuIG59LHIubj1mdW5jdGlvbihlKXt2YXIgdD1lJiZlLl9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gZS5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiBlfTtyZXR1cm4gci5kKHQsXCJhXCIsdCksdH0sci5vPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpfSxyLnA9XCJcIixyKHIucz05MCl9KHsxNzpmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dC5fX2VzTW9kdWxlPSEwLHQuZGVmYXVsdD12b2lkIDA7dmFyIG49cigxOCksaT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXt9cmV0dXJuIGUuZ2V0Rmlyc3RNYXRjaD1mdW5jdGlvbihlLHQpe3ZhciByPXQubWF0Y2goZSk7cmV0dXJuIHImJnIubGVuZ3RoPjAmJnJbMV18fFwiXCJ9LGUuZ2V0U2Vjb25kTWF0Y2g9ZnVuY3Rpb24oZSx0KXt2YXIgcj10Lm1hdGNoKGUpO3JldHVybiByJiZyLmxlbmd0aD4xJiZyWzJdfHxcIlwifSxlLm1hdGNoQW5kUmV0dXJuQ29uc3Q9ZnVuY3Rpb24oZSx0LHIpe2lmKGUudGVzdCh0KSlyZXR1cm4gcn0sZS5nZXRXaW5kb3dzVmVyc2lvbk5hbWU9ZnVuY3Rpb24oZSl7c3dpdGNoKGUpe2Nhc2VcIk5UXCI6cmV0dXJuXCJOVFwiO2Nhc2VcIlhQXCI6cmV0dXJuXCJYUFwiO2Nhc2VcIk5UIDUuMFwiOnJldHVyblwiMjAwMFwiO2Nhc2VcIk5UIDUuMVwiOnJldHVyblwiWFBcIjtjYXNlXCJOVCA1LjJcIjpyZXR1cm5cIjIwMDNcIjtjYXNlXCJOVCA2LjBcIjpyZXR1cm5cIlZpc3RhXCI7Y2FzZVwiTlQgNi4xXCI6cmV0dXJuXCI3XCI7Y2FzZVwiTlQgNi4yXCI6cmV0dXJuXCI4XCI7Y2FzZVwiTlQgNi4zXCI6cmV0dXJuXCI4LjFcIjtjYXNlXCJOVCAxMC4wXCI6cmV0dXJuXCIxMFwiO2RlZmF1bHQ6cmV0dXJufX0sZS5nZXRNYWNPU1ZlcnNpb25OYW1lPWZ1bmN0aW9uKGUpe3ZhciB0PWUuc3BsaXQoXCIuXCIpLnNwbGljZSgwLDIpLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIHBhcnNlSW50KGUsMTApfHwwfSkpO2lmKHQucHVzaCgwKSwxMD09PXRbMF0pc3dpdGNoKHRbMV0pe2Nhc2UgNTpyZXR1cm5cIkxlb3BhcmRcIjtjYXNlIDY6cmV0dXJuXCJTbm93IExlb3BhcmRcIjtjYXNlIDc6cmV0dXJuXCJMaW9uXCI7Y2FzZSA4OnJldHVyblwiTW91bnRhaW4gTGlvblwiO2Nhc2UgOTpyZXR1cm5cIk1hdmVyaWNrc1wiO2Nhc2UgMTA6cmV0dXJuXCJZb3NlbWl0ZVwiO2Nhc2UgMTE6cmV0dXJuXCJFbCBDYXBpdGFuXCI7Y2FzZSAxMjpyZXR1cm5cIlNpZXJyYVwiO2Nhc2UgMTM6cmV0dXJuXCJIaWdoIFNpZXJyYVwiO2Nhc2UgMTQ6cmV0dXJuXCJNb2phdmVcIjtjYXNlIDE1OnJldHVyblwiQ2F0YWxpbmFcIjtkZWZhdWx0OnJldHVybn19LGUuZ2V0QW5kcm9pZFZlcnNpb25OYW1lPWZ1bmN0aW9uKGUpe3ZhciB0PWUuc3BsaXQoXCIuXCIpLnNwbGljZSgwLDIpLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIHBhcnNlSW50KGUsMTApfHwwfSkpO2lmKHQucHVzaCgwKSwhKDE9PT10WzBdJiZ0WzFdPDUpKXJldHVybiAxPT09dFswXSYmdFsxXTw2P1wiQ3VwY2FrZVwiOjE9PT10WzBdJiZ0WzFdPj02P1wiRG9udXRcIjoyPT09dFswXSYmdFsxXTwyP1wiRWNsYWlyXCI6Mj09PXRbMF0mJjI9PT10WzFdP1wiRnJveW9cIjoyPT09dFswXSYmdFsxXT4yP1wiR2luZ2VyYnJlYWRcIjozPT09dFswXT9cIkhvbmV5Y29tYlwiOjQ9PT10WzBdJiZ0WzFdPDE/XCJJY2UgQ3JlYW0gU2FuZHdpY2hcIjo0PT09dFswXSYmdFsxXTw0P1wiSmVsbHkgQmVhblwiOjQ9PT10WzBdJiZ0WzFdPj00P1wiS2l0S2F0XCI6NT09PXRbMF0/XCJMb2xsaXBvcFwiOjY9PT10WzBdP1wiTWFyc2htYWxsb3dcIjo3PT09dFswXT9cIk5vdWdhdFwiOjg9PT10WzBdP1wiT3Jlb1wiOjk9PT10WzBdP1wiUGllXCI6dm9pZCAwfSxlLmdldFZlcnNpb25QcmVjaXNpb249ZnVuY3Rpb24oZSl7cmV0dXJuIGUuc3BsaXQoXCIuXCIpLmxlbmd0aH0sZS5jb21wYXJlVmVyc2lvbnM9ZnVuY3Rpb24odCxyLG4pe3ZvaWQgMD09PW4mJihuPSExKTt2YXIgaT1lLmdldFZlcnNpb25QcmVjaXNpb24odCkscz1lLmdldFZlcnNpb25QcmVjaXNpb24ociksYT1NYXRoLm1heChpLHMpLG89MCx1PWUubWFwKFt0LHJdLChmdW5jdGlvbih0KXt2YXIgcj1hLWUuZ2V0VmVyc2lvblByZWNpc2lvbih0KSxuPXQrbmV3IEFycmF5KHIrMSkuam9pbihcIi4wXCIpO3JldHVybiBlLm1hcChuLnNwbGl0KFwiLlwiKSwoZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBBcnJheSgyMC1lLmxlbmd0aCkuam9pbihcIjBcIikrZX0pKS5yZXZlcnNlKCl9KSk7Zm9yKG4mJihvPWEtTWF0aC5taW4oaSxzKSksYS09MTthPj1vOyl7aWYodVswXVthXT51WzFdW2FdKXJldHVybiAxO2lmKHVbMF1bYV09PT11WzFdW2FdKXtpZihhPT09bylyZXR1cm4gMDthLT0xfWVsc2UgaWYodVswXVthXTx1WzFdW2FdKXJldHVybi0xfX0sZS5tYXA9ZnVuY3Rpb24oZSx0KXt2YXIgcixuPVtdO2lmKEFycmF5LnByb3RvdHlwZS5tYXApcmV0dXJuIEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbChlLHQpO2ZvcihyPTA7cjxlLmxlbmd0aDtyKz0xKW4ucHVzaCh0KGVbcl0pKTtyZXR1cm4gbn0sZS5maW5kPWZ1bmN0aW9uKGUsdCl7dmFyIHIsbjtpZihBcnJheS5wcm90b3R5cGUuZmluZClyZXR1cm4gQXJyYXkucHJvdG90eXBlLmZpbmQuY2FsbChlLHQpO2ZvcihyPTAsbj1lLmxlbmd0aDtyPG47cis9MSl7dmFyIGk9ZVtyXTtpZih0KGkscikpcmV0dXJuIGl9fSxlLmFzc2lnbj1mdW5jdGlvbihlKXtmb3IodmFyIHQscixuPWUsaT1hcmd1bWVudHMubGVuZ3RoLHM9bmV3IEFycmF5KGk+MT9pLTE6MCksYT0xO2E8aTthKyspc1thLTFdPWFyZ3VtZW50c1thXTtpZihPYmplY3QuYXNzaWduKXJldHVybiBPYmplY3QuYXNzaWduLmFwcGx5KE9iamVjdCxbZV0uY29uY2F0KHMpKTt2YXIgbz1mdW5jdGlvbigpe3ZhciBlPXNbdF07XCJvYmplY3RcIj09dHlwZW9mIGUmJm51bGwhPT1lJiZPYmplY3Qua2V5cyhlKS5mb3JFYWNoKChmdW5jdGlvbih0KXtuW3RdPWVbdF19KSl9O2Zvcih0PTAscj1zLmxlbmd0aDt0PHI7dCs9MSlvKCk7cmV0dXJuIGV9LGUuZ2V0QnJvd3NlckFsaWFzPWZ1bmN0aW9uKGUpe3JldHVybiBuLkJST1dTRVJfQUxJQVNFU19NQVBbZV19LGUuZ2V0QnJvd3NlclR5cGVCeUFsaWFzPWZ1bmN0aW9uKGUpe3JldHVybiBuLkJST1dTRVJfTUFQW2VdfHxcIlwifSxlfSgpO3QuZGVmYXVsdD1pLGUuZXhwb3J0cz10LmRlZmF1bHR9LDE4OmZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt0Ll9fZXNNb2R1bGU9ITAsdC5FTkdJTkVfTUFQPXQuT1NfTUFQPXQuUExBVEZPUk1TX01BUD10LkJST1dTRVJfTUFQPXQuQlJPV1NFUl9BTElBU0VTX01BUD12b2lkIDA7dC5CUk9XU0VSX0FMSUFTRVNfTUFQPXtcIkFtYXpvbiBTaWxrXCI6XCJhbWF6b25fc2lsa1wiLFwiQW5kcm9pZCBCcm93c2VyXCI6XCJhbmRyb2lkXCIsQmFkYTpcImJhZGFcIixCbGFja0JlcnJ5OlwiYmxhY2tiZXJyeVwiLENocm9tZTpcImNocm9tZVwiLENocm9taXVtOlwiY2hyb21pdW1cIixFbGVjdHJvbjpcImVsZWN0cm9uXCIsRXBpcGhhbnk6XCJlcGlwaGFueVwiLEZpcmVmb3g6XCJmaXJlZm94XCIsRm9jdXM6XCJmb2N1c1wiLEdlbmVyaWM6XCJnZW5lcmljXCIsXCJHb29nbGUgU2VhcmNoXCI6XCJnb29nbGVfc2VhcmNoXCIsR29vZ2xlYm90OlwiZ29vZ2xlYm90XCIsXCJJbnRlcm5ldCBFeHBsb3JlclwiOlwiaWVcIixcIkstTWVsZW9uXCI6XCJrX21lbGVvblwiLE1heHRob246XCJtYXh0aG9uXCIsXCJNaWNyb3NvZnQgRWRnZVwiOlwiZWRnZVwiLFwiTVogQnJvd3NlclwiOlwibXpcIixcIk5BVkVSIFdoYWxlIEJyb3dzZXJcIjpcIm5hdmVyXCIsT3BlcmE6XCJvcGVyYVwiLFwiT3BlcmEgQ29hc3RcIjpcIm9wZXJhX2NvYXN0XCIsUGhhbnRvbUpTOlwicGhhbnRvbWpzXCIsUHVmZmluOlwicHVmZmluXCIsUXVwWmlsbGE6XCJxdXB6aWxsYVwiLFFROlwicXFcIixRUUxpdGU6XCJxcWxpdGVcIixTYWZhcmk6XCJzYWZhcmlcIixTYWlsZmlzaDpcInNhaWxmaXNoXCIsXCJTYW1zdW5nIEludGVybmV0IGZvciBBbmRyb2lkXCI6XCJzYW1zdW5nX2ludGVybmV0XCIsU2VhTW9ua2V5Olwic2VhbW9ua2V5XCIsU2xlaXBuaXI6XCJzbGVpcG5pclwiLFN3aW5nOlwic3dpbmdcIixUaXplbjpcInRpemVuXCIsXCJVQyBCcm93c2VyXCI6XCJ1Y1wiLFZpdmFsZGk6XCJ2aXZhbGRpXCIsXCJXZWJPUyBCcm93c2VyXCI6XCJ3ZWJvc1wiLFdlQ2hhdDpcIndlY2hhdFwiLFwiWWFuZGV4IEJyb3dzZXJcIjpcInlhbmRleFwiLFJva3U6XCJyb2t1XCJ9O3QuQlJPV1NFUl9NQVA9e2FtYXpvbl9zaWxrOlwiQW1hem9uIFNpbGtcIixhbmRyb2lkOlwiQW5kcm9pZCBCcm93c2VyXCIsYmFkYTpcIkJhZGFcIixibGFja2JlcnJ5OlwiQmxhY2tCZXJyeVwiLGNocm9tZTpcIkNocm9tZVwiLGNocm9taXVtOlwiQ2hyb21pdW1cIixlbGVjdHJvbjpcIkVsZWN0cm9uXCIsZXBpcGhhbnk6XCJFcGlwaGFueVwiLGZpcmVmb3g6XCJGaXJlZm94XCIsZm9jdXM6XCJGb2N1c1wiLGdlbmVyaWM6XCJHZW5lcmljXCIsZ29vZ2xlYm90OlwiR29vZ2xlYm90XCIsZ29vZ2xlX3NlYXJjaDpcIkdvb2dsZSBTZWFyY2hcIixpZTpcIkludGVybmV0IEV4cGxvcmVyXCIsa19tZWxlb246XCJLLU1lbGVvblwiLG1heHRob246XCJNYXh0aG9uXCIsZWRnZTpcIk1pY3Jvc29mdCBFZGdlXCIsbXo6XCJNWiBCcm93c2VyXCIsbmF2ZXI6XCJOQVZFUiBXaGFsZSBCcm93c2VyXCIsb3BlcmE6XCJPcGVyYVwiLG9wZXJhX2NvYXN0OlwiT3BlcmEgQ29hc3RcIixwaGFudG9tanM6XCJQaGFudG9tSlNcIixwdWZmaW46XCJQdWZmaW5cIixxdXB6aWxsYTpcIlF1cFppbGxhXCIscXE6XCJRUSBCcm93c2VyXCIscXFsaXRlOlwiUVEgQnJvd3NlciBMaXRlXCIsc2FmYXJpOlwiU2FmYXJpXCIsc2FpbGZpc2g6XCJTYWlsZmlzaFwiLHNhbXN1bmdfaW50ZXJuZXQ6XCJTYW1zdW5nIEludGVybmV0IGZvciBBbmRyb2lkXCIsc2VhbW9ua2V5OlwiU2VhTW9ua2V5XCIsc2xlaXBuaXI6XCJTbGVpcG5pclwiLHN3aW5nOlwiU3dpbmdcIix0aXplbjpcIlRpemVuXCIsdWM6XCJVQyBCcm93c2VyXCIsdml2YWxkaTpcIlZpdmFsZGlcIix3ZWJvczpcIldlYk9TIEJyb3dzZXJcIix3ZWNoYXQ6XCJXZUNoYXRcIix5YW5kZXg6XCJZYW5kZXggQnJvd3NlclwifTt0LlBMQVRGT1JNU19NQVA9e3RhYmxldDpcInRhYmxldFwiLG1vYmlsZTpcIm1vYmlsZVwiLGRlc2t0b3A6XCJkZXNrdG9wXCIsdHY6XCJ0dlwifTt0Lk9TX01BUD17V2luZG93c1Bob25lOlwiV2luZG93cyBQaG9uZVwiLFdpbmRvd3M6XCJXaW5kb3dzXCIsTWFjT1M6XCJtYWNPU1wiLGlPUzpcImlPU1wiLEFuZHJvaWQ6XCJBbmRyb2lkXCIsV2ViT1M6XCJXZWJPU1wiLEJsYWNrQmVycnk6XCJCbGFja0JlcnJ5XCIsQmFkYTpcIkJhZGFcIixUaXplbjpcIlRpemVuXCIsTGludXg6XCJMaW51eFwiLENocm9tZU9TOlwiQ2hyb21lIE9TXCIsUGxheVN0YXRpb240OlwiUGxheVN0YXRpb24gNFwiLFJva3U6XCJSb2t1XCJ9O3QuRU5HSU5FX01BUD17RWRnZUhUTUw6XCJFZGdlSFRNTFwiLEJsaW5rOlwiQmxpbmtcIixUcmlkZW50OlwiVHJpZGVudFwiLFByZXN0bzpcIlByZXN0b1wiLEdlY2tvOlwiR2Vja29cIixXZWJLaXQ6XCJXZWJLaXRcIn19LDkwOmZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt0Ll9fZXNNb2R1bGU9ITAsdC5kZWZhdWx0PXZvaWQgMDt2YXIgbixpPShuPXIoOTEpKSYmbi5fX2VzTW9kdWxlP246e2RlZmF1bHQ6bn0scz1yKDE4KTtmdW5jdGlvbiBhKGUsdCl7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBuPXRbcl07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG4ua2V5LG4pfX12YXIgbz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXt9dmFyIHQscixuO3JldHVybiBlLmdldFBhcnNlcj1mdW5jdGlvbihlLHQpe2lmKHZvaWQgMD09PXQmJih0PSExKSxcInN0cmluZ1wiIT10eXBlb2YgZSl0aHJvdyBuZXcgRXJyb3IoXCJVc2VyQWdlbnQgc2hvdWxkIGJlIGEgc3RyaW5nXCIpO3JldHVybiBuZXcgaS5kZWZhdWx0KGUsdCl9LGUucGFyc2U9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBpLmRlZmF1bHQoZSkuZ2V0UmVzdWx0KCl9LHQ9ZSxuPVt7a2V5OlwiQlJPV1NFUl9NQVBcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcy5CUk9XU0VSX01BUH19LHtrZXk6XCJFTkdJTkVfTUFQXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHMuRU5HSU5FX01BUH19LHtrZXk6XCJPU19NQVBcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcy5PU19NQVB9fSx7a2V5OlwiUExBVEZPUk1TX01BUFwiLGdldDpmdW5jdGlvbigpe3JldHVybiBzLlBMQVRGT1JNU19NQVB9fV0sKHI9bnVsbCkmJmEodC5wcm90b3R5cGUsciksbiYmYSh0LG4pLGV9KCk7dC5kZWZhdWx0PW8sZS5leHBvcnRzPXQuZGVmYXVsdH0sOTE6ZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3QuX19lc01vZHVsZT0hMCx0LmRlZmF1bHQ9dm9pZCAwO3ZhciBuPXUocig5MikpLGk9dShyKDkzKSkscz11KHIoOTQpKSxhPXUocig5NSkpLG89dShyKDE3KSk7ZnVuY3Rpb24gdShlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19dmFyIGQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7aWYodm9pZCAwPT09dCYmKHQ9ITEpLG51bGw9PWV8fFwiXCI9PT1lKXRocm93IG5ldyBFcnJvcihcIlVzZXJBZ2VudCBwYXJhbWV0ZXIgY2FuJ3QgYmUgZW1wdHlcIik7dGhpcy5fdWE9ZSx0aGlzLnBhcnNlZFJlc3VsdD17fSwhMCE9PXQmJnRoaXMucGFyc2UoKX12YXIgdD1lLnByb3RvdHlwZTtyZXR1cm4gdC5nZXRVQT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl91YX0sdC50ZXN0PWZ1bmN0aW9uKGUpe3JldHVybiBlLnRlc3QodGhpcy5fdWEpfSx0LnBhcnNlQnJvd3Nlcj1mdW5jdGlvbigpe3ZhciBlPXRoaXM7dGhpcy5wYXJzZWRSZXN1bHQuYnJvd3Nlcj17fTt2YXIgdD1vLmRlZmF1bHQuZmluZChuLmRlZmF1bHQsKGZ1bmN0aW9uKHQpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIHQudGVzdClyZXR1cm4gdC50ZXN0KGUpO2lmKHQudGVzdCBpbnN0YW5jZW9mIEFycmF5KXJldHVybiB0LnRlc3Quc29tZSgoZnVuY3Rpb24odCl7cmV0dXJuIGUudGVzdCh0KX0pKTt0aHJvdyBuZXcgRXJyb3IoXCJCcm93c2VyJ3MgdGVzdCBmdW5jdGlvbiBpcyBub3QgdmFsaWRcIil9KSk7cmV0dXJuIHQmJih0aGlzLnBhcnNlZFJlc3VsdC5icm93c2VyPXQuZGVzY3JpYmUodGhpcy5nZXRVQSgpKSksdGhpcy5wYXJzZWRSZXN1bHQuYnJvd3Nlcn0sdC5nZXRCcm93c2VyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGFyc2VkUmVzdWx0LmJyb3dzZXI/dGhpcy5wYXJzZWRSZXN1bHQuYnJvd3Nlcjp0aGlzLnBhcnNlQnJvd3NlcigpfSx0LmdldEJyb3dzZXJOYW1lPWZ1bmN0aW9uKGUpe3JldHVybiBlP1N0cmluZyh0aGlzLmdldEJyb3dzZXIoKS5uYW1lKS50b0xvd2VyQ2FzZSgpfHxcIlwiOnRoaXMuZ2V0QnJvd3NlcigpLm5hbWV8fFwiXCJ9LHQuZ2V0QnJvd3NlclZlcnNpb249ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRCcm93c2VyKCkudmVyc2lvbn0sdC5nZXRPUz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBhcnNlZFJlc3VsdC5vcz90aGlzLnBhcnNlZFJlc3VsdC5vczp0aGlzLnBhcnNlT1MoKX0sdC5wYXJzZU9TPWZ1bmN0aW9uKCl7dmFyIGU9dGhpczt0aGlzLnBhcnNlZFJlc3VsdC5vcz17fTt2YXIgdD1vLmRlZmF1bHQuZmluZChpLmRlZmF1bHQsKGZ1bmN0aW9uKHQpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIHQudGVzdClyZXR1cm4gdC50ZXN0KGUpO2lmKHQudGVzdCBpbnN0YW5jZW9mIEFycmF5KXJldHVybiB0LnRlc3Quc29tZSgoZnVuY3Rpb24odCl7cmV0dXJuIGUudGVzdCh0KX0pKTt0aHJvdyBuZXcgRXJyb3IoXCJCcm93c2VyJ3MgdGVzdCBmdW5jdGlvbiBpcyBub3QgdmFsaWRcIil9KSk7cmV0dXJuIHQmJih0aGlzLnBhcnNlZFJlc3VsdC5vcz10LmRlc2NyaWJlKHRoaXMuZ2V0VUEoKSkpLHRoaXMucGFyc2VkUmVzdWx0Lm9zfSx0LmdldE9TTmFtZT1mdW5jdGlvbihlKXt2YXIgdD10aGlzLmdldE9TKCkubmFtZTtyZXR1cm4gZT9TdHJpbmcodCkudG9Mb3dlckNhc2UoKXx8XCJcIjp0fHxcIlwifSx0LmdldE9TVmVyc2lvbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdldE9TKCkudmVyc2lvbn0sdC5nZXRQbGF0Zm9ybT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBhcnNlZFJlc3VsdC5wbGF0Zm9ybT90aGlzLnBhcnNlZFJlc3VsdC5wbGF0Zm9ybTp0aGlzLnBhcnNlUGxhdGZvcm0oKX0sdC5nZXRQbGF0Zm9ybVR5cGU9ZnVuY3Rpb24oZSl7dm9pZCAwPT09ZSYmKGU9ITEpO3ZhciB0PXRoaXMuZ2V0UGxhdGZvcm0oKS50eXBlO3JldHVybiBlP1N0cmluZyh0KS50b0xvd2VyQ2FzZSgpfHxcIlwiOnR8fFwiXCJ9LHQucGFyc2VQbGF0Zm9ybT1mdW5jdGlvbigpe3ZhciBlPXRoaXM7dGhpcy5wYXJzZWRSZXN1bHQucGxhdGZvcm09e307dmFyIHQ9by5kZWZhdWx0LmZpbmQocy5kZWZhdWx0LChmdW5jdGlvbih0KXtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LnRlc3QpcmV0dXJuIHQudGVzdChlKTtpZih0LnRlc3QgaW5zdGFuY2VvZiBBcnJheSlyZXR1cm4gdC50ZXN0LnNvbWUoKGZ1bmN0aW9uKHQpe3JldHVybiBlLnRlc3QodCl9KSk7dGhyb3cgbmV3IEVycm9yKFwiQnJvd3NlcidzIHRlc3QgZnVuY3Rpb24gaXMgbm90IHZhbGlkXCIpfSkpO3JldHVybiB0JiYodGhpcy5wYXJzZWRSZXN1bHQucGxhdGZvcm09dC5kZXNjcmliZSh0aGlzLmdldFVBKCkpKSx0aGlzLnBhcnNlZFJlc3VsdC5wbGF0Zm9ybX0sdC5nZXRFbmdpbmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXJzZWRSZXN1bHQuZW5naW5lP3RoaXMucGFyc2VkUmVzdWx0LmVuZ2luZTp0aGlzLnBhcnNlRW5naW5lKCl9LHQuZ2V0RW5naW5lTmFtZT1mdW5jdGlvbihlKXtyZXR1cm4gZT9TdHJpbmcodGhpcy5nZXRFbmdpbmUoKS5uYW1lKS50b0xvd2VyQ2FzZSgpfHxcIlwiOnRoaXMuZ2V0RW5naW5lKCkubmFtZXx8XCJcIn0sdC5wYXJzZUVuZ2luZT1mdW5jdGlvbigpe3ZhciBlPXRoaXM7dGhpcy5wYXJzZWRSZXN1bHQuZW5naW5lPXt9O3ZhciB0PW8uZGVmYXVsdC5maW5kKGEuZGVmYXVsdCwoZnVuY3Rpb24odCl7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgdC50ZXN0KXJldHVybiB0LnRlc3QoZSk7aWYodC50ZXN0IGluc3RhbmNlb2YgQXJyYXkpcmV0dXJuIHQudGVzdC5zb21lKChmdW5jdGlvbih0KXtyZXR1cm4gZS50ZXN0KHQpfSkpO3Rocm93IG5ldyBFcnJvcihcIkJyb3dzZXIncyB0ZXN0IGZ1bmN0aW9uIGlzIG5vdCB2YWxpZFwiKX0pKTtyZXR1cm4gdCYmKHRoaXMucGFyc2VkUmVzdWx0LmVuZ2luZT10LmRlc2NyaWJlKHRoaXMuZ2V0VUEoKSkpLHRoaXMucGFyc2VkUmVzdWx0LmVuZ2luZX0sdC5wYXJzZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBhcnNlQnJvd3NlcigpLHRoaXMucGFyc2VPUygpLHRoaXMucGFyc2VQbGF0Zm9ybSgpLHRoaXMucGFyc2VFbmdpbmUoKSx0aGlzfSx0LmdldFJlc3VsdD1mdW5jdGlvbigpe3JldHVybiBvLmRlZmF1bHQuYXNzaWduKHt9LHRoaXMucGFyc2VkUmVzdWx0KX0sdC5zYXRpc2ZpZXM9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcyxyPXt9LG49MCxpPXt9LHM9MDtpZihPYmplY3Qua2V5cyhlKS5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgYT1lW3RdO1wic3RyaW5nXCI9PXR5cGVvZiBhPyhpW3RdPWEscys9MSk6XCJvYmplY3RcIj09dHlwZW9mIGEmJihyW3RdPWEsbis9MSl9KSksbj4wKXt2YXIgYT1PYmplY3Qua2V5cyhyKSx1PW8uZGVmYXVsdC5maW5kKGEsKGZ1bmN0aW9uKGUpe3JldHVybiB0LmlzT1MoZSl9KSk7aWYodSl7dmFyIGQ9dGhpcy5zYXRpc2ZpZXMoclt1XSk7aWYodm9pZCAwIT09ZClyZXR1cm4gZH12YXIgYz1vLmRlZmF1bHQuZmluZChhLChmdW5jdGlvbihlKXtyZXR1cm4gdC5pc1BsYXRmb3JtKGUpfSkpO2lmKGMpe3ZhciBmPXRoaXMuc2F0aXNmaWVzKHJbY10pO2lmKHZvaWQgMCE9PWYpcmV0dXJuIGZ9fWlmKHM+MCl7dmFyIGw9T2JqZWN0LmtleXMoaSksaD1vLmRlZmF1bHQuZmluZChsLChmdW5jdGlvbihlKXtyZXR1cm4gdC5pc0Jyb3dzZXIoZSwhMCl9KSk7aWYodm9pZCAwIT09aClyZXR1cm4gdGhpcy5jb21wYXJlVmVyc2lvbihpW2hdKX19LHQuaXNCcm93c2VyPWZ1bmN0aW9uKGUsdCl7dm9pZCAwPT09dCYmKHQ9ITEpO3ZhciByPXRoaXMuZ2V0QnJvd3Nlck5hbWUoKS50b0xvd2VyQ2FzZSgpLG49ZS50b0xvd2VyQ2FzZSgpLGk9by5kZWZhdWx0LmdldEJyb3dzZXJUeXBlQnlBbGlhcyhuKTtyZXR1cm4gdCYmaSYmKG49aS50b0xvd2VyQ2FzZSgpKSxuPT09cn0sdC5jb21wYXJlVmVyc2lvbj1mdW5jdGlvbihlKXt2YXIgdD1bMF0scj1lLG49ITEsaT10aGlzLmdldEJyb3dzZXJWZXJzaW9uKCk7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGkpcmV0dXJuXCI+XCI9PT1lWzBdfHxcIjxcIj09PWVbMF0/KHI9ZS5zdWJzdHIoMSksXCI9XCI9PT1lWzFdPyhuPSEwLHI9ZS5zdWJzdHIoMikpOnQ9W10sXCI+XCI9PT1lWzBdP3QucHVzaCgxKTp0LnB1c2goLTEpKTpcIj1cIj09PWVbMF0/cj1lLnN1YnN0cigxKTpcIn5cIj09PWVbMF0mJihuPSEwLHI9ZS5zdWJzdHIoMSkpLHQuaW5kZXhPZihvLmRlZmF1bHQuY29tcGFyZVZlcnNpb25zKGkscixuKSk+LTF9LHQuaXNPUz1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5nZXRPU05hbWUoITApPT09U3RyaW5nKGUpLnRvTG93ZXJDYXNlKCl9LHQuaXNQbGF0Zm9ybT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5nZXRQbGF0Zm9ybVR5cGUoITApPT09U3RyaW5nKGUpLnRvTG93ZXJDYXNlKCl9LHQuaXNFbmdpbmU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZ2V0RW5naW5lTmFtZSghMCk9PT1TdHJpbmcoZSkudG9Mb3dlckNhc2UoKX0sdC5pcz1mdW5jdGlvbihlLHQpe3JldHVybiB2b2lkIDA9PT10JiYodD0hMSksdGhpcy5pc0Jyb3dzZXIoZSx0KXx8dGhpcy5pc09TKGUpfHx0aGlzLmlzUGxhdGZvcm0oZSl9LHQuc29tZT1mdW5jdGlvbihlKXt2YXIgdD10aGlzO3JldHVybiB2b2lkIDA9PT1lJiYoZT1bXSksZS5zb21lKChmdW5jdGlvbihlKXtyZXR1cm4gdC5pcyhlKX0pKX0sZX0oKTt0LmRlZmF1bHQ9ZCxlLmV4cG9ydHM9dC5kZWZhdWx0fSw5MjpmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dC5fX2VzTW9kdWxlPSEwLHQuZGVmYXVsdD12b2lkIDA7dmFyIG4saT0obj1yKDE3KSkmJm4uX19lc01vZHVsZT9uOntkZWZhdWx0Om59O3ZhciBzPS92ZXJzaW9uXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGE9W3t0ZXN0OlsvZ29vZ2xlYm90L2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiR29vZ2xlYm90XCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL2dvb2dsZWJvdFxcLyhcXGQrKFxcLlxcZCspKS9pLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL29wZXJhL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiT3BlcmFcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86b3BlcmEpW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL29wclxcL3xvcGlvcy9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIk9wZXJhXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/Om9wcnxvcGlvcylbXFxzL10oXFxTKykvaSxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9TYW1zdW5nQnJvd3Nlci9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIlNhbXN1bmcgSW50ZXJuZXQgZm9yIEFuZHJvaWRcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86U2Ftc3VuZ0Jyb3dzZXIpW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL1doYWxlL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiTkFWRVIgV2hhbGUgQnJvd3NlclwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzp3aGFsZSlbXFxzL10oXFxkKyg/OlxcLlxcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9NWkJyb3dzZXIvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJNWiBCcm93c2VyXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/Ok1aQnJvd3NlcilbXFxzL10oXFxkKyg/OlxcLlxcZCspKykvaSxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9mb2N1cy9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIkZvY3VzXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/OmZvY3VzKVtcXHMvXShcXGQrKD86XFwuXFxkKykrKS9pLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL3N3aW5nL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiU3dpbmdcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86c3dpbmcpW1xccy9dKFxcZCsoPzpcXC5cXGQrKSspL2ksZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvY29hc3QvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJPcGVyYSBDb2FzdFwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzpjb2FzdClbXFxzL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0Olsvb3B0XFwvXFxkKyg/Oi4/Xz9cXGQrKSsvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJPcGVyYSBUb3VjaFwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzpvcHQpW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL3lhYnJvd3Nlci9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIllhbmRleCBCcm93c2VyXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/OnlhYnJvd3NlcilbXFxzL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvdWNicm93c2VyL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiVUMgQnJvd3NlclwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzp1Y2Jyb3dzZXIpW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL01heHRob258bXhpb3MvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJNYXh0aG9uXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/Ok1heHRob258bXhpb3MpW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL2VwaXBoYW55L2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiRXBpcGhhbnlcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86ZXBpcGhhbnkpW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL3B1ZmZpbi9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIlB1ZmZpblwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzpwdWZmaW4pW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL3NsZWlwbmlyL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiU2xlaXBuaXJcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86c2xlaXBuaXIpW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL2stbWVsZW9uL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiSy1NZWxlb25cIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86ay1tZWxlb24pW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL21pY3JvbWVzc2VuZ2VyL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiV2VDaGF0XCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/Om1pY3JvbWVzc2VuZ2VyKVtcXHMvXShcXGQrKFxcLj9fP1xcZCspKykvaSxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9xcWJyb3dzZXIvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6L3FxYnJvd3NlcmxpdGUvaS50ZXN0KGUpP1wiUVEgQnJvd3NlciBMaXRlXCI6XCJRUSBCcm93c2VyXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/OnFxYnJvd3NlcmxpdGV8cXFicm93c2VyKVsvXShcXGQrKFxcLj9fP1xcZCspKykvaSxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9tc2llfHRyaWRlbnQvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJJbnRlcm5ldCBFeHBsb3JlclwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzptc2llIHxydjopKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL1xcc2VkZ1xcLy9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIk1pY3Jvc29mdCBFZGdlXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL1xcc2VkZ1xcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9lZGcoW2VhXXxpb3MpL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiTWljcm9zb2Z0IEVkZ2VcIn0scj1pLmRlZmF1bHQuZ2V0U2Vjb25kTWF0Y2goL2VkZyhbZWFdfGlvcylcXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0Olsvdml2YWxkaS9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIlZpdmFsZGlcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvdml2YWxkaVxcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9zZWFtb25rZXkvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJTZWFNb25rZXlcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvc2VhbW9ua2V5XFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL3NhaWxmaXNoL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiU2FpbGZpc2hcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvc2FpbGZpc2hcXHM/YnJvd3NlclxcLyhcXGQrKFxcLlxcZCspPykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9zaWxrL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiQW1hem9uIFNpbGtcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvc2lsa1xcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9waGFudG9tL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiUGhhbnRvbUpTXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL3BoYW50b21qc1xcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9zbGltZXJqcy9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIlNsaW1lckpTXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL3NsaW1lcmpzXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL2JsYWNrYmVycnl8XFxiYmJcXGQrL2ksL3JpbVxcc3RhYmxldC9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIkJsYWNrQmVycnlcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvYmxhY2tiZXJyeVtcXGRdK1xcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy8od2VifGhwdylbbzBdcy9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIldlYk9TIEJyb3dzZXJcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvdyg/OmViKT9bbzBdc2Jyb3dzZXJcXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvYmFkYS9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIkJhZGFcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvZG9sZmluXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL3RpemVuL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiVGl6ZW5cIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86dGl6ZW5cXHM/KT9icm93c2VyXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL3F1cHppbGxhL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiUXVwWmlsbGFcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86cXVwemlsbGEpW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL2ZpcmVmb3h8aWNld2Vhc2VsfGZ4aW9zL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiRmlyZWZveFwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzpmaXJlZm94fGljZXdlYXNlbHxmeGlvcylbXFxzL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvZWxlY3Ryb24vaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJFbGVjdHJvblwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzplbGVjdHJvbilcXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvTWl1aUJyb3dzZXIvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJNaXVpXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/Ok1pdWlCcm93c2VyKVtcXHMvXShcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9jaHJvbWl1bS9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIkNocm9taXVtXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/OmNocm9taXVtKVtcXHMvXShcXGQrKFxcLj9fP1xcZCspKykvaSxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9jaHJvbWV8Y3Jpb3N8Y3Jtby9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIkNocm9tZVwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzpjaHJvbWV8Y3Jpb3N8Y3JtbylcXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvR1NBL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiR29vZ2xlIFNlYXJjaFwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzpHU0EpXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpmdW5jdGlvbihlKXt2YXIgdD0hZS50ZXN0KC9saWtlIGFuZHJvaWQvaSkscj1lLnRlc3QoL2FuZHJvaWQvaSk7cmV0dXJuIHQmJnJ9LGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiQW5kcm9pZCBCcm93c2VyXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9wbGF5c3RhdGlvbiA0L2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiUGxheVN0YXRpb24gNFwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0Olsvc2FmYXJpfGFwcGxld2Via2l0L2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiU2FmYXJpXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy8uKi9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD0tMSE9PWUuc2VhcmNoKFwiXFxcXChcIik/L14oLiopXFwvKC4qKVsgXFx0XVxcKCguKikvOi9eKC4qKVxcLyguKikgLztyZXR1cm57bmFtZTppLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCh0LGUpLHZlcnNpb246aS5kZWZhdWx0LmdldFNlY29uZE1hdGNoKHQsZSl9fX1dO3QuZGVmYXVsdD1hLGUuZXhwb3J0cz10LmRlZmF1bHR9LDkzOmZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt0Ll9fZXNNb2R1bGU9ITAsdC5kZWZhdWx0PXZvaWQgMDt2YXIgbixpPShuPXIoMTcpKSYmbi5fX2VzTW9kdWxlP246e2RlZmF1bHQ6bn0scz1yKDE4KTt2YXIgYT1be3Rlc3Q6Wy9Sb2t1XFwvRFZQL10sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL1Jva3VcXC9EVlAtKFxcZCtcXC5cXGQrKS9pLGUpO3JldHVybntuYW1lOnMuT1NfTUFQLlJva3UsdmVyc2lvbjp0fX19LHt0ZXN0Olsvd2luZG93cyBwaG9uZS9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvd2luZG93cyBwaG9uZSAoPzpvcyk/XFxzPyhcXGQrKFxcLlxcZCspKikvaSxlKTtyZXR1cm57bmFtZTpzLk9TX01BUC5XaW5kb3dzUGhvbmUsdmVyc2lvbjp0fX19LHt0ZXN0Olsvd2luZG93cyAvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL1dpbmRvd3MgKChOVHxYUCkoIFxcZFxcZD8uXFxkKT8pL2ksZSkscj1pLmRlZmF1bHQuZ2V0V2luZG93c1ZlcnNpb25OYW1lKHQpO3JldHVybntuYW1lOnMuT1NfTUFQLldpbmRvd3MsdmVyc2lvbjp0LHZlcnNpb25OYW1lOnJ9fX0se3Rlc3Q6Wy9NYWNpbnRvc2goLio/KSBGeGlPUyguKj8pXFwvL10sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6cy5PU19NQVAuaU9TfSxyPWkuZGVmYXVsdC5nZXRTZWNvbmRNYXRjaCgvKFZlcnNpb25cXC8pKFxcZFtcXGQuXSspLyxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9tYWNpbnRvc2gvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL21hYyBvcyB4IChcXGQrKFxcLj9fP1xcZCspKykvaSxlKS5yZXBsYWNlKC9bX1xcc10vZyxcIi5cIikscj1pLmRlZmF1bHQuZ2V0TWFjT1NWZXJzaW9uTmFtZSh0KSxuPXtuYW1lOnMuT1NfTUFQLk1hY09TLHZlcnNpb246dH07cmV0dXJuIHImJihuLnZlcnNpb25OYW1lPXIpLG59fSx7dGVzdDpbLyhpcG9kfGlwaG9uZXxpcGFkKS9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvb3MgKFxcZCsoW19cXHNdXFxkKykqKSBsaWtlIG1hYyBvcyB4L2ksZSkucmVwbGFjZSgvW19cXHNdL2csXCIuXCIpO3JldHVybntuYW1lOnMuT1NfTUFQLmlPUyx2ZXJzaW9uOnR9fX0se3Rlc3Q6ZnVuY3Rpb24oZSl7dmFyIHQ9IWUudGVzdCgvbGlrZSBhbmRyb2lkL2kpLHI9ZS50ZXN0KC9hbmRyb2lkL2kpO3JldHVybiB0JiZyfSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvYW5kcm9pZFtcXHMvLV0oXFxkKyhcXC5cXGQrKSopL2ksZSkscj1pLmRlZmF1bHQuZ2V0QW5kcm9pZFZlcnNpb25OYW1lKHQpLG49e25hbWU6cy5PU19NQVAuQW5kcm9pZCx2ZXJzaW9uOnR9O3JldHVybiByJiYobi52ZXJzaW9uTmFtZT1yKSxufX0se3Rlc3Q6Wy8od2VifGhwdylbbzBdcy9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86d2VifGhwdylbbzBdc1xcLyhcXGQrKFxcLlxcZCspKikvaSxlKSxyPXtuYW1lOnMuT1NfTUFQLldlYk9TfTtyZXR1cm4gdCYmdC5sZW5ndGgmJihyLnZlcnNpb249dCkscn19LHt0ZXN0OlsvYmxhY2tiZXJyeXxcXGJiYlxcZCsvaSwvcmltXFxzdGFibGV0L2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC9yaW1cXHN0YWJsZXRcXHNvc1xccyhcXGQrKFxcLlxcZCspKikvaSxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL2JsYWNrYmVycnlcXGQrXFwvKFxcZCsoW19cXHNdXFxkKykqKS9pLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvXFxiYmIoXFxkKykvaSxlKTtyZXR1cm57bmFtZTpzLk9TX01BUC5CbGFja0JlcnJ5LHZlcnNpb246dH19fSx7dGVzdDpbL2JhZGEvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL2JhZGFcXC8oXFxkKyhcXC5cXGQrKSopL2ksZSk7cmV0dXJue25hbWU6cy5PU19NQVAuQmFkYSx2ZXJzaW9uOnR9fX0se3Rlc3Q6Wy90aXplbi9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvdGl6ZW5bL1xcc10oXFxkKyhcXC5cXGQrKSopL2ksZSk7cmV0dXJue25hbWU6cy5PU19NQVAuVGl6ZW4sdmVyc2lvbjp0fX19LHt0ZXN0OlsvbGludXgvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57bmFtZTpzLk9TX01BUC5MaW51eH19fSx7dGVzdDpbL0NyT1MvXSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybntuYW1lOnMuT1NfTUFQLkNocm9tZU9TfX19LHt0ZXN0OlsvUGxheVN0YXRpb24gNC9dLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC9QbGF5U3RhdGlvbiA0Wy9cXHNdKFxcZCsoXFwuXFxkKykqKS9pLGUpO3JldHVybntuYW1lOnMuT1NfTUFQLlBsYXlTdGF0aW9uNCx2ZXJzaW9uOnR9fX1dO3QuZGVmYXVsdD1hLGUuZXhwb3J0cz10LmRlZmF1bHR9LDk0OmZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt0Ll9fZXNNb2R1bGU9ITAsdC5kZWZhdWx0PXZvaWQgMDt2YXIgbixpPShuPXIoMTcpKSYmbi5fX2VzTW9kdWxlP246e2RlZmF1bHQ6bn0scz1yKDE4KTt2YXIgYT1be3Rlc3Q6Wy9nb29nbGVib3QvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpcImJvdFwiLHZlbmRvcjpcIkdvb2dsZVwifX19LHt0ZXN0OlsvaHVhd2VpL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oY2FuLWwwMSkvaSxlKSYmXCJOb3ZhXCIscj17dHlwZTpzLlBMQVRGT1JNU19NQVAubW9iaWxlLHZlbmRvcjpcIkh1YXdlaVwifTtyZXR1cm4gdCYmKHIubW9kZWw9dCkscn19LHt0ZXN0OlsvbmV4dXNcXHMqKD86N3w4fDl8MTApLiovaV0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpzLlBMQVRGT1JNU19NQVAudGFibGV0LHZlbmRvcjpcIk5leHVzXCJ9fX0se3Rlc3Q6Wy9pcGFkL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLnRhYmxldCx2ZW5kb3I6XCJBcHBsZVwiLG1vZGVsOlwiaVBhZFwifX19LHt0ZXN0OlsvTWFjaW50b3NoKC4qPykgRnhpT1MoLio/KVxcLy9dLGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLnRhYmxldCx2ZW5kb3I6XCJBcHBsZVwiLG1vZGVsOlwiaVBhZFwifX19LHt0ZXN0Olsva2Z0dCBidWlsZC9pXSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybnt0eXBlOnMuUExBVEZPUk1TX01BUC50YWJsZXQsdmVuZG9yOlwiQW1hem9uXCIsbW9kZWw6XCJLaW5kbGUgRmlyZSBIRCA3XCJ9fX0se3Rlc3Q6Wy9zaWxrL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLnRhYmxldCx2ZW5kb3I6XCJBbWF6b25cIn19fSx7dGVzdDpbL3RhYmxldCg/ISBwYykvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpzLlBMQVRGT1JNU19NQVAudGFibGV0fX19LHt0ZXN0OmZ1bmN0aW9uKGUpe3ZhciB0PWUudGVzdCgvaXBvZHxpcGhvbmUvaSkscj1lLnRlc3QoL2xpa2UgKGlwb2R8aXBob25lKS9pKTtyZXR1cm4gdCYmIXJ9LGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oaXBvZHxpcGhvbmUpL2ksZSk7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLm1vYmlsZSx2ZW5kb3I6XCJBcHBsZVwiLG1vZGVsOnR9fX0se3Rlc3Q6Wy9uZXh1c1xccypbMC02XS4qL2ksL2dhbGF4eSBuZXh1cy9pXSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybnt0eXBlOnMuUExBVEZPUk1TX01BUC5tb2JpbGUsdmVuZG9yOlwiTmV4dXNcIn19fSx7dGVzdDpbL1teLV1tb2JpL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLm1vYmlsZX19fSx7dGVzdDpmdW5jdGlvbihlKXtyZXR1cm5cImJsYWNrYmVycnlcIj09PWUuZ2V0QnJvd3Nlck5hbWUoITApfSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybnt0eXBlOnMuUExBVEZPUk1TX01BUC5tb2JpbGUsdmVuZG9yOlwiQmxhY2tCZXJyeVwifX19LHt0ZXN0OmZ1bmN0aW9uKGUpe3JldHVyblwiYmFkYVwiPT09ZS5nZXRCcm93c2VyTmFtZSghMCl9LGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLm1vYmlsZX19fSx7dGVzdDpmdW5jdGlvbihlKXtyZXR1cm5cIndpbmRvd3MgcGhvbmVcIj09PWUuZ2V0QnJvd3Nlck5hbWUoKX0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpzLlBMQVRGT1JNU19NQVAubW9iaWxlLHZlbmRvcjpcIk1pY3Jvc29mdFwifX19LHt0ZXN0OmZ1bmN0aW9uKGUpe3ZhciB0PU51bWJlcihTdHJpbmcoZS5nZXRPU1ZlcnNpb24oKSkuc3BsaXQoXCIuXCIpWzBdKTtyZXR1cm5cImFuZHJvaWRcIj09PWUuZ2V0T1NOYW1lKCEwKSYmdD49M30sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpzLlBMQVRGT1JNU19NQVAudGFibGV0fX19LHt0ZXN0OmZ1bmN0aW9uKGUpe3JldHVyblwiYW5kcm9pZFwiPT09ZS5nZXRPU05hbWUoITApfSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybnt0eXBlOnMuUExBVEZPUk1TX01BUC5tb2JpbGV9fX0se3Rlc3Q6ZnVuY3Rpb24oZSl7cmV0dXJuXCJtYWNvc1wiPT09ZS5nZXRPU05hbWUoITApfSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybnt0eXBlOnMuUExBVEZPUk1TX01BUC5kZXNrdG9wLHZlbmRvcjpcIkFwcGxlXCJ9fX0se3Rlc3Q6ZnVuY3Rpb24oZSl7cmV0dXJuXCJ3aW5kb3dzXCI9PT1lLmdldE9TTmFtZSghMCl9LGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLmRlc2t0b3B9fX0se3Rlc3Q6ZnVuY3Rpb24oZSl7cmV0dXJuXCJsaW51eFwiPT09ZS5nZXRPU05hbWUoITApfSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybnt0eXBlOnMuUExBVEZPUk1TX01BUC5kZXNrdG9wfX19LHt0ZXN0OmZ1bmN0aW9uKGUpe3JldHVyblwicGxheXN0YXRpb24gNFwiPT09ZS5nZXRPU05hbWUoITApfSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybnt0eXBlOnMuUExBVEZPUk1TX01BUC50dn19fSx7dGVzdDpmdW5jdGlvbihlKXtyZXR1cm5cInJva3VcIj09PWUuZ2V0T1NOYW1lKCEwKX0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpzLlBMQVRGT1JNU19NQVAudHZ9fX1dO3QuZGVmYXVsdD1hLGUuZXhwb3J0cz10LmRlZmF1bHR9LDk1OmZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt0Ll9fZXNNb2R1bGU9ITAsdC5kZWZhdWx0PXZvaWQgMDt2YXIgbixpPShuPXIoMTcpKSYmbi5fX2VzTW9kdWxlP246e2RlZmF1bHQ6bn0scz1yKDE4KTt2YXIgYT1be3Rlc3Q6ZnVuY3Rpb24oZSl7cmV0dXJuXCJtaWNyb3NvZnQgZWRnZVwiPT09ZS5nZXRCcm93c2VyTmFtZSghMCl9LGRlc2NyaWJlOmZ1bmN0aW9uKGUpe2lmKC9cXHNlZGdcXC8vaS50ZXN0KGUpKXJldHVybntuYW1lOnMuRU5HSU5FX01BUC5CbGlua307dmFyIHQ9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL2VkZ2VcXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJue25hbWU6cy5FTkdJTkVfTUFQLkVkZ2VIVE1MLHZlcnNpb246dH19fSx7dGVzdDpbL3RyaWRlbnQvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6cy5FTkdJTkVfTUFQLlRyaWRlbnR9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL3RyaWRlbnRcXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OmZ1bmN0aW9uKGUpe3JldHVybiBlLnRlc3QoL3ByZXN0by9pKX0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6cy5FTkdJTkVfTUFQLlByZXN0b30scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvcHJlc3RvXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpmdW5jdGlvbihlKXt2YXIgdD1lLnRlc3QoL2dlY2tvL2kpLHI9ZS50ZXN0KC9saWtlIGdlY2tvL2kpO3JldHVybiB0JiYhcn0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6cy5FTkdJTkVfTUFQLkdlY2tvfSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC9nZWNrb1xcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy8oYXBwbGUpP3dlYmtpdFxcLzUzN1xcLjM2L2ldLGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue25hbWU6cy5FTkdJTkVfTUFQLkJsaW5rfX19LHt0ZXN0OlsvKGFwcGxlKT93ZWJraXQvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6cy5FTkdJTkVfTUFQLldlYktpdH0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvd2Via2l0XFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fV07dC5kZWZhdWx0PWEsZS5leHBvcnRzPXQuZGVmYXVsdH19KX0pKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/bowser/es5.js\n");

/***/ }),

/***/ "./node_modules/broadcast-channel/dist/esbrowser/broadcast-channel.js":
/*!****************************************************************************!*\
  !*** ./node_modules/broadcast-channel/dist/esbrowser/broadcast-channel.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"OPEN_BROADCAST_CHANNELS\": function() { return /* binding */ OPEN_BROADCAST_CHANNELS; },\n/* harmony export */   \"BroadcastChannel\": function() { return /* binding */ BroadcastChannel; },\n/* harmony export */   \"clearNodeFolder\": function() { return /* binding */ clearNodeFolder; },\n/* harmony export */   \"enforceOptions\": function() { return /* binding */ enforceOptions; }\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util.js */ \"./node_modules/broadcast-channel/dist/esbrowser/util.js\");\n/* harmony import */ var _method_chooser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./method-chooser.js */ \"./node_modules/broadcast-channel/dist/esbrowser/method-chooser.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./options.js */ \"./node_modules/broadcast-channel/dist/esbrowser/options.js\");\n\r\n\r\n\r\n/**\r\n * Contains all open channels,\r\n * used in tests to ensure everything is closed.\r\n */\r\n\r\nvar OPEN_BROADCAST_CHANNELS = new Set();\r\nvar lastId = 0;\r\nvar BroadcastChannel = function BroadcastChannel(name, options) {\r\n  // identifier of the channel to debug stuff\r\n  this.id = lastId++;\r\n  OPEN_BROADCAST_CHANNELS.add(this);\r\n  this.name = name;\r\n\r\n  if (ENFORCED_OPTIONS) {\r\n    options = ENFORCED_OPTIONS;\r\n  }\r\n\r\n  this.options = (0,_options_js__WEBPACK_IMPORTED_MODULE_0__.fillOptionsWithDefaults)(options);\r\n  this.method = (0,_method_chooser_js__WEBPACK_IMPORTED_MODULE_1__.chooseMethod)(this.options); // isListening\r\n\r\n  this._iL = false;\r\n  /**\r\n   * _onMessageListener\r\n   * setting onmessage twice,\r\n   * will overwrite the first listener\r\n   */\r\n\r\n  this._onML = null;\r\n  /**\r\n   * _addEventListeners\r\n   */\r\n\r\n  this._addEL = {\r\n    message: [],\r\n    internal: []\r\n  };\r\n  /**\r\n   * Unsend message promises\r\n   * where the sending is still in progress\r\n   * @type {Set<Promise>}\r\n   */\r\n\r\n  this._uMP = new Set();\r\n  /**\r\n   * _beforeClose\r\n   * array of promises that will be awaited\r\n   * before the channel is closed\r\n   */\r\n\r\n  this._befC = [];\r\n  /**\r\n   * _preparePromise\r\n   */\r\n\r\n  this._prepP = null;\r\n\r\n  _prepareChannel(this);\r\n}; // STATICS\r\n\r\n/**\r\n * used to identify if someone overwrites\r\n * window.BroadcastChannel with this\r\n * See methods/native.js\r\n */\r\n\r\nBroadcastChannel._pubkey = true;\r\n/**\r\n * clears the tmp-folder if is node\r\n * @return {Promise<boolean>} true if has run, false if not node\r\n */\r\n\r\nfunction clearNodeFolder(options) {\r\n  options = (0,_options_js__WEBPACK_IMPORTED_MODULE_0__.fillOptionsWithDefaults)(options);\r\n  var method = (0,_method_chooser_js__WEBPACK_IMPORTED_MODULE_1__.chooseMethod)(options);\r\n\r\n  if (method.type === 'node') {\r\n    return method.clearNodeFolder().then(function () {\r\n      return true;\r\n    });\r\n  } else {\r\n    return _util_js__WEBPACK_IMPORTED_MODULE_2__.PROMISE_RESOLVED_FALSE;\r\n  }\r\n}\r\n/**\r\n * if set, this method is enforced,\r\n * no mather what the options are\r\n */\r\n\r\nvar ENFORCED_OPTIONS;\r\nfunction enforceOptions(options) {\r\n  ENFORCED_OPTIONS = options;\r\n} // PROTOTYPE\r\n\r\nBroadcastChannel.prototype = {\r\n  postMessage: function postMessage(msg) {\r\n    if (this.closed) {\r\n      throw new Error('BroadcastChannel.postMessage(): ' + 'Cannot post message after channel has closed ' +\r\n      /**\r\n       * In the past when this error appeared, it was realy hard to debug.\r\n       * So now we log the msg together with the error so it at least\r\n       * gives some clue about where in your application this happens.\r\n       */\r\n      JSON.stringify(msg));\r\n    }\r\n\r\n    return _post(this, 'message', msg);\r\n  },\r\n  postInternal: function postInternal(msg) {\r\n    return _post(this, 'internal', msg);\r\n  },\r\n\r\n  set onmessage(fn) {\r\n    var time = this.method.microSeconds();\r\n    var listenObj = {\r\n      time: time,\r\n      fn: fn\r\n    };\r\n\r\n    _removeListenerObject(this, 'message', this._onML);\r\n\r\n    if (fn && typeof fn === 'function') {\r\n      this._onML = listenObj;\r\n\r\n      _addListenerObject(this, 'message', listenObj);\r\n    } else {\r\n      this._onML = null;\r\n    }\r\n  },\r\n\r\n  addEventListener: function addEventListener(type, fn) {\r\n    var time = this.method.microSeconds();\r\n    var listenObj = {\r\n      time: time,\r\n      fn: fn\r\n    };\r\n\r\n    _addListenerObject(this, type, listenObj);\r\n  },\r\n  removeEventListener: function removeEventListener(type, fn) {\r\n    var obj = this._addEL[type].find(function (obj) {\r\n      return obj.fn === fn;\r\n    });\r\n\r\n    _removeListenerObject(this, type, obj);\r\n  },\r\n  close: function close() {\r\n    var _this = this;\r\n\r\n    if (this.closed) {\r\n      return;\r\n    }\r\n\r\n    OPEN_BROADCAST_CHANNELS[\"delete\"](this);\r\n    this.closed = true;\r\n    var awaitPrepare = this._prepP ? this._prepP : _util_js__WEBPACK_IMPORTED_MODULE_2__.PROMISE_RESOLVED_VOID;\r\n    this._onML = null;\r\n    this._addEL.message = [];\r\n    return awaitPrepare // wait until all current sending are processed\r\n    .then(function () {\r\n      return Promise.all(Array.from(_this._uMP));\r\n    }) // run before-close hooks\r\n    .then(function () {\r\n      return Promise.all(_this._befC.map(function (fn) {\r\n        return fn();\r\n      }));\r\n    }) // close the channel\r\n    .then(function () {\r\n      return _this.method.close(_this._state);\r\n    });\r\n  },\r\n\r\n  get type() {\r\n    return this.method.type;\r\n  },\r\n\r\n  get isClosed() {\r\n    return this.closed;\r\n  }\r\n\r\n};\r\n/**\r\n * Post a message over the channel\r\n * @returns {Promise} that resolved when the message sending is done\r\n */\r\n\r\nfunction _post(broadcastChannel, type, msg) {\r\n  var time = broadcastChannel.method.microSeconds();\r\n  var msgObj = {\r\n    time: time,\r\n    type: type,\r\n    data: msg\r\n  };\r\n  var awaitPrepare = broadcastChannel._prepP ? broadcastChannel._prepP : _util_js__WEBPACK_IMPORTED_MODULE_2__.PROMISE_RESOLVED_VOID;\r\n  return awaitPrepare.then(function () {\r\n    var sendPromise = broadcastChannel.method.postMessage(broadcastChannel._state, msgObj); // add/remove to unsend messages list\r\n\r\n    broadcastChannel._uMP.add(sendPromise);\r\n\r\n    sendPromise[\"catch\"]().then(function () {\r\n      return broadcastChannel._uMP[\"delete\"](sendPromise);\r\n    });\r\n    return sendPromise;\r\n  });\r\n}\r\n\r\nfunction _prepareChannel(channel) {\r\n  var maybePromise = channel.method.create(channel.name, channel.options);\r\n\r\n  if ((0,_util_js__WEBPACK_IMPORTED_MODULE_2__.isPromise)(maybePromise)) {\r\n    channel._prepP = maybePromise;\r\n    maybePromise.then(function (s) {\r\n      // used in tests to simulate slow runtime\r\n\r\n      /*if (channel.options.prepareDelay) {\r\n           await new Promise(res => setTimeout(res, this.options.prepareDelay));\r\n      }*/\r\n      channel._state = s;\r\n    });\r\n  } else {\r\n    channel._state = maybePromise;\r\n  }\r\n}\r\n\r\nfunction _hasMessageListeners(channel) {\r\n  if (channel._addEL.message.length > 0) return true;\r\n  if (channel._addEL.internal.length > 0) return true;\r\n  return false;\r\n}\r\n\r\nfunction _addListenerObject(channel, type, obj) {\r\n  channel._addEL[type].push(obj);\r\n\r\n  _startListening(channel);\r\n}\r\n\r\nfunction _removeListenerObject(channel, type, obj) {\r\n  channel._addEL[type] = channel._addEL[type].filter(function (o) {\r\n    return o !== obj;\r\n  });\r\n\r\n  _stopListening(channel);\r\n}\r\n\r\nfunction _startListening(channel) {\r\n  if (!channel._iL && _hasMessageListeners(channel)) {\r\n    // someone is listening, start subscribing\r\n    var listenerFn = function listenerFn(msgObj) {\r\n      channel._addEL[msgObj.type].forEach(function (listenerObject) {\r\n        /**\r\n         * Getting the current time in JavaScript has no good precision.\r\n         * So instead of only listening to events that happend 'after' the listener\r\n         * was added, we also listen to events that happended 100ms before it.\r\n         * This ensures that when another process, like a WebWorker, sends events\r\n         * we do not miss them out because their timestamp is a bit off compared to the main process.\r\n         * Not doing this would make messages missing when we send data directly after subscribing and awaiting a response.\r\n         * @link https://johnresig.com/blog/accuracy-of-javascript-time/\r\n         */\r\n        var hundredMsInMicro = 100 * 1000;\r\n        var minMessageTime = listenerObject.time - hundredMsInMicro;\r\n\r\n        if (msgObj.time >= minMessageTime) {\r\n          listenerObject.fn(msgObj.data);\r\n        }\r\n      });\r\n    };\r\n\r\n    var time = channel.method.microSeconds();\r\n\r\n    if (channel._prepP) {\r\n      channel._prepP.then(function () {\r\n        channel._iL = true;\r\n        channel.method.onMessage(channel._state, listenerFn, time);\r\n      });\r\n    } else {\r\n      channel._iL = true;\r\n      channel.method.onMessage(channel._state, listenerFn, time);\r\n    }\r\n  }\r\n}\r\n\r\nfunction _stopListening(channel) {\r\n  if (channel._iL && !_hasMessageListeners(channel)) {\r\n    // noone is listening, stop subscribing\r\n    channel._iL = false;\r\n    var time = channel.method.microSeconds();\r\n    channel.method.onMessage(channel._state, null, time);\r\n  }\r\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYnJvYWRjYXN0LWNoYW5uZWwvZGlzdC9lc2Jyb3dzZXIvYnJvYWRjYXN0LWNoYW5uZWwuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFxRjtBQUNsQztBQUNJO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsb0VBQXVCO0FBQ3hDLGdCQUFnQixnRUFBWSxnQkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNPO0FBQ1AsWUFBWSxvRUFBdUI7QUFDbkMsZUFBZSxnRUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0osV0FBVyw0REFBc0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELDJEQUFxQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLDJEQUFxQjtBQUM5RjtBQUNBLDRGQUE0RjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLG1EQUFTO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYnJvYWRjYXN0LWNoYW5uZWwvZGlzdC9lc2Jyb3dzZXIvYnJvYWRjYXN0LWNoYW5uZWwuanM/ZTI3YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc1Byb21pc2UsIFBST01JU0VfUkVTT0xWRURfRkFMU0UsIFBST01JU0VfUkVTT0xWRURfVk9JRCB9IGZyb20gJy4vdXRpbC5qcyc7XHJcbmltcG9ydCB7IGNob29zZU1ldGhvZCB9IGZyb20gJy4vbWV0aG9kLWNob29zZXIuanMnO1xyXG5pbXBvcnQgeyBmaWxsT3B0aW9uc1dpdGhEZWZhdWx0cyB9IGZyb20gJy4vb3B0aW9ucy5qcyc7XHJcbi8qKlxyXG4gKiBDb250YWlucyBhbGwgb3BlbiBjaGFubmVscyxcclxuICogdXNlZCBpbiB0ZXN0cyB0byBlbnN1cmUgZXZlcnl0aGluZyBpcyBjbG9zZWQuXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBPUEVOX0JST0FEQ0FTVF9DSEFOTkVMUyA9IG5ldyBTZXQoKTtcclxudmFyIGxhc3RJZCA9IDA7XHJcbmV4cG9ydCB2YXIgQnJvYWRjYXN0Q2hhbm5lbCA9IGZ1bmN0aW9uIEJyb2FkY2FzdENoYW5uZWwobmFtZSwgb3B0aW9ucykge1xyXG4gIC8vIGlkZW50aWZpZXIgb2YgdGhlIGNoYW5uZWwgdG8gZGVidWcgc3R1ZmZcclxuICB0aGlzLmlkID0gbGFzdElkKys7XHJcbiAgT1BFTl9CUk9BRENBU1RfQ0hBTk5FTFMuYWRkKHRoaXMpO1xyXG4gIHRoaXMubmFtZSA9IG5hbWU7XHJcblxyXG4gIGlmIChFTkZPUkNFRF9PUFRJT05TKSB7XHJcbiAgICBvcHRpb25zID0gRU5GT1JDRURfT1BUSU9OUztcclxuICB9XHJcblxyXG4gIHRoaXMub3B0aW9ucyA9IGZpbGxPcHRpb25zV2l0aERlZmF1bHRzKG9wdGlvbnMpO1xyXG4gIHRoaXMubWV0aG9kID0gY2hvb3NlTWV0aG9kKHRoaXMub3B0aW9ucyk7IC8vIGlzTGlzdGVuaW5nXHJcblxyXG4gIHRoaXMuX2lMID0gZmFsc2U7XHJcbiAgLyoqXHJcbiAgICogX29uTWVzc2FnZUxpc3RlbmVyXHJcbiAgICogc2V0dGluZyBvbm1lc3NhZ2UgdHdpY2UsXHJcbiAgICogd2lsbCBvdmVyd3JpdGUgdGhlIGZpcnN0IGxpc3RlbmVyXHJcbiAgICovXHJcblxyXG4gIHRoaXMuX29uTUwgPSBudWxsO1xyXG4gIC8qKlxyXG4gICAqIF9hZGRFdmVudExpc3RlbmVyc1xyXG4gICAqL1xyXG5cclxuICB0aGlzLl9hZGRFTCA9IHtcclxuICAgIG1lc3NhZ2U6IFtdLFxyXG4gICAgaW50ZXJuYWw6IFtdXHJcbiAgfTtcclxuICAvKipcclxuICAgKiBVbnNlbmQgbWVzc2FnZSBwcm9taXNlc1xyXG4gICAqIHdoZXJlIHRoZSBzZW5kaW5nIGlzIHN0aWxsIGluIHByb2dyZXNzXHJcbiAgICogQHR5cGUge1NldDxQcm9taXNlPn1cclxuICAgKi9cclxuXHJcbiAgdGhpcy5fdU1QID0gbmV3IFNldCgpO1xyXG4gIC8qKlxyXG4gICAqIF9iZWZvcmVDbG9zZVxyXG4gICAqIGFycmF5IG9mIHByb21pc2VzIHRoYXQgd2lsbCBiZSBhd2FpdGVkXHJcbiAgICogYmVmb3JlIHRoZSBjaGFubmVsIGlzIGNsb3NlZFxyXG4gICAqL1xyXG5cclxuICB0aGlzLl9iZWZDID0gW107XHJcbiAgLyoqXHJcbiAgICogX3ByZXBhcmVQcm9taXNlXHJcbiAgICovXHJcblxyXG4gIHRoaXMuX3ByZXBQID0gbnVsbDtcclxuXHJcbiAgX3ByZXBhcmVDaGFubmVsKHRoaXMpO1xyXG59OyAvLyBTVEFUSUNTXHJcblxyXG4vKipcclxuICogdXNlZCB0byBpZGVudGlmeSBpZiBzb21lb25lIG92ZXJ3cml0ZXNcclxuICogd2luZG93LkJyb2FkY2FzdENoYW5uZWwgd2l0aCB0aGlzXHJcbiAqIFNlZSBtZXRob2RzL25hdGl2ZS5qc1xyXG4gKi9cclxuXHJcbkJyb2FkY2FzdENoYW5uZWwuX3B1YmtleSA9IHRydWU7XHJcbi8qKlxyXG4gKiBjbGVhcnMgdGhlIHRtcC1mb2xkZXIgaWYgaXMgbm9kZVxyXG4gKiBAcmV0dXJuIHtQcm9taXNlPGJvb2xlYW4+fSB0cnVlIGlmIGhhcyBydW4sIGZhbHNlIGlmIG5vdCBub2RlXHJcbiAqL1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyTm9kZUZvbGRlcihvcHRpb25zKSB7XHJcbiAgb3B0aW9ucyA9IGZpbGxPcHRpb25zV2l0aERlZmF1bHRzKG9wdGlvbnMpO1xyXG4gIHZhciBtZXRob2QgPSBjaG9vc2VNZXRob2Qob3B0aW9ucyk7XHJcblxyXG4gIGlmIChtZXRob2QudHlwZSA9PT0gJ25vZGUnKSB7XHJcbiAgICByZXR1cm4gbWV0aG9kLmNsZWFyTm9kZUZvbGRlcigpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gUFJPTUlTRV9SRVNPTFZFRF9GQUxTRTtcclxuICB9XHJcbn1cclxuLyoqXHJcbiAqIGlmIHNldCwgdGhpcyBtZXRob2QgaXMgZW5mb3JjZWQsXHJcbiAqIG5vIG1hdGhlciB3aGF0IHRoZSBvcHRpb25zIGFyZVxyXG4gKi9cclxuXHJcbnZhciBFTkZPUkNFRF9PUFRJT05TO1xyXG5leHBvcnQgZnVuY3Rpb24gZW5mb3JjZU9wdGlvbnMob3B0aW9ucykge1xyXG4gIEVORk9SQ0VEX09QVElPTlMgPSBvcHRpb25zO1xyXG59IC8vIFBST1RPVFlQRVxyXG5cclxuQnJvYWRjYXN0Q2hhbm5lbC5wcm90b3R5cGUgPSB7XHJcbiAgcG9zdE1lc3NhZ2U6IGZ1bmN0aW9uIHBvc3RNZXNzYWdlKG1zZykge1xyXG4gICAgaWYgKHRoaXMuY2xvc2VkKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignQnJvYWRjYXN0Q2hhbm5lbC5wb3N0TWVzc2FnZSgpOiAnICsgJ0Nhbm5vdCBwb3N0IG1lc3NhZ2UgYWZ0ZXIgY2hhbm5lbCBoYXMgY2xvc2VkICcgK1xyXG4gICAgICAvKipcclxuICAgICAgICogSW4gdGhlIHBhc3Qgd2hlbiB0aGlzIGVycm9yIGFwcGVhcmVkLCBpdCB3YXMgcmVhbHkgaGFyZCB0byBkZWJ1Zy5cclxuICAgICAgICogU28gbm93IHdlIGxvZyB0aGUgbXNnIHRvZ2V0aGVyIHdpdGggdGhlIGVycm9yIHNvIGl0IGF0IGxlYXN0XHJcbiAgICAgICAqIGdpdmVzIHNvbWUgY2x1ZSBhYm91dCB3aGVyZSBpbiB5b3VyIGFwcGxpY2F0aW9uIHRoaXMgaGFwcGVucy5cclxuICAgICAgICovXHJcbiAgICAgIEpTT04uc3RyaW5naWZ5KG1zZykpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBfcG9zdCh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XHJcbiAgfSxcclxuICBwb3N0SW50ZXJuYWw6IGZ1bmN0aW9uIHBvc3RJbnRlcm5hbChtc2cpIHtcclxuICAgIHJldHVybiBfcG9zdCh0aGlzLCAnaW50ZXJuYWwnLCBtc2cpO1xyXG4gIH0sXHJcblxyXG4gIHNldCBvbm1lc3NhZ2UoZm4pIHtcclxuICAgIHZhciB0aW1lID0gdGhpcy5tZXRob2QubWljcm9TZWNvbmRzKCk7XHJcbiAgICB2YXIgbGlzdGVuT2JqID0ge1xyXG4gICAgICB0aW1lOiB0aW1lLFxyXG4gICAgICBmbjogZm5cclxuICAgIH07XHJcblxyXG4gICAgX3JlbW92ZUxpc3RlbmVyT2JqZWN0KHRoaXMsICdtZXNzYWdlJywgdGhpcy5fb25NTCk7XHJcblxyXG4gICAgaWYgKGZuICYmIHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICB0aGlzLl9vbk1MID0gbGlzdGVuT2JqO1xyXG5cclxuICAgICAgX2FkZExpc3RlbmVyT2JqZWN0KHRoaXMsICdtZXNzYWdlJywgbGlzdGVuT2JqKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX29uTUwgPSBudWxsO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZm4pIHtcclxuICAgIHZhciB0aW1lID0gdGhpcy5tZXRob2QubWljcm9TZWNvbmRzKCk7XHJcbiAgICB2YXIgbGlzdGVuT2JqID0ge1xyXG4gICAgICB0aW1lOiB0aW1lLFxyXG4gICAgICBmbjogZm5cclxuICAgIH07XHJcblxyXG4gICAgX2FkZExpc3RlbmVyT2JqZWN0KHRoaXMsIHR5cGUsIGxpc3Rlbk9iaik7XHJcbiAgfSxcclxuICByZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGZuKSB7XHJcbiAgICB2YXIgb2JqID0gdGhpcy5fYWRkRUxbdHlwZV0uZmluZChmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgIHJldHVybiBvYmouZm4gPT09IGZuO1xyXG4gICAgfSk7XHJcblxyXG4gICAgX3JlbW92ZUxpc3RlbmVyT2JqZWN0KHRoaXMsIHR5cGUsIG9iaik7XHJcbiAgfSxcclxuICBjbG9zZTogZnVuY3Rpb24gY2xvc2UoKSB7XHJcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cclxuICAgIGlmICh0aGlzLmNsb3NlZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgT1BFTl9CUk9BRENBU1RfQ0hBTk5FTFNbXCJkZWxldGVcIl0odGhpcyk7XHJcbiAgICB0aGlzLmNsb3NlZCA9IHRydWU7XHJcbiAgICB2YXIgYXdhaXRQcmVwYXJlID0gdGhpcy5fcHJlcFAgPyB0aGlzLl9wcmVwUCA6IFBST01JU0VfUkVTT0xWRURfVk9JRDtcclxuICAgIHRoaXMuX29uTUwgPSBudWxsO1xyXG4gICAgdGhpcy5fYWRkRUwubWVzc2FnZSA9IFtdO1xyXG4gICAgcmV0dXJuIGF3YWl0UHJlcGFyZSAvLyB3YWl0IHVudGlsIGFsbCBjdXJyZW50IHNlbmRpbmcgYXJlIHByb2Nlc3NlZFxyXG4gICAgLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoQXJyYXkuZnJvbShfdGhpcy5fdU1QKSk7XHJcbiAgICB9KSAvLyBydW4gYmVmb3JlLWNsb3NlIGhvb2tzXHJcbiAgICAudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChfdGhpcy5fYmVmQy5tYXAoZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgcmV0dXJuIGZuKCk7XHJcbiAgICAgIH0pKTtcclxuICAgIH0pIC8vIGNsb3NlIHRoZSBjaGFubmVsXHJcbiAgICAudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBfdGhpcy5tZXRob2QuY2xvc2UoX3RoaXMuX3N0YXRlKTtcclxuICAgIH0pO1xyXG4gIH0sXHJcblxyXG4gIGdldCB0eXBlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubWV0aG9kLnR5cGU7XHJcbiAgfSxcclxuXHJcbiAgZ2V0IGlzQ2xvc2VkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuY2xvc2VkO1xyXG4gIH1cclxuXHJcbn07XHJcbi8qKlxyXG4gKiBQb3N0IGEgbWVzc2FnZSBvdmVyIHRoZSBjaGFubmVsXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlfSB0aGF0IHJlc29sdmVkIHdoZW4gdGhlIG1lc3NhZ2Ugc2VuZGluZyBpcyBkb25lXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gX3Bvc3QoYnJvYWRjYXN0Q2hhbm5lbCwgdHlwZSwgbXNnKSB7XHJcbiAgdmFyIHRpbWUgPSBicm9hZGNhc3RDaGFubmVsLm1ldGhvZC5taWNyb1NlY29uZHMoKTtcclxuICB2YXIgbXNnT2JqID0ge1xyXG4gICAgdGltZTogdGltZSxcclxuICAgIHR5cGU6IHR5cGUsXHJcbiAgICBkYXRhOiBtc2dcclxuICB9O1xyXG4gIHZhciBhd2FpdFByZXBhcmUgPSBicm9hZGNhc3RDaGFubmVsLl9wcmVwUCA/IGJyb2FkY2FzdENoYW5uZWwuX3ByZXBQIDogUFJPTUlTRV9SRVNPTFZFRF9WT0lEO1xyXG4gIHJldHVybiBhd2FpdFByZXBhcmUudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgc2VuZFByb21pc2UgPSBicm9hZGNhc3RDaGFubmVsLm1ldGhvZC5wb3N0TWVzc2FnZShicm9hZGNhc3RDaGFubmVsLl9zdGF0ZSwgbXNnT2JqKTsgLy8gYWRkL3JlbW92ZSB0byB1bnNlbmQgbWVzc2FnZXMgbGlzdFxyXG5cclxuICAgIGJyb2FkY2FzdENoYW5uZWwuX3VNUC5hZGQoc2VuZFByb21pc2UpO1xyXG5cclxuICAgIHNlbmRQcm9taXNlW1wiY2F0Y2hcIl0oKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIGJyb2FkY2FzdENoYW5uZWwuX3VNUFtcImRlbGV0ZVwiXShzZW5kUHJvbWlzZSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBzZW5kUHJvbWlzZTtcclxuICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gX3ByZXBhcmVDaGFubmVsKGNoYW5uZWwpIHtcclxuICB2YXIgbWF5YmVQcm9taXNlID0gY2hhbm5lbC5tZXRob2QuY3JlYXRlKGNoYW5uZWwubmFtZSwgY2hhbm5lbC5vcHRpb25zKTtcclxuXHJcbiAgaWYgKGlzUHJvbWlzZShtYXliZVByb21pc2UpKSB7XHJcbiAgICBjaGFubmVsLl9wcmVwUCA9IG1heWJlUHJvbWlzZTtcclxuICAgIG1heWJlUHJvbWlzZS50aGVuKGZ1bmN0aW9uIChzKSB7XHJcbiAgICAgIC8vIHVzZWQgaW4gdGVzdHMgdG8gc2ltdWxhdGUgc2xvdyBydW50aW1lXHJcblxyXG4gICAgICAvKmlmIChjaGFubmVsLm9wdGlvbnMucHJlcGFyZURlbGF5KSB7XHJcbiAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCB0aGlzLm9wdGlvbnMucHJlcGFyZURlbGF5KSk7XHJcbiAgICAgIH0qL1xyXG4gICAgICBjaGFubmVsLl9zdGF0ZSA9IHM7XHJcbiAgICB9KTtcclxuICB9IGVsc2Uge1xyXG4gICAgY2hhbm5lbC5fc3RhdGUgPSBtYXliZVByb21pc2U7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBfaGFzTWVzc2FnZUxpc3RlbmVycyhjaGFubmVsKSB7XHJcbiAgaWYgKGNoYW5uZWwuX2FkZEVMLm1lc3NhZ2UubGVuZ3RoID4gMCkgcmV0dXJuIHRydWU7XHJcbiAgaWYgKGNoYW5uZWwuX2FkZEVMLmludGVybmFsLmxlbmd0aCA+IDApIHJldHVybiB0cnVlO1xyXG4gIHJldHVybiBmYWxzZTtcclxufVxyXG5cclxuZnVuY3Rpb24gX2FkZExpc3RlbmVyT2JqZWN0KGNoYW5uZWwsIHR5cGUsIG9iaikge1xyXG4gIGNoYW5uZWwuX2FkZEVMW3R5cGVdLnB1c2gob2JqKTtcclxuXHJcbiAgX3N0YXJ0TGlzdGVuaW5nKGNoYW5uZWwpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfcmVtb3ZlTGlzdGVuZXJPYmplY3QoY2hhbm5lbCwgdHlwZSwgb2JqKSB7XHJcbiAgY2hhbm5lbC5fYWRkRUxbdHlwZV0gPSBjaGFubmVsLl9hZGRFTFt0eXBlXS5maWx0ZXIoZnVuY3Rpb24gKG8pIHtcclxuICAgIHJldHVybiBvICE9PSBvYmo7XHJcbiAgfSk7XHJcblxyXG4gIF9zdG9wTGlzdGVuaW5nKGNoYW5uZWwpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfc3RhcnRMaXN0ZW5pbmcoY2hhbm5lbCkge1xyXG4gIGlmICghY2hhbm5lbC5faUwgJiYgX2hhc01lc3NhZ2VMaXN0ZW5lcnMoY2hhbm5lbCkpIHtcclxuICAgIC8vIHNvbWVvbmUgaXMgbGlzdGVuaW5nLCBzdGFydCBzdWJzY3JpYmluZ1xyXG4gICAgdmFyIGxpc3RlbmVyRm4gPSBmdW5jdGlvbiBsaXN0ZW5lckZuKG1zZ09iaikge1xyXG4gICAgICBjaGFubmVsLl9hZGRFTFttc2dPYmoudHlwZV0uZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXJPYmplY3QpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXR0aW5nIHRoZSBjdXJyZW50IHRpbWUgaW4gSmF2YVNjcmlwdCBoYXMgbm8gZ29vZCBwcmVjaXNpb24uXHJcbiAgICAgICAgICogU28gaW5zdGVhZCBvZiBvbmx5IGxpc3RlbmluZyB0byBldmVudHMgdGhhdCBoYXBwZW5kICdhZnRlcicgdGhlIGxpc3RlbmVyXHJcbiAgICAgICAgICogd2FzIGFkZGVkLCB3ZSBhbHNvIGxpc3RlbiB0byBldmVudHMgdGhhdCBoYXBwZW5kZWQgMTAwbXMgYmVmb3JlIGl0LlxyXG4gICAgICAgICAqIFRoaXMgZW5zdXJlcyB0aGF0IHdoZW4gYW5vdGhlciBwcm9jZXNzLCBsaWtlIGEgV2ViV29ya2VyLCBzZW5kcyBldmVudHNcclxuICAgICAgICAgKiB3ZSBkbyBub3QgbWlzcyB0aGVtIG91dCBiZWNhdXNlIHRoZWlyIHRpbWVzdGFtcCBpcyBhIGJpdCBvZmYgY29tcGFyZWQgdG8gdGhlIG1haW4gcHJvY2Vzcy5cclxuICAgICAgICAgKiBOb3QgZG9pbmcgdGhpcyB3b3VsZCBtYWtlIG1lc3NhZ2VzIG1pc3Npbmcgd2hlbiB3ZSBzZW5kIGRhdGEgZGlyZWN0bHkgYWZ0ZXIgc3Vic2NyaWJpbmcgYW5kIGF3YWl0aW5nIGEgcmVzcG9uc2UuXHJcbiAgICAgICAgICogQGxpbmsgaHR0cHM6Ly9qb2hucmVzaWcuY29tL2Jsb2cvYWNjdXJhY3ktb2YtamF2YXNjcmlwdC10aW1lL1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBodW5kcmVkTXNJbk1pY3JvID0gMTAwICogMTAwMDtcclxuICAgICAgICB2YXIgbWluTWVzc2FnZVRpbWUgPSBsaXN0ZW5lck9iamVjdC50aW1lIC0gaHVuZHJlZE1zSW5NaWNybztcclxuXHJcbiAgICAgICAgaWYgKG1zZ09iai50aW1lID49IG1pbk1lc3NhZ2VUaW1lKSB7XHJcbiAgICAgICAgICBsaXN0ZW5lck9iamVjdC5mbihtc2dPYmouZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIHRpbWUgPSBjaGFubmVsLm1ldGhvZC5taWNyb1NlY29uZHMoKTtcclxuXHJcbiAgICBpZiAoY2hhbm5lbC5fcHJlcFApIHtcclxuICAgICAgY2hhbm5lbC5fcHJlcFAudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY2hhbm5lbC5faUwgPSB0cnVlO1xyXG4gICAgICAgIGNoYW5uZWwubWV0aG9kLm9uTWVzc2FnZShjaGFubmVsLl9zdGF0ZSwgbGlzdGVuZXJGbiwgdGltZSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY2hhbm5lbC5faUwgPSB0cnVlO1xyXG4gICAgICBjaGFubmVsLm1ldGhvZC5vbk1lc3NhZ2UoY2hhbm5lbC5fc3RhdGUsIGxpc3RlbmVyRm4sIHRpbWUpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gX3N0b3BMaXN0ZW5pbmcoY2hhbm5lbCkge1xyXG4gIGlmIChjaGFubmVsLl9pTCAmJiAhX2hhc01lc3NhZ2VMaXN0ZW5lcnMoY2hhbm5lbCkpIHtcclxuICAgIC8vIG5vb25lIGlzIGxpc3RlbmluZywgc3RvcCBzdWJzY3JpYmluZ1xyXG4gICAgY2hhbm5lbC5faUwgPSBmYWxzZTtcclxuICAgIHZhciB0aW1lID0gY2hhbm5lbC5tZXRob2QubWljcm9TZWNvbmRzKCk7XHJcbiAgICBjaGFubmVsLm1ldGhvZC5vbk1lc3NhZ2UoY2hhbm5lbC5fc3RhdGUsIG51bGwsIHRpbWUpO1xyXG4gIH1cclxufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/broadcast-channel/dist/esbrowser/broadcast-channel.js\n");

/***/ }),

/***/ "./node_modules/broadcast-channel/dist/esbrowser/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/broadcast-channel/dist/esbrowser/index.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BroadcastChannel\": function() { return /* reexport safe */ _broadcast_channel__WEBPACK_IMPORTED_MODULE_0__.BroadcastChannel; },\n/* harmony export */   \"clearNodeFolder\": function() { return /* reexport safe */ _broadcast_channel__WEBPACK_IMPORTED_MODULE_0__.clearNodeFolder; },\n/* harmony export */   \"enforceOptions\": function() { return /* reexport safe */ _broadcast_channel__WEBPACK_IMPORTED_MODULE_0__.enforceOptions; },\n/* harmony export */   \"OPEN_BROADCAST_CHANNELS\": function() { return /* reexport safe */ _broadcast_channel__WEBPACK_IMPORTED_MODULE_0__.OPEN_BROADCAST_CHANNELS; },\n/* harmony export */   \"createLeaderElection\": function() { return /* reexport safe */ _leader_election__WEBPACK_IMPORTED_MODULE_1__.createLeaderElection; },\n/* harmony export */   \"beLeader\": function() { return /* reexport safe */ _leader_election__WEBPACK_IMPORTED_MODULE_1__.beLeader; }\n/* harmony export */ });\n/* harmony import */ var _broadcast_channel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./broadcast-channel */ \"./node_modules/broadcast-channel/dist/esbrowser/broadcast-channel.js\");\n/* harmony import */ var _leader_election__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./leader-election */ \"./node_modules/broadcast-channel/dist/esbrowser/leader-election.js\");\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYnJvYWRjYXN0LWNoYW5uZWwvZGlzdC9lc2Jyb3dzZXIvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBaUgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2Jyb2FkY2FzdC1jaGFubmVsL2Rpc3QvZXNicm93c2VyL2luZGV4LmpzP2Y0ZDQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgQnJvYWRjYXN0Q2hhbm5lbCwgY2xlYXJOb2RlRm9sZGVyLCBlbmZvcmNlT3B0aW9ucywgT1BFTl9CUk9BRENBU1RfQ0hBTk5FTFMgfSBmcm9tICcuL2Jyb2FkY2FzdC1jaGFubmVsJztcclxuZXhwb3J0IHsgY3JlYXRlTGVhZGVyRWxlY3Rpb24sIGJlTGVhZGVyIH0gZnJvbSAnLi9sZWFkZXItZWxlY3Rpb24nOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/broadcast-channel/dist/esbrowser/index.js\n");

/***/ }),

/***/ "./node_modules/broadcast-channel/dist/esbrowser/leader-election.js":
/*!**************************************************************************!*\
  !*** ./node_modules/broadcast-channel/dist/esbrowser/leader-election.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"beLeader\": function() { return /* binding */ beLeader; },\n/* harmony export */   \"createLeaderElection\": function() { return /* binding */ createLeaderElection; }\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ \"./node_modules/broadcast-channel/dist/esbrowser/util.js\");\n/* harmony import */ var unload__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! unload */ \"./node_modules/unload/dist/es/index.js\");\n\r\n\r\n\r\nvar LeaderElection = function LeaderElection(broadcastChannel, options) {\r\n  var _this = this;\r\n\r\n  this.broadcastChannel = broadcastChannel;\r\n  this._options = options;\r\n  this.isLeader = false;\r\n  this.hasLeader = false;\r\n  this.isDead = false;\r\n  this.token = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.randomToken)();\r\n  /**\r\n   * Apply Queue,\r\n   * used to ensure we do not run applyOnce()\r\n   * in parallel.\r\n   */\r\n\r\n  this._aplQ = _util_js__WEBPACK_IMPORTED_MODULE_1__.PROMISE_RESOLVED_VOID; // amount of unfinished applyOnce() calls\r\n\r\n  this._aplQC = 0; // things to clean up\r\n\r\n  this._unl = []; // _unloads\r\n\r\n  this._lstns = []; // _listeners\r\n\r\n  this._dpL = function () {}; // onduplicate listener\r\n\r\n\r\n  this._dpLC = false; // true when onduplicate called\r\n\r\n  /**\r\n   * Even when the own instance is not applying,\r\n   * we still listen to messages to ensure the hasLeader flag\r\n   * is set correctly.\r\n   */\r\n\r\n  var hasLeaderListener = function hasLeaderListener(msg) {\r\n    if (msg.context === 'leader') {\r\n      if (msg.action === 'death') {\r\n        _this.hasLeader = false;\r\n      }\r\n\r\n      if (msg.action === 'tell') {\r\n        _this.hasLeader = true;\r\n      }\r\n    }\r\n  };\r\n\r\n  this.broadcastChannel.addEventListener('internal', hasLeaderListener);\r\n\r\n  this._lstns.push(hasLeaderListener);\r\n};\r\n\r\nLeaderElection.prototype = {\r\n  /**\r\n   * Returns true if the instance is leader,\r\n   * false if not.\r\n   * @async\r\n   */\r\n  applyOnce: function applyOnce( // true if the applyOnce() call came from the fallbackInterval cycle\r\n  isFromFallbackInterval) {\r\n    var _this2 = this;\r\n\r\n    if (this.isLeader) {\r\n      return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.sleep)(0, true);\r\n    }\r\n\r\n    if (this.isDead) {\r\n      return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.sleep)(0, false);\r\n    }\r\n    /**\r\n     * Already applying more then once,\r\n     * -> wait for the apply queue to be finished.\r\n     */\r\n\r\n\r\n    if (this._aplQC > 1) {\r\n      return this._aplQ;\r\n    }\r\n    /**\r\n     * Add a new apply-run\r\n     */\r\n\r\n\r\n    var applyRun = function applyRun() {\r\n      /**\r\n       * Optimization shortcuts.\r\n       * Directly return if a previous run\r\n       * has already elected a leader.\r\n       */\r\n      if (_this2.isLeader) {\r\n        return _util_js__WEBPACK_IMPORTED_MODULE_1__.PROMISE_RESOLVED_TRUE;\r\n      }\r\n\r\n      var stopCriteria = false;\r\n      var stopCriteriaPromiseResolve;\r\n      /**\r\n       * Resolves when a stop criteria is reached.\r\n       * Uses as a performance shortcut so we do not\r\n       * have to await the responseTime when it is already clear\r\n       * that the election failed.\r\n       */\r\n\r\n      var stopCriteriaPromise = new Promise(function (res) {\r\n        stopCriteriaPromiseResolve = function stopCriteriaPromiseResolve() {\r\n          stopCriteria = true;\r\n          res();\r\n        };\r\n      });\r\n      var recieved = [];\r\n\r\n      var handleMessage = function handleMessage(msg) {\r\n        if (msg.context === 'leader' && msg.token != _this2.token) {\r\n          recieved.push(msg);\r\n\r\n          if (msg.action === 'apply') {\r\n            // other is applying\r\n            if (msg.token > _this2.token) {\r\n              /**\r\n               * other has higher token\r\n               * -> stop applying and let other become leader.\r\n               */\r\n              stopCriteriaPromiseResolve();\r\n            }\r\n          }\r\n\r\n          if (msg.action === 'tell') {\r\n            // other is already leader\r\n            stopCriteriaPromiseResolve();\r\n            _this2.hasLeader = true;\r\n          }\r\n        }\r\n      };\r\n\r\n      _this2.broadcastChannel.addEventListener('internal', handleMessage);\r\n      /**\r\n       * If the applyOnce() call came from the fallbackInterval,\r\n       * we can assume that the election runs in the background and\r\n       * not critical process is waiting for it.\r\n       * When this is true, we give the other intances\r\n       * more time to answer to messages in the election cycle.\r\n       * This makes it less likely to elect duplicate leaders.\r\n       * But also it takes longer which is not a problem because we anyway\r\n       * run in the background.\r\n       */\r\n\r\n\r\n      var waitForAnswerTime = isFromFallbackInterval ? _this2._options.responseTime * 4 : _this2._options.responseTime;\r\n\r\n      var applyPromise = _sendMessage(_this2, 'apply') // send out that this one is applying\r\n      .then(function () {\r\n        return Promise.race([(0,_util_js__WEBPACK_IMPORTED_MODULE_1__.sleep)(waitForAnswerTime), stopCriteriaPromise.then(function () {\r\n          return Promise.reject(new Error());\r\n        })]);\r\n      }) // send again in case another instance was just created\r\n      .then(function () {\r\n        return _sendMessage(_this2, 'apply');\r\n      }) // let others time to respond\r\n      .then(function () {\r\n        return Promise.race([(0,_util_js__WEBPACK_IMPORTED_MODULE_1__.sleep)(waitForAnswerTime), stopCriteriaPromise.then(function () {\r\n          return Promise.reject(new Error());\r\n        })]);\r\n      })[\"catch\"](function () {}).then(function () {\r\n        _this2.broadcastChannel.removeEventListener('internal', handleMessage);\r\n\r\n        if (!stopCriteria) {\r\n          // no stop criteria -> own is leader\r\n          return beLeader(_this2).then(function () {\r\n            return true;\r\n          });\r\n        } else {\r\n          // other is leader\r\n          return false;\r\n        }\r\n      });\r\n\r\n      return applyPromise;\r\n    };\r\n\r\n    this._aplQC = this._aplQC + 1;\r\n    this._aplQ = this._aplQ.then(function () {\r\n      return applyRun();\r\n    }).then(function () {\r\n      _this2._aplQC = _this2._aplQC - 1;\r\n    });\r\n    return this._aplQ.then(function () {\r\n      return _this2.isLeader;\r\n    });\r\n  },\r\n  awaitLeadership: function awaitLeadership() {\r\n    if (\r\n    /* _awaitLeadershipPromise */\r\n    !this._aLP) {\r\n      this._aLP = _awaitLeadershipOnce(this);\r\n    }\r\n\r\n    return this._aLP;\r\n  },\r\n\r\n  set onduplicate(fn) {\r\n    this._dpL = fn;\r\n  },\r\n\r\n  die: function die() {\r\n    var _this3 = this;\r\n\r\n    this._lstns.forEach(function (listener) {\r\n      return _this3.broadcastChannel.removeEventListener('internal', listener);\r\n    });\r\n\r\n    this._lstns = [];\r\n\r\n    this._unl.forEach(function (uFn) {\r\n      return uFn.remove();\r\n    });\r\n\r\n    this._unl = [];\r\n\r\n    if (this.isLeader) {\r\n      this.hasLeader = false;\r\n      this.isLeader = false;\r\n    }\r\n\r\n    this.isDead = true;\r\n    return _sendMessage(this, 'death');\r\n  }\r\n};\r\n/**\r\n * @param leaderElector {LeaderElector}\r\n */\r\n\r\nfunction _awaitLeadershipOnce(leaderElector) {\r\n  if (leaderElector.isLeader) {\r\n    return _util_js__WEBPACK_IMPORTED_MODULE_1__.PROMISE_RESOLVED_VOID;\r\n  }\r\n\r\n  return new Promise(function (res) {\r\n    var resolved = false;\r\n\r\n    function finish() {\r\n      if (resolved) {\r\n        return;\r\n      }\r\n\r\n      resolved = true;\r\n      leaderElector.broadcastChannel.removeEventListener('internal', whenDeathListener);\r\n      res(true);\r\n    } // try once now\r\n\r\n\r\n    leaderElector.applyOnce().then(function () {\r\n      if (leaderElector.isLeader) {\r\n        finish();\r\n      }\r\n    });\r\n    /**\r\n     * Try on fallbackInterval\r\n     * @recursive\r\n     */\r\n\r\n    var tryOnFallBack = function tryOnFallBack() {\r\n      return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.sleep)(leaderElector._options.fallbackInterval).then(function () {\r\n        if (leaderElector.isDead || resolved) {\r\n          return;\r\n        }\r\n\r\n        if (leaderElector.isLeader) {\r\n          finish();\r\n        } else {\r\n          return leaderElector.applyOnce(true).then(function () {\r\n            if (leaderElector.isLeader) {\r\n              finish();\r\n            } else {\r\n              tryOnFallBack();\r\n            }\r\n          });\r\n        }\r\n      });\r\n    };\r\n\r\n    tryOnFallBack(); // try when other leader dies\r\n\r\n    var whenDeathListener = function whenDeathListener(msg) {\r\n      if (msg.context === 'leader' && msg.action === 'death') {\r\n        leaderElector.hasLeader = false;\r\n        leaderElector.applyOnce().then(function () {\r\n          if (leaderElector.isLeader) {\r\n            finish();\r\n          }\r\n        });\r\n      }\r\n    };\r\n\r\n    leaderElector.broadcastChannel.addEventListener('internal', whenDeathListener);\r\n\r\n    leaderElector._lstns.push(whenDeathListener);\r\n  });\r\n}\r\n/**\r\n * sends and internal message over the broadcast-channel\r\n */\r\n\r\n\r\nfunction _sendMessage(leaderElector, action) {\r\n  var msgJson = {\r\n    context: 'leader',\r\n    action: action,\r\n    token: leaderElector.token\r\n  };\r\n  return leaderElector.broadcastChannel.postInternal(msgJson);\r\n}\r\n\r\nfunction beLeader(leaderElector) {\r\n  leaderElector.isLeader = true;\r\n  leaderElector.hasLeader = true;\r\n  var unloadFn = (0,unload__WEBPACK_IMPORTED_MODULE_0__.add)(function () {\r\n    return leaderElector.die();\r\n  });\r\n\r\n  leaderElector._unl.push(unloadFn);\r\n\r\n  var isLeaderListener = function isLeaderListener(msg) {\r\n    if (msg.context === 'leader' && msg.action === 'apply') {\r\n      _sendMessage(leaderElector, 'tell');\r\n    }\r\n\r\n    if (msg.context === 'leader' && msg.action === 'tell' && !leaderElector._dpLC) {\r\n      /**\r\n       * another instance is also leader!\r\n       * This can happen on rare events\r\n       * like when the CPU is at 100% for long time\r\n       * or the tabs are open very long and the browser throttles them.\r\n       * @link https://github.com/pubkey/broadcast-channel/issues/414\r\n       * @link https://github.com/pubkey/broadcast-channel/issues/385\r\n       */\r\n      leaderElector._dpLC = true;\r\n\r\n      leaderElector._dpL(); // message the lib user so the app can handle the problem\r\n\r\n\r\n      _sendMessage(leaderElector, 'tell'); // ensure other leader also knows the problem\r\n\r\n    }\r\n  };\r\n\r\n  leaderElector.broadcastChannel.addEventListener('internal', isLeaderListener);\r\n\r\n  leaderElector._lstns.push(isLeaderListener);\r\n\r\n  return _sendMessage(leaderElector, 'tell');\r\n}\r\n\r\nfunction fillOptionsWithDefaults(options, channel) {\r\n  if (!options) options = {};\r\n  options = JSON.parse(JSON.stringify(options));\r\n\r\n  if (!options.fallbackInterval) {\r\n    options.fallbackInterval = 3000;\r\n  }\r\n\r\n  if (!options.responseTime) {\r\n    options.responseTime = channel.method.averageResponseTime(channel.options);\r\n  }\r\n\r\n  return options;\r\n}\r\n\r\nfunction createLeaderElection(channel, options) {\r\n  if (channel._leaderElector) {\r\n    throw new Error('BroadcastChannel already has a leader-elector');\r\n  }\r\n\r\n  options = fillOptionsWithDefaults(options, channel);\r\n  var elector = new LeaderElection(channel, options);\r\n\r\n  channel._befC.push(function () {\r\n    return elector.die();\r\n  });\r\n\r\n  channel._leaderElector = elector;\r\n  return elector;\r\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYnJvYWRjYXN0LWNoYW5uZWwvZGlzdC9lc2Jyb3dzZXIvbGVhZGVyLWVsZWN0aW9uLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBNkY7QUFDbkQ7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxREFBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDJEQUFxQixFQUFFO0FBQ3RDO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsK0NBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsYUFBYSwrQ0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMkRBQXFCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwrQ0FBSztBQUNsQztBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDZCQUE2QiwrQ0FBSztBQUNsQztBQUNBLFNBQVM7QUFDVCxPQUFPLHlCQUF5QjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMkRBQXFCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLCtDQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLGlCQUFpQiwyQ0FBUztBQUMxQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYnJvYWRjYXN0LWNoYW5uZWwvZGlzdC9lc2Jyb3dzZXIvbGVhZGVyLWVsZWN0aW9uLmpzP2E2MDMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc2xlZXAsIHJhbmRvbVRva2VuLCBQUk9NSVNFX1JFU09MVkVEX1ZPSUQsIFBST01JU0VfUkVTT0xWRURfVFJVRSB9IGZyb20gJy4vdXRpbC5qcyc7XHJcbmltcG9ydCB7IGFkZCBhcyB1bmxvYWRBZGQgfSBmcm9tICd1bmxvYWQnO1xyXG5cclxudmFyIExlYWRlckVsZWN0aW9uID0gZnVuY3Rpb24gTGVhZGVyRWxlY3Rpb24oYnJvYWRjYXN0Q2hhbm5lbCwgb3B0aW9ucykge1xyXG4gIHZhciBfdGhpcyA9IHRoaXM7XHJcblxyXG4gIHRoaXMuYnJvYWRjYXN0Q2hhbm5lbCA9IGJyb2FkY2FzdENoYW5uZWw7XHJcbiAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgdGhpcy5pc0xlYWRlciA9IGZhbHNlO1xyXG4gIHRoaXMuaGFzTGVhZGVyID0gZmFsc2U7XHJcbiAgdGhpcy5pc0RlYWQgPSBmYWxzZTtcclxuICB0aGlzLnRva2VuID0gcmFuZG9tVG9rZW4oKTtcclxuICAvKipcclxuICAgKiBBcHBseSBRdWV1ZSxcclxuICAgKiB1c2VkIHRvIGVuc3VyZSB3ZSBkbyBub3QgcnVuIGFwcGx5T25jZSgpXHJcbiAgICogaW4gcGFyYWxsZWwuXHJcbiAgICovXHJcblxyXG4gIHRoaXMuX2FwbFEgPSBQUk9NSVNFX1JFU09MVkVEX1ZPSUQ7IC8vIGFtb3VudCBvZiB1bmZpbmlzaGVkIGFwcGx5T25jZSgpIGNhbGxzXHJcblxyXG4gIHRoaXMuX2FwbFFDID0gMDsgLy8gdGhpbmdzIHRvIGNsZWFuIHVwXHJcblxyXG4gIHRoaXMuX3VubCA9IFtdOyAvLyBfdW5sb2Fkc1xyXG5cclxuICB0aGlzLl9sc3RucyA9IFtdOyAvLyBfbGlzdGVuZXJzXHJcblxyXG4gIHRoaXMuX2RwTCA9IGZ1bmN0aW9uICgpIHt9OyAvLyBvbmR1cGxpY2F0ZSBsaXN0ZW5lclxyXG5cclxuXHJcbiAgdGhpcy5fZHBMQyA9IGZhbHNlOyAvLyB0cnVlIHdoZW4gb25kdXBsaWNhdGUgY2FsbGVkXHJcblxyXG4gIC8qKlxyXG4gICAqIEV2ZW4gd2hlbiB0aGUgb3duIGluc3RhbmNlIGlzIG5vdCBhcHBseWluZyxcclxuICAgKiB3ZSBzdGlsbCBsaXN0ZW4gdG8gbWVzc2FnZXMgdG8gZW5zdXJlIHRoZSBoYXNMZWFkZXIgZmxhZ1xyXG4gICAqIGlzIHNldCBjb3JyZWN0bHkuXHJcbiAgICovXHJcblxyXG4gIHZhciBoYXNMZWFkZXJMaXN0ZW5lciA9IGZ1bmN0aW9uIGhhc0xlYWRlckxpc3RlbmVyKG1zZykge1xyXG4gICAgaWYgKG1zZy5jb250ZXh0ID09PSAnbGVhZGVyJykge1xyXG4gICAgICBpZiAobXNnLmFjdGlvbiA9PT0gJ2RlYXRoJykge1xyXG4gICAgICAgIF90aGlzLmhhc0xlYWRlciA9IGZhbHNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAobXNnLmFjdGlvbiA9PT0gJ3RlbGwnKSB7XHJcbiAgICAgICAgX3RoaXMuaGFzTGVhZGVyID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHRoaXMuYnJvYWRjYXN0Q2hhbm5lbC5hZGRFdmVudExpc3RlbmVyKCdpbnRlcm5hbCcsIGhhc0xlYWRlckxpc3RlbmVyKTtcclxuXHJcbiAgdGhpcy5fbHN0bnMucHVzaChoYXNMZWFkZXJMaXN0ZW5lcik7XHJcbn07XHJcblxyXG5MZWFkZXJFbGVjdGlvbi5wcm90b3R5cGUgPSB7XHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBpbnN0YW5jZSBpcyBsZWFkZXIsXHJcbiAgICogZmFsc2UgaWYgbm90LlxyXG4gICAqIEBhc3luY1xyXG4gICAqL1xyXG4gIGFwcGx5T25jZTogZnVuY3Rpb24gYXBwbHlPbmNlKCAvLyB0cnVlIGlmIHRoZSBhcHBseU9uY2UoKSBjYWxsIGNhbWUgZnJvbSB0aGUgZmFsbGJhY2tJbnRlcnZhbCBjeWNsZVxyXG4gIGlzRnJvbUZhbGxiYWNrSW50ZXJ2YWwpIHtcclxuICAgIHZhciBfdGhpczIgPSB0aGlzO1xyXG5cclxuICAgIGlmICh0aGlzLmlzTGVhZGVyKSB7XHJcbiAgICAgIHJldHVybiBzbGVlcCgwLCB0cnVlKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5pc0RlYWQpIHtcclxuICAgICAgcmV0dXJuIHNsZWVwKDAsIGZhbHNlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWxyZWFkeSBhcHBseWluZyBtb3JlIHRoZW4gb25jZSxcclxuICAgICAqIC0+IHdhaXQgZm9yIHRoZSBhcHBseSBxdWV1ZSB0byBiZSBmaW5pc2hlZC5cclxuICAgICAqL1xyXG5cclxuXHJcbiAgICBpZiAodGhpcy5fYXBsUUMgPiAxKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9hcGxRO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYSBuZXcgYXBwbHktcnVuXHJcbiAgICAgKi9cclxuXHJcblxyXG4gICAgdmFyIGFwcGx5UnVuID0gZnVuY3Rpb24gYXBwbHlSdW4oKSB7XHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBPcHRpbWl6YXRpb24gc2hvcnRjdXRzLlxyXG4gICAgICAgKiBEaXJlY3RseSByZXR1cm4gaWYgYSBwcmV2aW91cyBydW5cclxuICAgICAgICogaGFzIGFscmVhZHkgZWxlY3RlZCBhIGxlYWRlci5cclxuICAgICAgICovXHJcbiAgICAgIGlmIChfdGhpczIuaXNMZWFkZXIpIHtcclxuICAgICAgICByZXR1cm4gUFJPTUlTRV9SRVNPTFZFRF9UUlVFO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgc3RvcENyaXRlcmlhID0gZmFsc2U7XHJcbiAgICAgIHZhciBzdG9wQ3JpdGVyaWFQcm9taXNlUmVzb2x2ZTtcclxuICAgICAgLyoqXHJcbiAgICAgICAqIFJlc29sdmVzIHdoZW4gYSBzdG9wIGNyaXRlcmlhIGlzIHJlYWNoZWQuXHJcbiAgICAgICAqIFVzZXMgYXMgYSBwZXJmb3JtYW5jZSBzaG9ydGN1dCBzbyB3ZSBkbyBub3RcclxuICAgICAgICogaGF2ZSB0byBhd2FpdCB0aGUgcmVzcG9uc2VUaW1lIHdoZW4gaXQgaXMgYWxyZWFkeSBjbGVhclxyXG4gICAgICAgKiB0aGF0IHRoZSBlbGVjdGlvbiBmYWlsZWQuXHJcbiAgICAgICAqL1xyXG5cclxuICAgICAgdmFyIHN0b3BDcml0ZXJpYVByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzKSB7XHJcbiAgICAgICAgc3RvcENyaXRlcmlhUHJvbWlzZVJlc29sdmUgPSBmdW5jdGlvbiBzdG9wQ3JpdGVyaWFQcm9taXNlUmVzb2x2ZSgpIHtcclxuICAgICAgICAgIHN0b3BDcml0ZXJpYSA9IHRydWU7XHJcbiAgICAgICAgICByZXMoKTtcclxuICAgICAgICB9O1xyXG4gICAgICB9KTtcclxuICAgICAgdmFyIHJlY2lldmVkID0gW107XHJcblxyXG4gICAgICB2YXIgaGFuZGxlTWVzc2FnZSA9IGZ1bmN0aW9uIGhhbmRsZU1lc3NhZ2UobXNnKSB7XHJcbiAgICAgICAgaWYgKG1zZy5jb250ZXh0ID09PSAnbGVhZGVyJyAmJiBtc2cudG9rZW4gIT0gX3RoaXMyLnRva2VuKSB7XHJcbiAgICAgICAgICByZWNpZXZlZC5wdXNoKG1zZyk7XHJcblxyXG4gICAgICAgICAgaWYgKG1zZy5hY3Rpb24gPT09ICdhcHBseScpIHtcclxuICAgICAgICAgICAgLy8gb3RoZXIgaXMgYXBwbHlpbmdcclxuICAgICAgICAgICAgaWYgKG1zZy50b2tlbiA+IF90aGlzMi50b2tlbikge1xyXG4gICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAqIG90aGVyIGhhcyBoaWdoZXIgdG9rZW5cclxuICAgICAgICAgICAgICAgKiAtPiBzdG9wIGFwcGx5aW5nIGFuZCBsZXQgb3RoZXIgYmVjb21lIGxlYWRlci5cclxuICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICBzdG9wQ3JpdGVyaWFQcm9taXNlUmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKG1zZy5hY3Rpb24gPT09ICd0ZWxsJykge1xyXG4gICAgICAgICAgICAvLyBvdGhlciBpcyBhbHJlYWR5IGxlYWRlclxyXG4gICAgICAgICAgICBzdG9wQ3JpdGVyaWFQcm9taXNlUmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICBfdGhpczIuaGFzTGVhZGVyID0gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBfdGhpczIuYnJvYWRjYXN0Q2hhbm5lbC5hZGRFdmVudExpc3RlbmVyKCdpbnRlcm5hbCcsIGhhbmRsZU1lc3NhZ2UpO1xyXG4gICAgICAvKipcclxuICAgICAgICogSWYgdGhlIGFwcGx5T25jZSgpIGNhbGwgY2FtZSBmcm9tIHRoZSBmYWxsYmFja0ludGVydmFsLFxyXG4gICAgICAgKiB3ZSBjYW4gYXNzdW1lIHRoYXQgdGhlIGVsZWN0aW9uIHJ1bnMgaW4gdGhlIGJhY2tncm91bmQgYW5kXHJcbiAgICAgICAqIG5vdCBjcml0aWNhbCBwcm9jZXNzIGlzIHdhaXRpbmcgZm9yIGl0LlxyXG4gICAgICAgKiBXaGVuIHRoaXMgaXMgdHJ1ZSwgd2UgZ2l2ZSB0aGUgb3RoZXIgaW50YW5jZXNcclxuICAgICAgICogbW9yZSB0aW1lIHRvIGFuc3dlciB0byBtZXNzYWdlcyBpbiB0aGUgZWxlY3Rpb24gY3ljbGUuXHJcbiAgICAgICAqIFRoaXMgbWFrZXMgaXQgbGVzcyBsaWtlbHkgdG8gZWxlY3QgZHVwbGljYXRlIGxlYWRlcnMuXHJcbiAgICAgICAqIEJ1dCBhbHNvIGl0IHRha2VzIGxvbmdlciB3aGljaCBpcyBub3QgYSBwcm9ibGVtIGJlY2F1c2Ugd2UgYW55d2F5XHJcbiAgICAgICAqIHJ1biBpbiB0aGUgYmFja2dyb3VuZC5cclxuICAgICAgICovXHJcblxyXG5cclxuICAgICAgdmFyIHdhaXRGb3JBbnN3ZXJUaW1lID0gaXNGcm9tRmFsbGJhY2tJbnRlcnZhbCA/IF90aGlzMi5fb3B0aW9ucy5yZXNwb25zZVRpbWUgKiA0IDogX3RoaXMyLl9vcHRpb25zLnJlc3BvbnNlVGltZTtcclxuXHJcbiAgICAgIHZhciBhcHBseVByb21pc2UgPSBfc2VuZE1lc3NhZ2UoX3RoaXMyLCAnYXBwbHknKSAvLyBzZW5kIG91dCB0aGF0IHRoaXMgb25lIGlzIGFwcGx5aW5nXHJcbiAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtzbGVlcCh3YWl0Rm9yQW5zd2VyVGltZSksIHN0b3BDcml0ZXJpYVByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCkpO1xyXG4gICAgICAgIH0pXSk7XHJcbiAgICAgIH0pIC8vIHNlbmQgYWdhaW4gaW4gY2FzZSBhbm90aGVyIGluc3RhbmNlIHdhcyBqdXN0IGNyZWF0ZWRcclxuICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfc2VuZE1lc3NhZ2UoX3RoaXMyLCAnYXBwbHknKTtcclxuICAgICAgfSkgLy8gbGV0IG90aGVycyB0aW1lIHRvIHJlc3BvbmRcclxuICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJhY2UoW3NsZWVwKHdhaXRGb3JBbnN3ZXJUaW1lKSwgc3RvcENyaXRlcmlhUHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoKSk7XHJcbiAgICAgICAgfSldKTtcclxuICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoKSB7fSkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX3RoaXMyLmJyb2FkY2FzdENoYW5uZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW50ZXJuYWwnLCBoYW5kbGVNZXNzYWdlKTtcclxuXHJcbiAgICAgICAgaWYgKCFzdG9wQ3JpdGVyaWEpIHtcclxuICAgICAgICAgIC8vIG5vIHN0b3AgY3JpdGVyaWEgLT4gb3duIGlzIGxlYWRlclxyXG4gICAgICAgICAgcmV0dXJuIGJlTGVhZGVyKF90aGlzMikudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIG90aGVyIGlzIGxlYWRlclxyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICByZXR1cm4gYXBwbHlQcm9taXNlO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLl9hcGxRQyA9IHRoaXMuX2FwbFFDICsgMTtcclxuICAgIHRoaXMuX2FwbFEgPSB0aGlzLl9hcGxRLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gYXBwbHlSdW4oKTtcclxuICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICBfdGhpczIuX2FwbFFDID0gX3RoaXMyLl9hcGxRQyAtIDE7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0aGlzLl9hcGxRLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gX3RoaXMyLmlzTGVhZGVyO1xyXG4gICAgfSk7XHJcbiAgfSxcclxuICBhd2FpdExlYWRlcnNoaXA6IGZ1bmN0aW9uIGF3YWl0TGVhZGVyc2hpcCgpIHtcclxuICAgIGlmIChcclxuICAgIC8qIF9hd2FpdExlYWRlcnNoaXBQcm9taXNlICovXHJcbiAgICAhdGhpcy5fYUxQKSB7XHJcbiAgICAgIHRoaXMuX2FMUCA9IF9hd2FpdExlYWRlcnNoaXBPbmNlKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLl9hTFA7XHJcbiAgfSxcclxuXHJcbiAgc2V0IG9uZHVwbGljYXRlKGZuKSB7XHJcbiAgICB0aGlzLl9kcEwgPSBmbjtcclxuICB9LFxyXG5cclxuICBkaWU6IGZ1bmN0aW9uIGRpZSgpIHtcclxuICAgIHZhciBfdGhpczMgPSB0aGlzO1xyXG5cclxuICAgIHRoaXMuX2xzdG5zLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XHJcbiAgICAgIHJldHVybiBfdGhpczMuYnJvYWRjYXN0Q2hhbm5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnRlcm5hbCcsIGxpc3RlbmVyKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuX2xzdG5zID0gW107XHJcblxyXG4gICAgdGhpcy5fdW5sLmZvckVhY2goZnVuY3Rpb24gKHVGbikge1xyXG4gICAgICByZXR1cm4gdUZuLnJlbW92ZSgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5fdW5sID0gW107XHJcblxyXG4gICAgaWYgKHRoaXMuaXNMZWFkZXIpIHtcclxuICAgICAgdGhpcy5oYXNMZWFkZXIgPSBmYWxzZTtcclxuICAgICAgdGhpcy5pc0xlYWRlciA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuaXNEZWFkID0gdHJ1ZTtcclxuICAgIHJldHVybiBfc2VuZE1lc3NhZ2UodGhpcywgJ2RlYXRoJyk7XHJcbiAgfVxyXG59O1xyXG4vKipcclxuICogQHBhcmFtIGxlYWRlckVsZWN0b3Ige0xlYWRlckVsZWN0b3J9XHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gX2F3YWl0TGVhZGVyc2hpcE9uY2UobGVhZGVyRWxlY3Rvcikge1xyXG4gIGlmIChsZWFkZXJFbGVjdG9yLmlzTGVhZGVyKSB7XHJcbiAgICByZXR1cm4gUFJPTUlTRV9SRVNPTFZFRF9WT0lEO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXMpIHtcclxuICAgIHZhciByZXNvbHZlZCA9IGZhbHNlO1xyXG5cclxuICAgIGZ1bmN0aW9uIGZpbmlzaCgpIHtcclxuICAgICAgaWYgKHJlc29sdmVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXNvbHZlZCA9IHRydWU7XHJcbiAgICAgIGxlYWRlckVsZWN0b3IuYnJvYWRjYXN0Q2hhbm5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnRlcm5hbCcsIHdoZW5EZWF0aExpc3RlbmVyKTtcclxuICAgICAgcmVzKHRydWUpO1xyXG4gICAgfSAvLyB0cnkgb25jZSBub3dcclxuXHJcblxyXG4gICAgbGVhZGVyRWxlY3Rvci5hcHBseU9uY2UoKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgaWYgKGxlYWRlckVsZWN0b3IuaXNMZWFkZXIpIHtcclxuICAgICAgICBmaW5pc2goKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICAvKipcclxuICAgICAqIFRyeSBvbiBmYWxsYmFja0ludGVydmFsXHJcbiAgICAgKiBAcmVjdXJzaXZlXHJcbiAgICAgKi9cclxuXHJcbiAgICB2YXIgdHJ5T25GYWxsQmFjayA9IGZ1bmN0aW9uIHRyeU9uRmFsbEJhY2soKSB7XHJcbiAgICAgIHJldHVybiBzbGVlcChsZWFkZXJFbGVjdG9yLl9vcHRpb25zLmZhbGxiYWNrSW50ZXJ2YWwpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChsZWFkZXJFbGVjdG9yLmlzRGVhZCB8fCByZXNvbHZlZCkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGxlYWRlckVsZWN0b3IuaXNMZWFkZXIpIHtcclxuICAgICAgICAgIGZpbmlzaCgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXR1cm4gbGVhZGVyRWxlY3Rvci5hcHBseU9uY2UodHJ1ZSkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChsZWFkZXJFbGVjdG9yLmlzTGVhZGVyKSB7XHJcbiAgICAgICAgICAgICAgZmluaXNoKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgdHJ5T25GYWxsQmFjaygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICB0cnlPbkZhbGxCYWNrKCk7IC8vIHRyeSB3aGVuIG90aGVyIGxlYWRlciBkaWVzXHJcblxyXG4gICAgdmFyIHdoZW5EZWF0aExpc3RlbmVyID0gZnVuY3Rpb24gd2hlbkRlYXRoTGlzdGVuZXIobXNnKSB7XHJcbiAgICAgIGlmIChtc2cuY29udGV4dCA9PT0gJ2xlYWRlcicgJiYgbXNnLmFjdGlvbiA9PT0gJ2RlYXRoJykge1xyXG4gICAgICAgIGxlYWRlckVsZWN0b3IuaGFzTGVhZGVyID0gZmFsc2U7XHJcbiAgICAgICAgbGVhZGVyRWxlY3Rvci5hcHBseU9uY2UoKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIGlmIChsZWFkZXJFbGVjdG9yLmlzTGVhZGVyKSB7XHJcbiAgICAgICAgICAgIGZpbmlzaCgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGxlYWRlckVsZWN0b3IuYnJvYWRjYXN0Q2hhbm5lbC5hZGRFdmVudExpc3RlbmVyKCdpbnRlcm5hbCcsIHdoZW5EZWF0aExpc3RlbmVyKTtcclxuXHJcbiAgICBsZWFkZXJFbGVjdG9yLl9sc3Rucy5wdXNoKHdoZW5EZWF0aExpc3RlbmVyKTtcclxuICB9KTtcclxufVxyXG4vKipcclxuICogc2VuZHMgYW5kIGludGVybmFsIG1lc3NhZ2Ugb3ZlciB0aGUgYnJvYWRjYXN0LWNoYW5uZWxcclxuICovXHJcblxyXG5cclxuZnVuY3Rpb24gX3NlbmRNZXNzYWdlKGxlYWRlckVsZWN0b3IsIGFjdGlvbikge1xyXG4gIHZhciBtc2dKc29uID0ge1xyXG4gICAgY29udGV4dDogJ2xlYWRlcicsXHJcbiAgICBhY3Rpb246IGFjdGlvbixcclxuICAgIHRva2VuOiBsZWFkZXJFbGVjdG9yLnRva2VuXHJcbiAgfTtcclxuICByZXR1cm4gbGVhZGVyRWxlY3Rvci5icm9hZGNhc3RDaGFubmVsLnBvc3RJbnRlcm5hbChtc2dKc29uKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGJlTGVhZGVyKGxlYWRlckVsZWN0b3IpIHtcclxuICBsZWFkZXJFbGVjdG9yLmlzTGVhZGVyID0gdHJ1ZTtcclxuICBsZWFkZXJFbGVjdG9yLmhhc0xlYWRlciA9IHRydWU7XHJcbiAgdmFyIHVubG9hZEZuID0gdW5sb2FkQWRkKGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBsZWFkZXJFbGVjdG9yLmRpZSgpO1xyXG4gIH0pO1xyXG5cclxuICBsZWFkZXJFbGVjdG9yLl91bmwucHVzaCh1bmxvYWRGbik7XHJcblxyXG4gIHZhciBpc0xlYWRlckxpc3RlbmVyID0gZnVuY3Rpb24gaXNMZWFkZXJMaXN0ZW5lcihtc2cpIHtcclxuICAgIGlmIChtc2cuY29udGV4dCA9PT0gJ2xlYWRlcicgJiYgbXNnLmFjdGlvbiA9PT0gJ2FwcGx5Jykge1xyXG4gICAgICBfc2VuZE1lc3NhZ2UobGVhZGVyRWxlY3RvciwgJ3RlbGwnKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobXNnLmNvbnRleHQgPT09ICdsZWFkZXInICYmIG1zZy5hY3Rpb24gPT09ICd0ZWxsJyAmJiAhbGVhZGVyRWxlY3Rvci5fZHBMQykge1xyXG4gICAgICAvKipcclxuICAgICAgICogYW5vdGhlciBpbnN0YW5jZSBpcyBhbHNvIGxlYWRlciFcclxuICAgICAgICogVGhpcyBjYW4gaGFwcGVuIG9uIHJhcmUgZXZlbnRzXHJcbiAgICAgICAqIGxpa2Ugd2hlbiB0aGUgQ1BVIGlzIGF0IDEwMCUgZm9yIGxvbmcgdGltZVxyXG4gICAgICAgKiBvciB0aGUgdGFicyBhcmUgb3BlbiB2ZXJ5IGxvbmcgYW5kIHRoZSBicm93c2VyIHRocm90dGxlcyB0aGVtLlxyXG4gICAgICAgKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vcHVia2V5L2Jyb2FkY2FzdC1jaGFubmVsL2lzc3Vlcy80MTRcclxuICAgICAgICogQGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3B1YmtleS9icm9hZGNhc3QtY2hhbm5lbC9pc3N1ZXMvMzg1XHJcbiAgICAgICAqL1xyXG4gICAgICBsZWFkZXJFbGVjdG9yLl9kcExDID0gdHJ1ZTtcclxuXHJcbiAgICAgIGxlYWRlckVsZWN0b3IuX2RwTCgpOyAvLyBtZXNzYWdlIHRoZSBsaWIgdXNlciBzbyB0aGUgYXBwIGNhbiBoYW5kbGUgdGhlIHByb2JsZW1cclxuXHJcblxyXG4gICAgICBfc2VuZE1lc3NhZ2UobGVhZGVyRWxlY3RvciwgJ3RlbGwnKTsgLy8gZW5zdXJlIG90aGVyIGxlYWRlciBhbHNvIGtub3dzIHRoZSBwcm9ibGVtXHJcblxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGxlYWRlckVsZWN0b3IuYnJvYWRjYXN0Q2hhbm5lbC5hZGRFdmVudExpc3RlbmVyKCdpbnRlcm5hbCcsIGlzTGVhZGVyTGlzdGVuZXIpO1xyXG5cclxuICBsZWFkZXJFbGVjdG9yLl9sc3Rucy5wdXNoKGlzTGVhZGVyTGlzdGVuZXIpO1xyXG5cclxuICByZXR1cm4gX3NlbmRNZXNzYWdlKGxlYWRlckVsZWN0b3IsICd0ZWxsJyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZpbGxPcHRpb25zV2l0aERlZmF1bHRzKG9wdGlvbnMsIGNoYW5uZWwpIHtcclxuICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcclxuICBvcHRpb25zID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvcHRpb25zKSk7XHJcblxyXG4gIGlmICghb3B0aW9ucy5mYWxsYmFja0ludGVydmFsKSB7XHJcbiAgICBvcHRpb25zLmZhbGxiYWNrSW50ZXJ2YWwgPSAzMDAwO1xyXG4gIH1cclxuXHJcbiAgaWYgKCFvcHRpb25zLnJlc3BvbnNlVGltZSkge1xyXG4gICAgb3B0aW9ucy5yZXNwb25zZVRpbWUgPSBjaGFubmVsLm1ldGhvZC5hdmVyYWdlUmVzcG9uc2VUaW1lKGNoYW5uZWwub3B0aW9ucyk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gb3B0aW9ucztcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUxlYWRlckVsZWN0aW9uKGNoYW5uZWwsIG9wdGlvbnMpIHtcclxuICBpZiAoY2hhbm5lbC5fbGVhZGVyRWxlY3Rvcikge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdCcm9hZGNhc3RDaGFubmVsIGFscmVhZHkgaGFzIGEgbGVhZGVyLWVsZWN0b3InKTtcclxuICB9XHJcblxyXG4gIG9wdGlvbnMgPSBmaWxsT3B0aW9uc1dpdGhEZWZhdWx0cyhvcHRpb25zLCBjaGFubmVsKTtcclxuICB2YXIgZWxlY3RvciA9IG5ldyBMZWFkZXJFbGVjdGlvbihjaGFubmVsLCBvcHRpb25zKTtcclxuXHJcbiAgY2hhbm5lbC5fYmVmQy5wdXNoKGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBlbGVjdG9yLmRpZSgpO1xyXG4gIH0pO1xyXG5cclxuICBjaGFubmVsLl9sZWFkZXJFbGVjdG9yID0gZWxlY3RvcjtcclxuICByZXR1cm4gZWxlY3RvcjtcclxufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/broadcast-channel/dist/esbrowser/leader-election.js\n");

/***/ }),

/***/ "./node_modules/broadcast-channel/dist/esbrowser/method-chooser.js":
/*!*************************************************************************!*\
  !*** ./node_modules/broadcast-channel/dist/esbrowser/method-chooser.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"chooseMethod\": function() { return /* binding */ chooseMethod; }\n/* harmony export */ });\n/* harmony import */ var _methods_native_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./methods/native.js */ \"./node_modules/broadcast-channel/dist/esbrowser/methods/native.js\");\n/* harmony import */ var _methods_indexed_db_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./methods/indexed-db.js */ \"./node_modules/broadcast-channel/dist/esbrowser/methods/indexed-db.js\");\n/* harmony import */ var _methods_localstorage_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./methods/localstorage.js */ \"./node_modules/broadcast-channel/dist/esbrowser/methods/localstorage.js\");\n/* harmony import */ var _methods_simulate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./methods/simulate.js */ \"./node_modules/broadcast-channel/dist/esbrowser/methods/simulate.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./util */ \"./node_modules/broadcast-channel/dist/esbrowser/util.js\");\n\r\n\r\n\r\n // the line below will be removed from es5/browser builds\r\n\r\n\r\n // order is important\r\n\r\nvar METHODS = [_methods_native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"], // fastest\r\n_methods_indexed_db_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"], _methods_localstorage_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]];\r\nfunction chooseMethod(options) {\r\n  var chooseMethods = [].concat(options.methods, METHODS).filter(Boolean); // the line below will be removed from es5/browser builds\r\n\r\n\r\n\r\n  if (options.type) {\r\n    if (options.type === 'simulate') {\r\n      // only use simulate-method if directly chosen\r\n      return _methods_simulate_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"];\r\n    }\r\n\r\n    var ret = chooseMethods.find(function (m) {\r\n      return m.type === options.type;\r\n    });\r\n    if (!ret) throw new Error('method-type ' + options.type + ' not found');else return ret;\r\n  }\r\n  /**\r\n   * if no webworker support is needed,\r\n   * remove idb from the list so that localstorage is been chosen\r\n   */\r\n\r\n\r\n  if (!options.webWorkerSupport && !_util__WEBPACK_IMPORTED_MODULE_4__.isNode) {\r\n    chooseMethods = chooseMethods.filter(function (m) {\r\n      return m.type !== 'idb';\r\n    });\r\n  }\r\n\r\n  var useMethod = chooseMethods.find(function (method) {\r\n    return method.canBeUsed();\r\n  });\r\n  if (!useMethod) throw new Error(\"No useable method found in \" + JSON.stringify(METHODS.map(function (m) {\r\n    return m.type;\r\n  })));else return useMethod;\r\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYnJvYWRjYXN0LWNoYW5uZWwvZGlzdC9lc2Jyb3dzZXIvbWV0aG9kLWNob29zZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQStDO0FBQ007QUFDTTtBQUNSLENBQUM7QUFDcEQ7QUFDQTtBQUNnQyxDQUFDO0FBQ2pDO0FBQ0EsZUFBZSwwREFBWTtBQUMzQiw4REFBYyxFQUFFLGdFQUFrQjtBQUMzQjtBQUNQLDJFQUEyRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDREQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx5Q0FBTTtBQUMxQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYnJvYWRjYXN0LWNoYW5uZWwvZGlzdC9lc2Jyb3dzZXIvbWV0aG9kLWNob29zZXIuanM/YTAwNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTmF0aXZlTWV0aG9kIGZyb20gJy4vbWV0aG9kcy9uYXRpdmUuanMnO1xyXG5pbXBvcnQgSW5kZXhlRGJNZXRob2QgZnJvbSAnLi9tZXRob2RzL2luZGV4ZWQtZGIuanMnO1xyXG5pbXBvcnQgTG9jYWxzdG9yYWdlTWV0aG9kIGZyb20gJy4vbWV0aG9kcy9sb2NhbHN0b3JhZ2UuanMnO1xyXG5pbXBvcnQgU2ltdWxhdGVNZXRob2QgZnJvbSAnLi9tZXRob2RzL3NpbXVsYXRlLmpzJzsgLy8gdGhlIGxpbmUgYmVsb3cgd2lsbCBiZSByZW1vdmVkIGZyb20gZXM1L2Jyb3dzZXIgYnVpbGRzXHJcblxyXG5cclxuaW1wb3J0IHsgaXNOb2RlIH0gZnJvbSAnLi91dGlsJzsgLy8gb3JkZXIgaXMgaW1wb3J0YW50XHJcblxyXG52YXIgTUVUSE9EUyA9IFtOYXRpdmVNZXRob2QsIC8vIGZhc3Rlc3RcclxuSW5kZXhlRGJNZXRob2QsIExvY2Fsc3RvcmFnZU1ldGhvZF07XHJcbmV4cG9ydCBmdW5jdGlvbiBjaG9vc2VNZXRob2Qob3B0aW9ucykge1xyXG4gIHZhciBjaG9vc2VNZXRob2RzID0gW10uY29uY2F0KG9wdGlvbnMubWV0aG9kcywgTUVUSE9EUykuZmlsdGVyKEJvb2xlYW4pOyAvLyB0aGUgbGluZSBiZWxvdyB3aWxsIGJlIHJlbW92ZWQgZnJvbSBlczUvYnJvd3NlciBidWlsZHNcclxuXHJcblxyXG5cclxuICBpZiAob3B0aW9ucy50eXBlKSB7XHJcbiAgICBpZiAob3B0aW9ucy50eXBlID09PSAnc2ltdWxhdGUnKSB7XHJcbiAgICAgIC8vIG9ubHkgdXNlIHNpbXVsYXRlLW1ldGhvZCBpZiBkaXJlY3RseSBjaG9zZW5cclxuICAgICAgcmV0dXJuIFNpbXVsYXRlTWV0aG9kO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciByZXQgPSBjaG9vc2VNZXRob2RzLmZpbmQoZnVuY3Rpb24gKG0pIHtcclxuICAgICAgcmV0dXJuIG0udHlwZSA9PT0gb3B0aW9ucy50eXBlO1xyXG4gICAgfSk7XHJcbiAgICBpZiAoIXJldCkgdGhyb3cgbmV3IEVycm9yKCdtZXRob2QtdHlwZSAnICsgb3B0aW9ucy50eXBlICsgJyBub3QgZm91bmQnKTtlbHNlIHJldHVybiByZXQ7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIGlmIG5vIHdlYndvcmtlciBzdXBwb3J0IGlzIG5lZWRlZCxcclxuICAgKiByZW1vdmUgaWRiIGZyb20gdGhlIGxpc3Qgc28gdGhhdCBsb2NhbHN0b3JhZ2UgaXMgYmVlbiBjaG9zZW5cclxuICAgKi9cclxuXHJcblxyXG4gIGlmICghb3B0aW9ucy53ZWJXb3JrZXJTdXBwb3J0ICYmICFpc05vZGUpIHtcclxuICAgIGNob29zZU1ldGhvZHMgPSBjaG9vc2VNZXRob2RzLmZpbHRlcihmdW5jdGlvbiAobSkge1xyXG4gICAgICByZXR1cm4gbS50eXBlICE9PSAnaWRiJztcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgdmFyIHVzZU1ldGhvZCA9IGNob29zZU1ldGhvZHMuZmluZChmdW5jdGlvbiAobWV0aG9kKSB7XHJcbiAgICByZXR1cm4gbWV0aG9kLmNhbkJlVXNlZCgpO1xyXG4gIH0pO1xyXG4gIGlmICghdXNlTWV0aG9kKSB0aHJvdyBuZXcgRXJyb3IoXCJObyB1c2VhYmxlIG1ldGhvZCBmb3VuZCBpbiBcIiArIEpTT04uc3RyaW5naWZ5KE1FVEhPRFMubWFwKGZ1bmN0aW9uIChtKSB7XHJcbiAgICByZXR1cm4gbS50eXBlO1xyXG4gIH0pKSk7ZWxzZSByZXR1cm4gdXNlTWV0aG9kO1xyXG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/broadcast-channel/dist/esbrowser/method-chooser.js\n");

/***/ }),

/***/ "./node_modules/broadcast-channel/dist/esbrowser/methods/indexed-db.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/broadcast-channel/dist/esbrowser/methods/indexed-db.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"microSeconds\": function() { return /* binding */ microSeconds; },\n/* harmony export */   \"type\": function() { return /* binding */ type; },\n/* harmony export */   \"getIdb\": function() { return /* binding */ getIdb; },\n/* harmony export */   \"createDatabase\": function() { return /* binding */ createDatabase; },\n/* harmony export */   \"writeMessage\": function() { return /* binding */ writeMessage; },\n/* harmony export */   \"getAllMessages\": function() { return /* binding */ getAllMessages; },\n/* harmony export */   \"getMessagesHigherThan\": function() { return /* binding */ getMessagesHigherThan; },\n/* harmony export */   \"removeMessageById\": function() { return /* binding */ removeMessageById; },\n/* harmony export */   \"getOldMessages\": function() { return /* binding */ getOldMessages; },\n/* harmony export */   \"cleanOldMessages\": function() { return /* binding */ cleanOldMessages; },\n/* harmony export */   \"create\": function() { return /* binding */ create; },\n/* harmony export */   \"close\": function() { return /* binding */ close; },\n/* harmony export */   \"postMessage\": function() { return /* binding */ postMessage; },\n/* harmony export */   \"onMessage\": function() { return /* binding */ onMessage; },\n/* harmony export */   \"canBeUsed\": function() { return /* binding */ canBeUsed; },\n/* harmony export */   \"averageResponseTime\": function() { return /* binding */ averageResponseTime; }\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ \"./node_modules/broadcast-channel/dist/esbrowser/util.js\");\n/* harmony import */ var oblivious_set__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! oblivious-set */ \"./node_modules/oblivious-set/dist/es/index.js\");\n/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../options */ \"./node_modules/broadcast-channel/dist/esbrowser/options.js\");\n/**\r\n * this method uses indexeddb to store the messages\r\n * There is currently no observerAPI for idb\r\n * @link https://github.com/w3c/IndexedDB/issues/51\r\n */\r\n\r\nvar microSeconds = _util_js__WEBPACK_IMPORTED_MODULE_0__.microSeconds;\r\n\r\n\r\nvar DB_PREFIX = 'pubkey.broadcast-channel-0-';\r\nvar OBJECT_STORE_ID = 'messages';\r\nvar type = 'idb';\r\nfunction getIdb() {\r\n  if (typeof indexedDB !== 'undefined') return indexedDB;\r\n\r\n  if (typeof window !== 'undefined') {\r\n    if (typeof window.mozIndexedDB !== 'undefined') return window.mozIndexedDB;\r\n    if (typeof window.webkitIndexedDB !== 'undefined') return window.webkitIndexedDB;\r\n    if (typeof window.msIndexedDB !== 'undefined') return window.msIndexedDB;\r\n  }\r\n\r\n  return false;\r\n}\r\nfunction createDatabase(channelName) {\r\n  var IndexedDB = getIdb(); // create table\r\n\r\n  var dbName = DB_PREFIX + channelName;\r\n  var openRequest = IndexedDB.open(dbName, 1);\r\n\r\n  openRequest.onupgradeneeded = function (ev) {\r\n    var db = ev.target.result;\r\n    db.createObjectStore(OBJECT_STORE_ID, {\r\n      keyPath: 'id',\r\n      autoIncrement: true\r\n    });\r\n  };\r\n\r\n  var dbPromise = new Promise(function (res, rej) {\r\n    openRequest.onerror = function (ev) {\r\n      return rej(ev);\r\n    };\r\n\r\n    openRequest.onsuccess = function () {\r\n      res(openRequest.result);\r\n    };\r\n  });\r\n  return dbPromise;\r\n}\r\n/**\r\n * writes the new message to the database\r\n * so other readers can find it\r\n */\r\n\r\nfunction writeMessage(db, readerUuid, messageJson) {\r\n  var time = new Date().getTime();\r\n  var writeObject = {\r\n    uuid: readerUuid,\r\n    time: time,\r\n    data: messageJson\r\n  };\r\n  var transaction = db.transaction([OBJECT_STORE_ID], 'readwrite');\r\n  return new Promise(function (res, rej) {\r\n    transaction.oncomplete = function () {\r\n      return res();\r\n    };\r\n\r\n    transaction.onerror = function (ev) {\r\n      return rej(ev);\r\n    };\r\n\r\n    var objectStore = transaction.objectStore(OBJECT_STORE_ID);\r\n    objectStore.add(writeObject);\r\n  });\r\n}\r\nfunction getAllMessages(db) {\r\n  var objectStore = db.transaction(OBJECT_STORE_ID).objectStore(OBJECT_STORE_ID);\r\n  var ret = [];\r\n  return new Promise(function (res) {\r\n    objectStore.openCursor().onsuccess = function (ev) {\r\n      var cursor = ev.target.result;\r\n\r\n      if (cursor) {\r\n        ret.push(cursor.value); //alert(\"Name for SSN \" + cursor.key + \" is \" + cursor.value.name);\r\n\r\n        cursor[\"continue\"]();\r\n      } else {\r\n        res(ret);\r\n      }\r\n    };\r\n  });\r\n}\r\nfunction getMessagesHigherThan(db, lastCursorId) {\r\n  var objectStore = db.transaction(OBJECT_STORE_ID).objectStore(OBJECT_STORE_ID);\r\n  var ret = [];\r\n\r\n  function openCursor() {\r\n    // Occasionally Safari will fail on IDBKeyRange.bound, this\r\n    // catches that error, having it open the cursor to the first\r\n    // item. When it gets data it will advance to the desired key.\r\n    try {\r\n      var keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);\r\n      return objectStore.openCursor(keyRangeValue);\r\n    } catch (e) {\r\n      return objectStore.openCursor();\r\n    }\r\n  }\r\n\r\n  return new Promise(function (res) {\r\n    openCursor().onsuccess = function (ev) {\r\n      var cursor = ev.target.result;\r\n\r\n      if (cursor) {\r\n        if (cursor.value.id < lastCursorId + 1) {\r\n          cursor[\"continue\"](lastCursorId + 1);\r\n        } else {\r\n          ret.push(cursor.value);\r\n          cursor[\"continue\"]();\r\n        }\r\n      } else {\r\n        res(ret);\r\n      }\r\n    };\r\n  });\r\n}\r\nfunction removeMessageById(db, id) {\r\n  var request = db.transaction([OBJECT_STORE_ID], 'readwrite').objectStore(OBJECT_STORE_ID)[\"delete\"](id);\r\n  return new Promise(function (res) {\r\n    request.onsuccess = function () {\r\n      return res();\r\n    };\r\n  });\r\n}\r\nfunction getOldMessages(db, ttl) {\r\n  var olderThen = new Date().getTime() - ttl;\r\n  var objectStore = db.transaction(OBJECT_STORE_ID).objectStore(OBJECT_STORE_ID);\r\n  var ret = [];\r\n  return new Promise(function (res) {\r\n    objectStore.openCursor().onsuccess = function (ev) {\r\n      var cursor = ev.target.result;\r\n\r\n      if (cursor) {\r\n        var msgObk = cursor.value;\r\n\r\n        if (msgObk.time < olderThen) {\r\n          ret.push(msgObk); //alert(\"Name for SSN \" + cursor.key + \" is \" + cursor.value.name);\r\n\r\n          cursor[\"continue\"]();\r\n        } else {\r\n          // no more old messages,\r\n          res(ret);\r\n          return;\r\n        }\r\n      } else {\r\n        res(ret);\r\n      }\r\n    };\r\n  });\r\n}\r\nfunction cleanOldMessages(db, ttl) {\r\n  return getOldMessages(db, ttl).then(function (tooOld) {\r\n    return Promise.all(tooOld.map(function (msgObj) {\r\n      return removeMessageById(db, msgObj.id);\r\n    }));\r\n  });\r\n}\r\nfunction create(channelName, options) {\r\n  options = (0,_options__WEBPACK_IMPORTED_MODULE_1__.fillOptionsWithDefaults)(options);\r\n  return createDatabase(channelName).then(function (db) {\r\n    var state = {\r\n      closed: false,\r\n      lastCursorId: 0,\r\n      channelName: channelName,\r\n      options: options,\r\n      uuid: (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.randomToken)(),\r\n\r\n      /**\r\n       * emittedMessagesIds\r\n       * contains all messages that have been emitted before\r\n       * @type {ObliviousSet}\r\n       */\r\n      eMIs: new oblivious_set__WEBPACK_IMPORTED_MODULE_2__.ObliviousSet(options.idb.ttl * 2),\r\n      // ensures we do not read messages in parrallel\r\n      writeBlockPromise: _util_js__WEBPACK_IMPORTED_MODULE_0__.PROMISE_RESOLVED_VOID,\r\n      messagesCallback: null,\r\n      readQueuePromises: [],\r\n      db: db\r\n    };\r\n    /**\r\n     * Handle abrupt closes that do not originate from db.close().\r\n     * This could happen, for example, if the underlying storage is\r\n     * removed or if the user clears the database in the browser's\r\n     * history preferences.\r\n     */\r\n\r\n    db.onclose = function () {\r\n      state.closed = true;\r\n      if (options.idb.onclose) options.idb.onclose();\r\n    };\r\n    /**\r\n     * if service-workers are used,\r\n     * we have no 'storage'-event if they post a message,\r\n     * therefore we also have to set an interval\r\n     */\r\n\r\n\r\n    _readLoop(state);\r\n\r\n    return state;\r\n  });\r\n}\r\n\r\nfunction _readLoop(state) {\r\n  if (state.closed) return;\r\n  readNewMessages(state).then(function () {\r\n    return (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.sleep)(state.options.idb.fallbackInterval);\r\n  }).then(function () {\r\n    return _readLoop(state);\r\n  });\r\n}\r\n\r\nfunction _filterMessage(msgObj, state) {\r\n  if (msgObj.uuid === state.uuid) return false; // send by own\r\n\r\n  if (state.eMIs.has(msgObj.id)) return false; // already emitted\r\n\r\n  if (msgObj.data.time < state.messagesCallbackTime) return false; // older then onMessageCallback\r\n\r\n  return true;\r\n}\r\n/**\r\n * reads all new messages from the database and emits them\r\n */\r\n\r\n\r\nfunction readNewMessages(state) {\r\n  // channel already closed\r\n  if (state.closed) return _util_js__WEBPACK_IMPORTED_MODULE_0__.PROMISE_RESOLVED_VOID; // if no one is listening, we do not need to scan for new messages\r\n\r\n  if (!state.messagesCallback) return _util_js__WEBPACK_IMPORTED_MODULE_0__.PROMISE_RESOLVED_VOID;\r\n  return getMessagesHigherThan(state.db, state.lastCursorId).then(function (newerMessages) {\r\n    var useMessages = newerMessages\r\n    /**\r\n     * there is a bug in iOS where the msgObj can be undefined some times\r\n     * so we filter them out\r\n     * @link https://github.com/pubkey/broadcast-channel/issues/19\r\n     */\r\n    .filter(function (msgObj) {\r\n      return !!msgObj;\r\n    }).map(function (msgObj) {\r\n      if (msgObj.id > state.lastCursorId) {\r\n        state.lastCursorId = msgObj.id;\r\n      }\r\n\r\n      return msgObj;\r\n    }).filter(function (msgObj) {\r\n      return _filterMessage(msgObj, state);\r\n    }).sort(function (msgObjA, msgObjB) {\r\n      return msgObjA.time - msgObjB.time;\r\n    }); // sort by time\r\n\r\n    useMessages.forEach(function (msgObj) {\r\n      if (state.messagesCallback) {\r\n        state.eMIs.add(msgObj.id);\r\n        state.messagesCallback(msgObj.data);\r\n      }\r\n    });\r\n    return _util_js__WEBPACK_IMPORTED_MODULE_0__.PROMISE_RESOLVED_VOID;\r\n  });\r\n}\r\n\r\nfunction close(channelState) {\r\n  channelState.closed = true;\r\n  channelState.db.close();\r\n}\r\nfunction postMessage(channelState, messageJson) {\r\n  channelState.writeBlockPromise = channelState.writeBlockPromise.then(function () {\r\n    return writeMessage(channelState.db, channelState.uuid, messageJson);\r\n  }).then(function () {\r\n    if ((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.randomInt)(0, 10) === 0) {\r\n      /* await (do not await) */\r\n      cleanOldMessages(channelState.db, channelState.options.idb.ttl);\r\n    }\r\n  });\r\n  return channelState.writeBlockPromise;\r\n}\r\nfunction onMessage(channelState, fn, time) {\r\n  channelState.messagesCallbackTime = time;\r\n  channelState.messagesCallback = fn;\r\n  readNewMessages(channelState);\r\n}\r\nfunction canBeUsed() {\r\n  if (_util_js__WEBPACK_IMPORTED_MODULE_0__.isNode) return false;\r\n  var idb = getIdb();\r\n  if (!idb) return false;\r\n  return true;\r\n}\r\nfunction averageResponseTime(options) {\r\n  return options.idb.fallbackInterval * 2;\r\n}\r\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\r\n  create: create,\r\n  close: close,\r\n  onMessage: onMessage,\r\n  postMessage: postMessage,\r\n  canBeUsed: canBeUsed,\r\n  type: type,\r\n  averageResponseTime: averageResponseTime,\r\n  microSeconds: microSeconds\r\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYnJvYWRjYXN0LWNoYW5uZWwvZGlzdC9lc2Jyb3dzZXIvbWV0aG9kcy9pbmRleGVkLWRiLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2lIO0FBQzFHLG1CQUFtQixrREFBSztBQUNjO0FBQ1E7QUFDckQ7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ087QUFDUCxZQUFZLGlFQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFEQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsZ0JBQWdCLHVEQUFZO0FBQzVCO0FBQ0EseUJBQXlCLDJEQUFxQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywrQ0FBSztBQUNoQixHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDJEQUFxQixFQUFFO0FBQ2xEO0FBQ0Esc0NBQXNDLDJEQUFxQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUssR0FBRztBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxXQUFXLDJEQUFxQjtBQUNoQyxHQUFHO0FBQ0g7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNILFFBQVEsbURBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxNQUFNLDRDQUFNO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSwrREFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9icm9hZGNhc3QtY2hhbm5lbC9kaXN0L2VzYnJvd3Nlci9tZXRob2RzL2luZGV4ZWQtZGIuanM/MDg3NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogdGhpcyBtZXRob2QgdXNlcyBpbmRleGVkZGIgdG8gc3RvcmUgdGhlIG1lc3NhZ2VzXHJcbiAqIFRoZXJlIGlzIGN1cnJlbnRseSBubyBvYnNlcnZlckFQSSBmb3IgaWRiXHJcbiAqIEBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS93M2MvSW5kZXhlZERCL2lzc3Vlcy81MVxyXG4gKi9cclxuaW1wb3J0IHsgc2xlZXAsIHJhbmRvbUludCwgcmFuZG9tVG9rZW4sIG1pY3JvU2Vjb25kcyBhcyBtaWNybywgaXNOb2RlLCBQUk9NSVNFX1JFU09MVkVEX1ZPSUQgfSBmcm9tICcuLi91dGlsLmpzJztcclxuZXhwb3J0IHZhciBtaWNyb1NlY29uZHMgPSBtaWNybztcclxuaW1wb3J0IHsgT2JsaXZpb3VzU2V0IH0gZnJvbSAnb2JsaXZpb3VzLXNldCc7XHJcbmltcG9ydCB7IGZpbGxPcHRpb25zV2l0aERlZmF1bHRzIH0gZnJvbSAnLi4vb3B0aW9ucyc7XHJcbnZhciBEQl9QUkVGSVggPSAncHVia2V5LmJyb2FkY2FzdC1jaGFubmVsLTAtJztcclxudmFyIE9CSkVDVF9TVE9SRV9JRCA9ICdtZXNzYWdlcyc7XHJcbmV4cG9ydCB2YXIgdHlwZSA9ICdpZGInO1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0SWRiKCkge1xyXG4gIGlmICh0eXBlb2YgaW5kZXhlZERCICE9PSAndW5kZWZpbmVkJykgcmV0dXJuIGluZGV4ZWREQjtcclxuXHJcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdy5tb3pJbmRleGVkREIgIT09ICd1bmRlZmluZWQnKSByZXR1cm4gd2luZG93Lm1vekluZGV4ZWREQjtcclxuICAgIGlmICh0eXBlb2Ygd2luZG93LndlYmtpdEluZGV4ZWREQiAhPT0gJ3VuZGVmaW5lZCcpIHJldHVybiB3aW5kb3cud2Via2l0SW5kZXhlZERCO1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cubXNJbmRleGVkREIgIT09ICd1bmRlZmluZWQnKSByZXR1cm4gd2luZG93Lm1zSW5kZXhlZERCO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVEYXRhYmFzZShjaGFubmVsTmFtZSkge1xyXG4gIHZhciBJbmRleGVkREIgPSBnZXRJZGIoKTsgLy8gY3JlYXRlIHRhYmxlXHJcblxyXG4gIHZhciBkYk5hbWUgPSBEQl9QUkVGSVggKyBjaGFubmVsTmFtZTtcclxuICB2YXIgb3BlblJlcXVlc3QgPSBJbmRleGVkREIub3BlbihkYk5hbWUsIDEpO1xyXG5cclxuICBvcGVuUmVxdWVzdC5vbnVwZ3JhZGVuZWVkZWQgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgIHZhciBkYiA9IGV2LnRhcmdldC5yZXN1bHQ7XHJcbiAgICBkYi5jcmVhdGVPYmplY3RTdG9yZShPQkpFQ1RfU1RPUkVfSUQsIHtcclxuICAgICAga2V5UGF0aDogJ2lkJyxcclxuICAgICAgYXV0b0luY3JlbWVudDogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgdmFyIGRiUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXMsIHJlaikge1xyXG4gICAgb3BlblJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICByZXR1cm4gcmVqKGV2KTtcclxuICAgIH07XHJcblxyXG4gICAgb3BlblJlcXVlc3Qub25zdWNjZXNzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXMob3BlblJlcXVlc3QucmVzdWx0KTtcclxuICAgIH07XHJcbiAgfSk7XHJcbiAgcmV0dXJuIGRiUHJvbWlzZTtcclxufVxyXG4vKipcclxuICogd3JpdGVzIHRoZSBuZXcgbWVzc2FnZSB0byB0aGUgZGF0YWJhc2VcclxuICogc28gb3RoZXIgcmVhZGVycyBjYW4gZmluZCBpdFxyXG4gKi9cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB3cml0ZU1lc3NhZ2UoZGIsIHJlYWRlclV1aWQsIG1lc3NhZ2VKc29uKSB7XHJcbiAgdmFyIHRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICB2YXIgd3JpdGVPYmplY3QgPSB7XHJcbiAgICB1dWlkOiByZWFkZXJVdWlkLFxyXG4gICAgdGltZTogdGltZSxcclxuICAgIGRhdGE6IG1lc3NhZ2VKc29uXHJcbiAgfTtcclxuICB2YXIgdHJhbnNhY3Rpb24gPSBkYi50cmFuc2FjdGlvbihbT0JKRUNUX1NUT1JFX0lEXSwgJ3JlYWR3cml0ZScpO1xyXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzLCByZWopIHtcclxuICAgIHRyYW5zYWN0aW9uLm9uY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiByZXMoKTtcclxuICAgIH07XHJcblxyXG4gICAgdHJhbnNhY3Rpb24ub25lcnJvciA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICByZXR1cm4gcmVqKGV2KTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIG9iamVjdFN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoT0JKRUNUX1NUT1JFX0lEKTtcclxuICAgIG9iamVjdFN0b3JlLmFkZCh3cml0ZU9iamVjdCk7XHJcbiAgfSk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEFsbE1lc3NhZ2VzKGRiKSB7XHJcbiAgdmFyIG9iamVjdFN0b3JlID0gZGIudHJhbnNhY3Rpb24oT0JKRUNUX1NUT1JFX0lEKS5vYmplY3RTdG9yZShPQkpFQ1RfU1RPUkVfSUQpO1xyXG4gIHZhciByZXQgPSBbXTtcclxuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlcykge1xyXG4gICAgb2JqZWN0U3RvcmUub3BlbkN1cnNvcigpLm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICB2YXIgY3Vyc29yID0gZXYudGFyZ2V0LnJlc3VsdDtcclxuXHJcbiAgICAgIGlmIChjdXJzb3IpIHtcclxuICAgICAgICByZXQucHVzaChjdXJzb3IudmFsdWUpOyAvL2FsZXJ0KFwiTmFtZSBmb3IgU1NOIFwiICsgY3Vyc29yLmtleSArIFwiIGlzIFwiICsgY3Vyc29yLnZhbHVlLm5hbWUpO1xyXG5cclxuICAgICAgICBjdXJzb3JbXCJjb250aW51ZVwiXSgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJlcyhyZXQpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH0pO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRNZXNzYWdlc0hpZ2hlclRoYW4oZGIsIGxhc3RDdXJzb3JJZCkge1xyXG4gIHZhciBvYmplY3RTdG9yZSA9IGRiLnRyYW5zYWN0aW9uKE9CSkVDVF9TVE9SRV9JRCkub2JqZWN0U3RvcmUoT0JKRUNUX1NUT1JFX0lEKTtcclxuICB2YXIgcmV0ID0gW107XHJcblxyXG4gIGZ1bmN0aW9uIG9wZW5DdXJzb3IoKSB7XHJcbiAgICAvLyBPY2Nhc2lvbmFsbHkgU2FmYXJpIHdpbGwgZmFpbCBvbiBJREJLZXlSYW5nZS5ib3VuZCwgdGhpc1xyXG4gICAgLy8gY2F0Y2hlcyB0aGF0IGVycm9yLCBoYXZpbmcgaXQgb3BlbiB0aGUgY3Vyc29yIHRvIHRoZSBmaXJzdFxyXG4gICAgLy8gaXRlbS4gV2hlbiBpdCBnZXRzIGRhdGEgaXQgd2lsbCBhZHZhbmNlIHRvIHRoZSBkZXNpcmVkIGtleS5cclxuICAgIHRyeSB7XHJcbiAgICAgIHZhciBrZXlSYW5nZVZhbHVlID0gSURCS2V5UmFuZ2UuYm91bmQobGFzdEN1cnNvcklkICsgMSwgSW5maW5pdHkpO1xyXG4gICAgICByZXR1cm4gb2JqZWN0U3RvcmUub3BlbkN1cnNvcihrZXlSYW5nZVZhbHVlKTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgcmV0dXJuIG9iamVjdFN0b3JlLm9wZW5DdXJzb3IoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzKSB7XHJcbiAgICBvcGVuQ3Vyc29yKCkub25zdWNjZXNzID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgIHZhciBjdXJzb3IgPSBldi50YXJnZXQucmVzdWx0O1xyXG5cclxuICAgICAgaWYgKGN1cnNvcikge1xyXG4gICAgICAgIGlmIChjdXJzb3IudmFsdWUuaWQgPCBsYXN0Q3Vyc29ySWQgKyAxKSB7XHJcbiAgICAgICAgICBjdXJzb3JbXCJjb250aW51ZVwiXShsYXN0Q3Vyc29ySWQgKyAxKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmV0LnB1c2goY3Vyc29yLnZhbHVlKTtcclxuICAgICAgICAgIGN1cnNvcltcImNvbnRpbnVlXCJdKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJlcyhyZXQpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH0pO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVNZXNzYWdlQnlJZChkYiwgaWQpIHtcclxuICB2YXIgcmVxdWVzdCA9IGRiLnRyYW5zYWN0aW9uKFtPQkpFQ1RfU1RPUkVfSURdLCAncmVhZHdyaXRlJykub2JqZWN0U3RvcmUoT0JKRUNUX1NUT1JFX0lEKVtcImRlbGV0ZVwiXShpZCk7XHJcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXMpIHtcclxuICAgIHJlcXVlc3Qub25zdWNjZXNzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gcmVzKCk7XHJcbiAgICB9O1xyXG4gIH0pO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRPbGRNZXNzYWdlcyhkYiwgdHRsKSB7XHJcbiAgdmFyIG9sZGVyVGhlbiA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gdHRsO1xyXG4gIHZhciBvYmplY3RTdG9yZSA9IGRiLnRyYW5zYWN0aW9uKE9CSkVDVF9TVE9SRV9JRCkub2JqZWN0U3RvcmUoT0JKRUNUX1NUT1JFX0lEKTtcclxuICB2YXIgcmV0ID0gW107XHJcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXMpIHtcclxuICAgIG9iamVjdFN0b3JlLm9wZW5DdXJzb3IoKS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgdmFyIGN1cnNvciA9IGV2LnRhcmdldC5yZXN1bHQ7XHJcblxyXG4gICAgICBpZiAoY3Vyc29yKSB7XHJcbiAgICAgICAgdmFyIG1zZ09iayA9IGN1cnNvci52YWx1ZTtcclxuXHJcbiAgICAgICAgaWYgKG1zZ09iay50aW1lIDwgb2xkZXJUaGVuKSB7XHJcbiAgICAgICAgICByZXQucHVzaChtc2dPYmspOyAvL2FsZXJ0KFwiTmFtZSBmb3IgU1NOIFwiICsgY3Vyc29yLmtleSArIFwiIGlzIFwiICsgY3Vyc29yLnZhbHVlLm5hbWUpO1xyXG5cclxuICAgICAgICAgIGN1cnNvcltcImNvbnRpbnVlXCJdKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIG5vIG1vcmUgb2xkIG1lc3NhZ2VzLFxyXG4gICAgICAgICAgcmVzKHJldCk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJlcyhyZXQpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH0pO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBjbGVhbk9sZE1lc3NhZ2VzKGRiLCB0dGwpIHtcclxuICByZXR1cm4gZ2V0T2xkTWVzc2FnZXMoZGIsIHR0bCkudGhlbihmdW5jdGlvbiAodG9vT2xkKSB7XHJcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwodG9vT2xkLm1hcChmdW5jdGlvbiAobXNnT2JqKSB7XHJcbiAgICAgIHJldHVybiByZW1vdmVNZXNzYWdlQnlJZChkYiwgbXNnT2JqLmlkKTtcclxuICAgIH0pKTtcclxuICB9KTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKGNoYW5uZWxOYW1lLCBvcHRpb25zKSB7XHJcbiAgb3B0aW9ucyA9IGZpbGxPcHRpb25zV2l0aERlZmF1bHRzKG9wdGlvbnMpO1xyXG4gIHJldHVybiBjcmVhdGVEYXRhYmFzZShjaGFubmVsTmFtZSkudGhlbihmdW5jdGlvbiAoZGIpIHtcclxuICAgIHZhciBzdGF0ZSA9IHtcclxuICAgICAgY2xvc2VkOiBmYWxzZSxcclxuICAgICAgbGFzdEN1cnNvcklkOiAwLFxyXG4gICAgICBjaGFubmVsTmFtZTogY2hhbm5lbE5hbWUsXHJcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXHJcbiAgICAgIHV1aWQ6IHJhbmRvbVRva2VuKCksXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogZW1pdHRlZE1lc3NhZ2VzSWRzXHJcbiAgICAgICAqIGNvbnRhaW5zIGFsbCBtZXNzYWdlcyB0aGF0IGhhdmUgYmVlbiBlbWl0dGVkIGJlZm9yZVxyXG4gICAgICAgKiBAdHlwZSB7T2JsaXZpb3VzU2V0fVxyXG4gICAgICAgKi9cclxuICAgICAgZU1JczogbmV3IE9ibGl2aW91c1NldChvcHRpb25zLmlkYi50dGwgKiAyKSxcclxuICAgICAgLy8gZW5zdXJlcyB3ZSBkbyBub3QgcmVhZCBtZXNzYWdlcyBpbiBwYXJyYWxsZWxcclxuICAgICAgd3JpdGVCbG9ja1Byb21pc2U6IFBST01JU0VfUkVTT0xWRURfVk9JRCxcclxuICAgICAgbWVzc2FnZXNDYWxsYmFjazogbnVsbCxcclxuICAgICAgcmVhZFF1ZXVlUHJvbWlzZXM6IFtdLFxyXG4gICAgICBkYjogZGJcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZSBhYnJ1cHQgY2xvc2VzIHRoYXQgZG8gbm90IG9yaWdpbmF0ZSBmcm9tIGRiLmNsb3NlKCkuXHJcbiAgICAgKiBUaGlzIGNvdWxkIGhhcHBlbiwgZm9yIGV4YW1wbGUsIGlmIHRoZSB1bmRlcmx5aW5nIHN0b3JhZ2UgaXNcclxuICAgICAqIHJlbW92ZWQgb3IgaWYgdGhlIHVzZXIgY2xlYXJzIHRoZSBkYXRhYmFzZSBpbiB0aGUgYnJvd3NlcidzXHJcbiAgICAgKiBoaXN0b3J5IHByZWZlcmVuY2VzLlxyXG4gICAgICovXHJcblxyXG4gICAgZGIub25jbG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgc3RhdGUuY2xvc2VkID0gdHJ1ZTtcclxuICAgICAgaWYgKG9wdGlvbnMuaWRiLm9uY2xvc2UpIG9wdGlvbnMuaWRiLm9uY2xvc2UoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIGlmIHNlcnZpY2Utd29ya2VycyBhcmUgdXNlZCxcclxuICAgICAqIHdlIGhhdmUgbm8gJ3N0b3JhZ2UnLWV2ZW50IGlmIHRoZXkgcG9zdCBhIG1lc3NhZ2UsXHJcbiAgICAgKiB0aGVyZWZvcmUgd2UgYWxzbyBoYXZlIHRvIHNldCBhbiBpbnRlcnZhbFxyXG4gICAgICovXHJcblxyXG5cclxuICAgIF9yZWFkTG9vcChzdGF0ZSk7XHJcblxyXG4gICAgcmV0dXJuIHN0YXRlO1xyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfcmVhZExvb3Aoc3RhdGUpIHtcclxuICBpZiAoc3RhdGUuY2xvc2VkKSByZXR1cm47XHJcbiAgcmVhZE5ld01lc3NhZ2VzKHN0YXRlKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBzbGVlcChzdGF0ZS5vcHRpb25zLmlkYi5mYWxsYmFja0ludGVydmFsKTtcclxuICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBfcmVhZExvb3Aoc3RhdGUpO1xyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfZmlsdGVyTWVzc2FnZShtc2dPYmosIHN0YXRlKSB7XHJcbiAgaWYgKG1zZ09iai51dWlkID09PSBzdGF0ZS51dWlkKSByZXR1cm4gZmFsc2U7IC8vIHNlbmQgYnkgb3duXHJcblxyXG4gIGlmIChzdGF0ZS5lTUlzLmhhcyhtc2dPYmouaWQpKSByZXR1cm4gZmFsc2U7IC8vIGFscmVhZHkgZW1pdHRlZFxyXG5cclxuICBpZiAobXNnT2JqLmRhdGEudGltZSA8IHN0YXRlLm1lc3NhZ2VzQ2FsbGJhY2tUaW1lKSByZXR1cm4gZmFsc2U7IC8vIG9sZGVyIHRoZW4gb25NZXNzYWdlQ2FsbGJhY2tcclxuXHJcbiAgcmV0dXJuIHRydWU7XHJcbn1cclxuLyoqXHJcbiAqIHJlYWRzIGFsbCBuZXcgbWVzc2FnZXMgZnJvbSB0aGUgZGF0YWJhc2UgYW5kIGVtaXRzIHRoZW1cclxuICovXHJcblxyXG5cclxuZnVuY3Rpb24gcmVhZE5ld01lc3NhZ2VzKHN0YXRlKSB7XHJcbiAgLy8gY2hhbm5lbCBhbHJlYWR5IGNsb3NlZFxyXG4gIGlmIChzdGF0ZS5jbG9zZWQpIHJldHVybiBQUk9NSVNFX1JFU09MVkVEX1ZPSUQ7IC8vIGlmIG5vIG9uZSBpcyBsaXN0ZW5pbmcsIHdlIGRvIG5vdCBuZWVkIHRvIHNjYW4gZm9yIG5ldyBtZXNzYWdlc1xyXG5cclxuICBpZiAoIXN0YXRlLm1lc3NhZ2VzQ2FsbGJhY2spIHJldHVybiBQUk9NSVNFX1JFU09MVkVEX1ZPSUQ7XHJcbiAgcmV0dXJuIGdldE1lc3NhZ2VzSGlnaGVyVGhhbihzdGF0ZS5kYiwgc3RhdGUubGFzdEN1cnNvcklkKS50aGVuKGZ1bmN0aW9uIChuZXdlck1lc3NhZ2VzKSB7XHJcbiAgICB2YXIgdXNlTWVzc2FnZXMgPSBuZXdlck1lc3NhZ2VzXHJcbiAgICAvKipcclxuICAgICAqIHRoZXJlIGlzIGEgYnVnIGluIGlPUyB3aGVyZSB0aGUgbXNnT2JqIGNhbiBiZSB1bmRlZmluZWQgc29tZSB0aW1lc1xyXG4gICAgICogc28gd2UgZmlsdGVyIHRoZW0gb3V0XHJcbiAgICAgKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vcHVia2V5L2Jyb2FkY2FzdC1jaGFubmVsL2lzc3Vlcy8xOVxyXG4gICAgICovXHJcbiAgICAuZmlsdGVyKGZ1bmN0aW9uIChtc2dPYmopIHtcclxuICAgICAgcmV0dXJuICEhbXNnT2JqO1xyXG4gICAgfSkubWFwKGZ1bmN0aW9uIChtc2dPYmopIHtcclxuICAgICAgaWYgKG1zZ09iai5pZCA+IHN0YXRlLmxhc3RDdXJzb3JJZCkge1xyXG4gICAgICAgIHN0YXRlLmxhc3RDdXJzb3JJZCA9IG1zZ09iai5pZDtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG1zZ09iajtcclxuICAgIH0pLmZpbHRlcihmdW5jdGlvbiAobXNnT2JqKSB7XHJcbiAgICAgIHJldHVybiBfZmlsdGVyTWVzc2FnZShtc2dPYmosIHN0YXRlKTtcclxuICAgIH0pLnNvcnQoZnVuY3Rpb24gKG1zZ09iakEsIG1zZ09iakIpIHtcclxuICAgICAgcmV0dXJuIG1zZ09iakEudGltZSAtIG1zZ09iakIudGltZTtcclxuICAgIH0pOyAvLyBzb3J0IGJ5IHRpbWVcclxuXHJcbiAgICB1c2VNZXNzYWdlcy5mb3JFYWNoKGZ1bmN0aW9uIChtc2dPYmopIHtcclxuICAgICAgaWYgKHN0YXRlLm1lc3NhZ2VzQ2FsbGJhY2spIHtcclxuICAgICAgICBzdGF0ZS5lTUlzLmFkZChtc2dPYmouaWQpO1xyXG4gICAgICAgIHN0YXRlLm1lc3NhZ2VzQ2FsbGJhY2sobXNnT2JqLmRhdGEpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBQUk9NSVNFX1JFU09MVkVEX1ZPSUQ7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjbG9zZShjaGFubmVsU3RhdGUpIHtcclxuICBjaGFubmVsU3RhdGUuY2xvc2VkID0gdHJ1ZTtcclxuICBjaGFubmVsU3RhdGUuZGIuY2xvc2UoKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gcG9zdE1lc3NhZ2UoY2hhbm5lbFN0YXRlLCBtZXNzYWdlSnNvbikge1xyXG4gIGNoYW5uZWxTdGF0ZS53cml0ZUJsb2NrUHJvbWlzZSA9IGNoYW5uZWxTdGF0ZS53cml0ZUJsb2NrUHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB3cml0ZU1lc3NhZ2UoY2hhbm5lbFN0YXRlLmRiLCBjaGFubmVsU3RhdGUudXVpZCwgbWVzc2FnZUpzb24pO1xyXG4gIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHJhbmRvbUludCgwLCAxMCkgPT09IDApIHtcclxuICAgICAgLyogYXdhaXQgKGRvIG5vdCBhd2FpdCkgKi9cclxuICAgICAgY2xlYW5PbGRNZXNzYWdlcyhjaGFubmVsU3RhdGUuZGIsIGNoYW5uZWxTdGF0ZS5vcHRpb25zLmlkYi50dGwpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIHJldHVybiBjaGFubmVsU3RhdGUud3JpdGVCbG9ja1Byb21pc2U7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIG9uTWVzc2FnZShjaGFubmVsU3RhdGUsIGZuLCB0aW1lKSB7XHJcbiAgY2hhbm5lbFN0YXRlLm1lc3NhZ2VzQ2FsbGJhY2tUaW1lID0gdGltZTtcclxuICBjaGFubmVsU3RhdGUubWVzc2FnZXNDYWxsYmFjayA9IGZuO1xyXG4gIHJlYWROZXdNZXNzYWdlcyhjaGFubmVsU3RhdGUpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBjYW5CZVVzZWQoKSB7XHJcbiAgaWYgKGlzTm9kZSkgcmV0dXJuIGZhbHNlO1xyXG4gIHZhciBpZGIgPSBnZXRJZGIoKTtcclxuICBpZiAoIWlkYikgcmV0dXJuIGZhbHNlO1xyXG4gIHJldHVybiB0cnVlO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBhdmVyYWdlUmVzcG9uc2VUaW1lKG9wdGlvbnMpIHtcclxuICByZXR1cm4gb3B0aW9ucy5pZGIuZmFsbGJhY2tJbnRlcnZhbCAqIDI7XHJcbn1cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIGNyZWF0ZTogY3JlYXRlLFxyXG4gIGNsb3NlOiBjbG9zZSxcclxuICBvbk1lc3NhZ2U6IG9uTWVzc2FnZSxcclxuICBwb3N0TWVzc2FnZTogcG9zdE1lc3NhZ2UsXHJcbiAgY2FuQmVVc2VkOiBjYW5CZVVzZWQsXHJcbiAgdHlwZTogdHlwZSxcclxuICBhdmVyYWdlUmVzcG9uc2VUaW1lOiBhdmVyYWdlUmVzcG9uc2VUaW1lLFxyXG4gIG1pY3JvU2Vjb25kczogbWljcm9TZWNvbmRzXHJcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/broadcast-channel/dist/esbrowser/methods/indexed-db.js\n");

/***/ }),

/***/ "./node_modules/broadcast-channel/dist/esbrowser/methods/localstorage.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/broadcast-channel/dist/esbrowser/methods/localstorage.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"microSeconds\": function() { return /* binding */ microSeconds; },\n/* harmony export */   \"type\": function() { return /* binding */ type; },\n/* harmony export */   \"getLocalStorage\": function() { return /* binding */ getLocalStorage; },\n/* harmony export */   \"storageKey\": function() { return /* binding */ storageKey; },\n/* harmony export */   \"postMessage\": function() { return /* binding */ postMessage; },\n/* harmony export */   \"addStorageEventListener\": function() { return /* binding */ addStorageEventListener; },\n/* harmony export */   \"removeStorageEventListener\": function() { return /* binding */ removeStorageEventListener; },\n/* harmony export */   \"create\": function() { return /* binding */ create; },\n/* harmony export */   \"close\": function() { return /* binding */ close; },\n/* harmony export */   \"onMessage\": function() { return /* binding */ onMessage; },\n/* harmony export */   \"canBeUsed\": function() { return /* binding */ canBeUsed; },\n/* harmony export */   \"averageResponseTime\": function() { return /* binding */ averageResponseTime; }\n/* harmony export */ });\n/* harmony import */ var oblivious_set__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! oblivious-set */ \"./node_modules/oblivious-set/dist/es/index.js\");\n/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../options */ \"./node_modules/broadcast-channel/dist/esbrowser/options.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ \"./node_modules/broadcast-channel/dist/esbrowser/util.js\");\n/**\r\n * A localStorage-only method which uses localstorage and its 'storage'-event\r\n * This does not work inside of webworkers because they have no access to locastorage\r\n * This is basically implemented to support IE9 or your grandmothers toaster.\r\n * @link https://caniuse.com/#feat=namevalue-storage\r\n * @link https://caniuse.com/#feat=indexeddb\r\n */\r\n\r\n\r\n\r\nvar microSeconds = _util__WEBPACK_IMPORTED_MODULE_0__.microSeconds;\r\nvar KEY_PREFIX = 'pubkey.broadcastChannel-';\r\nvar type = 'localstorage';\r\n/**\r\n * copied from crosstab\r\n * @link https://github.com/tejacques/crosstab/blob/master/src/crosstab.js#L32\r\n */\r\n\r\nfunction getLocalStorage() {\r\n  var localStorage;\r\n  if (typeof window === 'undefined') return null;\r\n\r\n  try {\r\n    localStorage = window.localStorage;\r\n    localStorage = window['ie8-eventlistener/storage'] || window.localStorage;\r\n  } catch (e) {// New versions of Firefox throw a Security exception\r\n    // if cookies are disabled. See\r\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1028153\r\n  }\r\n\r\n  return localStorage;\r\n}\r\nfunction storageKey(channelName) {\r\n  return KEY_PREFIX + channelName;\r\n}\r\n/**\r\n* writes the new message to the storage\r\n* and fires the storage-event so other readers can find it\r\n*/\r\n\r\nfunction postMessage(channelState, messageJson) {\r\n  return new Promise(function (res) {\r\n    (0,_util__WEBPACK_IMPORTED_MODULE_0__.sleep)().then(function () {\r\n      var key = storageKey(channelState.channelName);\r\n      var writeObj = {\r\n        token: (0,_util__WEBPACK_IMPORTED_MODULE_0__.randomToken)(),\r\n        time: new Date().getTime(),\r\n        data: messageJson,\r\n        uuid: channelState.uuid\r\n      };\r\n      var value = JSON.stringify(writeObj);\r\n      getLocalStorage().setItem(key, value);\r\n      /**\r\n       * StorageEvent does not fire the 'storage' event\r\n       * in the window that changes the state of the local storage.\r\n       * So we fire it manually\r\n       */\r\n\r\n      var ev = document.createEvent('Event');\r\n      ev.initEvent('storage', true, true);\r\n      ev.key = key;\r\n      ev.newValue = value;\r\n      window.dispatchEvent(ev);\r\n      res();\r\n    });\r\n  });\r\n}\r\nfunction addStorageEventListener(channelName, fn) {\r\n  var key = storageKey(channelName);\r\n\r\n  var listener = function listener(ev) {\r\n    if (ev.key === key) {\r\n      fn(JSON.parse(ev.newValue));\r\n    }\r\n  };\r\n\r\n  window.addEventListener('storage', listener);\r\n  return listener;\r\n}\r\nfunction removeStorageEventListener(listener) {\r\n  window.removeEventListener('storage', listener);\r\n}\r\nfunction create(channelName, options) {\r\n  options = (0,_options__WEBPACK_IMPORTED_MODULE_1__.fillOptionsWithDefaults)(options);\r\n\r\n  if (!canBeUsed()) {\r\n    throw new Error('BroadcastChannel: localstorage cannot be used');\r\n  }\r\n\r\n  var uuid = (0,_util__WEBPACK_IMPORTED_MODULE_0__.randomToken)();\r\n  /**\r\n   * eMIs\r\n   * contains all messages that have been emitted before\r\n   * @type {ObliviousSet}\r\n   */\r\n\r\n  var eMIs = new oblivious_set__WEBPACK_IMPORTED_MODULE_2__.ObliviousSet(options.localstorage.removeTimeout);\r\n  var state = {\r\n    channelName: channelName,\r\n    uuid: uuid,\r\n    eMIs: eMIs // emittedMessagesIds\r\n\r\n  };\r\n  state.listener = addStorageEventListener(channelName, function (msgObj) {\r\n    if (!state.messagesCallback) return; // no listener\r\n\r\n    if (msgObj.uuid === uuid) return; // own message\r\n\r\n    if (!msgObj.token || eMIs.has(msgObj.token)) return; // already emitted\r\n\r\n    if (msgObj.data.time && msgObj.data.time < state.messagesCallbackTime) return; // too old\r\n\r\n    eMIs.add(msgObj.token);\r\n    state.messagesCallback(msgObj.data);\r\n  });\r\n  return state;\r\n}\r\nfunction close(channelState) {\r\n  removeStorageEventListener(channelState.listener);\r\n}\r\nfunction onMessage(channelState, fn, time) {\r\n  channelState.messagesCallbackTime = time;\r\n  channelState.messagesCallback = fn;\r\n}\r\nfunction canBeUsed() {\r\n  if (_util__WEBPACK_IMPORTED_MODULE_0__.isNode) return false;\r\n  var ls = getLocalStorage();\r\n  if (!ls) return false;\r\n\r\n  try {\r\n    var key = '__broadcastchannel_check';\r\n    ls.setItem(key, 'works');\r\n    ls.removeItem(key);\r\n  } catch (e) {\r\n    // Safari 10 in private mode will not allow write access to local\r\n    // storage and fail with a QuotaExceededError. See\r\n    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API#Private_Browsing_Incognito_modes\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\nfunction averageResponseTime() {\r\n  var defaultTime = 120;\r\n  var userAgent = navigator.userAgent.toLowerCase();\r\n\r\n  if (userAgent.includes('safari') && !userAgent.includes('chrome')) {\r\n    // safari is much slower so this time is higher\r\n    return defaultTime * 2;\r\n  }\r\n\r\n  return defaultTime;\r\n}\r\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\r\n  create: create,\r\n  close: close,\r\n  onMessage: onMessage,\r\n  postMessage: postMessage,\r\n  canBeUsed: canBeUsed,\r\n  type: type,\r\n  averageResponseTime: averageResponseTime,\r\n  microSeconds: microSeconds\r\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYnJvYWRjYXN0LWNoYW5uZWwvZGlzdC9lc2Jyb3dzZXIvbWV0aG9kcy9sb2NhbHN0b3JhZ2UuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDNkM7QUFDUTtBQUN1QjtBQUNyRSxtQkFBbUIsK0NBQUs7QUFDL0I7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksV0FBVztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsSUFBSSw0Q0FBSztBQUNUO0FBQ0E7QUFDQSxlQUFlLGtEQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQLFlBQVksaUVBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtEQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsaUJBQWlCLHVEQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQLE1BQU0seUNBQU07QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2Jyb2FkY2FzdC1jaGFubmVsL2Rpc3QvZXNicm93c2VyL21ldGhvZHMvbG9jYWxzdG9yYWdlLmpzPzNkZGEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEEgbG9jYWxTdG9yYWdlLW9ubHkgbWV0aG9kIHdoaWNoIHVzZXMgbG9jYWxzdG9yYWdlIGFuZCBpdHMgJ3N0b3JhZ2UnLWV2ZW50XHJcbiAqIFRoaXMgZG9lcyBub3Qgd29yayBpbnNpZGUgb2Ygd2Vid29ya2VycyBiZWNhdXNlIHRoZXkgaGF2ZSBubyBhY2Nlc3MgdG8gbG9jYXN0b3JhZ2VcclxuICogVGhpcyBpcyBiYXNpY2FsbHkgaW1wbGVtZW50ZWQgdG8gc3VwcG9ydCBJRTkgb3IgeW91ciBncmFuZG1vdGhlcnMgdG9hc3Rlci5cclxuICogQGxpbmsgaHR0cHM6Ly9jYW5pdXNlLmNvbS8jZmVhdD1uYW1ldmFsdWUtc3RvcmFnZVxyXG4gKiBAbGluayBodHRwczovL2Nhbml1c2UuY29tLyNmZWF0PWluZGV4ZWRkYlxyXG4gKi9cclxuaW1wb3J0IHsgT2JsaXZpb3VzU2V0IH0gZnJvbSAnb2JsaXZpb3VzLXNldCc7XHJcbmltcG9ydCB7IGZpbGxPcHRpb25zV2l0aERlZmF1bHRzIH0gZnJvbSAnLi4vb3B0aW9ucyc7XHJcbmltcG9ydCB7IHNsZWVwLCByYW5kb21Ub2tlbiwgbWljcm9TZWNvbmRzIGFzIG1pY3JvLCBpc05vZGUgfSBmcm9tICcuLi91dGlsJztcclxuZXhwb3J0IHZhciBtaWNyb1NlY29uZHMgPSBtaWNybztcclxudmFyIEtFWV9QUkVGSVggPSAncHVia2V5LmJyb2FkY2FzdENoYW5uZWwtJztcclxuZXhwb3J0IHZhciB0eXBlID0gJ2xvY2Fsc3RvcmFnZSc7XHJcbi8qKlxyXG4gKiBjb3BpZWQgZnJvbSBjcm9zc3RhYlxyXG4gKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vdGVqYWNxdWVzL2Nyb3NzdGFiL2Jsb2IvbWFzdGVyL3NyYy9jcm9zc3RhYi5qcyNMMzJcclxuICovXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TG9jYWxTdG9yYWdlKCkge1xyXG4gIHZhciBsb2NhbFN0b3JhZ2U7XHJcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgdHJ5IHtcclxuICAgIGxvY2FsU3RvcmFnZSA9IHdpbmRvdy5sb2NhbFN0b3JhZ2U7XHJcbiAgICBsb2NhbFN0b3JhZ2UgPSB3aW5kb3dbJ2llOC1ldmVudGxpc3RlbmVyL3N0b3JhZ2UnXSB8fCB3aW5kb3cubG9jYWxTdG9yYWdlO1xyXG4gIH0gY2F0Y2ggKGUpIHsvLyBOZXcgdmVyc2lvbnMgb2YgRmlyZWZveCB0aHJvdyBhIFNlY3VyaXR5IGV4Y2VwdGlvblxyXG4gICAgLy8gaWYgY29va2llcyBhcmUgZGlzYWJsZWQuIFNlZVxyXG4gICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTAyODE1M1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGxvY2FsU3RvcmFnZTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gc3RvcmFnZUtleShjaGFubmVsTmFtZSkge1xyXG4gIHJldHVybiBLRVlfUFJFRklYICsgY2hhbm5lbE5hbWU7XHJcbn1cclxuLyoqXHJcbiogd3JpdGVzIHRoZSBuZXcgbWVzc2FnZSB0byB0aGUgc3RvcmFnZVxyXG4qIGFuZCBmaXJlcyB0aGUgc3RvcmFnZS1ldmVudCBzbyBvdGhlciByZWFkZXJzIGNhbiBmaW5kIGl0XHJcbiovXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcG9zdE1lc3NhZ2UoY2hhbm5lbFN0YXRlLCBtZXNzYWdlSnNvbikge1xyXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzKSB7XHJcbiAgICBzbGVlcCgpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIga2V5ID0gc3RvcmFnZUtleShjaGFubmVsU3RhdGUuY2hhbm5lbE5hbWUpO1xyXG4gICAgICB2YXIgd3JpdGVPYmogPSB7XHJcbiAgICAgICAgdG9rZW46IHJhbmRvbVRva2VuKCksXHJcbiAgICAgICAgdGltZTogbmV3IERhdGUoKS5nZXRUaW1lKCksXHJcbiAgICAgICAgZGF0YTogbWVzc2FnZUpzb24sXHJcbiAgICAgICAgdXVpZDogY2hhbm5lbFN0YXRlLnV1aWRcclxuICAgICAgfTtcclxuICAgICAgdmFyIHZhbHVlID0gSlNPTi5zdHJpbmdpZnkod3JpdGVPYmopO1xyXG4gICAgICBnZXRMb2NhbFN0b3JhZ2UoKS5zZXRJdGVtKGtleSwgdmFsdWUpO1xyXG4gICAgICAvKipcclxuICAgICAgICogU3RvcmFnZUV2ZW50IGRvZXMgbm90IGZpcmUgdGhlICdzdG9yYWdlJyBldmVudFxyXG4gICAgICAgKiBpbiB0aGUgd2luZG93IHRoYXQgY2hhbmdlcyB0aGUgc3RhdGUgb2YgdGhlIGxvY2FsIHN0b3JhZ2UuXHJcbiAgICAgICAqIFNvIHdlIGZpcmUgaXQgbWFudWFsbHlcclxuICAgICAgICovXHJcblxyXG4gICAgICB2YXIgZXYgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcclxuICAgICAgZXYuaW5pdEV2ZW50KCdzdG9yYWdlJywgdHJ1ZSwgdHJ1ZSk7XHJcbiAgICAgIGV2LmtleSA9IGtleTtcclxuICAgICAgZXYubmV3VmFsdWUgPSB2YWx1ZTtcclxuICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQoZXYpO1xyXG4gICAgICByZXMoKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBhZGRTdG9yYWdlRXZlbnRMaXN0ZW5lcihjaGFubmVsTmFtZSwgZm4pIHtcclxuICB2YXIga2V5ID0gc3RvcmFnZUtleShjaGFubmVsTmFtZSk7XHJcblxyXG4gIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIGxpc3RlbmVyKGV2KSB7XHJcbiAgICBpZiAoZXYua2V5ID09PSBrZXkpIHtcclxuICAgICAgZm4oSlNPTi5wYXJzZShldi5uZXdWYWx1ZSkpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzdG9yYWdlJywgbGlzdGVuZXIpO1xyXG4gIHJldHVybiBsaXN0ZW5lcjtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlU3RvcmFnZUV2ZW50TGlzdGVuZXIobGlzdGVuZXIpIHtcclxuICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc3RvcmFnZScsIGxpc3RlbmVyKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKGNoYW5uZWxOYW1lLCBvcHRpb25zKSB7XHJcbiAgb3B0aW9ucyA9IGZpbGxPcHRpb25zV2l0aERlZmF1bHRzKG9wdGlvbnMpO1xyXG5cclxuICBpZiAoIWNhbkJlVXNlZCgpKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jyb2FkY2FzdENoYW5uZWw6IGxvY2Fsc3RvcmFnZSBjYW5ub3QgYmUgdXNlZCcpO1xyXG4gIH1cclxuXHJcbiAgdmFyIHV1aWQgPSByYW5kb21Ub2tlbigpO1xyXG4gIC8qKlxyXG4gICAqIGVNSXNcclxuICAgKiBjb250YWlucyBhbGwgbWVzc2FnZXMgdGhhdCBoYXZlIGJlZW4gZW1pdHRlZCBiZWZvcmVcclxuICAgKiBAdHlwZSB7T2JsaXZpb3VzU2V0fVxyXG4gICAqL1xyXG5cclxuICB2YXIgZU1JcyA9IG5ldyBPYmxpdmlvdXNTZXQob3B0aW9ucy5sb2NhbHN0b3JhZ2UucmVtb3ZlVGltZW91dCk7XHJcbiAgdmFyIHN0YXRlID0ge1xyXG4gICAgY2hhbm5lbE5hbWU6IGNoYW5uZWxOYW1lLFxyXG4gICAgdXVpZDogdXVpZCxcclxuICAgIGVNSXM6IGVNSXMgLy8gZW1pdHRlZE1lc3NhZ2VzSWRzXHJcblxyXG4gIH07XHJcbiAgc3RhdGUubGlzdGVuZXIgPSBhZGRTdG9yYWdlRXZlbnRMaXN0ZW5lcihjaGFubmVsTmFtZSwgZnVuY3Rpb24gKG1zZ09iaikge1xyXG4gICAgaWYgKCFzdGF0ZS5tZXNzYWdlc0NhbGxiYWNrKSByZXR1cm47IC8vIG5vIGxpc3RlbmVyXHJcblxyXG4gICAgaWYgKG1zZ09iai51dWlkID09PSB1dWlkKSByZXR1cm47IC8vIG93biBtZXNzYWdlXHJcblxyXG4gICAgaWYgKCFtc2dPYmoudG9rZW4gfHwgZU1Jcy5oYXMobXNnT2JqLnRva2VuKSkgcmV0dXJuOyAvLyBhbHJlYWR5IGVtaXR0ZWRcclxuXHJcbiAgICBpZiAobXNnT2JqLmRhdGEudGltZSAmJiBtc2dPYmouZGF0YS50aW1lIDwgc3RhdGUubWVzc2FnZXNDYWxsYmFja1RpbWUpIHJldHVybjsgLy8gdG9vIG9sZFxyXG5cclxuICAgIGVNSXMuYWRkKG1zZ09iai50b2tlbik7XHJcbiAgICBzdGF0ZS5tZXNzYWdlc0NhbGxiYWNrKG1zZ09iai5kYXRhKTtcclxuICB9KTtcclxuICByZXR1cm4gc3RhdGU7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGNsb3NlKGNoYW5uZWxTdGF0ZSkge1xyXG4gIHJlbW92ZVN0b3JhZ2VFdmVudExpc3RlbmVyKGNoYW5uZWxTdGF0ZS5saXN0ZW5lcik7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIG9uTWVzc2FnZShjaGFubmVsU3RhdGUsIGZuLCB0aW1lKSB7XHJcbiAgY2hhbm5lbFN0YXRlLm1lc3NhZ2VzQ2FsbGJhY2tUaW1lID0gdGltZTtcclxuICBjaGFubmVsU3RhdGUubWVzc2FnZXNDYWxsYmFjayA9IGZuO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBjYW5CZVVzZWQoKSB7XHJcbiAgaWYgKGlzTm9kZSkgcmV0dXJuIGZhbHNlO1xyXG4gIHZhciBscyA9IGdldExvY2FsU3RvcmFnZSgpO1xyXG4gIGlmICghbHMpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgdHJ5IHtcclxuICAgIHZhciBrZXkgPSAnX19icm9hZGNhc3RjaGFubmVsX2NoZWNrJztcclxuICAgIGxzLnNldEl0ZW0oa2V5LCAnd29ya3MnKTtcclxuICAgIGxzLnJlbW92ZUl0ZW0oa2V5KTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICAvLyBTYWZhcmkgMTAgaW4gcHJpdmF0ZSBtb2RlIHdpbGwgbm90IGFsbG93IHdyaXRlIGFjY2VzcyB0byBsb2NhbFxyXG4gICAgLy8gc3RvcmFnZSBhbmQgZmFpbCB3aXRoIGEgUXVvdGFFeGNlZWRlZEVycm9yLiBTZWVcclxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJfU3RvcmFnZV9BUEkjUHJpdmF0ZV9Ccm93c2luZ19JbmNvZ25pdG9fbW9kZXNcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIHJldHVybiB0cnVlO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBhdmVyYWdlUmVzcG9uc2VUaW1lKCkge1xyXG4gIHZhciBkZWZhdWx0VGltZSA9IDEyMDtcclxuICB2YXIgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xyXG5cclxuICBpZiAodXNlckFnZW50LmluY2x1ZGVzKCdzYWZhcmknKSAmJiAhdXNlckFnZW50LmluY2x1ZGVzKCdjaHJvbWUnKSkge1xyXG4gICAgLy8gc2FmYXJpIGlzIG11Y2ggc2xvd2VyIHNvIHRoaXMgdGltZSBpcyBoaWdoZXJcclxuICAgIHJldHVybiBkZWZhdWx0VGltZSAqIDI7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZGVmYXVsdFRpbWU7XHJcbn1cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIGNyZWF0ZTogY3JlYXRlLFxyXG4gIGNsb3NlOiBjbG9zZSxcclxuICBvbk1lc3NhZ2U6IG9uTWVzc2FnZSxcclxuICBwb3N0TWVzc2FnZTogcG9zdE1lc3NhZ2UsXHJcbiAgY2FuQmVVc2VkOiBjYW5CZVVzZWQsXHJcbiAgdHlwZTogdHlwZSxcclxuICBhdmVyYWdlUmVzcG9uc2VUaW1lOiBhdmVyYWdlUmVzcG9uc2VUaW1lLFxyXG4gIG1pY3JvU2Vjb25kczogbWljcm9TZWNvbmRzXHJcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/broadcast-channel/dist/esbrowser/methods/localstorage.js\n");

/***/ }),

/***/ "./node_modules/broadcast-channel/dist/esbrowser/methods/native.js":
/*!*************************************************************************!*\
  !*** ./node_modules/broadcast-channel/dist/esbrowser/methods/native.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"microSeconds\": function() { return /* binding */ microSeconds; },\n/* harmony export */   \"type\": function() { return /* binding */ type; },\n/* harmony export */   \"create\": function() { return /* binding */ create; },\n/* harmony export */   \"close\": function() { return /* binding */ close; },\n/* harmony export */   \"postMessage\": function() { return /* binding */ postMessage; },\n/* harmony export */   \"onMessage\": function() { return /* binding */ onMessage; },\n/* harmony export */   \"canBeUsed\": function() { return /* binding */ canBeUsed; },\n/* harmony export */   \"averageResponseTime\": function() { return /* binding */ averageResponseTime; }\n/* harmony export */ });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ \"./node_modules/broadcast-channel/dist/esbrowser/util.js\");\n\r\nvar microSeconds = _util__WEBPACK_IMPORTED_MODULE_0__.microSeconds;\r\nvar type = 'native';\r\nfunction create(channelName) {\r\n  var state = {\r\n    messagesCallback: null,\r\n    bc: new BroadcastChannel(channelName),\r\n    subFns: [] // subscriberFunctions\r\n\r\n  };\r\n\r\n  state.bc.onmessage = function (msg) {\r\n    if (state.messagesCallback) {\r\n      state.messagesCallback(msg.data);\r\n    }\r\n  };\r\n\r\n  return state;\r\n}\r\nfunction close(channelState) {\r\n  channelState.bc.close();\r\n  channelState.subFns = [];\r\n}\r\nfunction postMessage(channelState, messageJson) {\r\n  try {\r\n    channelState.bc.postMessage(messageJson, false);\r\n    return _util__WEBPACK_IMPORTED_MODULE_0__.PROMISE_RESOLVED_VOID;\r\n  } catch (err) {\r\n    return Promise.reject(err);\r\n  }\r\n}\r\nfunction onMessage(channelState, fn) {\r\n  channelState.messagesCallback = fn;\r\n}\r\nfunction canBeUsed() {\r\n  /**\r\n   * in the electron-renderer, isNode will be true even if we are in browser-context\r\n   * so we also check if window is undefined\r\n   */\r\n  if (_util__WEBPACK_IMPORTED_MODULE_0__.isNode && typeof window === 'undefined') return false;\r\n\r\n  if (typeof BroadcastChannel === 'function') {\r\n    if (BroadcastChannel._pubkey) {\r\n      throw new Error('BroadcastChannel: Do not overwrite window.BroadcastChannel with this module, this is not a polyfill');\r\n    }\r\n\r\n    return true;\r\n  } else return false;\r\n}\r\nfunction averageResponseTime() {\r\n  return 150;\r\n}\r\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\r\n  create: create,\r\n  close: close,\r\n  onMessage: onMessage,\r\n  postMessage: postMessage,\r\n  canBeUsed: canBeUsed,\r\n  type: type,\r\n  averageResponseTime: averageResponseTime,\r\n  microSeconds: microSeconds\r\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYnJvYWRjYXN0LWNoYW5uZWwvZGlzdC9lc2Jyb3dzZXIvbWV0aG9kcy9uYXRpdmUuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQStFO0FBQ3hFLG1CQUFtQiwrQ0FBSztBQUN4QjtBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxXQUFXLHdEQUFxQjtBQUNoQyxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0seUNBQU07QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNPO0FBQ1A7QUFDQTtBQUNBLCtEQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2Jyb2FkY2FzdC1jaGFubmVsL2Rpc3QvZXNicm93c2VyL21ldGhvZHMvbmF0aXZlLmpzP2I3ZDAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbWljcm9TZWNvbmRzIGFzIG1pY3JvLCBpc05vZGUsIFBST01JU0VfUkVTT0xWRURfVk9JRCB9IGZyb20gJy4uL3V0aWwnO1xyXG5leHBvcnQgdmFyIG1pY3JvU2Vjb25kcyA9IG1pY3JvO1xyXG5leHBvcnQgdmFyIHR5cGUgPSAnbmF0aXZlJztcclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZShjaGFubmVsTmFtZSkge1xyXG4gIHZhciBzdGF0ZSA9IHtcclxuICAgIG1lc3NhZ2VzQ2FsbGJhY2s6IG51bGwsXHJcbiAgICBiYzogbmV3IEJyb2FkY2FzdENoYW5uZWwoY2hhbm5lbE5hbWUpLFxyXG4gICAgc3ViRm5zOiBbXSAvLyBzdWJzY3JpYmVyRnVuY3Rpb25zXHJcblxyXG4gIH07XHJcblxyXG4gIHN0YXRlLmJjLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChtc2cpIHtcclxuICAgIGlmIChzdGF0ZS5tZXNzYWdlc0NhbGxiYWNrKSB7XHJcbiAgICAgIHN0YXRlLm1lc3NhZ2VzQ2FsbGJhY2sobXNnLmRhdGEpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHJldHVybiBzdGF0ZTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gY2xvc2UoY2hhbm5lbFN0YXRlKSB7XHJcbiAgY2hhbm5lbFN0YXRlLmJjLmNsb3NlKCk7XHJcbiAgY2hhbm5lbFN0YXRlLnN1YkZucyA9IFtdO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBwb3N0TWVzc2FnZShjaGFubmVsU3RhdGUsIG1lc3NhZ2VKc29uKSB7XHJcbiAgdHJ5IHtcclxuICAgIGNoYW5uZWxTdGF0ZS5iYy5wb3N0TWVzc2FnZShtZXNzYWdlSnNvbiwgZmFsc2UpO1xyXG4gICAgcmV0dXJuIFBST01JU0VfUkVTT0xWRURfVk9JRDtcclxuICB9IGNhdGNoIChlcnIpIHtcclxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xyXG4gIH1cclxufVxyXG5leHBvcnQgZnVuY3Rpb24gb25NZXNzYWdlKGNoYW5uZWxTdGF0ZSwgZm4pIHtcclxuICBjaGFubmVsU3RhdGUubWVzc2FnZXNDYWxsYmFjayA9IGZuO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBjYW5CZVVzZWQoKSB7XHJcbiAgLyoqXHJcbiAgICogaW4gdGhlIGVsZWN0cm9uLXJlbmRlcmVyLCBpc05vZGUgd2lsbCBiZSB0cnVlIGV2ZW4gaWYgd2UgYXJlIGluIGJyb3dzZXItY29udGV4dFxyXG4gICAqIHNvIHdlIGFsc28gY2hlY2sgaWYgd2luZG93IGlzIHVuZGVmaW5lZFxyXG4gICAqL1xyXG4gIGlmIChpc05vZGUgJiYgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgaWYgKHR5cGVvZiBCcm9hZGNhc3RDaGFubmVsID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICBpZiAoQnJvYWRjYXN0Q2hhbm5lbC5fcHVia2V5KSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignQnJvYWRjYXN0Q2hhbm5lbDogRG8gbm90IG92ZXJ3cml0ZSB3aW5kb3cuQnJvYWRjYXN0Q2hhbm5lbCB3aXRoIHRoaXMgbW9kdWxlLCB0aGlzIGlzIG5vdCBhIHBvbHlmaWxsJyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSBlbHNlIHJldHVybiBmYWxzZTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gYXZlcmFnZVJlc3BvbnNlVGltZSgpIHtcclxuICByZXR1cm4gMTUwO1xyXG59XHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBjcmVhdGU6IGNyZWF0ZSxcclxuICBjbG9zZTogY2xvc2UsXHJcbiAgb25NZXNzYWdlOiBvbk1lc3NhZ2UsXHJcbiAgcG9zdE1lc3NhZ2U6IHBvc3RNZXNzYWdlLFxyXG4gIGNhbkJlVXNlZDogY2FuQmVVc2VkLFxyXG4gIHR5cGU6IHR5cGUsXHJcbiAgYXZlcmFnZVJlc3BvbnNlVGltZTogYXZlcmFnZVJlc3BvbnNlVGltZSxcclxuICBtaWNyb1NlY29uZHM6IG1pY3JvU2Vjb25kc1xyXG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/broadcast-channel/dist/esbrowser/methods/native.js\n");

/***/ }),

/***/ "./node_modules/broadcast-channel/dist/esbrowser/methods/simulate.js":
/*!***************************************************************************!*\
  !*** ./node_modules/broadcast-channel/dist/esbrowser/methods/simulate.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"microSeconds\": function() { return /* binding */ microSeconds; },\n/* harmony export */   \"type\": function() { return /* binding */ type; },\n/* harmony export */   \"create\": function() { return /* binding */ create; },\n/* harmony export */   \"close\": function() { return /* binding */ close; },\n/* harmony export */   \"postMessage\": function() { return /* binding */ postMessage; },\n/* harmony export */   \"onMessage\": function() { return /* binding */ onMessage; },\n/* harmony export */   \"canBeUsed\": function() { return /* binding */ canBeUsed; },\n/* harmony export */   \"averageResponseTime\": function() { return /* binding */ averageResponseTime; }\n/* harmony export */ });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ \"./node_modules/broadcast-channel/dist/esbrowser/util.js\");\n\r\nvar microSeconds = _util__WEBPACK_IMPORTED_MODULE_0__.microSeconds;\r\nvar type = 'simulate';\r\nvar SIMULATE_CHANNELS = new Set();\r\nfunction create(channelName) {\r\n  var state = {\r\n    name: channelName,\r\n    messagesCallback: null\r\n  };\r\n  SIMULATE_CHANNELS.add(state);\r\n  return state;\r\n}\r\nfunction close(channelState) {\r\n  SIMULATE_CHANNELS[\"delete\"](channelState);\r\n}\r\nfunction postMessage(channelState, messageJson) {\r\n  return new Promise(function (res) {\r\n    return setTimeout(function () {\r\n      var channelArray = Array.from(SIMULATE_CHANNELS);\r\n      channelArray.filter(function (channel) {\r\n        return channel.name === channelState.name;\r\n      }).filter(function (channel) {\r\n        return channel !== channelState;\r\n      }).filter(function (channel) {\r\n        return !!channel.messagesCallback;\r\n      }).forEach(function (channel) {\r\n        return channel.messagesCallback(messageJson);\r\n      });\r\n      res();\r\n    }, 5);\r\n  });\r\n}\r\nfunction onMessage(channelState, fn) {\r\n  channelState.messagesCallback = fn;\r\n}\r\nfunction canBeUsed() {\r\n  return true;\r\n}\r\nfunction averageResponseTime() {\r\n  return 5;\r\n}\r\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\r\n  create: create,\r\n  close: close,\r\n  onMessage: onMessage,\r\n  postMessage: postMessage,\r\n  canBeUsed: canBeUsed,\r\n  type: type,\r\n  averageResponseTime: averageResponseTime,\r\n  microSeconds: microSeconds\r\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYnJvYWRjYXN0LWNoYW5uZWwvZGlzdC9lc2Jyb3dzZXIvbWV0aG9kcy9zaW11bGF0ZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBZ0Q7QUFDekMsbUJBQW1CLCtDQUFLO0FBQ3hCO0FBQ1A7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLCtEQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2Jyb2FkY2FzdC1jaGFubmVsL2Rpc3QvZXNicm93c2VyL21ldGhvZHMvc2ltdWxhdGUuanM/NDkyOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBtaWNyb1NlY29uZHMgYXMgbWljcm8gfSBmcm9tICcuLi91dGlsJztcclxuZXhwb3J0IHZhciBtaWNyb1NlY29uZHMgPSBtaWNybztcclxuZXhwb3J0IHZhciB0eXBlID0gJ3NpbXVsYXRlJztcclxudmFyIFNJTVVMQVRFX0NIQU5ORUxTID0gbmV3IFNldCgpO1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKGNoYW5uZWxOYW1lKSB7XHJcbiAgdmFyIHN0YXRlID0ge1xyXG4gICAgbmFtZTogY2hhbm5lbE5hbWUsXHJcbiAgICBtZXNzYWdlc0NhbGxiYWNrOiBudWxsXHJcbiAgfTtcclxuICBTSU1VTEFURV9DSEFOTkVMUy5hZGQoc3RhdGUpO1xyXG4gIHJldHVybiBzdGF0ZTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gY2xvc2UoY2hhbm5lbFN0YXRlKSB7XHJcbiAgU0lNVUxBVEVfQ0hBTk5FTFNbXCJkZWxldGVcIl0oY2hhbm5lbFN0YXRlKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gcG9zdE1lc3NhZ2UoY2hhbm5lbFN0YXRlLCBtZXNzYWdlSnNvbikge1xyXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzKSB7XHJcbiAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBjaGFubmVsQXJyYXkgPSBBcnJheS5mcm9tKFNJTVVMQVRFX0NIQU5ORUxTKTtcclxuICAgICAgY2hhbm5lbEFycmF5LmZpbHRlcihmdW5jdGlvbiAoY2hhbm5lbCkge1xyXG4gICAgICAgIHJldHVybiBjaGFubmVsLm5hbWUgPT09IGNoYW5uZWxTdGF0ZS5uYW1lO1xyXG4gICAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKGNoYW5uZWwpIHtcclxuICAgICAgICByZXR1cm4gY2hhbm5lbCAhPT0gY2hhbm5lbFN0YXRlO1xyXG4gICAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKGNoYW5uZWwpIHtcclxuICAgICAgICByZXR1cm4gISFjaGFubmVsLm1lc3NhZ2VzQ2FsbGJhY2s7XHJcbiAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKGNoYW5uZWwpIHtcclxuICAgICAgICByZXR1cm4gY2hhbm5lbC5tZXNzYWdlc0NhbGxiYWNrKG1lc3NhZ2VKc29uKTtcclxuICAgICAgfSk7XHJcbiAgICAgIHJlcygpO1xyXG4gICAgfSwgNSk7XHJcbiAgfSk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIG9uTWVzc2FnZShjaGFubmVsU3RhdGUsIGZuKSB7XHJcbiAgY2hhbm5lbFN0YXRlLm1lc3NhZ2VzQ2FsbGJhY2sgPSBmbjtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gY2FuQmVVc2VkKCkge1xyXG4gIHJldHVybiB0cnVlO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBhdmVyYWdlUmVzcG9uc2VUaW1lKCkge1xyXG4gIHJldHVybiA1O1xyXG59XHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBjcmVhdGU6IGNyZWF0ZSxcclxuICBjbG9zZTogY2xvc2UsXHJcbiAgb25NZXNzYWdlOiBvbk1lc3NhZ2UsXHJcbiAgcG9zdE1lc3NhZ2U6IHBvc3RNZXNzYWdlLFxyXG4gIGNhbkJlVXNlZDogY2FuQmVVc2VkLFxyXG4gIHR5cGU6IHR5cGUsXHJcbiAgYXZlcmFnZVJlc3BvbnNlVGltZTogYXZlcmFnZVJlc3BvbnNlVGltZSxcclxuICBtaWNyb1NlY29uZHM6IG1pY3JvU2Vjb25kc1xyXG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/broadcast-channel/dist/esbrowser/methods/simulate.js\n");

/***/ }),

/***/ "./node_modules/broadcast-channel/dist/esbrowser/options.js":
/*!******************************************************************!*\
  !*** ./node_modules/broadcast-channel/dist/esbrowser/options.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"fillOptionsWithDefaults\": function() { return /* binding */ fillOptionsWithDefaults; }\n/* harmony export */ });\nfunction fillOptionsWithDefaults() {\r\n  var originalOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\r\n  var options = JSON.parse(JSON.stringify(originalOptions)); // main\r\n\r\n  if (typeof options.webWorkerSupport === 'undefined') options.webWorkerSupport = true; // indexed-db\r\n\r\n  if (!options.idb) options.idb = {}; //  after this time the messages get deleted\r\n\r\n  if (!options.idb.ttl) options.idb.ttl = 1000 * 45;\r\n  if (!options.idb.fallbackInterval) options.idb.fallbackInterval = 150; //  handles abrupt db onclose events.\r\n\r\n  if (originalOptions.idb && typeof originalOptions.idb.onclose === 'function') options.idb.onclose = originalOptions.idb.onclose; // localstorage\r\n\r\n  if (!options.localstorage) options.localstorage = {};\r\n  if (!options.localstorage.removeTimeout) options.localstorage.removeTimeout = 1000 * 60; // custom methods\r\n\r\n  if (originalOptions.methods) options.methods = originalOptions.methods; // node\r\n\r\n  if (!options.node) options.node = {};\r\n  if (!options.node.ttl) options.node.ttl = 1000 * 60 * 2; // 2 minutes;\r\n\r\n  /**\r\n   * On linux use 'ulimit -Hn' to get the limit of open files.\r\n   * On ubuntu this was 4096 for me, so we use half of that as maxParallelWrites default.\r\n   */\r\n\r\n  if (!options.node.maxParallelWrites) options.node.maxParallelWrites = 2048;\r\n  if (typeof options.node.useFastPath === 'undefined') options.node.useFastPath = true;\r\n  return options;\r\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYnJvYWRjYXN0LWNoYW5uZWwvZGlzdC9lc2Jyb3dzZXIvb3B0aW9ucy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUDtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBLHdGQUF3RjtBQUN4RjtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0EsbUlBQW1JO0FBQ25JO0FBQ0E7QUFDQSwyRkFBMkY7QUFDM0Y7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYnJvYWRjYXN0LWNoYW5uZWwvZGlzdC9lc2Jyb3dzZXIvb3B0aW9ucy5qcz84YzEzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBmaWxsT3B0aW9uc1dpdGhEZWZhdWx0cygpIHtcclxuICB2YXIgb3JpZ2luYWxPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcclxuICB2YXIgb3B0aW9ucyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob3JpZ2luYWxPcHRpb25zKSk7IC8vIG1haW5cclxuXHJcbiAgaWYgKHR5cGVvZiBvcHRpb25zLndlYldvcmtlclN1cHBvcnQgPT09ICd1bmRlZmluZWQnKSBvcHRpb25zLndlYldvcmtlclN1cHBvcnQgPSB0cnVlOyAvLyBpbmRleGVkLWRiXHJcblxyXG4gIGlmICghb3B0aW9ucy5pZGIpIG9wdGlvbnMuaWRiID0ge307IC8vICBhZnRlciB0aGlzIHRpbWUgdGhlIG1lc3NhZ2VzIGdldCBkZWxldGVkXHJcblxyXG4gIGlmICghb3B0aW9ucy5pZGIudHRsKSBvcHRpb25zLmlkYi50dGwgPSAxMDAwICogNDU7XHJcbiAgaWYgKCFvcHRpb25zLmlkYi5mYWxsYmFja0ludGVydmFsKSBvcHRpb25zLmlkYi5mYWxsYmFja0ludGVydmFsID0gMTUwOyAvLyAgaGFuZGxlcyBhYnJ1cHQgZGIgb25jbG9zZSBldmVudHMuXHJcblxyXG4gIGlmIChvcmlnaW5hbE9wdGlvbnMuaWRiICYmIHR5cGVvZiBvcmlnaW5hbE9wdGlvbnMuaWRiLm9uY2xvc2UgPT09ICdmdW5jdGlvbicpIG9wdGlvbnMuaWRiLm9uY2xvc2UgPSBvcmlnaW5hbE9wdGlvbnMuaWRiLm9uY2xvc2U7IC8vIGxvY2Fsc3RvcmFnZVxyXG5cclxuICBpZiAoIW9wdGlvbnMubG9jYWxzdG9yYWdlKSBvcHRpb25zLmxvY2Fsc3RvcmFnZSA9IHt9O1xyXG4gIGlmICghb3B0aW9ucy5sb2NhbHN0b3JhZ2UucmVtb3ZlVGltZW91dCkgb3B0aW9ucy5sb2NhbHN0b3JhZ2UucmVtb3ZlVGltZW91dCA9IDEwMDAgKiA2MDsgLy8gY3VzdG9tIG1ldGhvZHNcclxuXHJcbiAgaWYgKG9yaWdpbmFsT3B0aW9ucy5tZXRob2RzKSBvcHRpb25zLm1ldGhvZHMgPSBvcmlnaW5hbE9wdGlvbnMubWV0aG9kczsgLy8gbm9kZVxyXG5cclxuICBpZiAoIW9wdGlvbnMubm9kZSkgb3B0aW9ucy5ub2RlID0ge307XHJcbiAgaWYgKCFvcHRpb25zLm5vZGUudHRsKSBvcHRpb25zLm5vZGUudHRsID0gMTAwMCAqIDYwICogMjsgLy8gMiBtaW51dGVzO1xyXG5cclxuICAvKipcclxuICAgKiBPbiBsaW51eCB1c2UgJ3VsaW1pdCAtSG4nIHRvIGdldCB0aGUgbGltaXQgb2Ygb3BlbiBmaWxlcy5cclxuICAgKiBPbiB1YnVudHUgdGhpcyB3YXMgNDA5NiBmb3IgbWUsIHNvIHdlIHVzZSBoYWxmIG9mIHRoYXQgYXMgbWF4UGFyYWxsZWxXcml0ZXMgZGVmYXVsdC5cclxuICAgKi9cclxuXHJcbiAgaWYgKCFvcHRpb25zLm5vZGUubWF4UGFyYWxsZWxXcml0ZXMpIG9wdGlvbnMubm9kZS5tYXhQYXJhbGxlbFdyaXRlcyA9IDIwNDg7XHJcbiAgaWYgKHR5cGVvZiBvcHRpb25zLm5vZGUudXNlRmFzdFBhdGggPT09ICd1bmRlZmluZWQnKSBvcHRpb25zLm5vZGUudXNlRmFzdFBhdGggPSB0cnVlO1xyXG4gIHJldHVybiBvcHRpb25zO1xyXG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/broadcast-channel/dist/esbrowser/options.js\n");

/***/ }),

/***/ "./node_modules/broadcast-channel/dist/esbrowser/util.js":
/*!***************************************************************!*\
  !*** ./node_modules/broadcast-channel/dist/esbrowser/util.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isPromise\": function() { return /* binding */ isPromise; },\n/* harmony export */   \"PROMISE_RESOLVED_FALSE\": function() { return /* binding */ PROMISE_RESOLVED_FALSE; },\n/* harmony export */   \"PROMISE_RESOLVED_TRUE\": function() { return /* binding */ PROMISE_RESOLVED_TRUE; },\n/* harmony export */   \"PROMISE_RESOLVED_VOID\": function() { return /* binding */ PROMISE_RESOLVED_VOID; },\n/* harmony export */   \"sleep\": function() { return /* binding */ sleep; },\n/* harmony export */   \"randomInt\": function() { return /* binding */ randomInt; },\n/* harmony export */   \"randomToken\": function() { return /* binding */ randomToken; },\n/* harmony export */   \"microSeconds\": function() { return /* binding */ microSeconds; },\n/* harmony export */   \"isNode\": function() { return /* binding */ isNode; }\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/process/browser.js\");\n/**\r\n * returns true if the given object is a promise\r\n */\r\nfunction isPromise(obj) {\r\n  if (obj && typeof obj.then === 'function') {\r\n    return true;\r\n  } else {\r\n    return false;\r\n  }\r\n}\r\nvar PROMISE_RESOLVED_FALSE = Promise.resolve(false);\r\nvar PROMISE_RESOLVED_TRUE = Promise.resolve(true);\r\nvar PROMISE_RESOLVED_VOID = Promise.resolve();\r\nfunction sleep(time, resolveWith) {\r\n  if (!time) time = 0;\r\n  return new Promise(function (res) {\r\n    return setTimeout(function () {\r\n      return res(resolveWith);\r\n    }, time);\r\n  });\r\n}\r\nfunction randomInt(min, max) {\r\n  return Math.floor(Math.random() * (max - min + 1) + min);\r\n}\r\n/**\r\n * https://stackoverflow.com/a/8084248\r\n */\r\n\r\nfunction randomToken() {\r\n  return Math.random().toString(36).substring(2);\r\n}\r\nvar lastMs = 0;\r\nvar additional = 0;\r\n/**\r\n * returns the current time in micro-seconds,\r\n * WARNING: This is a pseudo-function\r\n * Performance.now is not reliable in webworkers, so we just make sure to never return the same time.\r\n * This is enough in browsers, and this function will not be used in nodejs.\r\n * The main reason for this hack is to ensure that BroadcastChannel behaves equal to production when it is used in fast-running unit tests.\r\n */\r\n\r\nfunction microSeconds() {\r\n  var ms = new Date().getTime();\r\n\r\n  if (ms === lastMs) {\r\n    additional++;\r\n    return ms * 1000 + additional;\r\n  } else {\r\n    lastMs = ms;\r\n    additional = 0;\r\n    return ms * 1000;\r\n  }\r\n}\r\n/**\r\n * copied from the 'detect-node' npm module\r\n * We cannot use the module directly because it causes problems with rollup\r\n * @link https://github.com/iliakan/detect-node/blob/master/index.js\r\n */\r\n\r\nvar isNode = Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]';//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYnJvYWRjYXN0LWNoYW5uZWwvZGlzdC9lc2Jyb3dzZXIvdXRpbC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNPO0FBQ0E7QUFDQTtBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sbURBQW1ELE9BQU8sbUJBQW1CLE9BQU8iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2Jyb2FkY2FzdC1jaGFubmVsL2Rpc3QvZXNicm93c2VyL3V0aWwuanM/NzU5MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogcmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBvYmplY3QgaXMgYSBwcm9taXNlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNQcm9taXNlKG9iaikge1xyXG4gIGlmIChvYmogJiYgdHlwZW9mIG9iai50aGVuID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufVxyXG5leHBvcnQgdmFyIFBST01JU0VfUkVTT0xWRURfRkFMU0UgPSBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xyXG5leHBvcnQgdmFyIFBST01JU0VfUkVTT0xWRURfVFJVRSA9IFByb21pc2UucmVzb2x2ZSh0cnVlKTtcclxuZXhwb3J0IHZhciBQUk9NSVNFX1JFU09MVkVEX1ZPSUQgPSBQcm9taXNlLnJlc29sdmUoKTtcclxuZXhwb3J0IGZ1bmN0aW9uIHNsZWVwKHRpbWUsIHJlc29sdmVXaXRoKSB7XHJcbiAgaWYgKCF0aW1lKSB0aW1lID0gMDtcclxuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlcykge1xyXG4gICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gcmVzKHJlc29sdmVXaXRoKTtcclxuICAgIH0sIHRpbWUpO1xyXG4gIH0pO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiByYW5kb21JbnQobWluLCBtYXgpIHtcclxuICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpICsgbWluKTtcclxufVxyXG4vKipcclxuICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzgwODQyNDhcclxuICovXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tVG9rZW4oKSB7XHJcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyKTtcclxufVxyXG52YXIgbGFzdE1zID0gMDtcclxudmFyIGFkZGl0aW9uYWwgPSAwO1xyXG4vKipcclxuICogcmV0dXJucyB0aGUgY3VycmVudCB0aW1lIGluIG1pY3JvLXNlY29uZHMsXHJcbiAqIFdBUk5JTkc6IFRoaXMgaXMgYSBwc2V1ZG8tZnVuY3Rpb25cclxuICogUGVyZm9ybWFuY2Uubm93IGlzIG5vdCByZWxpYWJsZSBpbiB3ZWJ3b3JrZXJzLCBzbyB3ZSBqdXN0IG1ha2Ugc3VyZSB0byBuZXZlciByZXR1cm4gdGhlIHNhbWUgdGltZS5cclxuICogVGhpcyBpcyBlbm91Z2ggaW4gYnJvd3NlcnMsIGFuZCB0aGlzIGZ1bmN0aW9uIHdpbGwgbm90IGJlIHVzZWQgaW4gbm9kZWpzLlxyXG4gKiBUaGUgbWFpbiByZWFzb24gZm9yIHRoaXMgaGFjayBpcyB0byBlbnN1cmUgdGhhdCBCcm9hZGNhc3RDaGFubmVsIGJlaGF2ZXMgZXF1YWwgdG8gcHJvZHVjdGlvbiB3aGVuIGl0IGlzIHVzZWQgaW4gZmFzdC1ydW5uaW5nIHVuaXQgdGVzdHMuXHJcbiAqL1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG1pY3JvU2Vjb25kcygpIHtcclxuICB2YXIgbXMgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuXHJcbiAgaWYgKG1zID09PSBsYXN0TXMpIHtcclxuICAgIGFkZGl0aW9uYWwrKztcclxuICAgIHJldHVybiBtcyAqIDEwMDAgKyBhZGRpdGlvbmFsO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBsYXN0TXMgPSBtcztcclxuICAgIGFkZGl0aW9uYWwgPSAwO1xyXG4gICAgcmV0dXJuIG1zICogMTAwMDtcclxuICB9XHJcbn1cclxuLyoqXHJcbiAqIGNvcGllZCBmcm9tIHRoZSAnZGV0ZWN0LW5vZGUnIG5wbSBtb2R1bGVcclxuICogV2UgY2Fubm90IHVzZSB0aGUgbW9kdWxlIGRpcmVjdGx5IGJlY2F1c2UgaXQgY2F1c2VzIHByb2JsZW1zIHdpdGggcm9sbHVwXHJcbiAqIEBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9pbGlha2FuL2RldGVjdC1ub2RlL2Jsb2IvbWFzdGVyL2luZGV4LmpzXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBpc05vZGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnID8gcHJvY2VzcyA6IDApID09PSAnW29iamVjdCBwcm9jZXNzXSc7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/broadcast-channel/dist/esbrowser/util.js\n");

/***/ }),

/***/ "./node_modules/call-bind/callBound.js":
/*!*********************************************!*\
  !*** ./node_modules/call-bind/callBound.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar GetIntrinsic = __webpack_require__(/*! get-intrinsic */ \"./node_modules/get-intrinsic/index.js\");\r\n\r\nvar callBind = __webpack_require__(/*! ./ */ \"./node_modules/call-bind/index.js\");\r\n\r\nvar $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));\r\n\r\nmodule.exports = function callBoundIntrinsic(name, allowMissing) {\r\n\tvar intrinsic = GetIntrinsic(name, !!allowMissing);\r\n\tif (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {\r\n\t\treturn callBind(intrinsic);\r\n\t}\r\n\treturn intrinsic;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2FsbC1iaW5kL2NhbGxCb3VuZC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsNERBQWU7QUFDMUM7QUFDQSxlQUFlLG1CQUFPLENBQUMsNkNBQUk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NhbGwtYmluZC9jYWxsQm91bmQuanM/YTFjOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xyXG5cclxudmFyIGNhbGxCaW5kID0gcmVxdWlyZSgnLi8nKTtcclxuXHJcbnZhciAkaW5kZXhPZiA9IGNhbGxCaW5kKEdldEludHJpbnNpYygnU3RyaW5nLnByb3RvdHlwZS5pbmRleE9mJykpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYWxsQm91bmRJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XHJcblx0dmFyIGludHJpbnNpYyA9IEdldEludHJpbnNpYyhuYW1lLCAhIWFsbG93TWlzc2luZyk7XHJcblx0aWYgKHR5cGVvZiBpbnRyaW5zaWMgPT09ICdmdW5jdGlvbicgJiYgJGluZGV4T2YobmFtZSwgJy5wcm90b3R5cGUuJykgPiAtMSkge1xyXG5cdFx0cmV0dXJuIGNhbGxCaW5kKGludHJpbnNpYyk7XHJcblx0fVxyXG5cdHJldHVybiBpbnRyaW5zaWM7XHJcbn07XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/call-bind/callBound.js\n");

/***/ }),

/***/ "./node_modules/call-bind/index.js":
/*!*****************************************!*\
  !*** ./node_modules/call-bind/index.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar bind = __webpack_require__(/*! function-bind */ \"./node_modules/function-bind/index.js\");\r\nvar GetIntrinsic = __webpack_require__(/*! get-intrinsic */ \"./node_modules/get-intrinsic/index.js\");\r\n\r\nvar $apply = GetIntrinsic('%Function.prototype.apply%');\r\nvar $call = GetIntrinsic('%Function.prototype.call%');\r\nvar $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);\r\n\r\nvar $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);\r\nvar $defineProperty = GetIntrinsic('%Object.defineProperty%', true);\r\nvar $max = GetIntrinsic('%Math.max%');\r\n\r\nif ($defineProperty) {\r\n\ttry {\r\n\t\t$defineProperty({}, 'a', { value: 1 });\r\n\t} catch (e) {\r\n\t\t// IE 8 has a broken defineProperty\r\n\t\t$defineProperty = null;\r\n\t}\r\n}\r\n\r\nmodule.exports = function callBind(originalFunction) {\r\n\tvar func = $reflectApply(bind, $call, arguments);\r\n\tif ($gOPD && $defineProperty) {\r\n\t\tvar desc = $gOPD(func, 'length');\r\n\t\tif (desc.configurable) {\r\n\t\t\t// original length, plus the receiver, minus any additional arguments (after the receiver)\r\n\t\t\t$defineProperty(\r\n\t\t\t\tfunc,\r\n\t\t\t\t'length',\r\n\t\t\t\t{ value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\treturn func;\r\n};\r\n\r\nvar applyBind = function applyBind() {\r\n\treturn $reflectApply(bind, $apply, arguments);\r\n};\r\n\r\nif ($defineProperty) {\r\n\t$defineProperty(module.exports, 'apply', { value: applyBind });\r\n} else {\r\n\tmodule.exports.apply = applyBind;\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2FsbC1iaW5kL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSxXQUFXLG1CQUFPLENBQUMsNERBQWU7QUFDbEMsbUJBQW1CLG1CQUFPLENBQUMsNERBQWU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTLFVBQVU7QUFDdkMsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxrQkFBa0I7QUFDOUQsRUFBRTtBQUNGLENBQUMsb0JBQW9CO0FBQ3JCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jYWxsLWJpbmQvaW5kZXguanM/NDY2YSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgYmluZCA9IHJlcXVpcmUoJ2Z1bmN0aW9uLWJpbmQnKTtcclxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcclxuXHJcbnZhciAkYXBwbHkgPSBHZXRJbnRyaW5zaWMoJyVGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHklJyk7XHJcbnZhciAkY2FsbCA9IEdldEludHJpbnNpYygnJUZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsJScpO1xyXG52YXIgJHJlZmxlY3RBcHBseSA9IEdldEludHJpbnNpYygnJVJlZmxlY3QuYXBwbHklJywgdHJ1ZSkgfHwgYmluZC5jYWxsKCRjYWxsLCAkYXBwbHkpO1xyXG5cclxudmFyICRnT1BEID0gR2V0SW50cmluc2ljKCclT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciUnLCB0cnVlKTtcclxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IEdldEludHJpbnNpYygnJU9iamVjdC5kZWZpbmVQcm9wZXJ0eSUnLCB0cnVlKTtcclxudmFyICRtYXggPSBHZXRJbnRyaW5zaWMoJyVNYXRoLm1heCUnKTtcclxuXHJcbmlmICgkZGVmaW5lUHJvcGVydHkpIHtcclxuXHR0cnkge1xyXG5cdFx0JGRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgdmFsdWU6IDEgfSk7XHJcblx0fSBjYXRjaCAoZSkge1xyXG5cdFx0Ly8gSUUgOCBoYXMgYSBicm9rZW4gZGVmaW5lUHJvcGVydHlcclxuXHRcdCRkZWZpbmVQcm9wZXJ0eSA9IG51bGw7XHJcblx0fVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhbGxCaW5kKG9yaWdpbmFsRnVuY3Rpb24pIHtcclxuXHR2YXIgZnVuYyA9ICRyZWZsZWN0QXBwbHkoYmluZCwgJGNhbGwsIGFyZ3VtZW50cyk7XHJcblx0aWYgKCRnT1BEICYmICRkZWZpbmVQcm9wZXJ0eSkge1xyXG5cdFx0dmFyIGRlc2MgPSAkZ09QRChmdW5jLCAnbGVuZ3RoJyk7XHJcblx0XHRpZiAoZGVzYy5jb25maWd1cmFibGUpIHtcclxuXHRcdFx0Ly8gb3JpZ2luYWwgbGVuZ3RoLCBwbHVzIHRoZSByZWNlaXZlciwgbWludXMgYW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIChhZnRlciB0aGUgcmVjZWl2ZXIpXHJcblx0XHRcdCRkZWZpbmVQcm9wZXJ0eShcclxuXHRcdFx0XHRmdW5jLFxyXG5cdFx0XHRcdCdsZW5ndGgnLFxyXG5cdFx0XHRcdHsgdmFsdWU6IDEgKyAkbWF4KDAsIG9yaWdpbmFsRnVuY3Rpb24ubGVuZ3RoIC0gKGFyZ3VtZW50cy5sZW5ndGggLSAxKSkgfVxyXG5cdFx0XHQpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gZnVuYztcclxufTtcclxuXHJcbnZhciBhcHBseUJpbmQgPSBmdW5jdGlvbiBhcHBseUJpbmQoKSB7XHJcblx0cmV0dXJuICRyZWZsZWN0QXBwbHkoYmluZCwgJGFwcGx5LCBhcmd1bWVudHMpO1xyXG59O1xyXG5cclxuaWYgKCRkZWZpbmVQcm9wZXJ0eSkge1xyXG5cdCRkZWZpbmVQcm9wZXJ0eShtb2R1bGUuZXhwb3J0cywgJ2FwcGx5JywgeyB2YWx1ZTogYXBwbHlCaW5kIH0pO1xyXG59IGVsc2Uge1xyXG5cdG1vZHVsZS5leHBvcnRzLmFwcGx5ID0gYXBwbHlCaW5kO1xyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/call-bind/index.js\n");

/***/ }),

/***/ "./node_modules/cipher-base/index.js":
/*!*******************************************!*\
  !*** ./node_modules/cipher-base/index.js ***!
  \*******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var Buffer = (__webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer)\r\nvar Transform = (__webpack_require__(/*! stream */ \"./node_modules/next/dist/compiled/stream-browserify/index.js\").Transform)\r\nvar StringDecoder = (__webpack_require__(/*! string_decoder */ \"./node_modules/string_decoder/lib/string_decoder.js\").StringDecoder)\r\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\r\n\r\nfunction CipherBase (hashMode) {\r\n  Transform.call(this)\r\n  this.hashMode = typeof hashMode === 'string'\r\n  if (this.hashMode) {\r\n    this[hashMode] = this._finalOrDigest\r\n  } else {\r\n    this.final = this._finalOrDigest\r\n  }\r\n  if (this._final) {\r\n    this.__final = this._final\r\n    this._final = null\r\n  }\r\n  this._decoder = null\r\n  this._encoding = null\r\n}\r\ninherits(CipherBase, Transform)\r\n\r\nCipherBase.prototype.update = function (data, inputEnc, outputEnc) {\r\n  if (typeof data === 'string') {\r\n    data = Buffer.from(data, inputEnc)\r\n  }\r\n\r\n  var outData = this._update(data)\r\n  if (this.hashMode) return this\r\n\r\n  if (outputEnc) {\r\n    outData = this._toString(outData, outputEnc)\r\n  }\r\n\r\n  return outData\r\n}\r\n\r\nCipherBase.prototype.setAutoPadding = function () {}\r\nCipherBase.prototype.getAuthTag = function () {\r\n  throw new Error('trying to get auth tag in unsupported state')\r\n}\r\n\r\nCipherBase.prototype.setAuthTag = function () {\r\n  throw new Error('trying to set auth tag in unsupported state')\r\n}\r\n\r\nCipherBase.prototype.setAAD = function () {\r\n  throw new Error('trying to set aad in unsupported state')\r\n}\r\n\r\nCipherBase.prototype._transform = function (data, _, next) {\r\n  var err\r\n  try {\r\n    if (this.hashMode) {\r\n      this._update(data)\r\n    } else {\r\n      this.push(this._update(data))\r\n    }\r\n  } catch (e) {\r\n    err = e\r\n  } finally {\r\n    next(err)\r\n  }\r\n}\r\nCipherBase.prototype._flush = function (done) {\r\n  var err\r\n  try {\r\n    this.push(this.__final())\r\n  } catch (e) {\r\n    err = e\r\n  }\r\n\r\n  done(err)\r\n}\r\nCipherBase.prototype._finalOrDigest = function (outputEnc) {\r\n  var outData = this.__final() || Buffer.alloc(0)\r\n  if (outputEnc) {\r\n    outData = this._toString(outData, outputEnc, true)\r\n  }\r\n  return outData\r\n}\r\n\r\nCipherBase.prototype._toString = function (value, enc, fin) {\r\n  if (!this._decoder) {\r\n    this._decoder = new StringDecoder(enc)\r\n    this._encoding = enc\r\n  }\r\n\r\n  if (this._encoding !== enc) throw new Error('can\\'t switch encodings')\r\n\r\n  var out = this._decoder.write(value)\r\n  if (fin) {\r\n    out += this._decoder.end()\r\n  }\r\n\r\n  return out\r\n}\r\n\r\nmodule.exports = CipherBase\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2lwaGVyLWJhc2UvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsYUFBYSxzRkFBNkI7QUFDMUMsZ0JBQWdCLDZHQUEyQjtBQUMzQyxvQkFBb0IsZ0hBQXVDO0FBQzNELGVBQWUsbUJBQU8sQ0FBQyw2REFBVTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY2lwaGVyLWJhc2UvaW5kZXguanM/ODgxMSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcclxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ3N0cmVhbScpLlRyYW5zZm9ybVxyXG52YXIgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyJykuU3RyaW5nRGVjb2RlclxyXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXHJcblxyXG5mdW5jdGlvbiBDaXBoZXJCYXNlIChoYXNoTW9kZSkge1xyXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMpXHJcbiAgdGhpcy5oYXNoTW9kZSA9IHR5cGVvZiBoYXNoTW9kZSA9PT0gJ3N0cmluZydcclxuICBpZiAodGhpcy5oYXNoTW9kZSkge1xyXG4gICAgdGhpc1toYXNoTW9kZV0gPSB0aGlzLl9maW5hbE9yRGlnZXN0XHJcbiAgfSBlbHNlIHtcclxuICAgIHRoaXMuZmluYWwgPSB0aGlzLl9maW5hbE9yRGlnZXN0XHJcbiAgfVxyXG4gIGlmICh0aGlzLl9maW5hbCkge1xyXG4gICAgdGhpcy5fX2ZpbmFsID0gdGhpcy5fZmluYWxcclxuICAgIHRoaXMuX2ZpbmFsID0gbnVsbFxyXG4gIH1cclxuICB0aGlzLl9kZWNvZGVyID0gbnVsbFxyXG4gIHRoaXMuX2VuY29kaW5nID0gbnVsbFxyXG59XHJcbmluaGVyaXRzKENpcGhlckJhc2UsIFRyYW5zZm9ybSlcclxuXHJcbkNpcGhlckJhc2UucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCBpbnB1dEVuYywgb3V0cHV0RW5jKSB7XHJcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xyXG4gICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEsIGlucHV0RW5jKVxyXG4gIH1cclxuXHJcbiAgdmFyIG91dERhdGEgPSB0aGlzLl91cGRhdGUoZGF0YSlcclxuICBpZiAodGhpcy5oYXNoTW9kZSkgcmV0dXJuIHRoaXNcclxuXHJcbiAgaWYgKG91dHB1dEVuYykge1xyXG4gICAgb3V0RGF0YSA9IHRoaXMuX3RvU3RyaW5nKG91dERhdGEsIG91dHB1dEVuYylcclxuICB9XHJcblxyXG4gIHJldHVybiBvdXREYXRhXHJcbn1cclxuXHJcbkNpcGhlckJhc2UucHJvdG90eXBlLnNldEF1dG9QYWRkaW5nID0gZnVuY3Rpb24gKCkge31cclxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuZ2V0QXV0aFRhZyA9IGZ1bmN0aW9uICgpIHtcclxuICB0aHJvdyBuZXcgRXJyb3IoJ3RyeWluZyB0byBnZXQgYXV0aCB0YWcgaW4gdW5zdXBwb3J0ZWQgc3RhdGUnKVxyXG59XHJcblxyXG5DaXBoZXJCYXNlLnByb3RvdHlwZS5zZXRBdXRoVGFnID0gZnVuY3Rpb24gKCkge1xyXG4gIHRocm93IG5ldyBFcnJvcigndHJ5aW5nIHRvIHNldCBhdXRoIHRhZyBpbiB1bnN1cHBvcnRlZCBzdGF0ZScpXHJcbn1cclxuXHJcbkNpcGhlckJhc2UucHJvdG90eXBlLnNldEFBRCA9IGZ1bmN0aW9uICgpIHtcclxuICB0aHJvdyBuZXcgRXJyb3IoJ3RyeWluZyB0byBzZXQgYWFkIGluIHVuc3VwcG9ydGVkIHN0YXRlJylcclxufVxyXG5cclxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChkYXRhLCBfLCBuZXh0KSB7XHJcbiAgdmFyIGVyclxyXG4gIHRyeSB7XHJcbiAgICBpZiAodGhpcy5oYXNoTW9kZSkge1xyXG4gICAgICB0aGlzLl91cGRhdGUoZGF0YSlcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMucHVzaCh0aGlzLl91cGRhdGUoZGF0YSkpXHJcbiAgICB9XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgZXJyID0gZVxyXG4gIH0gZmluYWxseSB7XHJcbiAgICBuZXh0KGVycilcclxuICB9XHJcbn1cclxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuX2ZsdXNoID0gZnVuY3Rpb24gKGRvbmUpIHtcclxuICB2YXIgZXJyXHJcbiAgdHJ5IHtcclxuICAgIHRoaXMucHVzaCh0aGlzLl9fZmluYWwoKSlcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICBlcnIgPSBlXHJcbiAgfVxyXG5cclxuICBkb25lKGVycilcclxufVxyXG5DaXBoZXJCYXNlLnByb3RvdHlwZS5fZmluYWxPckRpZ2VzdCA9IGZ1bmN0aW9uIChvdXRwdXRFbmMpIHtcclxuICB2YXIgb3V0RGF0YSA9IHRoaXMuX19maW5hbCgpIHx8IEJ1ZmZlci5hbGxvYygwKVxyXG4gIGlmIChvdXRwdXRFbmMpIHtcclxuICAgIG91dERhdGEgPSB0aGlzLl90b1N0cmluZyhvdXREYXRhLCBvdXRwdXRFbmMsIHRydWUpXHJcbiAgfVxyXG4gIHJldHVybiBvdXREYXRhXHJcbn1cclxuXHJcbkNpcGhlckJhc2UucHJvdG90eXBlLl90b1N0cmluZyA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jLCBmaW4pIHtcclxuICBpZiAoIXRoaXMuX2RlY29kZXIpIHtcclxuICAgIHRoaXMuX2RlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpXHJcbiAgICB0aGlzLl9lbmNvZGluZyA9IGVuY1xyXG4gIH1cclxuXHJcbiAgaWYgKHRoaXMuX2VuY29kaW5nICE9PSBlbmMpIHRocm93IG5ldyBFcnJvcignY2FuXFwndCBzd2l0Y2ggZW5jb2RpbmdzJylcclxuXHJcbiAgdmFyIG91dCA9IHRoaXMuX2RlY29kZXIud3JpdGUodmFsdWUpXHJcbiAgaWYgKGZpbikge1xyXG4gICAgb3V0ICs9IHRoaXMuX2RlY29kZXIuZW5kKClcclxuICB9XHJcblxyXG4gIHJldHVybiBvdXRcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDaXBoZXJCYXNlXHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/cipher-base/index.js\n");

/***/ }),

/***/ "./node_modules/create-hash/browser.js":
/*!*********************************************!*\
  !*** ./node_modules/create-hash/browser.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\r\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\r\nvar MD5 = __webpack_require__(/*! md5.js */ \"./node_modules/md5.js/index.js\")\r\nvar RIPEMD160 = __webpack_require__(/*! ripemd160 */ \"./node_modules/ripemd160/index.js\")\r\nvar sha = __webpack_require__(/*! sha.js */ \"./node_modules/sha.js/index.js\")\r\nvar Base = __webpack_require__(/*! cipher-base */ \"./node_modules/cipher-base/index.js\")\r\n\r\nfunction Hash (hash) {\r\n  Base.call(this, 'digest')\r\n\r\n  this._hash = hash\r\n}\r\n\r\ninherits(Hash, Base)\r\n\r\nHash.prototype._update = function (data) {\r\n  this._hash.update(data)\r\n}\r\n\r\nHash.prototype._final = function () {\r\n  return this._hash.digest()\r\n}\r\n\r\nmodule.exports = function createHash (alg) {\r\n  alg = alg.toLowerCase()\r\n  if (alg === 'md5') return new MD5()\r\n  if (alg === 'rmd160' || alg === 'ripemd160') return new RIPEMD160()\r\n\r\n  return new Hash(sha(alg))\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3JlYXRlLWhhc2gvYnJvd3Nlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBWTtBQUNaLGVBQWUsbUJBQU8sQ0FBQyw2REFBVTtBQUNqQyxVQUFVLG1CQUFPLENBQUMsOENBQVE7QUFDMUIsZ0JBQWdCLG1CQUFPLENBQUMsb0RBQVc7QUFDbkMsVUFBVSxtQkFBTyxDQUFDLDhDQUFRO0FBQzFCLFdBQVcsbUJBQU8sQ0FBQyx3REFBYTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyZWF0ZS1oYXNoL2Jyb3dzZXIuanM/MDI3NiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcclxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxyXG52YXIgTUQ1ID0gcmVxdWlyZSgnbWQ1LmpzJylcclxudmFyIFJJUEVNRDE2MCA9IHJlcXVpcmUoJ3JpcGVtZDE2MCcpXHJcbnZhciBzaGEgPSByZXF1aXJlKCdzaGEuanMnKVxyXG52YXIgQmFzZSA9IHJlcXVpcmUoJ2NpcGhlci1iYXNlJylcclxuXHJcbmZ1bmN0aW9uIEhhc2ggKGhhc2gpIHtcclxuICBCYXNlLmNhbGwodGhpcywgJ2RpZ2VzdCcpXHJcblxyXG4gIHRoaXMuX2hhc2ggPSBoYXNoXHJcbn1cclxuXHJcbmluaGVyaXRzKEhhc2gsIEJhc2UpXHJcblxyXG5IYXNoLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICB0aGlzLl9oYXNoLnVwZGF0ZShkYXRhKVxyXG59XHJcblxyXG5IYXNoLnByb3RvdHlwZS5fZmluYWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIHRoaXMuX2hhc2guZGlnZXN0KClcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVIYXNoIChhbGcpIHtcclxuICBhbGcgPSBhbGcudG9Mb3dlckNhc2UoKVxyXG4gIGlmIChhbGcgPT09ICdtZDUnKSByZXR1cm4gbmV3IE1ENSgpXHJcbiAgaWYgKGFsZyA9PT0gJ3JtZDE2MCcgfHwgYWxnID09PSAncmlwZW1kMTYwJykgcmV0dXJuIG5ldyBSSVBFTUQxNjAoKVxyXG5cclxuICByZXR1cm4gbmV3IEhhc2goc2hhKGFsZykpXHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/create-hash/browser.js\n");

/***/ }),

/***/ "./node_modules/define-properties/index.js":
/*!*************************************************!*\
  !*** ./node_modules/define-properties/index.js ***!
  \*************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar keys = __webpack_require__(/*! object-keys */ \"./node_modules/object-keys/index.js\");\r\nvar hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';\r\n\r\nvar toStr = Object.prototype.toString;\r\nvar concat = Array.prototype.concat;\r\nvar origDefineProperty = Object.defineProperty;\r\n\r\nvar isFunction = function (fn) {\r\n\treturn typeof fn === 'function' && toStr.call(fn) === '[object Function]';\r\n};\r\n\r\nvar arePropertyDescriptorsSupported = function () {\r\n\tvar obj = {};\r\n\ttry {\r\n\t\torigDefineProperty(obj, 'x', { enumerable: false, value: obj });\r\n\t\t// eslint-disable-next-line no-unused-vars, no-restricted-syntax\r\n\t\tfor (var _ in obj) { // jscs:ignore disallowUnusedVariables\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\treturn obj.x === obj;\r\n\t} catch (e) { /* this is IE 8. */\r\n\t\treturn false;\r\n\t}\r\n};\r\nvar supportsDescriptors = origDefineProperty && arePropertyDescriptorsSupported();\r\n\r\nvar defineProperty = function (object, name, value, predicate) {\r\n\tif (name in object && (!isFunction(predicate) || !predicate())) {\r\n\t\treturn;\r\n\t}\r\n\tif (supportsDescriptors) {\r\n\t\torigDefineProperty(object, name, {\r\n\t\t\tconfigurable: true,\r\n\t\t\tenumerable: false,\r\n\t\t\tvalue: value,\r\n\t\t\twritable: true\r\n\t\t});\r\n\t} else {\r\n\t\tobject[name] = value;\r\n\t}\r\n};\r\n\r\nvar defineProperties = function (object, map) {\r\n\tvar predicates = arguments.length > 2 ? arguments[2] : {};\r\n\tvar props = keys(map);\r\n\tif (hasSymbols) {\r\n\t\tprops = concat.call(props, Object.getOwnPropertySymbols(map));\r\n\t}\r\n\tfor (var i = 0; i < props.length; i += 1) {\r\n\t\tdefineProperty(object, props[i], map[props[i]], predicates[props[i]]);\r\n\t}\r\n};\r\n\r\ndefineProperties.supportsDescriptors = !!supportsDescriptors;\r\n\r\nmodule.exports = defineProperties;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVmaW5lLXByb3BlcnRpZXMvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLFdBQVcsbUJBQU8sQ0FBQyx3REFBYTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywrQkFBK0I7QUFDaEU7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsR0FBRyxZQUFZO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2RlZmluZS1wcm9wZXJ0aWVzL2luZGV4LmpzP2ViZTIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGtleXMgPSByZXF1aXJlKCdvYmplY3Qta2V5cycpO1xyXG52YXIgaGFzU3ltYm9scyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbCgnZm9vJykgPT09ICdzeW1ib2wnO1xyXG5cclxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcclxudmFyIGNvbmNhdCA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQ7XHJcbnZhciBvcmlnRGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XHJcblxyXG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIChmbikge1xyXG5cdHJldHVybiB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgJiYgdG9TdHIuY2FsbChmbikgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XHJcbn07XHJcblxyXG52YXIgYXJlUHJvcGVydHlEZXNjcmlwdG9yc1N1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcclxuXHR2YXIgb2JqID0ge307XHJcblx0dHJ5IHtcclxuXHRcdG9yaWdEZWZpbmVQcm9wZXJ0eShvYmosICd4JywgeyBlbnVtZXJhYmxlOiBmYWxzZSwgdmFsdWU6IG9iaiB9KTtcclxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFycywgbm8tcmVzdHJpY3RlZC1zeW50YXhcclxuXHRcdGZvciAodmFyIF8gaW4gb2JqKSB7IC8vIGpzY3M6aWdub3JlIGRpc2FsbG93VW51c2VkVmFyaWFibGVzXHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBvYmoueCA9PT0gb2JqO1xyXG5cdH0gY2F0Y2ggKGUpIHsgLyogdGhpcyBpcyBJRSA4LiAqL1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxufTtcclxudmFyIHN1cHBvcnRzRGVzY3JpcHRvcnMgPSBvcmlnRGVmaW5lUHJvcGVydHkgJiYgYXJlUHJvcGVydHlEZXNjcmlwdG9yc1N1cHBvcnRlZCgpO1xyXG5cclxudmFyIGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSwgdmFsdWUsIHByZWRpY2F0ZSkge1xyXG5cdGlmIChuYW1lIGluIG9iamVjdCAmJiAoIWlzRnVuY3Rpb24ocHJlZGljYXRlKSB8fCAhcHJlZGljYXRlKCkpKSB7XHJcblx0XHRyZXR1cm47XHJcblx0fVxyXG5cdGlmIChzdXBwb3J0c0Rlc2NyaXB0b3JzKSB7XHJcblx0XHRvcmlnRGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCB7XHJcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuXHRcdFx0ZW51bWVyYWJsZTogZmFsc2UsXHJcblx0XHRcdHZhbHVlOiB2YWx1ZSxcclxuXHRcdFx0d3JpdGFibGU6IHRydWVcclxuXHRcdH0pO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRvYmplY3RbbmFtZV0gPSB2YWx1ZTtcclxuXHR9XHJcbn07XHJcblxyXG52YXIgZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIChvYmplY3QsIG1hcCkge1xyXG5cdHZhciBwcmVkaWNhdGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB7fTtcclxuXHR2YXIgcHJvcHMgPSBrZXlzKG1hcCk7XHJcblx0aWYgKGhhc1N5bWJvbHMpIHtcclxuXHRcdHByb3BzID0gY29uY2F0LmNhbGwocHJvcHMsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMobWFwKSk7XHJcblx0fVxyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpICs9IDEpIHtcclxuXHRcdGRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcHNbaV0sIG1hcFtwcm9wc1tpXV0sIHByZWRpY2F0ZXNbcHJvcHNbaV1dKTtcclxuXHR9XHJcbn07XHJcblxyXG5kZWZpbmVQcm9wZXJ0aWVzLnN1cHBvcnRzRGVzY3JpcHRvcnMgPSAhIXN1cHBvcnRzRGVzY3JpcHRvcnM7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmluZVByb3BlcnRpZXM7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/define-properties/index.js\n");

/***/ }),

/***/ "./node_modules/detect-node/browser.js":
/*!*********************************************!*\
  !*** ./node_modules/detect-node/browser.js ***!
  \*********************************************/
/***/ (function(module) {

eval("module.exports = false;\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGV0ZWN0LW5vZGUvYnJvd3Nlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9kZXRlY3Qtbm9kZS9icm93c2VyLmpzPzE1MGEiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmYWxzZTtcclxuXHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/detect-node/browser.js\n");

/***/ }),

/***/ "./node_modules/end-of-stream/index.js":
/*!*********************************************!*\
  !*** ./node_modules/end-of-stream/index.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/process/browser.js\");\nvar once = __webpack_require__(/*! once */ \"./node_modules/once/once.js\");\r\n\r\nvar noop = function() {};\r\n\r\nvar isRequest = function(stream) {\r\n\treturn stream.setHeader && typeof stream.abort === 'function';\r\n};\r\n\r\nvar isChildProcess = function(stream) {\r\n\treturn stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3\r\n};\r\n\r\nvar eos = function(stream, opts, callback) {\r\n\tif (typeof opts === 'function') return eos(stream, null, opts);\r\n\tif (!opts) opts = {};\r\n\r\n\tcallback = once(callback || noop);\r\n\r\n\tvar ws = stream._writableState;\r\n\tvar rs = stream._readableState;\r\n\tvar readable = opts.readable || (opts.readable !== false && stream.readable);\r\n\tvar writable = opts.writable || (opts.writable !== false && stream.writable);\r\n\tvar cancelled = false;\r\n\r\n\tvar onlegacyfinish = function() {\r\n\t\tif (!stream.writable) onfinish();\r\n\t};\r\n\r\n\tvar onfinish = function() {\r\n\t\twritable = false;\r\n\t\tif (!readable) callback.call(stream);\r\n\t};\r\n\r\n\tvar onend = function() {\r\n\t\treadable = false;\r\n\t\tif (!writable) callback.call(stream);\r\n\t};\r\n\r\n\tvar onexit = function(exitCode) {\r\n\t\tcallback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);\r\n\t};\r\n\r\n\tvar onerror = function(err) {\r\n\t\tcallback.call(stream, err);\r\n\t};\r\n\r\n\tvar onclose = function() {\r\n\t\tprocess.nextTick(onclosenexttick);\r\n\t};\r\n\r\n\tvar onclosenexttick = function() {\r\n\t\tif (cancelled) return;\r\n\t\tif (readable && !(rs && (rs.ended && !rs.destroyed))) return callback.call(stream, new Error('premature close'));\r\n\t\tif (writable && !(ws && (ws.ended && !ws.destroyed))) return callback.call(stream, new Error('premature close'));\r\n\t};\r\n\r\n\tvar onrequest = function() {\r\n\t\tstream.req.on('finish', onfinish);\r\n\t};\r\n\r\n\tif (isRequest(stream)) {\r\n\t\tstream.on('complete', onfinish);\r\n\t\tstream.on('abort', onclose);\r\n\t\tif (stream.req) onrequest();\r\n\t\telse stream.on('request', onrequest);\r\n\t} else if (writable && !ws) { // legacy streams\r\n\t\tstream.on('end', onlegacyfinish);\r\n\t\tstream.on('close', onlegacyfinish);\r\n\t}\r\n\r\n\tif (isChildProcess(stream)) stream.on('exit', onexit);\r\n\r\n\tstream.on('end', onend);\r\n\tstream.on('finish', onfinish);\r\n\tif (opts.error !== false) stream.on('error', onerror);\r\n\tstream.on('close', onclose);\r\n\r\n\treturn function() {\r\n\t\tcancelled = true;\r\n\t\tstream.removeListener('complete', onfinish);\r\n\t\tstream.removeListener('abort', onclose);\r\n\t\tstream.removeListener('request', onrequest);\r\n\t\tif (stream.req) stream.req.removeListener('finish', onfinish);\r\n\t\tstream.removeListener('end', onlegacyfinish);\r\n\t\tstream.removeListener('close', onlegacyfinish);\r\n\t\tstream.removeListener('finish', onfinish);\r\n\t\tstream.removeListener('exit', onexit);\r\n\t\tstream.removeListener('end', onend);\r\n\t\tstream.removeListener('error', onerror);\r\n\t\tstream.removeListener('close', onclose);\r\n\t};\r\n};\r\n\r\nmodule.exports = eos;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZW5kLW9mLXN0cmVhbS9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsV0FBVyxtQkFBTyxDQUFDLHlDQUFNO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxPQUFPO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsNEJBQTRCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9lbmQtb2Ytc3RyZWFtL2luZGV4LmpzP2M0MGQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIG9uY2UgPSByZXF1aXJlKCdvbmNlJyk7XHJcblxyXG52YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XHJcblxyXG52YXIgaXNSZXF1ZXN0ID0gZnVuY3Rpb24oc3RyZWFtKSB7XHJcblx0cmV0dXJuIHN0cmVhbS5zZXRIZWFkZXIgJiYgdHlwZW9mIHN0cmVhbS5hYm9ydCA9PT0gJ2Z1bmN0aW9uJztcclxufTtcclxuXHJcbnZhciBpc0NoaWxkUHJvY2VzcyA9IGZ1bmN0aW9uKHN0cmVhbSkge1xyXG5cdHJldHVybiBzdHJlYW0uc3RkaW8gJiYgQXJyYXkuaXNBcnJheShzdHJlYW0uc3RkaW8pICYmIHN0cmVhbS5zdGRpby5sZW5ndGggPT09IDNcclxufTtcclxuXHJcbnZhciBlb3MgPSBmdW5jdGlvbihzdHJlYW0sIG9wdHMsIGNhbGxiYWNrKSB7XHJcblx0aWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZW9zKHN0cmVhbSwgbnVsbCwgb3B0cyk7XHJcblx0aWYgKCFvcHRzKSBvcHRzID0ge307XHJcblxyXG5cdGNhbGxiYWNrID0gb25jZShjYWxsYmFjayB8fCBub29wKTtcclxuXHJcblx0dmFyIHdzID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xyXG5cdHZhciBycyA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcclxuXHR2YXIgcmVhZGFibGUgPSBvcHRzLnJlYWRhYmxlIHx8IChvcHRzLnJlYWRhYmxlICE9PSBmYWxzZSAmJiBzdHJlYW0ucmVhZGFibGUpO1xyXG5cdHZhciB3cml0YWJsZSA9IG9wdHMud3JpdGFibGUgfHwgKG9wdHMud3JpdGFibGUgIT09IGZhbHNlICYmIHN0cmVhbS53cml0YWJsZSk7XHJcblx0dmFyIGNhbmNlbGxlZCA9IGZhbHNlO1xyXG5cclxuXHR2YXIgb25sZWdhY3lmaW5pc2ggPSBmdW5jdGlvbigpIHtcclxuXHRcdGlmICghc3RyZWFtLndyaXRhYmxlKSBvbmZpbmlzaCgpO1xyXG5cdH07XHJcblxyXG5cdHZhciBvbmZpbmlzaCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0d3JpdGFibGUgPSBmYWxzZTtcclxuXHRcdGlmICghcmVhZGFibGUpIGNhbGxiYWNrLmNhbGwoc3RyZWFtKTtcclxuXHR9O1xyXG5cclxuXHR2YXIgb25lbmQgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJlYWRhYmxlID0gZmFsc2U7XHJcblx0XHRpZiAoIXdyaXRhYmxlKSBjYWxsYmFjay5jYWxsKHN0cmVhbSk7XHJcblx0fTtcclxuXHJcblx0dmFyIG9uZXhpdCA9IGZ1bmN0aW9uKGV4aXRDb2RlKSB7XHJcblx0XHRjYWxsYmFjay5jYWxsKHN0cmVhbSwgZXhpdENvZGUgPyBuZXcgRXJyb3IoJ2V4aXRlZCB3aXRoIGVycm9yIGNvZGU6ICcgKyBleGl0Q29kZSkgOiBudWxsKTtcclxuXHR9O1xyXG5cclxuXHR2YXIgb25lcnJvciA9IGZ1bmN0aW9uKGVycikge1xyXG5cdFx0Y2FsbGJhY2suY2FsbChzdHJlYW0sIGVycik7XHJcblx0fTtcclxuXHJcblx0dmFyIG9uY2xvc2UgPSBmdW5jdGlvbigpIHtcclxuXHRcdHByb2Nlc3MubmV4dFRpY2sob25jbG9zZW5leHR0aWNrKTtcclxuXHR9O1xyXG5cclxuXHR2YXIgb25jbG9zZW5leHR0aWNrID0gZnVuY3Rpb24oKSB7XHJcblx0XHRpZiAoY2FuY2VsbGVkKSByZXR1cm47XHJcblx0XHRpZiAocmVhZGFibGUgJiYgIShycyAmJiAocnMuZW5kZWQgJiYgIXJzLmRlc3Ryb3llZCkpKSByZXR1cm4gY2FsbGJhY2suY2FsbChzdHJlYW0sIG5ldyBFcnJvcigncHJlbWF0dXJlIGNsb3NlJykpO1xyXG5cdFx0aWYgKHdyaXRhYmxlICYmICEod3MgJiYgKHdzLmVuZGVkICYmICF3cy5kZXN0cm95ZWQpKSkgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc3RyZWFtLCBuZXcgRXJyb3IoJ3ByZW1hdHVyZSBjbG9zZScpKTtcclxuXHR9O1xyXG5cclxuXHR2YXIgb25yZXF1ZXN0ID0gZnVuY3Rpb24oKSB7XHJcblx0XHRzdHJlYW0ucmVxLm9uKCdmaW5pc2gnLCBvbmZpbmlzaCk7XHJcblx0fTtcclxuXHJcblx0aWYgKGlzUmVxdWVzdChzdHJlYW0pKSB7XHJcblx0XHRzdHJlYW0ub24oJ2NvbXBsZXRlJywgb25maW5pc2gpO1xyXG5cdFx0c3RyZWFtLm9uKCdhYm9ydCcsIG9uY2xvc2UpO1xyXG5cdFx0aWYgKHN0cmVhbS5yZXEpIG9ucmVxdWVzdCgpO1xyXG5cdFx0ZWxzZSBzdHJlYW0ub24oJ3JlcXVlc3QnLCBvbnJlcXVlc3QpO1xyXG5cdH0gZWxzZSBpZiAod3JpdGFibGUgJiYgIXdzKSB7IC8vIGxlZ2FjeSBzdHJlYW1zXHJcblx0XHRzdHJlYW0ub24oJ2VuZCcsIG9ubGVnYWN5ZmluaXNoKTtcclxuXHRcdHN0cmVhbS5vbignY2xvc2UnLCBvbmxlZ2FjeWZpbmlzaCk7XHJcblx0fVxyXG5cclxuXHRpZiAoaXNDaGlsZFByb2Nlc3Moc3RyZWFtKSkgc3RyZWFtLm9uKCdleGl0Jywgb25leGl0KTtcclxuXHJcblx0c3RyZWFtLm9uKCdlbmQnLCBvbmVuZCk7XHJcblx0c3RyZWFtLm9uKCdmaW5pc2gnLCBvbmZpbmlzaCk7XHJcblx0aWYgKG9wdHMuZXJyb3IgIT09IGZhbHNlKSBzdHJlYW0ub24oJ2Vycm9yJywgb25lcnJvcik7XHJcblx0c3RyZWFtLm9uKCdjbG9zZScsIG9uY2xvc2UpO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24oKSB7XHJcblx0XHRjYW5jZWxsZWQgPSB0cnVlO1xyXG5cdFx0c3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjb21wbGV0ZScsIG9uZmluaXNoKTtcclxuXHRcdHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignYWJvcnQnLCBvbmNsb3NlKTtcclxuXHRcdHN0cmVhbS5yZW1vdmVMaXN0ZW5lcigncmVxdWVzdCcsIG9ucmVxdWVzdCk7XHJcblx0XHRpZiAoc3RyZWFtLnJlcSkgc3RyZWFtLnJlcS5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xyXG5cdFx0c3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmxlZ2FjeWZpbmlzaCk7XHJcblx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25sZWdhY3lmaW5pc2gpO1xyXG5cdFx0c3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XHJcblx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2V4aXQnLCBvbmV4aXQpO1xyXG5cdFx0c3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XHJcblx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XHJcblx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XHJcblx0fTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZW9zO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/end-of-stream/index.js\n");

/***/ }),

/***/ "./node_modules/es6-object-assign/index.js":
/*!*************************************************!*\
  !*** ./node_modules/es6-object-assign/index.js ***!
  \*************************************************/
/***/ (function(module) {

"use strict";
eval("/**\r\n * Code refactored from Mozilla Developer Network:\r\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\r\n */\r\n\r\n\r\n\r\nfunction assign(target, firstSource) {\r\n  if (target === undefined || target === null) {\r\n    throw new TypeError('Cannot convert first argument to object');\r\n  }\r\n\r\n  var to = Object(target);\r\n  for (var i = 1; i < arguments.length; i++) {\r\n    var nextSource = arguments[i];\r\n    if (nextSource === undefined || nextSource === null) {\r\n      continue;\r\n    }\r\n\r\n    var keysArray = Object.keys(Object(nextSource));\r\n    for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {\r\n      var nextKey = keysArray[nextIndex];\r\n      var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\r\n      if (desc !== undefined && desc.enumerable) {\r\n        to[nextKey] = nextSource[nextKey];\r\n      }\r\n    }\r\n  }\r\n  return to;\r\n}\r\n\r\nfunction polyfill() {\r\n  if (!Object.assign) {\r\n    Object.defineProperty(Object, 'assign', {\r\n      enumerable: false,\r\n      configurable: true,\r\n      writable: true,\r\n      value: assign\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  assign: assign,\r\n  polyfill: polyfill\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXM2LW9iamVjdC1hc3NpZ24vaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxpQkFBaUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZXM2LW9iamVjdC1hc3NpZ24vaW5kZXguanM/MmExNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQ29kZSByZWZhY3RvcmVkIGZyb20gTW96aWxsYSBEZXZlbG9wZXIgTmV0d29yazpcclxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2Fzc2lnblxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbmZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIGZpcnN0U291cmNlKSB7XHJcbiAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkIHx8IHRhcmdldCA9PT0gbnVsbCkge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgZmlyc3QgYXJndW1lbnQgdG8gb2JqZWN0Jyk7XHJcbiAgfVxyXG5cclxuICB2YXIgdG8gPSBPYmplY3QodGFyZ2V0KTtcclxuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgdmFyIG5leHRTb3VyY2UgPSBhcmd1bWVudHNbaV07XHJcbiAgICBpZiAobmV4dFNvdXJjZSA9PT0gdW5kZWZpbmVkIHx8IG5leHRTb3VyY2UgPT09IG51bGwpIHtcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGtleXNBcnJheSA9IE9iamVjdC5rZXlzKE9iamVjdChuZXh0U291cmNlKSk7XHJcbiAgICBmb3IgKHZhciBuZXh0SW5kZXggPSAwLCBsZW4gPSBrZXlzQXJyYXkubGVuZ3RoOyBuZXh0SW5kZXggPCBsZW47IG5leHRJbmRleCsrKSB7XHJcbiAgICAgIHZhciBuZXh0S2V5ID0ga2V5c0FycmF5W25leHRJbmRleF07XHJcbiAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuZXh0U291cmNlLCBuZXh0S2V5KTtcclxuICAgICAgaWYgKGRlc2MgIT09IHVuZGVmaW5lZCAmJiBkZXNjLmVudW1lcmFibGUpIHtcclxuICAgICAgICB0b1tuZXh0S2V5XSA9IG5leHRTb3VyY2VbbmV4dEtleV07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHRvO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwb2x5ZmlsbCgpIHtcclxuICBpZiAoIU9iamVjdC5hc3NpZ24pIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3QsICdhc3NpZ24nLCB7XHJcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICB2YWx1ZTogYXNzaWduXHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gIGFzc2lnbjogYXNzaWduLFxyXG4gIHBvbHlmaWxsOiBwb2x5ZmlsbFxyXG59O1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/es6-object-assign/index.js\n");

/***/ }),

/***/ "./node_modules/eth-rpc-errors/dist/classes.js":
/*!*****************************************************!*\
  !*** ./node_modules/eth-rpc-errors/dist/classes.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.EthereumProviderError = exports.EthereumRpcError = void 0;\r\nconst fast_safe_stringify_1 = __webpack_require__(/*! fast-safe-stringify */ \"./node_modules/fast-safe-stringify/index.js\");\r\n/**\r\n * Error subclass implementing JSON RPC 2.0 errors and Ethereum RPC errors\r\n * per EIP-1474.\r\n * Permits any integer error code.\r\n */\r\nclass EthereumRpcError extends Error {\r\n    constructor(code, message, data) {\r\n        if (!Number.isInteger(code)) {\r\n            throw new Error('\"code\" must be an integer.');\r\n        }\r\n        if (!message || typeof message !== 'string') {\r\n            throw new Error('\"message\" must be a nonempty string.');\r\n        }\r\n        super(message);\r\n        this.code = code;\r\n        if (data !== undefined) {\r\n            this.data = data;\r\n        }\r\n    }\r\n    /**\r\n     * Returns a plain object with all public class properties.\r\n     */\r\n    serialize() {\r\n        const serialized = {\r\n            code: this.code,\r\n            message: this.message,\r\n        };\r\n        if (this.data !== undefined) {\r\n            serialized.data = this.data;\r\n        }\r\n        if (this.stack) {\r\n            serialized.stack = this.stack;\r\n        }\r\n        return serialized;\r\n    }\r\n    /**\r\n     * Return a string representation of the serialized error, omitting\r\n     * any circular references.\r\n     */\r\n    toString() {\r\n        return fast_safe_stringify_1.default(this.serialize(), stringifyReplacer, 2);\r\n    }\r\n}\r\nexports.EthereumRpcError = EthereumRpcError;\r\n/**\r\n * Error subclass implementing Ethereum Provider errors per EIP-1193.\r\n * Permits integer error codes in the [ 1000 <= 4999 ] range.\r\n */\r\nclass EthereumProviderError extends EthereumRpcError {\r\n    /**\r\n     * Create an Ethereum Provider JSON-RPC error.\r\n     * `code` must be an integer in the 1000 <= 4999 range.\r\n     */\r\n    constructor(code, message, data) {\r\n        if (!isValidEthProviderCode(code)) {\r\n            throw new Error('\"code\" must be an integer such that: 1000 <= code <= 4999');\r\n        }\r\n        super(code, message, data);\r\n    }\r\n}\r\nexports.EthereumProviderError = EthereumProviderError;\r\n// Internal\r\nfunction isValidEthProviderCode(code) {\r\n    return Number.isInteger(code) && code >= 1000 && code <= 4999;\r\n}\r\nfunction stringifyReplacer(_, value) {\r\n    if (value === '[Circular]') {\r\n        return undefined;\r\n    }\r\n    return value;\r\n}\r\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xhc3Nlcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9jbGFzc2VzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLDZEQUFnRDtBQVNoRDs7OztHQUlHO0FBQ0gsTUFBYSxnQkFBb0IsU0FBUSxLQUFLO0lBTTVDLFlBQVksSUFBWSxFQUFFLE9BQWUsRUFBRSxJQUFRO1FBRWpELElBQUksQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQzNCLE1BQU0sSUFBSSxLQUFLLENBQ2IsNEJBQTRCLENBQzdCLENBQUM7U0FDSDtRQUNELElBQUksQ0FBQyxPQUFPLElBQUksT0FBTyxPQUFPLEtBQUssUUFBUSxFQUFFO1lBQzNDLE1BQU0sSUFBSSxLQUFLLENBQ2Isc0NBQXNDLENBQ3ZDLENBQUM7U0FDSDtRQUVELEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUNmLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2pCLElBQUksSUFBSSxLQUFLLFNBQVMsRUFBRTtZQUN0QixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztTQUNsQjtJQUNILENBQUM7SUFFRDs7T0FFRztJQUNILFNBQVM7UUFDUCxNQUFNLFVBQVUsR0FBK0I7WUFDN0MsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJO1lBQ2YsT0FBTyxFQUFFLElBQUksQ0FBQyxPQUFPO1NBQ3RCLENBQUM7UUFDRixJQUFJLElBQUksQ0FBQyxJQUFJLEtBQUssU0FBUyxFQUFFO1lBQzNCLFVBQVUsQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQztTQUM3QjtRQUNELElBQUksSUFBSSxDQUFDLEtBQUssRUFBRTtZQUNkLFVBQVUsQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQztTQUMvQjtRQUNELE9BQU8sVUFBVSxDQUFDO0lBQ3BCLENBQUM7SUFFRDs7O09BR0c7SUFDSCxRQUFRO1FBQ04sT0FBTyw2QkFBYSxDQUNsQixJQUFJLENBQUMsU0FBUyxFQUFFLEVBQ2hCLGlCQUFpQixFQUNqQixDQUFDLENBQ0YsQ0FBQztJQUNKLENBQUM7Q0FDRjtBQXRERCw0Q0FzREM7QUFFRDs7O0dBR0c7QUFDSCxNQUFhLHFCQUF5QixTQUFRLGdCQUFtQjtJQUUvRDs7O09BR0c7SUFDSCxZQUFZLElBQVksRUFBRSxPQUFlLEVBQUUsSUFBUTtRQUVqRCxJQUFJLENBQUMsc0JBQXNCLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDakMsTUFBTSxJQUFJLEtBQUssQ0FDYiwyREFBMkQsQ0FDNUQsQ0FBQztTQUNIO1FBRUQsS0FBSyxDQUFDLElBQUksRUFBRSxPQUFPLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDN0IsQ0FBQztDQUNGO0FBaEJELHNEQWdCQztBQUVELFdBQVc7QUFFWCxTQUFTLHNCQUFzQixDQUFDLElBQVk7SUFDMUMsT0FBTyxNQUFNLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksQ0FBQztBQUNoRSxDQUFDO0FBRUQsU0FBUyxpQkFBaUIsQ0FBQyxDQUFVLEVBQUUsS0FBYztJQUNuRCxJQUFJLEtBQUssS0FBSyxZQUFZLEVBQUU7UUFDMUIsT0FBTyxTQUFTLENBQUM7S0FDbEI7SUFDRCxPQUFPLEtBQUssQ0FBQztBQUNmLENBQUMifQ==//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXRoLXJwYy1lcnJvcnMvZGlzdC9jbGFzc2VzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QixHQUFHLHdCQUF3QjtBQUN4RCw4QkFBOEIsbUJBQU8sQ0FBQyx3RUFBcUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2V0aC1ycGMtZXJyb3JzL2Rpc3QvY2xhc3Nlcy5qcz9mNWIzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuRXRoZXJldW1Qcm92aWRlckVycm9yID0gZXhwb3J0cy5FdGhlcmV1bVJwY0Vycm9yID0gdm9pZCAwO1xyXG5jb25zdCBmYXN0X3NhZmVfc3RyaW5naWZ5XzEgPSByZXF1aXJlKFwiZmFzdC1zYWZlLXN0cmluZ2lmeVwiKTtcclxuLyoqXHJcbiAqIEVycm9yIHN1YmNsYXNzIGltcGxlbWVudGluZyBKU09OIFJQQyAyLjAgZXJyb3JzIGFuZCBFdGhlcmV1bSBSUEMgZXJyb3JzXHJcbiAqIHBlciBFSVAtMTQ3NC5cclxuICogUGVybWl0cyBhbnkgaW50ZWdlciBlcnJvciBjb2RlLlxyXG4gKi9cclxuY2xhc3MgRXRoZXJldW1ScGNFcnJvciBleHRlbmRzIEVycm9yIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvZGUsIG1lc3NhZ2UsIGRhdGEpIHtcclxuICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoY29kZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImNvZGVcIiBtdXN0IGJlIGFuIGludGVnZXIuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbWVzc2FnZSB8fCB0eXBlb2YgbWVzc2FnZSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIm1lc3NhZ2VcIiBtdXN0IGJlIGEgbm9uZW1wdHkgc3RyaW5nLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdXBlcihtZXNzYWdlKTtcclxuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xyXG4gICAgICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBwbGFpbiBvYmplY3Qgd2l0aCBhbGwgcHVibGljIGNsYXNzIHByb3BlcnRpZXMuXHJcbiAgICAgKi9cclxuICAgIHNlcmlhbGl6ZSgpIHtcclxuICAgICAgICBjb25zdCBzZXJpYWxpemVkID0ge1xyXG4gICAgICAgICAgICBjb2RlOiB0aGlzLmNvZGUsXHJcbiAgICAgICAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICh0aGlzLmRhdGEgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBzZXJpYWxpemVkLmRhdGEgPSB0aGlzLmRhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnN0YWNrKSB7XHJcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQuc3RhY2sgPSB0aGlzLnN0YWNrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2VyaWFsaXplZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzZXJpYWxpemVkIGVycm9yLCBvbWl0dGluZ1xyXG4gICAgICogYW55IGNpcmN1bGFyIHJlZmVyZW5jZXMuXHJcbiAgICAgKi9cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiBmYXN0X3NhZmVfc3RyaW5naWZ5XzEuZGVmYXVsdCh0aGlzLnNlcmlhbGl6ZSgpLCBzdHJpbmdpZnlSZXBsYWNlciwgMik7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5FdGhlcmV1bVJwY0Vycm9yID0gRXRoZXJldW1ScGNFcnJvcjtcclxuLyoqXHJcbiAqIEVycm9yIHN1YmNsYXNzIGltcGxlbWVudGluZyBFdGhlcmV1bSBQcm92aWRlciBlcnJvcnMgcGVyIEVJUC0xMTkzLlxyXG4gKiBQZXJtaXRzIGludGVnZXIgZXJyb3IgY29kZXMgaW4gdGhlIFsgMTAwMCA8PSA0OTk5IF0gcmFuZ2UuXHJcbiAqL1xyXG5jbGFzcyBFdGhlcmV1bVByb3ZpZGVyRXJyb3IgZXh0ZW5kcyBFdGhlcmV1bVJwY0Vycm9yIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGFuIEV0aGVyZXVtIFByb3ZpZGVyIEpTT04tUlBDIGVycm9yLlxyXG4gICAgICogYGNvZGVgIG11c3QgYmUgYW4gaW50ZWdlciBpbiB0aGUgMTAwMCA8PSA0OTk5IHJhbmdlLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihjb2RlLCBtZXNzYWdlLCBkYXRhKSB7XHJcbiAgICAgICAgaWYgKCFpc1ZhbGlkRXRoUHJvdmlkZXJDb2RlKGNvZGUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignXCJjb2RlXCIgbXVzdCBiZSBhbiBpbnRlZ2VyIHN1Y2ggdGhhdDogMTAwMCA8PSBjb2RlIDw9IDQ5OTknKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3VwZXIoY29kZSwgbWVzc2FnZSwgZGF0YSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5FdGhlcmV1bVByb3ZpZGVyRXJyb3IgPSBFdGhlcmV1bVByb3ZpZGVyRXJyb3I7XHJcbi8vIEludGVybmFsXHJcbmZ1bmN0aW9uIGlzVmFsaWRFdGhQcm92aWRlckNvZGUoY29kZSkge1xyXG4gICAgcmV0dXJuIE51bWJlci5pc0ludGVnZXIoY29kZSkgJiYgY29kZSA+PSAxMDAwICYmIGNvZGUgPD0gNDk5OTtcclxufVxyXG5mdW5jdGlvbiBzdHJpbmdpZnlSZXBsYWNlcihfLCB2YWx1ZSkge1xyXG4gICAgaWYgKHZhbHVlID09PSAnW0NpcmN1bGFyXScpIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVkyeGhjM05sY3k1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJaTR1TDNOeVl5OWpiR0Z6YzJWekxuUnpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdPenRCUVVGQkxEWkVRVUZuUkR0QlFWTm9SRHM3T3p0SFFVbEhPMEZCUTBnc1RVRkJZU3huUWtGQmIwSXNVMEZCVVN4TFFVRkxPMGxCVFRWRExGbEJRVmtzU1VGQldTeEZRVUZGTEU5QlFXVXNSVUZCUlN4SlFVRlJPMUZCUldwRUxFbEJRVWtzUTBGQlF5eE5RVUZOTEVOQlFVTXNVMEZCVXl4RFFVRkRMRWxCUVVrc1EwRkJReXhGUVVGRk8xbEJRek5DTEUxQlFVMHNTVUZCU1N4TFFVRkxMRU5CUTJJc05FSkJRVFJDTEVOQlF6ZENMRU5CUVVNN1UwRkRTRHRSUVVORUxFbEJRVWtzUTBGQlF5eFBRVUZQTEVsQlFVa3NUMEZCVHl4UFFVRlBMRXRCUVVzc1VVRkJVU3hGUVVGRk8xbEJRek5ETEUxQlFVMHNTVUZCU1N4TFFVRkxMRU5CUTJJc2MwTkJRWE5ETEVOQlEzWkRMRU5CUVVNN1UwRkRTRHRSUVVWRUxFdEJRVXNzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXp0UlFVTm1MRWxCUVVrc1EwRkJReXhKUVVGSkxFZEJRVWNzU1VGQlNTeERRVUZETzFGQlEycENMRWxCUVVrc1NVRkJTU3hMUVVGTExGTkJRVk1zUlVGQlJUdFpRVU4wUWl4SlFVRkpMRU5CUVVNc1NVRkJTU3hIUVVGSExFbEJRVWtzUTBGQlF6dFRRVU5zUWp0SlFVTklMRU5CUVVNN1NVRkZSRHM3VDBGRlJ6dEpRVU5JTEZOQlFWTTdVVUZEVUN4TlFVRk5MRlZCUVZVc1IwRkJLMEk3V1VGRE4wTXNTVUZCU1N4RlFVRkZMRWxCUVVrc1EwRkJReXhKUVVGSk8xbEJRMllzVDBGQlR5eEZRVUZGTEVsQlFVa3NRMEZCUXl4UFFVRlBPMU5CUTNSQ0xFTkJRVU03VVVGRFJpeEpRVUZKTEVsQlFVa3NRMEZCUXl4SlFVRkpMRXRCUVVzc1UwRkJVeXhGUVVGRk8xbEJRek5DTEZWQlFWVXNRMEZCUXl4SlFVRkpMRWRCUVVjc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF6dFRRVU0zUWp0UlFVTkVMRWxCUVVrc1NVRkJTU3hEUVVGRExFdEJRVXNzUlVGQlJUdFpRVU5rTEZWQlFWVXNRMEZCUXl4TFFVRkxMRWRCUVVjc1NVRkJTU3hEUVVGRExFdEJRVXNzUTBGQlF6dFRRVU12UWp0UlFVTkVMRTlCUVU4c1ZVRkJWU3hEUVVGRE8wbEJRM0JDTEVOQlFVTTdTVUZGUkRzN08wOUJSMGM3U1VGRFNDeFJRVUZSTzFGQlEwNHNUMEZCVHl3MlFrRkJZU3hEUVVOc1FpeEpRVUZKTEVOQlFVTXNVMEZCVXl4RlFVRkZMRVZCUTJoQ0xHbENRVUZwUWl4RlFVTnFRaXhEUVVGRExFTkJRMFlzUTBGQlF6dEpRVU5LTEVOQlFVTTdRMEZEUmp0QlFYUkVSQ3cwUTBGelJFTTdRVUZGUkRzN08wZEJSMGM3UVVGRFNDeE5RVUZoTEhGQ1FVRjVRaXhUUVVGUkxHZENRVUZ0UWp0SlFVVXZSRHM3TzA5QlIwYzdTVUZEU0N4WlFVRlpMRWxCUVZrc1JVRkJSU3hQUVVGbExFVkJRVVVzU1VGQlVUdFJRVVZxUkN4SlFVRkpMRU5CUVVNc2MwSkJRWE5DTEVOQlFVTXNTVUZCU1N4RFFVRkRMRVZCUVVVN1dVRkRha01zVFVGQlRTeEpRVUZKTEV0QlFVc3NRMEZEWWl3eVJFRkJNa1FzUTBGRE5VUXNRMEZCUXp0VFFVTklPMUZCUlVRc1MwRkJTeXhEUVVGRExFbEJRVWtzUlVGQlJTeFBRVUZQTEVWQlFVVXNTVUZCU1N4RFFVRkRMRU5CUVVNN1NVRkROMElzUTBGQlF6dERRVU5HTzBGQmFFSkVMSE5FUVdkQ1F6dEJRVVZFTEZkQlFWYzdRVUZGV0N4VFFVRlRMSE5DUVVGelFpeERRVUZETEVsQlFWazdTVUZETVVNc1QwRkJUeXhOUVVGTkxFTkJRVU1zVTBGQlV5eERRVUZETEVsQlFVa3NRMEZCUXl4SlFVRkpMRWxCUVVrc1NVRkJTU3hKUVVGSkxFbEJRVWtzU1VGQlNTeEpRVUZKTEVsQlFVa3NRMEZCUXp0QlFVTm9SU3hEUVVGRE8wRkJSVVFzVTBGQlV5eHBRa0ZCYVVJc1EwRkJReXhEUVVGVkxFVkJRVVVzUzBGQll6dEpRVU51UkN4SlFVRkpMRXRCUVVzc1MwRkJTeXhaUVVGWkxFVkJRVVU3VVVGRE1VSXNUMEZCVHl4VFFVRlRMRU5CUVVNN1MwRkRiRUk3U1VGRFJDeFBRVUZQTEV0QlFVc3NRMEZCUXp0QlFVTm1MRU5CUVVNaWZRPT0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/eth-rpc-errors/dist/classes.js\n");

/***/ }),

/***/ "./node_modules/eth-rpc-errors/dist/error-constants.js":
/*!*************************************************************!*\
  !*** ./node_modules/eth-rpc-errors/dist/error-constants.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.errorValues = exports.errorCodes = void 0;\r\nexports.errorCodes = {\r\n    rpc: {\r\n        invalidInput: -32000,\r\n        resourceNotFound: -32001,\r\n        resourceUnavailable: -32002,\r\n        transactionRejected: -32003,\r\n        methodNotSupported: -32004,\r\n        limitExceeded: -32005,\r\n        parse: -32700,\r\n        invalidRequest: -32600,\r\n        methodNotFound: -32601,\r\n        invalidParams: -32602,\r\n        internal: -32603,\r\n    },\r\n    provider: {\r\n        userRejectedRequest: 4001,\r\n        unauthorized: 4100,\r\n        unsupportedMethod: 4200,\r\n        disconnected: 4900,\r\n        chainDisconnected: 4901,\r\n    },\r\n};\r\nexports.errorValues = {\r\n    '-32700': {\r\n        standard: 'JSON RPC 2.0',\r\n        message: 'Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.',\r\n    },\r\n    '-32600': {\r\n        standard: 'JSON RPC 2.0',\r\n        message: 'The JSON sent is not a valid Request object.',\r\n    },\r\n    '-32601': {\r\n        standard: 'JSON RPC 2.0',\r\n        message: 'The method does not exist / is not available.',\r\n    },\r\n    '-32602': {\r\n        standard: 'JSON RPC 2.0',\r\n        message: 'Invalid method parameter(s).',\r\n    },\r\n    '-32603': {\r\n        standard: 'JSON RPC 2.0',\r\n        message: 'Internal JSON-RPC error.',\r\n    },\r\n    '-32000': {\r\n        standard: 'EIP-1474',\r\n        message: 'Invalid input.',\r\n    },\r\n    '-32001': {\r\n        standard: 'EIP-1474',\r\n        message: 'Resource not found.',\r\n    },\r\n    '-32002': {\r\n        standard: 'EIP-1474',\r\n        message: 'Resource unavailable.',\r\n    },\r\n    '-32003': {\r\n        standard: 'EIP-1474',\r\n        message: 'Transaction rejected.',\r\n    },\r\n    '-32004': {\r\n        standard: 'EIP-1474',\r\n        message: 'Method not supported.',\r\n    },\r\n    '-32005': {\r\n        standard: 'EIP-1474',\r\n        message: 'Request limit exceeded.',\r\n    },\r\n    '4001': {\r\n        standard: 'EIP-1193',\r\n        message: 'User rejected the request.',\r\n    },\r\n    '4100': {\r\n        standard: 'EIP-1193',\r\n        message: 'The requested account and/or method has not been authorized by the user.',\r\n    },\r\n    '4200': {\r\n        standard: 'EIP-1193',\r\n        message: 'The requested method is not supported by this Ethereum provider.',\r\n    },\r\n    '4900': {\r\n        standard: 'EIP-1193',\r\n        message: 'The provider is disconnected from all chains.',\r\n    },\r\n    '4901': {\r\n        standard: 'EIP-1193',\r\n        message: 'The provider is disconnected from the specified chain.',\r\n    },\r\n};\r\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXJyb3ItY29uc3RhbnRzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2Vycm9yLWNvbnN0YW50cy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUF1QmEsUUFBQSxVQUFVLEdBQWU7SUFDcEMsR0FBRyxFQUFFO1FBQ0gsWUFBWSxFQUFFLENBQUMsS0FBSztRQUNwQixnQkFBZ0IsRUFBRSxDQUFDLEtBQUs7UUFDeEIsbUJBQW1CLEVBQUUsQ0FBQyxLQUFLO1FBQzNCLG1CQUFtQixFQUFFLENBQUMsS0FBSztRQUMzQixrQkFBa0IsRUFBRSxDQUFDLEtBQUs7UUFDMUIsYUFBYSxFQUFFLENBQUMsS0FBSztRQUNyQixLQUFLLEVBQUUsQ0FBQyxLQUFLO1FBQ2IsY0FBYyxFQUFFLENBQUMsS0FBSztRQUN0QixjQUFjLEVBQUUsQ0FBQyxLQUFLO1FBQ3RCLGFBQWEsRUFBRSxDQUFDLEtBQUs7UUFDckIsUUFBUSxFQUFFLENBQUMsS0FBSztLQUNqQjtJQUNELFFBQVEsRUFBRTtRQUNSLG1CQUFtQixFQUFFLElBQUk7UUFDekIsWUFBWSxFQUFFLElBQUk7UUFDbEIsaUJBQWlCLEVBQUUsSUFBSTtRQUN2QixZQUFZLEVBQUUsSUFBSTtRQUNsQixpQkFBaUIsRUFBRSxJQUFJO0tBQ3hCO0NBQ0YsQ0FBQztBQUVXLFFBQUEsV0FBVyxHQUFHO0lBQ3pCLFFBQVEsRUFBRTtRQUNSLFFBQVEsRUFBRSxjQUFjO1FBQ3hCLE9BQU8sRUFBRSx1R0FBdUc7S0FDakg7SUFDRCxRQUFRLEVBQUU7UUFDUixRQUFRLEVBQUUsY0FBYztRQUN4QixPQUFPLEVBQUUsOENBQThDO0tBQ3hEO0lBQ0QsUUFBUSxFQUFFO1FBQ1IsUUFBUSxFQUFFLGNBQWM7UUFDeEIsT0FBTyxFQUFFLCtDQUErQztLQUN6RDtJQUNELFFBQVEsRUFBRTtRQUNSLFFBQVEsRUFBRSxjQUFjO1FBQ3hCLE9BQU8sRUFBRSw4QkFBOEI7S0FDeEM7SUFDRCxRQUFRLEVBQUU7UUFDUixRQUFRLEVBQUUsY0FBYztRQUN4QixPQUFPLEVBQUUsMEJBQTBCO0tBQ3BDO0lBQ0QsUUFBUSxFQUFFO1FBQ1IsUUFBUSxFQUFFLFVBQVU7UUFDcEIsT0FBTyxFQUFFLGdCQUFnQjtLQUMxQjtJQUNELFFBQVEsRUFBRTtRQUNSLFFBQVEsRUFBRSxVQUFVO1FBQ3BCLE9BQU8sRUFBRSxxQkFBcUI7S0FDL0I7SUFDRCxRQUFRLEVBQUU7UUFDUixRQUFRLEVBQUUsVUFBVTtRQUNwQixPQUFPLEVBQUUsdUJBQXVCO0tBQ2pDO0lBQ0QsUUFBUSxFQUFFO1FBQ1IsUUFBUSxFQUFFLFVBQVU7UUFDcEIsT0FBTyxFQUFFLHVCQUF1QjtLQUNqQztJQUNELFFBQVEsRUFBRTtRQUNSLFFBQVEsRUFBRSxVQUFVO1FBQ3BCLE9BQU8sRUFBRSx1QkFBdUI7S0FDakM7SUFDRCxRQUFRLEVBQUU7UUFDUixRQUFRLEVBQUUsVUFBVTtRQUNwQixPQUFPLEVBQUUseUJBQXlCO0tBQ25DO0lBQ0QsTUFBTSxFQUFFO1FBQ04sUUFBUSxFQUFFLFVBQVU7UUFDcEIsT0FBTyxFQUFFLDRCQUE0QjtLQUN0QztJQUNELE1BQU0sRUFBRTtRQUNOLFFBQVEsRUFBRSxVQUFVO1FBQ3BCLE9BQU8sRUFBRSwwRUFBMEU7S0FDcEY7SUFDRCxNQUFNLEVBQUU7UUFDTixRQUFRLEVBQUUsVUFBVTtRQUNwQixPQUFPLEVBQUUsa0VBQWtFO0tBQzVFO0lBQ0QsTUFBTSxFQUFFO1FBQ04sUUFBUSxFQUFFLFVBQVU7UUFDcEIsT0FBTyxFQUFFLCtDQUErQztLQUN6RDtJQUNELE1BQU0sRUFBRTtRQUNOLFFBQVEsRUFBRSxVQUFVO1FBQ3BCLE9BQU8sRUFBRSx3REFBd0Q7S0FDbEU7Q0FDRixDQUFDIn0=//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXRoLXJwYy1lcnJvcnMvZGlzdC9lcnJvci1jb25zdGFudHMuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CLEdBQUcsa0JBQWtCO0FBQ3hDLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZXRoLXJwYy1lcnJvcnMvZGlzdC9lcnJvci1jb25zdGFudHMuanM/MWJlMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLmVycm9yVmFsdWVzID0gZXhwb3J0cy5lcnJvckNvZGVzID0gdm9pZCAwO1xyXG5leHBvcnRzLmVycm9yQ29kZXMgPSB7XHJcbiAgICBycGM6IHtcclxuICAgICAgICBpbnZhbGlkSW5wdXQ6IC0zMjAwMCxcclxuICAgICAgICByZXNvdXJjZU5vdEZvdW5kOiAtMzIwMDEsXHJcbiAgICAgICAgcmVzb3VyY2VVbmF2YWlsYWJsZTogLTMyMDAyLFxyXG4gICAgICAgIHRyYW5zYWN0aW9uUmVqZWN0ZWQ6IC0zMjAwMyxcclxuICAgICAgICBtZXRob2ROb3RTdXBwb3J0ZWQ6IC0zMjAwNCxcclxuICAgICAgICBsaW1pdEV4Y2VlZGVkOiAtMzIwMDUsXHJcbiAgICAgICAgcGFyc2U6IC0zMjcwMCxcclxuICAgICAgICBpbnZhbGlkUmVxdWVzdDogLTMyNjAwLFxyXG4gICAgICAgIG1ldGhvZE5vdEZvdW5kOiAtMzI2MDEsXHJcbiAgICAgICAgaW52YWxpZFBhcmFtczogLTMyNjAyLFxyXG4gICAgICAgIGludGVybmFsOiAtMzI2MDMsXHJcbiAgICB9LFxyXG4gICAgcHJvdmlkZXI6IHtcclxuICAgICAgICB1c2VyUmVqZWN0ZWRSZXF1ZXN0OiA0MDAxLFxyXG4gICAgICAgIHVuYXV0aG9yaXplZDogNDEwMCxcclxuICAgICAgICB1bnN1cHBvcnRlZE1ldGhvZDogNDIwMCxcclxuICAgICAgICBkaXNjb25uZWN0ZWQ6IDQ5MDAsXHJcbiAgICAgICAgY2hhaW5EaXNjb25uZWN0ZWQ6IDQ5MDEsXHJcbiAgICB9LFxyXG59O1xyXG5leHBvcnRzLmVycm9yVmFsdWVzID0ge1xyXG4gICAgJy0zMjcwMCc6IHtcclxuICAgICAgICBzdGFuZGFyZDogJ0pTT04gUlBDIDIuMCcsXHJcbiAgICAgICAgbWVzc2FnZTogJ0ludmFsaWQgSlNPTiB3YXMgcmVjZWl2ZWQgYnkgdGhlIHNlcnZlci4gQW4gZXJyb3Igb2NjdXJyZWQgb24gdGhlIHNlcnZlciB3aGlsZSBwYXJzaW5nIHRoZSBKU09OIHRleHQuJyxcclxuICAgIH0sXHJcbiAgICAnLTMyNjAwJzoge1xyXG4gICAgICAgIHN0YW5kYXJkOiAnSlNPTiBSUEMgMi4wJyxcclxuICAgICAgICBtZXNzYWdlOiAnVGhlIEpTT04gc2VudCBpcyBub3QgYSB2YWxpZCBSZXF1ZXN0IG9iamVjdC4nLFxyXG4gICAgfSxcclxuICAgICctMzI2MDEnOiB7XHJcbiAgICAgICAgc3RhbmRhcmQ6ICdKU09OIFJQQyAyLjAnLFxyXG4gICAgICAgIG1lc3NhZ2U6ICdUaGUgbWV0aG9kIGRvZXMgbm90IGV4aXN0IC8gaXMgbm90IGF2YWlsYWJsZS4nLFxyXG4gICAgfSxcclxuICAgICctMzI2MDInOiB7XHJcbiAgICAgICAgc3RhbmRhcmQ6ICdKU09OIFJQQyAyLjAnLFxyXG4gICAgICAgIG1lc3NhZ2U6ICdJbnZhbGlkIG1ldGhvZCBwYXJhbWV0ZXIocykuJyxcclxuICAgIH0sXHJcbiAgICAnLTMyNjAzJzoge1xyXG4gICAgICAgIHN0YW5kYXJkOiAnSlNPTiBSUEMgMi4wJyxcclxuICAgICAgICBtZXNzYWdlOiAnSW50ZXJuYWwgSlNPTi1SUEMgZXJyb3IuJyxcclxuICAgIH0sXHJcbiAgICAnLTMyMDAwJzoge1xyXG4gICAgICAgIHN0YW5kYXJkOiAnRUlQLTE0NzQnLFxyXG4gICAgICAgIG1lc3NhZ2U6ICdJbnZhbGlkIGlucHV0LicsXHJcbiAgICB9LFxyXG4gICAgJy0zMjAwMSc6IHtcclxuICAgICAgICBzdGFuZGFyZDogJ0VJUC0xNDc0JyxcclxuICAgICAgICBtZXNzYWdlOiAnUmVzb3VyY2Ugbm90IGZvdW5kLicsXHJcbiAgICB9LFxyXG4gICAgJy0zMjAwMic6IHtcclxuICAgICAgICBzdGFuZGFyZDogJ0VJUC0xNDc0JyxcclxuICAgICAgICBtZXNzYWdlOiAnUmVzb3VyY2UgdW5hdmFpbGFibGUuJyxcclxuICAgIH0sXHJcbiAgICAnLTMyMDAzJzoge1xyXG4gICAgICAgIHN0YW5kYXJkOiAnRUlQLTE0NzQnLFxyXG4gICAgICAgIG1lc3NhZ2U6ICdUcmFuc2FjdGlvbiByZWplY3RlZC4nLFxyXG4gICAgfSxcclxuICAgICctMzIwMDQnOiB7XHJcbiAgICAgICAgc3RhbmRhcmQ6ICdFSVAtMTQ3NCcsXHJcbiAgICAgICAgbWVzc2FnZTogJ01ldGhvZCBub3Qgc3VwcG9ydGVkLicsXHJcbiAgICB9LFxyXG4gICAgJy0zMjAwNSc6IHtcclxuICAgICAgICBzdGFuZGFyZDogJ0VJUC0xNDc0JyxcclxuICAgICAgICBtZXNzYWdlOiAnUmVxdWVzdCBsaW1pdCBleGNlZWRlZC4nLFxyXG4gICAgfSxcclxuICAgICc0MDAxJzoge1xyXG4gICAgICAgIHN0YW5kYXJkOiAnRUlQLTExOTMnLFxyXG4gICAgICAgIG1lc3NhZ2U6ICdVc2VyIHJlamVjdGVkIHRoZSByZXF1ZXN0LicsXHJcbiAgICB9LFxyXG4gICAgJzQxMDAnOiB7XHJcbiAgICAgICAgc3RhbmRhcmQ6ICdFSVAtMTE5MycsXHJcbiAgICAgICAgbWVzc2FnZTogJ1RoZSByZXF1ZXN0ZWQgYWNjb3VudCBhbmQvb3IgbWV0aG9kIGhhcyBub3QgYmVlbiBhdXRob3JpemVkIGJ5IHRoZSB1c2VyLicsXHJcbiAgICB9LFxyXG4gICAgJzQyMDAnOiB7XHJcbiAgICAgICAgc3RhbmRhcmQ6ICdFSVAtMTE5MycsXHJcbiAgICAgICAgbWVzc2FnZTogJ1RoZSByZXF1ZXN0ZWQgbWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBFdGhlcmV1bSBwcm92aWRlci4nLFxyXG4gICAgfSxcclxuICAgICc0OTAwJzoge1xyXG4gICAgICAgIHN0YW5kYXJkOiAnRUlQLTExOTMnLFxyXG4gICAgICAgIG1lc3NhZ2U6ICdUaGUgcHJvdmlkZXIgaXMgZGlzY29ubmVjdGVkIGZyb20gYWxsIGNoYWlucy4nLFxyXG4gICAgfSxcclxuICAgICc0OTAxJzoge1xyXG4gICAgICAgIHN0YW5kYXJkOiAnRUlQLTExOTMnLFxyXG4gICAgICAgIG1lc3NhZ2U6ICdUaGUgcHJvdmlkZXIgaXMgZGlzY29ubmVjdGVkIGZyb20gdGhlIHNwZWNpZmllZCBjaGFpbi4nLFxyXG4gICAgfSxcclxufTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pWlhKeWIzSXRZMjl1YzNSaGJuUnpMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZjM0pqTDJWeWNtOXlMV052Ym5OMFlXNTBjeTUwY3lKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pT3pzN1FVRjFRbUVzVVVGQlFTeFZRVUZWTEVkQlFXVTdTVUZEY0VNc1IwRkJSeXhGUVVGRk8xRkJRMGdzV1VGQldTeEZRVUZGTEVOQlFVTXNTMEZCU3p0UlFVTndRaXhuUWtGQlowSXNSVUZCUlN4RFFVRkRMRXRCUVVzN1VVRkRlRUlzYlVKQlFXMUNMRVZCUVVVc1EwRkJReXhMUVVGTE8xRkJRek5DTEcxQ1FVRnRRaXhGUVVGRkxFTkJRVU1zUzBGQlN6dFJRVU16UWl4clFrRkJhMElzUlVGQlJTeERRVUZETEV0QlFVczdVVUZETVVJc1lVRkJZU3hGUVVGRkxFTkJRVU1zUzBGQlN6dFJRVU55UWl4TFFVRkxMRVZCUVVVc1EwRkJReXhMUVVGTE8xRkJRMklzWTBGQll5eEZRVUZGTEVOQlFVTXNTMEZCU3p0UlFVTjBRaXhqUVVGakxFVkJRVVVzUTBGQlF5eExRVUZMTzFGQlEzUkNMR0ZCUVdFc1JVRkJSU3hEUVVGRExFdEJRVXM3VVVGRGNrSXNVVUZCVVN4RlFVRkZMRU5CUVVNc1MwRkJTenRMUVVOcVFqdEpRVU5FTEZGQlFWRXNSVUZCUlR0UlFVTlNMRzFDUVVGdFFpeEZRVUZGTEVsQlFVazdVVUZEZWtJc1dVRkJXU3hGUVVGRkxFbEJRVWs3VVVGRGJFSXNhVUpCUVdsQ0xFVkJRVVVzU1VGQlNUdFJRVU4yUWl4WlFVRlpMRVZCUVVVc1NVRkJTVHRSUVVOc1FpeHBRa0ZCYVVJc1JVRkJSU3hKUVVGSk8wdEJRM2hDTzBOQlEwWXNRMEZCUXp0QlFVVlhMRkZCUVVFc1YwRkJWeXhIUVVGSE8wbEJRM3BDTEZGQlFWRXNSVUZCUlR0UlFVTlNMRkZCUVZFc1JVRkJSU3hqUVVGak8xRkJRM2hDTEU5QlFVOHNSVUZCUlN4MVIwRkJkVWM3UzBGRGFrZzdTVUZEUkN4UlFVRlJMRVZCUVVVN1VVRkRVaXhSUVVGUkxFVkJRVVVzWTBGQll6dFJRVU40UWl4UFFVRlBMRVZCUVVVc09FTkJRVGhETzB0QlEzaEVPMGxCUTBRc1VVRkJVU3hGUVVGRk8xRkJRMUlzVVVGQlVTeEZRVUZGTEdOQlFXTTdVVUZEZUVJc1QwRkJUeXhGUVVGRkxDdERRVUVyUXp0TFFVTjZSRHRKUVVORUxGRkJRVkVzUlVGQlJUdFJRVU5TTEZGQlFWRXNSVUZCUlN4alFVRmpPMUZCUTNoQ0xFOUJRVThzUlVGQlJTdzRRa0ZCT0VJN1MwRkRlRU03U1VGRFJDeFJRVUZSTEVWQlFVVTdVVUZEVWl4UlFVRlJMRVZCUVVVc1kwRkJZenRSUVVONFFpeFBRVUZQTEVWQlFVVXNNRUpCUVRCQ08wdEJRM0JETzBsQlEwUXNVVUZCVVN4RlFVRkZPMUZCUTFJc1VVRkJVU3hGUVVGRkxGVkJRVlU3VVVGRGNFSXNUMEZCVHl4RlFVRkZMR2RDUVVGblFqdExRVU14UWp0SlFVTkVMRkZCUVZFc1JVRkJSVHRSUVVOU0xGRkJRVkVzUlVGQlJTeFZRVUZWTzFGQlEzQkNMRTlCUVU4c1JVRkJSU3h4UWtGQmNVSTdTMEZETDBJN1NVRkRSQ3hSUVVGUkxFVkJRVVU3VVVGRFVpeFJRVUZSTEVWQlFVVXNWVUZCVlR0UlFVTndRaXhQUVVGUExFVkJRVVVzZFVKQlFYVkNPMHRCUTJwRE8wbEJRMFFzVVVGQlVTeEZRVUZGTzFGQlExSXNVVUZCVVN4RlFVRkZMRlZCUVZVN1VVRkRjRUlzVDBGQlR5eEZRVUZGTEhWQ1FVRjFRanRMUVVOcVF6dEpRVU5FTEZGQlFWRXNSVUZCUlR0UlFVTlNMRkZCUVZFc1JVRkJSU3hWUVVGVk8xRkJRM0JDTEU5QlFVOHNSVUZCUlN4MVFrRkJkVUk3UzBGRGFrTTdTVUZEUkN4UlFVRlJMRVZCUVVVN1VVRkRVaXhSUVVGUkxFVkJRVVVzVlVGQlZUdFJRVU53UWl4UFFVRlBMRVZCUVVVc2VVSkJRWGxDTzB0QlEyNURPMGxCUTBRc1RVRkJUU3hGUVVGRk8xRkJRMDRzVVVGQlVTeEZRVUZGTEZWQlFWVTdVVUZEY0VJc1QwRkJUeXhGUVVGRkxEUkNRVUUwUWp0TFFVTjBRenRKUVVORUxFMUJRVTBzUlVGQlJUdFJRVU5PTEZGQlFWRXNSVUZCUlN4VlFVRlZPMUZCUTNCQ0xFOUJRVThzUlVGQlJTd3dSVUZCTUVVN1MwRkRjRVk3U1VGRFJDeE5RVUZOTEVWQlFVVTdVVUZEVGl4UlFVRlJMRVZCUVVVc1ZVRkJWVHRSUVVOd1FpeFBRVUZQTEVWQlFVVXNhMFZCUVd0Rk8wdEJRelZGTzBsQlEwUXNUVUZCVFN4RlFVRkZPMUZCUTA0c1VVRkJVU3hGUVVGRkxGVkJRVlU3VVVGRGNFSXNUMEZCVHl4RlFVRkZMQ3REUVVFclF6dExRVU42UkR0SlFVTkVMRTFCUVUwc1JVRkJSVHRSUVVOT0xGRkJRVkVzUlVGQlJTeFZRVUZWTzFGQlEzQkNMRTlCUVU4c1JVRkJSU3gzUkVGQmQwUTdTMEZEYkVVN1EwRkRSaXhEUVVGREluMD0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/eth-rpc-errors/dist/error-constants.js\n");

/***/ }),

/***/ "./node_modules/eth-rpc-errors/dist/errors.js":
/*!****************************************************!*\
  !*** ./node_modules/eth-rpc-errors/dist/errors.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ethErrors = void 0;\r\nconst classes_1 = __webpack_require__(/*! ./classes */ \"./node_modules/eth-rpc-errors/dist/classes.js\");\r\nconst utils_1 = __webpack_require__(/*! ./utils */ \"./node_modules/eth-rpc-errors/dist/utils.js\");\r\nconst error_constants_1 = __webpack_require__(/*! ./error-constants */ \"./node_modules/eth-rpc-errors/dist/error-constants.js\");\r\nexports.ethErrors = {\r\n    rpc: {\r\n        /**\r\n         * Get a JSON RPC 2.0 Parse (-32700) error.\r\n         */\r\n        parse: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.parse, arg),\r\n        /**\r\n         * Get a JSON RPC 2.0 Invalid Request (-32600) error.\r\n         */\r\n        invalidRequest: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidRequest, arg),\r\n        /**\r\n         * Get a JSON RPC 2.0 Invalid Params (-32602) error.\r\n         */\r\n        invalidParams: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidParams, arg),\r\n        /**\r\n         * Get a JSON RPC 2.0 Method Not Found (-32601) error.\r\n         */\r\n        methodNotFound: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotFound, arg),\r\n        /**\r\n         * Get a JSON RPC 2.0 Internal (-32603) error.\r\n         */\r\n        internal: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.internal, arg),\r\n        /**\r\n         * Get a JSON RPC 2.0 Server error.\r\n         * Permits integer error codes in the [ -32099 <= -32005 ] range.\r\n         * Codes -32000 through -32004 are reserved by EIP-1474.\r\n         */\r\n        server: (opts) => {\r\n            if (!opts || typeof opts !== 'object' || Array.isArray(opts)) {\r\n                throw new Error('Ethereum RPC Server errors must provide single object argument.');\r\n            }\r\n            const { code } = opts;\r\n            if (!Number.isInteger(code) || code > -32005 || code < -32099) {\r\n                throw new Error('\"code\" must be an integer such that: -32099 <= code <= -32005');\r\n            }\r\n            return getEthJsonRpcError(code, opts);\r\n        },\r\n        /**\r\n         * Get an Ethereum JSON RPC Invalid Input (-32000) error.\r\n         */\r\n        invalidInput: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidInput, arg),\r\n        /**\r\n         * Get an Ethereum JSON RPC Resource Not Found (-32001) error.\r\n         */\r\n        resourceNotFound: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceNotFound, arg),\r\n        /**\r\n         * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.\r\n         */\r\n        resourceUnavailable: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceUnavailable, arg),\r\n        /**\r\n         * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.\r\n         */\r\n        transactionRejected: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.transactionRejected, arg),\r\n        /**\r\n         * Get an Ethereum JSON RPC Method Not Supported (-32004) error.\r\n         */\r\n        methodNotSupported: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotSupported, arg),\r\n        /**\r\n         * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.\r\n         */\r\n        limitExceeded: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.limitExceeded, arg),\r\n    },\r\n    provider: {\r\n        /**\r\n         * Get an Ethereum Provider User Rejected Request (4001) error.\r\n         */\r\n        userRejectedRequest: (arg) => {\r\n            return getEthProviderError(error_constants_1.errorCodes.provider.userRejectedRequest, arg);\r\n        },\r\n        /**\r\n         * Get an Ethereum Provider Unauthorized (4100) error.\r\n         */\r\n        unauthorized: (arg) => {\r\n            return getEthProviderError(error_constants_1.errorCodes.provider.unauthorized, arg);\r\n        },\r\n        /**\r\n         * Get an Ethereum Provider Unsupported Method (4200) error.\r\n         */\r\n        unsupportedMethod: (arg) => {\r\n            return getEthProviderError(error_constants_1.errorCodes.provider.unsupportedMethod, arg);\r\n        },\r\n        /**\r\n         * Get an Ethereum Provider Not Connected (4900) error.\r\n         */\r\n        disconnected: (arg) => {\r\n            return getEthProviderError(error_constants_1.errorCodes.provider.disconnected, arg);\r\n        },\r\n        /**\r\n         * Get an Ethereum Provider Chain Not Connected (4901) error.\r\n         */\r\n        chainDisconnected: (arg) => {\r\n            return getEthProviderError(error_constants_1.errorCodes.provider.chainDisconnected, arg);\r\n        },\r\n        /**\r\n         * Get a custom Ethereum Provider error.\r\n         */\r\n        custom: (opts) => {\r\n            if (!opts || typeof opts !== 'object' || Array.isArray(opts)) {\r\n                throw new Error('Ethereum Provider custom errors must provide single object argument.');\r\n            }\r\n            const { code, message, data } = opts;\r\n            if (!message || typeof message !== 'string') {\r\n                throw new Error('\"message\" must be a nonempty string');\r\n            }\r\n            return new classes_1.EthereumProviderError(code, message, data);\r\n        },\r\n    },\r\n};\r\n// Internal\r\nfunction getEthJsonRpcError(code, arg) {\r\n    const [message, data] = parseOpts(arg);\r\n    return new classes_1.EthereumRpcError(code, message || utils_1.getMessageFromCode(code), data);\r\n}\r\nfunction getEthProviderError(code, arg) {\r\n    const [message, data] = parseOpts(arg);\r\n    return new classes_1.EthereumProviderError(code, message || utils_1.getMessageFromCode(code), data);\r\n}\r\nfunction parseOpts(arg) {\r\n    if (arg) {\r\n        if (typeof arg === 'string') {\r\n            return [arg];\r\n        }\r\n        else if (typeof arg === 'object' && !Array.isArray(arg)) {\r\n            const { message, data } = arg;\r\n            if (message && typeof message !== 'string') {\r\n                throw new Error('Must specify string message.');\r\n            }\r\n            return [message || undefined, data];\r\n        }\r\n    }\r\n    return [];\r\n}\r\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXJyb3JzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2Vycm9ycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSx1Q0FBb0U7QUFDcEUsbUNBQTZDO0FBQzdDLHVEQUErQztBQWVsQyxRQUFBLFNBQVMsR0FBRztJQUN2QixHQUFHLEVBQUU7UUFFSDs7V0FFRztRQUNILEtBQUssRUFBRSxDQUFJLEdBQXFCLEVBQUUsRUFBRSxDQUFDLGtCQUFrQixDQUNyRCw0QkFBVSxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUMxQjtRQUVEOztXQUVHO1FBQ0gsY0FBYyxFQUFFLENBQUksR0FBcUIsRUFBRSxFQUFFLENBQUMsa0JBQWtCLENBQzlELDRCQUFVLENBQUMsR0FBRyxDQUFDLGNBQWMsRUFBRSxHQUFHLENBQ25DO1FBRUQ7O1dBRUc7UUFDSCxhQUFhLEVBQUUsQ0FBSSxHQUFxQixFQUFFLEVBQUUsQ0FBQyxrQkFBa0IsQ0FDN0QsNEJBQVUsQ0FBQyxHQUFHLENBQUMsYUFBYSxFQUFFLEdBQUcsQ0FDbEM7UUFFRDs7V0FFRztRQUNILGNBQWMsRUFBRSxDQUFJLEdBQXFCLEVBQUUsRUFBRSxDQUFDLGtCQUFrQixDQUM5RCw0QkFBVSxDQUFDLEdBQUcsQ0FBQyxjQUFjLEVBQUUsR0FBRyxDQUNuQztRQUVEOztXQUVHO1FBQ0gsUUFBUSxFQUFFLENBQUksR0FBcUIsRUFBRSxFQUFFLENBQUMsa0JBQWtCLENBQ3hELDRCQUFVLENBQUMsR0FBRyxDQUFDLFFBQVEsRUFBRSxHQUFHLENBQzdCO1FBRUQ7Ozs7V0FJRztRQUNILE1BQU0sRUFBRSxDQUFJLElBQTJCLEVBQUUsRUFBRTtZQUN6QyxJQUFJLENBQUMsSUFBSSxJQUFJLE9BQU8sSUFBSSxLQUFLLFFBQVEsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFO2dCQUM1RCxNQUFNLElBQUksS0FBSyxDQUFDLGlFQUFpRSxDQUFDLENBQUM7YUFDcEY7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# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXRoLXJwYy1lcnJvcnMvZGlzdC9lcnJvcnMuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCLGtCQUFrQixtQkFBTyxDQUFDLGdFQUFXO0FBQ3JDLGdCQUFnQixtQkFBTyxDQUFDLDREQUFTO0FBQ2pDLDBCQUEwQixtQkFBTyxDQUFDLGdGQUFtQjtBQUNyRCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2V0aC1ycGMtZXJyb3JzL2Rpc3QvZXJyb3JzLmpzP2I4MGUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5ldGhFcnJvcnMgPSB2b2lkIDA7XHJcbmNvbnN0IGNsYXNzZXNfMSA9IHJlcXVpcmUoXCIuL2NsYXNzZXNcIik7XHJcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcclxuY29uc3QgZXJyb3JfY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9lcnJvci1jb25zdGFudHNcIik7XHJcbmV4cG9ydHMuZXRoRXJyb3JzID0ge1xyXG4gICAgcnBjOiB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IGEgSlNPTiBSUEMgMi4wIFBhcnNlICgtMzI3MDApIGVycm9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHBhcnNlOiAoYXJnKSA9PiBnZXRFdGhKc29uUnBjRXJyb3IoZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JDb2Rlcy5ycGMucGFyc2UsIGFyZyksXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IGEgSlNPTiBSUEMgMi4wIEludmFsaWQgUmVxdWVzdCAoLTMyNjAwKSBlcnJvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBpbnZhbGlkUmVxdWVzdDogKGFyZykgPT4gZ2V0RXRoSnNvblJwY0Vycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucnBjLmludmFsaWRSZXF1ZXN0LCBhcmcpLFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCBhIEpTT04gUlBDIDIuMCBJbnZhbGlkIFBhcmFtcyAoLTMyNjAyKSBlcnJvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBpbnZhbGlkUGFyYW1zOiAoYXJnKSA9PiBnZXRFdGhKc29uUnBjRXJyb3IoZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JDb2Rlcy5ycGMuaW52YWxpZFBhcmFtcywgYXJnKSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgYSBKU09OIFJQQyAyLjAgTWV0aG9kIE5vdCBGb3VuZCAoLTMyNjAxKSBlcnJvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBtZXRob2ROb3RGb3VuZDogKGFyZykgPT4gZ2V0RXRoSnNvblJwY0Vycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucnBjLm1ldGhvZE5vdEZvdW5kLCBhcmcpLFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCBhIEpTT04gUlBDIDIuMCBJbnRlcm5hbCAoLTMyNjAzKSBlcnJvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBpbnRlcm5hbDogKGFyZykgPT4gZ2V0RXRoSnNvblJwY0Vycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucnBjLmludGVybmFsLCBhcmcpLFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCBhIEpTT04gUlBDIDIuMCBTZXJ2ZXIgZXJyb3IuXHJcbiAgICAgICAgICogUGVybWl0cyBpbnRlZ2VyIGVycm9yIGNvZGVzIGluIHRoZSBbIC0zMjA5OSA8PSAtMzIwMDUgXSByYW5nZS5cclxuICAgICAgICAgKiBDb2RlcyAtMzIwMDAgdGhyb3VnaCAtMzIwMDQgYXJlIHJlc2VydmVkIGJ5IEVJUC0xNDc0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNlcnZlcjogKG9wdHMpID0+IHtcclxuICAgICAgICAgICAgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KG9wdHMpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V0aGVyZXVtIFJQQyBTZXJ2ZXIgZXJyb3JzIG11c3QgcHJvdmlkZSBzaW5nbGUgb2JqZWN0IGFyZ3VtZW50LicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHsgY29kZSB9ID0gb3B0cztcclxuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGNvZGUpIHx8IGNvZGUgPiAtMzIwMDUgfHwgY29kZSA8IC0zMjA5OSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImNvZGVcIiBtdXN0IGJlIGFuIGludGVnZXIgc3VjaCB0aGF0OiAtMzIwOTkgPD0gY29kZSA8PSAtMzIwMDUnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZ2V0RXRoSnNvblJwY0Vycm9yKGNvZGUsIG9wdHMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IGFuIEV0aGVyZXVtIEpTT04gUlBDIEludmFsaWQgSW5wdXQgKC0zMjAwMCkgZXJyb3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaW52YWxpZElucHV0OiAoYXJnKSA9PiBnZXRFdGhKc29uUnBjRXJyb3IoZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JDb2Rlcy5ycGMuaW52YWxpZElucHV0LCBhcmcpLFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCBhbiBFdGhlcmV1bSBKU09OIFJQQyBSZXNvdXJjZSBOb3QgRm91bmQgKC0zMjAwMSkgZXJyb3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmVzb3VyY2VOb3RGb3VuZDogKGFyZykgPT4gZ2V0RXRoSnNvblJwY0Vycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucnBjLnJlc291cmNlTm90Rm91bmQsIGFyZyksXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IGFuIEV0aGVyZXVtIEpTT04gUlBDIFJlc291cmNlIFVuYXZhaWxhYmxlICgtMzIwMDIpIGVycm9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHJlc291cmNlVW5hdmFpbGFibGU6IChhcmcpID0+IGdldEV0aEpzb25ScGNFcnJvcihlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnJwYy5yZXNvdXJjZVVuYXZhaWxhYmxlLCBhcmcpLFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCBhbiBFdGhlcmV1bSBKU09OIFJQQyBUcmFuc2FjdGlvbiBSZWplY3RlZCAoLTMyMDAzKSBlcnJvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0cmFuc2FjdGlvblJlamVjdGVkOiAoYXJnKSA9PiBnZXRFdGhKc29uUnBjRXJyb3IoZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JDb2Rlcy5ycGMudHJhbnNhY3Rpb25SZWplY3RlZCwgYXJnKSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgYW4gRXRoZXJldW0gSlNPTiBSUEMgTWV0aG9kIE5vdCBTdXBwb3J0ZWQgKC0zMjAwNCkgZXJyb3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbWV0aG9kTm90U3VwcG9ydGVkOiAoYXJnKSA9PiBnZXRFdGhKc29uUnBjRXJyb3IoZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JDb2Rlcy5ycGMubWV0aG9kTm90U3VwcG9ydGVkLCBhcmcpLFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCBhbiBFdGhlcmV1bSBKU09OIFJQQyBMaW1pdCBFeGNlZWRlZCAoLTMyMDA1KSBlcnJvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBsaW1pdEV4Y2VlZGVkOiAoYXJnKSA9PiBnZXRFdGhKc29uUnBjRXJyb3IoZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JDb2Rlcy5ycGMubGltaXRFeGNlZWRlZCwgYXJnKSxcclxuICAgIH0sXHJcbiAgICBwcm92aWRlcjoge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCBhbiBFdGhlcmV1bSBQcm92aWRlciBVc2VyIFJlamVjdGVkIFJlcXVlc3QgKDQwMDEpIGVycm9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHVzZXJSZWplY3RlZFJlcXVlc3Q6IChhcmcpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldEV0aFByb3ZpZGVyRXJyb3IoZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JDb2Rlcy5wcm92aWRlci51c2VyUmVqZWN0ZWRSZXF1ZXN0LCBhcmcpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IGFuIEV0aGVyZXVtIFByb3ZpZGVyIFVuYXV0aG9yaXplZCAoNDEwMCkgZXJyb3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdW5hdXRob3JpemVkOiAoYXJnKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXRFdGhQcm92aWRlckVycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucHJvdmlkZXIudW5hdXRob3JpemVkLCBhcmcpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IGFuIEV0aGVyZXVtIFByb3ZpZGVyIFVuc3VwcG9ydGVkIE1ldGhvZCAoNDIwMCkgZXJyb3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdW5zdXBwb3J0ZWRNZXRob2Q6IChhcmcpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldEV0aFByb3ZpZGVyRXJyb3IoZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JDb2Rlcy5wcm92aWRlci51bnN1cHBvcnRlZE1ldGhvZCwgYXJnKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCBhbiBFdGhlcmV1bSBQcm92aWRlciBOb3QgQ29ubmVjdGVkICg0OTAwKSBlcnJvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBkaXNjb25uZWN0ZWQ6IChhcmcpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldEV0aFByb3ZpZGVyRXJyb3IoZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JDb2Rlcy5wcm92aWRlci5kaXNjb25uZWN0ZWQsIGFyZyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgYW4gRXRoZXJldW0gUHJvdmlkZXIgQ2hhaW4gTm90IENvbm5lY3RlZCAoNDkwMSkgZXJyb3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2hhaW5EaXNjb25uZWN0ZWQ6IChhcmcpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldEV0aFByb3ZpZGVyRXJyb3IoZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JDb2Rlcy5wcm92aWRlci5jaGFpbkRpc2Nvbm5lY3RlZCwgYXJnKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCBhIGN1c3RvbSBFdGhlcmV1bSBQcm92aWRlciBlcnJvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBjdXN0b206IChvcHRzKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghb3B0cyB8fCB0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShvcHRzKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFdGhlcmV1bSBQcm92aWRlciBjdXN0b20gZXJyb3JzIG11c3QgcHJvdmlkZSBzaW5nbGUgb2JqZWN0IGFyZ3VtZW50LicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHsgY29kZSwgbWVzc2FnZSwgZGF0YSB9ID0gb3B0cztcclxuICAgICAgICAgICAgaWYgKCFtZXNzYWdlIHx8IHR5cGVvZiBtZXNzYWdlICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIm1lc3NhZ2VcIiBtdXN0IGJlIGEgbm9uZW1wdHkgc3RyaW5nJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBjbGFzc2VzXzEuRXRoZXJldW1Qcm92aWRlckVycm9yKGNvZGUsIG1lc3NhZ2UsIGRhdGEpO1xyXG4gICAgICAgIH0sXHJcbiAgICB9LFxyXG59O1xyXG4vLyBJbnRlcm5hbFxyXG5mdW5jdGlvbiBnZXRFdGhKc29uUnBjRXJyb3IoY29kZSwgYXJnKSB7XHJcbiAgICBjb25zdCBbbWVzc2FnZSwgZGF0YV0gPSBwYXJzZU9wdHMoYXJnKTtcclxuICAgIHJldHVybiBuZXcgY2xhc3Nlc18xLkV0aGVyZXVtUnBjRXJyb3IoY29kZSwgbWVzc2FnZSB8fCB1dGlsc18xLmdldE1lc3NhZ2VGcm9tQ29kZShjb2RlKSwgZGF0YSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0RXRoUHJvdmlkZXJFcnJvcihjb2RlLCBhcmcpIHtcclxuICAgIGNvbnN0IFttZXNzYWdlLCBkYXRhXSA9IHBhcnNlT3B0cyhhcmcpO1xyXG4gICAgcmV0dXJuIG5ldyBjbGFzc2VzXzEuRXRoZXJldW1Qcm92aWRlckVycm9yKGNvZGUsIG1lc3NhZ2UgfHwgdXRpbHNfMS5nZXRNZXNzYWdlRnJvbUNvZGUoY29kZSksIGRhdGEpO1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlT3B0cyhhcmcpIHtcclxuICAgIGlmIChhcmcpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFthcmddO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShhcmcpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgbWVzc2FnZSwgZGF0YSB9ID0gYXJnO1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZSAmJiB0eXBlb2YgbWVzc2FnZSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBzcGVjaWZ5IHN0cmluZyBtZXNzYWdlLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBbbWVzc2FnZSB8fCB1bmRlZmluZWQsIGRhdGFdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBbXTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2laWEp5YjNKekxtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpTGk0dmMzSmpMMlZ5Y205eWN5NTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPenM3UVVGQlFTeDFRMEZCYjBVN1FVRkRjRVVzYlVOQlFUWkRPMEZCUXpkRExIVkVRVUVyUXp0QlFXVnNReXhSUVVGQkxGTkJRVk1zUjBGQlJ6dEpRVU4yUWl4SFFVRkhMRVZCUVVVN1VVRkZTRHM3VjBGRlJ6dFJRVU5JTEV0QlFVc3NSVUZCUlN4RFFVRkpMRWRCUVhGQ0xFVkJRVVVzUlVGQlJTeERRVUZETEd0Q1FVRnJRaXhEUVVOeVJDdzBRa0ZCVlN4RFFVRkRMRWRCUVVjc1EwRkJReXhMUVVGTExFVkJRVVVzUjBGQlJ5eERRVU14UWp0UlFVVkVPenRYUVVWSE8xRkJRMGdzWTBGQll5eEZRVUZGTEVOQlFVa3NSMEZCY1VJc1JVRkJSU3hGUVVGRkxFTkJRVU1zYTBKQlFXdENMRU5CUXpsRUxEUkNRVUZWTEVOQlFVTXNSMEZCUnl4RFFVRkRMR05CUVdNc1JVRkJSU3hIUVVGSExFTkJRMjVETzFGQlJVUTdPMWRCUlVjN1VVRkRTQ3hoUVVGaExFVkJRVVVzUTBGQlNTeEhRVUZ4UWl4RlFVRkZMRVZCUVVVc1EwRkJReXhyUWtGQmEwSXNRMEZETjBRc05FSkJRVlVzUTBGQlF5eEhRVUZITEVOQlFVTXNZVUZCWVN4RlFVRkZMRWRCUVVjc1EwRkRiRU03VVVGRlJEczdWMEZGUnp0UlFVTklMR05CUVdNc1JVRkJSU3hEUVVGSkxFZEJRWEZDTEVWQlFVVXNSVUZCUlN4RFFVRkRMR3RDUVVGclFpeERRVU01UkN3MFFrRkJWU3hEUVVGRExFZEJRVWNzUTBGQlF5eGpRVUZqTEVWQlFVVXNSMEZCUnl4RFFVTnVRenRSUVVWRU96dFhRVVZITzFGQlEwZ3NVVUZCVVN4RlFVRkZMRU5CUVVrc1IwRkJjVUlzUlVGQlJTeEZRVUZGTEVOQlFVTXNhMEpCUVd0Q0xFTkJRM2hFTERSQ1FVRlZMRU5CUVVNc1IwRkJSeXhEUVVGRExGRkJRVkVzUlVGQlJTeEhRVUZITEVOQlF6ZENPMUZCUlVRN096czdWMEZKUnp0UlFVTklMRTFCUVUwc1JVRkJSU3hEUVVGSkxFbEJRVEpDTEVWQlFVVXNSVUZCUlR0WlFVTjZReXhKUVVGSkxFTkJRVU1zU1VGQlNTeEpRVUZKTEU5QlFVOHNTVUZCU1N4TFFVRkxMRkZCUVZFc1NVRkJTU3hMUVVGTExFTkJRVU1zVDBGQlR5eERRVUZETEVsQlFVa3NRMEZCUXl4RlFVRkZPMmRDUVVNMVJDeE5RVUZOTEVsQlFVa3NTMEZCU3l4RFFVRkRMR2xGUVVGcFJTeERRVUZETEVOQlFVTTdZVUZEY0VZN1dVRkRSQ3hOUVVGTkxFVkJRVVVzU1VGQlNTeEZRVUZGTEVkQlFVY3NTVUZCU1N4RFFVRkRPMWxCUTNSQ0xFbEJRVWtzUTBGQlF5eE5RVUZOTEVOQlFVTXNVMEZCVXl4RFFVRkRMRWxCUVVrc1EwRkJReXhKUVVGSkxFbEJRVWtzUjBGQlJ5eERRVUZETEV0QlFVc3NTVUZCU1N4SlFVRkpMRWRCUVVjc1EwRkJReXhMUVVGTExFVkJRVVU3WjBKQlF6ZEVMRTFCUVUwc1NVRkJTU3hMUVVGTExFTkJRMklzSzBSQlFTdEVMRU5CUTJoRkxFTkJRVU03WVVGRFNEdFpRVU5FTEU5QlFVOHNhMEpCUVd0Q0xFTkJRVU1zU1VGQlNTeEZRVUZGTEVsQlFVa3NRMEZCUXl4RFFVRkRPMUZCUTNoRExFTkJRVU03VVVGRlJEczdWMEZGUnp0UlFVTklMRmxCUVZrc1JVRkJSU3hEUVVGSkxFZEJRWEZDTEVWQlFVVXNSVUZCUlN4RFFVRkRMR3RDUVVGclFpeERRVU0xUkN3MFFrRkJWU3hEUVVGRExFZEJRVWNzUTBGQlF5eFpRVUZaTEVWQlFVVXNSMEZCUnl4RFFVTnFRenRSUVVWRU96dFhRVVZITzFGQlEwZ3NaMEpCUVdkQ0xFVkJRVVVzUTBGQlNTeEhRVUZ4UWl4RlFVRkZMRVZCUVVVc1EwRkJReXhyUWtGQmEwSXNRMEZEYUVVc05FSkJRVlVzUTBGQlF5eEhRVUZITEVOQlFVTXNaMEpCUVdkQ0xFVkJRVVVzUjBGQlJ5eERRVU55UXp0UlFVVkVPenRYUVVWSE8xRkJRMGdzYlVKQlFXMUNMRVZCUVVVc1EwRkJTU3hIUVVGeFFpeEZRVUZGTEVWQlFVVXNRMEZCUXl4clFrRkJhMElzUTBGRGJrVXNORUpCUVZVc1EwRkJReXhIUVVGSExFTkJRVU1zYlVKQlFXMUNMRVZCUVVVc1IwRkJSeXhEUVVONFF6dFJRVVZFT3p0WFFVVkhPMUZCUTBnc2JVSkJRVzFDTEVWQlFVVXNRMEZCU1N4SFFVRnhRaXhGUVVGRkxFVkJRVVVzUTBGQlF5eHJRa0ZCYTBJc1EwRkRia1VzTkVKQlFWVXNRMEZCUXl4SFFVRkhMRU5CUVVNc2JVSkJRVzFDTEVWQlFVVXNSMEZCUnl4RFFVTjRRenRSUVVWRU96dFhRVVZITzFGQlEwZ3NhMEpCUVd0Q0xFVkJRVVVzUTBGQlNTeEhRVUZ4UWl4RlFVRkZMRVZCUVVVc1EwRkJReXhyUWtGQmEwSXNRMEZEYkVVc05FSkJRVlVzUTBGQlF5eEhRVUZITEVOQlFVTXNhMEpCUVd0Q0xFVkJRVVVzUjBGQlJ5eERRVU4yUXp0UlFVVkVPenRYUVVWSE8xRkJRMGdzWVVGQllTeEZRVUZGTEVOQlFVa3NSMEZCY1VJc1JVRkJSU3hGUVVGRkxFTkJRVU1zYTBKQlFXdENMRU5CUXpkRUxEUkNRVUZWTEVOQlFVTXNSMEZCUnl4RFFVRkRMR0ZCUVdFc1JVRkJSU3hIUVVGSExFTkJRMnhETzB0QlEwWTdTVUZGUkN4UlFVRlJMRVZCUVVVN1VVRkZVanM3VjBGRlJ6dFJRVU5JTEcxQ1FVRnRRaXhGUVVGRkxFTkJRVWtzUjBGQmNVSXNSVUZCUlN4RlFVRkZPMWxCUTJoRUxFOUJRVThzYlVKQlFXMUNMRU5CUTNoQ0xEUkNRVUZWTEVOQlFVTXNVVUZCVVN4RFFVRkRMRzFDUVVGdFFpeEZRVUZGTEVkQlFVY3NRMEZETjBNc1EwRkJRenRSUVVOS0xFTkJRVU03VVVGRlJEczdWMEZGUnp0UlFVTklMRmxCUVZrc1JVRkJSU3hEUVVGSkxFZEJRWEZDTEVWQlFVVXNSVUZCUlR0WlFVTjZReXhQUVVGUExHMUNRVUZ0UWl4RFFVTjRRaXcwUWtGQlZTeERRVUZETEZGQlFWRXNRMEZCUXl4WlFVRlpMRVZCUVVVc1IwRkJSeXhEUVVOMFF5eERRVUZETzFGQlEwb3NRMEZCUXp0UlFVVkVPenRYUVVWSE8xRkJRMGdzYVVKQlFXbENMRVZCUVVVc1EwRkJTU3hIUVVGeFFpeEZRVUZGTEVWQlFVVTdXVUZET1VNc1QwRkJUeXh0UWtGQmJVSXNRMEZEZUVJc05FSkJRVlVzUTBGQlF5eFJRVUZSTEVOQlFVTXNhVUpCUVdsQ0xFVkJRVVVzUjBGQlJ5eERRVU16UXl4RFFVRkRPMUZCUTBvc1EwRkJRenRSUVVWRU96dFhRVVZITzFGQlEwZ3NXVUZCV1N4RlFVRkZMRU5CUVVrc1IwRkJjVUlzUlVGQlJTeEZRVUZGTzFsQlEzcERMRTlCUVU4c2JVSkJRVzFDTEVOQlEzaENMRFJDUVVGVkxFTkJRVU1zVVVGQlVTeERRVUZETEZsQlFWa3NSVUZCUlN4SFFVRkhMRU5CUTNSRExFTkJRVU03VVVGRFNpeERRVUZETzFGQlJVUTdPMWRCUlVjN1VVRkRTQ3hwUWtGQmFVSXNSVUZCUlN4RFFVRkpMRWRCUVhGQ0xFVkJRVVVzUlVGQlJUdFpRVU01UXl4UFFVRlBMRzFDUVVGdFFpeERRVU40UWl3MFFrRkJWU3hEUVVGRExGRkJRVkVzUTBGQlF5eHBRa0ZCYVVJc1JVRkJSU3hIUVVGSExFTkJRek5ETEVOQlFVTTdVVUZEU2l4RFFVRkRPMUZCUlVRN08xZEJSVWM3VVVGRFNDeE5RVUZOTEVWQlFVVXNRMEZCU1N4SlFVRjFRaXhGUVVGRkxFVkJRVVU3V1VGRGNrTXNTVUZCU1N4RFFVRkRMRWxCUVVrc1NVRkJTU3hQUVVGUExFbEJRVWtzUzBGQlN5eFJRVUZSTEVsQlFVa3NTMEZCU3l4RFFVRkRMRTlCUVU4c1EwRkJReXhKUVVGSkxFTkJRVU1zUlVGQlJUdG5Ra0ZETlVRc1RVRkJUU3hKUVVGSkxFdEJRVXNzUTBGQlF5eHpSVUZCYzBVc1EwRkJReXhEUVVGRE8yRkJRM3BHTzFsQlJVUXNUVUZCVFN4RlFVRkZMRWxCUVVrc1JVRkJSU3hQUVVGUExFVkJRVVVzU1VGQlNTeEZRVUZGTEVkQlFVY3NTVUZCU1N4RFFVRkRPMWxCUlhKRExFbEJRVWtzUTBGQlF5eFBRVUZQTEVsQlFVa3NUMEZCVHl4UFFVRlBMRXRCUVVzc1VVRkJVU3hGUVVGRk8yZENRVU16UXl4TlFVRk5MRWxCUVVrc1MwRkJTeXhEUVVOaUxIRkRRVUZ4UXl4RFFVTjBReXhEUVVGRE8yRkJRMGc3V1VGRFJDeFBRVUZQTEVsQlFVa3NLMEpCUVhGQ0xFTkJRVU1zU1VGQlNTeEZRVUZGTEU5QlFVOHNSVUZCUlN4SlFVRkpMRU5CUVVNc1EwRkJRenRSUVVONFJDeERRVUZETzB0QlEwWTdRMEZEUml4RFFVRkRPMEZCUlVZc1YwRkJWenRCUVVWWUxGTkJRVk1zYTBKQlFXdENMRU5CUVVrc1NVRkJXU3hGUVVGRkxFZEJRWEZDTzBsQlEyaEZMRTFCUVUwc1EwRkJReXhQUVVGUExFVkJRVVVzU1VGQlNTeERRVUZETEVkQlFVY3NVMEZCVXl4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRE8wbEJRM1pETEU5QlFVOHNTVUZCU1N3d1FrRkJaMElzUTBGRGVrSXNTVUZCU1N4RlFVTktMRTlCUVU4c1NVRkJTU3d3UWtGQmEwSXNRMEZCUXl4SlFVRkpMRU5CUVVNc1JVRkRia01zU1VGQlNTeERRVU5NTEVOQlFVTTdRVUZEU2l4RFFVRkRPMEZCUlVRc1UwRkJVeXh0UWtGQmJVSXNRMEZCU1N4SlFVRlpMRVZCUVVVc1IwRkJjVUk3U1VGRGFrVXNUVUZCVFN4RFFVRkRMRTlCUVU4c1JVRkJSU3hKUVVGSkxFTkJRVU1zUjBGQlJ5eFRRVUZUTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNN1NVRkRka01zVDBGQlR5eEpRVUZKTEN0Q1FVRnhRaXhEUVVNNVFpeEpRVUZKTEVWQlEwb3NUMEZCVHl4SlFVRkpMREJDUVVGclFpeERRVUZETEVsQlFVa3NRMEZCUXl4RlFVTnVReXhKUVVGSkxFTkJRMHdzUTBGQlF6dEJRVU5LTEVOQlFVTTdRVUZGUkN4VFFVRlRMRk5CUVZNc1EwRkJTU3hIUVVGeFFqdEpRVU42UXl4SlFVRkpMRWRCUVVjc1JVRkJSVHRSUVVOUUxFbEJRVWtzVDBGQlR5eEhRVUZITEV0QlFVc3NVVUZCVVN4RlFVRkZPMWxCUXpOQ0xFOUJRVThzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXp0VFFVTmtPMkZCUVUwc1NVRkJTU3hQUVVGUExFZEJRVWNzUzBGQlN5eFJRVUZSTEVsQlFVa3NRMEZCUXl4TFFVRkxMRU5CUVVNc1QwRkJUeXhEUVVGRExFZEJRVWNzUTBGQlF5eEZRVUZGTzFsQlEzcEVMRTFCUVUwc1JVRkJSU3hQUVVGUExFVkJRVVVzU1VGQlNTeEZRVUZGTEVkQlFVY3NSMEZCUnl4RFFVRkRPMWxCUlRsQ0xFbEJRVWtzVDBGQlR5eEpRVUZKTEU5QlFVOHNUMEZCVHl4TFFVRkxMRkZCUVZFc1JVRkJSVHRuUWtGRE1VTXNUVUZCVFN4SlFVRkpMRXRCUVVzc1EwRkJReXc0UWtGQk9FSXNRMEZCUXl4RFFVRkRPMkZCUTJwRU8xbEJRMFFzVDBGQlR5eERRVUZETEU5QlFVOHNTVUZCU1N4VFFVRlRMRVZCUVVVc1NVRkJTU3hEUVVGRExFTkJRVU03VTBGRGNrTTdTMEZEUmp0SlFVTkVMRTlCUVU4c1JVRkJSU3hEUVVGRE8wRkJRMW9zUTBGQlF5SjkiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/eth-rpc-errors/dist/errors.js\n");

/***/ }),

/***/ "./node_modules/eth-rpc-errors/dist/index.js":
/*!***************************************************!*\
  !*** ./node_modules/eth-rpc-errors/dist/index.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.getMessageFromCode = exports.serializeError = exports.EthereumProviderError = exports.EthereumRpcError = exports.ethErrors = exports.errorCodes = void 0;\r\nconst classes_1 = __webpack_require__(/*! ./classes */ \"./node_modules/eth-rpc-errors/dist/classes.js\");\r\nObject.defineProperty(exports, \"EthereumRpcError\", ({ enumerable: true, get: function () { return classes_1.EthereumRpcError; } }));\r\nObject.defineProperty(exports, \"EthereumProviderError\", ({ enumerable: true, get: function () { return classes_1.EthereumProviderError; } }));\r\nconst utils_1 = __webpack_require__(/*! ./utils */ \"./node_modules/eth-rpc-errors/dist/utils.js\");\r\nObject.defineProperty(exports, \"serializeError\", ({ enumerable: true, get: function () { return utils_1.serializeError; } }));\r\nObject.defineProperty(exports, \"getMessageFromCode\", ({ enumerable: true, get: function () { return utils_1.getMessageFromCode; } }));\r\nconst errors_1 = __webpack_require__(/*! ./errors */ \"./node_modules/eth-rpc-errors/dist/errors.js\");\r\nObject.defineProperty(exports, \"ethErrors\", ({ enumerable: true, get: function () { return errors_1.ethErrors; } }));\r\nconst error_constants_1 = __webpack_require__(/*! ./error-constants */ \"./node_modules/eth-rpc-errors/dist/error-constants.js\");\r\nObject.defineProperty(exports, \"errorCodes\", ({ enumerable: true, get: function () { return error_constants_1.errorCodes; } }));\r\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsdUNBQW9FO0FBVWxFLGlHQVZPLDBCQUFnQixPQVVQO0FBQ2hCLHNHQVh5QiwrQkFBcUIsT0FXekI7QUFWdkIsbUNBRWlCO0FBU2YsK0ZBVkEsc0JBQWMsT0FVQTtBQUNkLG1HQVhnQiwwQkFBa0IsT0FXaEI7QUFUcEIscUNBQXFDO0FBS25DLDBGQUxPLGtCQUFTLE9BS1A7QUFKWCx1REFBK0M7QUFHN0MsMkZBSE8sNEJBQVUsT0FHUCJ9//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXRoLXJwYy1lcnJvcnMvZGlzdC9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEIsR0FBRyxzQkFBc0IsR0FBRyw2QkFBNkIsR0FBRyx3QkFBd0IsR0FBRyxpQkFBaUIsR0FBRyxrQkFBa0I7QUFDdkosa0JBQWtCLG1CQUFPLENBQUMsZ0VBQVc7QUFDckMsb0RBQW1ELEVBQUUscUNBQXFDLHNDQUFzQyxFQUFDO0FBQ2pJLHlEQUF3RCxFQUFFLHFDQUFxQywyQ0FBMkMsRUFBQztBQUMzSSxnQkFBZ0IsbUJBQU8sQ0FBQyw0REFBUztBQUNqQyxrREFBaUQsRUFBRSxxQ0FBcUMsa0NBQWtDLEVBQUM7QUFDM0gsc0RBQXFELEVBQUUscUNBQXFDLHNDQUFzQyxFQUFDO0FBQ25JLGlCQUFpQixtQkFBTyxDQUFDLDhEQUFVO0FBQ25DLDZDQUE0QyxFQUFFLHFDQUFxQyw4QkFBOEIsRUFBQztBQUNsSCwwQkFBMEIsbUJBQU8sQ0FBQyxnRkFBbUI7QUFDckQsOENBQTZDLEVBQUUscUNBQXFDLHdDQUF3QyxFQUFDO0FBQzdILDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZXRoLXJwYy1lcnJvcnMvZGlzdC9pbmRleC5qcz8zNGVlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuZ2V0TWVzc2FnZUZyb21Db2RlID0gZXhwb3J0cy5zZXJpYWxpemVFcnJvciA9IGV4cG9ydHMuRXRoZXJldW1Qcm92aWRlckVycm9yID0gZXhwb3J0cy5FdGhlcmV1bVJwY0Vycm9yID0gZXhwb3J0cy5ldGhFcnJvcnMgPSBleHBvcnRzLmVycm9yQ29kZXMgPSB2b2lkIDA7XHJcbmNvbnN0IGNsYXNzZXNfMSA9IHJlcXVpcmUoXCIuL2NsYXNzZXNcIik7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkV0aGVyZXVtUnBjRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsYXNzZXNfMS5FdGhlcmV1bVJwY0Vycm9yOyB9IH0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFdGhlcmV1bVByb3ZpZGVyRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsYXNzZXNfMS5FdGhlcmV1bVByb3ZpZGVyRXJyb3I7IH0gfSk7XHJcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2VyaWFsaXplRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzEuc2VyaWFsaXplRXJyb3I7IH0gfSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldE1lc3NhZ2VGcm9tQ29kZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMS5nZXRNZXNzYWdlRnJvbUNvZGU7IH0gfSk7XHJcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJldGhFcnJvcnNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVycm9yc18xLmV0aEVycm9yczsgfSB9KTtcclxuY29uc3QgZXJyb3JfY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9lcnJvci1jb25zdGFudHNcIik7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVycm9yQ29kZXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXM7IH0gfSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWFXNWtaWGd1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SXVMaTl6Y21NdmFXNWtaWGd1ZEhNaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWpzN08wRkJRVUVzZFVOQlFXOUZPMEZCVld4RkxHbEhRVlpQTERCQ1FVRm5RaXhQUVZWUU8wRkJRMmhDTEhOSFFWaDVRaXdyUWtGQmNVSXNUMEZYZWtJN1FVRldka0lzYlVOQlJXbENPMEZCVTJZc0swWkJWa0VzYzBKQlFXTXNUMEZWUVR0QlFVTmtMRzFIUVZoblFpd3dRa0ZCYTBJc1QwRlhhRUk3UVVGVWNFSXNjVU5CUVhGRE8wRkJTMjVETERCR1FVeFBMR3RDUVVGVExFOUJTMUE3UVVGS1dDeDFSRUZCSzBNN1FVRkhOME1zTWtaQlNFOHNORUpCUVZVc1QwRkhVQ0o5Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/eth-rpc-errors/dist/index.js\n");

/***/ }),

/***/ "./node_modules/eth-rpc-errors/dist/utils.js":
/*!***************************************************!*\
  !*** ./node_modules/eth-rpc-errors/dist/utils.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.serializeError = exports.isValidCode = exports.getMessageFromCode = exports.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;\r\nconst error_constants_1 = __webpack_require__(/*! ./error-constants */ \"./node_modules/eth-rpc-errors/dist/error-constants.js\");\r\nconst classes_1 = __webpack_require__(/*! ./classes */ \"./node_modules/eth-rpc-errors/dist/classes.js\");\r\nconst FALLBACK_ERROR_CODE = error_constants_1.errorCodes.rpc.internal;\r\nconst FALLBACK_MESSAGE = 'Unspecified error message. This is a bug, please report it.';\r\nconst FALLBACK_ERROR = {\r\n    code: FALLBACK_ERROR_CODE,\r\n    message: getMessageFromCode(FALLBACK_ERROR_CODE),\r\n};\r\nexports.JSON_RPC_SERVER_ERROR_MESSAGE = 'Unspecified server error.';\r\n/**\r\n * Gets the message for a given code, or a fallback message if the code has\r\n * no corresponding message.\r\n */\r\nfunction getMessageFromCode(code, fallbackMessage = FALLBACK_MESSAGE) {\r\n    if (Number.isInteger(code)) {\r\n        const codeString = code.toString();\r\n        if (hasKey(error_constants_1.errorValues, codeString)) {\r\n            return error_constants_1.errorValues[codeString].message;\r\n        }\r\n        if (isJsonRpcServerError(code)) {\r\n            return exports.JSON_RPC_SERVER_ERROR_MESSAGE;\r\n        }\r\n    }\r\n    return fallbackMessage;\r\n}\r\nexports.getMessageFromCode = getMessageFromCode;\r\n/**\r\n * Returns whether the given code is valid.\r\n * A code is only valid if it has a message.\r\n */\r\nfunction isValidCode(code) {\r\n    if (!Number.isInteger(code)) {\r\n        return false;\r\n    }\r\n    const codeString = code.toString();\r\n    if (error_constants_1.errorValues[codeString]) {\r\n        return true;\r\n    }\r\n    if (isJsonRpcServerError(code)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nexports.isValidCode = isValidCode;\r\n/**\r\n * Serializes the given error to an Ethereum JSON RPC-compatible error object.\r\n * Merely copies the given error's values if it is already compatible.\r\n * If the given error is not fully compatible, it will be preserved on the\r\n * returned object's data.originalError property.\r\n */\r\nfunction serializeError(error, { fallbackError = FALLBACK_ERROR, shouldIncludeStack = false, } = {}) {\r\n    var _a, _b;\r\n    if (!fallbackError ||\r\n        !Number.isInteger(fallbackError.code) ||\r\n        typeof fallbackError.message !== 'string') {\r\n        throw new Error('Must provide fallback error with integer number code and string message.');\r\n    }\r\n    if (error instanceof classes_1.EthereumRpcError) {\r\n        return error.serialize();\r\n    }\r\n    const serialized = {};\r\n    if (error &&\r\n        typeof error === 'object' &&\r\n        !Array.isArray(error) &&\r\n        hasKey(error, 'code') &&\r\n        isValidCode(error.code)) {\r\n        const _error = error;\r\n        serialized.code = _error.code;\r\n        if (_error.message && typeof _error.message === 'string') {\r\n            serialized.message = _error.message;\r\n            if (hasKey(_error, 'data')) {\r\n                serialized.data = _error.data;\r\n            }\r\n        }\r\n        else {\r\n            serialized.message = getMessageFromCode(serialized.code);\r\n            serialized.data = { originalError: assignOriginalError(error) };\r\n        }\r\n    }\r\n    else {\r\n        serialized.code = fallbackError.code;\r\n        const message = (_a = error) === null || _a === void 0 ? void 0 : _a.message;\r\n        serialized.message = (message && typeof message === 'string'\r\n            ? message\r\n            : fallbackError.message);\r\n        serialized.data = { originalError: assignOriginalError(error) };\r\n    }\r\n    const stack = (_b = error) === null || _b === void 0 ? void 0 : _b.stack;\r\n    if (shouldIncludeStack && error && stack && typeof stack === 'string') {\r\n        serialized.stack = stack;\r\n    }\r\n    return serialized;\r\n}\r\nexports.serializeError = serializeError;\r\n// Internal\r\nfunction isJsonRpcServerError(code) {\r\n    return code >= -32099 && code <= -32000;\r\n}\r\nfunction assignOriginalError(error) {\r\n    if (error && typeof error === 'object' && !Array.isArray(error)) {\r\n        return Object.assign({}, error);\r\n    }\r\n    return error;\r\n}\r\nfunction hasKey(obj, key) {\r\n    return Object.prototype.hasOwnProperty.call(obj, key);\r\n}\r\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsdURBQTREO0FBQzVELHVDQUF5RTtBQUV6RSxNQUFNLG1CQUFtQixHQUFHLDRCQUFVLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQztBQUNwRCxNQUFNLGdCQUFnQixHQUFHLDZEQUE2RCxDQUFDO0FBQ3ZGLE1BQU0sY0FBYyxHQUErQjtJQUNqRCxJQUFJLEVBQUUsbUJBQW1CO0lBQ3pCLE9BQU8sRUFBRSxrQkFBa0IsQ0FBQyxtQkFBbUIsQ0FBQztDQUNqRCxDQUFDO0FBRVcsUUFBQSw2QkFBNkIsR0FBRywyQkFBMkIsQ0FBQztBQUl6RTs7O0dBR0c7QUFDSCxTQUFnQixrQkFBa0IsQ0FDaEMsSUFBWSxFQUNaLGtCQUEwQixnQkFBZ0I7SUFFMUMsSUFBSSxNQUFNLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxFQUFFO1FBQzFCLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUVuQyxJQUFJLE1BQU0sQ0FBQyw2QkFBVyxFQUFFLFVBQVUsQ0FBQyxFQUFFO1lBQ25DLE9BQU8sNkJBQVcsQ0FBQyxVQUEyQixDQUFDLENBQUMsT0FBTyxDQUFDO1NBQ3pEO1FBQ0QsSUFBSSxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUM5QixPQUFPLHFDQUE2QixDQUFDO1NBQ3RDO0tBQ0Y7SUFDRCxPQUFPLGVBQWUsQ0FBQztBQUN6QixDQUFDO0FBZkQsZ0RBZUM7QUFFRDs7O0dBR0c7QUFDSCxTQUFnQixXQUFXLENBQUMsSUFBWTtJQUN0QyxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsRUFBRTtRQUMzQixPQUFPLEtBQUssQ0FBQztLQUNkO0lBRUQsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQ25DLElBQUksNkJBQVcsQ0FBQyxVQUEy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# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXRoLXJwYy1lcnJvcnMvZGlzdC91dGlscy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0IsR0FBRyxtQkFBbUIsR0FBRywwQkFBMEIsR0FBRyxxQ0FBcUM7QUFDakgsMEJBQTBCLG1CQUFPLENBQUMsZ0ZBQW1CO0FBQ3JELGtCQUFrQixtQkFBTyxDQUFDLGdFQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyw4REFBOEQsSUFBSTtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2V0aC1ycGMtZXJyb3JzL2Rpc3QvdXRpbHMuanM/ZjQxZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLnNlcmlhbGl6ZUVycm9yID0gZXhwb3J0cy5pc1ZhbGlkQ29kZSA9IGV4cG9ydHMuZ2V0TWVzc2FnZUZyb21Db2RlID0gZXhwb3J0cy5KU09OX1JQQ19TRVJWRVJfRVJST1JfTUVTU0FHRSA9IHZvaWQgMDtcclxuY29uc3QgZXJyb3JfY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9lcnJvci1jb25zdGFudHNcIik7XHJcbmNvbnN0IGNsYXNzZXNfMSA9IHJlcXVpcmUoXCIuL2NsYXNzZXNcIik7XHJcbmNvbnN0IEZBTExCQUNLX0VSUk9SX0NPREUgPSBlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnJwYy5pbnRlcm5hbDtcclxuY29uc3QgRkFMTEJBQ0tfTUVTU0FHRSA9ICdVbnNwZWNpZmllZCBlcnJvciBtZXNzYWdlLiBUaGlzIGlzIGEgYnVnLCBwbGVhc2UgcmVwb3J0IGl0Lic7XHJcbmNvbnN0IEZBTExCQUNLX0VSUk9SID0ge1xyXG4gICAgY29kZTogRkFMTEJBQ0tfRVJST1JfQ09ERSxcclxuICAgIG1lc3NhZ2U6IGdldE1lc3NhZ2VGcm9tQ29kZShGQUxMQkFDS19FUlJPUl9DT0RFKSxcclxufTtcclxuZXhwb3J0cy5KU09OX1JQQ19TRVJWRVJfRVJST1JfTUVTU0FHRSA9ICdVbnNwZWNpZmllZCBzZXJ2ZXIgZXJyb3IuJztcclxuLyoqXHJcbiAqIEdldHMgdGhlIG1lc3NhZ2UgZm9yIGEgZ2l2ZW4gY29kZSwgb3IgYSBmYWxsYmFjayBtZXNzYWdlIGlmIHRoZSBjb2RlIGhhc1xyXG4gKiBubyBjb3JyZXNwb25kaW5nIG1lc3NhZ2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRNZXNzYWdlRnJvbUNvZGUoY29kZSwgZmFsbGJhY2tNZXNzYWdlID0gRkFMTEJBQ0tfTUVTU0FHRSkge1xyXG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIoY29kZSkpIHtcclxuICAgICAgICBjb25zdCBjb2RlU3RyaW5nID0gY29kZS50b1N0cmluZygpO1xyXG4gICAgICAgIGlmIChoYXNLZXkoZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JWYWx1ZXMsIGNvZGVTdHJpbmcpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlcnJvcl9jb25zdGFudHNfMS5lcnJvclZhbHVlc1tjb2RlU3RyaW5nXS5tZXNzYWdlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNKc29uUnBjU2VydmVyRXJyb3IoY29kZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuSlNPTl9SUENfU0VSVkVSX0VSUk9SX01FU1NBR0U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbGxiYWNrTWVzc2FnZTtcclxufVxyXG5leHBvcnRzLmdldE1lc3NhZ2VGcm9tQ29kZSA9IGdldE1lc3NhZ2VGcm9tQ29kZTtcclxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4gY29kZSBpcyB2YWxpZC5cclxuICogQSBjb2RlIGlzIG9ubHkgdmFsaWQgaWYgaXQgaGFzIGEgbWVzc2FnZS5cclxuICovXHJcbmZ1bmN0aW9uIGlzVmFsaWRDb2RlKGNvZGUpIHtcclxuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihjb2RlKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGNvbnN0IGNvZGVTdHJpbmcgPSBjb2RlLnRvU3RyaW5nKCk7XHJcbiAgICBpZiAoZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JWYWx1ZXNbY29kZVN0cmluZ10pIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmIChpc0pzb25ScGNTZXJ2ZXJFcnJvcihjb2RlKSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmV4cG9ydHMuaXNWYWxpZENvZGUgPSBpc1ZhbGlkQ29kZTtcclxuLyoqXHJcbiAqIFNlcmlhbGl6ZXMgdGhlIGdpdmVuIGVycm9yIHRvIGFuIEV0aGVyZXVtIEpTT04gUlBDLWNvbXBhdGlibGUgZXJyb3Igb2JqZWN0LlxyXG4gKiBNZXJlbHkgY29waWVzIHRoZSBnaXZlbiBlcnJvcidzIHZhbHVlcyBpZiBpdCBpcyBhbHJlYWR5IGNvbXBhdGlibGUuXHJcbiAqIElmIHRoZSBnaXZlbiBlcnJvciBpcyBub3QgZnVsbHkgY29tcGF0aWJsZSwgaXQgd2lsbCBiZSBwcmVzZXJ2ZWQgb24gdGhlXHJcbiAqIHJldHVybmVkIG9iamVjdCdzIGRhdGEub3JpZ2luYWxFcnJvciBwcm9wZXJ0eS5cclxuICovXHJcbmZ1bmN0aW9uIHNlcmlhbGl6ZUVycm9yKGVycm9yLCB7IGZhbGxiYWNrRXJyb3IgPSBGQUxMQkFDS19FUlJPUiwgc2hvdWxkSW5jbHVkZVN0YWNrID0gZmFsc2UsIH0gPSB7fSkge1xyXG4gICAgdmFyIF9hLCBfYjtcclxuICAgIGlmICghZmFsbGJhY2tFcnJvciB8fFxyXG4gICAgICAgICFOdW1iZXIuaXNJbnRlZ2VyKGZhbGxiYWNrRXJyb3IuY29kZSkgfHxcclxuICAgICAgICB0eXBlb2YgZmFsbGJhY2tFcnJvci5tZXNzYWdlICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBwcm92aWRlIGZhbGxiYWNrIGVycm9yIHdpdGggaW50ZWdlciBudW1iZXIgY29kZSBhbmQgc3RyaW5nIG1lc3NhZ2UuJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBjbGFzc2VzXzEuRXRoZXJldW1ScGNFcnJvcikge1xyXG4gICAgICAgIHJldHVybiBlcnJvci5zZXJpYWxpemUoKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB7fTtcclxuICAgIGlmIChlcnJvciAmJlxyXG4gICAgICAgIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiZcclxuICAgICAgICAhQXJyYXkuaXNBcnJheShlcnJvcikgJiZcclxuICAgICAgICBoYXNLZXkoZXJyb3IsICdjb2RlJykgJiZcclxuICAgICAgICBpc1ZhbGlkQ29kZShlcnJvci5jb2RlKSkge1xyXG4gICAgICAgIGNvbnN0IF9lcnJvciA9IGVycm9yO1xyXG4gICAgICAgIHNlcmlhbGl6ZWQuY29kZSA9IF9lcnJvci5jb2RlO1xyXG4gICAgICAgIGlmIChfZXJyb3IubWVzc2FnZSAmJiB0eXBlb2YgX2Vycm9yLm1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQubWVzc2FnZSA9IF9lcnJvci5tZXNzYWdlO1xyXG4gICAgICAgICAgICBpZiAoaGFzS2V5KF9lcnJvciwgJ2RhdGEnKSkge1xyXG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZC5kYXRhID0gX2Vycm9yLmRhdGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQubWVzc2FnZSA9IGdldE1lc3NhZ2VGcm9tQ29kZShzZXJpYWxpemVkLmNvZGUpO1xyXG4gICAgICAgICAgICBzZXJpYWxpemVkLmRhdGEgPSB7IG9yaWdpbmFsRXJyb3I6IGFzc2lnbk9yaWdpbmFsRXJyb3IoZXJyb3IpIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgc2VyaWFsaXplZC5jb2RlID0gZmFsbGJhY2tFcnJvci5jb2RlO1xyXG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAoX2EgPSBlcnJvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1lc3NhZ2U7XHJcbiAgICAgICAgc2VyaWFsaXplZC5tZXNzYWdlID0gKG1lc3NhZ2UgJiYgdHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnXHJcbiAgICAgICAgICAgID8gbWVzc2FnZVxyXG4gICAgICAgICAgICA6IGZhbGxiYWNrRXJyb3IubWVzc2FnZSk7XHJcbiAgICAgICAgc2VyaWFsaXplZC5kYXRhID0geyBvcmlnaW5hbEVycm9yOiBhc3NpZ25PcmlnaW5hbEVycm9yKGVycm9yKSB9O1xyXG4gICAgfVxyXG4gICAgY29uc3Qgc3RhY2sgPSAoX2IgPSBlcnJvcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnN0YWNrO1xyXG4gICAgaWYgKHNob3VsZEluY2x1ZGVTdGFjayAmJiBlcnJvciAmJiBzdGFjayAmJiB0eXBlb2Ygc3RhY2sgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgc2VyaWFsaXplZC5zdGFjayA9IHN0YWNrO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XHJcbn1cclxuZXhwb3J0cy5zZXJpYWxpemVFcnJvciA9IHNlcmlhbGl6ZUVycm9yO1xyXG4vLyBJbnRlcm5hbFxyXG5mdW5jdGlvbiBpc0pzb25ScGNTZXJ2ZXJFcnJvcihjb2RlKSB7XHJcbiAgICByZXR1cm4gY29kZSA+PSAtMzIwOTkgJiYgY29kZSA8PSAtMzIwMDA7XHJcbn1cclxuZnVuY3Rpb24gYXNzaWduT3JpZ2luYWxFcnJvcihlcnJvcikge1xyXG4gICAgaWYgKGVycm9yICYmIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoZXJyb3IpKSB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGVycm9yKTtcclxuICAgIH1cclxuICAgIHJldHVybiBlcnJvcjtcclxufVxyXG5mdW5jdGlvbiBoYXNLZXkob2JqLCBrZXkpIHtcclxuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWRYUnBiSE11YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SXVMaTl6Y21NdmRYUnBiSE11ZEhNaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWpzN08wRkJRVUVzZFVSQlFUUkVPMEZCUXpWRUxIVkRRVUY1UlR0QlFVVjZSU3hOUVVGTkxHMUNRVUZ0UWl4SFFVRkhMRFJDUVVGVkxFTkJRVU1zUjBGQlJ5eERRVUZETEZGQlFWRXNRMEZCUXp0QlFVTndSQ3hOUVVGTkxHZENRVUZuUWl4SFFVRkhMRFpFUVVFMlJDeERRVUZETzBGQlEzWkdMRTFCUVUwc1kwRkJZeXhIUVVFclFqdEpRVU5xUkN4SlFVRkpMRVZCUVVVc2JVSkJRVzFDTzBsQlEzcENMRTlCUVU4c1JVRkJSU3hyUWtGQmEwSXNRMEZCUXl4dFFrRkJiVUlzUTBGQlF6dERRVU5xUkN4RFFVRkRPMEZCUlZjc1VVRkJRU3cyUWtGQk5rSXNSMEZCUnl3eVFrRkJNa0lzUTBGQlF6dEJRVWw2UlRzN08wZEJSMGM3UVVGRFNDeFRRVUZuUWl4clFrRkJhMElzUTBGRGFFTXNTVUZCV1N4RlFVTmFMR3RDUVVFd1FpeG5Ra0ZCWjBJN1NVRkZNVU1zU1VGQlNTeE5RVUZOTEVOQlFVTXNVMEZCVXl4RFFVRkRMRWxCUVVrc1EwRkJReXhGUVVGRk8xRkJRekZDTEUxQlFVMHNWVUZCVlN4SFFVRkhMRWxCUVVrc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF6dFJRVVZ1UXl4SlFVRkpMRTFCUVUwc1EwRkJReXcyUWtGQlZ5eEZRVUZGTEZWQlFWVXNRMEZCUXl4RlFVRkZPMWxCUTI1RExFOUJRVThzTmtKQlFWY3NRMEZCUXl4VlFVRXlRaXhEUVVGRExFTkJRVU1zVDBGQlR5eERRVUZETzFOQlEzcEVPMUZCUTBRc1NVRkJTU3h2UWtGQmIwSXNRMEZCUXl4SlFVRkpMRU5CUVVNc1JVRkJSVHRaUVVNNVFpeFBRVUZQTEhGRFFVRTJRaXhEUVVGRE8xTkJRM1JETzB0QlEwWTdTVUZEUkN4UFFVRlBMR1ZCUVdVc1EwRkJRenRCUVVONlFpeERRVUZETzBGQlprUXNaMFJCWlVNN1FVRkZSRHM3TzBkQlIwYzdRVUZEU0N4VFFVRm5RaXhYUVVGWExFTkJRVU1zU1VGQldUdEpRVU4wUXl4SlFVRkpMRU5CUVVNc1RVRkJUU3hEUVVGRExGTkJRVk1zUTBGQlF5eEpRVUZKTEVOQlFVTXNSVUZCUlR0UlFVTXpRaXhQUVVGUExFdEJRVXNzUTBGQlF6dExRVU5rTzBsQlJVUXNUVUZCVFN4VlFVRlZMRWRCUVVjc1NVRkJTU3hEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZETzBsQlEyNURMRWxCUVVrc05rSkJRVmNzUTBGQlF5eFZRVUV5UWl4RFFVRkRMRVZCUVVVN1VVRkROVU1zVDBGQlR5eEpRVUZKTEVOQlFVTTdTMEZEWWp0SlFVVkVMRWxCUVVrc2IwSkJRVzlDTEVOQlFVTXNTVUZCU1N4RFFVRkRMRVZCUVVVN1VVRkRPVUlzVDBGQlR5eEpRVUZKTEVOQlFVTTdTMEZEWWp0SlFVTkVMRTlCUVU4c1MwRkJTeXhEUVVGRE8wRkJRMllzUTBGQlF6dEJRV1JFTEd0RFFXTkRPMEZCUlVRN096czdPMGRCUzBjN1FVRkRTQ3hUUVVGblFpeGpRVUZqTEVOQlF6VkNMRXRCUVdNc1JVRkRaQ3hGUVVORkxHRkJRV0VzUjBGQlJ5eGpRVUZqTEVWQlF6bENMR3RDUVVGclFpeEhRVUZITEV0QlFVc3NSMEZETTBJc1IwRkJSeXhGUVVGRk96dEpRVWRPTEVsQlEwVXNRMEZCUXl4aFFVRmhPMUZCUTJRc1EwRkJReXhOUVVGTkxFTkJRVU1zVTBGQlV5eERRVUZETEdGQlFXRXNRMEZCUXl4SlFVRkpMRU5CUVVNN1VVRkRja01zVDBGQlR5eGhRVUZoTEVOQlFVTXNUMEZCVHl4TFFVRkxMRkZCUVZFc1JVRkRla003VVVGRFFTeE5RVUZOTEVsQlFVa3NTMEZCU3l4RFFVTmlMREJGUVVFd1JTeERRVU16UlN4RFFVRkRPMHRCUTBnN1NVRkZSQ3hKUVVGSkxFdEJRVXNzV1VGQldTd3dRa0ZCWjBJc1JVRkJSVHRSUVVOeVF5eFBRVUZQTEV0QlFVc3NRMEZCUXl4VFFVRlRMRVZCUVVVc1EwRkJRenRMUVVNeFFqdEpRVVZFTEUxQlFVMHNWVUZCVlN4SFFVRjNReXhGUVVGRkxFTkJRVU03U1VGRk0wUXNTVUZEUlN4TFFVRkxPMUZCUTB3c1QwRkJUeXhMUVVGTExFdEJRVXNzVVVGQlVUdFJRVU42UWl4RFFVRkRMRXRCUVVzc1EwRkJReXhQUVVGUExFTkJRVU1zUzBGQlN5eERRVUZETzFGQlEzSkNMRTFCUVUwc1EwRkJReXhMUVVGblF5eEZRVUZGTEUxQlFVMHNRMEZCUXp0UlFVTm9SQ3hYUVVGWExFTkJRVVVzUzBGQmIwTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1JVRkRka1E3VVVGRFFTeE5RVUZOTEUxQlFVMHNSMEZCUnl4TFFVRTBReXhEUVVGRE8xRkJRelZFTEZWQlFWVXNRMEZCUXl4SlFVRkpMRWRCUVVjc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF6dFJRVVU1UWl4SlFVRkpMRTFCUVUwc1EwRkJReXhQUVVGUExFbEJRVWtzVDBGQlR5eE5RVUZOTEVOQlFVTXNUMEZCVHl4TFFVRkxMRkZCUVZFc1JVRkJSVHRaUVVONFJDeFZRVUZWTEVOQlFVTXNUMEZCVHl4SFFVRkhMRTFCUVUwc1EwRkJReXhQUVVGUExFTkJRVU03V1VGRmNFTXNTVUZCU1N4TlFVRk5MRU5CUVVNc1RVRkJUU3hGUVVGRkxFMUJRVTBzUTBGQlF5eEZRVUZGTzJkQ1FVTXhRaXhWUVVGVkxFTkJRVU1zU1VGQlNTeEhRVUZITEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNN1lVRkRMMEk3VTBGRFJqdGhRVUZOTzFsQlEwd3NWVUZCVlN4RFFVRkRMRTlCUVU4c1IwRkJSeXhyUWtGQmEwSXNRMEZEY0VNc1ZVRkJlVU1zUTBGQlF5eEpRVUZKTEVOQlEyaEVMRU5CUVVNN1dVRkZSaXhWUVVGVkxFTkJRVU1zU1VGQlNTeEhRVUZITEVWQlFVVXNZVUZCWVN4RlFVRkZMRzFDUVVGdFFpeERRVUZETEV0QlFVc3NRMEZCUXl4RlFVRkZMRU5CUVVNN1UwRkRha1U3UzBGRFJqdFRRVUZOTzFGQlEwd3NWVUZCVlN4RFFVRkRMRWxCUVVrc1IwRkJSeXhoUVVGaExFTkJRVU1zU1VGQlNTeERRVUZETzFGQlJYSkRMRTFCUVUwc1QwRkJUeXhUUVVGSkxFdEJRV0VzTUVOQlFVVXNUMEZCVHl4RFFVRkRPMUZCUlhoRExGVkJRVlVzUTBGQlF5eFBRVUZQTEVkQlFVY3NRMEZEYmtJc1QwRkJUeXhKUVVGSkxFOUJRVThzVDBGQlR5eExRVUZMTEZGQlFWRTdXVUZEY0VNc1EwRkJReXhEUVVGRExFOUJRVTg3V1VGRFZDeERRVUZETEVOQlFVTXNZVUZCWVN4RFFVRkRMRTlCUVU4c1EwRkRNVUlzUTBGQlF6dFJRVU5HTEZWQlFWVXNRMEZCUXl4SlFVRkpMRWRCUVVjc1JVRkJSU3hoUVVGaExFVkJRVVVzYlVKQlFXMUNMRU5CUVVNc1MwRkJTeXhEUVVGRExFVkJRVVVzUTBGQlF6dExRVU5xUlR0SlFVVkVMRTFCUVUwc1MwRkJTeXhUUVVGSkxFdEJRV0VzTUVOQlFVVXNTMEZCU3l4RFFVRkRPMGxCUlhCRExFbEJRVWtzYTBKQlFXdENMRWxCUVVrc1MwRkJTeXhKUVVGSkxFdEJRVXNzU1VGQlNTeFBRVUZQTEV0QlFVc3NTMEZCU3l4UlFVRlJMRVZCUVVVN1VVRkRja1VzVlVGQlZTeERRVUZETEV0QlFVc3NSMEZCUnl4TFFVRkxMRU5CUVVNN1MwRkRNVUk3U1VGRFJDeFBRVUZQTEZWQlFYZERMRU5CUVVNN1FVRkRiRVFzUTBGQlF6dEJRV3hGUkN4M1EwRnJSVU03UVVGRlJDeFhRVUZYTzBGQlJWZ3NVMEZCVXl4dlFrRkJiMElzUTBGQlF5eEpRVUZaTzBsQlEzaERMRTlCUVU4c1NVRkJTU3hKUVVGSkxFTkJRVU1zUzBGQlN5eEpRVUZKTEVsQlFVa3NTVUZCU1N4RFFVRkRMRXRCUVVzc1EwRkJRenRCUVVNeFF5eERRVUZETzBGQlJVUXNVMEZCVXl4dFFrRkJiVUlzUTBGQlF5eExRVUZqTzBsQlEzcERMRWxCUVVrc1MwRkJTeXhKUVVGSkxFOUJRVThzUzBGQlN5eExRVUZMTEZGQlFWRXNTVUZCU1N4RFFVRkRMRXRCUVVzc1EwRkJReXhQUVVGUExFTkJRVU1zUzBGQlN5eERRVUZETEVWQlFVVTdVVUZETDBRc1QwRkJUeXhOUVVGTkxFTkJRVU1zVFVGQlRTeERRVUZETEVWQlFVVXNSVUZCUlN4TFFVRkxMRU5CUVVNc1EwRkJRenRMUVVOcVF6dEpRVU5FTEU5QlFVOHNTMEZCU3l4RFFVRkRPMEZCUTJZc1EwRkJRenRCUVVWRUxGTkJRVk1zVFVGQlRTeERRVUZETEVkQlFUUkNMRVZCUVVVc1IwRkJWenRKUVVOMlJDeFBRVUZQTEUxQlFVMHNRMEZCUXl4VFFVRlRMRU5CUVVNc1kwRkJZeXhEUVVGRExFbEJRVWtzUTBGQlF5eEhRVUZITEVWQlFVVXNSMEZCUnl4RFFVRkRMRU5CUVVNN1FVRkRlRVFzUTBGQlF5SjkiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/eth-rpc-errors/dist/utils.js\n");

/***/ }),

/***/ "./node_modules/ethereum-cryptography/hash-utils.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethereum-cryptography/hash-utils.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nfunction createHashFunction(hashConstructor) {\r\n    return function (msg) {\r\n        var hash = hashConstructor();\r\n        hash.update(msg);\r\n        return Buffer.from(hash.digest());\r\n    };\r\n}\r\nexports.createHashFunction = createHashFunction;\r\n//# sourceMappingURL=hash-utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L2hhc2gtdXRpbHMuanMuanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2V0aGVyZXVtLWNyeXB0b2dyYXBoeS9oYXNoLXV0aWxzLmpzP2Y3MzUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZnVuY3Rpb24gY3JlYXRlSGFzaEZ1bmN0aW9uKGhhc2hDb25zdHJ1Y3Rvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtc2cpIHtcclxuICAgICAgICB2YXIgaGFzaCA9IGhhc2hDb25zdHJ1Y3RvcigpO1xyXG4gICAgICAgIGhhc2gudXBkYXRlKG1zZyk7XHJcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGhhc2guZGlnZXN0KCkpO1xyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmNyZWF0ZUhhc2hGdW5jdGlvbiA9IGNyZWF0ZUhhc2hGdW5jdGlvbjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzaC11dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ethereum-cryptography/hash-utils.js\n");

/***/ }),

/***/ "./node_modules/ethereum-cryptography/keccak.js":
/*!******************************************************!*\
  !*** ./node_modules/ethereum-cryptography/keccak.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nvar hash_utils_1 = __webpack_require__(/*! ./hash-utils */ \"./node_modules/ethereum-cryptography/hash-utils.js\");\r\nvar createKeccakHash = __webpack_require__(/*! keccak */ \"./node_modules/keccak/js.js\");\r\nexports.keccak224 = hash_utils_1.createHashFunction(function () {\r\n    return createKeccakHash(\"keccak224\");\r\n});\r\nexports.keccak256 = hash_utils_1.createHashFunction(function () {\r\n    return createKeccakHash(\"keccak256\");\r\n});\r\nexports.keccak384 = hash_utils_1.createHashFunction(function () {\r\n    return createKeccakHash(\"keccak384\");\r\n});\r\nexports.keccak512 = hash_utils_1.createHashFunction(function () {\r\n    return createKeccakHash(\"keccak512\");\r\n});\r\n//# sourceMappingURL=keccak.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L2tlY2Nhay5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsbUJBQU8sQ0FBQyx3RUFBYztBQUN6Qyx1QkFBdUIsbUJBQU8sQ0FBQywyQ0FBUTtBQUN2QyxpQkFBaUI7QUFDakI7QUFDQSxDQUFDO0FBQ0QsaUJBQWlCO0FBQ2pCO0FBQ0EsQ0FBQztBQUNELGlCQUFpQjtBQUNqQjtBQUNBLENBQUM7QUFDRCxpQkFBaUI7QUFDakI7QUFDQSxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2V0aGVyZXVtLWNyeXB0b2dyYXBoeS9rZWNjYWsuanM/OWIwMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgaGFzaF91dGlsc18xID0gcmVxdWlyZShcIi4vaGFzaC11dGlsc1wiKTtcclxudmFyIGNyZWF0ZUtlY2Nha0hhc2ggPSByZXF1aXJlKFwia2VjY2FrXCIpO1xyXG5leHBvcnRzLmtlY2NhazIyNCA9IGhhc2hfdXRpbHNfMS5jcmVhdGVIYXNoRnVuY3Rpb24oZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZUtlY2Nha0hhc2goXCJrZWNjYWsyMjRcIik7XHJcbn0pO1xyXG5leHBvcnRzLmtlY2NhazI1NiA9IGhhc2hfdXRpbHNfMS5jcmVhdGVIYXNoRnVuY3Rpb24oZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZUtlY2Nha0hhc2goXCJrZWNjYWsyNTZcIik7XHJcbn0pO1xyXG5leHBvcnRzLmtlY2NhazM4NCA9IGhhc2hfdXRpbHNfMS5jcmVhdGVIYXNoRnVuY3Rpb24oZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZUtlY2Nha0hhc2goXCJrZWNjYWszODRcIik7XHJcbn0pO1xyXG5leHBvcnRzLmtlY2NhazUxMiA9IGhhc2hfdXRpbHNfMS5jcmVhdGVIYXNoRnVuY3Rpb24oZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZUtlY2Nha0hhc2goXCJrZWNjYWs1MTJcIik7XHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1rZWNjYWsuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ethereum-cryptography/keccak.js\n");

/***/ }),

/***/ "./node_modules/ethereum-cryptography/random.js":
/*!******************************************************!*\
  !*** ./node_modules/ethereum-cryptography/random.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nvar randombytes = __webpack_require__(/*! randombytes */ \"./node_modules/randombytes/browser.js\");\r\nfunction getRandomBytes(bytes) {\r\n    return new Promise(function (resolve, reject) {\r\n        randombytes(bytes, function (err, resp) {\r\n            if (err) {\r\n                reject(err);\r\n                return;\r\n            }\r\n            resolve(resp);\r\n        });\r\n    });\r\n}\r\nexports.getRandomBytes = getRandomBytes;\r\nfunction getRandomBytesSync(bytes) {\r\n    return randombytes(bytes);\r\n}\r\nexports.getRandomBytesSync = getRandomBytesSync;\r\n//# sourceMappingURL=random.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L3JhbmRvbS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsbUJBQU8sQ0FBQywwREFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2V0aGVyZXVtLWNyeXB0b2dyYXBoeS9yYW5kb20uanM/NTk5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgcmFuZG9tYnl0ZXMgPSByZXF1aXJlKFwicmFuZG9tYnl0ZXNcIik7XHJcbmZ1bmN0aW9uIGdldFJhbmRvbUJ5dGVzKGJ5dGVzKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIHJhbmRvbWJ5dGVzKGJ5dGVzLCBmdW5jdGlvbiAoZXJyLCByZXNwKSB7XHJcbiAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc29sdmUocmVzcCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG5leHBvcnRzLmdldFJhbmRvbUJ5dGVzID0gZ2V0UmFuZG9tQnl0ZXM7XHJcbmZ1bmN0aW9uIGdldFJhbmRvbUJ5dGVzU3luYyhieXRlcykge1xyXG4gICAgcmV0dXJuIHJhbmRvbWJ5dGVzKGJ5dGVzKTtcclxufVxyXG5leHBvcnRzLmdldFJhbmRvbUJ5dGVzU3luYyA9IGdldFJhbmRvbUJ5dGVzU3luYztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmFuZG9tLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ethereum-cryptography/random.js\n");

/***/ }),

/***/ "./node_modules/ethereum-cryptography/secp256k1.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethereum-cryptography/secp256k1.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nvar secp256k1_1 = __webpack_require__(/*! secp256k1 */ \"./node_modules/secp256k1/elliptic.js\");\r\nvar random_1 = __webpack_require__(/*! ./random */ \"./node_modules/ethereum-cryptography/random.js\");\r\nvar SECP256K1_PRIVATE_KEY_SIZE = 32;\r\nfunction createPrivateKey() {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var pk;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    if (false) {}\r\n                    return [4 /*yield*/, random_1.getRandomBytes(SECP256K1_PRIVATE_KEY_SIZE)];\r\n                case 1:\r\n                    pk = _a.sent();\r\n                    if (secp256k1_1.privateKeyVerify(pk)) {\r\n                        return [2 /*return*/, pk];\r\n                    }\r\n                    return [3 /*break*/, 0];\r\n                case 2: return [2 /*return*/];\r\n            }\r\n        });\r\n    });\r\n}\r\nexports.createPrivateKey = createPrivateKey;\r\nfunction createPrivateKeySync() {\r\n    while (true) {\r\n        var pk = random_1.getRandomBytesSync(SECP256K1_PRIVATE_KEY_SIZE);\r\n        if (secp256k1_1.privateKeyVerify(pk)) {\r\n            return pk;\r\n        }\r\n    }\r\n}\r\nexports.createPrivateKeySync = createPrivateKeySync;\r\n__export(__webpack_require__(/*! secp256k1 */ \"./node_modules/secp256k1/elliptic.js\"));\r\n//# sourceMappingURL=secp256k1.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L3NlY3AyNTZrMS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGNBQWMsNkJBQTZCLDBCQUEwQixjQUFjLHFCQUFxQjtBQUN4RyxpQkFBaUIsb0RBQW9ELHFFQUFxRSxjQUFjO0FBQ3hKLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLG1DQUFtQyxTQUFTO0FBQzVDLG1DQUFtQyxXQUFXLFVBQVU7QUFDeEQsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQSw4R0FBOEcsT0FBTztBQUNySCxpRkFBaUYsaUJBQWlCO0FBQ2xHLHlEQUF5RCxnQkFBZ0IsUUFBUTtBQUNqRiwrQ0FBK0MsZ0JBQWdCLGdCQUFnQjtBQUMvRTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsVUFBVSxZQUFZLGFBQWEsU0FBUyxVQUFVO0FBQ3RELG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLG1CQUFPLENBQUMsdURBQVc7QUFDckMsZUFBZSxtQkFBTyxDQUFDLGdFQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEtBQUssRUFBRSxFQUF3QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsU0FBUyxtQkFBTyxDQUFDLHVEQUFXO0FBQzVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9ldGhlcmV1bS1jcnlwdG9ncmFwaHkvc2VjcDI1NmsxLmpzPzI3Y2UiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufTtcclxudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59O1xyXG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbn1cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgc2VjcDI1NmsxXzEgPSByZXF1aXJlKFwic2VjcDI1NmsxXCIpO1xyXG52YXIgcmFuZG9tXzEgPSByZXF1aXJlKFwiLi9yYW5kb21cIik7XHJcbnZhciBTRUNQMjU2SzFfUFJJVkFURV9LRVlfU0laRSA9IDMyO1xyXG5mdW5jdGlvbiBjcmVhdGVQcml2YXRlS2V5KCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBwaztcclxuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRydWUpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHJhbmRvbV8xLmdldFJhbmRvbUJ5dGVzKFNFQ1AyNTZLMV9QUklWQVRFX0tFWV9TSVpFKV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgcGsgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlY3AyNTZrMV8xLnByaXZhdGVLZXlWZXJpZnkocGspKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBwa107XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDBdO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzIgLypyZXR1cm4qL107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydHMuY3JlYXRlUHJpdmF0ZUtleSA9IGNyZWF0ZVByaXZhdGVLZXk7XHJcbmZ1bmN0aW9uIGNyZWF0ZVByaXZhdGVLZXlTeW5jKCkge1xyXG4gICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICB2YXIgcGsgPSByYW5kb21fMS5nZXRSYW5kb21CeXRlc1N5bmMoU0VDUDI1NksxX1BSSVZBVEVfS0VZX1NJWkUpO1xyXG4gICAgICAgIGlmIChzZWNwMjU2azFfMS5wcml2YXRlS2V5VmVyaWZ5KHBrKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcGs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuY3JlYXRlUHJpdmF0ZUtleVN5bmMgPSBjcmVhdGVQcml2YXRlS2V5U3luYztcclxuX19leHBvcnQocmVxdWlyZShcInNlY3AyNTZrMVwiKSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlY3AyNTZrMS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ethereum-cryptography/secp256k1.js\n");

/***/ }),

/***/ "./node_modules/ethereumjs-util/dist.browser/account.js":
/*!**************************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist.browser/account.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\r\nvar __read = (this && this.__read) || function (o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n};\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.isZeroAddress = exports.zeroAddress = exports.importPublic = exports.privateToAddress = exports.privateToPublic = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isValidAddress = exports.Account = void 0;\r\nvar assert_1 = __importDefault(__webpack_require__(/*! assert */ \"./node_modules/assert/build/assert.js\"));\r\nvar externals_1 = __webpack_require__(/*! ./externals */ \"./node_modules/ethereumjs-util/dist.browser/externals.js\");\r\nvar secp256k1_1 = __webpack_require__(/*! ethereum-cryptography/secp256k1 */ \"./node_modules/ethereum-cryptography/secp256k1.js\");\r\nvar internal_1 = __webpack_require__(/*! ./internal */ \"./node_modules/ethereumjs-util/dist.browser/internal.js\");\r\nvar constants_1 = __webpack_require__(/*! ./constants */ \"./node_modules/ethereumjs-util/dist.browser/constants.js\");\r\nvar bytes_1 = __webpack_require__(/*! ./bytes */ \"./node_modules/ethereumjs-util/dist.browser/bytes.js\");\r\nvar hash_1 = __webpack_require__(/*! ./hash */ \"./node_modules/ethereumjs-util/dist.browser/hash.js\");\r\nvar helpers_1 = __webpack_require__(/*! ./helpers */ \"./node_modules/ethereumjs-util/dist.browser/helpers.js\");\r\nvar types_1 = __webpack_require__(/*! ./types */ \"./node_modules/ethereumjs-util/dist.browser/types.js\");\r\nvar Account = /** @class */ (function () {\r\n    /**\r\n     * This constructor assigns and validates the values.\r\n     * Use the static factory methods to assist in creating an Account from varying data types.\r\n     */\r\n    function Account(nonce, balance, stateRoot, codeHash) {\r\n        if (nonce === void 0) { nonce = new externals_1.BN(0); }\r\n        if (balance === void 0) { balance = new externals_1.BN(0); }\r\n        if (stateRoot === void 0) { stateRoot = constants_1.KECCAK256_RLP; }\r\n        if (codeHash === void 0) { codeHash = constants_1.KECCAK256_NULL; }\r\n        this.nonce = nonce;\r\n        this.balance = balance;\r\n        this.stateRoot = stateRoot;\r\n        this.codeHash = codeHash;\r\n        this._validate();\r\n    }\r\n    Account.fromAccountData = function (accountData) {\r\n        var nonce = accountData.nonce, balance = accountData.balance, stateRoot = accountData.stateRoot, codeHash = accountData.codeHash;\r\n        return new Account(nonce ? new externals_1.BN((0, bytes_1.toBuffer)(nonce)) : undefined, balance ? new externals_1.BN((0, bytes_1.toBuffer)(balance)) : undefined, stateRoot ? (0, bytes_1.toBuffer)(stateRoot) : undefined, codeHash ? (0, bytes_1.toBuffer)(codeHash) : undefined);\r\n    };\r\n    Account.fromRlpSerializedAccount = function (serialized) {\r\n        var values = externals_1.rlp.decode(serialized);\r\n        if (!Array.isArray(values)) {\r\n            throw new Error('Invalid serialized account input. Must be array');\r\n        }\r\n        return this.fromValuesArray(values);\r\n    };\r\n    Account.fromValuesArray = function (values) {\r\n        var _a = __read(values, 4), nonce = _a[0], balance = _a[1], stateRoot = _a[2], codeHash = _a[3];\r\n        return new Account(new externals_1.BN(nonce), new externals_1.BN(balance), stateRoot, codeHash);\r\n    };\r\n    Account.prototype._validate = function () {\r\n        if (this.nonce.lt(new externals_1.BN(0))) {\r\n            throw new Error('nonce must be greater than zero');\r\n        }\r\n        if (this.balance.lt(new externals_1.BN(0))) {\r\n            throw new Error('balance must be greater than zero');\r\n        }\r\n        if (this.stateRoot.length !== 32) {\r\n            throw new Error('stateRoot must have a length of 32');\r\n        }\r\n        if (this.codeHash.length !== 32) {\r\n            throw new Error('codeHash must have a length of 32');\r\n        }\r\n    };\r\n    /**\r\n     * Returns a Buffer Array of the raw Buffers for the account, in order.\r\n     */\r\n    Account.prototype.raw = function () {\r\n        return [\r\n            (0, types_1.bnToUnpaddedBuffer)(this.nonce),\r\n            (0, types_1.bnToUnpaddedBuffer)(this.balance),\r\n            this.stateRoot,\r\n            this.codeHash,\r\n        ];\r\n    };\r\n    /**\r\n     * Returns the RLP serialization of the account as a `Buffer`.\r\n     */\r\n    Account.prototype.serialize = function () {\r\n        return externals_1.rlp.encode(this.raw());\r\n    };\r\n    /**\r\n     * Returns a `Boolean` determining if the account is a contract.\r\n     */\r\n    Account.prototype.isContract = function () {\r\n        return !this.codeHash.equals(constants_1.KECCAK256_NULL);\r\n    };\r\n    /**\r\n     * Returns a `Boolean` determining if the account is empty complying to the definition of\r\n     * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):\r\n     * \"An account is considered empty when it has no code and zero nonce and zero balance.\"\r\n     */\r\n    Account.prototype.isEmpty = function () {\r\n        return this.balance.isZero() && this.nonce.isZero() && this.codeHash.equals(constants_1.KECCAK256_NULL);\r\n    };\r\n    return Account;\r\n}());\r\nexports.Account = Account;\r\n/**\r\n * Checks if the address is a valid. Accepts checksummed addresses too.\r\n */\r\nvar isValidAddress = function (hexAddress) {\r\n    try {\r\n        (0, helpers_1.assertIsString)(hexAddress);\r\n    }\r\n    catch (e) {\r\n        return false;\r\n    }\r\n    return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);\r\n};\r\nexports.isValidAddress = isValidAddress;\r\n/**\r\n * Returns a checksummed address.\r\n *\r\n * If an eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\r\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\r\n * For more details see [EIP-1191](https://eips.ethereum.org/EIPS/eip-1191).\r\n *\r\n * WARNING: Checksums with and without the chainId will differ and the EIP-1191 checksum is not\r\n * backwards compatible to the original widely adopted checksum format standard introduced in\r\n * [EIP-55](https://eips.ethereum.org/EIPS/eip-55), so this will break in existing applications.\r\n * Usage of this EIP is therefore discouraged unless you have a very targeted use case.\r\n */\r\nvar toChecksumAddress = function (hexAddress, eip1191ChainId) {\r\n    (0, helpers_1.assertIsHexString)(hexAddress);\r\n    var address = (0, internal_1.stripHexPrefix)(hexAddress).toLowerCase();\r\n    var prefix = '';\r\n    if (eip1191ChainId) {\r\n        var chainId = (0, types_1.toType)(eip1191ChainId, types_1.TypeOutput.BN);\r\n        prefix = chainId.toString() + '0x';\r\n    }\r\n    var hash = (0, hash_1.keccakFromString)(prefix + address).toString('hex');\r\n    var ret = '0x';\r\n    for (var i = 0; i < address.length; i++) {\r\n        if (parseInt(hash[i], 16) >= 8) {\r\n            ret += address[i].toUpperCase();\r\n        }\r\n        else {\r\n            ret += address[i];\r\n        }\r\n    }\r\n    return ret;\r\n};\r\nexports.toChecksumAddress = toChecksumAddress;\r\n/**\r\n * Checks if the address is a valid checksummed address.\r\n *\r\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\r\n */\r\nvar isValidChecksumAddress = function (hexAddress, eip1191ChainId) {\r\n    return (0, exports.isValidAddress)(hexAddress) && (0, exports.toChecksumAddress)(hexAddress, eip1191ChainId) === hexAddress;\r\n};\r\nexports.isValidChecksumAddress = isValidChecksumAddress;\r\n/**\r\n * Generates an address of a newly created contract.\r\n * @param from The address which is creating this new address\r\n * @param nonce The nonce of the from account\r\n */\r\nvar generateAddress = function (from, nonce) {\r\n    (0, helpers_1.assertIsBuffer)(from);\r\n    (0, helpers_1.assertIsBuffer)(nonce);\r\n    var nonceBN = new externals_1.BN(nonce);\r\n    if (nonceBN.isZero()) {\r\n        // in RLP we want to encode null in the case of zero nonce\r\n        // read the RLP documentation for an answer if you dare\r\n        return (0, hash_1.rlphash)([from, null]).slice(-20);\r\n    }\r\n    // Only take the lower 160bits of the hash\r\n    return (0, hash_1.rlphash)([from, Buffer.from(nonceBN.toArray())]).slice(-20);\r\n};\r\nexports.generateAddress = generateAddress;\r\n/**\r\n * Generates an address for a contract created using CREATE2.\r\n * @param from The address which is creating this new address\r\n * @param salt A salt\r\n * @param initCode The init code of the contract being created\r\n */\r\nvar generateAddress2 = function (from, salt, initCode) {\r\n    (0, helpers_1.assertIsBuffer)(from);\r\n    (0, helpers_1.assertIsBuffer)(salt);\r\n    (0, helpers_1.assertIsBuffer)(initCode);\r\n    (0, assert_1.default)(from.length === 20);\r\n    (0, assert_1.default)(salt.length === 32);\r\n    var address = (0, hash_1.keccak256)(Buffer.concat([Buffer.from('ff', 'hex'), from, salt, (0, hash_1.keccak256)(initCode)]));\r\n    return address.slice(-20);\r\n};\r\nexports.generateAddress2 = generateAddress2;\r\n/**\r\n * Checks if the private key satisfies the rules of the curve secp256k1.\r\n */\r\nvar isValidPrivate = function (privateKey) {\r\n    return (0, secp256k1_1.privateKeyVerify)(privateKey);\r\n};\r\nexports.isValidPrivate = isValidPrivate;\r\n/**\r\n * Checks if the public key satisfies the rules of the curve secp256k1\r\n * and the requirements of Ethereum.\r\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\r\n * @param sanitize Accept public keys in other formats\r\n */\r\nvar isValidPublic = function (publicKey, sanitize) {\r\n    if (sanitize === void 0) { sanitize = false; }\r\n    (0, helpers_1.assertIsBuffer)(publicKey);\r\n    if (publicKey.length === 64) {\r\n        // Convert to SEC1 for secp256k1\r\n        return (0, secp256k1_1.publicKeyVerify)(Buffer.concat([Buffer.from([4]), publicKey]));\r\n    }\r\n    if (!sanitize) {\r\n        return false;\r\n    }\r\n    return (0, secp256k1_1.publicKeyVerify)(publicKey);\r\n};\r\nexports.isValidPublic = isValidPublic;\r\n/**\r\n * Returns the ethereum address of a given public key.\r\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\r\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\r\n * @param sanitize Accept public keys in other formats\r\n */\r\nvar pubToAddress = function (pubKey, sanitize) {\r\n    if (sanitize === void 0) { sanitize = false; }\r\n    (0, helpers_1.assertIsBuffer)(pubKey);\r\n    if (sanitize && pubKey.length !== 64) {\r\n        pubKey = Buffer.from((0, secp256k1_1.publicKeyConvert)(pubKey, false).slice(1));\r\n    }\r\n    (0, assert_1.default)(pubKey.length === 64);\r\n    // Only take the lower 160bits of the hash\r\n    return (0, hash_1.keccak)(pubKey).slice(-20);\r\n};\r\nexports.pubToAddress = pubToAddress;\r\nexports.publicToAddress = exports.pubToAddress;\r\n/**\r\n * Returns the ethereum public key of a given private key.\r\n * @param privateKey A private key must be 256 bits wide\r\n */\r\nvar privateToPublic = function (privateKey) {\r\n    (0, helpers_1.assertIsBuffer)(privateKey);\r\n    // skip the type flag and use the X, Y points\r\n    return Buffer.from((0, secp256k1_1.publicKeyCreate)(privateKey, false)).slice(1);\r\n};\r\nexports.privateToPublic = privateToPublic;\r\n/**\r\n * Returns the ethereum address of a given private key.\r\n * @param privateKey A private key must be 256 bits wide\r\n */\r\nvar privateToAddress = function (privateKey) {\r\n    return (0, exports.publicToAddress)((0, exports.privateToPublic)(privateKey));\r\n};\r\nexports.privateToAddress = privateToAddress;\r\n/**\r\n * Converts a public key to the Ethereum format.\r\n */\r\nvar importPublic = function (publicKey) {\r\n    (0, helpers_1.assertIsBuffer)(publicKey);\r\n    if (publicKey.length !== 64) {\r\n        publicKey = Buffer.from((0, secp256k1_1.publicKeyConvert)(publicKey, false).slice(1));\r\n    }\r\n    return publicKey;\r\n};\r\nexports.importPublic = importPublic;\r\n/**\r\n * Returns the zero address.\r\n */\r\nvar zeroAddress = function () {\r\n    var addressLength = 20;\r\n    var addr = (0, bytes_1.zeros)(addressLength);\r\n    return (0, bytes_1.bufferToHex)(addr);\r\n};\r\nexports.zeroAddress = zeroAddress;\r\n/**\r\n * Checks if a given address is the zero address.\r\n */\r\nvar isZeroAddress = function (hexAddress) {\r\n    try {\r\n        (0, helpers_1.assertIsString)(hexAddress);\r\n    }\r\n    catch (e) {\r\n        return false;\r\n    }\r\n    var zeroAddr = (0, exports.zeroAddress)();\r\n    return zeroAddr === hexAddress;\r\n};\r\nexports.isZeroAddress = isZeroAddress;\r\n//# sourceMappingURL=account.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QuYnJvd3Nlci9hY2NvdW50LmpzLmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCLEdBQUcsbUJBQW1CLEdBQUcsb0JBQW9CLEdBQUcsd0JBQXdCLEdBQUcsdUJBQXVCLEdBQUcsdUJBQXVCLEdBQUcsb0JBQW9CLEdBQUcscUJBQXFCLEdBQUcsc0JBQXNCLEdBQUcsd0JBQXdCLEdBQUcsdUJBQXVCLEdBQUcsOEJBQThCLEdBQUcseUJBQXlCLEdBQUcsc0JBQXNCLEdBQUcsZUFBZTtBQUN0WCwrQkFBK0IsbUJBQU8sQ0FBQyxxREFBUTtBQUMvQyxrQkFBa0IsbUJBQU8sQ0FBQyw2RUFBYTtBQUN2QyxrQkFBa0IsbUJBQU8sQ0FBQywwRkFBaUM7QUFDM0QsaUJBQWlCLG1CQUFPLENBQUMsMkVBQVk7QUFDckMsa0JBQWtCLG1CQUFPLENBQUMsNkVBQWE7QUFDdkMsY0FBYyxtQkFBTyxDQUFDLHFFQUFTO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQyxtRUFBUTtBQUM3QixnQkFBZ0IsbUJBQU8sQ0FBQyx5RUFBVztBQUNuQyxjQUFjLG1CQUFPLENBQUMscUVBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLGtDQUFrQztBQUNsQyxvQ0FBb0M7QUFDcEMsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixHQUFHO0FBQzlCO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsTUFBTTtBQUM1QztBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsTUFBTSxTQUFTLE1BQU07QUFDN0Q7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE1BQU0sU0FBUyxNQUFNO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0LmJyb3dzZXIvYWNjb3VudC5qcz85MzVmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn07XHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5pc1plcm9BZGRyZXNzID0gZXhwb3J0cy56ZXJvQWRkcmVzcyA9IGV4cG9ydHMuaW1wb3J0UHVibGljID0gZXhwb3J0cy5wcml2YXRlVG9BZGRyZXNzID0gZXhwb3J0cy5wcml2YXRlVG9QdWJsaWMgPSBleHBvcnRzLnB1YmxpY1RvQWRkcmVzcyA9IGV4cG9ydHMucHViVG9BZGRyZXNzID0gZXhwb3J0cy5pc1ZhbGlkUHVibGljID0gZXhwb3J0cy5pc1ZhbGlkUHJpdmF0ZSA9IGV4cG9ydHMuZ2VuZXJhdGVBZGRyZXNzMiA9IGV4cG9ydHMuZ2VuZXJhdGVBZGRyZXNzID0gZXhwb3J0cy5pc1ZhbGlkQ2hlY2tzdW1BZGRyZXNzID0gZXhwb3J0cy50b0NoZWNrc3VtQWRkcmVzcyA9IGV4cG9ydHMuaXNWYWxpZEFkZHJlc3MgPSBleHBvcnRzLkFjY291bnQgPSB2b2lkIDA7XHJcbnZhciBhc3NlcnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYXNzZXJ0XCIpKTtcclxudmFyIGV4dGVybmFsc18xID0gcmVxdWlyZShcIi4vZXh0ZXJuYWxzXCIpO1xyXG52YXIgc2VjcDI1NmsxXzEgPSByZXF1aXJlKFwiZXRoZXJldW0tY3J5cHRvZ3JhcGh5L3NlY3AyNTZrMVwiKTtcclxudmFyIGludGVybmFsXzEgPSByZXF1aXJlKFwiLi9pbnRlcm5hbFwiKTtcclxudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xyXG52YXIgYnl0ZXNfMSA9IHJlcXVpcmUoXCIuL2J5dGVzXCIpO1xyXG52YXIgaGFzaF8xID0gcmVxdWlyZShcIi4vaGFzaFwiKTtcclxudmFyIGhlbHBlcnNfMSA9IHJlcXVpcmUoXCIuL2hlbHBlcnNcIik7XHJcbnZhciB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XHJcbnZhciBBY2NvdW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGNvbnN0cnVjdG9yIGFzc2lnbnMgYW5kIHZhbGlkYXRlcyB0aGUgdmFsdWVzLlxyXG4gICAgICogVXNlIHRoZSBzdGF0aWMgZmFjdG9yeSBtZXRob2RzIHRvIGFzc2lzdCBpbiBjcmVhdGluZyBhbiBBY2NvdW50IGZyb20gdmFyeWluZyBkYXRhIHR5cGVzLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBBY2NvdW50KG5vbmNlLCBiYWxhbmNlLCBzdGF0ZVJvb3QsIGNvZGVIYXNoKSB7XHJcbiAgICAgICAgaWYgKG5vbmNlID09PSB2b2lkIDApIHsgbm9uY2UgPSBuZXcgZXh0ZXJuYWxzXzEuQk4oMCk7IH1cclxuICAgICAgICBpZiAoYmFsYW5jZSA9PT0gdm9pZCAwKSB7IGJhbGFuY2UgPSBuZXcgZXh0ZXJuYWxzXzEuQk4oMCk7IH1cclxuICAgICAgICBpZiAoc3RhdGVSb290ID09PSB2b2lkIDApIHsgc3RhdGVSb290ID0gY29uc3RhbnRzXzEuS0VDQ0FLMjU2X1JMUDsgfVxyXG4gICAgICAgIGlmIChjb2RlSGFzaCA9PT0gdm9pZCAwKSB7IGNvZGVIYXNoID0gY29uc3RhbnRzXzEuS0VDQ0FLMjU2X05VTEw7IH1cclxuICAgICAgICB0aGlzLm5vbmNlID0gbm9uY2U7XHJcbiAgICAgICAgdGhpcy5iYWxhbmNlID0gYmFsYW5jZTtcclxuICAgICAgICB0aGlzLnN0YXRlUm9vdCA9IHN0YXRlUm9vdDtcclxuICAgICAgICB0aGlzLmNvZGVIYXNoID0gY29kZUhhc2g7XHJcbiAgICAgICAgdGhpcy5fdmFsaWRhdGUoKTtcclxuICAgIH1cclxuICAgIEFjY291bnQuZnJvbUFjY291bnREYXRhID0gZnVuY3Rpb24gKGFjY291bnREYXRhKSB7XHJcbiAgICAgICAgdmFyIG5vbmNlID0gYWNjb3VudERhdGEubm9uY2UsIGJhbGFuY2UgPSBhY2NvdW50RGF0YS5iYWxhbmNlLCBzdGF0ZVJvb3QgPSBhY2NvdW50RGF0YS5zdGF0ZVJvb3QsIGNvZGVIYXNoID0gYWNjb3VudERhdGEuY29kZUhhc2g7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBBY2NvdW50KG5vbmNlID8gbmV3IGV4dGVybmFsc18xLkJOKCgwLCBieXRlc18xLnRvQnVmZmVyKShub25jZSkpIDogdW5kZWZpbmVkLCBiYWxhbmNlID8gbmV3IGV4dGVybmFsc18xLkJOKCgwLCBieXRlc18xLnRvQnVmZmVyKShiYWxhbmNlKSkgOiB1bmRlZmluZWQsIHN0YXRlUm9vdCA/ICgwLCBieXRlc18xLnRvQnVmZmVyKShzdGF0ZVJvb3QpIDogdW5kZWZpbmVkLCBjb2RlSGFzaCA/ICgwLCBieXRlc18xLnRvQnVmZmVyKShjb2RlSGFzaCkgOiB1bmRlZmluZWQpO1xyXG4gICAgfTtcclxuICAgIEFjY291bnQuZnJvbVJscFNlcmlhbGl6ZWRBY2NvdW50ID0gZnVuY3Rpb24gKHNlcmlhbGl6ZWQpIHtcclxuICAgICAgICB2YXIgdmFsdWVzID0gZXh0ZXJuYWxzXzEucmxwLmRlY29kZShzZXJpYWxpemVkKTtcclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VyaWFsaXplZCBhY2NvdW50IGlucHV0LiBNdXN0IGJlIGFycmF5Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmZyb21WYWx1ZXNBcnJheSh2YWx1ZXMpO1xyXG4gICAgfTtcclxuICAgIEFjY291bnQuZnJvbVZhbHVlc0FycmF5ID0gZnVuY3Rpb24gKHZhbHVlcykge1xyXG4gICAgICAgIHZhciBfYSA9IF9fcmVhZCh2YWx1ZXMsIDQpLCBub25jZSA9IF9hWzBdLCBiYWxhbmNlID0gX2FbMV0sIHN0YXRlUm9vdCA9IF9hWzJdLCBjb2RlSGFzaCA9IF9hWzNdO1xyXG4gICAgICAgIHJldHVybiBuZXcgQWNjb3VudChuZXcgZXh0ZXJuYWxzXzEuQk4obm9uY2UpLCBuZXcgZXh0ZXJuYWxzXzEuQk4oYmFsYW5jZSksIHN0YXRlUm9vdCwgY29kZUhhc2gpO1xyXG4gICAgfTtcclxuICAgIEFjY291bnQucHJvdG90eXBlLl92YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5ub25jZS5sdChuZXcgZXh0ZXJuYWxzXzEuQk4oMCkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm9uY2UgbXVzdCBiZSBncmVhdGVyIHRoYW4gemVybycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5iYWxhbmNlLmx0KG5ldyBleHRlcm5hbHNfMS5CTigwKSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWxhbmNlIG11c3QgYmUgZ3JlYXRlciB0aGFuIHplcm8nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGVSb290Lmxlbmd0aCAhPT0gMzIpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdGF0ZVJvb3QgbXVzdCBoYXZlIGEgbGVuZ3RoIG9mIDMyJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmNvZGVIYXNoLmxlbmd0aCAhPT0gMzIpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb2RlSGFzaCBtdXN0IGhhdmUgYSBsZW5ndGggb2YgMzInKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgQnVmZmVyIEFycmF5IG9mIHRoZSByYXcgQnVmZmVycyBmb3IgdGhlIGFjY291bnQsIGluIG9yZGVyLlxyXG4gICAgICovXHJcbiAgICBBY2NvdW50LnByb3RvdHlwZS5yYXcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgKDAsIHR5cGVzXzEuYm5Ub1VucGFkZGVkQnVmZmVyKSh0aGlzLm5vbmNlKSxcclxuICAgICAgICAgICAgKDAsIHR5cGVzXzEuYm5Ub1VucGFkZGVkQnVmZmVyKSh0aGlzLmJhbGFuY2UpLFxyXG4gICAgICAgICAgICB0aGlzLnN0YXRlUm9vdCxcclxuICAgICAgICAgICAgdGhpcy5jb2RlSGFzaCxcclxuICAgICAgICBdO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgUkxQIHNlcmlhbGl6YXRpb24gb2YgdGhlIGFjY291bnQgYXMgYSBgQnVmZmVyYC5cclxuICAgICAqL1xyXG4gICAgQWNjb3VudC5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBleHRlcm5hbHNfMS5ybHAuZW5jb2RlKHRoaXMucmF3KCkpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGBCb29sZWFuYCBkZXRlcm1pbmluZyBpZiB0aGUgYWNjb3VudCBpcyBhIGNvbnRyYWN0LlxyXG4gICAgICovXHJcbiAgICBBY2NvdW50LnByb3RvdHlwZS5pc0NvbnRyYWN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5jb2RlSGFzaC5lcXVhbHMoY29uc3RhbnRzXzEuS0VDQ0FLMjU2X05VTEwpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGBCb29sZWFuYCBkZXRlcm1pbmluZyBpZiB0aGUgYWNjb3VudCBpcyBlbXB0eSBjb21wbHlpbmcgdG8gdGhlIGRlZmluaXRpb24gb2ZcclxuICAgICAqIGFjY291bnQgZW1wdGluZXNzIGluIFtFSVAtMTYxXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTE2MSk6XHJcbiAgICAgKiBcIkFuIGFjY291bnQgaXMgY29uc2lkZXJlZCBlbXB0eSB3aGVuIGl0IGhhcyBubyBjb2RlIGFuZCB6ZXJvIG5vbmNlIGFuZCB6ZXJvIGJhbGFuY2UuXCJcclxuICAgICAqL1xyXG4gICAgQWNjb3VudC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5iYWxhbmNlLmlzWmVybygpICYmIHRoaXMubm9uY2UuaXNaZXJvKCkgJiYgdGhpcy5jb2RlSGFzaC5lcXVhbHMoY29uc3RhbnRzXzEuS0VDQ0FLMjU2X05VTEwpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBBY2NvdW50O1xyXG59KCkpO1xyXG5leHBvcnRzLkFjY291bnQgPSBBY2NvdW50O1xyXG4vKipcclxuICogQ2hlY2tzIGlmIHRoZSBhZGRyZXNzIGlzIGEgdmFsaWQuIEFjY2VwdHMgY2hlY2tzdW1tZWQgYWRkcmVzc2VzIHRvby5cclxuICovXHJcbnZhciBpc1ZhbGlkQWRkcmVzcyA9IGZ1bmN0aW9uIChoZXhBZGRyZXNzKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNTdHJpbmcpKGhleEFkZHJlc3MpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gL14weFswLTlhLWZBLUZdezQwfSQvLnRlc3QoaGV4QWRkcmVzcyk7XHJcbn07XHJcbmV4cG9ydHMuaXNWYWxpZEFkZHJlc3MgPSBpc1ZhbGlkQWRkcmVzcztcclxuLyoqXHJcbiAqIFJldHVybnMgYSBjaGVja3N1bW1lZCBhZGRyZXNzLlxyXG4gKlxyXG4gKiBJZiBhbiBlaXAxMTkxQ2hhaW5JZCBpcyBwcm92aWRlZCwgdGhlIGNoYWluSWQgd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgY2hlY2tzdW0gY2FsY3VsYXRpb24uIFRoaXNcclxuICogaGFzIHRoZSBlZmZlY3Qgb2YgY2hlY2tzdW1tZWQgYWRkcmVzc2VzIGZvciBvbmUgY2hhaW4gaGF2aW5nIGludmFsaWQgY2hlY2tzdW1zIGZvciBvdGhlcnMuXHJcbiAqIEZvciBtb3JlIGRldGFpbHMgc2VlIFtFSVAtMTE5MV0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC0xMTkxKS5cclxuICpcclxuICogV0FSTklORzogQ2hlY2tzdW1zIHdpdGggYW5kIHdpdGhvdXQgdGhlIGNoYWluSWQgd2lsbCBkaWZmZXIgYW5kIHRoZSBFSVAtMTE5MSBjaGVja3N1bSBpcyBub3RcclxuICogYmFja3dhcmRzIGNvbXBhdGlibGUgdG8gdGhlIG9yaWdpbmFsIHdpZGVseSBhZG9wdGVkIGNoZWNrc3VtIGZvcm1hdCBzdGFuZGFyZCBpbnRyb2R1Y2VkIGluXHJcbiAqIFtFSVAtNTVdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNTUpLCBzbyB0aGlzIHdpbGwgYnJlYWsgaW4gZXhpc3RpbmcgYXBwbGljYXRpb25zLlxyXG4gKiBVc2FnZSBvZiB0aGlzIEVJUCBpcyB0aGVyZWZvcmUgZGlzY291cmFnZWQgdW5sZXNzIHlvdSBoYXZlIGEgdmVyeSB0YXJnZXRlZCB1c2UgY2FzZS5cclxuICovXHJcbnZhciB0b0NoZWNrc3VtQWRkcmVzcyA9IGZ1bmN0aW9uIChoZXhBZGRyZXNzLCBlaXAxMTkxQ2hhaW5JZCkge1xyXG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc0hleFN0cmluZykoaGV4QWRkcmVzcyk7XHJcbiAgICB2YXIgYWRkcmVzcyA9ICgwLCBpbnRlcm5hbF8xLnN0cmlwSGV4UHJlZml4KShoZXhBZGRyZXNzKS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgdmFyIHByZWZpeCA9ICcnO1xyXG4gICAgaWYgKGVpcDExOTFDaGFpbklkKSB7XHJcbiAgICAgICAgdmFyIGNoYWluSWQgPSAoMCwgdHlwZXNfMS50b1R5cGUpKGVpcDExOTFDaGFpbklkLCB0eXBlc18xLlR5cGVPdXRwdXQuQk4pO1xyXG4gICAgICAgIHByZWZpeCA9IGNoYWluSWQudG9TdHJpbmcoKSArICcweCc7XHJcbiAgICB9XHJcbiAgICB2YXIgaGFzaCA9ICgwLCBoYXNoXzEua2VjY2FrRnJvbVN0cmluZykocHJlZml4ICsgYWRkcmVzcykudG9TdHJpbmcoJ2hleCcpO1xyXG4gICAgdmFyIHJldCA9ICcweCc7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFkZHJlc3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAocGFyc2VJbnQoaGFzaFtpXSwgMTYpID49IDgpIHtcclxuICAgICAgICAgICAgcmV0ICs9IGFkZHJlc3NbaV0udG9VcHBlckNhc2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldCArPSBhZGRyZXNzW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXQ7XHJcbn07XHJcbmV4cG9ydHMudG9DaGVja3N1bUFkZHJlc3MgPSB0b0NoZWNrc3VtQWRkcmVzcztcclxuLyoqXHJcbiAqIENoZWNrcyBpZiB0aGUgYWRkcmVzcyBpcyBhIHZhbGlkIGNoZWNrc3VtbWVkIGFkZHJlc3MuXHJcbiAqXHJcbiAqIFNlZSB0b0NoZWNrc3VtQWRkcmVzcycgZG9jdW1lbnRhdGlvbiBmb3IgZGV0YWlscyBhYm91dCB0aGUgZWlwMTE5MUNoYWluSWQgcGFyYW1ldGVyLlxyXG4gKi9cclxudmFyIGlzVmFsaWRDaGVja3N1bUFkZHJlc3MgPSBmdW5jdGlvbiAoaGV4QWRkcmVzcywgZWlwMTE5MUNoYWluSWQpIHtcclxuICAgIHJldHVybiAoMCwgZXhwb3J0cy5pc1ZhbGlkQWRkcmVzcykoaGV4QWRkcmVzcykgJiYgKDAsIGV4cG9ydHMudG9DaGVja3N1bUFkZHJlc3MpKGhleEFkZHJlc3MsIGVpcDExOTFDaGFpbklkKSA9PT0gaGV4QWRkcmVzcztcclxufTtcclxuZXhwb3J0cy5pc1ZhbGlkQ2hlY2tzdW1BZGRyZXNzID0gaXNWYWxpZENoZWNrc3VtQWRkcmVzcztcclxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhbiBhZGRyZXNzIG9mIGEgbmV3bHkgY3JlYXRlZCBjb250cmFjdC5cclxuICogQHBhcmFtIGZyb20gVGhlIGFkZHJlc3Mgd2hpY2ggaXMgY3JlYXRpbmcgdGhpcyBuZXcgYWRkcmVzc1xyXG4gKiBAcGFyYW0gbm9uY2UgVGhlIG5vbmNlIG9mIHRoZSBmcm9tIGFjY291bnRcclxuICovXHJcbnZhciBnZW5lcmF0ZUFkZHJlc3MgPSBmdW5jdGlvbiAoZnJvbSwgbm9uY2UpIHtcclxuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIpKGZyb20pO1xyXG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc0J1ZmZlcikobm9uY2UpO1xyXG4gICAgdmFyIG5vbmNlQk4gPSBuZXcgZXh0ZXJuYWxzXzEuQk4obm9uY2UpO1xyXG4gICAgaWYgKG5vbmNlQk4uaXNaZXJvKCkpIHtcclxuICAgICAgICAvLyBpbiBSTFAgd2Ugd2FudCB0byBlbmNvZGUgbnVsbCBpbiB0aGUgY2FzZSBvZiB6ZXJvIG5vbmNlXHJcbiAgICAgICAgLy8gcmVhZCB0aGUgUkxQIGRvY3VtZW50YXRpb24gZm9yIGFuIGFuc3dlciBpZiB5b3UgZGFyZVxyXG4gICAgICAgIHJldHVybiAoMCwgaGFzaF8xLnJscGhhc2gpKFtmcm9tLCBudWxsXSkuc2xpY2UoLTIwKTtcclxuICAgIH1cclxuICAgIC8vIE9ubHkgdGFrZSB0aGUgbG93ZXIgMTYwYml0cyBvZiB0aGUgaGFzaFxyXG4gICAgcmV0dXJuICgwLCBoYXNoXzEucmxwaGFzaCkoW2Zyb20sIEJ1ZmZlci5mcm9tKG5vbmNlQk4udG9BcnJheSgpKV0pLnNsaWNlKC0yMCk7XHJcbn07XHJcbmV4cG9ydHMuZ2VuZXJhdGVBZGRyZXNzID0gZ2VuZXJhdGVBZGRyZXNzO1xyXG4vKipcclxuICogR2VuZXJhdGVzIGFuIGFkZHJlc3MgZm9yIGEgY29udHJhY3QgY3JlYXRlZCB1c2luZyBDUkVBVEUyLlxyXG4gKiBAcGFyYW0gZnJvbSBUaGUgYWRkcmVzcyB3aGljaCBpcyBjcmVhdGluZyB0aGlzIG5ldyBhZGRyZXNzXHJcbiAqIEBwYXJhbSBzYWx0IEEgc2FsdFxyXG4gKiBAcGFyYW0gaW5pdENvZGUgVGhlIGluaXQgY29kZSBvZiB0aGUgY29udHJhY3QgYmVpbmcgY3JlYXRlZFxyXG4gKi9cclxudmFyIGdlbmVyYXRlQWRkcmVzczIgPSBmdW5jdGlvbiAoZnJvbSwgc2FsdCwgaW5pdENvZGUpIHtcclxuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIpKGZyb20pO1xyXG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc0J1ZmZlcikoc2FsdCk7XHJcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzQnVmZmVyKShpbml0Q29kZSk7XHJcbiAgICAoMCwgYXNzZXJ0XzEuZGVmYXVsdCkoZnJvbS5sZW5ndGggPT09IDIwKTtcclxuICAgICgwLCBhc3NlcnRfMS5kZWZhdWx0KShzYWx0Lmxlbmd0aCA9PT0gMzIpO1xyXG4gICAgdmFyIGFkZHJlc3MgPSAoMCwgaGFzaF8xLmtlY2NhazI1NikoQnVmZmVyLmNvbmNhdChbQnVmZmVyLmZyb20oJ2ZmJywgJ2hleCcpLCBmcm9tLCBzYWx0LCAoMCwgaGFzaF8xLmtlY2NhazI1NikoaW5pdENvZGUpXSkpO1xyXG4gICAgcmV0dXJuIGFkZHJlc3Muc2xpY2UoLTIwKTtcclxufTtcclxuZXhwb3J0cy5nZW5lcmF0ZUFkZHJlc3MyID0gZ2VuZXJhdGVBZGRyZXNzMjtcclxuLyoqXHJcbiAqIENoZWNrcyBpZiB0aGUgcHJpdmF0ZSBrZXkgc2F0aXNmaWVzIHRoZSBydWxlcyBvZiB0aGUgY3VydmUgc2VjcDI1NmsxLlxyXG4gKi9cclxudmFyIGlzVmFsaWRQcml2YXRlID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcclxuICAgIHJldHVybiAoMCwgc2VjcDI1NmsxXzEucHJpdmF0ZUtleVZlcmlmeSkocHJpdmF0ZUtleSk7XHJcbn07XHJcbmV4cG9ydHMuaXNWYWxpZFByaXZhdGUgPSBpc1ZhbGlkUHJpdmF0ZTtcclxuLyoqXHJcbiAqIENoZWNrcyBpZiB0aGUgcHVibGljIGtleSBzYXRpc2ZpZXMgdGhlIHJ1bGVzIG9mIHRoZSBjdXJ2ZSBzZWNwMjU2azFcclxuICogYW5kIHRoZSByZXF1aXJlbWVudHMgb2YgRXRoZXJldW0uXHJcbiAqIEBwYXJhbSBwdWJsaWNLZXkgVGhlIHR3byBwb2ludHMgb2YgYW4gdW5jb21wcmVzc2VkIGtleSwgdW5sZXNzIHNhbml0aXplIGlzIGVuYWJsZWRcclxuICogQHBhcmFtIHNhbml0aXplIEFjY2VwdCBwdWJsaWMga2V5cyBpbiBvdGhlciBmb3JtYXRzXHJcbiAqL1xyXG52YXIgaXNWYWxpZFB1YmxpYyA9IGZ1bmN0aW9uIChwdWJsaWNLZXksIHNhbml0aXplKSB7XHJcbiAgICBpZiAoc2FuaXRpemUgPT09IHZvaWQgMCkgeyBzYW5pdGl6ZSA9IGZhbHNlOyB9XHJcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzQnVmZmVyKShwdWJsaWNLZXkpO1xyXG4gICAgaWYgKHB1YmxpY0tleS5sZW5ndGggPT09IDY0KSB7XHJcbiAgICAgICAgLy8gQ29udmVydCB0byBTRUMxIGZvciBzZWNwMjU2azFcclxuICAgICAgICByZXR1cm4gKDAsIHNlY3AyNTZrMV8xLnB1YmxpY0tleVZlcmlmeSkoQnVmZmVyLmNvbmNhdChbQnVmZmVyLmZyb20oWzRdKSwgcHVibGljS2V5XSkpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFzYW5pdGl6ZSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiAoMCwgc2VjcDI1NmsxXzEucHVibGljS2V5VmVyaWZ5KShwdWJsaWNLZXkpO1xyXG59O1xyXG5leHBvcnRzLmlzVmFsaWRQdWJsaWMgPSBpc1ZhbGlkUHVibGljO1xyXG4vKipcclxuICogUmV0dXJucyB0aGUgZXRoZXJldW0gYWRkcmVzcyBvZiBhIGdpdmVuIHB1YmxpYyBrZXkuXHJcbiAqIEFjY2VwdHMgXCJFdGhlcmV1bSBwdWJsaWMga2V5c1wiIGFuZCBTRUMxIGVuY29kZWQga2V5cy5cclxuICogQHBhcmFtIHB1YktleSBUaGUgdHdvIHBvaW50cyBvZiBhbiB1bmNvbXByZXNzZWQga2V5LCB1bmxlc3Mgc2FuaXRpemUgaXMgZW5hYmxlZFxyXG4gKiBAcGFyYW0gc2FuaXRpemUgQWNjZXB0IHB1YmxpYyBrZXlzIGluIG90aGVyIGZvcm1hdHNcclxuICovXHJcbnZhciBwdWJUb0FkZHJlc3MgPSBmdW5jdGlvbiAocHViS2V5LCBzYW5pdGl6ZSkge1xyXG4gICAgaWYgKHNhbml0aXplID09PSB2b2lkIDApIHsgc2FuaXRpemUgPSBmYWxzZTsgfVxyXG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc0J1ZmZlcikocHViS2V5KTtcclxuICAgIGlmIChzYW5pdGl6ZSAmJiBwdWJLZXkubGVuZ3RoICE9PSA2NCkge1xyXG4gICAgICAgIHB1YktleSA9IEJ1ZmZlci5mcm9tKCgwLCBzZWNwMjU2azFfMS5wdWJsaWNLZXlDb252ZXJ0KShwdWJLZXksIGZhbHNlKS5zbGljZSgxKSk7XHJcbiAgICB9XHJcbiAgICAoMCwgYXNzZXJ0XzEuZGVmYXVsdCkocHViS2V5Lmxlbmd0aCA9PT0gNjQpO1xyXG4gICAgLy8gT25seSB0YWtlIHRoZSBsb3dlciAxNjBiaXRzIG9mIHRoZSBoYXNoXHJcbiAgICByZXR1cm4gKDAsIGhhc2hfMS5rZWNjYWspKHB1YktleSkuc2xpY2UoLTIwKTtcclxufTtcclxuZXhwb3J0cy5wdWJUb0FkZHJlc3MgPSBwdWJUb0FkZHJlc3M7XHJcbmV4cG9ydHMucHVibGljVG9BZGRyZXNzID0gZXhwb3J0cy5wdWJUb0FkZHJlc3M7XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBldGhlcmV1bSBwdWJsaWMga2V5IG9mIGEgZ2l2ZW4gcHJpdmF0ZSBrZXkuXHJcbiAqIEBwYXJhbSBwcml2YXRlS2V5IEEgcHJpdmF0ZSBrZXkgbXVzdCBiZSAyNTYgYml0cyB3aWRlXHJcbiAqL1xyXG52YXIgcHJpdmF0ZVRvUHVibGljID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcclxuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIpKHByaXZhdGVLZXkpO1xyXG4gICAgLy8gc2tpcCB0aGUgdHlwZSBmbGFnIGFuZCB1c2UgdGhlIFgsIFkgcG9pbnRzXHJcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oKDAsIHNlY3AyNTZrMV8xLnB1YmxpY0tleUNyZWF0ZSkocHJpdmF0ZUtleSwgZmFsc2UpKS5zbGljZSgxKTtcclxufTtcclxuZXhwb3J0cy5wcml2YXRlVG9QdWJsaWMgPSBwcml2YXRlVG9QdWJsaWM7XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBldGhlcmV1bSBhZGRyZXNzIG9mIGEgZ2l2ZW4gcHJpdmF0ZSBrZXkuXHJcbiAqIEBwYXJhbSBwcml2YXRlS2V5IEEgcHJpdmF0ZSBrZXkgbXVzdCBiZSAyNTYgYml0cyB3aWRlXHJcbiAqL1xyXG52YXIgcHJpdmF0ZVRvQWRkcmVzcyA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XHJcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMucHVibGljVG9BZGRyZXNzKSgoMCwgZXhwb3J0cy5wcml2YXRlVG9QdWJsaWMpKHByaXZhdGVLZXkpKTtcclxufTtcclxuZXhwb3J0cy5wcml2YXRlVG9BZGRyZXNzID0gcHJpdmF0ZVRvQWRkcmVzcztcclxuLyoqXHJcbiAqIENvbnZlcnRzIGEgcHVibGljIGtleSB0byB0aGUgRXRoZXJldW0gZm9ybWF0LlxyXG4gKi9cclxudmFyIGltcG9ydFB1YmxpYyA9IGZ1bmN0aW9uIChwdWJsaWNLZXkpIHtcclxuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIpKHB1YmxpY0tleSk7XHJcbiAgICBpZiAocHVibGljS2V5Lmxlbmd0aCAhPT0gNjQpIHtcclxuICAgICAgICBwdWJsaWNLZXkgPSBCdWZmZXIuZnJvbSgoMCwgc2VjcDI1NmsxXzEucHVibGljS2V5Q29udmVydCkocHVibGljS2V5LCBmYWxzZSkuc2xpY2UoMSkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHB1YmxpY0tleTtcclxufTtcclxuZXhwb3J0cy5pbXBvcnRQdWJsaWMgPSBpbXBvcnRQdWJsaWM7XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSB6ZXJvIGFkZHJlc3MuXHJcbiAqL1xyXG52YXIgemVyb0FkZHJlc3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgYWRkcmVzc0xlbmd0aCA9IDIwO1xyXG4gICAgdmFyIGFkZHIgPSAoMCwgYnl0ZXNfMS56ZXJvcykoYWRkcmVzc0xlbmd0aCk7XHJcbiAgICByZXR1cm4gKDAsIGJ5dGVzXzEuYnVmZmVyVG9IZXgpKGFkZHIpO1xyXG59O1xyXG5leHBvcnRzLnplcm9BZGRyZXNzID0gemVyb0FkZHJlc3M7XHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYSBnaXZlbiBhZGRyZXNzIGlzIHRoZSB6ZXJvIGFkZHJlc3MuXHJcbiAqL1xyXG52YXIgaXNaZXJvQWRkcmVzcyA9IGZ1bmN0aW9uIChoZXhBZGRyZXNzKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNTdHJpbmcpKGhleEFkZHJlc3MpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB2YXIgemVyb0FkZHIgPSAoMCwgZXhwb3J0cy56ZXJvQWRkcmVzcykoKTtcclxuICAgIHJldHVybiB6ZXJvQWRkciA9PT0gaGV4QWRkcmVzcztcclxufTtcclxuZXhwb3J0cy5pc1plcm9BZGRyZXNzID0gaXNaZXJvQWRkcmVzcztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWNjb3VudC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ethereumjs-util/dist.browser/account.js\n");

/***/ }),

/***/ "./node_modules/ethereumjs-util/dist.browser/address.js":
/*!**************************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist.browser/address.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Address = void 0;\r\nvar assert_1 = __importDefault(__webpack_require__(/*! assert */ \"./node_modules/assert/build/assert.js\"));\r\nvar externals_1 = __webpack_require__(/*! ./externals */ \"./node_modules/ethereumjs-util/dist.browser/externals.js\");\r\nvar bytes_1 = __webpack_require__(/*! ./bytes */ \"./node_modules/ethereumjs-util/dist.browser/bytes.js\");\r\nvar account_1 = __webpack_require__(/*! ./account */ \"./node_modules/ethereumjs-util/dist.browser/account.js\");\r\nvar Address = /** @class */ (function () {\r\n    function Address(buf) {\r\n        (0, assert_1.default)(buf.length === 20, 'Invalid address length');\r\n        this.buf = buf;\r\n    }\r\n    /**\r\n     * Returns the zero address.\r\n     */\r\n    Address.zero = function () {\r\n        return new Address((0, bytes_1.zeros)(20));\r\n    };\r\n    /**\r\n     * Returns an Address object from a hex-encoded string.\r\n     * @param str - Hex-encoded address\r\n     */\r\n    Address.fromString = function (str) {\r\n        (0, assert_1.default)((0, account_1.isValidAddress)(str), 'Invalid address');\r\n        return new Address((0, bytes_1.toBuffer)(str));\r\n    };\r\n    /**\r\n     * Returns an address for a given public key.\r\n     * @param pubKey The two points of an uncompressed key\r\n     */\r\n    Address.fromPublicKey = function (pubKey) {\r\n        (0, assert_1.default)(Buffer.isBuffer(pubKey), 'Public key should be Buffer');\r\n        var buf = (0, account_1.pubToAddress)(pubKey);\r\n        return new Address(buf);\r\n    };\r\n    /**\r\n     * Returns an address for a given private key.\r\n     * @param privateKey A private key must be 256 bits wide\r\n     */\r\n    Address.fromPrivateKey = function (privateKey) {\r\n        (0, assert_1.default)(Buffer.isBuffer(privateKey), 'Private key should be Buffer');\r\n        var buf = (0, account_1.privateToAddress)(privateKey);\r\n        return new Address(buf);\r\n    };\r\n    /**\r\n     * Generates an address for a newly created contract.\r\n     * @param from The address which is creating this new address\r\n     * @param nonce The nonce of the from account\r\n     */\r\n    Address.generate = function (from, nonce) {\r\n        (0, assert_1.default)(externals_1.BN.isBN(nonce));\r\n        return new Address((0, account_1.generateAddress)(from.buf, nonce.toArrayLike(Buffer)));\r\n    };\r\n    /**\r\n     * Generates an address for a contract created using CREATE2.\r\n     * @param from The address which is creating this new address\r\n     * @param salt A salt\r\n     * @param initCode The init code of the contract being created\r\n     */\r\n    Address.generate2 = function (from, salt, initCode) {\r\n        (0, assert_1.default)(Buffer.isBuffer(salt));\r\n        (0, assert_1.default)(Buffer.isBuffer(initCode));\r\n        return new Address((0, account_1.generateAddress2)(from.buf, salt, initCode));\r\n    };\r\n    /**\r\n     * Is address equal to another.\r\n     */\r\n    Address.prototype.equals = function (address) {\r\n        return this.buf.equals(address.buf);\r\n    };\r\n    /**\r\n     * Is address zero.\r\n     */\r\n    Address.prototype.isZero = function () {\r\n        return this.equals(Address.zero());\r\n    };\r\n    /**\r\n     * True if address is in the address range defined\r\n     * by EIP-1352\r\n     */\r\n    Address.prototype.isPrecompileOrSystemAddress = function () {\r\n        var addressBN = new externals_1.BN(this.buf);\r\n        var rangeMin = new externals_1.BN(0);\r\n        var rangeMax = new externals_1.BN('ffff', 'hex');\r\n        return addressBN.gte(rangeMin) && addressBN.lte(rangeMax);\r\n    };\r\n    /**\r\n     * Returns hex encoding of address.\r\n     */\r\n    Address.prototype.toString = function () {\r\n        return '0x' + this.buf.toString('hex');\r\n    };\r\n    /**\r\n     * Returns Buffer representation of address.\r\n     */\r\n    Address.prototype.toBuffer = function () {\r\n        return Buffer.from(this.buf);\r\n    };\r\n    return Address;\r\n}());\r\nexports.Address = Address;\r\n//# sourceMappingURL=address.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QuYnJvd3Nlci9hZGRyZXNzLmpzLmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWU7QUFDZiwrQkFBK0IsbUJBQU8sQ0FBQyxxREFBUTtBQUMvQyxrQkFBa0IsbUJBQU8sQ0FBQyw2RUFBYTtBQUN2QyxjQUFjLG1CQUFPLENBQUMscUVBQVM7QUFDL0IsZ0JBQWdCLG1CQUFPLENBQUMseUVBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLE1BQU07QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixNQUFNO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLE1BQU07QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixNQUFNO0FBQ3BDLDhCQUE4QixNQUFNO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsZUFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC5icm93c2VyL2FkZHJlc3MuanM/ODkwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLkFkZHJlc3MgPSB2b2lkIDA7XHJcbnZhciBhc3NlcnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYXNzZXJ0XCIpKTtcclxudmFyIGV4dGVybmFsc18xID0gcmVxdWlyZShcIi4vZXh0ZXJuYWxzXCIpO1xyXG52YXIgYnl0ZXNfMSA9IHJlcXVpcmUoXCIuL2J5dGVzXCIpO1xyXG52YXIgYWNjb3VudF8xID0gcmVxdWlyZShcIi4vYWNjb3VudFwiKTtcclxudmFyIEFkZHJlc3MgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBBZGRyZXNzKGJ1Zikge1xyXG4gICAgICAgICgwLCBhc3NlcnRfMS5kZWZhdWx0KShidWYubGVuZ3RoID09PSAyMCwgJ0ludmFsaWQgYWRkcmVzcyBsZW5ndGgnKTtcclxuICAgICAgICB0aGlzLmJ1ZiA9IGJ1ZjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgemVybyBhZGRyZXNzLlxyXG4gICAgICovXHJcbiAgICBBZGRyZXNzLnplcm8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBBZGRyZXNzKCgwLCBieXRlc18xLnplcm9zKSgyMCkpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBBZGRyZXNzIG9iamVjdCBmcm9tIGEgaGV4LWVuY29kZWQgc3RyaW5nLlxyXG4gICAgICogQHBhcmFtIHN0ciAtIEhleC1lbmNvZGVkIGFkZHJlc3NcclxuICAgICAqL1xyXG4gICAgQWRkcmVzcy5mcm9tU3RyaW5nID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgICAgICgwLCBhc3NlcnRfMS5kZWZhdWx0KSgoMCwgYWNjb3VudF8xLmlzVmFsaWRBZGRyZXNzKShzdHIpLCAnSW52YWxpZCBhZGRyZXNzJyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBBZGRyZXNzKCgwLCBieXRlc18xLnRvQnVmZmVyKShzdHIpKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gYWRkcmVzcyBmb3IgYSBnaXZlbiBwdWJsaWMga2V5LlxyXG4gICAgICogQHBhcmFtIHB1YktleSBUaGUgdHdvIHBvaW50cyBvZiBhbiB1bmNvbXByZXNzZWQga2V5XHJcbiAgICAgKi9cclxuICAgIEFkZHJlc3MuZnJvbVB1YmxpY0tleSA9IGZ1bmN0aW9uIChwdWJLZXkpIHtcclxuICAgICAgICAoMCwgYXNzZXJ0XzEuZGVmYXVsdCkoQnVmZmVyLmlzQnVmZmVyKHB1YktleSksICdQdWJsaWMga2V5IHNob3VsZCBiZSBCdWZmZXInKTtcclxuICAgICAgICB2YXIgYnVmID0gKDAsIGFjY291bnRfMS5wdWJUb0FkZHJlc3MpKHB1YktleSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBBZGRyZXNzKGJ1Zik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFuIGFkZHJlc3MgZm9yIGEgZ2l2ZW4gcHJpdmF0ZSBrZXkuXHJcbiAgICAgKiBAcGFyYW0gcHJpdmF0ZUtleSBBIHByaXZhdGUga2V5IG11c3QgYmUgMjU2IGJpdHMgd2lkZVxyXG4gICAgICovXHJcbiAgICBBZGRyZXNzLmZyb21Qcml2YXRlS2V5ID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcclxuICAgICAgICAoMCwgYXNzZXJ0XzEuZGVmYXVsdCkoQnVmZmVyLmlzQnVmZmVyKHByaXZhdGVLZXkpLCAnUHJpdmF0ZSBrZXkgc2hvdWxkIGJlIEJ1ZmZlcicpO1xyXG4gICAgICAgIHZhciBidWYgPSAoMCwgYWNjb3VudF8xLnByaXZhdGVUb0FkZHJlc3MpKHByaXZhdGVLZXkpO1xyXG4gICAgICAgIHJldHVybiBuZXcgQWRkcmVzcyhidWYpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGVzIGFuIGFkZHJlc3MgZm9yIGEgbmV3bHkgY3JlYXRlZCBjb250cmFjdC5cclxuICAgICAqIEBwYXJhbSBmcm9tIFRoZSBhZGRyZXNzIHdoaWNoIGlzIGNyZWF0aW5nIHRoaXMgbmV3IGFkZHJlc3NcclxuICAgICAqIEBwYXJhbSBub25jZSBUaGUgbm9uY2Ugb2YgdGhlIGZyb20gYWNjb3VudFxyXG4gICAgICovXHJcbiAgICBBZGRyZXNzLmdlbmVyYXRlID0gZnVuY3Rpb24gKGZyb20sIG5vbmNlKSB7XHJcbiAgICAgICAgKDAsIGFzc2VydF8xLmRlZmF1bHQpKGV4dGVybmFsc18xLkJOLmlzQk4obm9uY2UpKTtcclxuICAgICAgICByZXR1cm4gbmV3IEFkZHJlc3MoKDAsIGFjY291bnRfMS5nZW5lcmF0ZUFkZHJlc3MpKGZyb20uYnVmLCBub25jZS50b0FycmF5TGlrZShCdWZmZXIpKSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgYW4gYWRkcmVzcyBmb3IgYSBjb250cmFjdCBjcmVhdGVkIHVzaW5nIENSRUFURTIuXHJcbiAgICAgKiBAcGFyYW0gZnJvbSBUaGUgYWRkcmVzcyB3aGljaCBpcyBjcmVhdGluZyB0aGlzIG5ldyBhZGRyZXNzXHJcbiAgICAgKiBAcGFyYW0gc2FsdCBBIHNhbHRcclxuICAgICAqIEBwYXJhbSBpbml0Q29kZSBUaGUgaW5pdCBjb2RlIG9mIHRoZSBjb250cmFjdCBiZWluZyBjcmVhdGVkXHJcbiAgICAgKi9cclxuICAgIEFkZHJlc3MuZ2VuZXJhdGUyID0gZnVuY3Rpb24gKGZyb20sIHNhbHQsIGluaXRDb2RlKSB7XHJcbiAgICAgICAgKDAsIGFzc2VydF8xLmRlZmF1bHQpKEJ1ZmZlci5pc0J1ZmZlcihzYWx0KSk7XHJcbiAgICAgICAgKDAsIGFzc2VydF8xLmRlZmF1bHQpKEJ1ZmZlci5pc0J1ZmZlcihpbml0Q29kZSkpO1xyXG4gICAgICAgIHJldHVybiBuZXcgQWRkcmVzcygoMCwgYWNjb3VudF8xLmdlbmVyYXRlQWRkcmVzczIpKGZyb20uYnVmLCBzYWx0LCBpbml0Q29kZSkpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogSXMgYWRkcmVzcyBlcXVhbCB0byBhbm90aGVyLlxyXG4gICAgICovXHJcbiAgICBBZGRyZXNzLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAoYWRkcmVzcykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJ1Zi5lcXVhbHMoYWRkcmVzcy5idWYpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogSXMgYWRkcmVzcyB6ZXJvLlxyXG4gICAgICovXHJcbiAgICBBZGRyZXNzLnByb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXF1YWxzKEFkZHJlc3MuemVybygpKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFRydWUgaWYgYWRkcmVzcyBpcyBpbiB0aGUgYWRkcmVzcyByYW5nZSBkZWZpbmVkXHJcbiAgICAgKiBieSBFSVAtMTM1MlxyXG4gICAgICovXHJcbiAgICBBZGRyZXNzLnByb3RvdHlwZS5pc1ByZWNvbXBpbGVPclN5c3RlbUFkZHJlc3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGFkZHJlc3NCTiA9IG5ldyBleHRlcm5hbHNfMS5CTih0aGlzLmJ1Zik7XHJcbiAgICAgICAgdmFyIHJhbmdlTWluID0gbmV3IGV4dGVybmFsc18xLkJOKDApO1xyXG4gICAgICAgIHZhciByYW5nZU1heCA9IG5ldyBleHRlcm5hbHNfMS5CTignZmZmZicsICdoZXgnKTtcclxuICAgICAgICByZXR1cm4gYWRkcmVzc0JOLmd0ZShyYW5nZU1pbikgJiYgYWRkcmVzc0JOLmx0ZShyYW5nZU1heCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGhleCBlbmNvZGluZyBvZiBhZGRyZXNzLlxyXG4gICAgICovXHJcbiAgICBBZGRyZXNzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gJzB4JyArIHRoaXMuYnVmLnRvU3RyaW5nKCdoZXgnKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgQnVmZmVyIHJlcHJlc2VudGF0aW9uIG9mIGFkZHJlc3MuXHJcbiAgICAgKi9cclxuICAgIEFkZHJlc3MucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh0aGlzLmJ1Zik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEFkZHJlc3M7XHJcbn0oKSk7XHJcbmV4cG9ydHMuQWRkcmVzcyA9IEFkZHJlc3M7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZHJlc3MuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ethereumjs-util/dist.browser/address.js\n");

/***/ }),

/***/ "./node_modules/ethereumjs-util/dist.browser/bytes.js":
/*!************************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist.browser/bytes.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\r\nvar __values = (this && this.__values) || function(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n};\r\nvar __read = (this && this.__read) || function (o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.bufArrToArr = exports.arrToBufArr = exports.validateNoLeadingZeroes = exports.baToJSON = exports.toUtf8 = exports.addHexPrefix = exports.toUnsigned = exports.fromSigned = exports.bufferToHex = exports.bufferToInt = exports.toBuffer = exports.unpadHexString = exports.unpadArray = exports.unpadBuffer = exports.setLengthRight = exports.setLengthLeft = exports.zeros = exports.intToBuffer = exports.intToHex = void 0;\r\nvar externals_1 = __webpack_require__(/*! ./externals */ \"./node_modules/ethereumjs-util/dist.browser/externals.js\");\r\nvar internal_1 = __webpack_require__(/*! ./internal */ \"./node_modules/ethereumjs-util/dist.browser/internal.js\");\r\nvar helpers_1 = __webpack_require__(/*! ./helpers */ \"./node_modules/ethereumjs-util/dist.browser/helpers.js\");\r\n/**\r\n * Converts a `Number` into a hex `String`\r\n * @param {Number} i\r\n * @return {String}\r\n */\r\nvar intToHex = function (i) {\r\n    if (!Number.isSafeInteger(i) || i < 0) {\r\n        throw new Error(\"Received an invalid integer type: \".concat(i));\r\n    }\r\n    return \"0x\".concat(i.toString(16));\r\n};\r\nexports.intToHex = intToHex;\r\n/**\r\n * Converts an `Number` to a `Buffer`\r\n * @param {Number} i\r\n * @return {Buffer}\r\n */\r\nvar intToBuffer = function (i) {\r\n    var hex = (0, exports.intToHex)(i);\r\n    return Buffer.from((0, internal_1.padToEven)(hex.slice(2)), 'hex');\r\n};\r\nexports.intToBuffer = intToBuffer;\r\n/**\r\n * Returns a buffer filled with 0s.\r\n * @param bytes the number of bytes the buffer should be\r\n */\r\nvar zeros = function (bytes) {\r\n    return Buffer.allocUnsafe(bytes).fill(0);\r\n};\r\nexports.zeros = zeros;\r\n/**\r\n * Pads a `Buffer` with zeros till it has `length` bytes.\r\n * Truncates the beginning or end of input if its length exceeds `length`.\r\n * @param msg the value to pad (Buffer)\r\n * @param length the number of bytes the output should be\r\n * @param right whether to start padding form the left or right\r\n * @return (Buffer)\r\n */\r\nvar setLength = function (msg, length, right) {\r\n    var buf = (0, exports.zeros)(length);\r\n    if (right) {\r\n        if (msg.length < length) {\r\n            msg.copy(buf);\r\n            return buf;\r\n        }\r\n        return msg.slice(0, length);\r\n    }\r\n    else {\r\n        if (msg.length < length) {\r\n            msg.copy(buf, length - msg.length);\r\n            return buf;\r\n        }\r\n        return msg.slice(-length);\r\n    }\r\n};\r\n/**\r\n * Left Pads a `Buffer` with leading zeros till it has `length` bytes.\r\n * Or it truncates the beginning if it exceeds.\r\n * @param msg the value to pad (Buffer)\r\n * @param length the number of bytes the output should be\r\n * @return (Buffer)\r\n */\r\nvar setLengthLeft = function (msg, length) {\r\n    (0, helpers_1.assertIsBuffer)(msg);\r\n    return setLength(msg, length, false);\r\n};\r\nexports.setLengthLeft = setLengthLeft;\r\n/**\r\n * Right Pads a `Buffer` with trailing zeros till it has `length` bytes.\r\n * it truncates the end if it exceeds.\r\n * @param msg the value to pad (Buffer)\r\n * @param length the number of bytes the output should be\r\n * @return (Buffer)\r\n */\r\nvar setLengthRight = function (msg, length) {\r\n    (0, helpers_1.assertIsBuffer)(msg);\r\n    return setLength(msg, length, true);\r\n};\r\nexports.setLengthRight = setLengthRight;\r\n/**\r\n * Trims leading zeros from a `Buffer`, `String` or `Number[]`.\r\n * @param a (Buffer|Array|String)\r\n * @return (Buffer|Array|String)\r\n */\r\nvar stripZeros = function (a) {\r\n    var first = a[0];\r\n    while (a.length > 0 && first.toString() === '0') {\r\n        a = a.slice(1);\r\n        first = a[0];\r\n    }\r\n    return a;\r\n};\r\n/**\r\n * Trims leading zeros from a `Buffer`.\r\n * @param a (Buffer)\r\n * @return (Buffer)\r\n */\r\nvar unpadBuffer = function (a) {\r\n    (0, helpers_1.assertIsBuffer)(a);\r\n    return stripZeros(a);\r\n};\r\nexports.unpadBuffer = unpadBuffer;\r\n/**\r\n * Trims leading zeros from an `Array` (of numbers).\r\n * @param a (number[])\r\n * @return (number[])\r\n */\r\nvar unpadArray = function (a) {\r\n    (0, helpers_1.assertIsArray)(a);\r\n    return stripZeros(a);\r\n};\r\nexports.unpadArray = unpadArray;\r\n/**\r\n * Trims leading zeros from a hex-prefixed `String`.\r\n * @param a (String)\r\n * @return (String)\r\n */\r\nvar unpadHexString = function (a) {\r\n    (0, helpers_1.assertIsHexString)(a);\r\n    a = (0, internal_1.stripHexPrefix)(a);\r\n    return stripZeros(a);\r\n};\r\nexports.unpadHexString = unpadHexString;\r\n/**\r\n * Attempts to turn a value into a `Buffer`.\r\n * Inputs supported: `Buffer`, `String` (hex-prefixed), `Number`, null/undefined, `BN` and other objects\r\n * with a `toArray()` or `toBuffer()` method.\r\n * @param v the value\r\n */\r\nvar toBuffer = function (v) {\r\n    if (v === null || v === undefined) {\r\n        return Buffer.allocUnsafe(0);\r\n    }\r\n    if (Buffer.isBuffer(v)) {\r\n        return Buffer.from(v);\r\n    }\r\n    if (Array.isArray(v) || v instanceof Uint8Array) {\r\n        return Buffer.from(v);\r\n    }\r\n    if (typeof v === 'string') {\r\n        if (!(0, internal_1.isHexString)(v)) {\r\n            throw new Error(\"Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: \".concat(v));\r\n        }\r\n        return Buffer.from((0, internal_1.padToEven)((0, internal_1.stripHexPrefix)(v)), 'hex');\r\n    }\r\n    if (typeof v === 'number') {\r\n        return (0, exports.intToBuffer)(v);\r\n    }\r\n    if (externals_1.BN.isBN(v)) {\r\n        if (v.isNeg()) {\r\n            throw new Error(\"Cannot convert negative BN to buffer. Given: \".concat(v));\r\n        }\r\n        return v.toArrayLike(Buffer);\r\n    }\r\n    if (v.toArray) {\r\n        // converts a BN to a Buffer\r\n        return Buffer.from(v.toArray());\r\n    }\r\n    if (v.toBuffer) {\r\n        return Buffer.from(v.toBuffer());\r\n    }\r\n    throw new Error('invalid type');\r\n};\r\nexports.toBuffer = toBuffer;\r\n/**\r\n * Converts a `Buffer` to a `Number`.\r\n * @param buf `Buffer` object to convert\r\n * @throws If the input number exceeds 53 bits.\r\n */\r\nvar bufferToInt = function (buf) {\r\n    return new externals_1.BN((0, exports.toBuffer)(buf)).toNumber();\r\n};\r\nexports.bufferToInt = bufferToInt;\r\n/**\r\n * Converts a `Buffer` into a `0x`-prefixed hex `String`.\r\n * @param buf `Buffer` object to convert\r\n */\r\nvar bufferToHex = function (buf) {\r\n    buf = (0, exports.toBuffer)(buf);\r\n    return '0x' + buf.toString('hex');\r\n};\r\nexports.bufferToHex = bufferToHex;\r\n/**\r\n * Interprets a `Buffer` as a signed integer and returns a `BN`. Assumes 256-bit numbers.\r\n * @param num Signed integer value\r\n */\r\nvar fromSigned = function (num) {\r\n    return new externals_1.BN(num).fromTwos(256);\r\n};\r\nexports.fromSigned = fromSigned;\r\n/**\r\n * Converts a `BN` to an unsigned integer and returns it as a `Buffer`. Assumes 256-bit numbers.\r\n * @param num\r\n */\r\nvar toUnsigned = function (num) {\r\n    return Buffer.from(num.toTwos(256).toArray());\r\n};\r\nexports.toUnsigned = toUnsigned;\r\n/**\r\n * Adds \"0x\" to a given `String` if it does not already start with \"0x\".\r\n */\r\nvar addHexPrefix = function (str) {\r\n    if (typeof str !== 'string') {\r\n        return str;\r\n    }\r\n    return (0, internal_1.isHexPrefixed)(str) ? str : '0x' + str;\r\n};\r\nexports.addHexPrefix = addHexPrefix;\r\n/**\r\n * Returns the utf8 string representation from a hex string.\r\n *\r\n * Examples:\r\n *\r\n * Input 1: '657468657265756d000000000000000000000000000000000000000000000000'\r\n * Input 2: '657468657265756d'\r\n * Input 3: '000000000000000000000000000000000000000000000000657468657265756d'\r\n *\r\n * Output (all 3 input variants): 'ethereum'\r\n *\r\n * Note that this method is not intended to be used with hex strings\r\n * representing quantities in both big endian or little endian notation.\r\n *\r\n * @param string Hex string, should be `0x` prefixed\r\n * @return Utf8 string\r\n */\r\nvar toUtf8 = function (hex) {\r\n    var zerosRegexp = /^(00)+|(00)+$/g;\r\n    hex = (0, internal_1.stripHexPrefix)(hex);\r\n    if (hex.length % 2 !== 0) {\r\n        throw new Error('Invalid non-even hex string input for toUtf8() provided');\r\n    }\r\n    var bufferVal = Buffer.from(hex.replace(zerosRegexp, ''), 'hex');\r\n    return bufferVal.toString('utf8');\r\n};\r\nexports.toUtf8 = toUtf8;\r\n/**\r\n * Converts a `Buffer` or `Array` to JSON.\r\n * @param ba (Buffer|Array)\r\n * @return (Array|String|null)\r\n */\r\nvar baToJSON = function (ba) {\r\n    if (Buffer.isBuffer(ba)) {\r\n        return \"0x\".concat(ba.toString('hex'));\r\n    }\r\n    else if (ba instanceof Array) {\r\n        var array = [];\r\n        for (var i = 0; i < ba.length; i++) {\r\n            array.push((0, exports.baToJSON)(ba[i]));\r\n        }\r\n        return array;\r\n    }\r\n};\r\nexports.baToJSON = baToJSON;\r\n/**\r\n * Checks provided Buffers for leading zeroes and throws if found.\r\n *\r\n * Examples:\r\n *\r\n * Valid values: 0x1, 0x, 0x01, 0x1234\r\n * Invalid values: 0x0, 0x00, 0x001, 0x0001\r\n *\r\n * Note: This method is useful for validating that RLP encoded integers comply with the rule that all\r\n * integer values encoded to RLP must be in the most compact form and contain no leading zero bytes\r\n * @param values An object containing string keys and Buffer values\r\n * @throws if any provided value is found to have leading zero bytes\r\n */\r\nvar validateNoLeadingZeroes = function (values) {\r\n    var e_1, _a;\r\n    try {\r\n        for (var _b = __values(Object.entries(values)), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n            var _d = __read(_c.value, 2), k = _d[0], v = _d[1];\r\n            if (v !== undefined && v.length > 0 && v[0] === 0) {\r\n                throw new Error(\"\".concat(k, \" cannot have leading zeroes, received: \").concat(v.toString('hex')));\r\n            }\r\n        }\r\n    }\r\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n    finally {\r\n        try {\r\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n        }\r\n        finally { if (e_1) throw e_1.error; }\r\n    }\r\n};\r\nexports.validateNoLeadingZeroes = validateNoLeadingZeroes;\r\nfunction arrToBufArr(arr) {\r\n    if (!Array.isArray(arr)) {\r\n        return Buffer.from(arr);\r\n    }\r\n    return arr.map(function (a) { return arrToBufArr(a); });\r\n}\r\nexports.arrToBufArr = arrToBufArr;\r\nfunction bufArrToArr(arr) {\r\n    if (!Array.isArray(arr)) {\r\n        return Uint8Array.from(arr !== null && arr !== void 0 ? arr : []);\r\n    }\r\n    return arr.map(function (a) { return bufArrToArr(a); });\r\n}\r\nexports.bufArrToArr = bufArrToArr;\r\n//# sourceMappingURL=bytes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QuYnJvd3Nlci9ieXRlcy5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsR0FBRyxtQkFBbUIsR0FBRywrQkFBK0IsR0FBRyxnQkFBZ0IsR0FBRyxjQUFjLEdBQUcsb0JBQW9CLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsbUJBQW1CLEdBQUcsbUJBQW1CLEdBQUcsZ0JBQWdCLEdBQUcsc0JBQXNCLEdBQUcsa0JBQWtCLEdBQUcsbUJBQW1CLEdBQUcsc0JBQXNCLEdBQUcscUJBQXFCLEdBQUcsYUFBYSxHQUFHLG1CQUFtQixHQUFHLGdCQUFnQjtBQUM3WixrQkFBa0IsbUJBQU8sQ0FBQyw2RUFBYTtBQUN2QyxpQkFBaUIsbUJBQU8sQ0FBQywyRUFBWTtBQUNyQyxnQkFBZ0IsbUJBQU8sQ0FBQyx5RUFBVztBQUNuQztBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBLFFBQVEsTUFBTTtBQUNkLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixNQUFNO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxNQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLFVBQVU7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0Esa0NBQWtDLHdCQUF3QjtBQUMxRDtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx3QkFBd0I7QUFDMUQ7QUFDQSxtQkFBbUI7QUFDbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0LmJyb3dzZXIvYnl0ZXMuanM/ZjhjOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xyXG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbn07XHJcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLmJ1ZkFyclRvQXJyID0gZXhwb3J0cy5hcnJUb0J1ZkFyciA9IGV4cG9ydHMudmFsaWRhdGVOb0xlYWRpbmdaZXJvZXMgPSBleHBvcnRzLmJhVG9KU09OID0gZXhwb3J0cy50b1V0ZjggPSBleHBvcnRzLmFkZEhleFByZWZpeCA9IGV4cG9ydHMudG9VbnNpZ25lZCA9IGV4cG9ydHMuZnJvbVNpZ25lZCA9IGV4cG9ydHMuYnVmZmVyVG9IZXggPSBleHBvcnRzLmJ1ZmZlclRvSW50ID0gZXhwb3J0cy50b0J1ZmZlciA9IGV4cG9ydHMudW5wYWRIZXhTdHJpbmcgPSBleHBvcnRzLnVucGFkQXJyYXkgPSBleHBvcnRzLnVucGFkQnVmZmVyID0gZXhwb3J0cy5zZXRMZW5ndGhSaWdodCA9IGV4cG9ydHMuc2V0TGVuZ3RoTGVmdCA9IGV4cG9ydHMuemVyb3MgPSBleHBvcnRzLmludFRvQnVmZmVyID0gZXhwb3J0cy5pbnRUb0hleCA9IHZvaWQgMDtcclxudmFyIGV4dGVybmFsc18xID0gcmVxdWlyZShcIi4vZXh0ZXJuYWxzXCIpO1xyXG52YXIgaW50ZXJuYWxfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFsXCIpO1xyXG52YXIgaGVscGVyc18xID0gcmVxdWlyZShcIi4vaGVscGVyc1wiKTtcclxuLyoqXHJcbiAqIENvbnZlcnRzIGEgYE51bWJlcmAgaW50byBhIGhleCBgU3RyaW5nYFxyXG4gKiBAcGFyYW0ge051bWJlcn0gaVxyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XHJcbiAqL1xyXG52YXIgaW50VG9IZXggPSBmdW5jdGlvbiAoaSkge1xyXG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihpKSB8fCBpIDwgMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlY2VpdmVkIGFuIGludmFsaWQgaW50ZWdlciB0eXBlOiBcIi5jb25jYXQoaSkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFwiMHhcIi5jb25jYXQoaS50b1N0cmluZygxNikpO1xyXG59O1xyXG5leHBvcnRzLmludFRvSGV4ID0gaW50VG9IZXg7XHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBhbiBgTnVtYmVyYCB0byBhIGBCdWZmZXJgXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBpXHJcbiAqIEByZXR1cm4ge0J1ZmZlcn1cclxuICovXHJcbnZhciBpbnRUb0J1ZmZlciA9IGZ1bmN0aW9uIChpKSB7XHJcbiAgICB2YXIgaGV4ID0gKDAsIGV4cG9ydHMuaW50VG9IZXgpKGkpO1xyXG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKCgwLCBpbnRlcm5hbF8xLnBhZFRvRXZlbikoaGV4LnNsaWNlKDIpKSwgJ2hleCcpO1xyXG59O1xyXG5leHBvcnRzLmludFRvQnVmZmVyID0gaW50VG9CdWZmZXI7XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgYnVmZmVyIGZpbGxlZCB3aXRoIDBzLlxyXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIG51bWJlciBvZiBieXRlcyB0aGUgYnVmZmVyIHNob3VsZCBiZVxyXG4gKi9cclxudmFyIHplcm9zID0gZnVuY3Rpb24gKGJ5dGVzKSB7XHJcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jVW5zYWZlKGJ5dGVzKS5maWxsKDApO1xyXG59O1xyXG5leHBvcnRzLnplcm9zID0gemVyb3M7XHJcbi8qKlxyXG4gKiBQYWRzIGEgYEJ1ZmZlcmAgd2l0aCB6ZXJvcyB0aWxsIGl0IGhhcyBgbGVuZ3RoYCBieXRlcy5cclxuICogVHJ1bmNhdGVzIHRoZSBiZWdpbm5pbmcgb3IgZW5kIG9mIGlucHV0IGlmIGl0cyBsZW5ndGggZXhjZWVkcyBgbGVuZ3RoYC5cclxuICogQHBhcmFtIG1zZyB0aGUgdmFsdWUgdG8gcGFkIChCdWZmZXIpXHJcbiAqIEBwYXJhbSBsZW5ndGggdGhlIG51bWJlciBvZiBieXRlcyB0aGUgb3V0cHV0IHNob3VsZCBiZVxyXG4gKiBAcGFyYW0gcmlnaHQgd2hldGhlciB0byBzdGFydCBwYWRkaW5nIGZvcm0gdGhlIGxlZnQgb3IgcmlnaHRcclxuICogQHJldHVybiAoQnVmZmVyKVxyXG4gKi9cclxudmFyIHNldExlbmd0aCA9IGZ1bmN0aW9uIChtc2csIGxlbmd0aCwgcmlnaHQpIHtcclxuICAgIHZhciBidWYgPSAoMCwgZXhwb3J0cy56ZXJvcykobGVuZ3RoKTtcclxuICAgIGlmIChyaWdodCkge1xyXG4gICAgICAgIGlmIChtc2cubGVuZ3RoIDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIG1zZy5jb3B5KGJ1Zik7XHJcbiAgICAgICAgICAgIHJldHVybiBidWY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtc2cuc2xpY2UoMCwgbGVuZ3RoKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChtc2cubGVuZ3RoIDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIG1zZy5jb3B5KGJ1ZiwgbGVuZ3RoIC0gbXNnLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIHJldHVybiBidWY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtc2cuc2xpY2UoLWxlbmd0aCk7XHJcbiAgICB9XHJcbn07XHJcbi8qKlxyXG4gKiBMZWZ0IFBhZHMgYSBgQnVmZmVyYCB3aXRoIGxlYWRpbmcgemVyb3MgdGlsbCBpdCBoYXMgYGxlbmd0aGAgYnl0ZXMuXHJcbiAqIE9yIGl0IHRydW5jYXRlcyB0aGUgYmVnaW5uaW5nIGlmIGl0IGV4Y2VlZHMuXHJcbiAqIEBwYXJhbSBtc2cgdGhlIHZhbHVlIHRvIHBhZCAoQnVmZmVyKVxyXG4gKiBAcGFyYW0gbGVuZ3RoIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhlIG91dHB1dCBzaG91bGQgYmVcclxuICogQHJldHVybiAoQnVmZmVyKVxyXG4gKi9cclxudmFyIHNldExlbmd0aExlZnQgPSBmdW5jdGlvbiAobXNnLCBsZW5ndGgpIHtcclxuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIpKG1zZyk7XHJcbiAgICByZXR1cm4gc2V0TGVuZ3RoKG1zZywgbGVuZ3RoLCBmYWxzZSk7XHJcbn07XHJcbmV4cG9ydHMuc2V0TGVuZ3RoTGVmdCA9IHNldExlbmd0aExlZnQ7XHJcbi8qKlxyXG4gKiBSaWdodCBQYWRzIGEgYEJ1ZmZlcmAgd2l0aCB0cmFpbGluZyB6ZXJvcyB0aWxsIGl0IGhhcyBgbGVuZ3RoYCBieXRlcy5cclxuICogaXQgdHJ1bmNhdGVzIHRoZSBlbmQgaWYgaXQgZXhjZWVkcy5cclxuICogQHBhcmFtIG1zZyB0aGUgdmFsdWUgdG8gcGFkIChCdWZmZXIpXHJcbiAqIEBwYXJhbSBsZW5ndGggdGhlIG51bWJlciBvZiBieXRlcyB0aGUgb3V0cHV0IHNob3VsZCBiZVxyXG4gKiBAcmV0dXJuIChCdWZmZXIpXHJcbiAqL1xyXG52YXIgc2V0TGVuZ3RoUmlnaHQgPSBmdW5jdGlvbiAobXNnLCBsZW5ndGgpIHtcclxuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIpKG1zZyk7XHJcbiAgICByZXR1cm4gc2V0TGVuZ3RoKG1zZywgbGVuZ3RoLCB0cnVlKTtcclxufTtcclxuZXhwb3J0cy5zZXRMZW5ndGhSaWdodCA9IHNldExlbmd0aFJpZ2h0O1xyXG4vKipcclxuICogVHJpbXMgbGVhZGluZyB6ZXJvcyBmcm9tIGEgYEJ1ZmZlcmAsIGBTdHJpbmdgIG9yIGBOdW1iZXJbXWAuXHJcbiAqIEBwYXJhbSBhIChCdWZmZXJ8QXJyYXl8U3RyaW5nKVxyXG4gKiBAcmV0dXJuIChCdWZmZXJ8QXJyYXl8U3RyaW5nKVxyXG4gKi9cclxudmFyIHN0cmlwWmVyb3MgPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgdmFyIGZpcnN0ID0gYVswXTtcclxuICAgIHdoaWxlIChhLmxlbmd0aCA+IDAgJiYgZmlyc3QudG9TdHJpbmcoKSA9PT0gJzAnKSB7XHJcbiAgICAgICAgYSA9IGEuc2xpY2UoMSk7XHJcbiAgICAgICAgZmlyc3QgPSBhWzBdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGE7XHJcbn07XHJcbi8qKlxyXG4gKiBUcmltcyBsZWFkaW5nIHplcm9zIGZyb20gYSBgQnVmZmVyYC5cclxuICogQHBhcmFtIGEgKEJ1ZmZlcilcclxuICogQHJldHVybiAoQnVmZmVyKVxyXG4gKi9cclxudmFyIHVucGFkQnVmZmVyID0gZnVuY3Rpb24gKGEpIHtcclxuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIpKGEpO1xyXG4gICAgcmV0dXJuIHN0cmlwWmVyb3MoYSk7XHJcbn07XHJcbmV4cG9ydHMudW5wYWRCdWZmZXIgPSB1bnBhZEJ1ZmZlcjtcclxuLyoqXHJcbiAqIFRyaW1zIGxlYWRpbmcgemVyb3MgZnJvbSBhbiBgQXJyYXlgIChvZiBudW1iZXJzKS5cclxuICogQHBhcmFtIGEgKG51bWJlcltdKVxyXG4gKiBAcmV0dXJuIChudW1iZXJbXSlcclxuICovXHJcbnZhciB1bnBhZEFycmF5ID0gZnVuY3Rpb24gKGEpIHtcclxuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNBcnJheSkoYSk7XHJcbiAgICByZXR1cm4gc3RyaXBaZXJvcyhhKTtcclxufTtcclxuZXhwb3J0cy51bnBhZEFycmF5ID0gdW5wYWRBcnJheTtcclxuLyoqXHJcbiAqIFRyaW1zIGxlYWRpbmcgemVyb3MgZnJvbSBhIGhleC1wcmVmaXhlZCBgU3RyaW5nYC5cclxuICogQHBhcmFtIGEgKFN0cmluZylcclxuICogQHJldHVybiAoU3RyaW5nKVxyXG4gKi9cclxudmFyIHVucGFkSGV4U3RyaW5nID0gZnVuY3Rpb24gKGEpIHtcclxuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNIZXhTdHJpbmcpKGEpO1xyXG4gICAgYSA9ICgwLCBpbnRlcm5hbF8xLnN0cmlwSGV4UHJlZml4KShhKTtcclxuICAgIHJldHVybiBzdHJpcFplcm9zKGEpO1xyXG59O1xyXG5leHBvcnRzLnVucGFkSGV4U3RyaW5nID0gdW5wYWRIZXhTdHJpbmc7XHJcbi8qKlxyXG4gKiBBdHRlbXB0cyB0byB0dXJuIGEgdmFsdWUgaW50byBhIGBCdWZmZXJgLlxyXG4gKiBJbnB1dHMgc3VwcG9ydGVkOiBgQnVmZmVyYCwgYFN0cmluZ2AgKGhleC1wcmVmaXhlZCksIGBOdW1iZXJgLCBudWxsL3VuZGVmaW5lZCwgYEJOYCBhbmQgb3RoZXIgb2JqZWN0c1xyXG4gKiB3aXRoIGEgYHRvQXJyYXkoKWAgb3IgYHRvQnVmZmVyKClgIG1ldGhvZC5cclxuICogQHBhcmFtIHYgdGhlIHZhbHVlXHJcbiAqL1xyXG52YXIgdG9CdWZmZXIgPSBmdW5jdGlvbiAodikge1xyXG4gICAgaWYgKHYgPT09IG51bGwgfHwgdiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKTtcclxuICAgIH1cclxuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIodikpIHtcclxuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odik7XHJcbiAgICB9XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2KSB8fCB2IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xyXG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh2KTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgdiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICBpZiAoISgwLCBpbnRlcm5hbF8xLmlzSGV4U3RyaW5nKSh2KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29udmVydCBzdHJpbmcgdG8gYnVmZmVyLiB0b0J1ZmZlciBvbmx5IHN1cHBvcnRzIDB4LXByZWZpeGVkIGhleCBzdHJpbmdzIGFuZCB0aGlzIHN0cmluZyB3YXMgZ2l2ZW46IFwiLmNvbmNhdCh2KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSgoMCwgaW50ZXJuYWxfMS5wYWRUb0V2ZW4pKCgwLCBpbnRlcm5hbF8xLnN0cmlwSGV4UHJlZml4KSh2KSksICdoZXgnKTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgdiA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuaW50VG9CdWZmZXIpKHYpO1xyXG4gICAgfVxyXG4gICAgaWYgKGV4dGVybmFsc18xLkJOLmlzQk4odikpIHtcclxuICAgICAgICBpZiAodi5pc05lZygpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb252ZXJ0IG5lZ2F0aXZlIEJOIHRvIGJ1ZmZlci4gR2l2ZW46IFwiLmNvbmNhdCh2KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2LnRvQXJyYXlMaWtlKEJ1ZmZlcik7XHJcbiAgICB9XHJcbiAgICBpZiAodi50b0FycmF5KSB7XHJcbiAgICAgICAgLy8gY29udmVydHMgYSBCTiB0byBhIEJ1ZmZlclxyXG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh2LnRvQXJyYXkoKSk7XHJcbiAgICB9XHJcbiAgICBpZiAodi50b0J1ZmZlcikge1xyXG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh2LnRvQnVmZmVyKCkpO1xyXG4gICAgfVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHR5cGUnKTtcclxufTtcclxuZXhwb3J0cy50b0J1ZmZlciA9IHRvQnVmZmVyO1xyXG4vKipcclxuICogQ29udmVydHMgYSBgQnVmZmVyYCB0byBhIGBOdW1iZXJgLlxyXG4gKiBAcGFyYW0gYnVmIGBCdWZmZXJgIG9iamVjdCB0byBjb252ZXJ0XHJcbiAqIEB0aHJvd3MgSWYgdGhlIGlucHV0IG51bWJlciBleGNlZWRzIDUzIGJpdHMuXHJcbiAqL1xyXG52YXIgYnVmZmVyVG9JbnQgPSBmdW5jdGlvbiAoYnVmKSB7XHJcbiAgICByZXR1cm4gbmV3IGV4dGVybmFsc18xLkJOKCgwLCBleHBvcnRzLnRvQnVmZmVyKShidWYpKS50b051bWJlcigpO1xyXG59O1xyXG5leHBvcnRzLmJ1ZmZlclRvSW50ID0gYnVmZmVyVG9JbnQ7XHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBhIGBCdWZmZXJgIGludG8gYSBgMHhgLXByZWZpeGVkIGhleCBgU3RyaW5nYC5cclxuICogQHBhcmFtIGJ1ZiBgQnVmZmVyYCBvYmplY3QgdG8gY29udmVydFxyXG4gKi9cclxudmFyIGJ1ZmZlclRvSGV4ID0gZnVuY3Rpb24gKGJ1Zikge1xyXG4gICAgYnVmID0gKDAsIGV4cG9ydHMudG9CdWZmZXIpKGJ1Zik7XHJcbiAgICByZXR1cm4gJzB4JyArIGJ1Zi50b1N0cmluZygnaGV4Jyk7XHJcbn07XHJcbmV4cG9ydHMuYnVmZmVyVG9IZXggPSBidWZmZXJUb0hleDtcclxuLyoqXHJcbiAqIEludGVycHJldHMgYSBgQnVmZmVyYCBhcyBhIHNpZ25lZCBpbnRlZ2VyIGFuZCByZXR1cm5zIGEgYEJOYC4gQXNzdW1lcyAyNTYtYml0IG51bWJlcnMuXHJcbiAqIEBwYXJhbSBudW0gU2lnbmVkIGludGVnZXIgdmFsdWVcclxuICovXHJcbnZhciBmcm9tU2lnbmVkID0gZnVuY3Rpb24gKG51bSkge1xyXG4gICAgcmV0dXJuIG5ldyBleHRlcm5hbHNfMS5CTihudW0pLmZyb21Ud29zKDI1Nik7XHJcbn07XHJcbmV4cG9ydHMuZnJvbVNpZ25lZCA9IGZyb21TaWduZWQ7XHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBhIGBCTmAgdG8gYW4gdW5zaWduZWQgaW50ZWdlciBhbmQgcmV0dXJucyBpdCBhcyBhIGBCdWZmZXJgLiBBc3N1bWVzIDI1Ni1iaXQgbnVtYmVycy5cclxuICogQHBhcmFtIG51bVxyXG4gKi9cclxudmFyIHRvVW5zaWduZWQgPSBmdW5jdGlvbiAobnVtKSB7XHJcbiAgICByZXR1cm4gQnVmZmVyLmZyb20obnVtLnRvVHdvcygyNTYpLnRvQXJyYXkoKSk7XHJcbn07XHJcbmV4cG9ydHMudG9VbnNpZ25lZCA9IHRvVW5zaWduZWQ7XHJcbi8qKlxyXG4gKiBBZGRzIFwiMHhcIiB0byBhIGdpdmVuIGBTdHJpbmdgIGlmIGl0IGRvZXMgbm90IGFscmVhZHkgc3RhcnQgd2l0aCBcIjB4XCIuXHJcbiAqL1xyXG52YXIgYWRkSGV4UHJlZml4ID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgIH1cclxuICAgIHJldHVybiAoMCwgaW50ZXJuYWxfMS5pc0hleFByZWZpeGVkKShzdHIpID8gc3RyIDogJzB4JyArIHN0cjtcclxufTtcclxuZXhwb3J0cy5hZGRIZXhQcmVmaXggPSBhZGRIZXhQcmVmaXg7XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSB1dGY4IHN0cmluZyByZXByZXNlbnRhdGlvbiBmcm9tIGEgaGV4IHN0cmluZy5cclxuICpcclxuICogRXhhbXBsZXM6XHJcbiAqXHJcbiAqIElucHV0IDE6ICc2NTc0Njg2NTcyNjU3NTZkMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJ1xyXG4gKiBJbnB1dCAyOiAnNjU3NDY4NjU3MjY1NzU2ZCdcclxuICogSW5wdXQgMzogJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDY1NzQ2ODY1NzI2NTc1NmQnXHJcbiAqXHJcbiAqIE91dHB1dCAoYWxsIDMgaW5wdXQgdmFyaWFudHMpOiAnZXRoZXJldW0nXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCBpcyBub3QgaW50ZW5kZWQgdG8gYmUgdXNlZCB3aXRoIGhleCBzdHJpbmdzXHJcbiAqIHJlcHJlc2VudGluZyBxdWFudGl0aWVzIGluIGJvdGggYmlnIGVuZGlhbiBvciBsaXR0bGUgZW5kaWFuIG5vdGF0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0gc3RyaW5nIEhleCBzdHJpbmcsIHNob3VsZCBiZSBgMHhgIHByZWZpeGVkXHJcbiAqIEByZXR1cm4gVXRmOCBzdHJpbmdcclxuICovXHJcbnZhciB0b1V0ZjggPSBmdW5jdGlvbiAoaGV4KSB7XHJcbiAgICB2YXIgemVyb3NSZWdleHAgPSAvXigwMCkrfCgwMCkrJC9nO1xyXG4gICAgaGV4ID0gKDAsIGludGVybmFsXzEuc3RyaXBIZXhQcmVmaXgpKGhleCk7XHJcbiAgICBpZiAoaGV4Lmxlbmd0aCAlIDIgIT09IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbm9uLWV2ZW4gaGV4IHN0cmluZyBpbnB1dCBmb3IgdG9VdGY4KCkgcHJvdmlkZWQnKTtcclxuICAgIH1cclxuICAgIHZhciBidWZmZXJWYWwgPSBCdWZmZXIuZnJvbShoZXgucmVwbGFjZSh6ZXJvc1JlZ2V4cCwgJycpLCAnaGV4Jyk7XHJcbiAgICByZXR1cm4gYnVmZmVyVmFsLnRvU3RyaW5nKCd1dGY4Jyk7XHJcbn07XHJcbmV4cG9ydHMudG9VdGY4ID0gdG9VdGY4O1xyXG4vKipcclxuICogQ29udmVydHMgYSBgQnVmZmVyYCBvciBgQXJyYXlgIHRvIEpTT04uXHJcbiAqIEBwYXJhbSBiYSAoQnVmZmVyfEFycmF5KVxyXG4gKiBAcmV0dXJuIChBcnJheXxTdHJpbmd8bnVsbClcclxuICovXHJcbnZhciBiYVRvSlNPTiA9IGZ1bmN0aW9uIChiYSkge1xyXG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihiYSkpIHtcclxuICAgICAgICByZXR1cm4gXCIweFwiLmNvbmNhdChiYS50b1N0cmluZygnaGV4JykpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoYmEgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAgIHZhciBhcnJheSA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgYXJyYXkucHVzaCgoMCwgZXhwb3J0cy5iYVRvSlNPTikoYmFbaV0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFycmF5O1xyXG4gICAgfVxyXG59O1xyXG5leHBvcnRzLmJhVG9KU09OID0gYmFUb0pTT047XHJcbi8qKlxyXG4gKiBDaGVja3MgcHJvdmlkZWQgQnVmZmVycyBmb3IgbGVhZGluZyB6ZXJvZXMgYW5kIHRocm93cyBpZiBmb3VuZC5cclxuICpcclxuICogRXhhbXBsZXM6XHJcbiAqXHJcbiAqIFZhbGlkIHZhbHVlczogMHgxLCAweCwgMHgwMSwgMHgxMjM0XHJcbiAqIEludmFsaWQgdmFsdWVzOiAweDAsIDB4MDAsIDB4MDAxLCAweDAwMDFcclxuICpcclxuICogTm90ZTogVGhpcyBtZXRob2QgaXMgdXNlZnVsIGZvciB2YWxpZGF0aW5nIHRoYXQgUkxQIGVuY29kZWQgaW50ZWdlcnMgY29tcGx5IHdpdGggdGhlIHJ1bGUgdGhhdCBhbGxcclxuICogaW50ZWdlciB2YWx1ZXMgZW5jb2RlZCB0byBSTFAgbXVzdCBiZSBpbiB0aGUgbW9zdCBjb21wYWN0IGZvcm0gYW5kIGNvbnRhaW4gbm8gbGVhZGluZyB6ZXJvIGJ5dGVzXHJcbiAqIEBwYXJhbSB2YWx1ZXMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgc3RyaW5nIGtleXMgYW5kIEJ1ZmZlciB2YWx1ZXNcclxuICogQHRocm93cyBpZiBhbnkgcHJvdmlkZWQgdmFsdWUgaXMgZm91bmQgdG8gaGF2ZSBsZWFkaW5nIHplcm8gYnl0ZXNcclxuICovXHJcbnZhciB2YWxpZGF0ZU5vTGVhZGluZ1plcm9lcyA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcclxuICAgIHZhciBlXzEsIF9hO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKE9iamVjdC5lbnRyaWVzKHZhbHVlcykpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XHJcbiAgICAgICAgICAgIHZhciBfZCA9IF9fcmVhZChfYy52YWx1ZSwgMiksIGsgPSBfZFswXSwgdiA9IF9kWzFdO1xyXG4gICAgICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkICYmIHYubGVuZ3RoID4gMCAmJiB2WzBdID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIi5jb25jYXQoaywgXCIgY2Fubm90IGhhdmUgbGVhZGluZyB6ZXJvZXMsIHJlY2VpdmVkOiBcIikuY29uY2F0KHYudG9TdHJpbmcoJ2hleCcpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XHJcbiAgICB9XHJcbn07XHJcbmV4cG9ydHMudmFsaWRhdGVOb0xlYWRpbmdaZXJvZXMgPSB2YWxpZGF0ZU5vTGVhZGluZ1plcm9lcztcclxuZnVuY3Rpb24gYXJyVG9CdWZBcnIoYXJyKSB7XHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyKSkge1xyXG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShhcnIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyci5tYXAoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGFyclRvQnVmQXJyKGEpOyB9KTtcclxufVxyXG5leHBvcnRzLmFyclRvQnVmQXJyID0gYXJyVG9CdWZBcnI7XHJcbmZ1bmN0aW9uIGJ1ZkFyclRvQXJyKGFycikge1xyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycikpIHtcclxuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGFyciAhPT0gbnVsbCAmJiBhcnIgIT09IHZvaWQgMCA/IGFyciA6IFtdKTtcclxuICAgIH1cclxuICAgIHJldHVybiBhcnIubWFwKGZ1bmN0aW9uIChhKSB7IHJldHVybiBidWZBcnJUb0FycihhKTsgfSk7XHJcbn1cclxuZXhwb3J0cy5idWZBcnJUb0FyciA9IGJ1ZkFyclRvQXJyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ieXRlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ethereumjs-util/dist.browser/bytes.js\n");

/***/ }),

/***/ "./node_modules/ethereumjs-util/dist.browser/constants.js":
/*!****************************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist.browser/constants.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.KECCAK256_RLP = exports.KECCAK256_RLP_S = exports.KECCAK256_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY_S = exports.KECCAK256_NULL = exports.KECCAK256_NULL_S = exports.TWO_POW256 = exports.MAX_INTEGER = exports.MAX_UINT64 = void 0;\r\nvar buffer_1 = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\");\r\nvar externals_1 = __webpack_require__(/*! ./externals */ \"./node_modules/ethereumjs-util/dist.browser/externals.js\");\r\n/**\r\n * 2^64-1\r\n */\r\nexports.MAX_UINT64 = new externals_1.BN('ffffffffffffffff', 16);\r\n/**\r\n * The max integer that the evm can handle (2^256-1)\r\n */\r\nexports.MAX_INTEGER = new externals_1.BN('ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 16);\r\n/**\r\n * 2^256\r\n */\r\nexports.TWO_POW256 = new externals_1.BN('10000000000000000000000000000000000000000000000000000000000000000', 16);\r\n/**\r\n * Keccak-256 hash of null\r\n */\r\nexports.KECCAK256_NULL_S = 'c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';\r\n/**\r\n * Keccak-256 hash of null\r\n */\r\nexports.KECCAK256_NULL = buffer_1.Buffer.from(exports.KECCAK256_NULL_S, 'hex');\r\n/**\r\n * Keccak-256 of an RLP of an empty array\r\n */\r\nexports.KECCAK256_RLP_ARRAY_S = '1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347';\r\n/**\r\n * Keccak-256 of an RLP of an empty array\r\n */\r\nexports.KECCAK256_RLP_ARRAY = buffer_1.Buffer.from(exports.KECCAK256_RLP_ARRAY_S, 'hex');\r\n/**\r\n * Keccak-256 hash of the RLP of null\r\n */\r\nexports.KECCAK256_RLP_S = '56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421';\r\n/**\r\n * Keccak-256 hash of the RLP of null\r\n */\r\nexports.KECCAK256_RLP = buffer_1.Buffer.from(exports.KECCAK256_RLP_S, 'hex');\r\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QuYnJvd3Nlci9jb25zdGFudHMuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCLEdBQUcsdUJBQXVCLEdBQUcsMkJBQTJCLEdBQUcsNkJBQTZCLEdBQUcsc0JBQXNCLEdBQUcsd0JBQXdCLEdBQUcsa0JBQWtCLEdBQUcsbUJBQW1CLEdBQUcsa0JBQWtCO0FBQ2pPLGVBQWUsbUJBQU8sQ0FBQyw4Q0FBUTtBQUMvQixrQkFBa0IsbUJBQU8sQ0FBQyw2RUFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QuYnJvd3Nlci9jb25zdGFudHMuanM/ZWY4ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLktFQ0NBSzI1Nl9STFAgPSBleHBvcnRzLktFQ0NBSzI1Nl9STFBfUyA9IGV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9BUlJBWSA9IGV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9BUlJBWV9TID0gZXhwb3J0cy5LRUNDQUsyNTZfTlVMTCA9IGV4cG9ydHMuS0VDQ0FLMjU2X05VTExfUyA9IGV4cG9ydHMuVFdPX1BPVzI1NiA9IGV4cG9ydHMuTUFYX0lOVEVHRVIgPSBleHBvcnRzLk1BWF9VSU5UNjQgPSB2b2lkIDA7XHJcbnZhciBidWZmZXJfMSA9IHJlcXVpcmUoXCJidWZmZXJcIik7XHJcbnZhciBleHRlcm5hbHNfMSA9IHJlcXVpcmUoXCIuL2V4dGVybmFsc1wiKTtcclxuLyoqXHJcbiAqIDJeNjQtMVxyXG4gKi9cclxuZXhwb3J0cy5NQVhfVUlOVDY0ID0gbmV3IGV4dGVybmFsc18xLkJOKCdmZmZmZmZmZmZmZmZmZmZmJywgMTYpO1xyXG4vKipcclxuICogVGhlIG1heCBpbnRlZ2VyIHRoYXQgdGhlIGV2bSBjYW4gaGFuZGxlICgyXjI1Ni0xKVxyXG4gKi9cclxuZXhwb3J0cy5NQVhfSU5URUdFUiA9IG5ldyBleHRlcm5hbHNfMS5CTignZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZicsIDE2KTtcclxuLyoqXHJcbiAqIDJeMjU2XHJcbiAqL1xyXG5leHBvcnRzLlRXT19QT1cyNTYgPSBuZXcgZXh0ZXJuYWxzXzEuQk4oJzEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJywgMTYpO1xyXG4vKipcclxuICogS2VjY2FrLTI1NiBoYXNoIG9mIG51bGxcclxuICovXHJcbmV4cG9ydHMuS0VDQ0FLMjU2X05VTExfUyA9ICdjNWQyNDYwMTg2ZjcyMzNjOTI3ZTdkYjJkY2M3MDNjMGU1MDBiNjUzY2E4MjI3M2I3YmZhZDgwNDVkODVhNDcwJztcclxuLyoqXHJcbiAqIEtlY2Nhay0yNTYgaGFzaCBvZiBudWxsXHJcbiAqL1xyXG5leHBvcnRzLktFQ0NBSzI1Nl9OVUxMID0gYnVmZmVyXzEuQnVmZmVyLmZyb20oZXhwb3J0cy5LRUNDQUsyNTZfTlVMTF9TLCAnaGV4Jyk7XHJcbi8qKlxyXG4gKiBLZWNjYWstMjU2IG9mIGFuIFJMUCBvZiBhbiBlbXB0eSBhcnJheVxyXG4gKi9cclxuZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZX1MgPSAnMWRjYzRkZThkZWM3NWQ3YWFiODViNTY3YjZjY2Q0MWFkMzEyNDUxYjk0OGE3NDEzZjBhMTQyZmQ0MGQ0OTM0Nyc7XHJcbi8qKlxyXG4gKiBLZWNjYWstMjU2IG9mIGFuIFJMUCBvZiBhbiBlbXB0eSBhcnJheVxyXG4gKi9cclxuZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZID0gYnVmZmVyXzEuQnVmZmVyLmZyb20oZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZX1MsICdoZXgnKTtcclxuLyoqXHJcbiAqIEtlY2Nhay0yNTYgaGFzaCBvZiB0aGUgUkxQIG9mIG51bGxcclxuICovXHJcbmV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9TID0gJzU2ZTgxZjE3MWJjYzU1YTZmZjgzNDVlNjkyYzBmODZlNWI0OGUwMWI5OTZjYWRjMDAxNjIyZmI1ZTM2M2I0MjEnO1xyXG4vKipcclxuICogS2VjY2FrLTI1NiBoYXNoIG9mIHRoZSBSTFAgb2YgbnVsbFxyXG4gKi9cclxuZXhwb3J0cy5LRUNDQUsyNTZfUkxQID0gYnVmZmVyXzEuQnVmZmVyLmZyb20oZXhwb3J0cy5LRUNDQUsyNTZfUkxQX1MsICdoZXgnKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ethereumjs-util/dist.browser/constants.js\n");

/***/ }),

/***/ "./node_modules/ethereumjs-util/dist.browser/externals.js":
/*!****************************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist.browser/externals.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\r\n/**\r\n * Re-exports commonly used modules:\r\n * * Exports [`BN`](https://github.com/indutny/bn.js), [`rlp`](https://github.com/ethereumjs/rlp).\r\n * @packageDocumentation\r\n */\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.rlp = exports.BN = void 0;\r\nvar bn_js_1 = __importDefault(__webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\"));\r\nexports.BN = bn_js_1.default;\r\nvar rlp = __importStar(__webpack_require__(/*! rlp */ \"./node_modules/rlp/dist.browser/index.js\"));\r\nexports.rlp = rlp;\r\n//# sourceMappingURL=externals.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QuYnJvd3Nlci9leHRlcm5hbHMuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxvQ0FBb0MsZ0JBQWdCO0FBQ3ZGLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxXQUFXLEdBQUcsVUFBVTtBQUN4Qiw4QkFBOEIsbUJBQU8sQ0FBQyw2Q0FBTztBQUM3QyxVQUFVO0FBQ1YsdUJBQXVCLG1CQUFPLENBQUMscURBQUs7QUFDcEMsV0FBVztBQUNYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC5icm93c2VyL2V4dGVybmFscy5qcz9hMDRiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG4vKipcclxuICogUmUtZXhwb3J0cyBjb21tb25seSB1c2VkIG1vZHVsZXM6XHJcbiAqICogRXhwb3J0cyBbYEJOYF0oaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMpLCBbYHJscGBdKGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bWpzL3JscCkuXHJcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxyXG4gKi9cclxudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcclxufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBvW2syXSA9IG1ba107XHJcbn0pKTtcclxudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XHJcbn0pIDogZnVuY3Rpb24obywgdikge1xyXG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xyXG59KTtcclxudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xyXG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5ybHAgPSBleHBvcnRzLkJOID0gdm9pZCAwO1xyXG52YXIgYm5fanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYm4uanNcIikpO1xyXG5leHBvcnRzLkJOID0gYm5fanNfMS5kZWZhdWx0O1xyXG52YXIgcmxwID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJybHBcIikpO1xyXG5leHBvcnRzLnJscCA9IHJscDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXh0ZXJuYWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ethereumjs-util/dist.browser/externals.js\n");

/***/ }),

/***/ "./node_modules/ethereumjs-util/dist.browser/hash.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist.browser/hash.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.rlphash = exports.ripemd160FromArray = exports.ripemd160FromString = exports.ripemd160 = exports.sha256FromArray = exports.sha256FromString = exports.sha256 = exports.keccakFromArray = exports.keccakFromHexString = exports.keccakFromString = exports.keccak256 = exports.keccak = void 0;\r\nvar keccak_1 = __webpack_require__(/*! ethereum-cryptography/keccak */ \"./node_modules/ethereum-cryptography/keccak.js\");\r\nvar createHash = __webpack_require__(/*! create-hash */ \"./node_modules/create-hash/browser.js\");\r\nvar externals_1 = __webpack_require__(/*! ./externals */ \"./node_modules/ethereumjs-util/dist.browser/externals.js\");\r\nvar bytes_1 = __webpack_require__(/*! ./bytes */ \"./node_modules/ethereumjs-util/dist.browser/bytes.js\");\r\nvar helpers_1 = __webpack_require__(/*! ./helpers */ \"./node_modules/ethereumjs-util/dist.browser/helpers.js\");\r\n/**\r\n * Creates Keccak hash of a Buffer input\r\n * @param a The input data (Buffer)\r\n * @param bits (number = 256) The Keccak width\r\n */\r\nvar keccak = function (a, bits) {\r\n    if (bits === void 0) { bits = 256; }\r\n    (0, helpers_1.assertIsBuffer)(a);\r\n    switch (bits) {\r\n        case 224: {\r\n            return (0, keccak_1.keccak224)(a);\r\n        }\r\n        case 256: {\r\n            return (0, keccak_1.keccak256)(a);\r\n        }\r\n        case 384: {\r\n            return (0, keccak_1.keccak384)(a);\r\n        }\r\n        case 512: {\r\n            return (0, keccak_1.keccak512)(a);\r\n        }\r\n        default: {\r\n            throw new Error(\"Invald algorithm: keccak\".concat(bits));\r\n        }\r\n    }\r\n};\r\nexports.keccak = keccak;\r\n/**\r\n * Creates Keccak-256 hash of the input, alias for keccak(a, 256).\r\n * @param a The input data (Buffer)\r\n */\r\nvar keccak256 = function (a) {\r\n    return (0, exports.keccak)(a);\r\n};\r\nexports.keccak256 = keccak256;\r\n/**\r\n * Creates Keccak hash of a utf-8 string input\r\n * @param a The input data (String)\r\n * @param bits (number = 256) The Keccak width\r\n */\r\nvar keccakFromString = function (a, bits) {\r\n    if (bits === void 0) { bits = 256; }\r\n    (0, helpers_1.assertIsString)(a);\r\n    var buf = Buffer.from(a, 'utf8');\r\n    return (0, exports.keccak)(buf, bits);\r\n};\r\nexports.keccakFromString = keccakFromString;\r\n/**\r\n * Creates Keccak hash of an 0x-prefixed string input\r\n * @param a The input data (String)\r\n * @param bits (number = 256) The Keccak width\r\n */\r\nvar keccakFromHexString = function (a, bits) {\r\n    if (bits === void 0) { bits = 256; }\r\n    (0, helpers_1.assertIsHexString)(a);\r\n    return (0, exports.keccak)((0, bytes_1.toBuffer)(a), bits);\r\n};\r\nexports.keccakFromHexString = keccakFromHexString;\r\n/**\r\n * Creates Keccak hash of a number array input\r\n * @param a The input data (number[])\r\n * @param bits (number = 256) The Keccak width\r\n */\r\nvar keccakFromArray = function (a, bits) {\r\n    if (bits === void 0) { bits = 256; }\r\n    (0, helpers_1.assertIsArray)(a);\r\n    return (0, exports.keccak)((0, bytes_1.toBuffer)(a), bits);\r\n};\r\nexports.keccakFromArray = keccakFromArray;\r\n/**\r\n * Creates SHA256 hash of an input.\r\n * @param  a The input data (Buffer|Array|String)\r\n */\r\nvar _sha256 = function (a) {\r\n    a = (0, bytes_1.toBuffer)(a);\r\n    return createHash('sha256').update(a).digest();\r\n};\r\n/**\r\n * Creates SHA256 hash of a Buffer input.\r\n * @param a The input data (Buffer)\r\n */\r\nvar sha256 = function (a) {\r\n    (0, helpers_1.assertIsBuffer)(a);\r\n    return _sha256(a);\r\n};\r\nexports.sha256 = sha256;\r\n/**\r\n * Creates SHA256 hash of a string input.\r\n * @param a The input data (string)\r\n */\r\nvar sha256FromString = function (a) {\r\n    (0, helpers_1.assertIsString)(a);\r\n    return _sha256(a);\r\n};\r\nexports.sha256FromString = sha256FromString;\r\n/**\r\n * Creates SHA256 hash of a number[] input.\r\n * @param a The input data (number[])\r\n */\r\nvar sha256FromArray = function (a) {\r\n    (0, helpers_1.assertIsArray)(a);\r\n    return _sha256(a);\r\n};\r\nexports.sha256FromArray = sha256FromArray;\r\n/**\r\n * Creates RIPEMD160 hash of the input.\r\n * @param a The input data (Buffer|Array|String|Number)\r\n * @param padded Whether it should be padded to 256 bits or not\r\n */\r\nvar _ripemd160 = function (a, padded) {\r\n    a = (0, bytes_1.toBuffer)(a);\r\n    var hash = createHash('rmd160').update(a).digest();\r\n    if (padded === true) {\r\n        return (0, bytes_1.setLengthLeft)(hash, 32);\r\n    }\r\n    else {\r\n        return hash;\r\n    }\r\n};\r\n/**\r\n * Creates RIPEMD160 hash of a Buffer input.\r\n * @param a The input data (Buffer)\r\n * @param padded Whether it should be padded to 256 bits or not\r\n */\r\nvar ripemd160 = function (a, padded) {\r\n    (0, helpers_1.assertIsBuffer)(a);\r\n    return _ripemd160(a, padded);\r\n};\r\nexports.ripemd160 = ripemd160;\r\n/**\r\n * Creates RIPEMD160 hash of a string input.\r\n * @param a The input data (String)\r\n * @param padded Whether it should be padded to 256 bits or not\r\n */\r\nvar ripemd160FromString = function (a, padded) {\r\n    (0, helpers_1.assertIsString)(a);\r\n    return _ripemd160(a, padded);\r\n};\r\nexports.ripemd160FromString = ripemd160FromString;\r\n/**\r\n * Creates RIPEMD160 hash of a number[] input.\r\n * @param a The input data (number[])\r\n * @param padded Whether it should be padded to 256 bits or not\r\n */\r\nvar ripemd160FromArray = function (a, padded) {\r\n    (0, helpers_1.assertIsArray)(a);\r\n    return _ripemd160(a, padded);\r\n};\r\nexports.ripemd160FromArray = ripemd160FromArray;\r\n/**\r\n * Creates SHA-3 hash of the RLP encoded version of the input.\r\n * @param a The input data\r\n */\r\nvar rlphash = function (a) {\r\n    return (0, exports.keccak)(externals_1.rlp.encode(a));\r\n};\r\nexports.rlphash = rlphash;\r\n//# sourceMappingURL=hash.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QuYnJvd3Nlci9oYXNoLmpzLmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlLEdBQUcsMEJBQTBCLEdBQUcsMkJBQTJCLEdBQUcsaUJBQWlCLEdBQUcsdUJBQXVCLEdBQUcsd0JBQXdCLEdBQUcsY0FBYyxHQUFHLHVCQUF1QixHQUFHLDJCQUEyQixHQUFHLHdCQUF3QixHQUFHLGlCQUFpQixHQUFHLGNBQWM7QUFDNVIsZUFBZSxtQkFBTyxDQUFDLG9GQUE4QjtBQUNyRCxpQkFBaUIsbUJBQU8sQ0FBQywwREFBYTtBQUN0QyxrQkFBa0IsbUJBQU8sQ0FBQyw2RUFBYTtBQUN2QyxjQUFjLG1CQUFPLENBQUMscUVBQVM7QUFDL0IsZ0JBQWdCLG1CQUFPLENBQUMseUVBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0LmJyb3dzZXIvaGFzaC5qcz9hNjg3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMucmxwaGFzaCA9IGV4cG9ydHMucmlwZW1kMTYwRnJvbUFycmF5ID0gZXhwb3J0cy5yaXBlbWQxNjBGcm9tU3RyaW5nID0gZXhwb3J0cy5yaXBlbWQxNjAgPSBleHBvcnRzLnNoYTI1NkZyb21BcnJheSA9IGV4cG9ydHMuc2hhMjU2RnJvbVN0cmluZyA9IGV4cG9ydHMuc2hhMjU2ID0gZXhwb3J0cy5rZWNjYWtGcm9tQXJyYXkgPSBleHBvcnRzLmtlY2Nha0Zyb21IZXhTdHJpbmcgPSBleHBvcnRzLmtlY2Nha0Zyb21TdHJpbmcgPSBleHBvcnRzLmtlY2NhazI1NiA9IGV4cG9ydHMua2VjY2FrID0gdm9pZCAwO1xyXG52YXIga2VjY2FrXzEgPSByZXF1aXJlKFwiZXRoZXJldW0tY3J5cHRvZ3JhcGh5L2tlY2Nha1wiKTtcclxudmFyIGNyZWF0ZUhhc2ggPSByZXF1aXJlKCdjcmVhdGUtaGFzaCcpO1xyXG52YXIgZXh0ZXJuYWxzXzEgPSByZXF1aXJlKFwiLi9leHRlcm5hbHNcIik7XHJcbnZhciBieXRlc18xID0gcmVxdWlyZShcIi4vYnl0ZXNcIik7XHJcbnZhciBoZWxwZXJzXzEgPSByZXF1aXJlKFwiLi9oZWxwZXJzXCIpO1xyXG4vKipcclxuICogQ3JlYXRlcyBLZWNjYWsgaGFzaCBvZiBhIEJ1ZmZlciBpbnB1dFxyXG4gKiBAcGFyYW0gYSBUaGUgaW5wdXQgZGF0YSAoQnVmZmVyKVxyXG4gKiBAcGFyYW0gYml0cyAobnVtYmVyID0gMjU2KSBUaGUgS2VjY2FrIHdpZHRoXHJcbiAqL1xyXG52YXIga2VjY2FrID0gZnVuY3Rpb24gKGEsIGJpdHMpIHtcclxuICAgIGlmIChiaXRzID09PSB2b2lkIDApIHsgYml0cyA9IDI1NjsgfVxyXG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc0J1ZmZlcikoYSk7XHJcbiAgICBzd2l0Y2ggKGJpdHMpIHtcclxuICAgICAgICBjYXNlIDIyNDoge1xyXG4gICAgICAgICAgICByZXR1cm4gKDAsIGtlY2Nha18xLmtlY2NhazIyNCkoYSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgMjU2OiB7XHJcbiAgICAgICAgICAgIHJldHVybiAoMCwga2VjY2FrXzEua2VjY2FrMjU2KShhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSAzODQ6IHtcclxuICAgICAgICAgICAgcmV0dXJuICgwLCBrZWNjYWtfMS5rZWNjYWszODQpKGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIDUxMjoge1xyXG4gICAgICAgICAgICByZXR1cm4gKDAsIGtlY2Nha18xLmtlY2NhazUxMikoYSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlZmF1bHQ6IHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxkIGFsZ29yaXRobToga2VjY2FrXCIuY29uY2F0KGJpdHMpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbmV4cG9ydHMua2VjY2FrID0ga2VjY2FrO1xyXG4vKipcclxuICogQ3JlYXRlcyBLZWNjYWstMjU2IGhhc2ggb2YgdGhlIGlucHV0LCBhbGlhcyBmb3Iga2VjY2FrKGEsIDI1NikuXHJcbiAqIEBwYXJhbSBhIFRoZSBpbnB1dCBkYXRhIChCdWZmZXIpXHJcbiAqL1xyXG52YXIga2VjY2FrMjU2ID0gZnVuY3Rpb24gKGEpIHtcclxuICAgIHJldHVybiAoMCwgZXhwb3J0cy5rZWNjYWspKGEpO1xyXG59O1xyXG5leHBvcnRzLmtlY2NhazI1NiA9IGtlY2NhazI1NjtcclxuLyoqXHJcbiAqIENyZWF0ZXMgS2VjY2FrIGhhc2ggb2YgYSB1dGYtOCBzdHJpbmcgaW5wdXRcclxuICogQHBhcmFtIGEgVGhlIGlucHV0IGRhdGEgKFN0cmluZylcclxuICogQHBhcmFtIGJpdHMgKG51bWJlciA9IDI1NikgVGhlIEtlY2NhayB3aWR0aFxyXG4gKi9cclxudmFyIGtlY2Nha0Zyb21TdHJpbmcgPSBmdW5jdGlvbiAoYSwgYml0cykge1xyXG4gICAgaWYgKGJpdHMgPT09IHZvaWQgMCkgeyBiaXRzID0gMjU2OyB9XHJcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzU3RyaW5nKShhKTtcclxuICAgIHZhciBidWYgPSBCdWZmZXIuZnJvbShhLCAndXRmOCcpO1xyXG4gICAgcmV0dXJuICgwLCBleHBvcnRzLmtlY2NhaykoYnVmLCBiaXRzKTtcclxufTtcclxuZXhwb3J0cy5rZWNjYWtGcm9tU3RyaW5nID0ga2VjY2FrRnJvbVN0cmluZztcclxuLyoqXHJcbiAqIENyZWF0ZXMgS2VjY2FrIGhhc2ggb2YgYW4gMHgtcHJlZml4ZWQgc3RyaW5nIGlucHV0XHJcbiAqIEBwYXJhbSBhIFRoZSBpbnB1dCBkYXRhIChTdHJpbmcpXHJcbiAqIEBwYXJhbSBiaXRzIChudW1iZXIgPSAyNTYpIFRoZSBLZWNjYWsgd2lkdGhcclxuICovXHJcbnZhciBrZWNjYWtGcm9tSGV4U3RyaW5nID0gZnVuY3Rpb24gKGEsIGJpdHMpIHtcclxuICAgIGlmIChiaXRzID09PSB2b2lkIDApIHsgYml0cyA9IDI1NjsgfVxyXG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc0hleFN0cmluZykoYSk7XHJcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMua2VjY2FrKSgoMCwgYnl0ZXNfMS50b0J1ZmZlcikoYSksIGJpdHMpO1xyXG59O1xyXG5leHBvcnRzLmtlY2Nha0Zyb21IZXhTdHJpbmcgPSBrZWNjYWtGcm9tSGV4U3RyaW5nO1xyXG4vKipcclxuICogQ3JlYXRlcyBLZWNjYWsgaGFzaCBvZiBhIG51bWJlciBhcnJheSBpbnB1dFxyXG4gKiBAcGFyYW0gYSBUaGUgaW5wdXQgZGF0YSAobnVtYmVyW10pXHJcbiAqIEBwYXJhbSBiaXRzIChudW1iZXIgPSAyNTYpIFRoZSBLZWNjYWsgd2lkdGhcclxuICovXHJcbnZhciBrZWNjYWtGcm9tQXJyYXkgPSBmdW5jdGlvbiAoYSwgYml0cykge1xyXG4gICAgaWYgKGJpdHMgPT09IHZvaWQgMCkgeyBiaXRzID0gMjU2OyB9XHJcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzQXJyYXkpKGEpO1xyXG4gICAgcmV0dXJuICgwLCBleHBvcnRzLmtlY2NhaykoKDAsIGJ5dGVzXzEudG9CdWZmZXIpKGEpLCBiaXRzKTtcclxufTtcclxuZXhwb3J0cy5rZWNjYWtGcm9tQXJyYXkgPSBrZWNjYWtGcm9tQXJyYXk7XHJcbi8qKlxyXG4gKiBDcmVhdGVzIFNIQTI1NiBoYXNoIG9mIGFuIGlucHV0LlxyXG4gKiBAcGFyYW0gIGEgVGhlIGlucHV0IGRhdGEgKEJ1ZmZlcnxBcnJheXxTdHJpbmcpXHJcbiAqL1xyXG52YXIgX3NoYTI1NiA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICBhID0gKDAsIGJ5dGVzXzEudG9CdWZmZXIpKGEpO1xyXG4gICAgcmV0dXJuIGNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShhKS5kaWdlc3QoKTtcclxufTtcclxuLyoqXHJcbiAqIENyZWF0ZXMgU0hBMjU2IGhhc2ggb2YgYSBCdWZmZXIgaW5wdXQuXHJcbiAqIEBwYXJhbSBhIFRoZSBpbnB1dCBkYXRhIChCdWZmZXIpXHJcbiAqL1xyXG52YXIgc2hhMjU2ID0gZnVuY3Rpb24gKGEpIHtcclxuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIpKGEpO1xyXG4gICAgcmV0dXJuIF9zaGEyNTYoYSk7XHJcbn07XHJcbmV4cG9ydHMuc2hhMjU2ID0gc2hhMjU2O1xyXG4vKipcclxuICogQ3JlYXRlcyBTSEEyNTYgaGFzaCBvZiBhIHN0cmluZyBpbnB1dC5cclxuICogQHBhcmFtIGEgVGhlIGlucHV0IGRhdGEgKHN0cmluZylcclxuICovXHJcbnZhciBzaGEyNTZGcm9tU3RyaW5nID0gZnVuY3Rpb24gKGEpIHtcclxuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNTdHJpbmcpKGEpO1xyXG4gICAgcmV0dXJuIF9zaGEyNTYoYSk7XHJcbn07XHJcbmV4cG9ydHMuc2hhMjU2RnJvbVN0cmluZyA9IHNoYTI1NkZyb21TdHJpbmc7XHJcbi8qKlxyXG4gKiBDcmVhdGVzIFNIQTI1NiBoYXNoIG9mIGEgbnVtYmVyW10gaW5wdXQuXHJcbiAqIEBwYXJhbSBhIFRoZSBpbnB1dCBkYXRhIChudW1iZXJbXSlcclxuICovXHJcbnZhciBzaGEyNTZGcm9tQXJyYXkgPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc0FycmF5KShhKTtcclxuICAgIHJldHVybiBfc2hhMjU2KGEpO1xyXG59O1xyXG5leHBvcnRzLnNoYTI1NkZyb21BcnJheSA9IHNoYTI1NkZyb21BcnJheTtcclxuLyoqXHJcbiAqIENyZWF0ZXMgUklQRU1EMTYwIGhhc2ggb2YgdGhlIGlucHV0LlxyXG4gKiBAcGFyYW0gYSBUaGUgaW5wdXQgZGF0YSAoQnVmZmVyfEFycmF5fFN0cmluZ3xOdW1iZXIpXHJcbiAqIEBwYXJhbSBwYWRkZWQgV2hldGhlciBpdCBzaG91bGQgYmUgcGFkZGVkIHRvIDI1NiBiaXRzIG9yIG5vdFxyXG4gKi9cclxudmFyIF9yaXBlbWQxNjAgPSBmdW5jdGlvbiAoYSwgcGFkZGVkKSB7XHJcbiAgICBhID0gKDAsIGJ5dGVzXzEudG9CdWZmZXIpKGEpO1xyXG4gICAgdmFyIGhhc2ggPSBjcmVhdGVIYXNoKCdybWQxNjAnKS51cGRhdGUoYSkuZGlnZXN0KCk7XHJcbiAgICBpZiAocGFkZGVkID09PSB0cnVlKSB7XHJcbiAgICAgICAgcmV0dXJuICgwLCBieXRlc18xLnNldExlbmd0aExlZnQpKGhhc2gsIDMyKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBoYXNoO1xyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogQ3JlYXRlcyBSSVBFTUQxNjAgaGFzaCBvZiBhIEJ1ZmZlciBpbnB1dC5cclxuICogQHBhcmFtIGEgVGhlIGlucHV0IGRhdGEgKEJ1ZmZlcilcclxuICogQHBhcmFtIHBhZGRlZCBXaGV0aGVyIGl0IHNob3VsZCBiZSBwYWRkZWQgdG8gMjU2IGJpdHMgb3Igbm90XHJcbiAqL1xyXG52YXIgcmlwZW1kMTYwID0gZnVuY3Rpb24gKGEsIHBhZGRlZCkge1xyXG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc0J1ZmZlcikoYSk7XHJcbiAgICByZXR1cm4gX3JpcGVtZDE2MChhLCBwYWRkZWQpO1xyXG59O1xyXG5leHBvcnRzLnJpcGVtZDE2MCA9IHJpcGVtZDE2MDtcclxuLyoqXHJcbiAqIENyZWF0ZXMgUklQRU1EMTYwIGhhc2ggb2YgYSBzdHJpbmcgaW5wdXQuXHJcbiAqIEBwYXJhbSBhIFRoZSBpbnB1dCBkYXRhIChTdHJpbmcpXHJcbiAqIEBwYXJhbSBwYWRkZWQgV2hldGhlciBpdCBzaG91bGQgYmUgcGFkZGVkIHRvIDI1NiBiaXRzIG9yIG5vdFxyXG4gKi9cclxudmFyIHJpcGVtZDE2MEZyb21TdHJpbmcgPSBmdW5jdGlvbiAoYSwgcGFkZGVkKSB7XHJcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzU3RyaW5nKShhKTtcclxuICAgIHJldHVybiBfcmlwZW1kMTYwKGEsIHBhZGRlZCk7XHJcbn07XHJcbmV4cG9ydHMucmlwZW1kMTYwRnJvbVN0cmluZyA9IHJpcGVtZDE2MEZyb21TdHJpbmc7XHJcbi8qKlxyXG4gKiBDcmVhdGVzIFJJUEVNRDE2MCBoYXNoIG9mIGEgbnVtYmVyW10gaW5wdXQuXHJcbiAqIEBwYXJhbSBhIFRoZSBpbnB1dCBkYXRhIChudW1iZXJbXSlcclxuICogQHBhcmFtIHBhZGRlZCBXaGV0aGVyIGl0IHNob3VsZCBiZSBwYWRkZWQgdG8gMjU2IGJpdHMgb3Igbm90XHJcbiAqL1xyXG52YXIgcmlwZW1kMTYwRnJvbUFycmF5ID0gZnVuY3Rpb24gKGEsIHBhZGRlZCkge1xyXG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc0FycmF5KShhKTtcclxuICAgIHJldHVybiBfcmlwZW1kMTYwKGEsIHBhZGRlZCk7XHJcbn07XHJcbmV4cG9ydHMucmlwZW1kMTYwRnJvbUFycmF5ID0gcmlwZW1kMTYwRnJvbUFycmF5O1xyXG4vKipcclxuICogQ3JlYXRlcyBTSEEtMyBoYXNoIG9mIHRoZSBSTFAgZW5jb2RlZCB2ZXJzaW9uIG9mIHRoZSBpbnB1dC5cclxuICogQHBhcmFtIGEgVGhlIGlucHV0IGRhdGFcclxuICovXHJcbnZhciBybHBoYXNoID0gZnVuY3Rpb24gKGEpIHtcclxuICAgIHJldHVybiAoMCwgZXhwb3J0cy5rZWNjYWspKGV4dGVybmFsc18xLnJscC5lbmNvZGUoYSkpO1xyXG59O1xyXG5leHBvcnRzLnJscGhhc2ggPSBybHBoYXNoO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNoLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ethereumjs-util/dist.browser/hash.js\n");

/***/ }),

/***/ "./node_modules/ethereumjs-util/dist.browser/helpers.js":
/*!**************************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist.browser/helpers.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.assertIsString = exports.assertIsArray = exports.assertIsBuffer = exports.assertIsHexString = void 0;\r\nvar internal_1 = __webpack_require__(/*! ./internal */ \"./node_modules/ethereumjs-util/dist.browser/internal.js\");\r\n/**\r\n * Throws if a string is not hex prefixed\r\n * @param {string} input string to check hex prefix of\r\n */\r\nvar assertIsHexString = function (input) {\r\n    if (!(0, internal_1.isHexString)(input)) {\r\n        var msg = \"This method only supports 0x-prefixed hex strings but input was: \".concat(input);\r\n        throw new Error(msg);\r\n    }\r\n};\r\nexports.assertIsHexString = assertIsHexString;\r\n/**\r\n * Throws if input is not a buffer\r\n * @param {Buffer} input value to check\r\n */\r\nvar assertIsBuffer = function (input) {\r\n    if (!Buffer.isBuffer(input)) {\r\n        var msg = \"This method only supports Buffer but input was: \".concat(input);\r\n        throw new Error(msg);\r\n    }\r\n};\r\nexports.assertIsBuffer = assertIsBuffer;\r\n/**\r\n * Throws if input is not an array\r\n * @param {number[]} input value to check\r\n */\r\nvar assertIsArray = function (input) {\r\n    if (!Array.isArray(input)) {\r\n        var msg = \"This method only supports number arrays but input was: \".concat(input);\r\n        throw new Error(msg);\r\n    }\r\n};\r\nexports.assertIsArray = assertIsArray;\r\n/**\r\n * Throws if input is not a string\r\n * @param {string} input value to check\r\n */\r\nvar assertIsString = function (input) {\r\n    if (typeof input !== 'string') {\r\n        var msg = \"This method only supports strings but input was: \".concat(input);\r\n        throw new Error(msg);\r\n    }\r\n};\r\nexports.assertIsString = assertIsString;\r\n//# sourceMappingURL=helpers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QuYnJvd3Nlci9oZWxwZXJzLmpzLmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0IsR0FBRyxxQkFBcUIsR0FBRyxzQkFBc0IsR0FBRyx5QkFBeUI7QUFDbkcsaUJBQWlCLG1CQUFPLENBQUMsMkVBQVk7QUFDckM7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQSxTQUFTLE1BQU07QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0LmJyb3dzZXIvaGVscGVycy5qcz9iN2E1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuYXNzZXJ0SXNTdHJpbmcgPSBleHBvcnRzLmFzc2VydElzQXJyYXkgPSBleHBvcnRzLmFzc2VydElzQnVmZmVyID0gZXhwb3J0cy5hc3NlcnRJc0hleFN0cmluZyA9IHZvaWQgMDtcclxudmFyIGludGVybmFsXzEgPSByZXF1aXJlKFwiLi9pbnRlcm5hbFwiKTtcclxuLyoqXHJcbiAqIFRocm93cyBpZiBhIHN0cmluZyBpcyBub3QgaGV4IHByZWZpeGVkXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCBzdHJpbmcgdG8gY2hlY2sgaGV4IHByZWZpeCBvZlxyXG4gKi9cclxudmFyIGFzc2VydElzSGV4U3RyaW5nID0gZnVuY3Rpb24gKGlucHV0KSB7XHJcbiAgICBpZiAoISgwLCBpbnRlcm5hbF8xLmlzSGV4U3RyaW5nKShpbnB1dCkpIHtcclxuICAgICAgICB2YXIgbXNnID0gXCJUaGlzIG1ldGhvZCBvbmx5IHN1cHBvcnRzIDB4LXByZWZpeGVkIGhleCBzdHJpbmdzIGJ1dCBpbnB1dCB3YXM6IFwiLmNvbmNhdChpbnB1dCk7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XHJcbiAgICB9XHJcbn07XHJcbmV4cG9ydHMuYXNzZXJ0SXNIZXhTdHJpbmcgPSBhc3NlcnRJc0hleFN0cmluZztcclxuLyoqXHJcbiAqIFRocm93cyBpZiBpbnB1dCBpcyBub3QgYSBidWZmZXJcclxuICogQHBhcmFtIHtCdWZmZXJ9IGlucHV0IHZhbHVlIHRvIGNoZWNrXHJcbiAqL1xyXG52YXIgYXNzZXJ0SXNCdWZmZXIgPSBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGlucHV0KSkge1xyXG4gICAgICAgIHZhciBtc2cgPSBcIlRoaXMgbWV0aG9kIG9ubHkgc3VwcG9ydHMgQnVmZmVyIGJ1dCBpbnB1dCB3YXM6IFwiLmNvbmNhdChpbnB1dCk7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XHJcbiAgICB9XHJcbn07XHJcbmV4cG9ydHMuYXNzZXJ0SXNCdWZmZXIgPSBhc3NlcnRJc0J1ZmZlcjtcclxuLyoqXHJcbiAqIFRocm93cyBpZiBpbnB1dCBpcyBub3QgYW4gYXJyYXlcclxuICogQHBhcmFtIHtudW1iZXJbXX0gaW5wdXQgdmFsdWUgdG8gY2hlY2tcclxuICovXHJcbnZhciBhc3NlcnRJc0FycmF5ID0gZnVuY3Rpb24gKGlucHV0KSB7XHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XHJcbiAgICAgICAgdmFyIG1zZyA9IFwiVGhpcyBtZXRob2Qgb25seSBzdXBwb3J0cyBudW1iZXIgYXJyYXlzIGJ1dCBpbnB1dCB3YXM6IFwiLmNvbmNhdChpbnB1dCk7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XHJcbiAgICB9XHJcbn07XHJcbmV4cG9ydHMuYXNzZXJ0SXNBcnJheSA9IGFzc2VydElzQXJyYXk7XHJcbi8qKlxyXG4gKiBUaHJvd3MgaWYgaW5wdXQgaXMgbm90IGEgc3RyaW5nXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCB2YWx1ZSB0byBjaGVja1xyXG4gKi9cclxudmFyIGFzc2VydElzU3RyaW5nID0gZnVuY3Rpb24gKGlucHV0KSB7XHJcbiAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHZhciBtc2cgPSBcIlRoaXMgbWV0aG9kIG9ubHkgc3VwcG9ydHMgc3RyaW5ncyBidXQgaW5wdXQgd2FzOiBcIi5jb25jYXQoaW5wdXQpO1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xyXG4gICAgfVxyXG59O1xyXG5leHBvcnRzLmFzc2VydElzU3RyaW5nID0gYXNzZXJ0SXNTdHJpbmc7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlbHBlcnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ethereumjs-util/dist.browser/helpers.js\n");

/***/ }),

/***/ "./node_modules/ethereumjs-util/dist.browser/index.js":
/*!************************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist.browser/index.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.isHexString = exports.getKeys = exports.fromAscii = exports.fromUtf8 = exports.toAscii = exports.arrayContainsArray = exports.getBinarySize = exports.padToEven = exports.stripHexPrefix = exports.isHexPrefixed = void 0;\r\n/**\r\n * Constants\r\n */\r\n__exportStar(__webpack_require__(/*! ./constants */ \"./node_modules/ethereumjs-util/dist.browser/constants.js\"), exports);\r\n/**\r\n * Account class and helper functions\r\n */\r\n__exportStar(__webpack_require__(/*! ./account */ \"./node_modules/ethereumjs-util/dist.browser/account.js\"), exports);\r\n/**\r\n * Address type\r\n */\r\n__exportStar(__webpack_require__(/*! ./address */ \"./node_modules/ethereumjs-util/dist.browser/address.js\"), exports);\r\n/**\r\n * Hash functions\r\n */\r\n__exportStar(__webpack_require__(/*! ./hash */ \"./node_modules/ethereumjs-util/dist.browser/hash.js\"), exports);\r\n/**\r\n * ECDSA signature\r\n */\r\n__exportStar(__webpack_require__(/*! ./signature */ \"./node_modules/ethereumjs-util/dist.browser/signature.js\"), exports);\r\n/**\r\n * Utilities for manipulating Buffers, byte arrays, etc.\r\n */\r\n__exportStar(__webpack_require__(/*! ./bytes */ \"./node_modules/ethereumjs-util/dist.browser/bytes.js\"), exports);\r\n/**\r\n * Function for definining properties on an object\r\n */\r\n__exportStar(__webpack_require__(/*! ./object */ \"./node_modules/ethereumjs-util/dist.browser/object.js\"), exports);\r\n/**\r\n * External exports (BN, rlp)\r\n */\r\n__exportStar(__webpack_require__(/*! ./externals */ \"./node_modules/ethereumjs-util/dist.browser/externals.js\"), exports);\r\n/**\r\n * Helpful TypeScript types\r\n */\r\n__exportStar(__webpack_require__(/*! ./types */ \"./node_modules/ethereumjs-util/dist.browser/types.js\"), exports);\r\n/**\r\n * Export ethjs-util methods\r\n */\r\nvar internal_1 = __webpack_require__(/*! ./internal */ \"./node_modules/ethereumjs-util/dist.browser/internal.js\");\r\nObject.defineProperty(exports, \"isHexPrefixed\", ({ enumerable: true, get: function () { return internal_1.isHexPrefixed; } }));\r\nObject.defineProperty(exports, \"stripHexPrefix\", ({ enumerable: true, get: function () { return internal_1.stripHexPrefix; } }));\r\nObject.defineProperty(exports, \"padToEven\", ({ enumerable: true, get: function () { return internal_1.padToEven; } }));\r\nObject.defineProperty(exports, \"getBinarySize\", ({ enumerable: true, get: function () { return internal_1.getBinarySize; } }));\r\nObject.defineProperty(exports, \"arrayContainsArray\", ({ enumerable: true, get: function () { return internal_1.arrayContainsArray; } }));\r\nObject.defineProperty(exports, \"toAscii\", ({ enumerable: true, get: function () { return internal_1.toAscii; } }));\r\nObject.defineProperty(exports, \"fromUtf8\", ({ enumerable: true, get: function () { return internal_1.fromUtf8; } }));\r\nObject.defineProperty(exports, \"fromAscii\", ({ enumerable: true, get: function () { return internal_1.fromAscii; } }));\r\nObject.defineProperty(exports, \"getKeys\", ({ enumerable: true, get: function () { return internal_1.getKeys; } }));\r\nObject.defineProperty(exports, \"isHexString\", ({ enumerable: true, get: function () { return internal_1.isHexString; } }));\r\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QuYnJvd3Nlci9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSxtQ0FBbUMsb0NBQW9DLGdCQUFnQjtBQUN2RixDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CLEdBQUcsZUFBZSxHQUFHLGlCQUFpQixHQUFHLGdCQUFnQixHQUFHLGVBQWUsR0FBRywwQkFBMEIsR0FBRyxxQkFBcUIsR0FBRyxpQkFBaUIsR0FBRyxzQkFBc0IsR0FBRyxxQkFBcUI7QUFDeE47QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLDZFQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyx5RUFBVztBQUNoQztBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMseUVBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLG1FQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyw2RUFBYTtBQUNsQztBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMscUVBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLHVFQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyw2RUFBYTtBQUNsQztBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMscUVBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsMkVBQVk7QUFDckMsaURBQWdELEVBQUUscUNBQXFDLG9DQUFvQyxFQUFDO0FBQzVILGtEQUFpRCxFQUFFLHFDQUFxQyxxQ0FBcUMsRUFBQztBQUM5SCw2Q0FBNEMsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDcEgsaURBQWdELEVBQUUscUNBQXFDLG9DQUFvQyxFQUFDO0FBQzVILHNEQUFxRCxFQUFFLHFDQUFxQyx5Q0FBeUMsRUFBQztBQUN0SSwyQ0FBMEMsRUFBRSxxQ0FBcUMsOEJBQThCLEVBQUM7QUFDaEgsNENBQTJDLEVBQUUscUNBQXFDLCtCQUErQixFQUFDO0FBQ2xILDZDQUE0QyxFQUFFLHFDQUFxQyxnQ0FBZ0MsRUFBQztBQUNwSCwyQ0FBMEMsRUFBRSxxQ0FBcUMsOEJBQThCLEVBQUM7QUFDaEgsK0NBQThDLEVBQUUscUNBQXFDLGtDQUFrQyxFQUFDO0FBQ3hIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC5icm93c2VyL2luZGV4LmpzP2U2OWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XHJcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59KSk7XHJcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuaXNIZXhTdHJpbmcgPSBleHBvcnRzLmdldEtleXMgPSBleHBvcnRzLmZyb21Bc2NpaSA9IGV4cG9ydHMuZnJvbVV0ZjggPSBleHBvcnRzLnRvQXNjaWkgPSBleHBvcnRzLmFycmF5Q29udGFpbnNBcnJheSA9IGV4cG9ydHMuZ2V0QmluYXJ5U2l6ZSA9IGV4cG9ydHMucGFkVG9FdmVuID0gZXhwb3J0cy5zdHJpcEhleFByZWZpeCA9IGV4cG9ydHMuaXNIZXhQcmVmaXhlZCA9IHZvaWQgMDtcclxuLyoqXHJcbiAqIENvbnN0YW50c1xyXG4gKi9cclxuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKSwgZXhwb3J0cyk7XHJcbi8qKlxyXG4gKiBBY2NvdW50IGNsYXNzIGFuZCBoZWxwZXIgZnVuY3Rpb25zXHJcbiAqL1xyXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYWNjb3VudFwiKSwgZXhwb3J0cyk7XHJcbi8qKlxyXG4gKiBBZGRyZXNzIHR5cGVcclxuICovXHJcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hZGRyZXNzXCIpLCBleHBvcnRzKTtcclxuLyoqXHJcbiAqIEhhc2ggZnVuY3Rpb25zXHJcbiAqL1xyXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaGFzaFwiKSwgZXhwb3J0cyk7XHJcbi8qKlxyXG4gKiBFQ0RTQSBzaWduYXR1cmVcclxuICovXHJcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zaWduYXR1cmVcIiksIGV4cG9ydHMpO1xyXG4vKipcclxuICogVXRpbGl0aWVzIGZvciBtYW5pcHVsYXRpbmcgQnVmZmVycywgYnl0ZSBhcnJheXMsIGV0Yy5cclxuICovXHJcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ieXRlc1wiKSwgZXhwb3J0cyk7XHJcbi8qKlxyXG4gKiBGdW5jdGlvbiBmb3IgZGVmaW5pbmluZyBwcm9wZXJ0aWVzIG9uIGFuIG9iamVjdFxyXG4gKi9cclxuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL29iamVjdFwiKSwgZXhwb3J0cyk7XHJcbi8qKlxyXG4gKiBFeHRlcm5hbCBleHBvcnRzIChCTiwgcmxwKVxyXG4gKi9cclxuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2V4dGVybmFsc1wiKSwgZXhwb3J0cyk7XHJcbi8qKlxyXG4gKiBIZWxwZnVsIFR5cGVTY3JpcHQgdHlwZXNcclxuICovXHJcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90eXBlc1wiKSwgZXhwb3J0cyk7XHJcbi8qKlxyXG4gKiBFeHBvcnQgZXRoanMtdXRpbCBtZXRob2RzXHJcbiAqL1xyXG52YXIgaW50ZXJuYWxfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFsXCIpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0hleFByZWZpeGVkXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlcm5hbF8xLmlzSGV4UHJlZml4ZWQ7IH0gfSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0cmlwSGV4UHJlZml4XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlcm5hbF8xLnN0cmlwSGV4UHJlZml4OyB9IH0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwYWRUb0V2ZW5cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVybmFsXzEucGFkVG9FdmVuOyB9IH0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRCaW5hcnlTaXplXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlcm5hbF8xLmdldEJpbmFyeVNpemU7IH0gfSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFycmF5Q29udGFpbnNBcnJheVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJuYWxfMS5hcnJheUNvbnRhaW5zQXJyYXk7IH0gfSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvQXNjaWlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVybmFsXzEudG9Bc2NpaTsgfSB9KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZnJvbVV0ZjhcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVybmFsXzEuZnJvbVV0Zjg7IH0gfSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImZyb21Bc2NpaVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJuYWxfMS5mcm9tQXNjaWk7IH0gfSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldEtleXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVybmFsXzEuZ2V0S2V5czsgfSB9KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNIZXhTdHJpbmdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVybmFsXzEuaXNIZXhTdHJpbmc7IH0gfSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ethereumjs-util/dist.browser/index.js\n");

/***/ }),

/***/ "./node_modules/ethereumjs-util/dist.browser/internal.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist.browser/internal.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\r\n/*\r\nThe MIT License\r\n\r\nCopyright (c) 2016 Nick Dodson. nickdodson.com\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.isHexString = exports.getKeys = exports.fromAscii = exports.fromUtf8 = exports.toAscii = exports.arrayContainsArray = exports.getBinarySize = exports.padToEven = exports.stripHexPrefix = exports.isHexPrefixed = void 0;\r\n/**\r\n * Returns a `Boolean` on whether or not the a `String` starts with '0x'\r\n * @param str the string input value\r\n * @return a boolean if it is or is not hex prefixed\r\n * @throws if the str input is not a string\r\n */\r\nfunction isHexPrefixed(str) {\r\n    if (typeof str !== 'string') {\r\n        throw new Error(\"[isHexPrefixed] input must be type 'string', received type \".concat(typeof str));\r\n    }\r\n    return str[0] === '0' && str[1] === 'x';\r\n}\r\nexports.isHexPrefixed = isHexPrefixed;\r\n/**\r\n * Removes '0x' from a given `String` if present\r\n * @param str the string value\r\n * @returns the string without 0x prefix\r\n */\r\nvar stripHexPrefix = function (str) {\r\n    if (typeof str !== 'string')\r\n        throw new Error(\"[stripHexPrefix] input must be type 'string', received \".concat(typeof str));\r\n    return isHexPrefixed(str) ? str.slice(2) : str;\r\n};\r\nexports.stripHexPrefix = stripHexPrefix;\r\n/**\r\n * Pads a `String` to have an even length\r\n * @param value\r\n * @return output\r\n */\r\nfunction padToEven(value) {\r\n    var a = value;\r\n    if (typeof a !== 'string') {\r\n        throw new Error(\"[padToEven] value must be type 'string', received \".concat(typeof a));\r\n    }\r\n    if (a.length % 2)\r\n        a = \"0\".concat(a);\r\n    return a;\r\n}\r\nexports.padToEven = padToEven;\r\n/**\r\n * Get the binary size of a string\r\n * @param str\r\n * @returns the number of bytes contained within the string\r\n */\r\nfunction getBinarySize(str) {\r\n    if (typeof str !== 'string') {\r\n        throw new Error(\"[getBinarySize] method requires input type 'string', recieved \".concat(typeof str));\r\n    }\r\n    return Buffer.byteLength(str, 'utf8');\r\n}\r\nexports.getBinarySize = getBinarySize;\r\n/**\r\n * Returns TRUE if the first specified array contains all elements\r\n * from the second one. FALSE otherwise.\r\n *\r\n * @param superset\r\n * @param subset\r\n *\r\n */\r\nfunction arrayContainsArray(superset, subset, some) {\r\n    if (Array.isArray(superset) !== true) {\r\n        throw new Error(\"[arrayContainsArray] method requires input 'superset' to be an array, got type '\".concat(typeof superset, \"'\"));\r\n    }\r\n    if (Array.isArray(subset) !== true) {\r\n        throw new Error(\"[arrayContainsArray] method requires input 'subset' to be an array, got type '\".concat(typeof subset, \"'\"));\r\n    }\r\n    return subset[some ? 'some' : 'every'](function (value) { return superset.indexOf(value) >= 0; });\r\n}\r\nexports.arrayContainsArray = arrayContainsArray;\r\n/**\r\n * Should be called to get ascii from its hex representation\r\n *\r\n * @param string in hex\r\n * @returns ascii string representation of hex value\r\n */\r\nfunction toAscii(hex) {\r\n    var str = '';\r\n    var i = 0;\r\n    var l = hex.length;\r\n    if (hex.substring(0, 2) === '0x')\r\n        i = 2;\r\n    for (; i < l; i += 2) {\r\n        var code = parseInt(hex.substr(i, 2), 16);\r\n        str += String.fromCharCode(code);\r\n    }\r\n    return str;\r\n}\r\nexports.toAscii = toAscii;\r\n/**\r\n * Should be called to get hex representation (prefixed by 0x) of utf8 string\r\n *\r\n * @param string\r\n * @param optional padding\r\n * @returns hex representation of input string\r\n */\r\nfunction fromUtf8(stringValue) {\r\n    var str = Buffer.from(stringValue, 'utf8');\r\n    return \"0x\".concat(padToEven(str.toString('hex')).replace(/^0+|0+$/g, ''));\r\n}\r\nexports.fromUtf8 = fromUtf8;\r\n/**\r\n * Should be called to get hex representation (prefixed by 0x) of ascii string\r\n *\r\n * @param  string\r\n * @param  optional padding\r\n * @returns  hex representation of input string\r\n */\r\nfunction fromAscii(stringValue) {\r\n    var hex = '';\r\n    for (var i = 0; i < stringValue.length; i++) {\r\n        var code = stringValue.charCodeAt(i);\r\n        var n = code.toString(16);\r\n        hex += n.length < 2 ? \"0\".concat(n) : n;\r\n    }\r\n    return \"0x\".concat(hex);\r\n}\r\nexports.fromAscii = fromAscii;\r\n/**\r\n * Returns the keys from an array of objects.\r\n * @example\r\n * ```js\r\n * getKeys([{a: '1', b: '2'}, {a: '3', b: '4'}], 'a') => ['1', '3']\r\n *````\r\n * @param  params\r\n * @param  key\r\n * @param  allowEmpty\r\n * @returns output just a simple array of output keys\r\n */\r\nfunction getKeys(params, key, allowEmpty) {\r\n    if (!Array.isArray(params)) {\r\n        throw new Error(\"[getKeys] method expects input 'params' to be an array, got \".concat(typeof params));\r\n    }\r\n    if (typeof key !== 'string') {\r\n        throw new Error(\"[getKeys] method expects input 'key' to be type 'string', got \".concat(typeof params));\r\n    }\r\n    var result = [];\r\n    for (var i = 0; i < params.length; i++) {\r\n        var value = params[i][key];\r\n        if (allowEmpty && !value) {\r\n            value = '';\r\n        }\r\n        else if (typeof value !== 'string') {\r\n            throw new Error(\"invalid abi - expected type 'string', received \".concat(typeof value));\r\n        }\r\n        result.push(value);\r\n    }\r\n    return result;\r\n}\r\nexports.getKeys = getKeys;\r\n/**\r\n * Is the string a hex string.\r\n *\r\n * @param  value\r\n * @param  length\r\n * @returns  output the string is a hex string\r\n */\r\nfunction isHexString(value, length) {\r\n    if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/))\r\n        return false;\r\n    if (length && value.length !== 2 + 2 * length)\r\n        return false;\r\n    return true;\r\n}\r\nexports.isHexString = isHexString;\r\n//# sourceMappingURL=internal.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QuYnJvd3Nlci9pbnRlcm5hbC5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQixHQUFHLGVBQWUsR0FBRyxpQkFBaUIsR0FBRyxnQkFBZ0IsR0FBRyxlQUFlLEdBQUcsMEJBQTBCLEdBQUcscUJBQXFCLEdBQUcsaUJBQWlCLEdBQUcsc0JBQXNCLEdBQUcscUJBQXFCO0FBQ3hOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsc0NBQXNDO0FBQ3BHO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZSxHQUFHLGVBQWU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC5icm93c2VyL2ludGVybmFsLmpzP2JmNDUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcblRoZSBNSVQgTGljZW5zZVxyXG5cclxuQ29weXJpZ2h0IChjKSAyMDE2IE5pY2sgRG9kc29uLiBuaWNrZG9kc29uLmNvbVxyXG5cclxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxyXG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXHJcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcclxudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxyXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcclxuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuXHJcblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXHJcbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxyXG5USEUgU09GVFdBUkVcclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5pc0hleFN0cmluZyA9IGV4cG9ydHMuZ2V0S2V5cyA9IGV4cG9ydHMuZnJvbUFzY2lpID0gZXhwb3J0cy5mcm9tVXRmOCA9IGV4cG9ydHMudG9Bc2NpaSA9IGV4cG9ydHMuYXJyYXlDb250YWluc0FycmF5ID0gZXhwb3J0cy5nZXRCaW5hcnlTaXplID0gZXhwb3J0cy5wYWRUb0V2ZW4gPSBleHBvcnRzLnN0cmlwSGV4UHJlZml4ID0gZXhwb3J0cy5pc0hleFByZWZpeGVkID0gdm9pZCAwO1xyXG4vKipcclxuICogUmV0dXJucyBhIGBCb29sZWFuYCBvbiB3aGV0aGVyIG9yIG5vdCB0aGUgYSBgU3RyaW5nYCBzdGFydHMgd2l0aCAnMHgnXHJcbiAqIEBwYXJhbSBzdHIgdGhlIHN0cmluZyBpbnB1dCB2YWx1ZVxyXG4gKiBAcmV0dXJuIGEgYm9vbGVhbiBpZiBpdCBpcyBvciBpcyBub3QgaGV4IHByZWZpeGVkXHJcbiAqIEB0aHJvd3MgaWYgdGhlIHN0ciBpbnB1dCBpcyBub3QgYSBzdHJpbmdcclxuICovXHJcbmZ1bmN0aW9uIGlzSGV4UHJlZml4ZWQoc3RyKSB7XHJcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbaXNIZXhQcmVmaXhlZF0gaW5wdXQgbXVzdCBiZSB0eXBlICdzdHJpbmcnLCByZWNlaXZlZCB0eXBlIFwiLmNvbmNhdCh0eXBlb2Ygc3RyKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3RyWzBdID09PSAnMCcgJiYgc3RyWzFdID09PSAneCc7XHJcbn1cclxuZXhwb3J0cy5pc0hleFByZWZpeGVkID0gaXNIZXhQcmVmaXhlZDtcclxuLyoqXHJcbiAqIFJlbW92ZXMgJzB4JyBmcm9tIGEgZ2l2ZW4gYFN0cmluZ2AgaWYgcHJlc2VudFxyXG4gKiBAcGFyYW0gc3RyIHRoZSBzdHJpbmcgdmFsdWVcclxuICogQHJldHVybnMgdGhlIHN0cmluZyB3aXRob3V0IDB4IHByZWZpeFxyXG4gKi9cclxudmFyIHN0cmlwSGV4UHJlZml4ID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIltzdHJpcEhleFByZWZpeF0gaW5wdXQgbXVzdCBiZSB0eXBlICdzdHJpbmcnLCByZWNlaXZlZCBcIi5jb25jYXQodHlwZW9mIHN0cikpO1xyXG4gICAgcmV0dXJuIGlzSGV4UHJlZml4ZWQoc3RyKSA/IHN0ci5zbGljZSgyKSA6IHN0cjtcclxufTtcclxuZXhwb3J0cy5zdHJpcEhleFByZWZpeCA9IHN0cmlwSGV4UHJlZml4O1xyXG4vKipcclxuICogUGFkcyBhIGBTdHJpbmdgIHRvIGhhdmUgYW4gZXZlbiBsZW5ndGhcclxuICogQHBhcmFtIHZhbHVlXHJcbiAqIEByZXR1cm4gb3V0cHV0XHJcbiAqL1xyXG5mdW5jdGlvbiBwYWRUb0V2ZW4odmFsdWUpIHtcclxuICAgIHZhciBhID0gdmFsdWU7XHJcbiAgICBpZiAodHlwZW9mIGEgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW3BhZFRvRXZlbl0gdmFsdWUgbXVzdCBiZSB0eXBlICdzdHJpbmcnLCByZWNlaXZlZCBcIi5jb25jYXQodHlwZW9mIGEpKTtcclxuICAgIH1cclxuICAgIGlmIChhLmxlbmd0aCAlIDIpXHJcbiAgICAgICAgYSA9IFwiMFwiLmNvbmNhdChhKTtcclxuICAgIHJldHVybiBhO1xyXG59XHJcbmV4cG9ydHMucGFkVG9FdmVuID0gcGFkVG9FdmVuO1xyXG4vKipcclxuICogR2V0IHRoZSBiaW5hcnkgc2l6ZSBvZiBhIHN0cmluZ1xyXG4gKiBAcGFyYW0gc3RyXHJcbiAqIEByZXR1cm5zIHRoZSBudW1iZXIgb2YgYnl0ZXMgY29udGFpbmVkIHdpdGhpbiB0aGUgc3RyaW5nXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRCaW5hcnlTaXplKHN0cikge1xyXG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW2dldEJpbmFyeVNpemVdIG1ldGhvZCByZXF1aXJlcyBpbnB1dCB0eXBlICdzdHJpbmcnLCByZWNpZXZlZCBcIi5jb25jYXQodHlwZW9mIHN0cikpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEJ1ZmZlci5ieXRlTGVuZ3RoKHN0ciwgJ3V0ZjgnKTtcclxufVxyXG5leHBvcnRzLmdldEJpbmFyeVNpemUgPSBnZXRCaW5hcnlTaXplO1xyXG4vKipcclxuICogUmV0dXJucyBUUlVFIGlmIHRoZSBmaXJzdCBzcGVjaWZpZWQgYXJyYXkgY29udGFpbnMgYWxsIGVsZW1lbnRzXHJcbiAqIGZyb20gdGhlIHNlY29uZCBvbmUuIEZBTFNFIG90aGVyd2lzZS5cclxuICpcclxuICogQHBhcmFtIHN1cGVyc2V0XHJcbiAqIEBwYXJhbSBzdWJzZXRcclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGFycmF5Q29udGFpbnNBcnJheShzdXBlcnNldCwgc3Vic2V0LCBzb21lKSB7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzdXBlcnNldCkgIT09IHRydWUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbYXJyYXlDb250YWluc0FycmF5XSBtZXRob2QgcmVxdWlyZXMgaW5wdXQgJ3N1cGVyc2V0JyB0byBiZSBhbiBhcnJheSwgZ290IHR5cGUgJ1wiLmNvbmNhdCh0eXBlb2Ygc3VwZXJzZXQsIFwiJ1wiKSk7XHJcbiAgICB9XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzdWJzZXQpICE9PSB0cnVlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW2FycmF5Q29udGFpbnNBcnJheV0gbWV0aG9kIHJlcXVpcmVzIGlucHV0ICdzdWJzZXQnIHRvIGJlIGFuIGFycmF5LCBnb3QgdHlwZSAnXCIuY29uY2F0KHR5cGVvZiBzdWJzZXQsIFwiJ1wiKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3Vic2V0W3NvbWUgPyAnc29tZScgOiAnZXZlcnknXShmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHN1cGVyc2V0LmluZGV4T2YodmFsdWUpID49IDA7IH0pO1xyXG59XHJcbmV4cG9ydHMuYXJyYXlDb250YWluc0FycmF5ID0gYXJyYXlDb250YWluc0FycmF5O1xyXG4vKipcclxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgYXNjaWkgZnJvbSBpdHMgaGV4IHJlcHJlc2VudGF0aW9uXHJcbiAqXHJcbiAqIEBwYXJhbSBzdHJpbmcgaW4gaGV4XHJcbiAqIEByZXR1cm5zIGFzY2lpIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBoZXggdmFsdWVcclxuICovXHJcbmZ1bmN0aW9uIHRvQXNjaWkoaGV4KSB7XHJcbiAgICB2YXIgc3RyID0gJyc7XHJcbiAgICB2YXIgaSA9IDA7XHJcbiAgICB2YXIgbCA9IGhleC5sZW5ndGg7XHJcbiAgICBpZiAoaGV4LnN1YnN0cmluZygwLCAyKSA9PT0gJzB4JylcclxuICAgICAgICBpID0gMjtcclxuICAgIGZvciAoOyBpIDwgbDsgaSArPSAyKSB7XHJcbiAgICAgICAgdmFyIGNvZGUgPSBwYXJzZUludChoZXguc3Vic3RyKGksIDIpLCAxNik7XHJcbiAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3RyO1xyXG59XHJcbmV4cG9ydHMudG9Bc2NpaSA9IHRvQXNjaWk7XHJcbi8qKlxyXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBoZXggcmVwcmVzZW50YXRpb24gKHByZWZpeGVkIGJ5IDB4KSBvZiB1dGY4IHN0cmluZ1xyXG4gKlxyXG4gKiBAcGFyYW0gc3RyaW5nXHJcbiAqIEBwYXJhbSBvcHRpb25hbCBwYWRkaW5nXHJcbiAqIEByZXR1cm5zIGhleCByZXByZXNlbnRhdGlvbiBvZiBpbnB1dCBzdHJpbmdcclxuICovXHJcbmZ1bmN0aW9uIGZyb21VdGY4KHN0cmluZ1ZhbHVlKSB7XHJcbiAgICB2YXIgc3RyID0gQnVmZmVyLmZyb20oc3RyaW5nVmFsdWUsICd1dGY4Jyk7XHJcbiAgICByZXR1cm4gXCIweFwiLmNvbmNhdChwYWRUb0V2ZW4oc3RyLnRvU3RyaW5nKCdoZXgnKSkucmVwbGFjZSgvXjArfDArJC9nLCAnJykpO1xyXG59XHJcbmV4cG9ydHMuZnJvbVV0ZjggPSBmcm9tVXRmODtcclxuLyoqXHJcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGhleCByZXByZXNlbnRhdGlvbiAocHJlZml4ZWQgYnkgMHgpIG9mIGFzY2lpIHN0cmluZ1xyXG4gKlxyXG4gKiBAcGFyYW0gIHN0cmluZ1xyXG4gKiBAcGFyYW0gIG9wdGlvbmFsIHBhZGRpbmdcclxuICogQHJldHVybnMgIGhleCByZXByZXNlbnRhdGlvbiBvZiBpbnB1dCBzdHJpbmdcclxuICovXHJcbmZ1bmN0aW9uIGZyb21Bc2NpaShzdHJpbmdWYWx1ZSkge1xyXG4gICAgdmFyIGhleCA9ICcnO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmdWYWx1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBjb2RlID0gc3RyaW5nVmFsdWUuY2hhckNvZGVBdChpKTtcclxuICAgICAgICB2YXIgbiA9IGNvZGUudG9TdHJpbmcoMTYpO1xyXG4gICAgICAgIGhleCArPSBuLmxlbmd0aCA8IDIgPyBcIjBcIi5jb25jYXQobikgOiBuO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFwiMHhcIi5jb25jYXQoaGV4KTtcclxufVxyXG5leHBvcnRzLmZyb21Bc2NpaSA9IGZyb21Bc2NpaTtcclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGtleXMgZnJvbSBhbiBhcnJheSBvZiBvYmplY3RzLlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqc1xyXG4gKiBnZXRLZXlzKFt7YTogJzEnLCBiOiAnMid9LCB7YTogJzMnLCBiOiAnNCd9XSwgJ2EnKSA9PiBbJzEnLCAnMyddXHJcbiAqYGBgYFxyXG4gKiBAcGFyYW0gIHBhcmFtc1xyXG4gKiBAcGFyYW0gIGtleVxyXG4gKiBAcGFyYW0gIGFsbG93RW1wdHlcclxuICogQHJldHVybnMgb3V0cHV0IGp1c3QgYSBzaW1wbGUgYXJyYXkgb2Ygb3V0cHV0IGtleXNcclxuICovXHJcbmZ1bmN0aW9uIGdldEtleXMocGFyYW1zLCBrZXksIGFsbG93RW1wdHkpIHtcclxuICAgIGlmICghQXJyYXkuaXNBcnJheShwYXJhbXMpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW2dldEtleXNdIG1ldGhvZCBleHBlY3RzIGlucHV0ICdwYXJhbXMnIHRvIGJlIGFuIGFycmF5LCBnb3QgXCIuY29uY2F0KHR5cGVvZiBwYXJhbXMpKTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIltnZXRLZXlzXSBtZXRob2QgZXhwZWN0cyBpbnB1dCAna2V5JyB0byBiZSB0eXBlICdzdHJpbmcnLCBnb3QgXCIuY29uY2F0KHR5cGVvZiBwYXJhbXMpKTtcclxuICAgIH1cclxuICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gcGFyYW1zW2ldW2tleV07XHJcbiAgICAgICAgaWYgKGFsbG93RW1wdHkgJiYgIXZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBhYmkgLSBleHBlY3RlZCB0eXBlICdzdHJpbmcnLCByZWNlaXZlZCBcIi5jb25jYXQodHlwZW9mIHZhbHVlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZXhwb3J0cy5nZXRLZXlzID0gZ2V0S2V5cztcclxuLyoqXHJcbiAqIElzIHRoZSBzdHJpbmcgYSBoZXggc3RyaW5nLlxyXG4gKlxyXG4gKiBAcGFyYW0gIHZhbHVlXHJcbiAqIEBwYXJhbSAgbGVuZ3RoXHJcbiAqIEByZXR1cm5zICBvdXRwdXQgdGhlIHN0cmluZyBpcyBhIGhleCBzdHJpbmdcclxuICovXHJcbmZ1bmN0aW9uIGlzSGV4U3RyaW5nKHZhbHVlLCBsZW5ndGgpIHtcclxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnIHx8ICF2YWx1ZS5tYXRjaCgvXjB4WzAtOUEtRmEtZl0qJC8pKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIGlmIChsZW5ndGggJiYgdmFsdWUubGVuZ3RoICE9PSAyICsgMiAqIGxlbmd0aClcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5leHBvcnRzLmlzSGV4U3RyaW5nID0gaXNIZXhTdHJpbmc7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVybmFsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ethereumjs-util/dist.browser/internal.js\n");

/***/ }),

/***/ "./node_modules/ethereumjs-util/dist.browser/object.js":
/*!*************************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist.browser/object.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.defineProperties = void 0;\r\nvar assert_1 = __importDefault(__webpack_require__(/*! assert */ \"./node_modules/assert/build/assert.js\"));\r\nvar internal_1 = __webpack_require__(/*! ./internal */ \"./node_modules/ethereumjs-util/dist.browser/internal.js\");\r\nvar externals_1 = __webpack_require__(/*! ./externals */ \"./node_modules/ethereumjs-util/dist.browser/externals.js\");\r\nvar bytes_1 = __webpack_require__(/*! ./bytes */ \"./node_modules/ethereumjs-util/dist.browser/bytes.js\");\r\n/**\r\n * Defines properties on a `Object`. It make the assumption that underlying data is binary.\r\n * @param self the `Object` to define properties on\r\n * @param fields an array fields to define. Fields can contain:\r\n * * `name` - the name of the properties\r\n * * `length` - the number of bytes the field can have\r\n * * `allowLess` - if the field can be less than the length\r\n * * `allowEmpty`\r\n * @param data data to be validated against the definitions\r\n * @deprecated\r\n */\r\nvar defineProperties = function (self, fields, data) {\r\n    self.raw = [];\r\n    self._fields = [];\r\n    // attach the `toJSON`\r\n    self.toJSON = function (label) {\r\n        if (label === void 0) { label = false; }\r\n        if (label) {\r\n            var obj_1 = {};\r\n            self._fields.forEach(function (field) {\r\n                obj_1[field] = \"0x\".concat(self[field].toString('hex'));\r\n            });\r\n            return obj_1;\r\n        }\r\n        return (0, bytes_1.baToJSON)(self.raw);\r\n    };\r\n    self.serialize = function serialize() {\r\n        return externals_1.rlp.encode(self.raw);\r\n    };\r\n    fields.forEach(function (field, i) {\r\n        self._fields.push(field.name);\r\n        function getter() {\r\n            return self.raw[i];\r\n        }\r\n        function setter(v) {\r\n            v = (0, bytes_1.toBuffer)(v);\r\n            if (v.toString('hex') === '00' && !field.allowZero) {\r\n                v = Buffer.allocUnsafe(0);\r\n            }\r\n            if (field.allowLess && field.length) {\r\n                v = (0, bytes_1.unpadBuffer)(v);\r\n                (0, assert_1.default)(field.length >= v.length, \"The field \".concat(field.name, \" must not have more \").concat(field.length, \" bytes\"));\r\n            }\r\n            else if (!(field.allowZero && v.length === 0) && field.length) {\r\n                (0, assert_1.default)(field.length === v.length, \"The field \".concat(field.name, \" must have byte length of \").concat(field.length));\r\n            }\r\n            self.raw[i] = v;\r\n        }\r\n        Object.defineProperty(self, field.name, {\r\n            enumerable: true,\r\n            configurable: true,\r\n            get: getter,\r\n            set: setter,\r\n        });\r\n        if (field.default) {\r\n            self[field.name] = field.default;\r\n        }\r\n        // attach alias\r\n        if (field.alias) {\r\n            Object.defineProperty(self, field.alias, {\r\n                enumerable: false,\r\n                configurable: true,\r\n                set: setter,\r\n                get: getter,\r\n            });\r\n        }\r\n    });\r\n    // if the constuctor is passed data\r\n    if (data) {\r\n        if (typeof data === 'string') {\r\n            data = Buffer.from((0, internal_1.stripHexPrefix)(data), 'hex');\r\n        }\r\n        if (Buffer.isBuffer(data)) {\r\n            data = externals_1.rlp.decode(data);\r\n        }\r\n        if (Array.isArray(data)) {\r\n            if (data.length > self._fields.length) {\r\n                throw new Error('wrong number of fields in data');\r\n            }\r\n            // make sure all the items are buffers\r\n            data.forEach(function (d, i) {\r\n                self[self._fields[i]] = (0, bytes_1.toBuffer)(d);\r\n            });\r\n        }\r\n        else if (typeof data === 'object') {\r\n            var keys_1 = Object.keys(data);\r\n            fields.forEach(function (field) {\r\n                if (keys_1.indexOf(field.name) !== -1)\r\n                    self[field.name] = data[field.name];\r\n                if (keys_1.indexOf(field.alias) !== -1)\r\n                    self[field.alias] = data[field.alias];\r\n            });\r\n        }\r\n        else {\r\n            throw new Error('invalid data');\r\n        }\r\n    }\r\n};\r\nexports.defineProperties = defineProperties;\r\n//# sourceMappingURL=object.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QuYnJvd3Nlci9vYmplY3QuanMuanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCO0FBQ3hCLCtCQUErQixtQkFBTyxDQUFDLHFEQUFRO0FBQy9DLGlCQUFpQixtQkFBTyxDQUFDLDJFQUFZO0FBQ3JDLGtCQUFrQixtQkFBTyxDQUFDLDZFQUFhO0FBQ3ZDLGNBQWMsbUJBQU8sQ0FBQyxxRUFBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE1BQU07QUFDekI7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC5icm93c2VyL29iamVjdC5qcz9iMjdmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuZGVmaW5lUHJvcGVydGllcyA9IHZvaWQgMDtcclxudmFyIGFzc2VydF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJhc3NlcnRcIikpO1xyXG52YXIgaW50ZXJuYWxfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFsXCIpO1xyXG52YXIgZXh0ZXJuYWxzXzEgPSByZXF1aXJlKFwiLi9leHRlcm5hbHNcIik7XHJcbnZhciBieXRlc18xID0gcmVxdWlyZShcIi4vYnl0ZXNcIik7XHJcbi8qKlxyXG4gKiBEZWZpbmVzIHByb3BlcnRpZXMgb24gYSBgT2JqZWN0YC4gSXQgbWFrZSB0aGUgYXNzdW1wdGlvbiB0aGF0IHVuZGVybHlpbmcgZGF0YSBpcyBiaW5hcnkuXHJcbiAqIEBwYXJhbSBzZWxmIHRoZSBgT2JqZWN0YCB0byBkZWZpbmUgcHJvcGVydGllcyBvblxyXG4gKiBAcGFyYW0gZmllbGRzIGFuIGFycmF5IGZpZWxkcyB0byBkZWZpbmUuIEZpZWxkcyBjYW4gY29udGFpbjpcclxuICogKiBgbmFtZWAgLSB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydGllc1xyXG4gKiAqIGBsZW5ndGhgIC0gdGhlIG51bWJlciBvZiBieXRlcyB0aGUgZmllbGQgY2FuIGhhdmVcclxuICogKiBgYWxsb3dMZXNzYCAtIGlmIHRoZSBmaWVsZCBjYW4gYmUgbGVzcyB0aGFuIHRoZSBsZW5ndGhcclxuICogKiBgYWxsb3dFbXB0eWBcclxuICogQHBhcmFtIGRhdGEgZGF0YSB0byBiZSB2YWxpZGF0ZWQgYWdhaW5zdCB0aGUgZGVmaW5pdGlvbnNcclxuICogQGRlcHJlY2F0ZWRcclxuICovXHJcbnZhciBkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKHNlbGYsIGZpZWxkcywgZGF0YSkge1xyXG4gICAgc2VsZi5yYXcgPSBbXTtcclxuICAgIHNlbGYuX2ZpZWxkcyA9IFtdO1xyXG4gICAgLy8gYXR0YWNoIHRoZSBgdG9KU09OYFxyXG4gICAgc2VsZi50b0pTT04gPSBmdW5jdGlvbiAobGFiZWwpIHtcclxuICAgICAgICBpZiAobGFiZWwgPT09IHZvaWQgMCkgeyBsYWJlbCA9IGZhbHNlOyB9XHJcbiAgICAgICAgaWYgKGxhYmVsKSB7XHJcbiAgICAgICAgICAgIHZhciBvYmpfMSA9IHt9O1xyXG4gICAgICAgICAgICBzZWxmLl9maWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHtcclxuICAgICAgICAgICAgICAgIG9ial8xW2ZpZWxkXSA9IFwiMHhcIi5jb25jYXQoc2VsZltmaWVsZF0udG9TdHJpbmcoJ2hleCcpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmpfMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICgwLCBieXRlc18xLmJhVG9KU09OKShzZWxmLnJhdyk7XHJcbiAgICB9O1xyXG4gICAgc2VsZi5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIGV4dGVybmFsc18xLnJscC5lbmNvZGUoc2VsZi5yYXcpO1xyXG4gICAgfTtcclxuICAgIGZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCwgaSkge1xyXG4gICAgICAgIHNlbGYuX2ZpZWxkcy5wdXNoKGZpZWxkLm5hbWUpO1xyXG4gICAgICAgIGZ1bmN0aW9uIGdldHRlcigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNlbGYucmF3W2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBzZXR0ZXIodikge1xyXG4gICAgICAgICAgICB2ID0gKDAsIGJ5dGVzXzEudG9CdWZmZXIpKHYpO1xyXG4gICAgICAgICAgICBpZiAodi50b1N0cmluZygnaGV4JykgPT09ICcwMCcgJiYgIWZpZWxkLmFsbG93WmVybykge1xyXG4gICAgICAgICAgICAgICAgdiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZmllbGQuYWxsb3dMZXNzICYmIGZpZWxkLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdiA9ICgwLCBieXRlc18xLnVucGFkQnVmZmVyKSh2KTtcclxuICAgICAgICAgICAgICAgICgwLCBhc3NlcnRfMS5kZWZhdWx0KShmaWVsZC5sZW5ndGggPj0gdi5sZW5ndGgsIFwiVGhlIGZpZWxkIFwiLmNvbmNhdChmaWVsZC5uYW1lLCBcIiBtdXN0IG5vdCBoYXZlIG1vcmUgXCIpLmNvbmNhdChmaWVsZC5sZW5ndGgsIFwiIGJ5dGVzXCIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghKGZpZWxkLmFsbG93WmVybyAmJiB2Lmxlbmd0aCA9PT0gMCkgJiYgZmllbGQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAoMCwgYXNzZXJ0XzEuZGVmYXVsdCkoZmllbGQubGVuZ3RoID09PSB2Lmxlbmd0aCwgXCJUaGUgZmllbGQgXCIuY29uY2F0KGZpZWxkLm5hbWUsIFwiIG11c3QgaGF2ZSBieXRlIGxlbmd0aCBvZiBcIikuY29uY2F0KGZpZWxkLmxlbmd0aCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNlbGYucmF3W2ldID0gdjtcclxuICAgICAgICB9XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsIGZpZWxkLm5hbWUsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBnZXQ6IGdldHRlcixcclxuICAgICAgICAgICAgc2V0OiBzZXR0ZXIsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGZpZWxkLmRlZmF1bHQpIHtcclxuICAgICAgICAgICAgc2VsZltmaWVsZC5uYW1lXSA9IGZpZWxkLmRlZmF1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGF0dGFjaCBhbGlhc1xyXG4gICAgICAgIGlmIChmaWVsZC5hbGlhcykge1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZiwgZmllbGQuYWxpYXMsIHtcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgc2V0OiBzZXR0ZXIsXHJcbiAgICAgICAgICAgICAgICBnZXQ6IGdldHRlcixcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICAvLyBpZiB0aGUgY29uc3R1Y3RvciBpcyBwYXNzZWQgZGF0YVxyXG4gICAgaWYgKGRhdGEpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbSgoMCwgaW50ZXJuYWxfMS5zdHJpcEhleFByZWZpeCkoZGF0YSksICdoZXgnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xyXG4gICAgICAgICAgICBkYXRhID0gZXh0ZXJuYWxzXzEucmxwLmRlY29kZShkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcclxuICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoID4gc2VsZi5fZmllbGRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3cm9uZyBudW1iZXIgb2YgZmllbGRzIGluIGRhdGEnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgYWxsIHRoZSBpdGVtcyBhcmUgYnVmZmVyc1xyXG4gICAgICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgICAgIHNlbGZbc2VsZi5fZmllbGRzW2ldXSA9ICgwLCBieXRlc18xLnRvQnVmZmVyKShkKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICB2YXIga2V5c18xID0gT2JqZWN0LmtleXMoZGF0YSk7XHJcbiAgICAgICAgICAgIGZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGtleXNfMS5pbmRleE9mKGZpZWxkLm5hbWUpICE9PSAtMSlcclxuICAgICAgICAgICAgICAgICAgICBzZWxmW2ZpZWxkLm5hbWVdID0gZGF0YVtmaWVsZC5uYW1lXTtcclxuICAgICAgICAgICAgICAgIGlmIChrZXlzXzEuaW5kZXhPZihmaWVsZC5hbGlhcykgIT09IC0xKVxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGZbZmllbGQuYWxpYXNdID0gZGF0YVtmaWVsZC5hbGlhc107XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGRhdGEnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbmV4cG9ydHMuZGVmaW5lUHJvcGVydGllcyA9IGRlZmluZVByb3BlcnRpZXM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9iamVjdC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ethereumjs-util/dist.browser/object.js\n");

/***/ }),

/***/ "./node_modules/ethereumjs-util/dist.browser/signature.js":
/*!****************************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist.browser/signature.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.hashPersonalMessage = exports.isValidSignature = exports.fromRpcSig = exports.toCompactSig = exports.toRpcSig = exports.ecrecover = exports.ecsign = void 0;\r\nvar secp256k1_1 = __webpack_require__(/*! ethereum-cryptography/secp256k1 */ \"./node_modules/ethereum-cryptography/secp256k1.js\");\r\nvar externals_1 = __webpack_require__(/*! ./externals */ \"./node_modules/ethereumjs-util/dist.browser/externals.js\");\r\nvar bytes_1 = __webpack_require__(/*! ./bytes */ \"./node_modules/ethereumjs-util/dist.browser/bytes.js\");\r\nvar hash_1 = __webpack_require__(/*! ./hash */ \"./node_modules/ethereumjs-util/dist.browser/hash.js\");\r\nvar helpers_1 = __webpack_require__(/*! ./helpers */ \"./node_modules/ethereumjs-util/dist.browser/helpers.js\");\r\nvar types_1 = __webpack_require__(/*! ./types */ \"./node_modules/ethereumjs-util/dist.browser/types.js\");\r\nfunction ecsign(msgHash, privateKey, chainId) {\r\n    var _a = (0, secp256k1_1.ecdsaSign)(msgHash, privateKey), signature = _a.signature, recovery = _a.recid;\r\n    var r = Buffer.from(signature.slice(0, 32));\r\n    var s = Buffer.from(signature.slice(32, 64));\r\n    if (!chainId || typeof chainId === 'number') {\r\n        // return legacy type ECDSASignature (deprecated in favor of ECDSASignatureBuffer to handle large chainIds)\r\n        if (chainId && !Number.isSafeInteger(chainId)) {\r\n            throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)');\r\n        }\r\n        var v_1 = chainId ? recovery + (chainId * 2 + 35) : recovery + 27;\r\n        return { r: r, s: s, v: v_1 };\r\n    }\r\n    var chainIdBN = (0, types_1.toType)(chainId, types_1.TypeOutput.BN);\r\n    var v = chainIdBN.muln(2).addn(35).addn(recovery).toArrayLike(Buffer);\r\n    return { r: r, s: s, v: v };\r\n}\r\nexports.ecsign = ecsign;\r\nfunction calculateSigRecovery(v, chainId) {\r\n    var vBN = (0, types_1.toType)(v, types_1.TypeOutput.BN);\r\n    if (!chainId) {\r\n        return vBN.subn(27);\r\n    }\r\n    var chainIdBN = (0, types_1.toType)(chainId, types_1.TypeOutput.BN);\r\n    return vBN.sub(chainIdBN.muln(2).addn(35));\r\n}\r\nfunction isValidSigRecovery(recovery) {\r\n    var rec = new externals_1.BN(recovery);\r\n    return rec.eqn(0) || rec.eqn(1);\r\n}\r\n/**\r\n * ECDSA public key recovery from signature.\r\n * @returns Recovered public key\r\n */\r\nvar ecrecover = function (msgHash, v, r, s, chainId) {\r\n    var signature = Buffer.concat([(0, bytes_1.setLengthLeft)(r, 32), (0, bytes_1.setLengthLeft)(s, 32)], 64);\r\n    var recovery = calculateSigRecovery(v, chainId);\r\n    if (!isValidSigRecovery(recovery)) {\r\n        throw new Error('Invalid signature v value');\r\n    }\r\n    var senderPubKey = (0, secp256k1_1.ecdsaRecover)(signature, recovery.toNumber(), msgHash);\r\n    return Buffer.from((0, secp256k1_1.publicKeyConvert)(senderPubKey, false).slice(1));\r\n};\r\nexports.ecrecover = ecrecover;\r\n/**\r\n * Convert signature parameters into the format of `eth_sign` RPC method.\r\n * @returns Signature\r\n */\r\nvar toRpcSig = function (v, r, s, chainId) {\r\n    var recovery = calculateSigRecovery(v, chainId);\r\n    if (!isValidSigRecovery(recovery)) {\r\n        throw new Error('Invalid signature v value');\r\n    }\r\n    // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin\r\n    return (0, bytes_1.bufferToHex)(Buffer.concat([(0, bytes_1.setLengthLeft)(r, 32), (0, bytes_1.setLengthLeft)(s, 32), (0, bytes_1.toBuffer)(v)]));\r\n};\r\nexports.toRpcSig = toRpcSig;\r\n/**\r\n * Convert signature parameters into the format of Compact Signature Representation (EIP-2098).\r\n * @returns Signature\r\n */\r\nvar toCompactSig = function (v, r, s, chainId) {\r\n    var recovery = calculateSigRecovery(v, chainId);\r\n    if (!isValidSigRecovery(recovery)) {\r\n        throw new Error('Invalid signature v value');\r\n    }\r\n    var vn = (0, types_1.toType)(v, types_1.TypeOutput.Number);\r\n    var ss = s;\r\n    if ((vn > 28 && vn % 2 === 1) || vn === 1 || vn === 28) {\r\n        ss = Buffer.from(s);\r\n        ss[0] |= 0x80;\r\n    }\r\n    return (0, bytes_1.bufferToHex)(Buffer.concat([(0, bytes_1.setLengthLeft)(r, 32), (0, bytes_1.setLengthLeft)(ss, 32)]));\r\n};\r\nexports.toCompactSig = toCompactSig;\r\n/**\r\n * Convert signature format of the `eth_sign` RPC method to signature parameters\r\n * NOTE: all because of a bug in geth: https://github.com/ethereum/go-ethereum/issues/2053\r\n */\r\nvar fromRpcSig = function (sig) {\r\n    var buf = (0, bytes_1.toBuffer)(sig);\r\n    var r;\r\n    var s;\r\n    var v;\r\n    if (buf.length >= 65) {\r\n        r = buf.slice(0, 32);\r\n        s = buf.slice(32, 64);\r\n        v = (0, bytes_1.bufferToInt)(buf.slice(64));\r\n    }\r\n    else if (buf.length === 64) {\r\n        // Compact Signature Representation (https://eips.ethereum.org/EIPS/eip-2098)\r\n        r = buf.slice(0, 32);\r\n        s = buf.slice(32, 64);\r\n        v = (0, bytes_1.bufferToInt)(buf.slice(32, 33)) >> 7;\r\n        s[0] &= 0x7f;\r\n    }\r\n    else {\r\n        throw new Error('Invalid signature length');\r\n    }\r\n    // support both versions of `eth_sign` responses\r\n    if (v < 27) {\r\n        v += 27;\r\n    }\r\n    return {\r\n        v: v,\r\n        r: r,\r\n        s: s,\r\n    };\r\n};\r\nexports.fromRpcSig = fromRpcSig;\r\n/**\r\n * Validate a ECDSA signature.\r\n * @param homesteadOrLater Indicates whether this is being used on either the homestead hardfork or a later one\r\n */\r\nvar isValidSignature = function (v, r, s, homesteadOrLater, chainId) {\r\n    if (homesteadOrLater === void 0) { homesteadOrLater = true; }\r\n    var SECP256K1_N_DIV_2 = new externals_1.BN('7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0', 16);\r\n    var SECP256K1_N = new externals_1.BN('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 16);\r\n    if (r.length !== 32 || s.length !== 32) {\r\n        return false;\r\n    }\r\n    if (!isValidSigRecovery(calculateSigRecovery(v, chainId))) {\r\n        return false;\r\n    }\r\n    var rBN = new externals_1.BN(r);\r\n    var sBN = new externals_1.BN(s);\r\n    if (rBN.isZero() || rBN.gt(SECP256K1_N) || sBN.isZero() || sBN.gt(SECP256K1_N)) {\r\n        return false;\r\n    }\r\n    if (homesteadOrLater && sBN.cmp(SECP256K1_N_DIV_2) === 1) {\r\n        return false;\r\n    }\r\n    return true;\r\n};\r\nexports.isValidSignature = isValidSignature;\r\n/**\r\n * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.\r\n * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`\r\n * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key\r\n * used to produce the signature.\r\n */\r\nvar hashPersonalMessage = function (message) {\r\n    (0, helpers_1.assertIsBuffer)(message);\r\n    var prefix = Buffer.from(\"\\u0019Ethereum Signed Message:\\n\".concat(message.length), 'utf-8');\r\n    return (0, hash_1.keccak)(Buffer.concat([prefix, message]));\r\n};\r\nexports.hashPersonalMessage = hashPersonalMessage;\r\n//# sourceMappingURL=signature.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QuYnJvd3Nlci9zaWduYXR1cmUuanMuanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDJCQUEyQixHQUFHLHdCQUF3QixHQUFHLGtCQUFrQixHQUFHLG9CQUFvQixHQUFHLGdCQUFnQixHQUFHLGlCQUFpQixHQUFHLGNBQWM7QUFDMUosa0JBQWtCLG1CQUFPLENBQUMsMEZBQWlDO0FBQzNELGtCQUFrQixtQkFBTyxDQUFDLDZFQUFhO0FBQ3ZDLGNBQWMsbUJBQU8sQ0FBQyxxRUFBUztBQUMvQixhQUFhLG1CQUFPLENBQUMsbUVBQVE7QUFDN0IsZ0JBQWdCLG1CQUFPLENBQUMseUVBQVc7QUFDbkMsY0FBYyxtQkFBTyxDQUFDLHFFQUFTO0FBQy9CO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEIsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esa0VBQWtFLE1BQU07QUFDeEUsYUFBYTtBQUNiO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE1BQU07QUFDMUM7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQSxvQ0FBb0MsTUFBTTtBQUMxQztBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE1BQU07QUFDdkIsOEJBQThCLE1BQU07QUFDcEM7QUFDQSwyQkFBMkI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0LmJyb3dzZXIvc2lnbmF0dXJlLmpzPzdkODYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5oYXNoUGVyc29uYWxNZXNzYWdlID0gZXhwb3J0cy5pc1ZhbGlkU2lnbmF0dXJlID0gZXhwb3J0cy5mcm9tUnBjU2lnID0gZXhwb3J0cy50b0NvbXBhY3RTaWcgPSBleHBvcnRzLnRvUnBjU2lnID0gZXhwb3J0cy5lY3JlY292ZXIgPSBleHBvcnRzLmVjc2lnbiA9IHZvaWQgMDtcclxudmFyIHNlY3AyNTZrMV8xID0gcmVxdWlyZShcImV0aGVyZXVtLWNyeXB0b2dyYXBoeS9zZWNwMjU2azFcIik7XHJcbnZhciBleHRlcm5hbHNfMSA9IHJlcXVpcmUoXCIuL2V4dGVybmFsc1wiKTtcclxudmFyIGJ5dGVzXzEgPSByZXF1aXJlKFwiLi9ieXRlc1wiKTtcclxudmFyIGhhc2hfMSA9IHJlcXVpcmUoXCIuL2hhc2hcIik7XHJcbnZhciBoZWxwZXJzXzEgPSByZXF1aXJlKFwiLi9oZWxwZXJzXCIpO1xyXG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xyXG5mdW5jdGlvbiBlY3NpZ24obXNnSGFzaCwgcHJpdmF0ZUtleSwgY2hhaW5JZCkge1xyXG4gICAgdmFyIF9hID0gKDAsIHNlY3AyNTZrMV8xLmVjZHNhU2lnbikobXNnSGFzaCwgcHJpdmF0ZUtleSksIHNpZ25hdHVyZSA9IF9hLnNpZ25hdHVyZSwgcmVjb3ZlcnkgPSBfYS5yZWNpZDtcclxuICAgIHZhciByID0gQnVmZmVyLmZyb20oc2lnbmF0dXJlLnNsaWNlKDAsIDMyKSk7XHJcbiAgICB2YXIgcyA9IEJ1ZmZlci5mcm9tKHNpZ25hdHVyZS5zbGljZSgzMiwgNjQpKTtcclxuICAgIGlmICghY2hhaW5JZCB8fCB0eXBlb2YgY2hhaW5JZCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAvLyByZXR1cm4gbGVnYWN5IHR5cGUgRUNEU0FTaWduYXR1cmUgKGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgRUNEU0FTaWduYXR1cmVCdWZmZXIgdG8gaGFuZGxlIGxhcmdlIGNoYWluSWRzKVxyXG4gICAgICAgIGlmIChjaGFpbklkICYmICFOdW1iZXIuaXNTYWZlSW50ZWdlcihjaGFpbklkKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBwcm92aWRlZCBudW1iZXIgaXMgZ3JlYXRlciB0aGFuIE1BWF9TQUZFX0lOVEVHRVIgKHBsZWFzZSB1c2UgYW4gYWx0ZXJuYXRpdmUgaW5wdXQgdHlwZSknKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHZfMSA9IGNoYWluSWQgPyByZWNvdmVyeSArIChjaGFpbklkICogMiArIDM1KSA6IHJlY292ZXJ5ICsgMjc7XHJcbiAgICAgICAgcmV0dXJuIHsgcjogciwgczogcywgdjogdl8xIH07XHJcbiAgICB9XHJcbiAgICB2YXIgY2hhaW5JZEJOID0gKDAsIHR5cGVzXzEudG9UeXBlKShjaGFpbklkLCB0eXBlc18xLlR5cGVPdXRwdXQuQk4pO1xyXG4gICAgdmFyIHYgPSBjaGFpbklkQk4ubXVsbigyKS5hZGRuKDM1KS5hZGRuKHJlY292ZXJ5KS50b0FycmF5TGlrZShCdWZmZXIpO1xyXG4gICAgcmV0dXJuIHsgcjogciwgczogcywgdjogdiB9O1xyXG59XHJcbmV4cG9ydHMuZWNzaWduID0gZWNzaWduO1xyXG5mdW5jdGlvbiBjYWxjdWxhdGVTaWdSZWNvdmVyeSh2LCBjaGFpbklkKSB7XHJcbiAgICB2YXIgdkJOID0gKDAsIHR5cGVzXzEudG9UeXBlKSh2LCB0eXBlc18xLlR5cGVPdXRwdXQuQk4pO1xyXG4gICAgaWYgKCFjaGFpbklkKSB7XHJcbiAgICAgICAgcmV0dXJuIHZCTi5zdWJuKDI3KTtcclxuICAgIH1cclxuICAgIHZhciBjaGFpbklkQk4gPSAoMCwgdHlwZXNfMS50b1R5cGUpKGNoYWluSWQsIHR5cGVzXzEuVHlwZU91dHB1dC5CTik7XHJcbiAgICByZXR1cm4gdkJOLnN1YihjaGFpbklkQk4ubXVsbigyKS5hZGRuKDM1KSk7XHJcbn1cclxuZnVuY3Rpb24gaXNWYWxpZFNpZ1JlY292ZXJ5KHJlY292ZXJ5KSB7XHJcbiAgICB2YXIgcmVjID0gbmV3IGV4dGVybmFsc18xLkJOKHJlY292ZXJ5KTtcclxuICAgIHJldHVybiByZWMuZXFuKDApIHx8IHJlYy5lcW4oMSk7XHJcbn1cclxuLyoqXHJcbiAqIEVDRFNBIHB1YmxpYyBrZXkgcmVjb3ZlcnkgZnJvbSBzaWduYXR1cmUuXHJcbiAqIEByZXR1cm5zIFJlY292ZXJlZCBwdWJsaWMga2V5XHJcbiAqL1xyXG52YXIgZWNyZWNvdmVyID0gZnVuY3Rpb24gKG1zZ0hhc2gsIHYsIHIsIHMsIGNoYWluSWQpIHtcclxuICAgIHZhciBzaWduYXR1cmUgPSBCdWZmZXIuY29uY2F0KFsoMCwgYnl0ZXNfMS5zZXRMZW5ndGhMZWZ0KShyLCAzMiksICgwLCBieXRlc18xLnNldExlbmd0aExlZnQpKHMsIDMyKV0sIDY0KTtcclxuICAgIHZhciByZWNvdmVyeSA9IGNhbGN1bGF0ZVNpZ1JlY292ZXJ5KHYsIGNoYWluSWQpO1xyXG4gICAgaWYgKCFpc1ZhbGlkU2lnUmVjb3ZlcnkocmVjb3ZlcnkpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNpZ25hdHVyZSB2IHZhbHVlJyk7XHJcbiAgICB9XHJcbiAgICB2YXIgc2VuZGVyUHViS2V5ID0gKDAsIHNlY3AyNTZrMV8xLmVjZHNhUmVjb3Zlcikoc2lnbmF0dXJlLCByZWNvdmVyeS50b051bWJlcigpLCBtc2dIYXNoKTtcclxuICAgIHJldHVybiBCdWZmZXIuZnJvbSgoMCwgc2VjcDI1NmsxXzEucHVibGljS2V5Q29udmVydCkoc2VuZGVyUHViS2V5LCBmYWxzZSkuc2xpY2UoMSkpO1xyXG59O1xyXG5leHBvcnRzLmVjcmVjb3ZlciA9IGVjcmVjb3ZlcjtcclxuLyoqXHJcbiAqIENvbnZlcnQgc2lnbmF0dXJlIHBhcmFtZXRlcnMgaW50byB0aGUgZm9ybWF0IG9mIGBldGhfc2lnbmAgUlBDIG1ldGhvZC5cclxuICogQHJldHVybnMgU2lnbmF0dXJlXHJcbiAqL1xyXG52YXIgdG9ScGNTaWcgPSBmdW5jdGlvbiAodiwgciwgcywgY2hhaW5JZCkge1xyXG4gICAgdmFyIHJlY292ZXJ5ID0gY2FsY3VsYXRlU2lnUmVjb3ZlcnkodiwgY2hhaW5JZCk7XHJcbiAgICBpZiAoIWlzVmFsaWRTaWdSZWNvdmVyeShyZWNvdmVyeSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2lnbmF0dXJlIHYgdmFsdWUnKTtcclxuICAgIH1cclxuICAgIC8vIGdldGggKGFuZCB0aGUgUlBDIGV0aF9zaWduIG1ldGhvZCkgdXNlcyB0aGUgNjUgYnl0ZSBmb3JtYXQgdXNlZCBieSBCaXRjb2luXHJcbiAgICByZXR1cm4gKDAsIGJ5dGVzXzEuYnVmZmVyVG9IZXgpKEJ1ZmZlci5jb25jYXQoWygwLCBieXRlc18xLnNldExlbmd0aExlZnQpKHIsIDMyKSwgKDAsIGJ5dGVzXzEuc2V0TGVuZ3RoTGVmdCkocywgMzIpLCAoMCwgYnl0ZXNfMS50b0J1ZmZlcikodildKSk7XHJcbn07XHJcbmV4cG9ydHMudG9ScGNTaWcgPSB0b1JwY1NpZztcclxuLyoqXHJcbiAqIENvbnZlcnQgc2lnbmF0dXJlIHBhcmFtZXRlcnMgaW50byB0aGUgZm9ybWF0IG9mIENvbXBhY3QgU2lnbmF0dXJlIFJlcHJlc2VudGF0aW9uIChFSVAtMjA5OCkuXHJcbiAqIEByZXR1cm5zIFNpZ25hdHVyZVxyXG4gKi9cclxudmFyIHRvQ29tcGFjdFNpZyA9IGZ1bmN0aW9uICh2LCByLCBzLCBjaGFpbklkKSB7XHJcbiAgICB2YXIgcmVjb3ZlcnkgPSBjYWxjdWxhdGVTaWdSZWNvdmVyeSh2LCBjaGFpbklkKTtcclxuICAgIGlmICghaXNWYWxpZFNpZ1JlY292ZXJ5KHJlY292ZXJ5KSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzaWduYXR1cmUgdiB2YWx1ZScpO1xyXG4gICAgfVxyXG4gICAgdmFyIHZuID0gKDAsIHR5cGVzXzEudG9UeXBlKSh2LCB0eXBlc18xLlR5cGVPdXRwdXQuTnVtYmVyKTtcclxuICAgIHZhciBzcyA9IHM7XHJcbiAgICBpZiAoKHZuID4gMjggJiYgdm4gJSAyID09PSAxKSB8fCB2biA9PT0gMSB8fCB2biA9PT0gMjgpIHtcclxuICAgICAgICBzcyA9IEJ1ZmZlci5mcm9tKHMpO1xyXG4gICAgICAgIHNzWzBdIHw9IDB4ODA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKDAsIGJ5dGVzXzEuYnVmZmVyVG9IZXgpKEJ1ZmZlci5jb25jYXQoWygwLCBieXRlc18xLnNldExlbmd0aExlZnQpKHIsIDMyKSwgKDAsIGJ5dGVzXzEuc2V0TGVuZ3RoTGVmdCkoc3MsIDMyKV0pKTtcclxufTtcclxuZXhwb3J0cy50b0NvbXBhY3RTaWcgPSB0b0NvbXBhY3RTaWc7XHJcbi8qKlxyXG4gKiBDb252ZXJ0IHNpZ25hdHVyZSBmb3JtYXQgb2YgdGhlIGBldGhfc2lnbmAgUlBDIG1ldGhvZCB0byBzaWduYXR1cmUgcGFyYW1ldGVyc1xyXG4gKiBOT1RFOiBhbGwgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBnZXRoOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vZ28tZXRoZXJldW0vaXNzdWVzLzIwNTNcclxuICovXHJcbnZhciBmcm9tUnBjU2lnID0gZnVuY3Rpb24gKHNpZykge1xyXG4gICAgdmFyIGJ1ZiA9ICgwLCBieXRlc18xLnRvQnVmZmVyKShzaWcpO1xyXG4gICAgdmFyIHI7XHJcbiAgICB2YXIgcztcclxuICAgIHZhciB2O1xyXG4gICAgaWYgKGJ1Zi5sZW5ndGggPj0gNjUpIHtcclxuICAgICAgICByID0gYnVmLnNsaWNlKDAsIDMyKTtcclxuICAgICAgICBzID0gYnVmLnNsaWNlKDMyLCA2NCk7XHJcbiAgICAgICAgdiA9ICgwLCBieXRlc18xLmJ1ZmZlclRvSW50KShidWYuc2xpY2UoNjQpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGJ1Zi5sZW5ndGggPT09IDY0KSB7XHJcbiAgICAgICAgLy8gQ29tcGFjdCBTaWduYXR1cmUgUmVwcmVzZW50YXRpb24gKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtMjA5OClcclxuICAgICAgICByID0gYnVmLnNsaWNlKDAsIDMyKTtcclxuICAgICAgICBzID0gYnVmLnNsaWNlKDMyLCA2NCk7XHJcbiAgICAgICAgdiA9ICgwLCBieXRlc18xLmJ1ZmZlclRvSW50KShidWYuc2xpY2UoMzIsIDMzKSkgPj4gNztcclxuICAgICAgICBzWzBdICY9IDB4N2Y7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2lnbmF0dXJlIGxlbmd0aCcpO1xyXG4gICAgfVxyXG4gICAgLy8gc3VwcG9ydCBib3RoIHZlcnNpb25zIG9mIGBldGhfc2lnbmAgcmVzcG9uc2VzXHJcbiAgICBpZiAodiA8IDI3KSB7XHJcbiAgICAgICAgdiArPSAyNztcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdjogdixcclxuICAgICAgICByOiByLFxyXG4gICAgICAgIHM6IHMsXHJcbiAgICB9O1xyXG59O1xyXG5leHBvcnRzLmZyb21ScGNTaWcgPSBmcm9tUnBjU2lnO1xyXG4vKipcclxuICogVmFsaWRhdGUgYSBFQ0RTQSBzaWduYXR1cmUuXHJcbiAqIEBwYXJhbSBob21lc3RlYWRPckxhdGVyIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgaXMgYmVpbmcgdXNlZCBvbiBlaXRoZXIgdGhlIGhvbWVzdGVhZCBoYXJkZm9yayBvciBhIGxhdGVyIG9uZVxyXG4gKi9cclxudmFyIGlzVmFsaWRTaWduYXR1cmUgPSBmdW5jdGlvbiAodiwgciwgcywgaG9tZXN0ZWFkT3JMYXRlciwgY2hhaW5JZCkge1xyXG4gICAgaWYgKGhvbWVzdGVhZE9yTGF0ZXIgPT09IHZvaWQgMCkgeyBob21lc3RlYWRPckxhdGVyID0gdHJ1ZTsgfVxyXG4gICAgdmFyIFNFQ1AyNTZLMV9OX0RJVl8yID0gbmV3IGV4dGVybmFsc18xLkJOKCc3ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZjVkNTc2ZTczNTdhNDUwMWRkZmU5MmY0NjY4MWIyMGEwJywgMTYpO1xyXG4gICAgdmFyIFNFQ1AyNTZLMV9OID0gbmV3IGV4dGVybmFsc18xLkJOKCdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWJhYWVkY2U2YWY0OGEwM2JiZmQyNWU4Y2QwMzY0MTQxJywgMTYpO1xyXG4gICAgaWYgKHIubGVuZ3RoICE9PSAzMiB8fCBzLmxlbmd0aCAhPT0gMzIpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzVmFsaWRTaWdSZWNvdmVyeShjYWxjdWxhdGVTaWdSZWNvdmVyeSh2LCBjaGFpbklkKSkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB2YXIgckJOID0gbmV3IGV4dGVybmFsc18xLkJOKHIpO1xyXG4gICAgdmFyIHNCTiA9IG5ldyBleHRlcm5hbHNfMS5CTihzKTtcclxuICAgIGlmIChyQk4uaXNaZXJvKCkgfHwgckJOLmd0KFNFQ1AyNTZLMV9OKSB8fCBzQk4uaXNaZXJvKCkgfHwgc0JOLmd0KFNFQ1AyNTZLMV9OKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChob21lc3RlYWRPckxhdGVyICYmIHNCTi5jbXAoU0VDUDI1NksxX05fRElWXzIpID09PSAxKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn07XHJcbmV4cG9ydHMuaXNWYWxpZFNpZ25hdHVyZSA9IGlzVmFsaWRTaWduYXR1cmU7XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBrZWNjYWstMjU2IGhhc2ggb2YgYG1lc3NhZ2VgLCBwcmVmaXhlZCB3aXRoIHRoZSBoZWFkZXIgdXNlZCBieSB0aGUgYGV0aF9zaWduYCBSUEMgY2FsbC5cclxuICogVGhlIG91dHB1dCBvZiB0aGlzIGZ1bmN0aW9uIGNhbiBiZSBmZWQgaW50byBgZWNzaWduYCB0byBwcm9kdWNlIHRoZSBzYW1lIHNpZ25hdHVyZSBhcyB0aGUgYGV0aF9zaWduYFxyXG4gKiBjYWxsIGZvciBhIGdpdmVuIGBtZXNzYWdlYCwgb3IgZmVkIHRvIGBlY3JlY292ZXJgIGFsb25nIHdpdGggYSBzaWduYXR1cmUgdG8gcmVjb3ZlciB0aGUgcHVibGljIGtleVxyXG4gKiB1c2VkIHRvIHByb2R1Y2UgdGhlIHNpZ25hdHVyZS5cclxuICovXHJcbnZhciBoYXNoUGVyc29uYWxNZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcclxuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIpKG1lc3NhZ2UpO1xyXG4gICAgdmFyIHByZWZpeCA9IEJ1ZmZlci5mcm9tKFwiXFx1MDAxOUV0aGVyZXVtIFNpZ25lZCBNZXNzYWdlOlxcblwiLmNvbmNhdChtZXNzYWdlLmxlbmd0aCksICd1dGYtOCcpO1xyXG4gICAgcmV0dXJuICgwLCBoYXNoXzEua2VjY2FrKShCdWZmZXIuY29uY2F0KFtwcmVmaXgsIG1lc3NhZ2VdKSk7XHJcbn07XHJcbmV4cG9ydHMuaGFzaFBlcnNvbmFsTWVzc2FnZSA9IGhhc2hQZXJzb25hbE1lc3NhZ2U7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZ25hdHVyZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ethereumjs-util/dist.browser/signature.js\n");

/***/ }),

/***/ "./node_modules/ethereumjs-util/dist.browser/types.js":
/*!************************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist.browser/types.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.toType = exports.TypeOutput = exports.bnToRlp = exports.bnToUnpaddedBuffer = exports.bnToHex = void 0;\r\nvar externals_1 = __webpack_require__(/*! ./externals */ \"./node_modules/ethereumjs-util/dist.browser/externals.js\");\r\nvar internal_1 = __webpack_require__(/*! ./internal */ \"./node_modules/ethereumjs-util/dist.browser/internal.js\");\r\nvar bytes_1 = __webpack_require__(/*! ./bytes */ \"./node_modules/ethereumjs-util/dist.browser/bytes.js\");\r\n/**\r\n * Convert BN to 0x-prefixed hex string.\r\n */\r\nfunction bnToHex(value) {\r\n    return \"0x\".concat(value.toString(16));\r\n}\r\nexports.bnToHex = bnToHex;\r\n/**\r\n * Convert value from BN to an unpadded Buffer\r\n * (useful for RLP transport)\r\n * @param value value to convert\r\n */\r\nfunction bnToUnpaddedBuffer(value) {\r\n    // Using `bn.toArrayLike(Buffer)` instead of `bn.toBuffer()`\r\n    // for compatibility with browserify and similar tools\r\n    return (0, bytes_1.unpadBuffer)(value.toArrayLike(Buffer));\r\n}\r\nexports.bnToUnpaddedBuffer = bnToUnpaddedBuffer;\r\n/**\r\n * Deprecated alias for {@link bnToUnpaddedBuffer}\r\n * @deprecated\r\n */\r\nfunction bnToRlp(value) {\r\n    return bnToUnpaddedBuffer(value);\r\n}\r\nexports.bnToRlp = bnToRlp;\r\n/**\r\n * Type output options\r\n */\r\nvar TypeOutput;\r\n(function (TypeOutput) {\r\n    TypeOutput[TypeOutput[\"Number\"] = 0] = \"Number\";\r\n    TypeOutput[TypeOutput[\"BN\"] = 1] = \"BN\";\r\n    TypeOutput[TypeOutput[\"Buffer\"] = 2] = \"Buffer\";\r\n    TypeOutput[TypeOutput[\"PrefixedHexString\"] = 3] = \"PrefixedHexString\";\r\n})(TypeOutput = exports.TypeOutput || (exports.TypeOutput = {}));\r\nfunction toType(input, outputType) {\r\n    if (input === null) {\r\n        return null;\r\n    }\r\n    if (input === undefined) {\r\n        return undefined;\r\n    }\r\n    if (typeof input === 'string' && !(0, internal_1.isHexString)(input)) {\r\n        throw new Error(\"A string must be provided with a 0x-prefix, given: \".concat(input));\r\n    }\r\n    else if (typeof input === 'number' && !Number.isSafeInteger(input)) {\r\n        throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)');\r\n    }\r\n    var output = (0, bytes_1.toBuffer)(input);\r\n    if (outputType === TypeOutput.Buffer) {\r\n        return output;\r\n    }\r\n    else if (outputType === TypeOutput.BN) {\r\n        return new externals_1.BN(output);\r\n    }\r\n    else if (outputType === TypeOutput.Number) {\r\n        var bn = new externals_1.BN(output);\r\n        var max = new externals_1.BN(Number.MAX_SAFE_INTEGER.toString());\r\n        if (bn.gt(max)) {\r\n            throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)');\r\n        }\r\n        return bn.toNumber();\r\n    }\r\n    else {\r\n        // outputType === TypeOutput.PrefixedHexString\r\n        return \"0x\".concat(output.toString('hex'));\r\n    }\r\n}\r\nexports.toType = toType;\r\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QuYnJvd3Nlci90eXBlcy5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYyxHQUFHLGtCQUFrQixHQUFHLGVBQWUsR0FBRywwQkFBMEIsR0FBRyxlQUFlO0FBQ3BHLGtCQUFrQixtQkFBTyxDQUFDLDZFQUFhO0FBQ3ZDLGlCQUFpQixtQkFBTyxDQUFDLDJFQUFZO0FBQ3JDLGNBQWMsbUJBQU8sQ0FBQyxxRUFBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxNQUFNO0FBQzVEO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0Msa0JBQWtCLEtBQUs7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC5icm93c2VyL3R5cGVzLmpzPzBiY2YiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy50b1R5cGUgPSBleHBvcnRzLlR5cGVPdXRwdXQgPSBleHBvcnRzLmJuVG9SbHAgPSBleHBvcnRzLmJuVG9VbnBhZGRlZEJ1ZmZlciA9IGV4cG9ydHMuYm5Ub0hleCA9IHZvaWQgMDtcclxudmFyIGV4dGVybmFsc18xID0gcmVxdWlyZShcIi4vZXh0ZXJuYWxzXCIpO1xyXG52YXIgaW50ZXJuYWxfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFsXCIpO1xyXG52YXIgYnl0ZXNfMSA9IHJlcXVpcmUoXCIuL2J5dGVzXCIpO1xyXG4vKipcclxuICogQ29udmVydCBCTiB0byAweC1wcmVmaXhlZCBoZXggc3RyaW5nLlxyXG4gKi9cclxuZnVuY3Rpb24gYm5Ub0hleCh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIFwiMHhcIi5jb25jYXQodmFsdWUudG9TdHJpbmcoMTYpKTtcclxufVxyXG5leHBvcnRzLmJuVG9IZXggPSBiblRvSGV4O1xyXG4vKipcclxuICogQ29udmVydCB2YWx1ZSBmcm9tIEJOIHRvIGFuIHVucGFkZGVkIEJ1ZmZlclxyXG4gKiAodXNlZnVsIGZvciBSTFAgdHJhbnNwb3J0KVxyXG4gKiBAcGFyYW0gdmFsdWUgdmFsdWUgdG8gY29udmVydFxyXG4gKi9cclxuZnVuY3Rpb24gYm5Ub1VucGFkZGVkQnVmZmVyKHZhbHVlKSB7XHJcbiAgICAvLyBVc2luZyBgYm4udG9BcnJheUxpa2UoQnVmZmVyKWAgaW5zdGVhZCBvZiBgYm4udG9CdWZmZXIoKWBcclxuICAgIC8vIGZvciBjb21wYXRpYmlsaXR5IHdpdGggYnJvd3NlcmlmeSBhbmQgc2ltaWxhciB0b29sc1xyXG4gICAgcmV0dXJuICgwLCBieXRlc18xLnVucGFkQnVmZmVyKSh2YWx1ZS50b0FycmF5TGlrZShCdWZmZXIpKTtcclxufVxyXG5leHBvcnRzLmJuVG9VbnBhZGRlZEJ1ZmZlciA9IGJuVG9VbnBhZGRlZEJ1ZmZlcjtcclxuLyoqXHJcbiAqIERlcHJlY2F0ZWQgYWxpYXMgZm9yIHtAbGluayBiblRvVW5wYWRkZWRCdWZmZXJ9XHJcbiAqIEBkZXByZWNhdGVkXHJcbiAqL1xyXG5mdW5jdGlvbiBiblRvUmxwKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gYm5Ub1VucGFkZGVkQnVmZmVyKHZhbHVlKTtcclxufVxyXG5leHBvcnRzLmJuVG9SbHAgPSBiblRvUmxwO1xyXG4vKipcclxuICogVHlwZSBvdXRwdXQgb3B0aW9uc1xyXG4gKi9cclxudmFyIFR5cGVPdXRwdXQ7XHJcbihmdW5jdGlvbiAoVHlwZU91dHB1dCkge1xyXG4gICAgVHlwZU91dHB1dFtUeXBlT3V0cHV0W1wiTnVtYmVyXCJdID0gMF0gPSBcIk51bWJlclwiO1xyXG4gICAgVHlwZU91dHB1dFtUeXBlT3V0cHV0W1wiQk5cIl0gPSAxXSA9IFwiQk5cIjtcclxuICAgIFR5cGVPdXRwdXRbVHlwZU91dHB1dFtcIkJ1ZmZlclwiXSA9IDJdID0gXCJCdWZmZXJcIjtcclxuICAgIFR5cGVPdXRwdXRbVHlwZU91dHB1dFtcIlByZWZpeGVkSGV4U3RyaW5nXCJdID0gM10gPSBcIlByZWZpeGVkSGV4U3RyaW5nXCI7XHJcbn0pKFR5cGVPdXRwdXQgPSBleHBvcnRzLlR5cGVPdXRwdXQgfHwgKGV4cG9ydHMuVHlwZU91dHB1dCA9IHt9KSk7XHJcbmZ1bmN0aW9uIHRvVHlwZShpbnB1dCwgb3V0cHV0VHlwZSkge1xyXG4gICAgaWYgKGlucHV0ID09PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBpZiAoaW5wdXQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJyAmJiAhKDAsIGludGVybmFsXzEuaXNIZXhTdHJpbmcpKGlucHV0KSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkEgc3RyaW5nIG11c3QgYmUgcHJvdmlkZWQgd2l0aCBhIDB4LXByZWZpeCwgZ2l2ZW46IFwiLmNvbmNhdChpbnB1dCkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJyAmJiAhTnVtYmVyLmlzU2FmZUludGVnZXIoaW5wdXQpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcHJvdmlkZWQgbnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiBNQVhfU0FGRV9JTlRFR0VSIChwbGVhc2UgdXNlIGFuIGFsdGVybmF0aXZlIGlucHV0IHR5cGUpJyk7XHJcbiAgICB9XHJcbiAgICB2YXIgb3V0cHV0ID0gKDAsIGJ5dGVzXzEudG9CdWZmZXIpKGlucHV0KTtcclxuICAgIGlmIChvdXRwdXRUeXBlID09PSBUeXBlT3V0cHV0LkJ1ZmZlcikge1xyXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChvdXRwdXRUeXBlID09PSBUeXBlT3V0cHV0LkJOKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBleHRlcm5hbHNfMS5CTihvdXRwdXQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAob3V0cHV0VHlwZSA9PT0gVHlwZU91dHB1dC5OdW1iZXIpIHtcclxuICAgICAgICB2YXIgYm4gPSBuZXcgZXh0ZXJuYWxzXzEuQk4ob3V0cHV0KTtcclxuICAgICAgICB2YXIgbWF4ID0gbmV3IGV4dGVybmFsc18xLkJOKE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIGlmIChibi5ndChtYXgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHByb3ZpZGVkIG51bWJlciBpcyBncmVhdGVyIHRoYW4gTUFYX1NBRkVfSU5URUdFUiAocGxlYXNlIHVzZSBhbiBhbHRlcm5hdGl2ZSBvdXRwdXQgdHlwZSknKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJuLnRvTnVtYmVyKCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBvdXRwdXRUeXBlID09PSBUeXBlT3V0cHV0LlByZWZpeGVkSGV4U3RyaW5nXHJcbiAgICAgICAgcmV0dXJuIFwiMHhcIi5jb25jYXQob3V0cHV0LnRvU3RyaW5nKCdoZXgnKSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy50b1R5cGUgPSB0b1R5cGU7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ethereumjs-util/dist.browser/types.js\n");

/***/ }),

/***/ "./node_modules/fast-deep-equal/index.js":
/*!***********************************************!*\
  !*** ./node_modules/fast-deep-equal/index.js ***!
  \***********************************************/
/***/ (function(module) {

"use strict";
eval("\r\n\r\n// do not edit .js files directly - edit src/index.jst\r\n\r\n\r\n\r\nmodule.exports = function equal(a, b) {\r\n  if (a === b) return true;\r\n\r\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\r\n    if (a.constructor !== b.constructor) return false;\r\n\r\n    var length, i, keys;\r\n    if (Array.isArray(a)) {\r\n      length = a.length;\r\n      if (length != b.length) return false;\r\n      for (i = length; i-- !== 0;)\r\n        if (!equal(a[i], b[i])) return false;\r\n      return true;\r\n    }\r\n\r\n\r\n\r\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\r\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\r\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\r\n\r\n    keys = Object.keys(a);\r\n    length = keys.length;\r\n    if (length !== Object.keys(b).length) return false;\r\n\r\n    for (i = length; i-- !== 0;)\r\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\r\n\r\n    for (i = length; i-- !== 0;) {\r\n      var key = keys[i];\r\n\r\n      if (!equal(a[key], b[key])) return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  // true if both NaN, false otherwise\r\n  return a!==a && b!==b;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmFzdC1kZWVwLWVxdWFsL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFVBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixVQUFVO0FBQy9CO0FBQ0E7QUFDQSxxQkFBcUIsVUFBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYXN0LWRlZXAtZXF1YWwvaW5kZXguanM/MGJjNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG4vLyBkbyBub3QgZWRpdCAuanMgZmlsZXMgZGlyZWN0bHkgLSBlZGl0IHNyYy9pbmRleC5qc3RcclxuXHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlcXVhbChhLCBiKSB7XHJcbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xyXG5cclxuICBpZiAoYSAmJiBiICYmIHR5cGVvZiBhID09ICdvYmplY3QnICYmIHR5cGVvZiBiID09ICdvYmplY3QnKSB7XHJcbiAgICBpZiAoYS5jb25zdHJ1Y3RvciAhPT0gYi5jb25zdHJ1Y3RvcikgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgIHZhciBsZW5ndGgsIGksIGtleXM7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xyXG4gICAgICBsZW5ndGggPSBhLmxlbmd0aDtcclxuICAgICAgaWYgKGxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXHJcbiAgICAgICAgaWYgKCFlcXVhbChhW2ldLCBiW2ldKSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcblxyXG5cclxuICAgIGlmIChhLmNvbnN0cnVjdG9yID09PSBSZWdFeHApIHJldHVybiBhLnNvdXJjZSA9PT0gYi5zb3VyY2UgJiYgYS5mbGFncyA9PT0gYi5mbGFncztcclxuICAgIGlmIChhLnZhbHVlT2YgIT09IE9iamVjdC5wcm90b3R5cGUudmFsdWVPZikgcmV0dXJuIGEudmFsdWVPZigpID09PSBiLnZhbHVlT2YoKTtcclxuICAgIGlmIChhLnRvU3RyaW5nICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKSByZXR1cm4gYS50b1N0cmluZygpID09PSBiLnRvU3RyaW5nKCk7XHJcblxyXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xyXG4gICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XHJcbiAgICBpZiAobGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXHJcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIGtleXNbaV0pKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KSB7XHJcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xyXG5cclxuICAgICAgaWYgKCFlcXVhbChhW2tleV0sIGJba2V5XSkpIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8vIHRydWUgaWYgYm90aCBOYU4sIGZhbHNlIG90aGVyd2lzZVxyXG4gIHJldHVybiBhIT09YSAmJiBiIT09YjtcclxufTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/fast-deep-equal/index.js\n");

/***/ }),

/***/ "./node_modules/fast-safe-stringify/index.js":
/*!***************************************************!*\
  !*** ./node_modules/fast-safe-stringify/index.js ***!
  \***************************************************/
/***/ (function(module) {

eval("module.exports = stringify\r\nstringify.default = stringify\r\nstringify.stable = deterministicStringify\r\nstringify.stableStringify = deterministicStringify\r\n\r\nvar LIMIT_REPLACE_NODE = '[...]'\r\nvar CIRCULAR_REPLACE_NODE = '[Circular]'\r\n\r\nvar arr = []\r\nvar replacerStack = []\r\n\r\nfunction defaultOptions () {\r\n  return {\r\n    depthLimit: Number.MAX_SAFE_INTEGER,\r\n    edgesLimit: Number.MAX_SAFE_INTEGER\r\n  }\r\n}\r\n\r\n// Regular stringify\r\nfunction stringify (obj, replacer, spacer, options) {\r\n  if (typeof options === 'undefined') {\r\n    options = defaultOptions()\r\n  }\r\n\r\n  decirc(obj, '', 0, [], undefined, 0, options)\r\n  var res\r\n  try {\r\n    if (replacerStack.length === 0) {\r\n      res = JSON.stringify(obj, replacer, spacer)\r\n    } else {\r\n      res = JSON.stringify(obj, replaceGetterValues(replacer), spacer)\r\n    }\r\n  } catch (_) {\r\n    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]')\r\n  } finally {\r\n    while (arr.length !== 0) {\r\n      var part = arr.pop()\r\n      if (part.length === 4) {\r\n        Object.defineProperty(part[0], part[1], part[3])\r\n      } else {\r\n        part[0][part[1]] = part[2]\r\n      }\r\n    }\r\n  }\r\n  return res\r\n}\r\n\r\nfunction setReplace (replace, val, k, parent) {\r\n  var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k)\r\n  if (propertyDescriptor.get !== undefined) {\r\n    if (propertyDescriptor.configurable) {\r\n      Object.defineProperty(parent, k, { value: replace })\r\n      arr.push([parent, k, val, propertyDescriptor])\r\n    } else {\r\n      replacerStack.push([val, k, replace])\r\n    }\r\n  } else {\r\n    parent[k] = replace\r\n    arr.push([parent, k, val])\r\n  }\r\n}\r\n\r\nfunction decirc (val, k, edgeIndex, stack, parent, depth, options) {\r\n  depth += 1\r\n  var i\r\n  if (typeof val === 'object' && val !== null) {\r\n    for (i = 0; i < stack.length; i++) {\r\n      if (stack[i] === val) {\r\n        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent)\r\n        return\r\n      }\r\n    }\r\n\r\n    if (\r\n      typeof options.depthLimit !== 'undefined' &&\r\n      depth > options.depthLimit\r\n    ) {\r\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent)\r\n      return\r\n    }\r\n\r\n    if (\r\n      typeof options.edgesLimit !== 'undefined' &&\r\n      edgeIndex + 1 > options.edgesLimit\r\n    ) {\r\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent)\r\n      return\r\n    }\r\n\r\n    stack.push(val)\r\n    // Optimize for Arrays. Big arrays could kill the performance otherwise!\r\n    if (Array.isArray(val)) {\r\n      for (i = 0; i < val.length; i++) {\r\n        decirc(val[i], i, i, stack, val, depth, options)\r\n      }\r\n    } else {\r\n      var keys = Object.keys(val)\r\n      for (i = 0; i < keys.length; i++) {\r\n        var key = keys[i]\r\n        decirc(val[key], key, i, stack, val, depth, options)\r\n      }\r\n    }\r\n    stack.pop()\r\n  }\r\n}\r\n\r\n// Stable-stringify\r\nfunction compareFunction (a, b) {\r\n  if (a < b) {\r\n    return -1\r\n  }\r\n  if (a > b) {\r\n    return 1\r\n  }\r\n  return 0\r\n}\r\n\r\nfunction deterministicStringify (obj, replacer, spacer, options) {\r\n  if (typeof options === 'undefined') {\r\n    options = defaultOptions()\r\n  }\r\n\r\n  var tmp = deterministicDecirc(obj, '', 0, [], undefined, 0, options) || obj\r\n  var res\r\n  try {\r\n    if (replacerStack.length === 0) {\r\n      res = JSON.stringify(tmp, replacer, spacer)\r\n    } else {\r\n      res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer)\r\n    }\r\n  } catch (_) {\r\n    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]')\r\n  } finally {\r\n    // Ensure that we restore the object as it was.\r\n    while (arr.length !== 0) {\r\n      var part = arr.pop()\r\n      if (part.length === 4) {\r\n        Object.defineProperty(part[0], part[1], part[3])\r\n      } else {\r\n        part[0][part[1]] = part[2]\r\n      }\r\n    }\r\n  }\r\n  return res\r\n}\r\n\r\nfunction deterministicDecirc (val, k, edgeIndex, stack, parent, depth, options) {\r\n  depth += 1\r\n  var i\r\n  if (typeof val === 'object' && val !== null) {\r\n    for (i = 0; i < stack.length; i++) {\r\n      if (stack[i] === val) {\r\n        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent)\r\n        return\r\n      }\r\n    }\r\n    try {\r\n      if (typeof val.toJSON === 'function') {\r\n        return\r\n      }\r\n    } catch (_) {\r\n      return\r\n    }\r\n\r\n    if (\r\n      typeof options.depthLimit !== 'undefined' &&\r\n      depth > options.depthLimit\r\n    ) {\r\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent)\r\n      return\r\n    }\r\n\r\n    if (\r\n      typeof options.edgesLimit !== 'undefined' &&\r\n      edgeIndex + 1 > options.edgesLimit\r\n    ) {\r\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent)\r\n      return\r\n    }\r\n\r\n    stack.push(val)\r\n    // Optimize for Arrays. Big arrays could kill the performance otherwise!\r\n    if (Array.isArray(val)) {\r\n      for (i = 0; i < val.length; i++) {\r\n        deterministicDecirc(val[i], i, i, stack, val, depth, options)\r\n      }\r\n    } else {\r\n      // Create a temporary object in the required way\r\n      var tmp = {}\r\n      var keys = Object.keys(val).sort(compareFunction)\r\n      for (i = 0; i < keys.length; i++) {\r\n        var key = keys[i]\r\n        deterministicDecirc(val[key], key, i, stack, val, depth, options)\r\n        tmp[key] = val[key]\r\n      }\r\n      if (typeof parent !== 'undefined') {\r\n        arr.push([parent, k, val])\r\n        parent[k] = tmp\r\n      } else {\r\n        return tmp\r\n      }\r\n    }\r\n    stack.pop()\r\n  }\r\n}\r\n\r\n// wraps replacer function to handle values we couldn't replace\r\n// and mark them as replaced value\r\nfunction replaceGetterValues (replacer) {\r\n  replacer =\r\n    typeof replacer !== 'undefined'\r\n      ? replacer\r\n      : function (k, v) {\r\n        return v\r\n      }\r\n  return function (key, val) {\r\n    if (replacerStack.length > 0) {\r\n      for (var i = 0; i < replacerStack.length; i++) {\r\n        var part = replacerStack[i]\r\n        if (part[1] === key && part[0] === val) {\r\n          val = part[2]\r\n          replacerStack.splice(i, 1)\r\n          break\r\n        }\r\n      }\r\n    }\r\n    return replacer.call(this, key, val)\r\n  }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmFzdC1zYWZlLXN0cmluZ2lmeS9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxnQkFBZ0I7QUFDekQ7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMEJBQTBCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2Zhc3Qtc2FmZS1zdHJpbmdpZnkvaW5kZXguanM/MzcyZSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHN0cmluZ2lmeVxyXG5zdHJpbmdpZnkuZGVmYXVsdCA9IHN0cmluZ2lmeVxyXG5zdHJpbmdpZnkuc3RhYmxlID0gZGV0ZXJtaW5pc3RpY1N0cmluZ2lmeVxyXG5zdHJpbmdpZnkuc3RhYmxlU3RyaW5naWZ5ID0gZGV0ZXJtaW5pc3RpY1N0cmluZ2lmeVxyXG5cclxudmFyIExJTUlUX1JFUExBQ0VfTk9ERSA9ICdbLi4uXSdcclxudmFyIENJUkNVTEFSX1JFUExBQ0VfTk9ERSA9ICdbQ2lyY3VsYXJdJ1xyXG5cclxudmFyIGFyciA9IFtdXHJcbnZhciByZXBsYWNlclN0YWNrID0gW11cclxuXHJcbmZ1bmN0aW9uIGRlZmF1bHRPcHRpb25zICgpIHtcclxuICByZXR1cm4ge1xyXG4gICAgZGVwdGhMaW1pdDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXHJcbiAgICBlZGdlc0xpbWl0OiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxyXG4gIH1cclxufVxyXG5cclxuLy8gUmVndWxhciBzdHJpbmdpZnlcclxuZnVuY3Rpb24gc3RyaW5naWZ5IChvYmosIHJlcGxhY2VyLCBzcGFjZXIsIG9wdGlvbnMpIHtcclxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnMoKVxyXG4gIH1cclxuXHJcbiAgZGVjaXJjKG9iaiwgJycsIDAsIFtdLCB1bmRlZmluZWQsIDAsIG9wdGlvbnMpXHJcbiAgdmFyIHJlc1xyXG4gIHRyeSB7XHJcbiAgICBpZiAocmVwbGFjZXJTdGFjay5sZW5ndGggPT09IDApIHtcclxuICAgICAgcmVzID0gSlNPTi5zdHJpbmdpZnkob2JqLCByZXBsYWNlciwgc3BhY2VyKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmVzID0gSlNPTi5zdHJpbmdpZnkob2JqLCByZXBsYWNlR2V0dGVyVmFsdWVzKHJlcGxhY2VyKSwgc3BhY2VyKVxyXG4gICAgfVxyXG4gIH0gY2F0Y2ggKF8pIHtcclxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSgnW3VuYWJsZSB0byBzZXJpYWxpemUsIGNpcmN1bGFyIHJlZmVyZW5jZSBpcyB0b28gY29tcGxleCB0byBhbmFseXplXScpXHJcbiAgfSBmaW5hbGx5IHtcclxuICAgIHdoaWxlIChhcnIubGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgIHZhciBwYXJ0ID0gYXJyLnBvcCgpXHJcbiAgICAgIGlmIChwYXJ0Lmxlbmd0aCA9PT0gNCkge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwYXJ0WzBdLCBwYXJ0WzFdLCBwYXJ0WzNdKVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHBhcnRbMF1bcGFydFsxXV0gPSBwYXJ0WzJdXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHJlc1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZXRSZXBsYWNlIChyZXBsYWNlLCB2YWwsIGssIHBhcmVudCkge1xyXG4gIHZhciBwcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHBhcmVudCwgaylcclxuICBpZiAocHJvcGVydHlEZXNjcmlwdG9yLmdldCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICBpZiAocHJvcGVydHlEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGFyZW50LCBrLCB7IHZhbHVlOiByZXBsYWNlIH0pXHJcbiAgICAgIGFyci5wdXNoKFtwYXJlbnQsIGssIHZhbCwgcHJvcGVydHlEZXNjcmlwdG9yXSlcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJlcGxhY2VyU3RhY2sucHVzaChbdmFsLCBrLCByZXBsYWNlXSlcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgcGFyZW50W2tdID0gcmVwbGFjZVxyXG4gICAgYXJyLnB1c2goW3BhcmVudCwgaywgdmFsXSlcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlY2lyYyAodmFsLCBrLCBlZGdlSW5kZXgsIHN0YWNrLCBwYXJlbnQsIGRlcHRoLCBvcHRpb25zKSB7XHJcbiAgZGVwdGggKz0gMVxyXG4gIHZhciBpXHJcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCkge1xyXG4gICAgZm9yIChpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlmIChzdGFja1tpXSA9PT0gdmFsKSB7XHJcbiAgICAgICAgc2V0UmVwbGFjZShDSVJDVUxBUl9SRVBMQUNFX05PREUsIHZhbCwgaywgcGFyZW50KVxyXG4gICAgICAgIHJldHVyblxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKFxyXG4gICAgICB0eXBlb2Ygb3B0aW9ucy5kZXB0aExpbWl0ICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgICBkZXB0aCA+IG9wdGlvbnMuZGVwdGhMaW1pdFxyXG4gICAgKSB7XHJcbiAgICAgIHNldFJlcGxhY2UoTElNSVRfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudClcclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKFxyXG4gICAgICB0eXBlb2Ygb3B0aW9ucy5lZGdlc0xpbWl0ICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgICBlZGdlSW5kZXggKyAxID4gb3B0aW9ucy5lZGdlc0xpbWl0XHJcbiAgICApIHtcclxuICAgICAgc2V0UmVwbGFjZShMSU1JVF9SRVBMQUNFX05PREUsIHZhbCwgaywgcGFyZW50KVxyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuXHJcbiAgICBzdGFjay5wdXNoKHZhbClcclxuICAgIC8vIE9wdGltaXplIGZvciBBcnJheXMuIEJpZyBhcnJheXMgY291bGQga2lsbCB0aGUgcGVyZm9ybWFuY2Ugb3RoZXJ3aXNlIVxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgZGVjaXJjKHZhbFtpXSwgaSwgaSwgc3RhY2ssIHZhbCwgZGVwdGgsIG9wdGlvbnMpXHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsKVxyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldXHJcbiAgICAgICAgZGVjaXJjKHZhbFtrZXldLCBrZXksIGksIHN0YWNrLCB2YWwsIGRlcHRoLCBvcHRpb25zKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGFjay5wb3AoKVxyXG4gIH1cclxufVxyXG5cclxuLy8gU3RhYmxlLXN0cmluZ2lmeVxyXG5mdW5jdGlvbiBjb21wYXJlRnVuY3Rpb24gKGEsIGIpIHtcclxuICBpZiAoYSA8IGIpIHtcclxuICAgIHJldHVybiAtMVxyXG4gIH1cclxuICBpZiAoYSA+IGIpIHtcclxuICAgIHJldHVybiAxXHJcbiAgfVxyXG4gIHJldHVybiAwXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRldGVybWluaXN0aWNTdHJpbmdpZnkgKG9iaiwgcmVwbGFjZXIsIHNwYWNlciwgb3B0aW9ucykge1xyXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucygpXHJcbiAgfVxyXG5cclxuICB2YXIgdG1wID0gZGV0ZXJtaW5pc3RpY0RlY2lyYyhvYmosICcnLCAwLCBbXSwgdW5kZWZpbmVkLCAwLCBvcHRpb25zKSB8fCBvYmpcclxuICB2YXIgcmVzXHJcbiAgdHJ5IHtcclxuICAgIGlmIChyZXBsYWNlclN0YWNrLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICByZXMgPSBKU09OLnN0cmluZ2lmeSh0bXAsIHJlcGxhY2VyLCBzcGFjZXIpXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXMgPSBKU09OLnN0cmluZ2lmeSh0bXAsIHJlcGxhY2VHZXR0ZXJWYWx1ZXMocmVwbGFjZXIpLCBzcGFjZXIpXHJcbiAgICB9XHJcbiAgfSBjYXRjaCAoXykge1xyXG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KCdbdW5hYmxlIHRvIHNlcmlhbGl6ZSwgY2lyY3VsYXIgcmVmZXJlbmNlIGlzIHRvbyBjb21wbGV4IHRvIGFuYWx5emVdJylcclxuICB9IGZpbmFsbHkge1xyXG4gICAgLy8gRW5zdXJlIHRoYXQgd2UgcmVzdG9yZSB0aGUgb2JqZWN0IGFzIGl0IHdhcy5cclxuICAgIHdoaWxlIChhcnIubGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgIHZhciBwYXJ0ID0gYXJyLnBvcCgpXHJcbiAgICAgIGlmIChwYXJ0Lmxlbmd0aCA9PT0gNCkge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwYXJ0WzBdLCBwYXJ0WzFdLCBwYXJ0WzNdKVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHBhcnRbMF1bcGFydFsxXV0gPSBwYXJ0WzJdXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHJlc1xyXG59XHJcblxyXG5mdW5jdGlvbiBkZXRlcm1pbmlzdGljRGVjaXJjICh2YWwsIGssIGVkZ2VJbmRleCwgc3RhY2ssIHBhcmVudCwgZGVwdGgsIG9wdGlvbnMpIHtcclxuICBkZXB0aCArPSAxXHJcbiAgdmFyIGlcclxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdmFsICE9PSBudWxsKSB7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcclxuICAgICAgaWYgKHN0YWNrW2ldID09PSB2YWwpIHtcclxuICAgICAgICBzZXRSZXBsYWNlKENJUkNVTEFSX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpXHJcbiAgICAgICAgcmV0dXJuXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHRyeSB7XHJcbiAgICAgIGlmICh0eXBlb2YgdmFsLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHJldHVyblxyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChfKSB7XHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG5cclxuICAgIGlmIChcclxuICAgICAgdHlwZW9mIG9wdGlvbnMuZGVwdGhMaW1pdCAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgZGVwdGggPiBvcHRpb25zLmRlcHRoTGltaXRcclxuICAgICkge1xyXG4gICAgICBzZXRSZXBsYWNlKExJTUlUX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpXHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG5cclxuICAgIGlmIChcclxuICAgICAgdHlwZW9mIG9wdGlvbnMuZWRnZXNMaW1pdCAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgZWRnZUluZGV4ICsgMSA+IG9wdGlvbnMuZWRnZXNMaW1pdFxyXG4gICAgKSB7XHJcbiAgICAgIHNldFJlcGxhY2UoTElNSVRfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudClcclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcblxyXG4gICAgc3RhY2sucHVzaCh2YWwpXHJcbiAgICAvLyBPcHRpbWl6ZSBmb3IgQXJyYXlzLiBCaWcgYXJyYXlzIGNvdWxkIGtpbGwgdGhlIHBlcmZvcm1hbmNlIG90aGVyd2lzZSFcclxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcclxuICAgICAgZm9yIChpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGRldGVybWluaXN0aWNEZWNpcmModmFsW2ldLCBpLCBpLCBzdGFjaywgdmFsLCBkZXB0aCwgb3B0aW9ucylcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gQ3JlYXRlIGEgdGVtcG9yYXJ5IG9iamVjdCBpbiB0aGUgcmVxdWlyZWQgd2F5XHJcbiAgICAgIHZhciB0bXAgPSB7fVxyXG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbCkuc29ydChjb21wYXJlRnVuY3Rpb24pXHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV1cclxuICAgICAgICBkZXRlcm1pbmlzdGljRGVjaXJjKHZhbFtrZXldLCBrZXksIGksIHN0YWNrLCB2YWwsIGRlcHRoLCBvcHRpb25zKVxyXG4gICAgICAgIHRtcFtrZXldID0gdmFsW2tleV1cclxuICAgICAgfVxyXG4gICAgICBpZiAodHlwZW9mIHBhcmVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICBhcnIucHVzaChbcGFyZW50LCBrLCB2YWxdKVxyXG4gICAgICAgIHBhcmVudFtrXSA9IHRtcFxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB0bXBcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhY2sucG9wKClcclxuICB9XHJcbn1cclxuXHJcbi8vIHdyYXBzIHJlcGxhY2VyIGZ1bmN0aW9uIHRvIGhhbmRsZSB2YWx1ZXMgd2UgY291bGRuJ3QgcmVwbGFjZVxyXG4vLyBhbmQgbWFyayB0aGVtIGFzIHJlcGxhY2VkIHZhbHVlXHJcbmZ1bmN0aW9uIHJlcGxhY2VHZXR0ZXJWYWx1ZXMgKHJlcGxhY2VyKSB7XHJcbiAgcmVwbGFjZXIgPVxyXG4gICAgdHlwZW9mIHJlcGxhY2VyICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICA/IHJlcGxhY2VyXHJcbiAgICAgIDogZnVuY3Rpb24gKGssIHYpIHtcclxuICAgICAgICByZXR1cm4gdlxyXG4gICAgICB9XHJcbiAgcmV0dXJuIGZ1bmN0aW9uIChrZXksIHZhbCkge1xyXG4gICAgaWYgKHJlcGxhY2VyU3RhY2subGVuZ3RoID4gMCkge1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcGxhY2VyU3RhY2subGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgcGFydCA9IHJlcGxhY2VyU3RhY2tbaV1cclxuICAgICAgICBpZiAocGFydFsxXSA9PT0ga2V5ICYmIHBhcnRbMF0gPT09IHZhbCkge1xyXG4gICAgICAgICAgdmFsID0gcGFydFsyXVxyXG4gICAgICAgICAgcmVwbGFjZXJTdGFjay5zcGxpY2UoaSwgMSlcclxuICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbClcclxuICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/fast-safe-stringify/index.js\n");

/***/ }),

/***/ "./node_modules/foreach/index.js":
/*!***************************************!*\
  !*** ./node_modules/foreach/index.js ***!
  \***************************************/
/***/ (function(module) {

eval("\r\nvar hasOwn = Object.prototype.hasOwnProperty;\r\nvar toString = Object.prototype.toString;\r\n\r\nmodule.exports = function forEach (obj, fn, ctx) {\r\n    if (toString.call(fn) !== '[object Function]') {\r\n        throw new TypeError('iterator must be a function');\r\n    }\r\n    var l = obj.length;\r\n    if (l === +l) {\r\n        for (var i = 0; i < l; i++) {\r\n            fn.call(ctx, obj[i], i, obj);\r\n        }\r\n    } else {\r\n        for (var k in obj) {\r\n            if (hasOwn.call(obj, k)) {\r\n                fn.call(ctx, obj[k], k, obj);\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZm9yZWFjaC9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZm9yZWFjaC9pbmRleC5qcz9kZDEyIl0sInNvdXJjZXNDb250ZW50IjpbIlxyXG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcclxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZm9yRWFjaCAob2JqLCBmbiwgY3R4KSB7XHJcbiAgICBpZiAodG9TdHJpbmcuY2FsbChmbikgIT09ICdbb2JqZWN0IEZ1bmN0aW9uXScpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpdGVyYXRvciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcclxuICAgIH1cclxuICAgIHZhciBsID0gb2JqLmxlbmd0aDtcclxuICAgIGlmIChsID09PSArbCkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGZuLmNhbGwoY3R4LCBvYmpbaV0sIGksIG9iaik7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBmb3IgKHZhciBrIGluIG9iaikge1xyXG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwob2JqLCBrKSkge1xyXG4gICAgICAgICAgICAgICAgZm4uY2FsbChjdHgsIG9ialtrXSwgaywgb2JqKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/foreach/index.js\n");

/***/ }),

/***/ "./node_modules/function-bind/implementation.js":
/*!******************************************************!*\
  !*** ./node_modules/function-bind/implementation.js ***!
  \******************************************************/
/***/ (function(module) {

"use strict";
eval("\r\n\r\n/* eslint no-invalid-this: 1 */\r\n\r\nvar ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';\r\nvar slice = Array.prototype.slice;\r\nvar toStr = Object.prototype.toString;\r\nvar funcType = '[object Function]';\r\n\r\nmodule.exports = function bind(that) {\r\n    var target = this;\r\n    if (typeof target !== 'function' || toStr.call(target) !== funcType) {\r\n        throw new TypeError(ERROR_MESSAGE + target);\r\n    }\r\n    var args = slice.call(arguments, 1);\r\n\r\n    var bound;\r\n    var binder = function () {\r\n        if (this instanceof bound) {\r\n            var result = target.apply(\r\n                this,\r\n                args.concat(slice.call(arguments))\r\n            );\r\n            if (Object(result) === result) {\r\n                return result;\r\n            }\r\n            return this;\r\n        } else {\r\n            return target.apply(\r\n                that,\r\n                args.concat(slice.call(arguments))\r\n            );\r\n        }\r\n    };\r\n\r\n    var boundLength = Math.max(0, target.length - args.length);\r\n    var boundArgs = [];\r\n    for (var i = 0; i < boundLength; i++) {\r\n        boundArgs.push('$' + i);\r\n    }\r\n\r\n    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);\r\n\r\n    if (target.prototype) {\r\n        var Empty = function Empty() {};\r\n        Empty.prototype = target.prototype;\r\n        bound.prototype = new Empty();\r\n        Empty.prototype = null;\r\n    }\r\n\r\n    return bound;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZnVuY3Rpb24tYmluZC9pbXBsZW1lbnRhdGlvbi5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQSwrRUFBK0Usc0NBQXNDO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mdW5jdGlvbi1iaW5kL2ltcGxlbWVudGF0aW9uLmpzPzY3ZjUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyogZXNsaW50IG5vLWludmFsaWQtdGhpczogMSAqL1xyXG5cclxudmFyIEVSUk9SX01FU1NBR0UgPSAnRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgY2FsbGVkIG9uIGluY29tcGF0aWJsZSAnO1xyXG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XHJcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XHJcbnZhciBmdW5jVHlwZSA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpbmQodGhhdCkge1xyXG4gICAgdmFyIHRhcmdldCA9IHRoaXM7XHJcbiAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gJ2Z1bmN0aW9uJyB8fCB0b1N0ci5jYWxsKHRhcmdldCkgIT09IGZ1bmNUeXBlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihFUlJPUl9NRVNTQUdFICsgdGFyZ2V0KTtcclxuICAgIH1cclxuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG5cclxuICAgIHZhciBib3VuZDtcclxuICAgIHZhciBiaW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGFyZ2V0LmFwcGx5KFxyXG4gICAgICAgICAgICAgICAgdGhpcyxcclxuICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSlcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgaWYgKE9iamVjdChyZXN1bHQpID09PSByZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseShcclxuICAgICAgICAgICAgICAgIHRoYXQsXHJcbiAgICAgICAgICAgICAgICBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgYm91bmRMZW5ndGggPSBNYXRoLm1heCgwLCB0YXJnZXQubGVuZ3RoIC0gYXJncy5sZW5ndGgpO1xyXG4gICAgdmFyIGJvdW5kQXJncyA9IFtdO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3VuZExlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgYm91bmRBcmdzLnB1c2goJyQnICsgaSk7XHJcbiAgICB9XHJcblxyXG4gICAgYm91bmQgPSBGdW5jdGlvbignYmluZGVyJywgJ3JldHVybiBmdW5jdGlvbiAoJyArIGJvdW5kQXJncy5qb2luKCcsJykgKyAnKXsgcmV0dXJuIGJpbmRlci5hcHBseSh0aGlzLGFyZ3VtZW50cyk7IH0nKShiaW5kZXIpO1xyXG5cclxuICAgIGlmICh0YXJnZXQucHJvdG90eXBlKSB7XHJcbiAgICAgICAgdmFyIEVtcHR5ID0gZnVuY3Rpb24gRW1wdHkoKSB7fTtcclxuICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSB0YXJnZXQucHJvdG90eXBlO1xyXG4gICAgICAgIGJvdW5kLnByb3RvdHlwZSA9IG5ldyBFbXB0eSgpO1xyXG4gICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGJvdW5kO1xyXG59O1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/function-bind/implementation.js\n");

/***/ }),

/***/ "./node_modules/function-bind/index.js":
/*!*********************************************!*\
  !*** ./node_modules/function-bind/index.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar implementation = __webpack_require__(/*! ./implementation */ \"./node_modules/function-bind/implementation.js\");\r\n\r\nmodule.exports = Function.prototype.bind || implementation;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZnVuY3Rpb24tYmluZC9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EscUJBQXFCLG1CQUFPLENBQUMsd0VBQWtCO0FBQy9DO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2Z1bmN0aW9uLWJpbmQvaW5kZXguanM/ZjY1YSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIHx8IGltcGxlbWVudGF0aW9uO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/function-bind/index.js\n");

/***/ }),

/***/ "./node_modules/get-intrinsic/index.js":
/*!*********************************************!*\
  !*** ./node_modules/get-intrinsic/index.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar undefined;\r\n\r\nvar $SyntaxError = SyntaxError;\r\nvar $Function = Function;\r\nvar $TypeError = TypeError;\r\n\r\n// eslint-disable-next-line consistent-return\r\nvar getEvalledConstructor = function (expressionSyntax) {\r\n\ttry {\r\n\t\treturn $Function('\"use strict\"; return (' + expressionSyntax + ').constructor;')();\r\n\t} catch (e) {}\r\n};\r\n\r\nvar $gOPD = Object.getOwnPropertyDescriptor;\r\nif ($gOPD) {\r\n\ttry {\r\n\t\t$gOPD({}, '');\r\n\t} catch (e) {\r\n\t\t$gOPD = null; // this is IE 8, which has a broken gOPD\r\n\t}\r\n}\r\n\r\nvar throwTypeError = function () {\r\n\tthrow new $TypeError();\r\n};\r\nvar ThrowTypeError = $gOPD\r\n\t? (function () {\r\n\t\ttry {\r\n\t\t\t// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties\r\n\t\t\targuments.callee; // IE 8 does not throw here\r\n\t\t\treturn throwTypeError;\r\n\t\t} catch (calleeThrows) {\r\n\t\t\ttry {\r\n\t\t\t\t// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')\r\n\t\t\t\treturn $gOPD(arguments, 'callee').get;\r\n\t\t\t} catch (gOPDthrows) {\r\n\t\t\t\treturn throwTypeError;\r\n\t\t\t}\r\n\t\t}\r\n\t}())\r\n\t: throwTypeError;\r\n\r\nvar hasSymbols = __webpack_require__(/*! has-symbols */ \"./node_modules/has-symbols/index.js\")();\r\n\r\nvar getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto\r\n\r\nvar needsEval = {};\r\n\r\nvar TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);\r\n\r\nvar INTRINSICS = {\r\n\t'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,\r\n\t'%Array%': Array,\r\n\t'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,\r\n\t'%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,\r\n\t'%AsyncFromSyncIteratorPrototype%': undefined,\r\n\t'%AsyncFunction%': needsEval,\r\n\t'%AsyncGenerator%': needsEval,\r\n\t'%AsyncGeneratorFunction%': needsEval,\r\n\t'%AsyncIteratorPrototype%': needsEval,\r\n\t'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,\r\n\t'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,\r\n\t'%Boolean%': Boolean,\r\n\t'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,\r\n\t'%Date%': Date,\r\n\t'%decodeURI%': decodeURI,\r\n\t'%decodeURIComponent%': decodeURIComponent,\r\n\t'%encodeURI%': encodeURI,\r\n\t'%encodeURIComponent%': encodeURIComponent,\r\n\t'%Error%': Error,\r\n\t'%eval%': eval, // eslint-disable-line no-eval\r\n\t'%EvalError%': EvalError,\r\n\t'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,\r\n\t'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,\r\n\t'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,\r\n\t'%Function%': $Function,\r\n\t'%GeneratorFunction%': needsEval,\r\n\t'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,\r\n\t'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,\r\n\t'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,\r\n\t'%isFinite%': isFinite,\r\n\t'%isNaN%': isNaN,\r\n\t'%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,\r\n\t'%JSON%': typeof JSON === 'object' ? JSON : undefined,\r\n\t'%Map%': typeof Map === 'undefined' ? undefined : Map,\r\n\t'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),\r\n\t'%Math%': Math,\r\n\t'%Number%': Number,\r\n\t'%Object%': Object,\r\n\t'%parseFloat%': parseFloat,\r\n\t'%parseInt%': parseInt,\r\n\t'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,\r\n\t'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,\r\n\t'%RangeError%': RangeError,\r\n\t'%ReferenceError%': ReferenceError,\r\n\t'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,\r\n\t'%RegExp%': RegExp,\r\n\t'%Set%': typeof Set === 'undefined' ? undefined : Set,\r\n\t'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),\r\n\t'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,\r\n\t'%String%': String,\r\n\t'%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,\r\n\t'%Symbol%': hasSymbols ? Symbol : undefined,\r\n\t'%SyntaxError%': $SyntaxError,\r\n\t'%ThrowTypeError%': ThrowTypeError,\r\n\t'%TypedArray%': TypedArray,\r\n\t'%TypeError%': $TypeError,\r\n\t'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,\r\n\t'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,\r\n\t'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,\r\n\t'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,\r\n\t'%URIError%': URIError,\r\n\t'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,\r\n\t'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,\r\n\t'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet\r\n};\r\n\r\nvar doEval = function doEval(name) {\r\n\tvar value;\r\n\tif (name === '%AsyncFunction%') {\r\n\t\tvalue = getEvalledConstructor('async function () {}');\r\n\t} else if (name === '%GeneratorFunction%') {\r\n\t\tvalue = getEvalledConstructor('function* () {}');\r\n\t} else if (name === '%AsyncGeneratorFunction%') {\r\n\t\tvalue = getEvalledConstructor('async function* () {}');\r\n\t} else if (name === '%AsyncGenerator%') {\r\n\t\tvar fn = doEval('%AsyncGeneratorFunction%');\r\n\t\tif (fn) {\r\n\t\t\tvalue = fn.prototype;\r\n\t\t}\r\n\t} else if (name === '%AsyncIteratorPrototype%') {\r\n\t\tvar gen = doEval('%AsyncGenerator%');\r\n\t\tif (gen) {\r\n\t\t\tvalue = getProto(gen.prototype);\r\n\t\t}\r\n\t}\r\n\r\n\tINTRINSICS[name] = value;\r\n\r\n\treturn value;\r\n};\r\n\r\nvar LEGACY_ALIASES = {\r\n\t'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],\r\n\t'%ArrayPrototype%': ['Array', 'prototype'],\r\n\t'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],\r\n\t'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],\r\n\t'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],\r\n\t'%ArrayProto_values%': ['Array', 'prototype', 'values'],\r\n\t'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],\r\n\t'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],\r\n\t'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],\r\n\t'%BooleanPrototype%': ['Boolean', 'prototype'],\r\n\t'%DataViewPrototype%': ['DataView', 'prototype'],\r\n\t'%DatePrototype%': ['Date', 'prototype'],\r\n\t'%ErrorPrototype%': ['Error', 'prototype'],\r\n\t'%EvalErrorPrototype%': ['EvalError', 'prototype'],\r\n\t'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],\r\n\t'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],\r\n\t'%FunctionPrototype%': ['Function', 'prototype'],\r\n\t'%Generator%': ['GeneratorFunction', 'prototype'],\r\n\t'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],\r\n\t'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],\r\n\t'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],\r\n\t'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],\r\n\t'%JSONParse%': ['JSON', 'parse'],\r\n\t'%JSONStringify%': ['JSON', 'stringify'],\r\n\t'%MapPrototype%': ['Map', 'prototype'],\r\n\t'%NumberPrototype%': ['Number', 'prototype'],\r\n\t'%ObjectPrototype%': ['Object', 'prototype'],\r\n\t'%ObjProto_toString%': ['Object', 'prototype', 'toString'],\r\n\t'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],\r\n\t'%PromisePrototype%': ['Promise', 'prototype'],\r\n\t'%PromiseProto_then%': ['Promise', 'prototype', 'then'],\r\n\t'%Promise_all%': ['Promise', 'all'],\r\n\t'%Promise_reject%': ['Promise', 'reject'],\r\n\t'%Promise_resolve%': ['Promise', 'resolve'],\r\n\t'%RangeErrorPrototype%': ['RangeError', 'prototype'],\r\n\t'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],\r\n\t'%RegExpPrototype%': ['RegExp', 'prototype'],\r\n\t'%SetPrototype%': ['Set', 'prototype'],\r\n\t'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],\r\n\t'%StringPrototype%': ['String', 'prototype'],\r\n\t'%SymbolPrototype%': ['Symbol', 'prototype'],\r\n\t'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],\r\n\t'%TypedArrayPrototype%': ['TypedArray', 'prototype'],\r\n\t'%TypeErrorPrototype%': ['TypeError', 'prototype'],\r\n\t'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],\r\n\t'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],\r\n\t'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],\r\n\t'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],\r\n\t'%URIErrorPrototype%': ['URIError', 'prototype'],\r\n\t'%WeakMapPrototype%': ['WeakMap', 'prototype'],\r\n\t'%WeakSetPrototype%': ['WeakSet', 'prototype']\r\n};\r\n\r\nvar bind = __webpack_require__(/*! function-bind */ \"./node_modules/function-bind/index.js\");\r\nvar hasOwn = __webpack_require__(/*! has */ \"./node_modules/has/src/index.js\");\r\nvar $concat = bind.call(Function.call, Array.prototype.concat);\r\nvar $spliceApply = bind.call(Function.apply, Array.prototype.splice);\r\nvar $replace = bind.call(Function.call, String.prototype.replace);\r\nvar $strSlice = bind.call(Function.call, String.prototype.slice);\r\n\r\n/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */\r\nvar rePropName = /[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;\r\nvar reEscapeChar = /\\\\(\\\\)?/g; /** Used to match backslashes in property paths. */\r\nvar stringToPath = function stringToPath(string) {\r\n\tvar first = $strSlice(string, 0, 1);\r\n\tvar last = $strSlice(string, -1);\r\n\tif (first === '%' && last !== '%') {\r\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected closing `%`');\r\n\t} else if (last === '%' && first !== '%') {\r\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected opening `%`');\r\n\t}\r\n\tvar result = [];\r\n\t$replace(string, rePropName, function (match, number, quote, subString) {\r\n\t\tresult[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;\r\n\t});\r\n\treturn result;\r\n};\r\n/* end adaptation */\r\n\r\nvar getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {\r\n\tvar intrinsicName = name;\r\n\tvar alias;\r\n\tif (hasOwn(LEGACY_ALIASES, intrinsicName)) {\r\n\t\talias = LEGACY_ALIASES[intrinsicName];\r\n\t\tintrinsicName = '%' + alias[0] + '%';\r\n\t}\r\n\r\n\tif (hasOwn(INTRINSICS, intrinsicName)) {\r\n\t\tvar value = INTRINSICS[intrinsicName];\r\n\t\tif (value === needsEval) {\r\n\t\t\tvalue = doEval(intrinsicName);\r\n\t\t}\r\n\t\tif (typeof value === 'undefined' && !allowMissing) {\r\n\t\t\tthrow new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\talias: alias,\r\n\t\t\tname: intrinsicName,\r\n\t\t\tvalue: value\r\n\t\t};\r\n\t}\r\n\r\n\tthrow new $SyntaxError('intrinsic ' + name + ' does not exist!');\r\n};\r\n\r\nmodule.exports = function GetIntrinsic(name, allowMissing) {\r\n\tif (typeof name !== 'string' || name.length === 0) {\r\n\t\tthrow new $TypeError('intrinsic name must be a non-empty string');\r\n\t}\r\n\tif (arguments.length > 1 && typeof allowMissing !== 'boolean') {\r\n\t\tthrow new $TypeError('\"allowMissing\" argument must be a boolean');\r\n\t}\r\n\r\n\tvar parts = stringToPath(name);\r\n\tvar intrinsicBaseName = parts.length > 0 ? parts[0] : '';\r\n\r\n\tvar intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);\r\n\tvar intrinsicRealName = intrinsic.name;\r\n\tvar value = intrinsic.value;\r\n\tvar skipFurtherCaching = false;\r\n\r\n\tvar alias = intrinsic.alias;\r\n\tif (alias) {\r\n\t\tintrinsicBaseName = alias[0];\r\n\t\t$spliceApply(parts, $concat([0, 1], alias));\r\n\t}\r\n\r\n\tfor (var i = 1, isOwn = true; i < parts.length; i += 1) {\r\n\t\tvar part = parts[i];\r\n\t\tvar first = $strSlice(part, 0, 1);\r\n\t\tvar last = $strSlice(part, -1);\r\n\t\tif (\r\n\t\t\t(\r\n\t\t\t\t(first === '\"' || first === \"'\" || first === '`')\r\n\t\t\t\t|| (last === '\"' || last === \"'\" || last === '`')\r\n\t\t\t)\r\n\t\t\t&& first !== last\r\n\t\t) {\r\n\t\t\tthrow new $SyntaxError('property names with quotes must have matching quotes');\r\n\t\t}\r\n\t\tif (part === 'constructor' || !isOwn) {\r\n\t\t\tskipFurtherCaching = true;\r\n\t\t}\r\n\r\n\t\tintrinsicBaseName += '.' + part;\r\n\t\tintrinsicRealName = '%' + intrinsicBaseName + '%';\r\n\r\n\t\tif (hasOwn(INTRINSICS, intrinsicRealName)) {\r\n\t\t\tvalue = INTRINSICS[intrinsicRealName];\r\n\t\t} else if (value != null) {\r\n\t\t\tif (!(part in value)) {\r\n\t\t\t\tif (!allowMissing) {\r\n\t\t\t\t\tthrow new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');\r\n\t\t\t\t}\r\n\t\t\t\treturn void undefined;\r\n\t\t\t}\r\n\t\t\tif ($gOPD && (i + 1) >= parts.length) {\r\n\t\t\t\tvar desc = $gOPD(value, part);\r\n\t\t\t\tisOwn = !!desc;\r\n\r\n\t\t\t\t// By convention, when a data property is converted to an accessor\r\n\t\t\t\t// property to emulate a data property that does not suffer from\r\n\t\t\t\t// the override mistake, that accessor's getter is marked with\r\n\t\t\t\t// an `originalValue` property. Here, when we detect this, we\r\n\t\t\t\t// uphold the illusion by pretending to see that original data\r\n\t\t\t\t// property, i.e., returning the value rather than the getter\r\n\t\t\t\t// itself.\r\n\t\t\t\tif (isOwn && 'get' in desc && !('originalValue' in desc.get)) {\r\n\t\t\t\t\tvalue = desc.get;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvalue = value[part];\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tisOwn = hasOwn(value, part);\r\n\t\t\t\tvalue = value[part];\r\n\t\t\t}\r\n\r\n\t\t\tif (isOwn && !skipFurtherCaching) {\r\n\t\t\t\tINTRINSICS[intrinsicRealName] = value;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn value;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2V0LWludHJpbnNpYy9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDhDQUE4QztBQUNoRixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixHQUFHO0FBQ0gsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLHdEQUFhO0FBQ3RDO0FBQ0EsdURBQXVELHVCQUF1QjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQsR0FBRztBQUNILGdEQUFnRDtBQUNoRCxHQUFHO0FBQ0gsc0RBQXNEO0FBQ3RELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBTyxDQUFDLDREQUFlO0FBQ2xDLGFBQWEsbUJBQU8sQ0FBQyw0Q0FBSztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrQkFBa0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZ2V0LWludHJpbnNpYy9pbmRleC5qcz84NDIxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciB1bmRlZmluZWQ7XHJcblxyXG52YXIgJFN5bnRheEVycm9yID0gU3ludGF4RXJyb3I7XHJcbnZhciAkRnVuY3Rpb24gPSBGdW5jdGlvbjtcclxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XHJcblxyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cclxudmFyIGdldEV2YWxsZWRDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChleHByZXNzaW9uU3ludGF4KSB7XHJcblx0dHJ5IHtcclxuXHRcdHJldHVybiAkRnVuY3Rpb24oJ1widXNlIHN0cmljdFwiOyByZXR1cm4gKCcgKyBleHByZXNzaW9uU3ludGF4ICsgJykuY29uc3RydWN0b3I7JykoKTtcclxuXHR9IGNhdGNoIChlKSB7fVxyXG59O1xyXG5cclxudmFyICRnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcclxuaWYgKCRnT1BEKSB7XHJcblx0dHJ5IHtcclxuXHRcdCRnT1BEKHt9LCAnJyk7XHJcblx0fSBjYXRjaCAoZSkge1xyXG5cdFx0JGdPUEQgPSBudWxsOyAvLyB0aGlzIGlzIElFIDgsIHdoaWNoIGhhcyBhIGJyb2tlbiBnT1BEXHJcblx0fVxyXG59XHJcblxyXG52YXIgdGhyb3dUeXBlRXJyb3IgPSBmdW5jdGlvbiAoKSB7XHJcblx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoKTtcclxufTtcclxudmFyIFRocm93VHlwZUVycm9yID0gJGdPUERcclxuXHQ/IChmdW5jdGlvbiAoKSB7XHJcblx0XHR0cnkge1xyXG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zLCBuby1jYWxsZXIsIG5vLXJlc3RyaWN0ZWQtcHJvcGVydGllc1xyXG5cdFx0XHRhcmd1bWVudHMuY2FsbGVlOyAvLyBJRSA4IGRvZXMgbm90IHRocm93IGhlcmVcclxuXHRcdFx0cmV0dXJuIHRocm93VHlwZUVycm9yO1xyXG5cdFx0fSBjYXRjaCAoY2FsbGVlVGhyb3dzKSB7XHJcblx0XHRcdHRyeSB7XHJcblx0XHRcdFx0Ly8gSUUgOCB0aHJvd3Mgb24gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihhcmd1bWVudHMsICcnKVxyXG5cdFx0XHRcdHJldHVybiAkZ09QRChhcmd1bWVudHMsICdjYWxsZWUnKS5nZXQ7XHJcblx0XHRcdH0gY2F0Y2ggKGdPUER0aHJvd3MpIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhyb3dUeXBlRXJyb3I7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9KCkpXHJcblx0OiB0aHJvd1R5cGVFcnJvcjtcclxuXHJcbnZhciBoYXNTeW1ib2xzID0gcmVxdWlyZSgnaGFzLXN5bWJvbHMnKSgpO1xyXG5cclxudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4Ll9fcHJvdG9fXzsgfTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm90b1xyXG5cclxudmFyIG5lZWRzRXZhbCA9IHt9O1xyXG5cclxudmFyIFR5cGVkQXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBnZXRQcm90byhVaW50OEFycmF5KTtcclxuXHJcbnZhciBJTlRSSU5TSUNTID0ge1xyXG5cdCclQWdncmVnYXRlRXJyb3IlJzogdHlwZW9mIEFnZ3JlZ2F0ZUVycm9yID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEFnZ3JlZ2F0ZUVycm9yLFxyXG5cdCclQXJyYXklJzogQXJyYXksXHJcblx0JyVBcnJheUJ1ZmZlciUnOiB0eXBlb2YgQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQXJyYXlCdWZmZXIsXHJcblx0JyVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgPyBnZXRQcm90byhbXVtTeW1ib2wuaXRlcmF0b3JdKCkpIDogdW5kZWZpbmVkLFxyXG5cdCclQXN5bmNGcm9tU3luY0l0ZXJhdG9yUHJvdG90eXBlJSc6IHVuZGVmaW5lZCxcclxuXHQnJUFzeW5jRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxyXG5cdCclQXN5bmNHZW5lcmF0b3IlJzogbmVlZHNFdmFsLFxyXG5cdCclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXHJcblx0JyVBc3luY0l0ZXJhdG9yUHJvdG90eXBlJSc6IG5lZWRzRXZhbCxcclxuXHQnJUF0b21pY3MlJzogdHlwZW9mIEF0b21pY3MgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQXRvbWljcyxcclxuXHQnJUJpZ0ludCUnOiB0eXBlb2YgQmlnSW50ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEJpZ0ludCxcclxuXHQnJUJvb2xlYW4lJzogQm9vbGVhbixcclxuXHQnJURhdGFWaWV3JSc6IHR5cGVvZiBEYXRhVmlldyA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBEYXRhVmlldyxcclxuXHQnJURhdGUlJzogRGF0ZSxcclxuXHQnJWRlY29kZVVSSSUnOiBkZWNvZGVVUkksXHJcblx0JyVkZWNvZGVVUklDb21wb25lbnQlJzogZGVjb2RlVVJJQ29tcG9uZW50LFxyXG5cdCclZW5jb2RlVVJJJSc6IGVuY29kZVVSSSxcclxuXHQnJWVuY29kZVVSSUNvbXBvbmVudCUnOiBlbmNvZGVVUklDb21wb25lbnQsXHJcblx0JyVFcnJvciUnOiBFcnJvcixcclxuXHQnJWV2YWwlJzogZXZhbCwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1ldmFsXHJcblx0JyVFdmFsRXJyb3IlJzogRXZhbEVycm9yLFxyXG5cdCclRmxvYXQzMkFycmF5JSc6IHR5cGVvZiBGbG9hdDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmxvYXQzMkFycmF5LFxyXG5cdCclRmxvYXQ2NEFycmF5JSc6IHR5cGVvZiBGbG9hdDY0QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmxvYXQ2NEFycmF5LFxyXG5cdCclRmluYWxpemF0aW9uUmVnaXN0cnklJzogdHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZpbmFsaXphdGlvblJlZ2lzdHJ5LFxyXG5cdCclRnVuY3Rpb24lJzogJEZ1bmN0aW9uLFxyXG5cdCclR2VuZXJhdG9yRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxyXG5cdCclSW50OEFycmF5JSc6IHR5cGVvZiBJbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50OEFycmF5LFxyXG5cdCclSW50MTZBcnJheSUnOiB0eXBlb2YgSW50MTZBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQxNkFycmF5LFxyXG5cdCclSW50MzJBcnJheSUnOiB0eXBlb2YgSW50MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQzMkFycmF5LFxyXG5cdCclaXNGaW5pdGUlJzogaXNGaW5pdGUsXHJcblx0JyVpc05hTiUnOiBpc05hTixcclxuXHQnJUl0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgPyBnZXRQcm90byhnZXRQcm90byhbXVtTeW1ib2wuaXRlcmF0b3JdKCkpKSA6IHVuZGVmaW5lZCxcclxuXHQnJUpTT04lJzogdHlwZW9mIEpTT04gPT09ICdvYmplY3QnID8gSlNPTiA6IHVuZGVmaW5lZCxcclxuXHQnJU1hcCUnOiB0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IE1hcCxcclxuXHQnJU1hcEl0ZXJhdG9yUHJvdG90eXBlJSc6IHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNTeW1ib2xzID8gdW5kZWZpbmVkIDogZ2V0UHJvdG8obmV3IE1hcCgpW1N5bWJvbC5pdGVyYXRvcl0oKSksXHJcblx0JyVNYXRoJSc6IE1hdGgsXHJcblx0JyVOdW1iZXIlJzogTnVtYmVyLFxyXG5cdCclT2JqZWN0JSc6IE9iamVjdCxcclxuXHQnJXBhcnNlRmxvYXQlJzogcGFyc2VGbG9hdCxcclxuXHQnJXBhcnNlSW50JSc6IHBhcnNlSW50LFxyXG5cdCclUHJvbWlzZSUnOiB0eXBlb2YgUHJvbWlzZSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBQcm9taXNlLFxyXG5cdCclUHJveHklJzogdHlwZW9mIFByb3h5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFByb3h5LFxyXG5cdCclUmFuZ2VFcnJvciUnOiBSYW5nZUVycm9yLFxyXG5cdCclUmVmZXJlbmNlRXJyb3IlJzogUmVmZXJlbmNlRXJyb3IsXHJcblx0JyVSZWZsZWN0JSc6IHR5cGVvZiBSZWZsZWN0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFJlZmxlY3QsXHJcblx0JyVSZWdFeHAlJzogUmVnRXhwLFxyXG5cdCclU2V0JSc6IHR5cGVvZiBTZXQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogU2V0LFxyXG5cdCclU2V0SXRlcmF0b3JQcm90b3R5cGUlJzogdHlwZW9mIFNldCA9PT0gJ3VuZGVmaW5lZCcgfHwgIWhhc1N5bWJvbHMgPyB1bmRlZmluZWQgOiBnZXRQcm90byhuZXcgU2V0KClbU3ltYm9sLml0ZXJhdG9yXSgpKSxcclxuXHQnJVNoYXJlZEFycmF5QnVmZmVyJSc6IHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBTaGFyZWRBcnJheUJ1ZmZlcixcclxuXHQnJVN0cmluZyUnOiBTdHJpbmcsXHJcblx0JyVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzID8gZ2V0UHJvdG8oJydbU3ltYm9sLml0ZXJhdG9yXSgpKSA6IHVuZGVmaW5lZCxcclxuXHQnJVN5bWJvbCUnOiBoYXNTeW1ib2xzID8gU3ltYm9sIDogdW5kZWZpbmVkLFxyXG5cdCclU3ludGF4RXJyb3IlJzogJFN5bnRheEVycm9yLFxyXG5cdCclVGhyb3dUeXBlRXJyb3IlJzogVGhyb3dUeXBlRXJyb3IsXHJcblx0JyVUeXBlZEFycmF5JSc6IFR5cGVkQXJyYXksXHJcblx0JyVUeXBlRXJyb3IlJzogJFR5cGVFcnJvcixcclxuXHQnJVVpbnQ4QXJyYXklJzogdHlwZW9mIFVpbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDhBcnJheSxcclxuXHQnJVVpbnQ4Q2xhbXBlZEFycmF5JSc6IHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50OENsYW1wZWRBcnJheSxcclxuXHQnJVVpbnQxNkFycmF5JSc6IHR5cGVvZiBVaW50MTZBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50MTZBcnJheSxcclxuXHQnJVVpbnQzMkFycmF5JSc6IHR5cGVvZiBVaW50MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50MzJBcnJheSxcclxuXHQnJVVSSUVycm9yJSc6IFVSSUVycm9yLFxyXG5cdCclV2Vha01hcCUnOiB0eXBlb2YgV2Vha01hcCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrTWFwLFxyXG5cdCclV2Vha1JlZiUnOiB0eXBlb2YgV2Vha1JlZiA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrUmVmLFxyXG5cdCclV2Vha1NldCUnOiB0eXBlb2YgV2Vha1NldCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrU2V0XHJcbn07XHJcblxyXG52YXIgZG9FdmFsID0gZnVuY3Rpb24gZG9FdmFsKG5hbWUpIHtcclxuXHR2YXIgdmFsdWU7XHJcblx0aWYgKG5hbWUgPT09ICclQXN5bmNGdW5jdGlvbiUnKSB7XHJcblx0XHR2YWx1ZSA9IGdldEV2YWxsZWRDb25zdHJ1Y3RvcignYXN5bmMgZnVuY3Rpb24gKCkge30nKTtcclxuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclR2VuZXJhdG9yRnVuY3Rpb24lJykge1xyXG5cdFx0dmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2Z1bmN0aW9uKiAoKSB7fScpO1xyXG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJScpIHtcclxuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdhc3luYyBmdW5jdGlvbiogKCkge30nKTtcclxuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNHZW5lcmF0b3IlJykge1xyXG5cdFx0dmFyIGZuID0gZG9FdmFsKCclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnKTtcclxuXHRcdGlmIChmbikge1xyXG5cdFx0XHR2YWx1ZSA9IGZuLnByb3RvdHlwZTtcclxuXHRcdH1cclxuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNJdGVyYXRvclByb3RvdHlwZSUnKSB7XHJcblx0XHR2YXIgZ2VuID0gZG9FdmFsKCclQXN5bmNHZW5lcmF0b3IlJyk7XHJcblx0XHRpZiAoZ2VuKSB7XHJcblx0XHRcdHZhbHVlID0gZ2V0UHJvdG8oZ2VuLnByb3RvdHlwZSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRJTlRSSU5TSUNTW25hbWVdID0gdmFsdWU7XHJcblxyXG5cdHJldHVybiB2YWx1ZTtcclxufTtcclxuXHJcbnZhciBMRUdBQ1lfQUxJQVNFUyA9IHtcclxuXHQnJUFycmF5QnVmZmVyUHJvdG90eXBlJSc6IFsnQXJyYXlCdWZmZXInLCAncHJvdG90eXBlJ10sXHJcblx0JyVBcnJheVByb3RvdHlwZSUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZSddLFxyXG5cdCclQXJyYXlQcm90b19lbnRyaWVzJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2VudHJpZXMnXSxcclxuXHQnJUFycmF5UHJvdG9fZm9yRWFjaCUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICdmb3JFYWNoJ10sXHJcblx0JyVBcnJheVByb3RvX2tleXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAna2V5cyddLFxyXG5cdCclQXJyYXlQcm90b192YWx1ZXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAndmFsdWVzJ10sXHJcblx0JyVBc3luY0Z1bmN0aW9uUHJvdG90eXBlJSc6IFsnQXN5bmNGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcclxuXHQnJUFzeW5jR2VuZXJhdG9yJSc6IFsnQXN5bmNHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcclxuXHQnJUFzeW5jR2VuZXJhdG9yUHJvdG90eXBlJSc6IFsnQXN5bmNHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnLCAncHJvdG90eXBlJ10sXHJcblx0JyVCb29sZWFuUHJvdG90eXBlJSc6IFsnQm9vbGVhbicsICdwcm90b3R5cGUnXSxcclxuXHQnJURhdGFWaWV3UHJvdG90eXBlJSc6IFsnRGF0YVZpZXcnLCAncHJvdG90eXBlJ10sXHJcblx0JyVEYXRlUHJvdG90eXBlJSc6IFsnRGF0ZScsICdwcm90b3R5cGUnXSxcclxuXHQnJUVycm9yUHJvdG90eXBlJSc6IFsnRXJyb3InLCAncHJvdG90eXBlJ10sXHJcblx0JyVFdmFsRXJyb3JQcm90b3R5cGUlJzogWydFdmFsRXJyb3InLCAncHJvdG90eXBlJ10sXHJcblx0JyVGbG9hdDMyQXJyYXlQcm90b3R5cGUlJzogWydGbG9hdDMyQXJyYXknLCAncHJvdG90eXBlJ10sXHJcblx0JyVGbG9hdDY0QXJyYXlQcm90b3R5cGUlJzogWydGbG9hdDY0QXJyYXknLCAncHJvdG90eXBlJ10sXHJcblx0JyVGdW5jdGlvblByb3RvdHlwZSUnOiBbJ0Z1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxyXG5cdCclR2VuZXJhdG9yJSc6IFsnR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXHJcblx0JyVHZW5lcmF0b3JQcm90b3R5cGUlJzogWydHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnLCAncHJvdG90eXBlJ10sXHJcblx0JyVJbnQ4QXJyYXlQcm90b3R5cGUlJzogWydJbnQ4QXJyYXknLCAncHJvdG90eXBlJ10sXHJcblx0JyVJbnQxNkFycmF5UHJvdG90eXBlJSc6IFsnSW50MTZBcnJheScsICdwcm90b3R5cGUnXSxcclxuXHQnJUludDMyQXJyYXlQcm90b3R5cGUlJzogWydJbnQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxyXG5cdCclSlNPTlBhcnNlJSc6IFsnSlNPTicsICdwYXJzZSddLFxyXG5cdCclSlNPTlN0cmluZ2lmeSUnOiBbJ0pTT04nLCAnc3RyaW5naWZ5J10sXHJcblx0JyVNYXBQcm90b3R5cGUlJzogWydNYXAnLCAncHJvdG90eXBlJ10sXHJcblx0JyVOdW1iZXJQcm90b3R5cGUlJzogWydOdW1iZXInLCAncHJvdG90eXBlJ10sXHJcblx0JyVPYmplY3RQcm90b3R5cGUlJzogWydPYmplY3QnLCAncHJvdG90eXBlJ10sXHJcblx0JyVPYmpQcm90b190b1N0cmluZyUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnLCAndG9TdHJpbmcnXSxcclxuXHQnJU9ialByb3RvX3ZhbHVlT2YlJzogWydPYmplY3QnLCAncHJvdG90eXBlJywgJ3ZhbHVlT2YnXSxcclxuXHQnJVByb21pc2VQcm90b3R5cGUlJzogWydQcm9taXNlJywgJ3Byb3RvdHlwZSddLFxyXG5cdCclUHJvbWlzZVByb3RvX3RoZW4lJzogWydQcm9taXNlJywgJ3Byb3RvdHlwZScsICd0aGVuJ10sXHJcblx0JyVQcm9taXNlX2FsbCUnOiBbJ1Byb21pc2UnLCAnYWxsJ10sXHJcblx0JyVQcm9taXNlX3JlamVjdCUnOiBbJ1Byb21pc2UnLCAncmVqZWN0J10sXHJcblx0JyVQcm9taXNlX3Jlc29sdmUlJzogWydQcm9taXNlJywgJ3Jlc29sdmUnXSxcclxuXHQnJVJhbmdlRXJyb3JQcm90b3R5cGUlJzogWydSYW5nZUVycm9yJywgJ3Byb3RvdHlwZSddLFxyXG5cdCclUmVmZXJlbmNlRXJyb3JQcm90b3R5cGUlJzogWydSZWZlcmVuY2VFcnJvcicsICdwcm90b3R5cGUnXSxcclxuXHQnJVJlZ0V4cFByb3RvdHlwZSUnOiBbJ1JlZ0V4cCcsICdwcm90b3R5cGUnXSxcclxuXHQnJVNldFByb3RvdHlwZSUnOiBbJ1NldCcsICdwcm90b3R5cGUnXSxcclxuXHQnJVNoYXJlZEFycmF5QnVmZmVyUHJvdG90eXBlJSc6IFsnU2hhcmVkQXJyYXlCdWZmZXInLCAncHJvdG90eXBlJ10sXHJcblx0JyVTdHJpbmdQcm90b3R5cGUlJzogWydTdHJpbmcnLCAncHJvdG90eXBlJ10sXHJcblx0JyVTeW1ib2xQcm90b3R5cGUlJzogWydTeW1ib2wnLCAncHJvdG90eXBlJ10sXHJcblx0JyVTeW50YXhFcnJvclByb3RvdHlwZSUnOiBbJ1N5bnRheEVycm9yJywgJ3Byb3RvdHlwZSddLFxyXG5cdCclVHlwZWRBcnJheVByb3RvdHlwZSUnOiBbJ1R5cGVkQXJyYXknLCAncHJvdG90eXBlJ10sXHJcblx0JyVUeXBlRXJyb3JQcm90b3R5cGUlJzogWydUeXBlRXJyb3InLCAncHJvdG90eXBlJ10sXHJcblx0JyVVaW50OEFycmF5UHJvdG90eXBlJSc6IFsnVWludDhBcnJheScsICdwcm90b3R5cGUnXSxcclxuXHQnJVVpbnQ4Q2xhbXBlZEFycmF5UHJvdG90eXBlJSc6IFsnVWludDhDbGFtcGVkQXJyYXknLCAncHJvdG90eXBlJ10sXHJcblx0JyVVaW50MTZBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQxNkFycmF5JywgJ3Byb3RvdHlwZSddLFxyXG5cdCclVWludDMyQXJyYXlQcm90b3R5cGUlJzogWydVaW50MzJBcnJheScsICdwcm90b3R5cGUnXSxcclxuXHQnJVVSSUVycm9yUHJvdG90eXBlJSc6IFsnVVJJRXJyb3InLCAncHJvdG90eXBlJ10sXHJcblx0JyVXZWFrTWFwUHJvdG90eXBlJSc6IFsnV2Vha01hcCcsICdwcm90b3R5cGUnXSxcclxuXHQnJVdlYWtTZXRQcm90b3R5cGUlJzogWydXZWFrU2V0JywgJ3Byb3RvdHlwZSddXHJcbn07XHJcblxyXG52YXIgYmluZCA9IHJlcXVpcmUoJ2Z1bmN0aW9uLWJpbmQnKTtcclxudmFyIGhhc093biA9IHJlcXVpcmUoJ2hhcycpO1xyXG52YXIgJGNvbmNhdCA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBBcnJheS5wcm90b3R5cGUuY29uY2F0KTtcclxudmFyICRzcGxpY2VBcHBseSA9IGJpbmQuY2FsbChGdW5jdGlvbi5hcHBseSwgQXJyYXkucHJvdG90eXBlLnNwbGljZSk7XHJcbnZhciAkcmVwbGFjZSA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UpO1xyXG52YXIgJHN0clNsaWNlID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIFN0cmluZy5wcm90b3R5cGUuc2xpY2UpO1xyXG5cclxuLyogYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9sb2Rhc2gvbG9kYXNoL2Jsb2IvNC4xNy4xNS9kaXN0L2xvZGFzaC5qcyNMNjczNS1MNjc0NCAqL1xyXG52YXIgcmVQcm9wTmFtZSA9IC9bXiUuW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JSQpKS9nO1xyXG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7IC8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xyXG52YXIgc3RyaW5nVG9QYXRoID0gZnVuY3Rpb24gc3RyaW5nVG9QYXRoKHN0cmluZykge1xyXG5cdHZhciBmaXJzdCA9ICRzdHJTbGljZShzdHJpbmcsIDAsIDEpO1xyXG5cdHZhciBsYXN0ID0gJHN0clNsaWNlKHN0cmluZywgLTEpO1xyXG5cdGlmIChmaXJzdCA9PT0gJyUnICYmIGxhc3QgIT09ICclJykge1xyXG5cdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignaW52YWxpZCBpbnRyaW5zaWMgc3ludGF4LCBleHBlY3RlZCBjbG9zaW5nIGAlYCcpO1xyXG5cdH0gZWxzZSBpZiAobGFzdCA9PT0gJyUnICYmIGZpcnN0ICE9PSAnJScpIHtcclxuXHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2ludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgb3BlbmluZyBgJWAnKTtcclxuXHR9XHJcblx0dmFyIHJlc3VsdCA9IFtdO1xyXG5cdCRyZXBsYWNlKHN0cmluZywgcmVQcm9wTmFtZSwgZnVuY3Rpb24gKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcclxuXHRcdHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHF1b3RlID8gJHJlcGxhY2Uoc3ViU3RyaW5nLCByZUVzY2FwZUNoYXIsICckMScpIDogbnVtYmVyIHx8IG1hdGNoO1xyXG5cdH0pO1xyXG5cdHJldHVybiByZXN1bHQ7XHJcbn07XHJcbi8qIGVuZCBhZGFwdGF0aW9uICovXHJcblxyXG52YXIgZ2V0QmFzZUludHJpbnNpYyA9IGZ1bmN0aW9uIGdldEJhc2VJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XHJcblx0dmFyIGludHJpbnNpY05hbWUgPSBuYW1lO1xyXG5cdHZhciBhbGlhcztcclxuXHRpZiAoaGFzT3duKExFR0FDWV9BTElBU0VTLCBpbnRyaW5zaWNOYW1lKSkge1xyXG5cdFx0YWxpYXMgPSBMRUdBQ1lfQUxJQVNFU1tpbnRyaW5zaWNOYW1lXTtcclxuXHRcdGludHJpbnNpY05hbWUgPSAnJScgKyBhbGlhc1swXSArICclJztcclxuXHR9XHJcblxyXG5cdGlmIChoYXNPd24oSU5UUklOU0lDUywgaW50cmluc2ljTmFtZSkpIHtcclxuXHRcdHZhciB2YWx1ZSA9IElOVFJJTlNJQ1NbaW50cmluc2ljTmFtZV07XHJcblx0XHRpZiAodmFsdWUgPT09IG5lZWRzRXZhbCkge1xyXG5cdFx0XHR2YWx1ZSA9IGRvRXZhbChpbnRyaW5zaWNOYW1lKTtcclxuXHRcdH1cclxuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnICYmICFhbGxvd01pc3NpbmcpIHtcclxuXHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2ludHJpbnNpYyAnICsgbmFtZSArICcgZXhpc3RzLCBidXQgaXMgbm90IGF2YWlsYWJsZS4gUGxlYXNlIGZpbGUgYW4gaXNzdWUhJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0YWxpYXM6IGFsaWFzLFxyXG5cdFx0XHRuYW1lOiBpbnRyaW5zaWNOYW1lLFxyXG5cdFx0XHR2YWx1ZTogdmFsdWVcclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdpbnRyaW5zaWMgJyArIG5hbWUgKyAnIGRvZXMgbm90IGV4aXN0IScpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBHZXRJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XHJcblx0aWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyB8fCBuYW1lLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2ludHJpbnNpYyBuYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XHJcblx0fVxyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB0eXBlb2YgYWxsb3dNaXNzaW5nICE9PSAnYm9vbGVhbicpIHtcclxuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdcImFsbG93TWlzc2luZ1wiIGFyZ3VtZW50IG11c3QgYmUgYSBib29sZWFuJyk7XHJcblx0fVxyXG5cclxuXHR2YXIgcGFydHMgPSBzdHJpbmdUb1BhdGgobmFtZSk7XHJcblx0dmFyIGludHJpbnNpY0Jhc2VOYW1lID0gcGFydHMubGVuZ3RoID4gMCA/IHBhcnRzWzBdIDogJyc7XHJcblxyXG5cdHZhciBpbnRyaW5zaWMgPSBnZXRCYXNlSW50cmluc2ljKCclJyArIGludHJpbnNpY0Jhc2VOYW1lICsgJyUnLCBhbGxvd01pc3NpbmcpO1xyXG5cdHZhciBpbnRyaW5zaWNSZWFsTmFtZSA9IGludHJpbnNpYy5uYW1lO1xyXG5cdHZhciB2YWx1ZSA9IGludHJpbnNpYy52YWx1ZTtcclxuXHR2YXIgc2tpcEZ1cnRoZXJDYWNoaW5nID0gZmFsc2U7XHJcblxyXG5cdHZhciBhbGlhcyA9IGludHJpbnNpYy5hbGlhcztcclxuXHRpZiAoYWxpYXMpIHtcclxuXHRcdGludHJpbnNpY0Jhc2VOYW1lID0gYWxpYXNbMF07XHJcblx0XHQkc3BsaWNlQXBwbHkocGFydHMsICRjb25jYXQoWzAsIDFdLCBhbGlhcykpO1xyXG5cdH1cclxuXHJcblx0Zm9yICh2YXIgaSA9IDEsIGlzT3duID0gdHJ1ZTsgaSA8IHBhcnRzLmxlbmd0aDsgaSArPSAxKSB7XHJcblx0XHR2YXIgcGFydCA9IHBhcnRzW2ldO1xyXG5cdFx0dmFyIGZpcnN0ID0gJHN0clNsaWNlKHBhcnQsIDAsIDEpO1xyXG5cdFx0dmFyIGxhc3QgPSAkc3RyU2xpY2UocGFydCwgLTEpO1xyXG5cdFx0aWYgKFxyXG5cdFx0XHQoXHJcblx0XHRcdFx0KGZpcnN0ID09PSAnXCInIHx8IGZpcnN0ID09PSBcIidcIiB8fCBmaXJzdCA9PT0gJ2AnKVxyXG5cdFx0XHRcdHx8IChsYXN0ID09PSAnXCInIHx8IGxhc3QgPT09IFwiJ1wiIHx8IGxhc3QgPT09ICdgJylcclxuXHRcdFx0KVxyXG5cdFx0XHQmJiBmaXJzdCAhPT0gbGFzdFxyXG5cdFx0KSB7XHJcblx0XHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ3Byb3BlcnR5IG5hbWVzIHdpdGggcXVvdGVzIG11c3QgaGF2ZSBtYXRjaGluZyBxdW90ZXMnKTtcclxuXHRcdH1cclxuXHRcdGlmIChwYXJ0ID09PSAnY29uc3RydWN0b3InIHx8ICFpc093bikge1xyXG5cdFx0XHRza2lwRnVydGhlckNhY2hpbmcgPSB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGludHJpbnNpY0Jhc2VOYW1lICs9ICcuJyArIHBhcnQ7XHJcblx0XHRpbnRyaW5zaWNSZWFsTmFtZSA9ICclJyArIGludHJpbnNpY0Jhc2VOYW1lICsgJyUnO1xyXG5cclxuXHRcdGlmIChoYXNPd24oSU5UUklOU0lDUywgaW50cmluc2ljUmVhbE5hbWUpKSB7XHJcblx0XHRcdHZhbHVlID0gSU5UUklOU0lDU1tpbnRyaW5zaWNSZWFsTmFtZV07XHJcblx0XHR9IGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcclxuXHRcdFx0aWYgKCEocGFydCBpbiB2YWx1ZSkpIHtcclxuXHRcdFx0XHRpZiAoIWFsbG93TWlzc2luZykge1xyXG5cdFx0XHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2Jhc2UgaW50cmluc2ljIGZvciAnICsgbmFtZSArICcgZXhpc3RzLCBidXQgdGhlIHByb3BlcnR5IGlzIG5vdCBhdmFpbGFibGUuJyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiB2b2lkIHVuZGVmaW5lZDtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoJGdPUEQgJiYgKGkgKyAxKSA+PSBwYXJ0cy5sZW5ndGgpIHtcclxuXHRcdFx0XHR2YXIgZGVzYyA9ICRnT1BEKHZhbHVlLCBwYXJ0KTtcclxuXHRcdFx0XHRpc093biA9ICEhZGVzYztcclxuXHJcblx0XHRcdFx0Ly8gQnkgY29udmVudGlvbiwgd2hlbiBhIGRhdGEgcHJvcGVydHkgaXMgY29udmVydGVkIHRvIGFuIGFjY2Vzc29yXHJcblx0XHRcdFx0Ly8gcHJvcGVydHkgdG8gZW11bGF0ZSBhIGRhdGEgcHJvcGVydHkgdGhhdCBkb2VzIG5vdCBzdWZmZXIgZnJvbVxyXG5cdFx0XHRcdC8vIHRoZSBvdmVycmlkZSBtaXN0YWtlLCB0aGF0IGFjY2Vzc29yJ3MgZ2V0dGVyIGlzIG1hcmtlZCB3aXRoXHJcblx0XHRcdFx0Ly8gYW4gYG9yaWdpbmFsVmFsdWVgIHByb3BlcnR5LiBIZXJlLCB3aGVuIHdlIGRldGVjdCB0aGlzLCB3ZVxyXG5cdFx0XHRcdC8vIHVwaG9sZCB0aGUgaWxsdXNpb24gYnkgcHJldGVuZGluZyB0byBzZWUgdGhhdCBvcmlnaW5hbCBkYXRhXHJcblx0XHRcdFx0Ly8gcHJvcGVydHksIGkuZS4sIHJldHVybmluZyB0aGUgdmFsdWUgcmF0aGVyIHRoYW4gdGhlIGdldHRlclxyXG5cdFx0XHRcdC8vIGl0c2VsZi5cclxuXHRcdFx0XHRpZiAoaXNPd24gJiYgJ2dldCcgaW4gZGVzYyAmJiAhKCdvcmlnaW5hbFZhbHVlJyBpbiBkZXNjLmdldCkpIHtcclxuXHRcdFx0XHRcdHZhbHVlID0gZGVzYy5nZXQ7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHZhbHVlID0gdmFsdWVbcGFydF07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGlzT3duID0gaGFzT3duKHZhbHVlLCBwYXJ0KTtcclxuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlW3BhcnRdO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoaXNPd24gJiYgIXNraXBGdXJ0aGVyQ2FjaGluZykge1xyXG5cdFx0XHRcdElOVFJJTlNJQ1NbaW50cmluc2ljUmVhbE5hbWVdID0gdmFsdWU7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIHZhbHVlO1xyXG59O1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/get-intrinsic/index.js\n");

/***/ }),

/***/ "./node_modules/has-symbols/index.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/index.js ***!
  \*******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar origSymbol = typeof Symbol !== 'undefined' && Symbol;\r\nvar hasSymbolSham = __webpack_require__(/*! ./shams */ \"./node_modules/has-symbols/shams.js\");\r\n\r\nmodule.exports = function hasNativeSymbols() {\r\n\tif (typeof origSymbol !== 'function') { return false; }\r\n\tif (typeof Symbol !== 'function') { return false; }\r\n\tif (typeof origSymbol('foo') !== 'symbol') { return false; }\r\n\tif (typeof Symbol('bar') !== 'symbol') { return false; }\r\n\r\n\treturn hasSymbolSham();\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGFzLXN5bWJvbHMvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsb0RBQVM7QUFDckM7QUFDQTtBQUNBLHlDQUF5QztBQUN6QyxxQ0FBcUM7QUFDckMsOENBQThDO0FBQzlDLDBDQUEwQztBQUMxQztBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2hhcy1zeW1ib2xzL2luZGV4LmpzPzJkNWMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIG9yaWdTeW1ib2wgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2w7XHJcbnZhciBoYXNTeW1ib2xTaGFtID0gcmVxdWlyZSgnLi9zaGFtcycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNOYXRpdmVTeW1ib2xzKCkge1xyXG5cdGlmICh0eXBlb2Ygb3JpZ1N5bWJvbCAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cclxuXHRpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cclxuXHRpZiAodHlwZW9mIG9yaWdTeW1ib2woJ2ZvbycpICE9PSAnc3ltYm9sJykgeyByZXR1cm4gZmFsc2U7IH1cclxuXHRpZiAodHlwZW9mIFN5bWJvbCgnYmFyJykgIT09ICdzeW1ib2wnKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuXHRyZXR1cm4gaGFzU3ltYm9sU2hhbSgpO1xyXG59O1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/has-symbols/index.js\n");

/***/ }),

/***/ "./node_modules/has-symbols/shams.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/shams.js ***!
  \*******************************************/
/***/ (function(module) {

"use strict";
eval("\r\n\r\n/* eslint complexity: [2, 18], max-statements: [2, 33] */\r\nmodule.exports = function hasSymbols() {\r\n\tif (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }\r\n\tif (typeof Symbol.iterator === 'symbol') { return true; }\r\n\r\n\tvar obj = {};\r\n\tvar sym = Symbol('test');\r\n\tvar symObj = Object(sym);\r\n\tif (typeof sym === 'string') { return false; }\r\n\r\n\tif (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }\r\n\tif (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }\r\n\r\n\t// temp disabled per https://github.com/ljharb/object.assign/issues/17\r\n\t// if (sym instanceof Symbol) { return false; }\r\n\t// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4\r\n\t// if (!(symObj instanceof Symbol)) { return false; }\r\n\r\n\t// if (typeof Symbol.prototype.toString !== 'function') { return false; }\r\n\t// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }\r\n\r\n\tvar symVal = 42;\r\n\tobj[sym] = symVal;\r\n\tfor (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop\r\n\tif (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }\r\n\r\n\tif (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }\r\n\r\n\tvar syms = Object.getOwnPropertySymbols(obj);\r\n\tif (syms.length !== 1 || syms[0] !== sym) { return false; }\r\n\r\n\tif (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }\r\n\r\n\tif (typeof Object.getOwnPropertyDescriptor === 'function') {\r\n\t\tvar descriptor = Object.getOwnPropertyDescriptor(obj, sym);\r\n\t\tif (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }\r\n\t}\r\n\r\n\treturn true;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGFzLXN5bWJvbHMvc2hhbXMuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwyRkFBMkY7QUFDM0YsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0Esa0VBQWtFO0FBQ2xFLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsMkRBQTJEO0FBQzNELCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDLDJFQUEyRTtBQUMzRTtBQUNBLHlHQUF5RztBQUN6RztBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvaGFzLXN5bWJvbHMvc2hhbXMuanM/Y2Y3ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG4vKiBlc2xpbnQgY29tcGxleGl0eTogWzIsIDE4XSwgbWF4LXN0YXRlbWVudHM6IFsyLCAzM10gKi9cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNTeW1ib2xzKCkge1xyXG5cdGlmICh0eXBlb2YgU3ltYm9sICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cdGlmICh0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSAnc3ltYm9sJykgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cclxuXHR2YXIgb2JqID0ge307XHJcblx0dmFyIHN5bSA9IFN5bWJvbCgndGVzdCcpO1xyXG5cdHZhciBzeW1PYmogPSBPYmplY3Qoc3ltKTtcclxuXHRpZiAodHlwZW9mIHN5bSA9PT0gJ3N0cmluZycpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltKSAhPT0gJ1tvYmplY3QgU3ltYm9sXScpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW1PYmopICE9PSAnW29iamVjdCBTeW1ib2xdJykgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0Ly8gdGVtcCBkaXNhYmxlZCBwZXIgaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9vYmplY3QuYXNzaWduL2lzc3Vlcy8xN1xyXG5cdC8vIGlmIChzeW0gaW5zdGFuY2VvZiBTeW1ib2wpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblx0Ly8gdGVtcCBkaXNhYmxlZCBwZXIgaHR0cHM6Ly9naXRodWIuY29tL1dlYlJlZmxlY3Rpb24vZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzL2lzc3Vlcy80XHJcblx0Ly8gaWYgKCEoc3ltT2JqIGluc3RhbmNlb2YgU3ltYm9sKSkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0Ly8gaWYgKHR5cGVvZiBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cdC8vIGlmIChTdHJpbmcoc3ltKSAhPT0gU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bSkpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdHZhciBzeW1WYWwgPSA0MjtcclxuXHRvYmpbc3ltXSA9IHN5bVZhbDtcclxuXHRmb3IgKHN5bSBpbiBvYmopIHsgcmV0dXJuIGZhbHNlOyB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXgsIG5vLXVucmVhY2hhYmxlLWxvb3BcclxuXHRpZiAodHlwZW9mIE9iamVjdC5rZXlzID09PSAnZnVuY3Rpb24nICYmIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoICE9PSAwKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuXHRpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzID09PSAnZnVuY3Rpb24nICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubGVuZ3RoICE9PSAwKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuXHR2YXIgc3ltcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqKTtcclxuXHRpZiAoc3ltcy5sZW5ndGggIT09IDEgfHwgc3ltc1swXSAhPT0gc3ltKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuXHRpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmosIHN5bSkpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0dmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgc3ltKTtcclxuXHRcdGlmIChkZXNjcmlwdG9yLnZhbHVlICE9PSBzeW1WYWwgfHwgZGVzY3JpcHRvci5lbnVtZXJhYmxlICE9PSB0cnVlKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRydWU7XHJcbn07XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/has-symbols/shams.js\n");

/***/ }),

/***/ "./node_modules/has-tostringtag/shams.js":
/*!***********************************************!*\
  !*** ./node_modules/has-tostringtag/shams.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar hasSymbols = __webpack_require__(/*! has-symbols/shams */ \"./node_modules/has-symbols/shams.js\");\r\n\r\nmodule.exports = function hasToStringTagShams() {\r\n\treturn hasSymbols() && !!Symbol.toStringTag;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGFzLXRvc3RyaW5ndGFnL3NoYW1zLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyw4REFBbUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2hhcy10b3N0cmluZ3RhZy9zaGFtcy5qcz8zNjM2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBoYXNTeW1ib2xzID0gcmVxdWlyZSgnaGFzLXN5bWJvbHMvc2hhbXMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzVG9TdHJpbmdUYWdTaGFtcygpIHtcclxuXHRyZXR1cm4gaGFzU3ltYm9scygpICYmICEhU3ltYm9sLnRvU3RyaW5nVGFnO1xyXG59O1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/has-tostringtag/shams.js\n");

/***/ }),

/***/ "./node_modules/has/src/index.js":
/*!***************************************!*\
  !*** ./node_modules/has/src/index.js ***!
  \***************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar bind = __webpack_require__(/*! function-bind */ \"./node_modules/function-bind/index.js\");\r\n\r\nmodule.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGFzL3NyYy9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsV0FBVyxtQkFBTyxDQUFDLDREQUFlO0FBQ2xDO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2hhcy9zcmMvaW5kZXguanM/MzA2NyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgYmluZCA9IHJlcXVpcmUoJ2Z1bmN0aW9uLWJpbmQnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/has/src/index.js\n");

/***/ }),

/***/ "./node_modules/hash-base/index.js":
/*!*****************************************!*\
  !*** ./node_modules/hash-base/index.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\r\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer)\r\nvar Transform = (__webpack_require__(/*! readable-stream */ \"./node_modules/readable-stream/readable-browser.js\").Transform)\r\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\r\n\r\nfunction throwIfNotStringOrBuffer (val, prefix) {\r\n  if (!Buffer.isBuffer(val) && typeof val !== 'string') {\r\n    throw new TypeError(prefix + ' must be a string or a buffer')\r\n  }\r\n}\r\n\r\nfunction HashBase (blockSize) {\r\n  Transform.call(this)\r\n\r\n  this._block = Buffer.allocUnsafe(blockSize)\r\n  this._blockSize = blockSize\r\n  this._blockOffset = 0\r\n  this._length = [0, 0, 0, 0]\r\n\r\n  this._finalized = false\r\n}\r\n\r\ninherits(HashBase, Transform)\r\n\r\nHashBase.prototype._transform = function (chunk, encoding, callback) {\r\n  var error = null\r\n  try {\r\n    this.update(chunk, encoding)\r\n  } catch (err) {\r\n    error = err\r\n  }\r\n\r\n  callback(error)\r\n}\r\n\r\nHashBase.prototype._flush = function (callback) {\r\n  var error = null\r\n  try {\r\n    this.push(this.digest())\r\n  } catch (err) {\r\n    error = err\r\n  }\r\n\r\n  callback(error)\r\n}\r\n\r\nHashBase.prototype.update = function (data, encoding) {\r\n  throwIfNotStringOrBuffer(data, 'Data')\r\n  if (this._finalized) throw new Error('Digest already called')\r\n  if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding)\r\n\r\n  // consume data\r\n  var block = this._block\r\n  var offset = 0\r\n  while (this._blockOffset + data.length - offset >= this._blockSize) {\r\n    for (var i = this._blockOffset; i < this._blockSize;) block[i++] = data[offset++]\r\n    this._update()\r\n    this._blockOffset = 0\r\n  }\r\n  while (offset < data.length) block[this._blockOffset++] = data[offset++]\r\n\r\n  // update length\r\n  for (var j = 0, carry = data.length * 8; carry > 0; ++j) {\r\n    this._length[j] += carry\r\n    carry = (this._length[j] / 0x0100000000) | 0\r\n    if (carry > 0) this._length[j] -= 0x0100000000 * carry\r\n  }\r\n\r\n  return this\r\n}\r\n\r\nHashBase.prototype._update = function () {\r\n  throw new Error('_update is not implemented')\r\n}\r\n\r\nHashBase.prototype.digest = function (encoding) {\r\n  if (this._finalized) throw new Error('Digest already called')\r\n  this._finalized = true\r\n\r\n  var digest = this._digest()\r\n  if (encoding !== undefined) digest = digest.toString(encoding)\r\n\r\n  // reset state\r\n  this._block.fill(0)\r\n  this._blockOffset = 0\r\n  for (var i = 0; i < 4; ++i) this._length[i] = 0\r\n\r\n  return digest\r\n}\r\n\r\nHashBase.prototype._digest = function () {\r\n  throw new Error('_digest is not implemented')\r\n}\r\n\r\nmodule.exports = HashBase\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGFzaC1iYXNlL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1osYUFBYSxzRkFBNkI7QUFDMUMsZ0JBQWdCLDRHQUFvQztBQUNwRCxlQUFlLG1CQUFPLENBQUMsNkRBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxvQkFBb0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2hhc2gtYmFzZS9pbmRleC5qcz9mOTI5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xyXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcclxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpLlRyYW5zZm9ybVxyXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXHJcblxyXG5mdW5jdGlvbiB0aHJvd0lmTm90U3RyaW5nT3JCdWZmZXIgKHZhbCwgcHJlZml4KSB7XHJcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodmFsKSAmJiB0eXBlb2YgdmFsICE9PSAnc3RyaW5nJykge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihwcmVmaXggKyAnIG11c3QgYmUgYSBzdHJpbmcgb3IgYSBidWZmZXInKVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gSGFzaEJhc2UgKGJsb2NrU2l6ZSkge1xyXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMpXHJcblxyXG4gIHRoaXMuX2Jsb2NrID0gQnVmZmVyLmFsbG9jVW5zYWZlKGJsb2NrU2l6ZSlcclxuICB0aGlzLl9ibG9ja1NpemUgPSBibG9ja1NpemVcclxuICB0aGlzLl9ibG9ja09mZnNldCA9IDBcclxuICB0aGlzLl9sZW5ndGggPSBbMCwgMCwgMCwgMF1cclxuXHJcbiAgdGhpcy5fZmluYWxpemVkID0gZmFsc2VcclxufVxyXG5cclxuaW5oZXJpdHMoSGFzaEJhc2UsIFRyYW5zZm9ybSlcclxuXHJcbkhhc2hCYXNlLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcclxuICB2YXIgZXJyb3IgPSBudWxsXHJcbiAgdHJ5IHtcclxuICAgIHRoaXMudXBkYXRlKGNodW5rLCBlbmNvZGluZylcclxuICB9IGNhdGNoIChlcnIpIHtcclxuICAgIGVycm9yID0gZXJyXHJcbiAgfVxyXG5cclxuICBjYWxsYmFjayhlcnJvcilcclxufVxyXG5cclxuSGFzaEJhc2UucHJvdG90eXBlLl9mbHVzaCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gIHZhciBlcnJvciA9IG51bGxcclxuICB0cnkge1xyXG4gICAgdGhpcy5wdXNoKHRoaXMuZGlnZXN0KCkpXHJcbiAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICBlcnJvciA9IGVyclxyXG4gIH1cclxuXHJcbiAgY2FsbGJhY2soZXJyb3IpXHJcbn1cclxuXHJcbkhhc2hCYXNlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSwgZW5jb2RpbmcpIHtcclxuICB0aHJvd0lmTm90U3RyaW5nT3JCdWZmZXIoZGF0YSwgJ0RhdGEnKVxyXG4gIGlmICh0aGlzLl9maW5hbGl6ZWQpIHRocm93IG5ldyBFcnJvcignRGlnZXN0IGFscmVhZHkgY2FsbGVkJylcclxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEsIGVuY29kaW5nKVxyXG5cclxuICAvLyBjb25zdW1lIGRhdGFcclxuICB2YXIgYmxvY2sgPSB0aGlzLl9ibG9ja1xyXG4gIHZhciBvZmZzZXQgPSAwXHJcbiAgd2hpbGUgKHRoaXMuX2Jsb2NrT2Zmc2V0ICsgZGF0YS5sZW5ndGggLSBvZmZzZXQgPj0gdGhpcy5fYmxvY2tTaXplKSB7XHJcbiAgICBmb3IgKHZhciBpID0gdGhpcy5fYmxvY2tPZmZzZXQ7IGkgPCB0aGlzLl9ibG9ja1NpemU7KSBibG9ja1tpKytdID0gZGF0YVtvZmZzZXQrK11cclxuICAgIHRoaXMuX3VwZGF0ZSgpXHJcbiAgICB0aGlzLl9ibG9ja09mZnNldCA9IDBcclxuICB9XHJcbiAgd2hpbGUgKG9mZnNldCA8IGRhdGEubGVuZ3RoKSBibG9ja1t0aGlzLl9ibG9ja09mZnNldCsrXSA9IGRhdGFbb2Zmc2V0KytdXHJcblxyXG4gIC8vIHVwZGF0ZSBsZW5ndGhcclxuICBmb3IgKHZhciBqID0gMCwgY2FycnkgPSBkYXRhLmxlbmd0aCAqIDg7IGNhcnJ5ID4gMDsgKytqKSB7XHJcbiAgICB0aGlzLl9sZW5ndGhbal0gKz0gY2FycnlcclxuICAgIGNhcnJ5ID0gKHRoaXMuX2xlbmd0aFtqXSAvIDB4MDEwMDAwMDAwMCkgfCAwXHJcbiAgICBpZiAoY2FycnkgPiAwKSB0aGlzLl9sZW5ndGhbal0gLT0gMHgwMTAwMDAwMDAwICogY2FycnlcclxuICB9XHJcblxyXG4gIHJldHVybiB0aGlzXHJcbn1cclxuXHJcbkhhc2hCYXNlLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gIHRocm93IG5ldyBFcnJvcignX3VwZGF0ZSBpcyBub3QgaW1wbGVtZW50ZWQnKVxyXG59XHJcblxyXG5IYXNoQmFzZS5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKGVuY29kaW5nKSB7XHJcbiAgaWYgKHRoaXMuX2ZpbmFsaXplZCkgdGhyb3cgbmV3IEVycm9yKCdEaWdlc3QgYWxyZWFkeSBjYWxsZWQnKVxyXG4gIHRoaXMuX2ZpbmFsaXplZCA9IHRydWVcclxuXHJcbiAgdmFyIGRpZ2VzdCA9IHRoaXMuX2RpZ2VzdCgpXHJcbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIGRpZ2VzdCA9IGRpZ2VzdC50b1N0cmluZyhlbmNvZGluZylcclxuXHJcbiAgLy8gcmVzZXQgc3RhdGVcclxuICB0aGlzLl9ibG9jay5maWxsKDApXHJcbiAgdGhpcy5fYmxvY2tPZmZzZXQgPSAwXHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyArK2kpIHRoaXMuX2xlbmd0aFtpXSA9IDBcclxuXHJcbiAgcmV0dXJuIGRpZ2VzdFxyXG59XHJcblxyXG5IYXNoQmFzZS5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uICgpIHtcclxuICB0aHJvdyBuZXcgRXJyb3IoJ19kaWdlc3QgaXMgbm90IGltcGxlbWVudGVkJylcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBIYXNoQmFzZVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/hash-base/index.js\n");

/***/ }),

/***/ "./node_modules/is-arguments/index.js":
/*!********************************************!*\
  !*** ./node_modules/is-arguments/index.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ \"./node_modules/has-tostringtag/shams.js\")();\r\nvar callBound = __webpack_require__(/*! call-bind/callBound */ \"./node_modules/call-bind/callBound.js\");\r\n\r\nvar $toString = callBound('Object.prototype.toString');\r\n\r\nvar isStandardArguments = function isArguments(value) {\r\n\tif (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {\r\n\t\treturn false;\r\n\t}\r\n\treturn $toString(value) === '[object Arguments]';\r\n};\r\n\r\nvar isLegacyArguments = function isArguments(value) {\r\n\tif (isStandardArguments(value)) {\r\n\t\treturn true;\r\n\t}\r\n\treturn value !== null &&\r\n\t\ttypeof value === 'object' &&\r\n\t\ttypeof value.length === 'number' &&\r\n\t\tvalue.length >= 0 &&\r\n\t\t$toString(value) !== '[object Array]' &&\r\n\t\t$toString(value.callee) === '[object Function]';\r\n};\r\n\r\nvar supportsStandardArguments = (function () {\r\n\treturn isStandardArguments(arguments);\r\n}());\r\n\r\nisStandardArguments.isLegacyArguments = isLegacyArguments; // for tests\r\n\r\nmodule.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaXMtYXJndW1lbnRzL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSxxQkFBcUIsbUJBQU8sQ0FBQyxzRUFBdUI7QUFDcEQsZ0JBQWdCLG1CQUFPLENBQUMsa0VBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9pcy1hcmd1bWVudHMvaW5kZXguanM/MWMwZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgaGFzVG9TdHJpbmdUYWcgPSByZXF1aXJlKCdoYXMtdG9zdHJpbmd0YWcvc2hhbXMnKSgpO1xyXG52YXIgY2FsbEJvdW5kID0gcmVxdWlyZSgnY2FsbC1iaW5kL2NhbGxCb3VuZCcpO1xyXG5cclxudmFyICR0b1N0cmluZyA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZycpO1xyXG5cclxudmFyIGlzU3RhbmRhcmRBcmd1bWVudHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xyXG5cdGlmIChoYXNUb1N0cmluZ1RhZyAmJiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIFN5bWJvbC50b1N0cmluZ1RhZyBpbiB2YWx1ZSkge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHRyZXR1cm4gJHRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XHJcbn07XHJcblxyXG52YXIgaXNMZWdhY3lBcmd1bWVudHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xyXG5cdGlmIChpc1N0YW5kYXJkQXJndW1lbnRzKHZhbHVlKSkge1xyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG5cdHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJlxyXG5cdFx0dHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxyXG5cdFx0dHlwZW9mIHZhbHVlLmxlbmd0aCA9PT0gJ251bWJlcicgJiZcclxuXHRcdHZhbHVlLmxlbmd0aCA+PSAwICYmXHJcblx0XHQkdG9TdHJpbmcodmFsdWUpICE9PSAnW29iamVjdCBBcnJheV0nICYmXHJcblx0XHQkdG9TdHJpbmcodmFsdWUuY2FsbGVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcclxufTtcclxuXHJcbnZhciBzdXBwb3J0c1N0YW5kYXJkQXJndW1lbnRzID0gKGZ1bmN0aW9uICgpIHtcclxuXHRyZXR1cm4gaXNTdGFuZGFyZEFyZ3VtZW50cyhhcmd1bWVudHMpO1xyXG59KCkpO1xyXG5cclxuaXNTdGFuZGFyZEFyZ3VtZW50cy5pc0xlZ2FjeUFyZ3VtZW50cyA9IGlzTGVnYWN5QXJndW1lbnRzOyAvLyBmb3IgdGVzdHNcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gc3VwcG9ydHNTdGFuZGFyZEFyZ3VtZW50cyA/IGlzU3RhbmRhcmRBcmd1bWVudHMgOiBpc0xlZ2FjeUFyZ3VtZW50cztcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/is-arguments/index.js\n");

/***/ }),

/***/ "./node_modules/is-generator-function/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/is-generator-function/index.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar toStr = Object.prototype.toString;\r\nvar fnToStr = Function.prototype.toString;\r\nvar isFnRegex = /^\\s*(?:function)?\\*/;\r\nvar hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ \"./node_modules/has-tostringtag/shams.js\")();\r\nvar getProto = Object.getPrototypeOf;\r\nvar getGeneratorFunc = function () { // eslint-disable-line consistent-return\r\n\tif (!hasToStringTag) {\r\n\t\treturn false;\r\n\t}\r\n\ttry {\r\n\t\treturn Function('return function*() {}')();\r\n\t} catch (e) {\r\n\t}\r\n};\r\nvar GeneratorFunction;\r\n\r\nmodule.exports = function isGeneratorFunction(fn) {\r\n\tif (typeof fn !== 'function') {\r\n\t\treturn false;\r\n\t}\r\n\tif (isFnRegex.test(fnToStr.call(fn))) {\r\n\t\treturn true;\r\n\t}\r\n\tif (!hasToStringTag) {\r\n\t\tvar str = toStr.call(fn);\r\n\t\treturn str === '[object GeneratorFunction]';\r\n\t}\r\n\tif (!getProto) {\r\n\t\treturn false;\r\n\t}\r\n\tif (typeof GeneratorFunction === 'undefined') {\r\n\t\tvar generatorFunc = getGeneratorFunc();\r\n\t\tGeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;\r\n\t}\r\n\treturn getProto(fn) === GeneratorFunction;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaXMtZ2VuZXJhdG9yLWZ1bmN0aW9uL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQU8sQ0FBQyxzRUFBdUI7QUFDcEQ7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvaXMtZ2VuZXJhdG9yLWZ1bmN0aW9uL2luZGV4LmpzPzAzZTYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcclxudmFyIGZuVG9TdHIgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XHJcbnZhciBpc0ZuUmVnZXggPSAvXlxccyooPzpmdW5jdGlvbik/XFwqLztcclxudmFyIGhhc1RvU3RyaW5nVGFnID0gcmVxdWlyZSgnaGFzLXRvc3RyaW5ndGFnL3NoYW1zJykoKTtcclxudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xyXG52YXIgZ2V0R2VuZXJhdG9yRnVuYyA9IGZ1bmN0aW9uICgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXJldHVyblxyXG5cdGlmICghaGFzVG9TdHJpbmdUYWcpIHtcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcblx0dHJ5IHtcclxuXHRcdHJldHVybiBGdW5jdGlvbigncmV0dXJuIGZ1bmN0aW9uKigpIHt9JykoKTtcclxuXHR9IGNhdGNoIChlKSB7XHJcblx0fVxyXG59O1xyXG52YXIgR2VuZXJhdG9yRnVuY3Rpb247XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzR2VuZXJhdG9yRnVuY3Rpb24oZm4pIHtcclxuXHRpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cdGlmIChpc0ZuUmVnZXgudGVzdChmblRvU3RyLmNhbGwoZm4pKSkge1xyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG5cdGlmICghaGFzVG9TdHJpbmdUYWcpIHtcclxuXHRcdHZhciBzdHIgPSB0b1N0ci5jYWxsKGZuKTtcclxuXHRcdHJldHVybiBzdHIgPT09ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXSc7XHJcblx0fVxyXG5cdGlmICghZ2V0UHJvdG8pIHtcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcblx0aWYgKHR5cGVvZiBHZW5lcmF0b3JGdW5jdGlvbiA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuXHRcdHZhciBnZW5lcmF0b3JGdW5jID0gZ2V0R2VuZXJhdG9yRnVuYygpO1xyXG5cdFx0R2VuZXJhdG9yRnVuY3Rpb24gPSBnZW5lcmF0b3JGdW5jID8gZ2V0UHJvdG8oZ2VuZXJhdG9yRnVuYykgOiBmYWxzZTtcclxuXHR9XHJcblx0cmV0dXJuIGdldFByb3RvKGZuKSA9PT0gR2VuZXJhdG9yRnVuY3Rpb247XHJcbn07XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/is-generator-function/index.js\n");

/***/ }),

/***/ "./node_modules/is-nan/implementation.js":
/*!***********************************************!*\
  !*** ./node_modules/is-nan/implementation.js ***!
  \***********************************************/
/***/ (function(module) {

"use strict";
eval("\r\n\r\n/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */\r\n\r\nmodule.exports = function isNaN(value) {\r\n\treturn value !== value;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaXMtbmFuL2ltcGxlbWVudGF0aW9uLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9pcy1uYW4vaW1wbGVtZW50YXRpb24uanM/MzUxNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG4vKiBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtbnVtYmVyLmlzbmFuICovXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzTmFOKHZhbHVlKSB7XHJcblx0cmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcclxufTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/is-nan/implementation.js\n");

/***/ }),

/***/ "./node_modules/is-nan/index.js":
/*!**************************************!*\
  !*** ./node_modules/is-nan/index.js ***!
  \**************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar callBind = __webpack_require__(/*! call-bind */ \"./node_modules/call-bind/index.js\");\r\nvar define = __webpack_require__(/*! define-properties */ \"./node_modules/define-properties/index.js\");\r\n\r\nvar implementation = __webpack_require__(/*! ./implementation */ \"./node_modules/is-nan/implementation.js\");\r\nvar getPolyfill = __webpack_require__(/*! ./polyfill */ \"./node_modules/is-nan/polyfill.js\");\r\nvar shim = __webpack_require__(/*! ./shim */ \"./node_modules/is-nan/shim.js\");\r\n\r\nvar polyfill = callBind(getPolyfill(), Number);\r\n\r\n/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */\r\n\r\ndefine(polyfill, {\r\n\tgetPolyfill: getPolyfill,\r\n\timplementation: implementation,\r\n\tshim: shim\r\n});\r\n\r\nmodule.exports = polyfill;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaXMtbmFuL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSxlQUFlLG1CQUFPLENBQUMsb0RBQVc7QUFDbEMsYUFBYSxtQkFBTyxDQUFDLG9FQUFtQjtBQUN4QztBQUNBLHFCQUFxQixtQkFBTyxDQUFDLGlFQUFrQjtBQUMvQyxrQkFBa0IsbUJBQU8sQ0FBQyxxREFBWTtBQUN0QyxXQUFXLG1CQUFPLENBQUMsNkNBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2lzLW5hbi9pbmRleC5qcz8zOWYwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBjYWxsQmluZCA9IHJlcXVpcmUoJ2NhbGwtYmluZCcpO1xyXG52YXIgZGVmaW5lID0gcmVxdWlyZSgnZGVmaW5lLXByb3BlcnRpZXMnKTtcclxuXHJcbnZhciBpbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcclxudmFyIGdldFBvbHlmaWxsID0gcmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xyXG52YXIgc2hpbSA9IHJlcXVpcmUoJy4vc2hpbScpO1xyXG5cclxudmFyIHBvbHlmaWxsID0gY2FsbEJpbmQoZ2V0UG9seWZpbGwoKSwgTnVtYmVyKTtcclxuXHJcbi8qIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1udW1iZXIuaXNuYW4gKi9cclxuXHJcbmRlZmluZShwb2x5ZmlsbCwge1xyXG5cdGdldFBvbHlmaWxsOiBnZXRQb2x5ZmlsbCxcclxuXHRpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb24sXHJcblx0c2hpbTogc2hpbVxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gcG9seWZpbGw7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/is-nan/index.js\n");

/***/ }),

/***/ "./node_modules/is-nan/polyfill.js":
/*!*****************************************!*\
  !*** ./node_modules/is-nan/polyfill.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar implementation = __webpack_require__(/*! ./implementation */ \"./node_modules/is-nan/implementation.js\");\r\n\r\nmodule.exports = function getPolyfill() {\r\n\tif (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN('a')) {\r\n\t\treturn Number.isNaN;\r\n\t}\r\n\treturn implementation;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaXMtbmFuL3BvbHlmaWxsLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSxxQkFBcUIsbUJBQU8sQ0FBQyxpRUFBa0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2lzLW5hbi9wb2x5ZmlsbC5qcz8xNzc5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBpbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0UG9seWZpbGwoKSB7XHJcblx0aWYgKE51bWJlci5pc05hTiAmJiBOdW1iZXIuaXNOYU4oTmFOKSAmJiAhTnVtYmVyLmlzTmFOKCdhJykpIHtcclxuXHRcdHJldHVybiBOdW1iZXIuaXNOYU47XHJcblx0fVxyXG5cdHJldHVybiBpbXBsZW1lbnRhdGlvbjtcclxufTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/is-nan/polyfill.js\n");

/***/ }),

/***/ "./node_modules/is-nan/shim.js":
/*!*************************************!*\
  !*** ./node_modules/is-nan/shim.js ***!
  \*************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar define = __webpack_require__(/*! define-properties */ \"./node_modules/define-properties/index.js\");\r\nvar getPolyfill = __webpack_require__(/*! ./polyfill */ \"./node_modules/is-nan/polyfill.js\");\r\n\r\n/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */\r\n\r\nmodule.exports = function shimNumberIsNaN() {\r\n\tvar polyfill = getPolyfill();\r\n\tdefine(Number, { isNaN: polyfill }, {\r\n\t\tisNaN: function testIsNaN() {\r\n\t\t\treturn Number.isNaN !== polyfill;\r\n\t\t}\r\n\t});\r\n\treturn polyfill;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaXMtbmFuL3NoaW0uanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLGFBQWEsbUJBQU8sQ0FBQyxvRUFBbUI7QUFDeEMsa0JBQWtCLG1CQUFPLENBQUMscURBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2lzLW5hbi9zaGltLmpzPzUxZmMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGRlZmluZSA9IHJlcXVpcmUoJ2RlZmluZS1wcm9wZXJ0aWVzJyk7XHJcbnZhciBnZXRQb2x5ZmlsbCA9IHJlcXVpcmUoJy4vcG9seWZpbGwnKTtcclxuXHJcbi8qIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1udW1iZXIuaXNuYW4gKi9cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2hpbU51bWJlcklzTmFOKCkge1xyXG5cdHZhciBwb2x5ZmlsbCA9IGdldFBvbHlmaWxsKCk7XHJcblx0ZGVmaW5lKE51bWJlciwgeyBpc05hTjogcG9seWZpbGwgfSwge1xyXG5cdFx0aXNOYU46IGZ1bmN0aW9uIHRlc3RJc05hTigpIHtcclxuXHRcdFx0cmV0dXJuIE51bWJlci5pc05hTiAhPT0gcG9seWZpbGw7XHJcblx0XHR9XHJcblx0fSk7XHJcblx0cmV0dXJuIHBvbHlmaWxsO1xyXG59O1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/is-nan/shim.js\n");

/***/ }),

/***/ "./node_modules/is-typed-array/index.js":
/*!**********************************************!*\
  !*** ./node_modules/is-typed-array/index.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar forEach = __webpack_require__(/*! foreach */ \"./node_modules/foreach/index.js\");\r\nvar availableTypedArrays = __webpack_require__(/*! available-typed-arrays */ \"./node_modules/available-typed-arrays/index.js\");\r\nvar callBound = __webpack_require__(/*! call-bind/callBound */ \"./node_modules/call-bind/callBound.js\");\r\n\r\nvar $toString = callBound('Object.prototype.toString');\r\nvar hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ \"./node_modules/has-tostringtag/shams.js\")();\r\n\r\nvar g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;\r\nvar typedArrays = availableTypedArrays();\r\n\r\nvar $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {\r\n\tfor (var i = 0; i < array.length; i += 1) {\r\n\t\tif (array[i] === value) {\r\n\t\t\treturn i;\r\n\t\t}\r\n\t}\r\n\treturn -1;\r\n};\r\nvar $slice = callBound('String.prototype.slice');\r\nvar toStrTags = {};\r\nvar gOPD = __webpack_require__(/*! es-abstract/helpers/getOwnPropertyDescriptor */ \"./node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js\");\r\nvar getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');\r\nif (hasToStringTag && gOPD && getPrototypeOf) {\r\n\tforEach(typedArrays, function (typedArray) {\r\n\t\tvar arr = new g[typedArray]();\r\n\t\tif (Symbol.toStringTag in arr) {\r\n\t\t\tvar proto = getPrototypeOf(arr);\r\n\t\t\tvar descriptor = gOPD(proto, Symbol.toStringTag);\r\n\t\t\tif (!descriptor) {\r\n\t\t\t\tvar superProto = getPrototypeOf(proto);\r\n\t\t\t\tdescriptor = gOPD(superProto, Symbol.toStringTag);\r\n\t\t\t}\r\n\t\t\ttoStrTags[typedArray] = descriptor.get;\r\n\t\t}\r\n\t});\r\n}\r\n\r\nvar tryTypedArrays = function tryAllTypedArrays(value) {\r\n\tvar anyTrue = false;\r\n\tforEach(toStrTags, function (getter, typedArray) {\r\n\t\tif (!anyTrue) {\r\n\t\t\ttry {\r\n\t\t\t\tanyTrue = getter.call(value) === typedArray;\r\n\t\t\t} catch (e) { /**/ }\r\n\t\t}\r\n\t});\r\n\treturn anyTrue;\r\n};\r\n\r\nmodule.exports = function isTypedArray(value) {\r\n\tif (!value || typeof value !== 'object') { return false; }\r\n\tif (!hasToStringTag || !(Symbol.toStringTag in value)) {\r\n\t\tvar tag = $slice($toString(value), 8, -1);\r\n\t\treturn $indexOf(typedArrays, tag) > -1;\r\n\t}\r\n\tif (!gOPD) { return false; }\r\n\treturn tryTypedArrays(value);\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaXMtdHlwZWQtYXJyYXkvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxnREFBUztBQUMvQiwyQkFBMkIsbUJBQU8sQ0FBQyw4RUFBd0I7QUFDM0QsZ0JBQWdCLG1CQUFPLENBQUMsa0VBQXFCO0FBQzdDO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQU8sQ0FBQyxzRUFBdUI7QUFDcEQ7QUFDQSw0Q0FBNEMscUJBQU07QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBTyxDQUFDLG9IQUE4QztBQUNqRSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLFlBQVk7QUFDakI7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvaXMtdHlwZWQtYXJyYXkvaW5kZXguanM/YjUyZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgZm9yRWFjaCA9IHJlcXVpcmUoJ2ZvcmVhY2gnKTtcclxudmFyIGF2YWlsYWJsZVR5cGVkQXJyYXlzID0gcmVxdWlyZSgnYXZhaWxhYmxlLXR5cGVkLWFycmF5cycpO1xyXG52YXIgY2FsbEJvdW5kID0gcmVxdWlyZSgnY2FsbC1iaW5kL2NhbGxCb3VuZCcpO1xyXG5cclxudmFyICR0b1N0cmluZyA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZycpO1xyXG52YXIgaGFzVG9TdHJpbmdUYWcgPSByZXF1aXJlKCdoYXMtdG9zdHJpbmd0YWcvc2hhbXMnKSgpO1xyXG5cclxudmFyIGcgPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiBnbG9iYWxUaGlzO1xyXG52YXIgdHlwZWRBcnJheXMgPSBhdmFpbGFibGVUeXBlZEFycmF5cygpO1xyXG5cclxudmFyICRpbmRleE9mID0gY2FsbEJvdW5kKCdBcnJheS5wcm90b3R5cGUuaW5kZXhPZicsIHRydWUpIHx8IGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlKSB7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkgKz0gMSkge1xyXG5cdFx0aWYgKGFycmF5W2ldID09PSB2YWx1ZSkge1xyXG5cdFx0XHRyZXR1cm4gaTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIC0xO1xyXG59O1xyXG52YXIgJHNsaWNlID0gY2FsbEJvdW5kKCdTdHJpbmcucHJvdG90eXBlLnNsaWNlJyk7XHJcbnZhciB0b1N0clRhZ3MgPSB7fTtcclxudmFyIGdPUEQgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC9oZWxwZXJzL2dldE93blByb3BlcnR5RGVzY3JpcHRvcicpO1xyXG52YXIgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7IC8vIHJlcXVpcmUoJ2dldHByb3RvdHlwZW9mJyk7XHJcbmlmIChoYXNUb1N0cmluZ1RhZyAmJiBnT1BEICYmIGdldFByb3RvdHlwZU9mKSB7XHJcblx0Zm9yRWFjaCh0eXBlZEFycmF5cywgZnVuY3Rpb24gKHR5cGVkQXJyYXkpIHtcclxuXHRcdHZhciBhcnIgPSBuZXcgZ1t0eXBlZEFycmF5XSgpO1xyXG5cdFx0aWYgKFN5bWJvbC50b1N0cmluZ1RhZyBpbiBhcnIpIHtcclxuXHRcdFx0dmFyIHByb3RvID0gZ2V0UHJvdG90eXBlT2YoYXJyKTtcclxuXHRcdFx0dmFyIGRlc2NyaXB0b3IgPSBnT1BEKHByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpO1xyXG5cdFx0XHRpZiAoIWRlc2NyaXB0b3IpIHtcclxuXHRcdFx0XHR2YXIgc3VwZXJQcm90byA9IGdldFByb3RvdHlwZU9mKHByb3RvKTtcclxuXHRcdFx0XHRkZXNjcmlwdG9yID0gZ09QRChzdXBlclByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRvU3RyVGFnc1t0eXBlZEFycmF5XSA9IGRlc2NyaXB0b3IuZ2V0O1xyXG5cdFx0fVxyXG5cdH0pO1xyXG59XHJcblxyXG52YXIgdHJ5VHlwZWRBcnJheXMgPSBmdW5jdGlvbiB0cnlBbGxUeXBlZEFycmF5cyh2YWx1ZSkge1xyXG5cdHZhciBhbnlUcnVlID0gZmFsc2U7XHJcblx0Zm9yRWFjaCh0b1N0clRhZ3MsIGZ1bmN0aW9uIChnZXR0ZXIsIHR5cGVkQXJyYXkpIHtcclxuXHRcdGlmICghYW55VHJ1ZSkge1xyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdGFueVRydWUgPSBnZXR0ZXIuY2FsbCh2YWx1ZSkgPT09IHR5cGVkQXJyYXk7XHJcblx0XHRcdH0gY2F0Y2ggKGUpIHsgLyoqLyB9XHJcblx0XHR9XHJcblx0fSk7XHJcblx0cmV0dXJuIGFueVRydWU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzVHlwZWRBcnJheSh2YWx1ZSkge1xyXG5cdGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH1cclxuXHRpZiAoIWhhc1RvU3RyaW5nVGFnIHx8ICEoU3ltYm9sLnRvU3RyaW5nVGFnIGluIHZhbHVlKSkge1xyXG5cdFx0dmFyIHRhZyA9ICRzbGljZSgkdG9TdHJpbmcodmFsdWUpLCA4LCAtMSk7XHJcblx0XHRyZXR1cm4gJGluZGV4T2YodHlwZWRBcnJheXMsIHRhZykgPiAtMTtcclxuXHR9XHJcblx0aWYgKCFnT1BEKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cdHJldHVybiB0cnlUeXBlZEFycmF5cyh2YWx1ZSk7XHJcbn07XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/is-typed-array/index.js\n");

/***/ }),

/***/ "./node_modules/json-rpc-random-id/index.js":
/*!**************************************************!*\
  !*** ./node_modules/json-rpc-random-id/index.js ***!
  \**************************************************/
/***/ (function(module) {

eval("module.exports = IdIterator\r\n\r\nfunction IdIterator(opts){\r\n  opts = opts || {}\r\n  var max = opts.max || Number.MAX_SAFE_INTEGER\r\n  var idCounter = typeof opts.start !== 'undefined' ? opts.start : Math.floor(Math.random() * max)\r\n\r\n  return function createRandomId () {\r\n    idCounter = idCounter % max\r\n    return idCounter++\r\n  }\r\n\r\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvanNvbi1ycGMtcmFuZG9tLWlkL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9qc29uLXJwYy1yYW5kb20taWQvaW5kZXguanM/ODFkNiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IElkSXRlcmF0b3JcclxuXHJcbmZ1bmN0aW9uIElkSXRlcmF0b3Iob3B0cyl7XHJcbiAgb3B0cyA9IG9wdHMgfHwge31cclxuICB2YXIgbWF4ID0gb3B0cy5tYXggfHwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcclxuICB2YXIgaWRDb3VudGVyID0gdHlwZW9mIG9wdHMuc3RhcnQgIT09ICd1bmRlZmluZWQnID8gb3B0cy5zdGFydCA6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG1heClcclxuXHJcbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZVJhbmRvbUlkICgpIHtcclxuICAgIGlkQ291bnRlciA9IGlkQ291bnRlciAlIG1heFxyXG4gICAgcmV0dXJuIGlkQ291bnRlcisrXHJcbiAgfVxyXG5cclxufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/json-rpc-random-id/index.js\n");

/***/ }),

/***/ "./node_modules/keccak/js.js":
/*!***********************************!*\
  !*** ./node_modules/keccak/js.js ***!
  \***********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./lib/api */ \"./node_modules/keccak/lib/api/index.js\")(__webpack_require__(/*! ./lib/keccak */ \"./node_modules/keccak/lib/keccak.js\"))\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMva2VjY2FrL2pzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQixtQkFBTyxDQUFDLHlEQUFXLEVBQUUsbUJBQU8sQ0FBQyx5REFBYyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMva2VjY2FrL2pzLmpzPzQ5NDQiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9hcGknKShyZXF1aXJlKCcuL2xpYi9rZWNjYWsnKSlcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/keccak/js.js\n");

/***/ }),

/***/ "./node_modules/keccak/lib/api/index.js":
/*!**********************************************!*\
  !*** ./node_modules/keccak/lib/api/index.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const createKeccak = __webpack_require__(/*! ./keccak */ \"./node_modules/keccak/lib/api/keccak.js\")\r\nconst createShake = __webpack_require__(/*! ./shake */ \"./node_modules/keccak/lib/api/shake.js\")\r\n\r\nmodule.exports = function (KeccakState) {\r\n  const Keccak = createKeccak(KeccakState)\r\n  const Shake = createShake(KeccakState)\r\n\r\n  return function (algorithm, options) {\r\n    const hash = typeof algorithm === 'string' ? algorithm.toLowerCase() : algorithm\r\n    switch (hash) {\r\n      case 'keccak224': return new Keccak(1152, 448, null, 224, options)\r\n      case 'keccak256': return new Keccak(1088, 512, null, 256, options)\r\n      case 'keccak384': return new Keccak(832, 768, null, 384, options)\r\n      case 'keccak512': return new Keccak(576, 1024, null, 512, options)\r\n\r\n      case 'sha3-224': return new Keccak(1152, 448, 0x06, 224, options)\r\n      case 'sha3-256': return new Keccak(1088, 512, 0x06, 256, options)\r\n      case 'sha3-384': return new Keccak(832, 768, 0x06, 384, options)\r\n      case 'sha3-512': return new Keccak(576, 1024, 0x06, 512, options)\r\n\r\n      case 'shake128': return new Shake(1344, 256, 0x1f, options)\r\n      case 'shake256': return new Shake(1088, 512, 0x1f, options)\r\n\r\n      default: throw new Error('Invald algorithm: ' + algorithm)\r\n    }\r\n  }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMva2VjY2FrL2xpYi9hcGkvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQUEscUJBQXFCLG1CQUFPLENBQUMseURBQVU7QUFDdkMsb0JBQW9CLG1CQUFPLENBQUMsdURBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2tlY2Nhay9saWIvYXBpL2luZGV4LmpzPzI3NzAiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY3JlYXRlS2VjY2FrID0gcmVxdWlyZSgnLi9rZWNjYWsnKVxyXG5jb25zdCBjcmVhdGVTaGFrZSA9IHJlcXVpcmUoJy4vc2hha2UnKVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS2VjY2FrU3RhdGUpIHtcclxuICBjb25zdCBLZWNjYWsgPSBjcmVhdGVLZWNjYWsoS2VjY2FrU3RhdGUpXHJcbiAgY29uc3QgU2hha2UgPSBjcmVhdGVTaGFrZShLZWNjYWtTdGF0ZSlcclxuXHJcbiAgcmV0dXJuIGZ1bmN0aW9uIChhbGdvcml0aG0sIG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IGhhc2ggPSB0eXBlb2YgYWxnb3JpdGhtID09PSAnc3RyaW5nJyA/IGFsZ29yaXRobS50b0xvd2VyQ2FzZSgpIDogYWxnb3JpdGhtXHJcbiAgICBzd2l0Y2ggKGhhc2gpIHtcclxuICAgICAgY2FzZSAna2VjY2FrMjI0JzogcmV0dXJuIG5ldyBLZWNjYWsoMTE1MiwgNDQ4LCBudWxsLCAyMjQsIG9wdGlvbnMpXHJcbiAgICAgIGNhc2UgJ2tlY2NhazI1Nic6IHJldHVybiBuZXcgS2VjY2FrKDEwODgsIDUxMiwgbnVsbCwgMjU2LCBvcHRpb25zKVxyXG4gICAgICBjYXNlICdrZWNjYWszODQnOiByZXR1cm4gbmV3IEtlY2Nhayg4MzIsIDc2OCwgbnVsbCwgMzg0LCBvcHRpb25zKVxyXG4gICAgICBjYXNlICdrZWNjYWs1MTInOiByZXR1cm4gbmV3IEtlY2Nhayg1NzYsIDEwMjQsIG51bGwsIDUxMiwgb3B0aW9ucylcclxuXHJcbiAgICAgIGNhc2UgJ3NoYTMtMjI0JzogcmV0dXJuIG5ldyBLZWNjYWsoMTE1MiwgNDQ4LCAweDA2LCAyMjQsIG9wdGlvbnMpXHJcbiAgICAgIGNhc2UgJ3NoYTMtMjU2JzogcmV0dXJuIG5ldyBLZWNjYWsoMTA4OCwgNTEyLCAweDA2LCAyNTYsIG9wdGlvbnMpXHJcbiAgICAgIGNhc2UgJ3NoYTMtMzg0JzogcmV0dXJuIG5ldyBLZWNjYWsoODMyLCA3NjgsIDB4MDYsIDM4NCwgb3B0aW9ucylcclxuICAgICAgY2FzZSAnc2hhMy01MTInOiByZXR1cm4gbmV3IEtlY2Nhayg1NzYsIDEwMjQsIDB4MDYsIDUxMiwgb3B0aW9ucylcclxuXHJcbiAgICAgIGNhc2UgJ3NoYWtlMTI4JzogcmV0dXJuIG5ldyBTaGFrZSgxMzQ0LCAyNTYsIDB4MWYsIG9wdGlvbnMpXHJcbiAgICAgIGNhc2UgJ3NoYWtlMjU2JzogcmV0dXJuIG5ldyBTaGFrZSgxMDg4LCA1MTIsIDB4MWYsIG9wdGlvbnMpXHJcblxyXG4gICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsZCBhbGdvcml0aG06ICcgKyBhbGdvcml0aG0pXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/keccak/lib/api/index.js\n");

/***/ }),

/***/ "./node_modules/keccak/lib/api/keccak.js":
/*!***********************************************!*\
  !*** ./node_modules/keccak/lib/api/keccak.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\nconst { Transform } = __webpack_require__(/*! readable-stream */ \"./node_modules/readable-stream/readable-browser.js\")\r\n\r\nmodule.exports = (KeccakState) => class Keccak extends Transform {\r\n  constructor (rate, capacity, delimitedSuffix, hashBitLength, options) {\r\n    super(options)\r\n\r\n    this._rate = rate\r\n    this._capacity = capacity\r\n    this._delimitedSuffix = delimitedSuffix\r\n    this._hashBitLength = hashBitLength\r\n    this._options = options\r\n\r\n    this._state = new KeccakState()\r\n    this._state.initialize(rate, capacity)\r\n    this._finalized = false\r\n  }\r\n\r\n  _transform (chunk, encoding, callback) {\r\n    let error = null\r\n    try {\r\n      this.update(chunk, encoding)\r\n    } catch (err) {\r\n      error = err\r\n    }\r\n\r\n    callback(error)\r\n  }\r\n\r\n  _flush (callback) {\r\n    let error = null\r\n    try {\r\n      this.push(this.digest())\r\n    } catch (err) {\r\n      error = err\r\n    }\r\n\r\n    callback(error)\r\n  }\r\n\r\n  update (data, encoding) {\r\n    if (!Buffer.isBuffer(data) && typeof data !== 'string') throw new TypeError('Data must be a string or a buffer')\r\n    if (this._finalized) throw new Error('Digest already called')\r\n    if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding)\r\n\r\n    this._state.absorb(data)\r\n\r\n    return this\r\n  }\r\n\r\n  digest (encoding) {\r\n    if (this._finalized) throw new Error('Digest already called')\r\n    this._finalized = true\r\n\r\n    if (this._delimitedSuffix) this._state.absorbLastFewBits(this._delimitedSuffix)\r\n    let digest = this._state.squeeze(this._hashBitLength / 8)\r\n    if (encoding !== undefined) digest = digest.toString(encoding)\r\n\r\n    this._resetState()\r\n\r\n    return digest\r\n  }\r\n\r\n  // remove result from memory\r\n  _resetState () {\r\n    this._state.initialize(this._rate, this._capacity)\r\n    return this\r\n  }\r\n\r\n  // because sometimes we need hash right now and little later\r\n  _clone () {\r\n    const clone = new Keccak(this._rate, this._capacity, this._delimitedSuffix, this._hashBitLength, this._options)\r\n    this._state.copy(clone._state)\r\n    clone._finalized = this._finalized\r\n\r\n    return clone\r\n  }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMva2VjY2FrL2xpYi9hcGkva2VjY2FrLmpzLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLDJFQUFpQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxNQUFNO0FBQ2Y7QUFDQSxTQUFTLE1BQU0sd0JBQXdCLE1BQU07QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2tlY2Nhay9saWIvYXBpL2tlY2Nhay5qcz9jNDA0Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHsgVHJhbnNmb3JtIH0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSAoS2VjY2FrU3RhdGUpID0+IGNsYXNzIEtlY2NhayBleHRlbmRzIFRyYW5zZm9ybSB7XHJcbiAgY29uc3RydWN0b3IgKHJhdGUsIGNhcGFjaXR5LCBkZWxpbWl0ZWRTdWZmaXgsIGhhc2hCaXRMZW5ndGgsIG9wdGlvbnMpIHtcclxuICAgIHN1cGVyKG9wdGlvbnMpXHJcblxyXG4gICAgdGhpcy5fcmF0ZSA9IHJhdGVcclxuICAgIHRoaXMuX2NhcGFjaXR5ID0gY2FwYWNpdHlcclxuICAgIHRoaXMuX2RlbGltaXRlZFN1ZmZpeCA9IGRlbGltaXRlZFN1ZmZpeFxyXG4gICAgdGhpcy5faGFzaEJpdExlbmd0aCA9IGhhc2hCaXRMZW5ndGhcclxuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zXHJcblxyXG4gICAgdGhpcy5fc3RhdGUgPSBuZXcgS2VjY2FrU3RhdGUoKVxyXG4gICAgdGhpcy5fc3RhdGUuaW5pdGlhbGl6ZShyYXRlLCBjYXBhY2l0eSlcclxuICAgIHRoaXMuX2ZpbmFsaXplZCA9IGZhbHNlXHJcbiAgfVxyXG5cclxuICBfdHJhbnNmb3JtIChjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XHJcbiAgICBsZXQgZXJyb3IgPSBudWxsXHJcbiAgICB0cnkge1xyXG4gICAgICB0aGlzLnVwZGF0ZShjaHVuaywgZW5jb2RpbmcpXHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgZXJyb3IgPSBlcnJcclxuICAgIH1cclxuXHJcbiAgICBjYWxsYmFjayhlcnJvcilcclxuICB9XHJcblxyXG4gIF9mbHVzaCAoY2FsbGJhY2spIHtcclxuICAgIGxldCBlcnJvciA9IG51bGxcclxuICAgIHRyeSB7XHJcbiAgICAgIHRoaXMucHVzaCh0aGlzLmRpZ2VzdCgpKVxyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGVycm9yID0gZXJyXHJcbiAgICB9XHJcblxyXG4gICAgY2FsbGJhY2soZXJyb3IpXHJcbiAgfVxyXG5cclxuICB1cGRhdGUgKGRhdGEsIGVuY29kaW5nKSB7XHJcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihkYXRhKSAmJiB0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0RhdGEgbXVzdCBiZSBhIHN0cmluZyBvciBhIGJ1ZmZlcicpXHJcbiAgICBpZiAodGhpcy5fZmluYWxpemVkKSB0aHJvdyBuZXcgRXJyb3IoJ0RpZ2VzdCBhbHJlYWR5IGNhbGxlZCcpXHJcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEsIGVuY29kaW5nKVxyXG5cclxuICAgIHRoaXMuX3N0YXRlLmFic29yYihkYXRhKVxyXG5cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICBkaWdlc3QgKGVuY29kaW5nKSB7XHJcbiAgICBpZiAodGhpcy5fZmluYWxpemVkKSB0aHJvdyBuZXcgRXJyb3IoJ0RpZ2VzdCBhbHJlYWR5IGNhbGxlZCcpXHJcbiAgICB0aGlzLl9maW5hbGl6ZWQgPSB0cnVlXHJcblxyXG4gICAgaWYgKHRoaXMuX2RlbGltaXRlZFN1ZmZpeCkgdGhpcy5fc3RhdGUuYWJzb3JiTGFzdEZld0JpdHModGhpcy5fZGVsaW1pdGVkU3VmZml4KVxyXG4gICAgbGV0IGRpZ2VzdCA9IHRoaXMuX3N0YXRlLnNxdWVlemUodGhpcy5faGFzaEJpdExlbmd0aCAvIDgpXHJcbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkgZGlnZXN0ID0gZGlnZXN0LnRvU3RyaW5nKGVuY29kaW5nKVxyXG5cclxuICAgIHRoaXMuX3Jlc2V0U3RhdGUoKVxyXG5cclxuICAgIHJldHVybiBkaWdlc3RcclxuICB9XHJcblxyXG4gIC8vIHJlbW92ZSByZXN1bHQgZnJvbSBtZW1vcnlcclxuICBfcmVzZXRTdGF0ZSAoKSB7XHJcbiAgICB0aGlzLl9zdGF0ZS5pbml0aWFsaXplKHRoaXMuX3JhdGUsIHRoaXMuX2NhcGFjaXR5KVxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIC8vIGJlY2F1c2Ugc29tZXRpbWVzIHdlIG5lZWQgaGFzaCByaWdodCBub3cgYW5kIGxpdHRsZSBsYXRlclxyXG4gIF9jbG9uZSAoKSB7XHJcbiAgICBjb25zdCBjbG9uZSA9IG5ldyBLZWNjYWsodGhpcy5fcmF0ZSwgdGhpcy5fY2FwYWNpdHksIHRoaXMuX2RlbGltaXRlZFN1ZmZpeCwgdGhpcy5faGFzaEJpdExlbmd0aCwgdGhpcy5fb3B0aW9ucylcclxuICAgIHRoaXMuX3N0YXRlLmNvcHkoY2xvbmUuX3N0YXRlKVxyXG4gICAgY2xvbmUuX2ZpbmFsaXplZCA9IHRoaXMuX2ZpbmFsaXplZFxyXG5cclxuICAgIHJldHVybiBjbG9uZVxyXG4gIH1cclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/keccak/lib/api/keccak.js\n");

/***/ }),

/***/ "./node_modules/keccak/lib/api/shake.js":
/*!**********************************************!*\
  !*** ./node_modules/keccak/lib/api/shake.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\nconst { Transform } = __webpack_require__(/*! readable-stream */ \"./node_modules/readable-stream/readable-browser.js\")\r\n\r\nmodule.exports = (KeccakState) => class Shake extends Transform {\r\n  constructor (rate, capacity, delimitedSuffix, options) {\r\n    super(options)\r\n\r\n    this._rate = rate\r\n    this._capacity = capacity\r\n    this._delimitedSuffix = delimitedSuffix\r\n    this._options = options\r\n\r\n    this._state = new KeccakState()\r\n    this._state.initialize(rate, capacity)\r\n    this._finalized = false\r\n  }\r\n\r\n  _transform (chunk, encoding, callback) {\r\n    let error = null\r\n    try {\r\n      this.update(chunk, encoding)\r\n    } catch (err) {\r\n      error = err\r\n    }\r\n\r\n    callback(error)\r\n  }\r\n\r\n  _flush () {}\r\n\r\n  _read (size) {\r\n    this.push(this.squeeze(size))\r\n  }\r\n\r\n  update (data, encoding) {\r\n    if (!Buffer.isBuffer(data) && typeof data !== 'string') throw new TypeError('Data must be a string or a buffer')\r\n    if (this._finalized) throw new Error('Squeeze already called')\r\n    if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding)\r\n\r\n    this._state.absorb(data)\r\n\r\n    return this\r\n  }\r\n\r\n  squeeze (dataByteLength, encoding) {\r\n    if (!this._finalized) {\r\n      this._finalized = true\r\n      this._state.absorbLastFewBits(this._delimitedSuffix)\r\n    }\r\n\r\n    let data = this._state.squeeze(dataByteLength)\r\n    if (encoding !== undefined) data = data.toString(encoding)\r\n\r\n    return data\r\n  }\r\n\r\n  _resetState () {\r\n    this._state.initialize(this._rate, this._capacity)\r\n    return this\r\n  }\r\n\r\n  _clone () {\r\n    const clone = new Shake(this._rate, this._capacity, this._delimitedSuffix, this._options)\r\n    this._state.copy(clone._state)\r\n    clone._finalized = this._finalized\r\n\r\n    return clone\r\n  }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMva2VjY2FrL2xpYi9hcGkvc2hha2UuanMuanMiLCJtYXBwaW5ncyI6IjtBQUFBLFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMsMkVBQWlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxNQUFNO0FBQ2Y7QUFDQSxTQUFTLE1BQU0sd0JBQXdCLE1BQU07QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2tlY2Nhay9saWIvYXBpL3NoYWtlLmpzP2M4YWMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeyBUcmFuc2Zvcm0gfSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IChLZWNjYWtTdGF0ZSkgPT4gY2xhc3MgU2hha2UgZXh0ZW5kcyBUcmFuc2Zvcm0ge1xyXG4gIGNvbnN0cnVjdG9yIChyYXRlLCBjYXBhY2l0eSwgZGVsaW1pdGVkU3VmZml4LCBvcHRpb25zKSB7XHJcbiAgICBzdXBlcihvcHRpb25zKVxyXG5cclxuICAgIHRoaXMuX3JhdGUgPSByYXRlXHJcbiAgICB0aGlzLl9jYXBhY2l0eSA9IGNhcGFjaXR5XHJcbiAgICB0aGlzLl9kZWxpbWl0ZWRTdWZmaXggPSBkZWxpbWl0ZWRTdWZmaXhcclxuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zXHJcblxyXG4gICAgdGhpcy5fc3RhdGUgPSBuZXcgS2VjY2FrU3RhdGUoKVxyXG4gICAgdGhpcy5fc3RhdGUuaW5pdGlhbGl6ZShyYXRlLCBjYXBhY2l0eSlcclxuICAgIHRoaXMuX2ZpbmFsaXplZCA9IGZhbHNlXHJcbiAgfVxyXG5cclxuICBfdHJhbnNmb3JtIChjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XHJcbiAgICBsZXQgZXJyb3IgPSBudWxsXHJcbiAgICB0cnkge1xyXG4gICAgICB0aGlzLnVwZGF0ZShjaHVuaywgZW5jb2RpbmcpXHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgZXJyb3IgPSBlcnJcclxuICAgIH1cclxuXHJcbiAgICBjYWxsYmFjayhlcnJvcilcclxuICB9XHJcblxyXG4gIF9mbHVzaCAoKSB7fVxyXG5cclxuICBfcmVhZCAoc2l6ZSkge1xyXG4gICAgdGhpcy5wdXNoKHRoaXMuc3F1ZWV6ZShzaXplKSlcclxuICB9XHJcblxyXG4gIHVwZGF0ZSAoZGF0YSwgZW5jb2RpbmcpIHtcclxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGRhdGEpICYmIHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IFR5cGVFcnJvcignRGF0YSBtdXN0IGJlIGEgc3RyaW5nIG9yIGEgYnVmZmVyJylcclxuICAgIGlmICh0aGlzLl9maW5hbGl6ZWQpIHRocm93IG5ldyBFcnJvcignU3F1ZWV6ZSBhbHJlYWR5IGNhbGxlZCcpXHJcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEsIGVuY29kaW5nKVxyXG5cclxuICAgIHRoaXMuX3N0YXRlLmFic29yYihkYXRhKVxyXG5cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICBzcXVlZXplIChkYXRhQnl0ZUxlbmd0aCwgZW5jb2RpbmcpIHtcclxuICAgIGlmICghdGhpcy5fZmluYWxpemVkKSB7XHJcbiAgICAgIHRoaXMuX2ZpbmFsaXplZCA9IHRydWVcclxuICAgICAgdGhpcy5fc3RhdGUuYWJzb3JiTGFzdEZld0JpdHModGhpcy5fZGVsaW1pdGVkU3VmZml4KVxyXG4gICAgfVxyXG5cclxuICAgIGxldCBkYXRhID0gdGhpcy5fc3RhdGUuc3F1ZWV6ZShkYXRhQnl0ZUxlbmd0aClcclxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSBkYXRhID0gZGF0YS50b1N0cmluZyhlbmNvZGluZylcclxuXHJcbiAgICByZXR1cm4gZGF0YVxyXG4gIH1cclxuXHJcbiAgX3Jlc2V0U3RhdGUgKCkge1xyXG4gICAgdGhpcy5fc3RhdGUuaW5pdGlhbGl6ZSh0aGlzLl9yYXRlLCB0aGlzLl9jYXBhY2l0eSlcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICBfY2xvbmUgKCkge1xyXG4gICAgY29uc3QgY2xvbmUgPSBuZXcgU2hha2UodGhpcy5fcmF0ZSwgdGhpcy5fY2FwYWNpdHksIHRoaXMuX2RlbGltaXRlZFN1ZmZpeCwgdGhpcy5fb3B0aW9ucylcclxuICAgIHRoaXMuX3N0YXRlLmNvcHkoY2xvbmUuX3N0YXRlKVxyXG4gICAgY2xvbmUuX2ZpbmFsaXplZCA9IHRoaXMuX2ZpbmFsaXplZFxyXG5cclxuICAgIHJldHVybiBjbG9uZVxyXG4gIH1cclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/keccak/lib/api/shake.js\n");

/***/ }),

/***/ "./node_modules/keccak/lib/keccak-state-unroll.js":
/*!********************************************************!*\
  !*** ./node_modules/keccak/lib/keccak-state-unroll.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("const P1600_ROUND_CONSTANTS = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648]\r\n\r\nexports.p1600 = function (s) {\r\n  for (let round = 0; round < 24; ++round) {\r\n    // theta\r\n    const lo0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40]\r\n    const hi0 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41]\r\n    const lo1 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42]\r\n    const hi1 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43]\r\n    const lo2 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44]\r\n    const hi2 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45]\r\n    const lo3 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46]\r\n    const hi3 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47]\r\n    const lo4 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48]\r\n    const hi4 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49]\r\n\r\n    let lo = lo4 ^ (lo1 << 1 | hi1 >>> 31)\r\n    let hi = hi4 ^ (hi1 << 1 | lo1 >>> 31)\r\n    const t1slo0 = s[0] ^ lo\r\n    const t1shi0 = s[1] ^ hi\r\n    const t1slo5 = s[10] ^ lo\r\n    const t1shi5 = s[11] ^ hi\r\n    const t1slo10 = s[20] ^ lo\r\n    const t1shi10 = s[21] ^ hi\r\n    const t1slo15 = s[30] ^ lo\r\n    const t1shi15 = s[31] ^ hi\r\n    const t1slo20 = s[40] ^ lo\r\n    const t1shi20 = s[41] ^ hi\r\n    lo = lo0 ^ (lo2 << 1 | hi2 >>> 31)\r\n    hi = hi0 ^ (hi2 << 1 | lo2 >>> 31)\r\n    const t1slo1 = s[2] ^ lo\r\n    const t1shi1 = s[3] ^ hi\r\n    const t1slo6 = s[12] ^ lo\r\n    const t1shi6 = s[13] ^ hi\r\n    const t1slo11 = s[22] ^ lo\r\n    const t1shi11 = s[23] ^ hi\r\n    const t1slo16 = s[32] ^ lo\r\n    const t1shi16 = s[33] ^ hi\r\n    const t1slo21 = s[42] ^ lo\r\n    const t1shi21 = s[43] ^ hi\r\n    lo = lo1 ^ (lo3 << 1 | hi3 >>> 31)\r\n    hi = hi1 ^ (hi3 << 1 | lo3 >>> 31)\r\n    const t1slo2 = s[4] ^ lo\r\n    const t1shi2 = s[5] ^ hi\r\n    const t1slo7 = s[14] ^ lo\r\n    const t1shi7 = s[15] ^ hi\r\n    const t1slo12 = s[24] ^ lo\r\n    const t1shi12 = s[25] ^ hi\r\n    const t1slo17 = s[34] ^ lo\r\n    const t1shi17 = s[35] ^ hi\r\n    const t1slo22 = s[44] ^ lo\r\n    const t1shi22 = s[45] ^ hi\r\n    lo = lo2 ^ (lo4 << 1 | hi4 >>> 31)\r\n    hi = hi2 ^ (hi4 << 1 | lo4 >>> 31)\r\n    const t1slo3 = s[6] ^ lo\r\n    const t1shi3 = s[7] ^ hi\r\n    const t1slo8 = s[16] ^ lo\r\n    const t1shi8 = s[17] ^ hi\r\n    const t1slo13 = s[26] ^ lo\r\n    const t1shi13 = s[27] ^ hi\r\n    const t1slo18 = s[36] ^ lo\r\n    const t1shi18 = s[37] ^ hi\r\n    const t1slo23 = s[46] ^ lo\r\n    const t1shi23 = s[47] ^ hi\r\n    lo = lo3 ^ (lo0 << 1 | hi0 >>> 31)\r\n    hi = hi3 ^ (hi0 << 1 | lo0 >>> 31)\r\n    const t1slo4 = s[8] ^ lo\r\n    const t1shi4 = s[9] ^ hi\r\n    const t1slo9 = s[18] ^ lo\r\n    const t1shi9 = s[19] ^ hi\r\n    const t1slo14 = s[28] ^ lo\r\n    const t1shi14 = s[29] ^ hi\r\n    const t1slo19 = s[38] ^ lo\r\n    const t1shi19 = s[39] ^ hi\r\n    const t1slo24 = s[48] ^ lo\r\n    const t1shi24 = s[49] ^ hi\r\n\r\n    // rho & pi\r\n    const t2slo0 = t1slo0\r\n    const t2shi0 = t1shi0\r\n    const t2slo16 = (t1shi5 << 4 | t1slo5 >>> 28)\r\n    const t2shi16 = (t1slo5 << 4 | t1shi5 >>> 28)\r\n    const t2slo7 = (t1slo10 << 3 | t1shi10 >>> 29)\r\n    const t2shi7 = (t1shi10 << 3 | t1slo10 >>> 29)\r\n    const t2slo23 = (t1shi15 << 9 | t1slo15 >>> 23)\r\n    const t2shi23 = (t1slo15 << 9 | t1shi15 >>> 23)\r\n    const t2slo14 = (t1slo20 << 18 | t1shi20 >>> 14)\r\n    const t2shi14 = (t1shi20 << 18 | t1slo20 >>> 14)\r\n    const t2slo10 = (t1slo1 << 1 | t1shi1 >>> 31)\r\n    const t2shi10 = (t1shi1 << 1 | t1slo1 >>> 31)\r\n    const t2slo1 = (t1shi6 << 12 | t1slo6 >>> 20)\r\n    const t2shi1 = (t1slo6 << 12 | t1shi6 >>> 20)\r\n    const t2slo17 = (t1slo11 << 10 | t1shi11 >>> 22)\r\n    const t2shi17 = (t1shi11 << 10 | t1slo11 >>> 22)\r\n    const t2slo8 = (t1shi16 << 13 | t1slo16 >>> 19)\r\n    const t2shi8 = (t1slo16 << 13 | t1shi16 >>> 19)\r\n    const t2slo24 = (t1slo21 << 2 | t1shi21 >>> 30)\r\n    const t2shi24 = (t1shi21 << 2 | t1slo21 >>> 30)\r\n    const t2slo20 = (t1shi2 << 30 | t1slo2 >>> 2)\r\n    const t2shi20 = (t1slo2 << 30 | t1shi2 >>> 2)\r\n    const t2slo11 = (t1slo7 << 6 | t1shi7 >>> 26)\r\n    const t2shi11 = (t1shi7 << 6 | t1slo7 >>> 26)\r\n    const t2slo2 = (t1shi12 << 11 | t1slo12 >>> 21)\r\n    const t2shi2 = (t1slo12 << 11 | t1shi12 >>> 21)\r\n    const t2slo18 = (t1slo17 << 15 | t1shi17 >>> 17)\r\n    const t2shi18 = (t1shi17 << 15 | t1slo17 >>> 17)\r\n    const t2slo9 = (t1shi22 << 29 | t1slo22 >>> 3)\r\n    const t2shi9 = (t1slo22 << 29 | t1shi22 >>> 3)\r\n    const t2slo5 = (t1slo3 << 28 | t1shi3 >>> 4)\r\n    const t2shi5 = (t1shi3 << 28 | t1slo3 >>> 4)\r\n    const t2slo21 = (t1shi8 << 23 | t1slo8 >>> 9)\r\n    const t2shi21 = (t1slo8 << 23 | t1shi8 >>> 9)\r\n    const t2slo12 = (t1slo13 << 25 | t1shi13 >>> 7)\r\n    const t2shi12 = (t1shi13 << 25 | t1slo13 >>> 7)\r\n    const t2slo3 = (t1slo18 << 21 | t1shi18 >>> 11)\r\n    const t2shi3 = (t1shi18 << 21 | t1slo18 >>> 11)\r\n    const t2slo19 = (t1shi23 << 24 | t1slo23 >>> 8)\r\n    const t2shi19 = (t1slo23 << 24 | t1shi23 >>> 8)\r\n    const t2slo15 = (t1slo4 << 27 | t1shi4 >>> 5)\r\n    const t2shi15 = (t1shi4 << 27 | t1slo4 >>> 5)\r\n    const t2slo6 = (t1slo9 << 20 | t1shi9 >>> 12)\r\n    const t2shi6 = (t1shi9 << 20 | t1slo9 >>> 12)\r\n    const t2slo22 = (t1shi14 << 7 | t1slo14 >>> 25)\r\n    const t2shi22 = (t1slo14 << 7 | t1shi14 >>> 25)\r\n    const t2slo13 = (t1slo19 << 8 | t1shi19 >>> 24)\r\n    const t2shi13 = (t1shi19 << 8 | t1slo19 >>> 24)\r\n    const t2slo4 = (t1slo24 << 14 | t1shi24 >>> 18)\r\n    const t2shi4 = (t1shi24 << 14 | t1slo24 >>> 18)\r\n\r\n    // chi\r\n    s[0] = t2slo0 ^ (~t2slo1 & t2slo2)\r\n    s[1] = t2shi0 ^ (~t2shi1 & t2shi2)\r\n    s[10] = t2slo5 ^ (~t2slo6 & t2slo7)\r\n    s[11] = t2shi5 ^ (~t2shi6 & t2shi7)\r\n    s[20] = t2slo10 ^ (~t2slo11 & t2slo12)\r\n    s[21] = t2shi10 ^ (~t2shi11 & t2shi12)\r\n    s[30] = t2slo15 ^ (~t2slo16 & t2slo17)\r\n    s[31] = t2shi15 ^ (~t2shi16 & t2shi17)\r\n    s[40] = t2slo20 ^ (~t2slo21 & t2slo22)\r\n    s[41] = t2shi20 ^ (~t2shi21 & t2shi22)\r\n    s[2] = t2slo1 ^ (~t2slo2 & t2slo3)\r\n    s[3] = t2shi1 ^ (~t2shi2 & t2shi3)\r\n    s[12] = t2slo6 ^ (~t2slo7 & t2slo8)\r\n    s[13] = t2shi6 ^ (~t2shi7 & t2shi8)\r\n    s[22] = t2slo11 ^ (~t2slo12 & t2slo13)\r\n    s[23] = t2shi11 ^ (~t2shi12 & t2shi13)\r\n    s[32] = t2slo16 ^ (~t2slo17 & t2slo18)\r\n    s[33] = t2shi16 ^ (~t2shi17 & t2shi18)\r\n    s[42] = t2slo21 ^ (~t2slo22 & t2slo23)\r\n    s[43] = t2shi21 ^ (~t2shi22 & t2shi23)\r\n    s[4] = t2slo2 ^ (~t2slo3 & t2slo4)\r\n    s[5] = t2shi2 ^ (~t2shi3 & t2shi4)\r\n    s[14] = t2slo7 ^ (~t2slo8 & t2slo9)\r\n    s[15] = t2shi7 ^ (~t2shi8 & t2shi9)\r\n    s[24] = t2slo12 ^ (~t2slo13 & t2slo14)\r\n    s[25] = t2shi12 ^ (~t2shi13 & t2shi14)\r\n    s[34] = t2slo17 ^ (~t2slo18 & t2slo19)\r\n    s[35] = t2shi17 ^ (~t2shi18 & t2shi19)\r\n    s[44] = t2slo22 ^ (~t2slo23 & t2slo24)\r\n    s[45] = t2shi22 ^ (~t2shi23 & t2shi24)\r\n    s[6] = t2slo3 ^ (~t2slo4 & t2slo0)\r\n    s[7] = t2shi3 ^ (~t2shi4 & t2shi0)\r\n    s[16] = t2slo8 ^ (~t2slo9 & t2slo5)\r\n    s[17] = t2shi8 ^ (~t2shi9 & t2shi5)\r\n    s[26] = t2slo13 ^ (~t2slo14 & t2slo10)\r\n    s[27] = t2shi13 ^ (~t2shi14 & t2shi10)\r\n    s[36] = t2slo18 ^ (~t2slo19 & t2slo15)\r\n    s[37] = t2shi18 ^ (~t2shi19 & t2shi15)\r\n    s[46] = t2slo23 ^ (~t2slo24 & t2slo20)\r\n    s[47] = t2shi23 ^ (~t2shi24 & t2shi20)\r\n    s[8] = t2slo4 ^ (~t2slo0 & t2slo1)\r\n    s[9] = t2shi4 ^ (~t2shi0 & t2shi1)\r\n    s[18] = t2slo9 ^ (~t2slo5 & t2slo6)\r\n    s[19] = t2shi9 ^ (~t2shi5 & t2shi6)\r\n    s[28] = t2slo14 ^ (~t2slo10 & t2slo11)\r\n    s[29] = t2shi14 ^ (~t2shi10 & t2shi11)\r\n    s[38] = t2slo19 ^ (~t2slo15 & t2slo16)\r\n    s[39] = t2shi19 ^ (~t2shi15 & t2shi16)\r\n    s[48] = t2slo24 ^ (~t2slo20 & t2slo21)\r\n    s[49] = t2shi24 ^ (~t2shi20 & t2shi21)\r\n\r\n    // iota\r\n    s[0] ^= P1600_ROUND_CONSTANTS[round * 2]\r\n    s[1] ^= P1600_ROUND_CONSTANTS[round * 2 + 1]\r\n  }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMva2VjY2FrL2xpYi9rZWNjYWstc3RhdGUtdW5yb2xsLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSxhQUFhO0FBQ2Isc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMva2VjY2FrL2xpYi9rZWNjYWstc3RhdGUtdW5yb2xsLmpzP2Y0MWMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgUDE2MDBfUk9VTkRfQ09OU1RBTlRTID0gWzEsIDAsIDMyODk4LCAwLCAzMjkwNiwgMjE0NzQ4MzY0OCwgMjE0NzUxNjQxNiwgMjE0NzQ4MzY0OCwgMzI5MDcsIDAsIDIxNDc0ODM2NDksIDAsIDIxNDc1MTY1NDUsIDIxNDc0ODM2NDgsIDMyNzc3LCAyMTQ3NDgzNjQ4LCAxMzgsIDAsIDEzNiwgMCwgMjE0NzUxNjQyNSwgMCwgMjE0NzQ4MzY1OCwgMCwgMjE0NzUxNjU1NSwgMCwgMTM5LCAyMTQ3NDgzNjQ4LCAzMjkwNSwgMjE0NzQ4MzY0OCwgMzI3NzEsIDIxNDc0ODM2NDgsIDMyNzcwLCAyMTQ3NDgzNjQ4LCAxMjgsIDIxNDc0ODM2NDgsIDMyNzc4LCAwLCAyMTQ3NDgzNjU4LCAyMTQ3NDgzNjQ4LCAyMTQ3NTE2NTQ1LCAyMTQ3NDgzNjQ4LCAzMjg5NiwgMjE0NzQ4MzY0OCwgMjE0NzQ4MzY0OSwgMCwgMjE0NzUxNjQyNCwgMjE0NzQ4MzY0OF1cclxuXHJcbmV4cG9ydHMucDE2MDAgPSBmdW5jdGlvbiAocykge1xyXG4gIGZvciAobGV0IHJvdW5kID0gMDsgcm91bmQgPCAyNDsgKytyb3VuZCkge1xyXG4gICAgLy8gdGhldGFcclxuICAgIGNvbnN0IGxvMCA9IHNbMF0gXiBzWzEwXSBeIHNbMjBdIF4gc1szMF0gXiBzWzQwXVxyXG4gICAgY29uc3QgaGkwID0gc1sxXSBeIHNbMTFdIF4gc1syMV0gXiBzWzMxXSBeIHNbNDFdXHJcbiAgICBjb25zdCBsbzEgPSBzWzJdIF4gc1sxMl0gXiBzWzIyXSBeIHNbMzJdIF4gc1s0Ml1cclxuICAgIGNvbnN0IGhpMSA9IHNbM10gXiBzWzEzXSBeIHNbMjNdIF4gc1szM10gXiBzWzQzXVxyXG4gICAgY29uc3QgbG8yID0gc1s0XSBeIHNbMTRdIF4gc1syNF0gXiBzWzM0XSBeIHNbNDRdXHJcbiAgICBjb25zdCBoaTIgPSBzWzVdIF4gc1sxNV0gXiBzWzI1XSBeIHNbMzVdIF4gc1s0NV1cclxuICAgIGNvbnN0IGxvMyA9IHNbNl0gXiBzWzE2XSBeIHNbMjZdIF4gc1szNl0gXiBzWzQ2XVxyXG4gICAgY29uc3QgaGkzID0gc1s3XSBeIHNbMTddIF4gc1syN10gXiBzWzM3XSBeIHNbNDddXHJcbiAgICBjb25zdCBsbzQgPSBzWzhdIF4gc1sxOF0gXiBzWzI4XSBeIHNbMzhdIF4gc1s0OF1cclxuICAgIGNvbnN0IGhpNCA9IHNbOV0gXiBzWzE5XSBeIHNbMjldIF4gc1szOV0gXiBzWzQ5XVxyXG5cclxuICAgIGxldCBsbyA9IGxvNCBeIChsbzEgPDwgMSB8IGhpMSA+Pj4gMzEpXHJcbiAgICBsZXQgaGkgPSBoaTQgXiAoaGkxIDw8IDEgfCBsbzEgPj4+IDMxKVxyXG4gICAgY29uc3QgdDFzbG8wID0gc1swXSBeIGxvXHJcbiAgICBjb25zdCB0MXNoaTAgPSBzWzFdIF4gaGlcclxuICAgIGNvbnN0IHQxc2xvNSA9IHNbMTBdIF4gbG9cclxuICAgIGNvbnN0IHQxc2hpNSA9IHNbMTFdIF4gaGlcclxuICAgIGNvbnN0IHQxc2xvMTAgPSBzWzIwXSBeIGxvXHJcbiAgICBjb25zdCB0MXNoaTEwID0gc1syMV0gXiBoaVxyXG4gICAgY29uc3QgdDFzbG8xNSA9IHNbMzBdIF4gbG9cclxuICAgIGNvbnN0IHQxc2hpMTUgPSBzWzMxXSBeIGhpXHJcbiAgICBjb25zdCB0MXNsbzIwID0gc1s0MF0gXiBsb1xyXG4gICAgY29uc3QgdDFzaGkyMCA9IHNbNDFdIF4gaGlcclxuICAgIGxvID0gbG8wIF4gKGxvMiA8PCAxIHwgaGkyID4+PiAzMSlcclxuICAgIGhpID0gaGkwIF4gKGhpMiA8PCAxIHwgbG8yID4+PiAzMSlcclxuICAgIGNvbnN0IHQxc2xvMSA9IHNbMl0gXiBsb1xyXG4gICAgY29uc3QgdDFzaGkxID0gc1szXSBeIGhpXHJcbiAgICBjb25zdCB0MXNsbzYgPSBzWzEyXSBeIGxvXHJcbiAgICBjb25zdCB0MXNoaTYgPSBzWzEzXSBeIGhpXHJcbiAgICBjb25zdCB0MXNsbzExID0gc1syMl0gXiBsb1xyXG4gICAgY29uc3QgdDFzaGkxMSA9IHNbMjNdIF4gaGlcclxuICAgIGNvbnN0IHQxc2xvMTYgPSBzWzMyXSBeIGxvXHJcbiAgICBjb25zdCB0MXNoaTE2ID0gc1szM10gXiBoaVxyXG4gICAgY29uc3QgdDFzbG8yMSA9IHNbNDJdIF4gbG9cclxuICAgIGNvbnN0IHQxc2hpMjEgPSBzWzQzXSBeIGhpXHJcbiAgICBsbyA9IGxvMSBeIChsbzMgPDwgMSB8IGhpMyA+Pj4gMzEpXHJcbiAgICBoaSA9IGhpMSBeIChoaTMgPDwgMSB8IGxvMyA+Pj4gMzEpXHJcbiAgICBjb25zdCB0MXNsbzIgPSBzWzRdIF4gbG9cclxuICAgIGNvbnN0IHQxc2hpMiA9IHNbNV0gXiBoaVxyXG4gICAgY29uc3QgdDFzbG83ID0gc1sxNF0gXiBsb1xyXG4gICAgY29uc3QgdDFzaGk3ID0gc1sxNV0gXiBoaVxyXG4gICAgY29uc3QgdDFzbG8xMiA9IHNbMjRdIF4gbG9cclxuICAgIGNvbnN0IHQxc2hpMTIgPSBzWzI1XSBeIGhpXHJcbiAgICBjb25zdCB0MXNsbzE3ID0gc1szNF0gXiBsb1xyXG4gICAgY29uc3QgdDFzaGkxNyA9IHNbMzVdIF4gaGlcclxuICAgIGNvbnN0IHQxc2xvMjIgPSBzWzQ0XSBeIGxvXHJcbiAgICBjb25zdCB0MXNoaTIyID0gc1s0NV0gXiBoaVxyXG4gICAgbG8gPSBsbzIgXiAobG80IDw8IDEgfCBoaTQgPj4+IDMxKVxyXG4gICAgaGkgPSBoaTIgXiAoaGk0IDw8IDEgfCBsbzQgPj4+IDMxKVxyXG4gICAgY29uc3QgdDFzbG8zID0gc1s2XSBeIGxvXHJcbiAgICBjb25zdCB0MXNoaTMgPSBzWzddIF4gaGlcclxuICAgIGNvbnN0IHQxc2xvOCA9IHNbMTZdIF4gbG9cclxuICAgIGNvbnN0IHQxc2hpOCA9IHNbMTddIF4gaGlcclxuICAgIGNvbnN0IHQxc2xvMTMgPSBzWzI2XSBeIGxvXHJcbiAgICBjb25zdCB0MXNoaTEzID0gc1syN10gXiBoaVxyXG4gICAgY29uc3QgdDFzbG8xOCA9IHNbMzZdIF4gbG9cclxuICAgIGNvbnN0IHQxc2hpMTggPSBzWzM3XSBeIGhpXHJcbiAgICBjb25zdCB0MXNsbzIzID0gc1s0Nl0gXiBsb1xyXG4gICAgY29uc3QgdDFzaGkyMyA9IHNbNDddIF4gaGlcclxuICAgIGxvID0gbG8zIF4gKGxvMCA8PCAxIHwgaGkwID4+PiAzMSlcclxuICAgIGhpID0gaGkzIF4gKGhpMCA8PCAxIHwgbG8wID4+PiAzMSlcclxuICAgIGNvbnN0IHQxc2xvNCA9IHNbOF0gXiBsb1xyXG4gICAgY29uc3QgdDFzaGk0ID0gc1s5XSBeIGhpXHJcbiAgICBjb25zdCB0MXNsbzkgPSBzWzE4XSBeIGxvXHJcbiAgICBjb25zdCB0MXNoaTkgPSBzWzE5XSBeIGhpXHJcbiAgICBjb25zdCB0MXNsbzE0ID0gc1syOF0gXiBsb1xyXG4gICAgY29uc3QgdDFzaGkxNCA9IHNbMjldIF4gaGlcclxuICAgIGNvbnN0IHQxc2xvMTkgPSBzWzM4XSBeIGxvXHJcbiAgICBjb25zdCB0MXNoaTE5ID0gc1szOV0gXiBoaVxyXG4gICAgY29uc3QgdDFzbG8yNCA9IHNbNDhdIF4gbG9cclxuICAgIGNvbnN0IHQxc2hpMjQgPSBzWzQ5XSBeIGhpXHJcblxyXG4gICAgLy8gcmhvICYgcGlcclxuICAgIGNvbnN0IHQyc2xvMCA9IHQxc2xvMFxyXG4gICAgY29uc3QgdDJzaGkwID0gdDFzaGkwXHJcbiAgICBjb25zdCB0MnNsbzE2ID0gKHQxc2hpNSA8PCA0IHwgdDFzbG81ID4+PiAyOClcclxuICAgIGNvbnN0IHQyc2hpMTYgPSAodDFzbG81IDw8IDQgfCB0MXNoaTUgPj4+IDI4KVxyXG4gICAgY29uc3QgdDJzbG83ID0gKHQxc2xvMTAgPDwgMyB8IHQxc2hpMTAgPj4+IDI5KVxyXG4gICAgY29uc3QgdDJzaGk3ID0gKHQxc2hpMTAgPDwgMyB8IHQxc2xvMTAgPj4+IDI5KVxyXG4gICAgY29uc3QgdDJzbG8yMyA9ICh0MXNoaTE1IDw8IDkgfCB0MXNsbzE1ID4+PiAyMylcclxuICAgIGNvbnN0IHQyc2hpMjMgPSAodDFzbG8xNSA8PCA5IHwgdDFzaGkxNSA+Pj4gMjMpXHJcbiAgICBjb25zdCB0MnNsbzE0ID0gKHQxc2xvMjAgPDwgMTggfCB0MXNoaTIwID4+PiAxNClcclxuICAgIGNvbnN0IHQyc2hpMTQgPSAodDFzaGkyMCA8PCAxOCB8IHQxc2xvMjAgPj4+IDE0KVxyXG4gICAgY29uc3QgdDJzbG8xMCA9ICh0MXNsbzEgPDwgMSB8IHQxc2hpMSA+Pj4gMzEpXHJcbiAgICBjb25zdCB0MnNoaTEwID0gKHQxc2hpMSA8PCAxIHwgdDFzbG8xID4+PiAzMSlcclxuICAgIGNvbnN0IHQyc2xvMSA9ICh0MXNoaTYgPDwgMTIgfCB0MXNsbzYgPj4+IDIwKVxyXG4gICAgY29uc3QgdDJzaGkxID0gKHQxc2xvNiA8PCAxMiB8IHQxc2hpNiA+Pj4gMjApXHJcbiAgICBjb25zdCB0MnNsbzE3ID0gKHQxc2xvMTEgPDwgMTAgfCB0MXNoaTExID4+PiAyMilcclxuICAgIGNvbnN0IHQyc2hpMTcgPSAodDFzaGkxMSA8PCAxMCB8IHQxc2xvMTEgPj4+IDIyKVxyXG4gICAgY29uc3QgdDJzbG84ID0gKHQxc2hpMTYgPDwgMTMgfCB0MXNsbzE2ID4+PiAxOSlcclxuICAgIGNvbnN0IHQyc2hpOCA9ICh0MXNsbzE2IDw8IDEzIHwgdDFzaGkxNiA+Pj4gMTkpXHJcbiAgICBjb25zdCB0MnNsbzI0ID0gKHQxc2xvMjEgPDwgMiB8IHQxc2hpMjEgPj4+IDMwKVxyXG4gICAgY29uc3QgdDJzaGkyNCA9ICh0MXNoaTIxIDw8IDIgfCB0MXNsbzIxID4+PiAzMClcclxuICAgIGNvbnN0IHQyc2xvMjAgPSAodDFzaGkyIDw8IDMwIHwgdDFzbG8yID4+PiAyKVxyXG4gICAgY29uc3QgdDJzaGkyMCA9ICh0MXNsbzIgPDwgMzAgfCB0MXNoaTIgPj4+IDIpXHJcbiAgICBjb25zdCB0MnNsbzExID0gKHQxc2xvNyA8PCA2IHwgdDFzaGk3ID4+PiAyNilcclxuICAgIGNvbnN0IHQyc2hpMTEgPSAodDFzaGk3IDw8IDYgfCB0MXNsbzcgPj4+IDI2KVxyXG4gICAgY29uc3QgdDJzbG8yID0gKHQxc2hpMTIgPDwgMTEgfCB0MXNsbzEyID4+PiAyMSlcclxuICAgIGNvbnN0IHQyc2hpMiA9ICh0MXNsbzEyIDw8IDExIHwgdDFzaGkxMiA+Pj4gMjEpXHJcbiAgICBjb25zdCB0MnNsbzE4ID0gKHQxc2xvMTcgPDwgMTUgfCB0MXNoaTE3ID4+PiAxNylcclxuICAgIGNvbnN0IHQyc2hpMTggPSAodDFzaGkxNyA8PCAxNSB8IHQxc2xvMTcgPj4+IDE3KVxyXG4gICAgY29uc3QgdDJzbG85ID0gKHQxc2hpMjIgPDwgMjkgfCB0MXNsbzIyID4+PiAzKVxyXG4gICAgY29uc3QgdDJzaGk5ID0gKHQxc2xvMjIgPDwgMjkgfCB0MXNoaTIyID4+PiAzKVxyXG4gICAgY29uc3QgdDJzbG81ID0gKHQxc2xvMyA8PCAyOCB8IHQxc2hpMyA+Pj4gNClcclxuICAgIGNvbnN0IHQyc2hpNSA9ICh0MXNoaTMgPDwgMjggfCB0MXNsbzMgPj4+IDQpXHJcbiAgICBjb25zdCB0MnNsbzIxID0gKHQxc2hpOCA8PCAyMyB8IHQxc2xvOCA+Pj4gOSlcclxuICAgIGNvbnN0IHQyc2hpMjEgPSAodDFzbG84IDw8IDIzIHwgdDFzaGk4ID4+PiA5KVxyXG4gICAgY29uc3QgdDJzbG8xMiA9ICh0MXNsbzEzIDw8IDI1IHwgdDFzaGkxMyA+Pj4gNylcclxuICAgIGNvbnN0IHQyc2hpMTIgPSAodDFzaGkxMyA8PCAyNSB8IHQxc2xvMTMgPj4+IDcpXHJcbiAgICBjb25zdCB0MnNsbzMgPSAodDFzbG8xOCA8PCAyMSB8IHQxc2hpMTggPj4+IDExKVxyXG4gICAgY29uc3QgdDJzaGkzID0gKHQxc2hpMTggPDwgMjEgfCB0MXNsbzE4ID4+PiAxMSlcclxuICAgIGNvbnN0IHQyc2xvMTkgPSAodDFzaGkyMyA8PCAyNCB8IHQxc2xvMjMgPj4+IDgpXHJcbiAgICBjb25zdCB0MnNoaTE5ID0gKHQxc2xvMjMgPDwgMjQgfCB0MXNoaTIzID4+PiA4KVxyXG4gICAgY29uc3QgdDJzbG8xNSA9ICh0MXNsbzQgPDwgMjcgfCB0MXNoaTQgPj4+IDUpXHJcbiAgICBjb25zdCB0MnNoaTE1ID0gKHQxc2hpNCA8PCAyNyB8IHQxc2xvNCA+Pj4gNSlcclxuICAgIGNvbnN0IHQyc2xvNiA9ICh0MXNsbzkgPDwgMjAgfCB0MXNoaTkgPj4+IDEyKVxyXG4gICAgY29uc3QgdDJzaGk2ID0gKHQxc2hpOSA8PCAyMCB8IHQxc2xvOSA+Pj4gMTIpXHJcbiAgICBjb25zdCB0MnNsbzIyID0gKHQxc2hpMTQgPDwgNyB8IHQxc2xvMTQgPj4+IDI1KVxyXG4gICAgY29uc3QgdDJzaGkyMiA9ICh0MXNsbzE0IDw8IDcgfCB0MXNoaTE0ID4+PiAyNSlcclxuICAgIGNvbnN0IHQyc2xvMTMgPSAodDFzbG8xOSA8PCA4IHwgdDFzaGkxOSA+Pj4gMjQpXHJcbiAgICBjb25zdCB0MnNoaTEzID0gKHQxc2hpMTkgPDwgOCB8IHQxc2xvMTkgPj4+IDI0KVxyXG4gICAgY29uc3QgdDJzbG80ID0gKHQxc2xvMjQgPDwgMTQgfCB0MXNoaTI0ID4+PiAxOClcclxuICAgIGNvbnN0IHQyc2hpNCA9ICh0MXNoaTI0IDw8IDE0IHwgdDFzbG8yNCA+Pj4gMTgpXHJcblxyXG4gICAgLy8gY2hpXHJcbiAgICBzWzBdID0gdDJzbG8wIF4gKH50MnNsbzEgJiB0MnNsbzIpXHJcbiAgICBzWzFdID0gdDJzaGkwIF4gKH50MnNoaTEgJiB0MnNoaTIpXHJcbiAgICBzWzEwXSA9IHQyc2xvNSBeICh+dDJzbG82ICYgdDJzbG83KVxyXG4gICAgc1sxMV0gPSB0MnNoaTUgXiAofnQyc2hpNiAmIHQyc2hpNylcclxuICAgIHNbMjBdID0gdDJzbG8xMCBeICh+dDJzbG8xMSAmIHQyc2xvMTIpXHJcbiAgICBzWzIxXSA9IHQyc2hpMTAgXiAofnQyc2hpMTEgJiB0MnNoaTEyKVxyXG4gICAgc1szMF0gPSB0MnNsbzE1IF4gKH50MnNsbzE2ICYgdDJzbG8xNylcclxuICAgIHNbMzFdID0gdDJzaGkxNSBeICh+dDJzaGkxNiAmIHQyc2hpMTcpXHJcbiAgICBzWzQwXSA9IHQyc2xvMjAgXiAofnQyc2xvMjEgJiB0MnNsbzIyKVxyXG4gICAgc1s0MV0gPSB0MnNoaTIwIF4gKH50MnNoaTIxICYgdDJzaGkyMilcclxuICAgIHNbMl0gPSB0MnNsbzEgXiAofnQyc2xvMiAmIHQyc2xvMylcclxuICAgIHNbM10gPSB0MnNoaTEgXiAofnQyc2hpMiAmIHQyc2hpMylcclxuICAgIHNbMTJdID0gdDJzbG82IF4gKH50MnNsbzcgJiB0MnNsbzgpXHJcbiAgICBzWzEzXSA9IHQyc2hpNiBeICh+dDJzaGk3ICYgdDJzaGk4KVxyXG4gICAgc1syMl0gPSB0MnNsbzExIF4gKH50MnNsbzEyICYgdDJzbG8xMylcclxuICAgIHNbMjNdID0gdDJzaGkxMSBeICh+dDJzaGkxMiAmIHQyc2hpMTMpXHJcbiAgICBzWzMyXSA9IHQyc2xvMTYgXiAofnQyc2xvMTcgJiB0MnNsbzE4KVxyXG4gICAgc1szM10gPSB0MnNoaTE2IF4gKH50MnNoaTE3ICYgdDJzaGkxOClcclxuICAgIHNbNDJdID0gdDJzbG8yMSBeICh+dDJzbG8yMiAmIHQyc2xvMjMpXHJcbiAgICBzWzQzXSA9IHQyc2hpMjEgXiAofnQyc2hpMjIgJiB0MnNoaTIzKVxyXG4gICAgc1s0XSA9IHQyc2xvMiBeICh+dDJzbG8zICYgdDJzbG80KVxyXG4gICAgc1s1XSA9IHQyc2hpMiBeICh+dDJzaGkzICYgdDJzaGk0KVxyXG4gICAgc1sxNF0gPSB0MnNsbzcgXiAofnQyc2xvOCAmIHQyc2xvOSlcclxuICAgIHNbMTVdID0gdDJzaGk3IF4gKH50MnNoaTggJiB0MnNoaTkpXHJcbiAgICBzWzI0XSA9IHQyc2xvMTIgXiAofnQyc2xvMTMgJiB0MnNsbzE0KVxyXG4gICAgc1syNV0gPSB0MnNoaTEyIF4gKH50MnNoaTEzICYgdDJzaGkxNClcclxuICAgIHNbMzRdID0gdDJzbG8xNyBeICh+dDJzbG8xOCAmIHQyc2xvMTkpXHJcbiAgICBzWzM1XSA9IHQyc2hpMTcgXiAofnQyc2hpMTggJiB0MnNoaTE5KVxyXG4gICAgc1s0NF0gPSB0MnNsbzIyIF4gKH50MnNsbzIzICYgdDJzbG8yNClcclxuICAgIHNbNDVdID0gdDJzaGkyMiBeICh+dDJzaGkyMyAmIHQyc2hpMjQpXHJcbiAgICBzWzZdID0gdDJzbG8zIF4gKH50MnNsbzQgJiB0MnNsbzApXHJcbiAgICBzWzddID0gdDJzaGkzIF4gKH50MnNoaTQgJiB0MnNoaTApXHJcbiAgICBzWzE2XSA9IHQyc2xvOCBeICh+dDJzbG85ICYgdDJzbG81KVxyXG4gICAgc1sxN10gPSB0MnNoaTggXiAofnQyc2hpOSAmIHQyc2hpNSlcclxuICAgIHNbMjZdID0gdDJzbG8xMyBeICh+dDJzbG8xNCAmIHQyc2xvMTApXHJcbiAgICBzWzI3XSA9IHQyc2hpMTMgXiAofnQyc2hpMTQgJiB0MnNoaTEwKVxyXG4gICAgc1szNl0gPSB0MnNsbzE4IF4gKH50MnNsbzE5ICYgdDJzbG8xNSlcclxuICAgIHNbMzddID0gdDJzaGkxOCBeICh+dDJzaGkxOSAmIHQyc2hpMTUpXHJcbiAgICBzWzQ2XSA9IHQyc2xvMjMgXiAofnQyc2xvMjQgJiB0MnNsbzIwKVxyXG4gICAgc1s0N10gPSB0MnNoaTIzIF4gKH50MnNoaTI0ICYgdDJzaGkyMClcclxuICAgIHNbOF0gPSB0MnNsbzQgXiAofnQyc2xvMCAmIHQyc2xvMSlcclxuICAgIHNbOV0gPSB0MnNoaTQgXiAofnQyc2hpMCAmIHQyc2hpMSlcclxuICAgIHNbMThdID0gdDJzbG85IF4gKH50MnNsbzUgJiB0MnNsbzYpXHJcbiAgICBzWzE5XSA9IHQyc2hpOSBeICh+dDJzaGk1ICYgdDJzaGk2KVxyXG4gICAgc1syOF0gPSB0MnNsbzE0IF4gKH50MnNsbzEwICYgdDJzbG8xMSlcclxuICAgIHNbMjldID0gdDJzaGkxNCBeICh+dDJzaGkxMCAmIHQyc2hpMTEpXHJcbiAgICBzWzM4XSA9IHQyc2xvMTkgXiAofnQyc2xvMTUgJiB0MnNsbzE2KVxyXG4gICAgc1szOV0gPSB0MnNoaTE5IF4gKH50MnNoaTE1ICYgdDJzaGkxNilcclxuICAgIHNbNDhdID0gdDJzbG8yNCBeICh+dDJzbG8yMCAmIHQyc2xvMjEpXHJcbiAgICBzWzQ5XSA9IHQyc2hpMjQgXiAofnQyc2hpMjAgJiB0MnNoaTIxKVxyXG5cclxuICAgIC8vIGlvdGFcclxuICAgIHNbMF0gXj0gUDE2MDBfUk9VTkRfQ09OU1RBTlRTW3JvdW5kICogMl1cclxuICAgIHNbMV0gXj0gUDE2MDBfUk9VTkRfQ09OU1RBTlRTW3JvdW5kICogMiArIDFdXHJcbiAgfVxyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/keccak/lib/keccak-state-unroll.js\n");

/***/ }),

/***/ "./node_modules/keccak/lib/keccak.js":
/*!*******************************************!*\
  !*** ./node_modules/keccak/lib/keccak.js ***!
  \*******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\nconst keccakState = __webpack_require__(/*! ./keccak-state-unroll */ \"./node_modules/keccak/lib/keccak-state-unroll.js\")\r\n\r\nfunction Keccak () {\r\n  // much faster than `new Array(50)`\r\n  this.state = [\r\n    0, 0, 0, 0, 0,\r\n    0, 0, 0, 0, 0,\r\n    0, 0, 0, 0, 0,\r\n    0, 0, 0, 0, 0,\r\n    0, 0, 0, 0, 0\r\n  ]\r\n\r\n  this.blockSize = null\r\n  this.count = 0\r\n  this.squeezing = false\r\n}\r\n\r\nKeccak.prototype.initialize = function (rate, capacity) {\r\n  for (let i = 0; i < 50; ++i) this.state[i] = 0\r\n  this.blockSize = rate / 8\r\n  this.count = 0\r\n  this.squeezing = false\r\n}\r\n\r\nKeccak.prototype.absorb = function (data) {\r\n  for (let i = 0; i < data.length; ++i) {\r\n    this.state[~~(this.count / 4)] ^= data[i] << (8 * (this.count % 4))\r\n    this.count += 1\r\n    if (this.count === this.blockSize) {\r\n      keccakState.p1600(this.state)\r\n      this.count = 0\r\n    }\r\n  }\r\n}\r\n\r\nKeccak.prototype.absorbLastFewBits = function (bits) {\r\n  this.state[~~(this.count / 4)] ^= bits << (8 * (this.count % 4))\r\n  if ((bits & 0x80) !== 0 && this.count === (this.blockSize - 1)) keccakState.p1600(this.state)\r\n  this.state[~~((this.blockSize - 1) / 4)] ^= 0x80 << (8 * ((this.blockSize - 1) % 4))\r\n  keccakState.p1600(this.state)\r\n  this.count = 0\r\n  this.squeezing = true\r\n}\r\n\r\nKeccak.prototype.squeeze = function (length) {\r\n  if (!this.squeezing) this.absorbLastFewBits(0x01)\r\n\r\n  const output = Buffer.alloc(length)\r\n  for (let i = 0; i < length; ++i) {\r\n    output[i] = (this.state[~~(this.count / 4)] >>> (8 * (this.count % 4))) & 0xff\r\n    this.count += 1\r\n    if (this.count === this.blockSize) {\r\n      keccakState.p1600(this.state)\r\n      this.count = 0\r\n    }\r\n  }\r\n\r\n  return output\r\n}\r\n\r\nKeccak.prototype.copy = function (dest) {\r\n  for (let i = 0; i < 50; ++i) dest.state[i] = this.state[i]\r\n  dest.blockSize = this.blockSize\r\n  dest.count = this.count\r\n  dest.squeezing = this.squeezing\r\n}\r\n\r\nmodule.exports = Keccak\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMva2VjY2FrL2xpYi9rZWNjYWsuanMuanMiLCJtYXBwaW5ncyI6IjtBQUFBLG9CQUFvQixtQkFBTyxDQUFDLCtFQUF1QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsTUFBTTtBQUN2QixrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2tlY2Nhay9saWIva2VjY2FrLmpzPzA3YjkiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qga2VjY2FrU3RhdGUgPSByZXF1aXJlKCcuL2tlY2Nhay1zdGF0ZS11bnJvbGwnKVxyXG5cclxuZnVuY3Rpb24gS2VjY2FrICgpIHtcclxuICAvLyBtdWNoIGZhc3RlciB0aGFuIGBuZXcgQXJyYXkoNTApYFxyXG4gIHRoaXMuc3RhdGUgPSBbXHJcbiAgICAwLCAwLCAwLCAwLCAwLFxyXG4gICAgMCwgMCwgMCwgMCwgMCxcclxuICAgIDAsIDAsIDAsIDAsIDAsXHJcbiAgICAwLCAwLCAwLCAwLCAwLFxyXG4gICAgMCwgMCwgMCwgMCwgMFxyXG4gIF1cclxuXHJcbiAgdGhpcy5ibG9ja1NpemUgPSBudWxsXHJcbiAgdGhpcy5jb3VudCA9IDBcclxuICB0aGlzLnNxdWVlemluZyA9IGZhbHNlXHJcbn1cclxuXHJcbktlY2Nhay5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChyYXRlLCBjYXBhY2l0eSkge1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgNTA7ICsraSkgdGhpcy5zdGF0ZVtpXSA9IDBcclxuICB0aGlzLmJsb2NrU2l6ZSA9IHJhdGUgLyA4XHJcbiAgdGhpcy5jb3VudCA9IDBcclxuICB0aGlzLnNxdWVlemluZyA9IGZhbHNlXHJcbn1cclxuXHJcbktlY2Nhay5wcm90b3R5cGUuYWJzb3JiID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcclxuICAgIHRoaXMuc3RhdGVbfn4odGhpcy5jb3VudCAvIDQpXSBePSBkYXRhW2ldIDw8ICg4ICogKHRoaXMuY291bnQgJSA0KSlcclxuICAgIHRoaXMuY291bnQgKz0gMVxyXG4gICAgaWYgKHRoaXMuY291bnQgPT09IHRoaXMuYmxvY2tTaXplKSB7XHJcbiAgICAgIGtlY2Nha1N0YXRlLnAxNjAwKHRoaXMuc3RhdGUpXHJcbiAgICAgIHRoaXMuY291bnQgPSAwXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5LZWNjYWsucHJvdG90eXBlLmFic29yYkxhc3RGZXdCaXRzID0gZnVuY3Rpb24gKGJpdHMpIHtcclxuICB0aGlzLnN0YXRlW35+KHRoaXMuY291bnQgLyA0KV0gXj0gYml0cyA8PCAoOCAqICh0aGlzLmNvdW50ICUgNCkpXHJcbiAgaWYgKChiaXRzICYgMHg4MCkgIT09IDAgJiYgdGhpcy5jb3VudCA9PT0gKHRoaXMuYmxvY2tTaXplIC0gMSkpIGtlY2Nha1N0YXRlLnAxNjAwKHRoaXMuc3RhdGUpXHJcbiAgdGhpcy5zdGF0ZVt+figodGhpcy5ibG9ja1NpemUgLSAxKSAvIDQpXSBePSAweDgwIDw8ICg4ICogKCh0aGlzLmJsb2NrU2l6ZSAtIDEpICUgNCkpXHJcbiAga2VjY2FrU3RhdGUucDE2MDAodGhpcy5zdGF0ZSlcclxuICB0aGlzLmNvdW50ID0gMFxyXG4gIHRoaXMuc3F1ZWV6aW5nID0gdHJ1ZVxyXG59XHJcblxyXG5LZWNjYWsucHJvdG90eXBlLnNxdWVlemUgPSBmdW5jdGlvbiAobGVuZ3RoKSB7XHJcbiAgaWYgKCF0aGlzLnNxdWVlemluZykgdGhpcy5hYnNvcmJMYXN0RmV3Qml0cygweDAxKVxyXG5cclxuICBjb25zdCBvdXRwdXQgPSBCdWZmZXIuYWxsb2MobGVuZ3RoKVxyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgIG91dHB1dFtpXSA9ICh0aGlzLnN0YXRlW35+KHRoaXMuY291bnQgLyA0KV0gPj4+ICg4ICogKHRoaXMuY291bnQgJSA0KSkpICYgMHhmZlxyXG4gICAgdGhpcy5jb3VudCArPSAxXHJcbiAgICBpZiAodGhpcy5jb3VudCA9PT0gdGhpcy5ibG9ja1NpemUpIHtcclxuICAgICAga2VjY2FrU3RhdGUucDE2MDAodGhpcy5zdGF0ZSlcclxuICAgICAgdGhpcy5jb3VudCA9IDBcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBvdXRwdXRcclxufVxyXG5cclxuS2VjY2FrLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKGRlc3QpIHtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IDUwOyArK2kpIGRlc3Quc3RhdGVbaV0gPSB0aGlzLnN0YXRlW2ldXHJcbiAgZGVzdC5ibG9ja1NpemUgPSB0aGlzLmJsb2NrU2l6ZVxyXG4gIGRlc3QuY291bnQgPSB0aGlzLmNvdW50XHJcbiAgZGVzdC5zcXVlZXppbmcgPSB0aGlzLnNxdWVlemluZ1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEtlY2Nha1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/keccak/lib/keccak.js\n");

/***/ }),

/***/ "./node_modules/lodash.merge/index.js":
/*!********************************************!*\
  !*** ./node_modules/lodash.merge/index.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n/**\r\n * Lodash (Custom Build) <https://lodash.com/>\r\n * Build: `lodash modularize exports=\"npm\" -o ./`\r\n * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>\r\n * Released under MIT license <https://lodash.com/license>\r\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\r\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\r\n */\r\n\r\n/** Used as the size to enable large array optimizations. */\r\nvar LARGE_ARRAY_SIZE = 200;\r\n\r\n/** Used to stand-in for `undefined` hash values. */\r\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\r\n\r\n/** Used to detect hot functions by number of calls within a span of milliseconds. */\r\nvar HOT_COUNT = 800,\r\n    HOT_SPAN = 16;\r\n\r\n/** Used as references for various `Number` constants. */\r\nvar MAX_SAFE_INTEGER = 9007199254740991;\r\n\r\n/** `Object#toString` result references. */\r\nvar argsTag = '[object Arguments]',\r\n    arrayTag = '[object Array]',\r\n    asyncTag = '[object AsyncFunction]',\r\n    boolTag = '[object Boolean]',\r\n    dateTag = '[object Date]',\r\n    errorTag = '[object Error]',\r\n    funcTag = '[object Function]',\r\n    genTag = '[object GeneratorFunction]',\r\n    mapTag = '[object Map]',\r\n    numberTag = '[object Number]',\r\n    nullTag = '[object Null]',\r\n    objectTag = '[object Object]',\r\n    proxyTag = '[object Proxy]',\r\n    regexpTag = '[object RegExp]',\r\n    setTag = '[object Set]',\r\n    stringTag = '[object String]',\r\n    undefinedTag = '[object Undefined]',\r\n    weakMapTag = '[object WeakMap]';\r\n\r\nvar arrayBufferTag = '[object ArrayBuffer]',\r\n    dataViewTag = '[object DataView]',\r\n    float32Tag = '[object Float32Array]',\r\n    float64Tag = '[object Float64Array]',\r\n    int8Tag = '[object Int8Array]',\r\n    int16Tag = '[object Int16Array]',\r\n    int32Tag = '[object Int32Array]',\r\n    uint8Tag = '[object Uint8Array]',\r\n    uint8ClampedTag = '[object Uint8ClampedArray]',\r\n    uint16Tag = '[object Uint16Array]',\r\n    uint32Tag = '[object Uint32Array]';\r\n\r\n/**\r\n * Used to match `RegExp`\r\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\r\n */\r\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\r\n\r\n/** Used to detect host constructors (Safari). */\r\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\r\n\r\n/** Used to detect unsigned integer values. */\r\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\r\n\r\n/** Used to identify `toStringTag` values of typed arrays. */\r\nvar typedArrayTags = {};\r\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\r\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\r\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\r\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\r\ntypedArrayTags[uint32Tag] = true;\r\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\r\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\r\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\r\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\r\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\r\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\r\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\r\ntypedArrayTags[weakMapTag] = false;\r\n\r\n/** Detect free variable `global` from Node.js. */\r\nvar freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;\r\n\r\n/** Detect free variable `self`. */\r\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\r\n\r\n/** Used as a reference to the global object. */\r\nvar root = freeGlobal || freeSelf || Function('return this')();\r\n\r\n/** Detect free variable `exports`. */\r\nvar freeExports =  true && exports && !exports.nodeType && exports;\r\n\r\n/** Detect free variable `module`. */\r\nvar freeModule = freeExports && \"object\" == 'object' && module && !module.nodeType && module;\r\n\r\n/** Detect the popular CommonJS extension `module.exports`. */\r\nvar moduleExports = freeModule && freeModule.exports === freeExports;\r\n\r\n/** Detect free variable `process` from Node.js. */\r\nvar freeProcess = moduleExports && freeGlobal.process;\r\n\r\n/** Used to access faster Node.js helpers. */\r\nvar nodeUtil = (function() {\r\n  try {\r\n    // Use `util.types` for Node.js 10+.\r\n    var types = freeModule && freeModule.require && freeModule.require('util').types;\r\n\r\n    if (types) {\r\n      return types;\r\n    }\r\n\r\n    // Legacy `process.binding('util')` for Node.js < 10.\r\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\r\n  } catch (e) {}\r\n}());\r\n\r\n/* Node.js helper references. */\r\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\r\n\r\n/**\r\n * A faster alternative to `Function#apply`, this function invokes `func`\r\n * with the `this` binding of `thisArg` and the arguments of `args`.\r\n *\r\n * @private\r\n * @param {Function} func The function to invoke.\r\n * @param {*} thisArg The `this` binding of `func`.\r\n * @param {Array} args The arguments to invoke `func` with.\r\n * @returns {*} Returns the result of `func`.\r\n */\r\nfunction apply(func, thisArg, args) {\r\n  switch (args.length) {\r\n    case 0: return func.call(thisArg);\r\n    case 1: return func.call(thisArg, args[0]);\r\n    case 2: return func.call(thisArg, args[0], args[1]);\r\n    case 3: return func.call(thisArg, args[0], args[1], args[2]);\r\n  }\r\n  return func.apply(thisArg, args);\r\n}\r\n\r\n/**\r\n * The base implementation of `_.times` without support for iteratee shorthands\r\n * or max array length checks.\r\n *\r\n * @private\r\n * @param {number} n The number of times to invoke `iteratee`.\r\n * @param {Function} iteratee The function invoked per iteration.\r\n * @returns {Array} Returns the array of results.\r\n */\r\nfunction baseTimes(n, iteratee) {\r\n  var index = -1,\r\n      result = Array(n);\r\n\r\n  while (++index < n) {\r\n    result[index] = iteratee(index);\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * The base implementation of `_.unary` without support for storing metadata.\r\n *\r\n * @private\r\n * @param {Function} func The function to cap arguments for.\r\n * @returns {Function} Returns the new capped function.\r\n */\r\nfunction baseUnary(func) {\r\n  return function(value) {\r\n    return func(value);\r\n  };\r\n}\r\n\r\n/**\r\n * Gets the value at `key` of `object`.\r\n *\r\n * @private\r\n * @param {Object} [object] The object to query.\r\n * @param {string} key The key of the property to get.\r\n * @returns {*} Returns the property value.\r\n */\r\nfunction getValue(object, key) {\r\n  return object == null ? undefined : object[key];\r\n}\r\n\r\n/**\r\n * Creates a unary function that invokes `func` with its argument transformed.\r\n *\r\n * @private\r\n * @param {Function} func The function to wrap.\r\n * @param {Function} transform The argument transform.\r\n * @returns {Function} Returns the new function.\r\n */\r\nfunction overArg(func, transform) {\r\n  return function(arg) {\r\n    return func(transform(arg));\r\n  };\r\n}\r\n\r\n/** Used for built-in method references. */\r\nvar arrayProto = Array.prototype,\r\n    funcProto = Function.prototype,\r\n    objectProto = Object.prototype;\r\n\r\n/** Used to detect overreaching core-js shims. */\r\nvar coreJsData = root['__core-js_shared__'];\r\n\r\n/** Used to resolve the decompiled source of functions. */\r\nvar funcToString = funcProto.toString;\r\n\r\n/** Used to check objects for own properties. */\r\nvar hasOwnProperty = objectProto.hasOwnProperty;\r\n\r\n/** Used to detect methods masquerading as native. */\r\nvar maskSrcKey = (function() {\r\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\r\n  return uid ? ('Symbol(src)_1.' + uid) : '';\r\n}());\r\n\r\n/**\r\n * Used to resolve the\r\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\r\n * of values.\r\n */\r\nvar nativeObjectToString = objectProto.toString;\r\n\r\n/** Used to infer the `Object` constructor. */\r\nvar objectCtorString = funcToString.call(Object);\r\n\r\n/** Used to detect if a method is native. */\r\nvar reIsNative = RegExp('^' +\r\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\r\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\r\n);\r\n\r\n/** Built-in value references. */\r\nvar Buffer = moduleExports ? root.Buffer : undefined,\r\n    Symbol = root.Symbol,\r\n    Uint8Array = root.Uint8Array,\r\n    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,\r\n    getPrototype = overArg(Object.getPrototypeOf, Object),\r\n    objectCreate = Object.create,\r\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\r\n    splice = arrayProto.splice,\r\n    symToStringTag = Symbol ? Symbol.toStringTag : undefined;\r\n\r\nvar defineProperty = (function() {\r\n  try {\r\n    var func = getNative(Object, 'defineProperty');\r\n    func({}, '', {});\r\n    return func;\r\n  } catch (e) {}\r\n}());\r\n\r\n/* Built-in method references for those with the same name as other `lodash` methods. */\r\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\r\n    nativeMax = Math.max,\r\n    nativeNow = Date.now;\r\n\r\n/* Built-in method references that are verified to be native. */\r\nvar Map = getNative(root, 'Map'),\r\n    nativeCreate = getNative(Object, 'create');\r\n\r\n/**\r\n * The base implementation of `_.create` without support for assigning\r\n * properties to the created object.\r\n *\r\n * @private\r\n * @param {Object} proto The object to inherit from.\r\n * @returns {Object} Returns the new object.\r\n */\r\nvar baseCreate = (function() {\r\n  function object() {}\r\n  return function(proto) {\r\n    if (!isObject(proto)) {\r\n      return {};\r\n    }\r\n    if (objectCreate) {\r\n      return objectCreate(proto);\r\n    }\r\n    object.prototype = proto;\r\n    var result = new object;\r\n    object.prototype = undefined;\r\n    return result;\r\n  };\r\n}());\r\n\r\n/**\r\n * Creates a hash object.\r\n *\r\n * @private\r\n * @constructor\r\n * @param {Array} [entries] The key-value pairs to cache.\r\n */\r\nfunction Hash(entries) {\r\n  var index = -1,\r\n      length = entries == null ? 0 : entries.length;\r\n\r\n  this.clear();\r\n  while (++index < length) {\r\n    var entry = entries[index];\r\n    this.set(entry[0], entry[1]);\r\n  }\r\n}\r\n\r\n/**\r\n * Removes all key-value entries from the hash.\r\n *\r\n * @private\r\n * @name clear\r\n * @memberOf Hash\r\n */\r\nfunction hashClear() {\r\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\r\n  this.size = 0;\r\n}\r\n\r\n/**\r\n * Removes `key` and its value from the hash.\r\n *\r\n * @private\r\n * @name delete\r\n * @memberOf Hash\r\n * @param {Object} hash The hash to modify.\r\n * @param {string} key The key of the value to remove.\r\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\r\n */\r\nfunction hashDelete(key) {\r\n  var result = this.has(key) && delete this.__data__[key];\r\n  this.size -= result ? 1 : 0;\r\n  return result;\r\n}\r\n\r\n/**\r\n * Gets the hash value for `key`.\r\n *\r\n * @private\r\n * @name get\r\n * @memberOf Hash\r\n * @param {string} key The key of the value to get.\r\n * @returns {*} Returns the entry value.\r\n */\r\nfunction hashGet(key) {\r\n  var data = this.__data__;\r\n  if (nativeCreate) {\r\n    var result = data[key];\r\n    return result === HASH_UNDEFINED ? undefined : result;\r\n  }\r\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\r\n}\r\n\r\n/**\r\n * Checks if a hash value for `key` exists.\r\n *\r\n * @private\r\n * @name has\r\n * @memberOf Hash\r\n * @param {string} key The key of the entry to check.\r\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\r\n */\r\nfunction hashHas(key) {\r\n  var data = this.__data__;\r\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\r\n}\r\n\r\n/**\r\n * Sets the hash `key` to `value`.\r\n *\r\n * @private\r\n * @name set\r\n * @memberOf Hash\r\n * @param {string} key The key of the value to set.\r\n * @param {*} value The value to set.\r\n * @returns {Object} Returns the hash instance.\r\n */\r\nfunction hashSet(key, value) {\r\n  var data = this.__data__;\r\n  this.size += this.has(key) ? 0 : 1;\r\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\r\n  return this;\r\n}\r\n\r\n// Add methods to `Hash`.\r\nHash.prototype.clear = hashClear;\r\nHash.prototype['delete'] = hashDelete;\r\nHash.prototype.get = hashGet;\r\nHash.prototype.has = hashHas;\r\nHash.prototype.set = hashSet;\r\n\r\n/**\r\n * Creates an list cache object.\r\n *\r\n * @private\r\n * @constructor\r\n * @param {Array} [entries] The key-value pairs to cache.\r\n */\r\nfunction ListCache(entries) {\r\n  var index = -1,\r\n      length = entries == null ? 0 : entries.length;\r\n\r\n  this.clear();\r\n  while (++index < length) {\r\n    var entry = entries[index];\r\n    this.set(entry[0], entry[1]);\r\n  }\r\n}\r\n\r\n/**\r\n * Removes all key-value entries from the list cache.\r\n *\r\n * @private\r\n * @name clear\r\n * @memberOf ListCache\r\n */\r\nfunction listCacheClear() {\r\n  this.__data__ = [];\r\n  this.size = 0;\r\n}\r\n\r\n/**\r\n * Removes `key` and its value from the list cache.\r\n *\r\n * @private\r\n * @name delete\r\n * @memberOf ListCache\r\n * @param {string} key The key of the value to remove.\r\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\r\n */\r\nfunction listCacheDelete(key) {\r\n  var data = this.__data__,\r\n      index = assocIndexOf(data, key);\r\n\r\n  if (index < 0) {\r\n    return false;\r\n  }\r\n  var lastIndex = data.length - 1;\r\n  if (index == lastIndex) {\r\n    data.pop();\r\n  } else {\r\n    splice.call(data, index, 1);\r\n  }\r\n  --this.size;\r\n  return true;\r\n}\r\n\r\n/**\r\n * Gets the list cache value for `key`.\r\n *\r\n * @private\r\n * @name get\r\n * @memberOf ListCache\r\n * @param {string} key The key of the value to get.\r\n * @returns {*} Returns the entry value.\r\n */\r\nfunction listCacheGet(key) {\r\n  var data = this.__data__,\r\n      index = assocIndexOf(data, key);\r\n\r\n  return index < 0 ? undefined : data[index][1];\r\n}\r\n\r\n/**\r\n * Checks if a list cache value for `key` exists.\r\n *\r\n * @private\r\n * @name has\r\n * @memberOf ListCache\r\n * @param {string} key The key of the entry to check.\r\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\r\n */\r\nfunction listCacheHas(key) {\r\n  return assocIndexOf(this.__data__, key) > -1;\r\n}\r\n\r\n/**\r\n * Sets the list cache `key` to `value`.\r\n *\r\n * @private\r\n * @name set\r\n * @memberOf ListCache\r\n * @param {string} key The key of the value to set.\r\n * @param {*} value The value to set.\r\n * @returns {Object} Returns the list cache instance.\r\n */\r\nfunction listCacheSet(key, value) {\r\n  var data = this.__data__,\r\n      index = assocIndexOf(data, key);\r\n\r\n  if (index < 0) {\r\n    ++this.size;\r\n    data.push([key, value]);\r\n  } else {\r\n    data[index][1] = value;\r\n  }\r\n  return this;\r\n}\r\n\r\n// Add methods to `ListCache`.\r\nListCache.prototype.clear = listCacheClear;\r\nListCache.prototype['delete'] = listCacheDelete;\r\nListCache.prototype.get = listCacheGet;\r\nListCache.prototype.has = listCacheHas;\r\nListCache.prototype.set = listCacheSet;\r\n\r\n/**\r\n * Creates a map cache object to store key-value pairs.\r\n *\r\n * @private\r\n * @constructor\r\n * @param {Array} [entries] The key-value pairs to cache.\r\n */\r\nfunction MapCache(entries) {\r\n  var index = -1,\r\n      length = entries == null ? 0 : entries.length;\r\n\r\n  this.clear();\r\n  while (++index < length) {\r\n    var entry = entries[index];\r\n    this.set(entry[0], entry[1]);\r\n  }\r\n}\r\n\r\n/**\r\n * Removes all key-value entries from the map.\r\n *\r\n * @private\r\n * @name clear\r\n * @memberOf MapCache\r\n */\r\nfunction mapCacheClear() {\r\n  this.size = 0;\r\n  this.__data__ = {\r\n    'hash': new Hash,\r\n    'map': new (Map || ListCache),\r\n    'string': new Hash\r\n  };\r\n}\r\n\r\n/**\r\n * Removes `key` and its value from the map.\r\n *\r\n * @private\r\n * @name delete\r\n * @memberOf MapCache\r\n * @param {string} key The key of the value to remove.\r\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\r\n */\r\nfunction mapCacheDelete(key) {\r\n  var result = getMapData(this, key)['delete'](key);\r\n  this.size -= result ? 1 : 0;\r\n  return result;\r\n}\r\n\r\n/**\r\n * Gets the map value for `key`.\r\n *\r\n * @private\r\n * @name get\r\n * @memberOf MapCache\r\n * @param {string} key The key of the value to get.\r\n * @returns {*} Returns the entry value.\r\n */\r\nfunction mapCacheGet(key) {\r\n  return getMapData(this, key).get(key);\r\n}\r\n\r\n/**\r\n * Checks if a map value for `key` exists.\r\n *\r\n * @private\r\n * @name has\r\n * @memberOf MapCache\r\n * @param {string} key The key of the entry to check.\r\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\r\n */\r\nfunction mapCacheHas(key) {\r\n  return getMapData(this, key).has(key);\r\n}\r\n\r\n/**\r\n * Sets the map `key` to `value`.\r\n *\r\n * @private\r\n * @name set\r\n * @memberOf MapCache\r\n * @param {string} key The key of the value to set.\r\n * @param {*} value The value to set.\r\n * @returns {Object} Returns the map cache instance.\r\n */\r\nfunction mapCacheSet(key, value) {\r\n  var data = getMapData(this, key),\r\n      size = data.size;\r\n\r\n  data.set(key, value);\r\n  this.size += data.size == size ? 0 : 1;\r\n  return this;\r\n}\r\n\r\n// Add methods to `MapCache`.\r\nMapCache.prototype.clear = mapCacheClear;\r\nMapCache.prototype['delete'] = mapCacheDelete;\r\nMapCache.prototype.get = mapCacheGet;\r\nMapCache.prototype.has = mapCacheHas;\r\nMapCache.prototype.set = mapCacheSet;\r\n\r\n/**\r\n * Creates a stack cache object to store key-value pairs.\r\n *\r\n * @private\r\n * @constructor\r\n * @param {Array} [entries] The key-value pairs to cache.\r\n */\r\nfunction Stack(entries) {\r\n  var data = this.__data__ = new ListCache(entries);\r\n  this.size = data.size;\r\n}\r\n\r\n/**\r\n * Removes all key-value entries from the stack.\r\n *\r\n * @private\r\n * @name clear\r\n * @memberOf Stack\r\n */\r\nfunction stackClear() {\r\n  this.__data__ = new ListCache;\r\n  this.size = 0;\r\n}\r\n\r\n/**\r\n * Removes `key` and its value from the stack.\r\n *\r\n * @private\r\n * @name delete\r\n * @memberOf Stack\r\n * @param {string} key The key of the value to remove.\r\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\r\n */\r\nfunction stackDelete(key) {\r\n  var data = this.__data__,\r\n      result = data['delete'](key);\r\n\r\n  this.size = data.size;\r\n  return result;\r\n}\r\n\r\n/**\r\n * Gets the stack value for `key`.\r\n *\r\n * @private\r\n * @name get\r\n * @memberOf Stack\r\n * @param {string} key The key of the value to get.\r\n * @returns {*} Returns the entry value.\r\n */\r\nfunction stackGet(key) {\r\n  return this.__data__.get(key);\r\n}\r\n\r\n/**\r\n * Checks if a stack value for `key` exists.\r\n *\r\n * @private\r\n * @name has\r\n * @memberOf Stack\r\n * @param {string} key The key of the entry to check.\r\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\r\n */\r\nfunction stackHas(key) {\r\n  return this.__data__.has(key);\r\n}\r\n\r\n/**\r\n * Sets the stack `key` to `value`.\r\n *\r\n * @private\r\n * @name set\r\n * @memberOf Stack\r\n * @param {string} key The key of the value to set.\r\n * @param {*} value The value to set.\r\n * @returns {Object} Returns the stack cache instance.\r\n */\r\nfunction stackSet(key, value) {\r\n  var data = this.__data__;\r\n  if (data instanceof ListCache) {\r\n    var pairs = data.__data__;\r\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\r\n      pairs.push([key, value]);\r\n      this.size = ++data.size;\r\n      return this;\r\n    }\r\n    data = this.__data__ = new MapCache(pairs);\r\n  }\r\n  data.set(key, value);\r\n  this.size = data.size;\r\n  return this;\r\n}\r\n\r\n// Add methods to `Stack`.\r\nStack.prototype.clear = stackClear;\r\nStack.prototype['delete'] = stackDelete;\r\nStack.prototype.get = stackGet;\r\nStack.prototype.has = stackHas;\r\nStack.prototype.set = stackSet;\r\n\r\n/**\r\n * Creates an array of the enumerable property names of the array-like `value`.\r\n *\r\n * @private\r\n * @param {*} value The value to query.\r\n * @param {boolean} inherited Specify returning inherited property names.\r\n * @returns {Array} Returns the array of property names.\r\n */\r\nfunction arrayLikeKeys(value, inherited) {\r\n  var isArr = isArray(value),\r\n      isArg = !isArr && isArguments(value),\r\n      isBuff = !isArr && !isArg && isBuffer(value),\r\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\r\n      skipIndexes = isArr || isArg || isBuff || isType,\r\n      result = skipIndexes ? baseTimes(value.length, String) : [],\r\n      length = result.length;\r\n\r\n  for (var key in value) {\r\n    if ((inherited || hasOwnProperty.call(value, key)) &&\r\n        !(skipIndexes && (\r\n           // Safari 9 has enumerable `arguments.length` in strict mode.\r\n           key == 'length' ||\r\n           // Node.js 0.10 has enumerable non-index properties on buffers.\r\n           (isBuff && (key == 'offset' || key == 'parent')) ||\r\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\r\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\r\n           // Skip index properties.\r\n           isIndex(key, length)\r\n        ))) {\r\n      result.push(key);\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * This function is like `assignValue` except that it doesn't assign\r\n * `undefined` values.\r\n *\r\n * @private\r\n * @param {Object} object The object to modify.\r\n * @param {string} key The key of the property to assign.\r\n * @param {*} value The value to assign.\r\n */\r\nfunction assignMergeValue(object, key, value) {\r\n  if ((value !== undefined && !eq(object[key], value)) ||\r\n      (value === undefined && !(key in object))) {\r\n    baseAssignValue(object, key, value);\r\n  }\r\n}\r\n\r\n/**\r\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\r\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\r\n * for equality comparisons.\r\n *\r\n * @private\r\n * @param {Object} object The object to modify.\r\n * @param {string} key The key of the property to assign.\r\n * @param {*} value The value to assign.\r\n */\r\nfunction assignValue(object, key, value) {\r\n  var objValue = object[key];\r\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\r\n      (value === undefined && !(key in object))) {\r\n    baseAssignValue(object, key, value);\r\n  }\r\n}\r\n\r\n/**\r\n * Gets the index at which the `key` is found in `array` of key-value pairs.\r\n *\r\n * @private\r\n * @param {Array} array The array to inspect.\r\n * @param {*} key The key to search for.\r\n * @returns {number} Returns the index of the matched value, else `-1`.\r\n */\r\nfunction assocIndexOf(array, key) {\r\n  var length = array.length;\r\n  while (length--) {\r\n    if (eq(array[length][0], key)) {\r\n      return length;\r\n    }\r\n  }\r\n  return -1;\r\n}\r\n\r\n/**\r\n * The base implementation of `assignValue` and `assignMergeValue` without\r\n * value checks.\r\n *\r\n * @private\r\n * @param {Object} object The object to modify.\r\n * @param {string} key The key of the property to assign.\r\n * @param {*} value The value to assign.\r\n */\r\nfunction baseAssignValue(object, key, value) {\r\n  if (key == '__proto__' && defineProperty) {\r\n    defineProperty(object, key, {\r\n      'configurable': true,\r\n      'enumerable': true,\r\n      'value': value,\r\n      'writable': true\r\n    });\r\n  } else {\r\n    object[key] = value;\r\n  }\r\n}\r\n\r\n/**\r\n * The base implementation of `baseForOwn` which iterates over `object`\r\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\r\n * Iteratee functions may exit iteration early by explicitly returning `false`.\r\n *\r\n * @private\r\n * @param {Object} object The object to iterate over.\r\n * @param {Function} iteratee The function invoked per iteration.\r\n * @param {Function} keysFunc The function to get the keys of `object`.\r\n * @returns {Object} Returns `object`.\r\n */\r\nvar baseFor = createBaseFor();\r\n\r\n/**\r\n * The base implementation of `getTag` without fallbacks for buggy environments.\r\n *\r\n * @private\r\n * @param {*} value The value to query.\r\n * @returns {string} Returns the `toStringTag`.\r\n */\r\nfunction baseGetTag(value) {\r\n  if (value == null) {\r\n    return value === undefined ? undefinedTag : nullTag;\r\n  }\r\n  return (symToStringTag && symToStringTag in Object(value))\r\n    ? getRawTag(value)\r\n    : objectToString(value);\r\n}\r\n\r\n/**\r\n * The base implementation of `_.isArguments`.\r\n *\r\n * @private\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\r\n */\r\nfunction baseIsArguments(value) {\r\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\r\n}\r\n\r\n/**\r\n * The base implementation of `_.isNative` without bad shim checks.\r\n *\r\n * @private\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is a native function,\r\n *  else `false`.\r\n */\r\nfunction baseIsNative(value) {\r\n  if (!isObject(value) || isMasked(value)) {\r\n    return false;\r\n  }\r\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\r\n  return pattern.test(toSource(value));\r\n}\r\n\r\n/**\r\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\r\n *\r\n * @private\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\r\n */\r\nfunction baseIsTypedArray(value) {\r\n  return isObjectLike(value) &&\r\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\r\n}\r\n\r\n/**\r\n * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\r\n *\r\n * @private\r\n * @param {Object} object The object to query.\r\n * @returns {Array} Returns the array of property names.\r\n */\r\nfunction baseKeysIn(object) {\r\n  if (!isObject(object)) {\r\n    return nativeKeysIn(object);\r\n  }\r\n  var isProto = isPrototype(object),\r\n      result = [];\r\n\r\n  for (var key in object) {\r\n    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\r\n      result.push(key);\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * The base implementation of `_.merge` without support for multiple sources.\r\n *\r\n * @private\r\n * @param {Object} object The destination object.\r\n * @param {Object} source The source object.\r\n * @param {number} srcIndex The index of `source`.\r\n * @param {Function} [customizer] The function to customize merged values.\r\n * @param {Object} [stack] Tracks traversed source values and their merged\r\n *  counterparts.\r\n */\r\nfunction baseMerge(object, source, srcIndex, customizer, stack) {\r\n  if (object === source) {\r\n    return;\r\n  }\r\n  baseFor(source, function(srcValue, key) {\r\n    stack || (stack = new Stack);\r\n    if (isObject(srcValue)) {\r\n      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\r\n    }\r\n    else {\r\n      var newValue = customizer\r\n        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)\r\n        : undefined;\r\n\r\n      if (newValue === undefined) {\r\n        newValue = srcValue;\r\n      }\r\n      assignMergeValue(object, key, newValue);\r\n    }\r\n  }, keysIn);\r\n}\r\n\r\n/**\r\n * A specialized version of `baseMerge` for arrays and objects which performs\r\n * deep merges and tracks traversed objects enabling objects with circular\r\n * references to be merged.\r\n *\r\n * @private\r\n * @param {Object} object The destination object.\r\n * @param {Object} source The source object.\r\n * @param {string} key The key of the value to merge.\r\n * @param {number} srcIndex The index of `source`.\r\n * @param {Function} mergeFunc The function to merge values.\r\n * @param {Function} [customizer] The function to customize assigned values.\r\n * @param {Object} [stack] Tracks traversed source values and their merged\r\n *  counterparts.\r\n */\r\nfunction baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\r\n  var objValue = safeGet(object, key),\r\n      srcValue = safeGet(source, key),\r\n      stacked = stack.get(srcValue);\r\n\r\n  if (stacked) {\r\n    assignMergeValue(object, key, stacked);\r\n    return;\r\n  }\r\n  var newValue = customizer\r\n    ? customizer(objValue, srcValue, (key + ''), object, source, stack)\r\n    : undefined;\r\n\r\n  var isCommon = newValue === undefined;\r\n\r\n  if (isCommon) {\r\n    var isArr = isArray(srcValue),\r\n        isBuff = !isArr && isBuffer(srcValue),\r\n        isTyped = !isArr && !isBuff && isTypedArray(srcValue);\r\n\r\n    newValue = srcValue;\r\n    if (isArr || isBuff || isTyped) {\r\n      if (isArray(objValue)) {\r\n        newValue = objValue;\r\n      }\r\n      else if (isArrayLikeObject(objValue)) {\r\n        newValue = copyArray(objValue);\r\n      }\r\n      else if (isBuff) {\r\n        isCommon = false;\r\n        newValue = cloneBuffer(srcValue, true);\r\n      }\r\n      else if (isTyped) {\r\n        isCommon = false;\r\n        newValue = cloneTypedArray(srcValue, true);\r\n      }\r\n      else {\r\n        newValue = [];\r\n      }\r\n    }\r\n    else if (isPlainObject(srcValue) || isArguments(srcValue)) {\r\n      newValue = objValue;\r\n      if (isArguments(objValue)) {\r\n        newValue = toPlainObject(objValue);\r\n      }\r\n      else if (!isObject(objValue) || isFunction(objValue)) {\r\n        newValue = initCloneObject(srcValue);\r\n      }\r\n    }\r\n    else {\r\n      isCommon = false;\r\n    }\r\n  }\r\n  if (isCommon) {\r\n    // Recursively merge objects and arrays (susceptible to call stack limits).\r\n    stack.set(srcValue, newValue);\r\n    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\r\n    stack['delete'](srcValue);\r\n  }\r\n  assignMergeValue(object, key, newValue);\r\n}\r\n\r\n/**\r\n * The base implementation of `_.rest` which doesn't validate or coerce arguments.\r\n *\r\n * @private\r\n * @param {Function} func The function to apply a rest parameter to.\r\n * @param {number} [start=func.length-1] The start position of the rest parameter.\r\n * @returns {Function} Returns the new function.\r\n */\r\nfunction baseRest(func, start) {\r\n  return setToString(overRest(func, start, identity), func + '');\r\n}\r\n\r\n/**\r\n * The base implementation of `setToString` without support for hot loop shorting.\r\n *\r\n * @private\r\n * @param {Function} func The function to modify.\r\n * @param {Function} string The `toString` result.\r\n * @returns {Function} Returns `func`.\r\n */\r\nvar baseSetToString = !defineProperty ? identity : function(func, string) {\r\n  return defineProperty(func, 'toString', {\r\n    'configurable': true,\r\n    'enumerable': false,\r\n    'value': constant(string),\r\n    'writable': true\r\n  });\r\n};\r\n\r\n/**\r\n * Creates a clone of  `buffer`.\r\n *\r\n * @private\r\n * @param {Buffer} buffer The buffer to clone.\r\n * @param {boolean} [isDeep] Specify a deep clone.\r\n * @returns {Buffer} Returns the cloned buffer.\r\n */\r\nfunction cloneBuffer(buffer, isDeep) {\r\n  if (isDeep) {\r\n    return buffer.slice();\r\n  }\r\n  var length = buffer.length,\r\n      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\r\n\r\n  buffer.copy(result);\r\n  return result;\r\n}\r\n\r\n/**\r\n * Creates a clone of `arrayBuffer`.\r\n *\r\n * @private\r\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\r\n * @returns {ArrayBuffer} Returns the cloned array buffer.\r\n */\r\nfunction cloneArrayBuffer(arrayBuffer) {\r\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\r\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\r\n  return result;\r\n}\r\n\r\n/**\r\n * Creates a clone of `typedArray`.\r\n *\r\n * @private\r\n * @param {Object} typedArray The typed array to clone.\r\n * @param {boolean} [isDeep] Specify a deep clone.\r\n * @returns {Object} Returns the cloned typed array.\r\n */\r\nfunction cloneTypedArray(typedArray, isDeep) {\r\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\r\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\r\n}\r\n\r\n/**\r\n * Copies the values of `source` to `array`.\r\n *\r\n * @private\r\n * @param {Array} source The array to copy values from.\r\n * @param {Array} [array=[]] The array to copy values to.\r\n * @returns {Array} Returns `array`.\r\n */\r\nfunction copyArray(source, array) {\r\n  var index = -1,\r\n      length = source.length;\r\n\r\n  array || (array = Array(length));\r\n  while (++index < length) {\r\n    array[index] = source[index];\r\n  }\r\n  return array;\r\n}\r\n\r\n/**\r\n * Copies properties of `source` to `object`.\r\n *\r\n * @private\r\n * @param {Object} source The object to copy properties from.\r\n * @param {Array} props The property identifiers to copy.\r\n * @param {Object} [object={}] The object to copy properties to.\r\n * @param {Function} [customizer] The function to customize copied values.\r\n * @returns {Object} Returns `object`.\r\n */\r\nfunction copyObject(source, props, object, customizer) {\r\n  var isNew = !object;\r\n  object || (object = {});\r\n\r\n  var index = -1,\r\n      length = props.length;\r\n\r\n  while (++index < length) {\r\n    var key = props[index];\r\n\r\n    var newValue = customizer\r\n      ? customizer(object[key], source[key], key, object, source)\r\n      : undefined;\r\n\r\n    if (newValue === undefined) {\r\n      newValue = source[key];\r\n    }\r\n    if (isNew) {\r\n      baseAssignValue(object, key, newValue);\r\n    } else {\r\n      assignValue(object, key, newValue);\r\n    }\r\n  }\r\n  return object;\r\n}\r\n\r\n/**\r\n * Creates a function like `_.assign`.\r\n *\r\n * @private\r\n * @param {Function} assigner The function to assign values.\r\n * @returns {Function} Returns the new assigner function.\r\n */\r\nfunction createAssigner(assigner) {\r\n  return baseRest(function(object, sources) {\r\n    var index = -1,\r\n        length = sources.length,\r\n        customizer = length > 1 ? sources[length - 1] : undefined,\r\n        guard = length > 2 ? sources[2] : undefined;\r\n\r\n    customizer = (assigner.length > 3 && typeof customizer == 'function')\r\n      ? (length--, customizer)\r\n      : undefined;\r\n\r\n    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\r\n      customizer = length < 3 ? undefined : customizer;\r\n      length = 1;\r\n    }\r\n    object = Object(object);\r\n    while (++index < length) {\r\n      var source = sources[index];\r\n      if (source) {\r\n        assigner(object, source, index, customizer);\r\n      }\r\n    }\r\n    return object;\r\n  });\r\n}\r\n\r\n/**\r\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\r\n *\r\n * @private\r\n * @param {boolean} [fromRight] Specify iterating from right to left.\r\n * @returns {Function} Returns the new base function.\r\n */\r\nfunction createBaseFor(fromRight) {\r\n  return function(object, iteratee, keysFunc) {\r\n    var index = -1,\r\n        iterable = Object(object),\r\n        props = keysFunc(object),\r\n        length = props.length;\r\n\r\n    while (length--) {\r\n      var key = props[fromRight ? length : ++index];\r\n      if (iteratee(iterable[key], key, iterable) === false) {\r\n        break;\r\n      }\r\n    }\r\n    return object;\r\n  };\r\n}\r\n\r\n/**\r\n * Gets the data for `map`.\r\n *\r\n * @private\r\n * @param {Object} map The map to query.\r\n * @param {string} key The reference key.\r\n * @returns {*} Returns the map data.\r\n */\r\nfunction getMapData(map, key) {\r\n  var data = map.__data__;\r\n  return isKeyable(key)\r\n    ? data[typeof key == 'string' ? 'string' : 'hash']\r\n    : data.map;\r\n}\r\n\r\n/**\r\n * Gets the native function at `key` of `object`.\r\n *\r\n * @private\r\n * @param {Object} object The object to query.\r\n * @param {string} key The key of the method to get.\r\n * @returns {*} Returns the function if it's native, else `undefined`.\r\n */\r\nfunction getNative(object, key) {\r\n  var value = getValue(object, key);\r\n  return baseIsNative(value) ? value : undefined;\r\n}\r\n\r\n/**\r\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\r\n *\r\n * @private\r\n * @param {*} value The value to query.\r\n * @returns {string} Returns the raw `toStringTag`.\r\n */\r\nfunction getRawTag(value) {\r\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\r\n      tag = value[symToStringTag];\r\n\r\n  try {\r\n    value[symToStringTag] = undefined;\r\n    var unmasked = true;\r\n  } catch (e) {}\r\n\r\n  var result = nativeObjectToString.call(value);\r\n  if (unmasked) {\r\n    if (isOwn) {\r\n      value[symToStringTag] = tag;\r\n    } else {\r\n      delete value[symToStringTag];\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * Initializes an object clone.\r\n *\r\n * @private\r\n * @param {Object} object The object to clone.\r\n * @returns {Object} Returns the initialized clone.\r\n */\r\nfunction initCloneObject(object) {\r\n  return (typeof object.constructor == 'function' && !isPrototype(object))\r\n    ? baseCreate(getPrototype(object))\r\n    : {};\r\n}\r\n\r\n/**\r\n * Checks if `value` is a valid array-like index.\r\n *\r\n * @private\r\n * @param {*} value The value to check.\r\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\r\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\r\n */\r\nfunction isIndex(value, length) {\r\n  var type = typeof value;\r\n  length = length == null ? MAX_SAFE_INTEGER : length;\r\n\r\n  return !!length &&\r\n    (type == 'number' ||\r\n      (type != 'symbol' && reIsUint.test(value))) &&\r\n        (value > -1 && value % 1 == 0 && value < length);\r\n}\r\n\r\n/**\r\n * Checks if the given arguments are from an iteratee call.\r\n *\r\n * @private\r\n * @param {*} value The potential iteratee value argument.\r\n * @param {*} index The potential iteratee index or key argument.\r\n * @param {*} object The potential iteratee object argument.\r\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\r\n *  else `false`.\r\n */\r\nfunction isIterateeCall(value, index, object) {\r\n  if (!isObject(object)) {\r\n    return false;\r\n  }\r\n  var type = typeof index;\r\n  if (type == 'number'\r\n        ? (isArrayLike(object) && isIndex(index, object.length))\r\n        : (type == 'string' && index in object)\r\n      ) {\r\n    return eq(object[index], value);\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * Checks if `value` is suitable for use as unique object key.\r\n *\r\n * @private\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\r\n */\r\nfunction isKeyable(value) {\r\n  var type = typeof value;\r\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\r\n    ? (value !== '__proto__')\r\n    : (value === null);\r\n}\r\n\r\n/**\r\n * Checks if `func` has its source masked.\r\n *\r\n * @private\r\n * @param {Function} func The function to check.\r\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\r\n */\r\nfunction isMasked(func) {\r\n  return !!maskSrcKey && (maskSrcKey in func);\r\n}\r\n\r\n/**\r\n * Checks if `value` is likely a prototype object.\r\n *\r\n * @private\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\r\n */\r\nfunction isPrototype(value) {\r\n  var Ctor = value && value.constructor,\r\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\r\n\r\n  return value === proto;\r\n}\r\n\r\n/**\r\n * This function is like\r\n * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\r\n * except that it includes inherited enumerable properties.\r\n *\r\n * @private\r\n * @param {Object} object The object to query.\r\n * @returns {Array} Returns the array of property names.\r\n */\r\nfunction nativeKeysIn(object) {\r\n  var result = [];\r\n  if (object != null) {\r\n    for (var key in Object(object)) {\r\n      result.push(key);\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * Converts `value` to a string using `Object.prototype.toString`.\r\n *\r\n * @private\r\n * @param {*} value The value to convert.\r\n * @returns {string} Returns the converted string.\r\n */\r\nfunction objectToString(value) {\r\n  return nativeObjectToString.call(value);\r\n}\r\n\r\n/**\r\n * A specialized version of `baseRest` which transforms the rest array.\r\n *\r\n * @private\r\n * @param {Function} func The function to apply a rest parameter to.\r\n * @param {number} [start=func.length-1] The start position of the rest parameter.\r\n * @param {Function} transform The rest array transform.\r\n * @returns {Function} Returns the new function.\r\n */\r\nfunction overRest(func, start, transform) {\r\n  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\r\n  return function() {\r\n    var args = arguments,\r\n        index = -1,\r\n        length = nativeMax(args.length - start, 0),\r\n        array = Array(length);\r\n\r\n    while (++index < length) {\r\n      array[index] = args[start + index];\r\n    }\r\n    index = -1;\r\n    var otherArgs = Array(start + 1);\r\n    while (++index < start) {\r\n      otherArgs[index] = args[index];\r\n    }\r\n    otherArgs[start] = transform(array);\r\n    return apply(func, this, otherArgs);\r\n  };\r\n}\r\n\r\n/**\r\n * Gets the value at `key`, unless `key` is \"__proto__\" or \"constructor\".\r\n *\r\n * @private\r\n * @param {Object} object The object to query.\r\n * @param {string} key The key of the property to get.\r\n * @returns {*} Returns the property value.\r\n */\r\nfunction safeGet(object, key) {\r\n  if (key === 'constructor' && typeof object[key] === 'function') {\r\n    return;\r\n  }\r\n\r\n  if (key == '__proto__') {\r\n    return;\r\n  }\r\n\r\n  return object[key];\r\n}\r\n\r\n/**\r\n * Sets the `toString` method of `func` to return `string`.\r\n *\r\n * @private\r\n * @param {Function} func The function to modify.\r\n * @param {Function} string The `toString` result.\r\n * @returns {Function} Returns `func`.\r\n */\r\nvar setToString = shortOut(baseSetToString);\r\n\r\n/**\r\n * Creates a function that'll short out and invoke `identity` instead\r\n * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\r\n * milliseconds.\r\n *\r\n * @private\r\n * @param {Function} func The function to restrict.\r\n * @returns {Function} Returns the new shortable function.\r\n */\r\nfunction shortOut(func) {\r\n  var count = 0,\r\n      lastCalled = 0;\r\n\r\n  return function() {\r\n    var stamp = nativeNow(),\r\n        remaining = HOT_SPAN - (stamp - lastCalled);\r\n\r\n    lastCalled = stamp;\r\n    if (remaining > 0) {\r\n      if (++count >= HOT_COUNT) {\r\n        return arguments[0];\r\n      }\r\n    } else {\r\n      count = 0;\r\n    }\r\n    return func.apply(undefined, arguments);\r\n  };\r\n}\r\n\r\n/**\r\n * Converts `func` to its source code.\r\n *\r\n * @private\r\n * @param {Function} func The function to convert.\r\n * @returns {string} Returns the source code.\r\n */\r\nfunction toSource(func) {\r\n  if (func != null) {\r\n    try {\r\n      return funcToString.call(func);\r\n    } catch (e) {}\r\n    try {\r\n      return (func + '');\r\n    } catch (e) {}\r\n  }\r\n  return '';\r\n}\r\n\r\n/**\r\n * Performs a\r\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\r\n * comparison between two values to determine if they are equivalent.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.0.0\r\n * @category Lang\r\n * @param {*} value The value to compare.\r\n * @param {*} other The other value to compare.\r\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\r\n * @example\r\n *\r\n * var object = { 'a': 1 };\r\n * var other = { 'a': 1 };\r\n *\r\n * _.eq(object, object);\r\n * // => true\r\n *\r\n * _.eq(object, other);\r\n * // => false\r\n *\r\n * _.eq('a', 'a');\r\n * // => true\r\n *\r\n * _.eq('a', Object('a'));\r\n * // => false\r\n *\r\n * _.eq(NaN, NaN);\r\n * // => true\r\n */\r\nfunction eq(value, other) {\r\n  return value === other || (value !== value && other !== other);\r\n}\r\n\r\n/**\r\n * Checks if `value` is likely an `arguments` object.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 0.1.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\r\n *  else `false`.\r\n * @example\r\n *\r\n * _.isArguments(function() { return arguments; }());\r\n * // => true\r\n *\r\n * _.isArguments([1, 2, 3]);\r\n * // => false\r\n */\r\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\r\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\r\n    !propertyIsEnumerable.call(value, 'callee');\r\n};\r\n\r\n/**\r\n * Checks if `value` is classified as an `Array` object.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 0.1.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\r\n * @example\r\n *\r\n * _.isArray([1, 2, 3]);\r\n * // => true\r\n *\r\n * _.isArray(document.body.children);\r\n * // => false\r\n *\r\n * _.isArray('abc');\r\n * // => false\r\n *\r\n * _.isArray(_.noop);\r\n * // => false\r\n */\r\nvar isArray = Array.isArray;\r\n\r\n/**\r\n * Checks if `value` is array-like. A value is considered array-like if it's\r\n * not a function and has a `value.length` that's an integer greater than or\r\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.0.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\r\n * @example\r\n *\r\n * _.isArrayLike([1, 2, 3]);\r\n * // => true\r\n *\r\n * _.isArrayLike(document.body.children);\r\n * // => true\r\n *\r\n * _.isArrayLike('abc');\r\n * // => true\r\n *\r\n * _.isArrayLike(_.noop);\r\n * // => false\r\n */\r\nfunction isArrayLike(value) {\r\n  return value != null && isLength(value.length) && !isFunction(value);\r\n}\r\n\r\n/**\r\n * This method is like `_.isArrayLike` except that it also checks if `value`\r\n * is an object.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.0.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is an array-like object,\r\n *  else `false`.\r\n * @example\r\n *\r\n * _.isArrayLikeObject([1, 2, 3]);\r\n * // => true\r\n *\r\n * _.isArrayLikeObject(document.body.children);\r\n * // => true\r\n *\r\n * _.isArrayLikeObject('abc');\r\n * // => false\r\n *\r\n * _.isArrayLikeObject(_.noop);\r\n * // => false\r\n */\r\nfunction isArrayLikeObject(value) {\r\n  return isObjectLike(value) && isArrayLike(value);\r\n}\r\n\r\n/**\r\n * Checks if `value` is a buffer.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.3.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\r\n * @example\r\n *\r\n * _.isBuffer(new Buffer(2));\r\n * // => true\r\n *\r\n * _.isBuffer(new Uint8Array(2));\r\n * // => false\r\n */\r\nvar isBuffer = nativeIsBuffer || stubFalse;\r\n\r\n/**\r\n * Checks if `value` is classified as a `Function` object.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 0.1.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\r\n * @example\r\n *\r\n * _.isFunction(_);\r\n * // => true\r\n *\r\n * _.isFunction(/abc/);\r\n * // => false\r\n */\r\nfunction isFunction(value) {\r\n  if (!isObject(value)) {\r\n    return false;\r\n  }\r\n  // The use of `Object#toString` avoids issues with the `typeof` operator\r\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\r\n  var tag = baseGetTag(value);\r\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\r\n}\r\n\r\n/**\r\n * Checks if `value` is a valid array-like length.\r\n *\r\n * **Note:** This method is loosely based on\r\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.0.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\r\n * @example\r\n *\r\n * _.isLength(3);\r\n * // => true\r\n *\r\n * _.isLength(Number.MIN_VALUE);\r\n * // => false\r\n *\r\n * _.isLength(Infinity);\r\n * // => false\r\n *\r\n * _.isLength('3');\r\n * // => false\r\n */\r\nfunction isLength(value) {\r\n  return typeof value == 'number' &&\r\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\r\n}\r\n\r\n/**\r\n * Checks if `value` is the\r\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\r\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 0.1.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\r\n * @example\r\n *\r\n * _.isObject({});\r\n * // => true\r\n *\r\n * _.isObject([1, 2, 3]);\r\n * // => true\r\n *\r\n * _.isObject(_.noop);\r\n * // => true\r\n *\r\n * _.isObject(null);\r\n * // => false\r\n */\r\nfunction isObject(value) {\r\n  var type = typeof value;\r\n  return value != null && (type == 'object' || type == 'function');\r\n}\r\n\r\n/**\r\n * Checks if `value` is object-like. A value is object-like if it's not `null`\r\n * and has a `typeof` result of \"object\".\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.0.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\r\n * @example\r\n *\r\n * _.isObjectLike({});\r\n * // => true\r\n *\r\n * _.isObjectLike([1, 2, 3]);\r\n * // => true\r\n *\r\n * _.isObjectLike(_.noop);\r\n * // => false\r\n *\r\n * _.isObjectLike(null);\r\n * // => false\r\n */\r\nfunction isObjectLike(value) {\r\n  return value != null && typeof value == 'object';\r\n}\r\n\r\n/**\r\n * Checks if `value` is a plain object, that is, an object created by the\r\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 0.8.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\r\n * @example\r\n *\r\n * function Foo() {\r\n *   this.a = 1;\r\n * }\r\n *\r\n * _.isPlainObject(new Foo);\r\n * // => false\r\n *\r\n * _.isPlainObject([1, 2, 3]);\r\n * // => false\r\n *\r\n * _.isPlainObject({ 'x': 0, 'y': 0 });\r\n * // => true\r\n *\r\n * _.isPlainObject(Object.create(null));\r\n * // => true\r\n */\r\nfunction isPlainObject(value) {\r\n  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\r\n    return false;\r\n  }\r\n  var proto = getPrototype(value);\r\n  if (proto === null) {\r\n    return true;\r\n  }\r\n  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\r\n  return typeof Ctor == 'function' && Ctor instanceof Ctor &&\r\n    funcToString.call(Ctor) == objectCtorString;\r\n}\r\n\r\n/**\r\n * Checks if `value` is classified as a typed array.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 3.0.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\r\n * @example\r\n *\r\n * _.isTypedArray(new Uint8Array);\r\n * // => true\r\n *\r\n * _.isTypedArray([]);\r\n * // => false\r\n */\r\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\r\n\r\n/**\r\n * Converts `value` to a plain object flattening inherited enumerable string\r\n * keyed properties of `value` to own properties of the plain object.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 3.0.0\r\n * @category Lang\r\n * @param {*} value The value to convert.\r\n * @returns {Object} Returns the converted plain object.\r\n * @example\r\n *\r\n * function Foo() {\r\n *   this.b = 2;\r\n * }\r\n *\r\n * Foo.prototype.c = 3;\r\n *\r\n * _.assign({ 'a': 1 }, new Foo);\r\n * // => { 'a': 1, 'b': 2 }\r\n *\r\n * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\r\n * // => { 'a': 1, 'b': 2, 'c': 3 }\r\n */\r\nfunction toPlainObject(value) {\r\n  return copyObject(value, keysIn(value));\r\n}\r\n\r\n/**\r\n * Creates an array of the own and inherited enumerable property names of `object`.\r\n *\r\n * **Note:** Non-object values are coerced to objects.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 3.0.0\r\n * @category Object\r\n * @param {Object} object The object to query.\r\n * @returns {Array} Returns the array of property names.\r\n * @example\r\n *\r\n * function Foo() {\r\n *   this.a = 1;\r\n *   this.b = 2;\r\n * }\r\n *\r\n * Foo.prototype.c = 3;\r\n *\r\n * _.keysIn(new Foo);\r\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\r\n */\r\nfunction keysIn(object) {\r\n  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\r\n}\r\n\r\n/**\r\n * This method is like `_.assign` except that it recursively merges own and\r\n * inherited enumerable string keyed properties of source objects into the\r\n * destination object. Source properties that resolve to `undefined` are\r\n * skipped if a destination value exists. Array and plain object properties\r\n * are merged recursively. Other objects and value types are overridden by\r\n * assignment. Source objects are applied from left to right. Subsequent\r\n * sources overwrite property assignments of previous sources.\r\n *\r\n * **Note:** This method mutates `object`.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 0.5.0\r\n * @category Object\r\n * @param {Object} object The destination object.\r\n * @param {...Object} [sources] The source objects.\r\n * @returns {Object} Returns `object`.\r\n * @example\r\n *\r\n * var object = {\r\n *   'a': [{ 'b': 2 }, { 'd': 4 }]\r\n * };\r\n *\r\n * var other = {\r\n *   'a': [{ 'c': 3 }, { 'e': 5 }]\r\n * };\r\n *\r\n * _.merge(object, other);\r\n * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }\r\n */\r\nvar merge = createAssigner(function(object, source, srcIndex) {\r\n  baseMerge(object, source, srcIndex);\r\n});\r\n\r\n/**\r\n * Creates a function that returns `value`.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 2.4.0\r\n * @category Util\r\n * @param {*} value The value to return from the new function.\r\n * @returns {Function} Returns the new constant function.\r\n * @example\r\n *\r\n * var objects = _.times(2, _.constant({ 'a': 1 }));\r\n *\r\n * console.log(objects);\r\n * // => [{ 'a': 1 }, { 'a': 1 }]\r\n *\r\n * console.log(objects[0] === objects[1]);\r\n * // => true\r\n */\r\nfunction constant(value) {\r\n  return function() {\r\n    return value;\r\n  };\r\n}\r\n\r\n/**\r\n * This method returns the first argument it receives.\r\n *\r\n * @static\r\n * @since 0.1.0\r\n * @memberOf _\r\n * @category Util\r\n * @param {*} value Any value.\r\n * @returns {*} Returns `value`.\r\n * @example\r\n *\r\n * var object = { 'a': 1 };\r\n *\r\n * console.log(_.identity(object) === object);\r\n * // => true\r\n */\r\nfunction identity(value) {\r\n  return value;\r\n}\r\n\r\n/**\r\n * This method returns `false`.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.13.0\r\n * @category Util\r\n * @returns {boolean} Returns `false`.\r\n * @example\r\n *\r\n * _.times(2, _.stubFalse);\r\n * // => [false, false]\r\n */\r\nfunction stubFalse() {\r\n  return false;\r\n}\r\n\r\nmodule.exports = merge;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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IndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC5tZXJnZS9pbmRleC5qcz8wZjA4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBMb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XHJcbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxyXG4gKiBDb3B5cmlnaHQgT3BlbkpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9vcGVuanNmLm9yZy8+XHJcbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cclxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cclxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXHJcbiAqL1xyXG5cclxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXHJcbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xyXG5cclxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xyXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XHJcblxyXG4vKiogVXNlZCB0byBkZXRlY3QgaG90IGZ1bmN0aW9ucyBieSBudW1iZXIgb2YgY2FsbHMgd2l0aGluIGEgc3BhbiBvZiBtaWxsaXNlY29uZHMuICovXHJcbnZhciBIT1RfQ09VTlQgPSA4MDAsXHJcbiAgICBIT1RfU1BBTiA9IDE2O1xyXG5cclxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXHJcbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcclxuXHJcbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cclxudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcclxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcclxuICAgIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxyXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcclxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXHJcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXHJcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcclxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXHJcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcclxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxyXG4gICAgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcclxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxyXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nLFxyXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXHJcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcclxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxyXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXScsXHJcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xyXG5cclxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcclxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcclxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcclxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcclxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcclxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxyXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXHJcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcclxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXHJcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxyXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcclxuXHJcbi8qKlxyXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXHJcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxyXG4gKi9cclxudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcclxuXHJcbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cclxudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XHJcblxyXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXHJcbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XHJcblxyXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXHJcbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xyXG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cclxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxyXG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxyXG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XHJcbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xyXG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XHJcbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cclxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxyXG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XHJcbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cclxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxyXG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XHJcbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XHJcblxyXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xyXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XHJcblxyXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xyXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcclxuXHJcbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xyXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcclxuXHJcbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXHJcbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcclxuXHJcbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cclxudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcclxuXHJcbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXHJcbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xyXG5cclxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXHJcbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xyXG5cclxuLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXHJcbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcclxuICB0cnkge1xyXG4gICAgLy8gVXNlIGB1dGlsLnR5cGVzYCBmb3IgTm9kZS5qcyAxMCsuXHJcbiAgICB2YXIgdHlwZXMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUucmVxdWlyZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUoJ3V0aWwnKS50eXBlcztcclxuXHJcbiAgICBpZiAodHlwZXMpIHtcclxuICAgICAgcmV0dXJuIHR5cGVzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIExlZ2FjeSBgcHJvY2Vzcy5iaW5kaW5nKCd1dGlsJylgIGZvciBOb2RlLmpzIDwgMTAuXHJcbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XHJcbiAgfSBjYXRjaCAoZSkge31cclxufSgpKTtcclxuXHJcbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXHJcbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xyXG5cclxuLyoqXHJcbiAqIEEgZmFzdGVyIGFsdGVybmF0aXZlIHRvIGBGdW5jdGlvbiNhcHBseWAsIHRoaXMgZnVuY3Rpb24gaW52b2tlcyBgZnVuY2BcclxuICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxyXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cclxuICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cclxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXHJcbiAqL1xyXG5mdW5jdGlvbiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKSB7XHJcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xyXG4gICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcpO1xyXG4gICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0pO1xyXG4gICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xyXG4gICAgY2FzZSAzOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xyXG4gIH1cclxuICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcclxuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXHJcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cclxuICovXHJcbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xyXG4gIHZhciBpbmRleCA9IC0xLFxyXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcclxuXHJcbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XHJcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG4vKipcclxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXHJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cclxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXHJcbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cclxuICovXHJcbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XHJcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cclxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXHJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcclxuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XHJcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XHJcbiAgfTtcclxufVxyXG5cclxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xyXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSxcclxuICAgIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcclxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcclxuXHJcbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cclxudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcclxuXHJcbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cclxudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcclxuXHJcbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xyXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcclxuXHJcbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXHJcbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xyXG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XHJcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xyXG59KCkpO1xyXG5cclxuLyoqXHJcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcclxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXHJcbiAqIG9mIHZhbHVlcy5cclxuICovXHJcbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xyXG5cclxuLyoqIFVzZWQgdG8gaW5mZXIgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLiAqL1xyXG52YXIgb2JqZWN0Q3RvclN0cmluZyA9IGZ1bmNUb1N0cmluZy5jYWxsKE9iamVjdCk7XHJcblxyXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xyXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xyXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXHJcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXHJcbik7XHJcblxyXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cclxudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcclxuICAgIFN5bWJvbCA9IHJvb3QuU3ltYm9sLFxyXG4gICAgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheSxcclxuICAgIGFsbG9jVW5zYWZlID0gQnVmZmVyID8gQnVmZmVyLmFsbG9jVW5zYWZlIDogdW5kZWZpbmVkLFxyXG4gICAgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCksXHJcbiAgICBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlLFxyXG4gICAgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZSxcclxuICAgIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlLFxyXG4gICAgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XHJcblxyXG52YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XHJcbiAgdHJ5IHtcclxuICAgIHZhciBmdW5jID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2RlZmluZVByb3BlcnR5Jyk7XHJcbiAgICBmdW5jKHt9LCAnJywge30pO1xyXG4gICAgcmV0dXJuIGZ1bmM7XHJcbiAgfSBjYXRjaCAoZSkge31cclxufSgpKTtcclxuXHJcbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cclxudmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkLFxyXG4gICAgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXHJcbiAgICBuYXRpdmVOb3cgPSBEYXRlLm5vdztcclxuXHJcbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cclxudmFyIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyksXHJcbiAgICBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XHJcblxyXG4vKipcclxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xyXG4gKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxyXG4gKi9cclxudmFyIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XHJcbiAgZnVuY3Rpb24gb2JqZWN0KCkge31cclxuICByZXR1cm4gZnVuY3Rpb24ocHJvdG8pIHtcclxuICAgIGlmICghaXNPYmplY3QocHJvdG8pKSB7XHJcbiAgICAgIHJldHVybiB7fTtcclxuICAgIH1cclxuICAgIGlmIChvYmplY3RDcmVhdGUpIHtcclxuICAgICAgcmV0dXJuIG9iamVjdENyZWF0ZShwcm90byk7XHJcbiAgICB9XHJcbiAgICBvYmplY3QucHJvdG90eXBlID0gcHJvdG87XHJcbiAgICB2YXIgcmVzdWx0ID0gbmV3IG9iamVjdDtcclxuICAgIG9iamVjdC5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH07XHJcbn0oKSk7XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXHJcbiAqL1xyXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcclxuICB2YXIgaW5kZXggPSAtMSxcclxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xyXG5cclxuICB0aGlzLmNsZWFyKCk7XHJcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcclxuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xyXG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAbmFtZSBjbGVhclxyXG4gKiBAbWVtYmVyT2YgSGFzaFxyXG4gKi9cclxuZnVuY3Rpb24gaGFzaENsZWFyKCkge1xyXG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcclxuICB0aGlzLnNpemUgPSAwO1xyXG59XHJcblxyXG4vKipcclxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBuYW1lIGRlbGV0ZVxyXG4gKiBAbWVtYmVyT2YgSGFzaFxyXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXHJcbiAqL1xyXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xyXG4gIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XHJcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xyXG4gIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQG5hbWUgZ2V0XHJcbiAqIEBtZW1iZXJPZiBIYXNoXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxyXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXHJcbiAqL1xyXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xyXG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcclxuICBpZiAobmF0aXZlQ3JlYXRlKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xyXG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XHJcbiAgfVxyXG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBuYW1lIGhhc1xyXG4gKiBAbWVtYmVyT2YgSGFzaFxyXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxyXG4gKi9cclxuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcclxuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XHJcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBuYW1lIHNldFxyXG4gKiBAbWVtYmVyT2YgSGFzaFxyXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxyXG4gKi9cclxuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XHJcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xyXG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XHJcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cclxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XHJcbkhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XHJcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XHJcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XHJcbkhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxyXG4gKi9cclxuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcclxuICB2YXIgaW5kZXggPSAtMSxcclxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xyXG5cclxuICB0aGlzLmNsZWFyKCk7XHJcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcclxuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xyXG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAbmFtZSBjbGVhclxyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXHJcbiAqL1xyXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcclxuICB0aGlzLl9fZGF0YV9fID0gW107XHJcbiAgdGhpcy5zaXplID0gMDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAbmFtZSBkZWxldGVcclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxyXG4gKi9cclxuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xyXG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcclxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcclxuXHJcbiAgaWYgKGluZGV4IDwgMCkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xyXG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcclxuICAgIGRhdGEucG9wKCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcclxuICB9XHJcbiAgLS10aGlzLnNpemU7XHJcbiAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQG5hbWUgZ2V0XHJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcclxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXHJcbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cclxuICovXHJcbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcclxuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXHJcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XHJcblxyXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQG5hbWUgaGFzXHJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcclxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cclxuICovXHJcbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcclxuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQG5hbWUgc2V0XHJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcclxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cclxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cclxuICovXHJcbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XHJcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxyXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xyXG5cclxuICBpZiAoaW5kZXggPCAwKSB7XHJcbiAgICArK3RoaXMuc2l6ZTtcclxuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xyXG4gIH1cclxuICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXHJcbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcclxuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XHJcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xyXG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcclxuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXHJcbiAqL1xyXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XHJcbiAgdmFyIGluZGV4ID0gLTEsXHJcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcclxuXHJcbiAgdGhpcy5jbGVhcigpO1xyXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XHJcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcclxuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAbmFtZSBjbGVhclxyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcclxuICovXHJcbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XHJcbiAgdGhpcy5zaXplID0gMDtcclxuICB0aGlzLl9fZGF0YV9fID0ge1xyXG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcclxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxyXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBuYW1lIGRlbGV0ZVxyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcclxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cclxuICovXHJcbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xyXG4gIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XHJcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xyXG4gIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAbmFtZSBnZXRcclxuICogQG1lbWJlck9mIE1hcENhY2hlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxyXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXHJcbiAqL1xyXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcclxuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBuYW1lIGhhc1xyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcclxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cclxuICovXHJcbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xyXG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQG5hbWUgc2V0XHJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XHJcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXHJcbiAgICAgIHNpemUgPSBkYXRhLnNpemU7XHJcblxyXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xyXG4gIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xyXG4gIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG4vLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxyXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xyXG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XHJcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcclxuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xyXG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cclxuICovXHJcbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcclxuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xyXG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAbmFtZSBjbGVhclxyXG4gKiBAbWVtYmVyT2YgU3RhY2tcclxuICovXHJcbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XHJcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XHJcbiAgdGhpcy5zaXplID0gMDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQG5hbWUgZGVsZXRlXHJcbiAqIEBtZW1iZXJPZiBTdGFja1xyXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxyXG4gKi9cclxuZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XHJcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxyXG4gICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xyXG5cclxuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQG5hbWUgZ2V0XHJcbiAqIEBtZW1iZXJPZiBTdGFja1xyXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cclxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxyXG4gKi9cclxuZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XHJcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAbmFtZSBoYXNcclxuICogQG1lbWJlck9mIFN0YWNrXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXHJcbiAqL1xyXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcclxuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBuYW1lIHNldFxyXG4gKiBAbWVtYmVyT2YgU3RhY2tcclxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cclxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XHJcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xyXG4gIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XHJcbiAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xyXG4gICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xyXG4gICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XHJcbiAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcclxuICB9XHJcbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XHJcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xyXG4gIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxyXG5TdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xyXG5TdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XHJcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcclxuU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xyXG5TdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cclxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxyXG4gKi9cclxuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XHJcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXHJcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcclxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXHJcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxyXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXHJcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxyXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xyXG5cclxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcclxuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXHJcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXHJcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxyXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxyXG4gICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxyXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxyXG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cclxuICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcclxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXHJcbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcclxuICAgICAgICApKSkge1xyXG4gICAgICByZXN1bHQucHVzaChrZXkpO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG4vKipcclxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBhc3NpZ25WYWx1ZWAgZXhjZXB0IHRoYXQgaXQgZG9lc24ndCBhc3NpZ25cclxuICogYHVuZGVmaW5lZGAgdmFsdWVzLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxyXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxyXG4gKi9cclxuZnVuY3Rpb24gYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcclxuICBpZiAoKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWVxKG9iamVjdFtrZXldLCB2YWx1ZSkpIHx8XHJcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XHJcbiAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XHJcbiAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXHJcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cclxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cclxuICovXHJcbmZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xyXG4gIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xyXG4gIGlmICghKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGVxKG9ialZhbHVlLCB2YWx1ZSkpIHx8XHJcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XHJcbiAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxyXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXHJcbiAqL1xyXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xyXG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XHJcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XHJcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xyXG4gICAgICByZXR1cm4gbGVuZ3RoO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gLTE7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYXNzaWduVmFsdWVgIGFuZCBgYXNzaWduTWVyZ2VWYWx1ZWAgd2l0aG91dFxyXG4gKiB2YWx1ZSBjaGVja3MuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXHJcbiAqL1xyXG5mdW5jdGlvbiBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XHJcbiAgaWYgKGtleSA9PSAnX19wcm90b19fJyAmJiBkZWZpbmVQcm9wZXJ0eSkge1xyXG4gICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcclxuICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXHJcbiAgICAgICdlbnVtZXJhYmxlJzogdHJ1ZSxcclxuICAgICAgJ3ZhbHVlJzogdmFsdWUsXHJcbiAgICAgICd3cml0YWJsZSc6IHRydWVcclxuICAgIH0pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlcyBvdmVyIGBvYmplY3RgXHJcbiAqIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LlxyXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXHJcbiAqL1xyXG52YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cclxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cclxuICovXHJcbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcclxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xyXG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xyXG4gIH1cclxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXHJcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcclxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xyXG59XHJcblxyXG4vKipcclxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxyXG4gKi9cclxuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XHJcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxyXG4gKiAgZWxzZSBgZmFsc2VgLlxyXG4gKi9cclxuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XHJcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbih2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xyXG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXHJcbiAqL1xyXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XHJcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcclxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzSW5gIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxyXG4gKi9cclxuZnVuY3Rpb24gYmFzZUtleXNJbihvYmplY3QpIHtcclxuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcclxuICAgIHJldHVybiBuYXRpdmVLZXlzSW4ob2JqZWN0KTtcclxuICB9XHJcbiAgdmFyIGlzUHJvdG8gPSBpc1Byb3RvdHlwZShvYmplY3QpLFxyXG4gICAgICByZXN1bHQgPSBbXTtcclxuXHJcbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xyXG4gICAgaWYgKCEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcclxuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1lcmdlYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXMuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cclxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cclxuICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC5cclxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2VkIHZhbHVlcy5cclxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcclxuICogIGNvdW50ZXJwYXJ0cy5cclxuICovXHJcbmZ1bmN0aW9uIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XHJcbiAgaWYgKG9iamVjdCA9PT0gc291cmNlKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGJhc2VGb3Ioc291cmNlLCBmdW5jdGlvbihzcmNWYWx1ZSwga2V5KSB7XHJcbiAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xyXG4gICAgaWYgKGlzT2JqZWN0KHNyY1ZhbHVlKSkge1xyXG4gICAgICBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBiYXNlTWVyZ2UsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXHJcbiAgICAgICAgPyBjdXN0b21pemVyKHNhZmVHZXQob2JqZWN0LCBrZXkpLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxyXG4gICAgICAgIDogdW5kZWZpbmVkO1xyXG5cclxuICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xyXG4gICAgICB9XHJcbiAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcclxuICAgIH1cclxuICB9LCBrZXlzSW4pO1xyXG59XHJcblxyXG4vKipcclxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlTWVyZ2VgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcclxuICogZGVlcCBtZXJnZXMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcclxuICogcmVmZXJlbmNlcyB0byBiZSBtZXJnZWQuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cclxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cclxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBtZXJnZS5cclxuICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC5cclxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWVyZ2VGdW5jIFRoZSBmdW5jdGlvbiB0byBtZXJnZSB2YWx1ZXMuXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cclxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcclxuICogIGNvdW50ZXJwYXJ0cy5cclxuICovXHJcbmZ1bmN0aW9uIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIG1lcmdlRnVuYywgY3VzdG9taXplciwgc3RhY2spIHtcclxuICB2YXIgb2JqVmFsdWUgPSBzYWZlR2V0KG9iamVjdCwga2V5KSxcclxuICAgICAgc3JjVmFsdWUgPSBzYWZlR2V0KHNvdXJjZSwga2V5KSxcclxuICAgICAgc3RhY2tlZCA9IHN0YWNrLmdldChzcmNWYWx1ZSk7XHJcblxyXG4gIGlmIChzdGFja2VkKSB7XHJcbiAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBzdGFja2VkKTtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxyXG4gICAgPyBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxyXG4gICAgOiB1bmRlZmluZWQ7XHJcblxyXG4gIHZhciBpc0NvbW1vbiA9IG5ld1ZhbHVlID09PSB1bmRlZmluZWQ7XHJcblxyXG4gIGlmIChpc0NvbW1vbikge1xyXG4gICAgdmFyIGlzQXJyID0gaXNBcnJheShzcmNWYWx1ZSksXHJcbiAgICAgICAgaXNCdWZmID0gIWlzQXJyICYmIGlzQnVmZmVyKHNyY1ZhbHVlKSxcclxuICAgICAgICBpc1R5cGVkID0gIWlzQXJyICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHNyY1ZhbHVlKTtcclxuXHJcbiAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xyXG4gICAgaWYgKGlzQXJyIHx8IGlzQnVmZiB8fCBpc1R5cGVkKSB7XHJcbiAgICAgIGlmIChpc0FycmF5KG9ialZhbHVlKSkge1xyXG4gICAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAoaXNBcnJheUxpa2VPYmplY3Qob2JqVmFsdWUpKSB7XHJcbiAgICAgICAgbmV3VmFsdWUgPSBjb3B5QXJyYXkob2JqVmFsdWUpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKGlzQnVmZikge1xyXG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XHJcbiAgICAgICAgbmV3VmFsdWUgPSBjbG9uZUJ1ZmZlcihzcmNWYWx1ZSwgdHJ1ZSk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAoaXNUeXBlZCkge1xyXG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XHJcbiAgICAgICAgbmV3VmFsdWUgPSBjbG9uZVR5cGVkQXJyYXkoc3JjVmFsdWUsIHRydWUpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIG5ld1ZhbHVlID0gW107XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzUGxhaW5PYmplY3Qoc3JjVmFsdWUpIHx8IGlzQXJndW1lbnRzKHNyY1ZhbHVlKSkge1xyXG4gICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlO1xyXG4gICAgICBpZiAoaXNBcmd1bWVudHMob2JqVmFsdWUpKSB7XHJcbiAgICAgICAgbmV3VmFsdWUgPSB0b1BsYWluT2JqZWN0KG9ialZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIGlmICghaXNPYmplY3Qob2JqVmFsdWUpIHx8IGlzRnVuY3Rpb24ob2JqVmFsdWUpKSB7XHJcbiAgICAgICAgbmV3VmFsdWUgPSBpbml0Q2xvbmVPYmplY3Qoc3JjVmFsdWUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgaXNDb21tb24gPSBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcbiAgaWYgKGlzQ29tbW9uKSB7XHJcbiAgICAvLyBSZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cclxuICAgIHN0YWNrLnNldChzcmNWYWx1ZSwgbmV3VmFsdWUpO1xyXG4gICAgbWVyZ2VGdW5jKG5ld1ZhbHVlLCBzcmNWYWx1ZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcclxuICAgIHN0YWNrWydkZWxldGUnXShzcmNWYWx1ZSk7XHJcbiAgfVxyXG4gIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlc3RgIHdoaWNoIGRvZXNuJ3QgdmFsaWRhdGUgb3IgY29lcmNlIGFyZ3VtZW50cy5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cclxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIGJhc2VSZXN0KGZ1bmMsIHN0YXJ0KSB7XHJcbiAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCBpZGVudGl0eSksIGZ1bmMgKyAnJyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0VG9TdHJpbmdgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3Agc2hvcnRpbmcuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cclxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cclxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cclxuICovXHJcbnZhciBiYXNlU2V0VG9TdHJpbmcgPSAhZGVmaW5lUHJvcGVydHkgPyBpZGVudGl0eSA6IGZ1bmN0aW9uKGZ1bmMsIHN0cmluZykge1xyXG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jLCAndG9TdHJpbmcnLCB7XHJcbiAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcclxuICAgICdlbnVtZXJhYmxlJzogZmFsc2UsXHJcbiAgICAndmFsdWUnOiBjb25zdGFudChzdHJpbmcpLFxyXG4gICAgJ3dyaXRhYmxlJzogdHJ1ZVxyXG4gIH0pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiAgYGJ1ZmZlcmAuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgVGhlIGJ1ZmZlciB0byBjbG9uZS5cclxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cclxuICogQHJldHVybnMge0J1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGJ1ZmZlci5cclxuICovXHJcbmZ1bmN0aW9uIGNsb25lQnVmZmVyKGJ1ZmZlciwgaXNEZWVwKSB7XHJcbiAgaWYgKGlzRGVlcCkge1xyXG4gICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgpO1xyXG4gIH1cclxuICB2YXIgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCxcclxuICAgICAgcmVzdWx0ID0gYWxsb2NVbnNhZmUgPyBhbGxvY1Vuc2FmZShsZW5ndGgpIDogbmV3IGJ1ZmZlci5jb25zdHJ1Y3RvcihsZW5ndGgpO1xyXG5cclxuICBidWZmZXIuY29weShyZXN1bHQpO1xyXG4gIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGFycmF5QnVmZmVyYC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cclxuICogQHJldHVybnMge0FycmF5QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYXJyYXkgYnVmZmVyLlxyXG4gKi9cclxuZnVuY3Rpb24gY2xvbmVBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlcikge1xyXG4gIHZhciByZXN1bHQgPSBuZXcgYXJyYXlCdWZmZXIuY29uc3RydWN0b3IoYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCk7XHJcbiAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGB0eXBlZEFycmF5YC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtPYmplY3R9IHR5cGVkQXJyYXkgVGhlIHR5cGVkIGFycmF5IHRvIGNsb25lLlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgdHlwZWQgYXJyYXkuXHJcbiAqL1xyXG5mdW5jdGlvbiBjbG9uZVR5cGVkQXJyYXkodHlwZWRBcnJheSwgaXNEZWVwKSB7XHJcbiAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIodHlwZWRBcnJheS5idWZmZXIpIDogdHlwZWRBcnJheS5idWZmZXI7XHJcbiAgcmV0dXJuIG5ldyB0eXBlZEFycmF5LmNvbnN0cnVjdG9yKGJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5Lmxlbmd0aCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXHJcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheT1bXV0gVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIHRvLlxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cclxuICovXHJcbmZ1bmN0aW9uIGNvcHlBcnJheShzb3VyY2UsIGFycmF5KSB7XHJcbiAgdmFyIGluZGV4ID0gLTEsXHJcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XHJcblxyXG4gIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xyXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XHJcbiAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xyXG4gIH1cclxuICByZXR1cm4gYXJyYXk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxyXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gY29weS5cclxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb3BpZWQgdmFsdWVzLlxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxyXG4gKi9cclxuZnVuY3Rpb24gY29weU9iamVjdChzb3VyY2UsIHByb3BzLCBvYmplY3QsIGN1c3RvbWl6ZXIpIHtcclxuICB2YXIgaXNOZXcgPSAhb2JqZWN0O1xyXG4gIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xyXG5cclxuICB2YXIgaW5kZXggPSAtMSxcclxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xyXG5cclxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xyXG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcclxuXHJcbiAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXHJcbiAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXHJcbiAgICAgIDogdW5kZWZpbmVkO1xyXG5cclxuICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIG5ld1ZhbHVlID0gc291cmNlW2tleV07XHJcbiAgICB9XHJcbiAgICBpZiAoaXNOZXcpIHtcclxuICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gb2JqZWN0O1xyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uYXNzaWduYC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduZXIgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXHJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFzc2lnbmVyIGZ1bmN0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlQXNzaWduZXIoYXNzaWduZXIpIHtcclxuICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XHJcbiAgICB2YXIgaW5kZXggPSAtMSxcclxuICAgICAgICBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aCxcclxuICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoID4gMSA/IHNvdXJjZXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQsXHJcbiAgICAgICAgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcclxuXHJcbiAgICBjdXN0b21pemVyID0gKGFzc2lnbmVyLmxlbmd0aCA+IDMgJiYgdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJylcclxuICAgICAgPyAobGVuZ3RoLS0sIGN1c3RvbWl6ZXIpXHJcbiAgICAgIDogdW5kZWZpbmVkO1xyXG5cclxuICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLCBzb3VyY2VzWzFdLCBndWFyZCkpIHtcclxuICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiBjdXN0b21pemVyO1xyXG4gICAgICBsZW5ndGggPSAxO1xyXG4gICAgfVxyXG4gICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XHJcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xyXG4gICAgICB2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XHJcbiAgICAgIGlmIChzb3VyY2UpIHtcclxuICAgICAgICBhc3NpZ25lcihvYmplY3QsIHNvdXJjZSwgaW5kZXgsIGN1c3RvbWl6ZXIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb2JqZWN0O1xyXG4gIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIG1ldGhvZHMgbGlrZSBgXy5mb3JJbmAgYW5kIGBfLmZvck93bmAuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHtcclxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcclxuICAgIHZhciBpbmRleCA9IC0xLFxyXG4gICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KG9iamVjdCksXHJcbiAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxyXG4gICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcclxuXHJcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcclxuICAgICAgdmFyIGtleSA9IHByb3BzW2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdO1xyXG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBvYmplY3Q7XHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXHJcbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cclxuICovXHJcbmZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcclxuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcclxuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcclxuICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXHJcbiAgICA6IGRhdGEubWFwO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cclxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XHJcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xyXG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cclxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcclxuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXHJcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcclxuXHJcbiAgdHJ5IHtcclxuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcclxuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XHJcbiAgfSBjYXRjaCAoZSkge31cclxuXHJcbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xyXG4gIGlmICh1bm1hc2tlZCkge1xyXG4gICAgaWYgKGlzT3duKSB7XHJcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cclxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXHJcbiAqL1xyXG5mdW5jdGlvbiBpbml0Q2xvbmVPYmplY3Qob2JqZWN0KSB7XHJcbiAgcmV0dXJuICh0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgIWlzUHJvdG90eXBlKG9iamVjdCkpXHJcbiAgICA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpXHJcbiAgICA6IHt9O1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcclxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcclxuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XHJcblxyXG4gIHJldHVybiAhIWxlbmd0aCAmJlxyXG4gICAgKHR5cGUgPT0gJ251bWJlcicgfHxcclxuICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxyXG4gICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cclxuICogQHBhcmFtIHsqfSBpbmRleCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIGluZGV4IG9yIGtleSBhcmd1bWVudC5cclxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsXHJcbiAqICBlbHNlIGBmYWxzZWAuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xyXG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICB2YXIgdHlwZSA9IHR5cGVvZiBpbmRleDtcclxuICBpZiAodHlwZSA9PSAnbnVtYmVyJ1xyXG4gICAgICAgID8gKGlzQXJyYXlMaWtlKG9iamVjdCkgJiYgaXNJbmRleChpbmRleCwgb2JqZWN0Lmxlbmd0aCkpXHJcbiAgICAgICAgOiAodHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3QpXHJcbiAgICAgICkge1xyXG4gICAgcmV0dXJuIGVxKG9iamVjdFtpbmRleF0sIHZhbHVlKTtcclxuICB9XHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcclxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcclxuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxyXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxyXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xyXG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cclxuICovXHJcbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XHJcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcclxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XHJcblxyXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2VcclxuICogW2BPYmplY3Qua2V5c2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxyXG4gKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXHJcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XHJcbiAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gIGlmIChvYmplY3QgIT0gbnVsbCkge1xyXG4gICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XHJcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cclxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cclxuICovXHJcbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XHJcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xyXG59XHJcblxyXG4vKipcclxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggdHJhbnNmb3JtcyB0aGUgcmVzdCBhcnJheS5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cclxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIHJlc3QgYXJyYXkgdHJhbnNmb3JtLlxyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCB0cmFuc2Zvcm0pIHtcclxuICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gKGZ1bmMubGVuZ3RoIC0gMSkgOiBzdGFydCwgMCk7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXHJcbiAgICAgICAgaW5kZXggPSAtMSxcclxuICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXHJcbiAgICAgICAgYXJyYXkgPSBBcnJheShsZW5ndGgpO1xyXG5cclxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XHJcbiAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XHJcbiAgICB9XHJcbiAgICBpbmRleCA9IC0xO1xyXG4gICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XHJcbiAgICB3aGlsZSAoKytpbmRleCA8IHN0YXJ0KSB7XHJcbiAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcclxuICAgIH1cclxuICAgIG90aGVyQXJnc1tzdGFydF0gPSB0cmFuc2Zvcm0oYXJyYXkpO1xyXG4gICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgLCB1bmxlc3MgYGtleWAgaXMgXCJfX3Byb3RvX19cIiBvciBcImNvbnN0cnVjdG9yXCIuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cclxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXHJcbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cclxuICovXHJcbmZ1bmN0aW9uIHNhZmVHZXQob2JqZWN0LCBrZXkpIHtcclxuICBpZiAoa2V5ID09PSAnY29uc3RydWN0b3InICYmIHR5cGVvZiBvYmplY3Rba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgaWYgKGtleSA9PSAnX19wcm90b19fJykge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG9iamVjdFtrZXldO1xyXG59XHJcblxyXG4vKipcclxuICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYGZ1bmNgIHRvIHJldHVybiBgc3RyaW5nYC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxyXG4gKi9cclxudmFyIHNldFRvU3RyaW5nID0gc2hvcnRPdXQoYmFzZVNldFRvU3RyaW5nKTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcclxuICogb2YgYGZ1bmNgIHdoZW4gaXQncyBjYWxsZWQgYEhPVF9DT1VOVGAgb3IgbW9yZSB0aW1lcyBpbiBgSE9UX1NQQU5gXHJcbiAqIG1pbGxpc2Vjb25kcy5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXHJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIHNob3J0T3V0KGZ1bmMpIHtcclxuICB2YXIgY291bnQgPSAwLFxyXG4gICAgICBsYXN0Q2FsbGVkID0gMDtcclxuXHJcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHN0YW1wID0gbmF0aXZlTm93KCksXHJcbiAgICAgICAgcmVtYWluaW5nID0gSE9UX1NQQU4gLSAoc3RhbXAgLSBsYXN0Q2FsbGVkKTtcclxuXHJcbiAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XHJcbiAgICBpZiAocmVtYWluaW5nID4gMCkge1xyXG4gICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcclxuICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb3VudCA9IDA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxyXG4gKi9cclxuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xyXG4gIGlmIChmdW5jICE9IG51bGwpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcclxuICAgIH0gY2F0Y2ggKGUpIHt9XHJcbiAgICB0cnkge1xyXG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XHJcbiAgICB9IGNhdGNoIChlKSB7fVxyXG4gIH1cclxuICByZXR1cm4gJyc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQZXJmb3JtcyBhXHJcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXHJcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZW1iZXJPZiBfXHJcbiAqIEBzaW5jZSA0LjAuMFxyXG4gKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxyXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcclxuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcclxuICpcclxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XHJcbiAqIC8vID0+IHRydWVcclxuICpcclxuICogXy5lcShvYmplY3QsIG90aGVyKTtcclxuICogLy8gPT4gZmFsc2VcclxuICpcclxuICogXy5lcSgnYScsICdhJyk7XHJcbiAqIC8vID0+IHRydWVcclxuICpcclxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcclxuICogLy8gPT4gZmFsc2VcclxuICpcclxuICogXy5lcShOYU4sIE5hTik7XHJcbiAqIC8vID0+IHRydWVcclxuICovXHJcbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xyXG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAbWVtYmVyT2YgX1xyXG4gKiBAc2luY2UgMC4xLjBcclxuICogQGNhdGVnb3J5IExhbmdcclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcclxuICogIGVsc2UgYGZhbHNlYC5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcclxuICogLy8gPT4gdHJ1ZVxyXG4gKlxyXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XHJcbiAqIC8vID0+IGZhbHNlXHJcbiAqL1xyXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxyXG4gICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZW1iZXJPZiBfXHJcbiAqIEBzaW5jZSAwLjEuMFxyXG4gKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XHJcbiAqIC8vID0+IHRydWVcclxuICpcclxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xyXG4gKiAvLyA9PiBmYWxzZVxyXG4gKlxyXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xyXG4gKiAvLyA9PiBmYWxzZVxyXG4gKlxyXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcclxuICogLy8gPT4gZmFsc2VcclxuICovXHJcbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXHJcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAbWVtYmVyT2YgX1xyXG4gKiBAc2luY2UgNC4wLjBcclxuICogQGNhdGVnb3J5IExhbmdcclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xyXG4gKiAvLyA9PiB0cnVlXHJcbiAqXHJcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XHJcbiAqIC8vID0+IHRydWVcclxuICpcclxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XHJcbiAqIC8vID0+IHRydWVcclxuICpcclxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xyXG4gKiAvLyA9PiBmYWxzZVxyXG4gKi9cclxuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcclxuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcclxuICogaXMgYW4gb2JqZWN0LlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZW1iZXJPZiBfXHJcbiAqIEBzaW5jZSA0LjAuMFxyXG4gKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXktbGlrZSBvYmplY3QsXHJcbiAqICBlbHNlIGBmYWxzZWAuXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcclxuICogLy8gPT4gdHJ1ZVxyXG4gKlxyXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xyXG4gKiAvLyA9PiB0cnVlXHJcbiAqXHJcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xyXG4gKiAvLyA9PiBmYWxzZVxyXG4gKlxyXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XHJcbiAqIC8vID0+IGZhbHNlXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xyXG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZW1iZXJPZiBfXHJcbiAqIEBzaW5jZSA0LjMuMFxyXG4gKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcclxuICogLy8gPT4gdHJ1ZVxyXG4gKlxyXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcclxuICogLy8gPT4gZmFsc2VcclxuICovXHJcbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQG1lbWJlck9mIF9cclxuICogQHNpbmNlIDAuMS4wXHJcbiAqIEBjYXRlZ29yeSBMYW5nXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIF8uaXNGdW5jdGlvbihfKTtcclxuICogLy8gPT4gdHJ1ZVxyXG4gKlxyXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xyXG4gKiAvLyA9PiBmYWxzZVxyXG4gKi9cclxuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xyXG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxyXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxyXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcclxuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cclxuICpcclxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cclxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAbWVtYmVyT2YgX1xyXG4gKiBAc2luY2UgNC4wLjBcclxuICogQGNhdGVnb3J5IExhbmdcclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIF8uaXNMZW5ndGgoMyk7XHJcbiAqIC8vID0+IHRydWVcclxuICpcclxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcclxuICogLy8gPT4gZmFsc2VcclxuICpcclxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XHJcbiAqIC8vID0+IGZhbHNlXHJcbiAqXHJcbiAqIF8uaXNMZW5ndGgoJzMnKTtcclxuICogLy8gPT4gZmFsc2VcclxuICovXHJcbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XHJcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxyXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXHJcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcclxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZW1iZXJPZiBfXHJcbiAqIEBzaW5jZSAwLjEuMFxyXG4gKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIF8uaXNPYmplY3Qoe30pO1xyXG4gKiAvLyA9PiB0cnVlXHJcbiAqXHJcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcclxuICogLy8gPT4gdHJ1ZVxyXG4gKlxyXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XHJcbiAqIC8vID0+IHRydWVcclxuICpcclxuICogXy5pc09iamVjdChudWxsKTtcclxuICogLy8gPT4gZmFsc2VcclxuICovXHJcbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XHJcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XHJcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxyXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQG1lbWJlck9mIF9cclxuICogQHNpbmNlIDQuMC4wXHJcbiAqIEBjYXRlZ29yeSBMYW5nXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XHJcbiAqIC8vID0+IHRydWVcclxuICpcclxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcclxuICogLy8gPT4gdHJ1ZVxyXG4gKlxyXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xyXG4gKiAvLyA9PiBmYWxzZVxyXG4gKlxyXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcclxuICogLy8gPT4gZmFsc2VcclxuICovXHJcbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xyXG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JztcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcclxuICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZW1iZXJPZiBfXHJcbiAqIEBzaW5jZSAwLjguMFxyXG4gKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogZnVuY3Rpb24gRm9vKCkge1xyXG4gKiAgIHRoaXMuYSA9IDE7XHJcbiAqIH1cclxuICpcclxuICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xyXG4gKiAvLyA9PiBmYWxzZVxyXG4gKlxyXG4gKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcclxuICogLy8gPT4gZmFsc2VcclxuICpcclxuICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XHJcbiAqIC8vID0+IHRydWVcclxuICpcclxuICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xyXG4gKiAvLyA9PiB0cnVlXHJcbiAqL1xyXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XHJcbiAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8IGJhc2VHZXRUYWcodmFsdWUpICE9IG9iamVjdFRhZykge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUodmFsdWUpO1xyXG4gIGlmIChwcm90byA9PT0gbnVsbCkge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG4gIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XHJcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiZcclxuICAgIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQG1lbWJlck9mIF9cclxuICogQHNpbmNlIDMuMC4wXHJcbiAqIEBjYXRlZ29yeSBMYW5nXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcclxuICogLy8gPT4gdHJ1ZVxyXG4gKlxyXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XHJcbiAqIC8vID0+IGZhbHNlXHJcbiAqL1xyXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XHJcblxyXG4vKipcclxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHBsYWluIG9iamVjdCBmbGF0dGVuaW5nIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZ1xyXG4gKiBrZXllZCBwcm9wZXJ0aWVzIG9mIGB2YWx1ZWAgdG8gb3duIHByb3BlcnRpZXMgb2YgdGhlIHBsYWluIG9iamVjdC5cclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAbWVtYmVyT2YgX1xyXG4gKiBAc2luY2UgMy4wLjBcclxuICogQGNhdGVnb3J5IExhbmdcclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cclxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29udmVydGVkIHBsYWluIG9iamVjdC5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogZnVuY3Rpb24gRm9vKCkge1xyXG4gKiAgIHRoaXMuYiA9IDI7XHJcbiAqIH1cclxuICpcclxuICogRm9vLnByb3RvdHlwZS5jID0gMztcclxuICpcclxuICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgbmV3IEZvbyk7XHJcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxyXG4gKlxyXG4gKiBfLmFzc2lnbih7ICdhJzogMSB9LCBfLnRvUGxhaW5PYmplY3QobmV3IEZvbykpO1xyXG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfVxyXG4gKi9cclxuZnVuY3Rpb24gdG9QbGFpbk9iamVjdCh2YWx1ZSkge1xyXG4gIHJldHVybiBjb3B5T2JqZWN0KHZhbHVlLCBrZXlzSW4odmFsdWUpKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXHJcbiAqXHJcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZW1iZXJPZiBfXHJcbiAqIEBzaW5jZSAzLjAuMFxyXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cclxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogZnVuY3Rpb24gRm9vKCkge1xyXG4gKiAgIHRoaXMuYSA9IDE7XHJcbiAqICAgdGhpcy5iID0gMjtcclxuICogfVxyXG4gKlxyXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xyXG4gKlxyXG4gKiBfLmtleXNJbihuZXcgRm9vKTtcclxuICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXHJcbiAqL1xyXG5mdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XHJcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCwgdHJ1ZSkgOiBiYXNlS2V5c0luKG9iamVjdCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbmAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgbWVyZ2VzIG93biBhbmRcclxuICogaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdHMgaW50byB0aGVcclxuICogZGVzdGluYXRpb24gb2JqZWN0LiBTb3VyY2UgcHJvcGVydGllcyB0aGF0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAgYXJlXHJcbiAqIHNraXBwZWQgaWYgYSBkZXN0aW5hdGlvbiB2YWx1ZSBleGlzdHMuIEFycmF5IGFuZCBwbGFpbiBvYmplY3QgcHJvcGVydGllc1xyXG4gKiBhcmUgbWVyZ2VkIHJlY3Vyc2l2ZWx5LiBPdGhlciBvYmplY3RzIGFuZCB2YWx1ZSB0eXBlcyBhcmUgb3ZlcnJpZGRlbiBieVxyXG4gKiBhc3NpZ25tZW50LiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuIFN1YnNlcXVlbnRcclxuICogc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cclxuICpcclxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQG1lbWJlck9mIF9cclxuICogQHNpbmNlIDAuNS4wXHJcbiAqIEBjYXRlZ29yeSBPYmplY3RcclxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxyXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cclxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogdmFyIG9iamVjdCA9IHtcclxuICogICAnYSc6IFt7ICdiJzogMiB9LCB7ICdkJzogNCB9XVxyXG4gKiB9O1xyXG4gKlxyXG4gKiB2YXIgb3RoZXIgPSB7XHJcbiAqICAgJ2EnOiBbeyAnYyc6IDMgfSwgeyAnZSc6IDUgfV1cclxuICogfTtcclxuICpcclxuICogXy5tZXJnZShvYmplY3QsIG90aGVyKTtcclxuICogLy8gPT4geyAnYSc6IFt7ICdiJzogMiwgJ2MnOiAzIH0sIHsgJ2QnOiA0LCAnZSc6IDUgfV0gfVxyXG4gKi9cclxudmFyIG1lcmdlID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KSB7XHJcbiAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCk7XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYHZhbHVlYC5cclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAbWVtYmVyT2YgX1xyXG4gKiBAc2luY2UgMi40LjBcclxuICogQGNhdGVnb3J5IFV0aWxcclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmV0dXJuIGZyb20gdGhlIG5ldyBmdW5jdGlvbi5cclxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29uc3RhbnQgZnVuY3Rpb24uXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLmNvbnN0YW50KHsgJ2EnOiAxIH0pKTtcclxuICpcclxuICogY29uc29sZS5sb2cob2JqZWN0cyk7XHJcbiAqIC8vID0+IFt7ICdhJzogMSB9LCB7ICdhJzogMSB9XVxyXG4gKlxyXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzWzBdID09PSBvYmplY3RzWzFdKTtcclxuICogLy8gPT4gdHJ1ZVxyXG4gKi9cclxuZnVuY3Rpb24gY29uc3RhbnQodmFsdWUpIHtcclxuICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBzaW5jZSAwLjEuMFxyXG4gKiBAbWVtYmVyT2YgX1xyXG4gKiBAY2F0ZWdvcnkgVXRpbFxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cclxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XHJcbiAqXHJcbiAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcclxuICogLy8gPT4gdHJ1ZVxyXG4gKi9cclxuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcclxuICByZXR1cm4gdmFsdWU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQG1lbWJlck9mIF9cclxuICogQHNpbmNlIDQuMTMuMFxyXG4gKiBAY2F0ZWdvcnkgVXRpbFxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcclxuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cclxuICovXHJcbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcclxuICByZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gbWVyZ2U7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lodash.merge/index.js\n");

/***/ }),

/***/ "./node_modules/lodash/lodash.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/lodash.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_RESULT__;/**\r\n * @license\r\n * Lodash <https://lodash.com/>\r\n * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>\r\n * Released under MIT license <https://lodash.com/license>\r\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\r\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\r\n */\r\n;(function() {\r\n\r\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\r\n  var undefined;\r\n\r\n  /** Used as the semantic version number. */\r\n  var VERSION = '4.17.21';\r\n\r\n  /** Used as the size to enable large array optimizations. */\r\n  var LARGE_ARRAY_SIZE = 200;\r\n\r\n  /** Error message constants. */\r\n  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',\r\n      FUNC_ERROR_TEXT = 'Expected a function',\r\n      INVALID_TEMPL_VAR_ERROR_TEXT = 'Invalid `variable` option passed into `_.template`';\r\n\r\n  /** Used to stand-in for `undefined` hash values. */\r\n  var HASH_UNDEFINED = '__lodash_hash_undefined__';\r\n\r\n  /** Used as the maximum memoize cache size. */\r\n  var MAX_MEMOIZE_SIZE = 500;\r\n\r\n  /** Used as the internal argument placeholder. */\r\n  var PLACEHOLDER = '__lodash_placeholder__';\r\n\r\n  /** Used to compose bitmasks for cloning. */\r\n  var CLONE_DEEP_FLAG = 1,\r\n      CLONE_FLAT_FLAG = 2,\r\n      CLONE_SYMBOLS_FLAG = 4;\r\n\r\n  /** Used to compose bitmasks for value comparisons. */\r\n  var COMPARE_PARTIAL_FLAG = 1,\r\n      COMPARE_UNORDERED_FLAG = 2;\r\n\r\n  /** Used to compose bitmasks for function metadata. */\r\n  var WRAP_BIND_FLAG = 1,\r\n      WRAP_BIND_KEY_FLAG = 2,\r\n      WRAP_CURRY_BOUND_FLAG = 4,\r\n      WRAP_CURRY_FLAG = 8,\r\n      WRAP_CURRY_RIGHT_FLAG = 16,\r\n      WRAP_PARTIAL_FLAG = 32,\r\n      WRAP_PARTIAL_RIGHT_FLAG = 64,\r\n      WRAP_ARY_FLAG = 128,\r\n      WRAP_REARG_FLAG = 256,\r\n      WRAP_FLIP_FLAG = 512;\r\n\r\n  /** Used as default options for `_.truncate`. */\r\n  var DEFAULT_TRUNC_LENGTH = 30,\r\n      DEFAULT_TRUNC_OMISSION = '...';\r\n\r\n  /** Used to detect hot functions by number of calls within a span of milliseconds. */\r\n  var HOT_COUNT = 800,\r\n      HOT_SPAN = 16;\r\n\r\n  /** Used to indicate the type of lazy iteratees. */\r\n  var LAZY_FILTER_FLAG = 1,\r\n      LAZY_MAP_FLAG = 2,\r\n      LAZY_WHILE_FLAG = 3;\r\n\r\n  /** Used as references for various `Number` constants. */\r\n  var INFINITY = 1 / 0,\r\n      MAX_SAFE_INTEGER = 9007199254740991,\r\n      MAX_INTEGER = 1.7976931348623157e+308,\r\n      NAN = 0 / 0;\r\n\r\n  /** Used as references for the maximum length and index of an array. */\r\n  var MAX_ARRAY_LENGTH = 4294967295,\r\n      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,\r\n      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;\r\n\r\n  /** Used to associate wrap methods with their bit flags. */\r\n  var wrapFlags = [\r\n    ['ary', WRAP_ARY_FLAG],\r\n    ['bind', WRAP_BIND_FLAG],\r\n    ['bindKey', WRAP_BIND_KEY_FLAG],\r\n    ['curry', WRAP_CURRY_FLAG],\r\n    ['curryRight', WRAP_CURRY_RIGHT_FLAG],\r\n    ['flip', WRAP_FLIP_FLAG],\r\n    ['partial', WRAP_PARTIAL_FLAG],\r\n    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],\r\n    ['rearg', WRAP_REARG_FLAG]\r\n  ];\r\n\r\n  /** `Object#toString` result references. */\r\n  var argsTag = '[object Arguments]',\r\n      arrayTag = '[object Array]',\r\n      asyncTag = '[object AsyncFunction]',\r\n      boolTag = '[object Boolean]',\r\n      dateTag = '[object Date]',\r\n      domExcTag = '[object DOMException]',\r\n      errorTag = '[object Error]',\r\n      funcTag = '[object Function]',\r\n      genTag = '[object GeneratorFunction]',\r\n      mapTag = '[object Map]',\r\n      numberTag = '[object Number]',\r\n      nullTag = '[object Null]',\r\n      objectTag = '[object Object]',\r\n      promiseTag = '[object Promise]',\r\n      proxyTag = '[object Proxy]',\r\n      regexpTag = '[object RegExp]',\r\n      setTag = '[object Set]',\r\n      stringTag = '[object String]',\r\n      symbolTag = '[object Symbol]',\r\n      undefinedTag = '[object Undefined]',\r\n      weakMapTag = '[object WeakMap]',\r\n      weakSetTag = '[object WeakSet]';\r\n\r\n  var arrayBufferTag = '[object ArrayBuffer]',\r\n      dataViewTag = '[object DataView]',\r\n      float32Tag = '[object Float32Array]',\r\n      float64Tag = '[object Float64Array]',\r\n      int8Tag = '[object Int8Array]',\r\n      int16Tag = '[object Int16Array]',\r\n      int32Tag = '[object Int32Array]',\r\n      uint8Tag = '[object Uint8Array]',\r\n      uint8ClampedTag = '[object Uint8ClampedArray]',\r\n      uint16Tag = '[object Uint16Array]',\r\n      uint32Tag = '[object Uint32Array]';\r\n\r\n  /** Used to match empty string literals in compiled template source. */\r\n  var reEmptyStringLeading = /\\b__p \\+= '';/g,\r\n      reEmptyStringMiddle = /\\b(__p \\+=) '' \\+/g,\r\n      reEmptyStringTrailing = /(__e\\(.*?\\)|\\b__t\\)) \\+\\n'';/g;\r\n\r\n  /** Used to match HTML entities and HTML characters. */\r\n  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,\r\n      reUnescapedHtml = /[&<>\"']/g,\r\n      reHasEscapedHtml = RegExp(reEscapedHtml.source),\r\n      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);\r\n\r\n  /** Used to match template delimiters. */\r\n  var reEscape = /<%-([\\s\\S]+?)%>/g,\r\n      reEvaluate = /<%([\\s\\S]+?)%>/g,\r\n      reInterpolate = /<%=([\\s\\S]+?)%>/g;\r\n\r\n  /** Used to match property names within property paths. */\r\n  var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\r\n      reIsPlainProp = /^\\w*$/,\r\n      rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\r\n\r\n  /**\r\n   * Used to match `RegExp`\r\n   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\r\n   */\r\n  var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g,\r\n      reHasRegExpChar = RegExp(reRegExpChar.source);\r\n\r\n  /** Used to match leading whitespace. */\r\n  var reTrimStart = /^\\s+/;\r\n\r\n  /** Used to match a single whitespace character. */\r\n  var reWhitespace = /\\s/;\r\n\r\n  /** Used to match wrap detail comments. */\r\n  var reWrapComment = /\\{(?:\\n\\/\\* \\[wrapped with .+\\] \\*\\/)?\\n?/,\r\n      reWrapDetails = /\\{\\n\\/\\* \\[wrapped with (.+)\\] \\*/,\r\n      reSplitDetails = /,? & /;\r\n\r\n  /** Used to match words composed of alphanumeric characters. */\r\n  var reAsciiWord = /[^\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7f]+/g;\r\n\r\n  /**\r\n   * Used to validate the `validate` option in `_.template` variable.\r\n   *\r\n   * Forbids characters which could potentially change the meaning of the function argument definition:\r\n   * - \"(),\" (modification of function parameters)\r\n   * - \"=\" (default value)\r\n   * - \"[]{}\" (destructuring of function parameters)\r\n   * - \"/\" (beginning of a comment)\r\n   * - whitespace\r\n   */\r\n  var reForbiddenIdentifierChars = /[()=,{}\\[\\]\\/\\s]/;\r\n\r\n  /** Used to match backslashes in property paths. */\r\n  var reEscapeChar = /\\\\(\\\\)?/g;\r\n\r\n  /**\r\n   * Used to match\r\n   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).\r\n   */\r\n  var reEsTemplate = /\\$\\{([^\\\\}]*(?:\\\\.[^\\\\}]*)*)\\}/g;\r\n\r\n  /** Used to match `RegExp` flags from their coerced string values. */\r\n  var reFlags = /\\w*$/;\r\n\r\n  /** Used to detect bad signed hexadecimal string values. */\r\n  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\r\n\r\n  /** Used to detect binary string values. */\r\n  var reIsBinary = /^0b[01]+$/i;\r\n\r\n  /** Used to detect host constructors (Safari). */\r\n  var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\r\n\r\n  /** Used to detect octal string values. */\r\n  var reIsOctal = /^0o[0-7]+$/i;\r\n\r\n  /** Used to detect unsigned integer values. */\r\n  var reIsUint = /^(?:0|[1-9]\\d*)$/;\r\n\r\n  /** Used to match Latin Unicode letters (excluding mathematical operators). */\r\n  var reLatin = /[\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\xff\\u0100-\\u017f]/g;\r\n\r\n  /** Used to ensure capturing order of template delimiters. */\r\n  var reNoMatch = /($^)/;\r\n\r\n  /** Used to match unescaped characters in compiled string literals. */\r\n  var reUnescapedString = /['\\n\\r\\u2028\\u2029\\\\]/g;\r\n\r\n  /** Used to compose unicode character classes. */\r\n  var rsAstralRange = '\\\\ud800-\\\\udfff',\r\n      rsComboMarksRange = '\\\\u0300-\\\\u036f',\r\n      reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f',\r\n      rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff',\r\n      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,\r\n      rsDingbatRange = '\\\\u2700-\\\\u27bf',\r\n      rsLowerRange = 'a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff',\r\n      rsMathOpRange = '\\\\xac\\\\xb1\\\\xd7\\\\xf7',\r\n      rsNonCharRange = '\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf',\r\n      rsPunctuationRange = '\\\\u2000-\\\\u206f',\r\n      rsSpaceRange = ' \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000',\r\n      rsUpperRange = 'A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde',\r\n      rsVarRange = '\\\\ufe0e\\\\ufe0f',\r\n      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;\r\n\r\n  /** Used to compose unicode capture groups. */\r\n  var rsApos = \"['\\u2019]\",\r\n      rsAstral = '[' + rsAstralRange + ']',\r\n      rsBreak = '[' + rsBreakRange + ']',\r\n      rsCombo = '[' + rsComboRange + ']',\r\n      rsDigits = '\\\\d+',\r\n      rsDingbat = '[' + rsDingbatRange + ']',\r\n      rsLower = '[' + rsLowerRange + ']',\r\n      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',\r\n      rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]',\r\n      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',\r\n      rsNonAstral = '[^' + rsAstralRange + ']',\r\n      rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}',\r\n      rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]',\r\n      rsUpper = '[' + rsUpperRange + ']',\r\n      rsZWJ = '\\\\u200d';\r\n\r\n  /** Used to compose unicode regexes. */\r\n  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',\r\n      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',\r\n      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',\r\n      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',\r\n      reOptMod = rsModifier + '?',\r\n      rsOptVar = '[' + rsVarRange + ']?',\r\n      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',\r\n      rsOrdLower = '\\\\d*(?:1st|2nd|3rd|(?![123])\\\\dth)(?=\\\\b|[A-Z_])',\r\n      rsOrdUpper = '\\\\d*(?:1ST|2ND|3RD|(?![123])\\\\dTH)(?=\\\\b|[a-z_])',\r\n      rsSeq = rsOptVar + reOptMod + rsOptJoin,\r\n      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,\r\n      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';\r\n\r\n  /** Used to match apostrophes. */\r\n  var reApos = RegExp(rsApos, 'g');\r\n\r\n  /**\r\n   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and\r\n   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).\r\n   */\r\n  var reComboMark = RegExp(rsCombo, 'g');\r\n\r\n  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\r\n  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');\r\n\r\n  /** Used to match complex or compound words. */\r\n  var reUnicodeWord = RegExp([\r\n    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',\r\n    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',\r\n    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,\r\n    rsUpper + '+' + rsOptContrUpper,\r\n    rsOrdUpper,\r\n    rsOrdLower,\r\n    rsDigits,\r\n    rsEmoji\r\n  ].join('|'), 'g');\r\n\r\n  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\r\n  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');\r\n\r\n  /** Used to detect strings that need a more robust regexp to match words. */\r\n  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;\r\n\r\n  /** Used to assign default `context` object properties. */\r\n  var contextProps = [\r\n    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',\r\n    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',\r\n    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',\r\n    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',\r\n    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'\r\n  ];\r\n\r\n  /** Used to make template sourceURLs easier to identify. */\r\n  var templateCounter = -1;\r\n\r\n  /** Used to identify `toStringTag` values of typed arrays. */\r\n  var typedArrayTags = {};\r\n  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\r\n  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\r\n  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\r\n  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\r\n  typedArrayTags[uint32Tag] = true;\r\n  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =\r\n  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\r\n  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\r\n  typedArrayTags[errorTag] = typedArrayTags[funcTag] =\r\n  typedArrayTags[mapTag] = typedArrayTags[numberTag] =\r\n  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =\r\n  typedArrayTags[setTag] = typedArrayTags[stringTag] =\r\n  typedArrayTags[weakMapTag] = false;\r\n\r\n  /** Used to identify `toStringTag` values supported by `_.clone`. */\r\n  var cloneableTags = {};\r\n  cloneableTags[argsTag] = cloneableTags[arrayTag] =\r\n  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\r\n  cloneableTags[boolTag] = cloneableTags[dateTag] =\r\n  cloneableTags[float32Tag] = cloneableTags[float64Tag] =\r\n  cloneableTags[int8Tag] = cloneableTags[int16Tag] =\r\n  cloneableTags[int32Tag] = cloneableTags[mapTag] =\r\n  cloneableTags[numberTag] = cloneableTags[objectTag] =\r\n  cloneableTags[regexpTag] = cloneableTags[setTag] =\r\n  cloneableTags[stringTag] = cloneableTags[symbolTag] =\r\n  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\r\n  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\r\n  cloneableTags[errorTag] = cloneableTags[funcTag] =\r\n  cloneableTags[weakMapTag] = false;\r\n\r\n  /** Used to map Latin Unicode letters to basic Latin letters. */\r\n  var deburredLetters = {\r\n    // Latin-1 Supplement block.\r\n    '\\xc0': 'A',  '\\xc1': 'A', '\\xc2': 'A', '\\xc3': 'A', '\\xc4': 'A', '\\xc5': 'A',\r\n    '\\xe0': 'a',  '\\xe1': 'a', '\\xe2': 'a', '\\xe3': 'a', '\\xe4': 'a', '\\xe5': 'a',\r\n    '\\xc7': 'C',  '\\xe7': 'c',\r\n    '\\xd0': 'D',  '\\xf0': 'd',\r\n    '\\xc8': 'E',  '\\xc9': 'E', '\\xca': 'E', '\\xcb': 'E',\r\n    '\\xe8': 'e',  '\\xe9': 'e', '\\xea': 'e', '\\xeb': 'e',\r\n    '\\xcc': 'I',  '\\xcd': 'I', '\\xce': 'I', '\\xcf': 'I',\r\n    '\\xec': 'i',  '\\xed': 'i', '\\xee': 'i', '\\xef': 'i',\r\n    '\\xd1': 'N',  '\\xf1': 'n',\r\n    '\\xd2': 'O',  '\\xd3': 'O', '\\xd4': 'O', '\\xd5': 'O', '\\xd6': 'O', '\\xd8': 'O',\r\n    '\\xf2': 'o',  '\\xf3': 'o', '\\xf4': 'o', '\\xf5': 'o', '\\xf6': 'o', '\\xf8': 'o',\r\n    '\\xd9': 'U',  '\\xda': 'U', '\\xdb': 'U', '\\xdc': 'U',\r\n    '\\xf9': 'u',  '\\xfa': 'u', '\\xfb': 'u', '\\xfc': 'u',\r\n    '\\xdd': 'Y',  '\\xfd': 'y', '\\xff': 'y',\r\n    '\\xc6': 'Ae', '\\xe6': 'ae',\r\n    '\\xde': 'Th', '\\xfe': 'th',\r\n    '\\xdf': 'ss',\r\n    // Latin Extended-A block.\r\n    '\\u0100': 'A',  '\\u0102': 'A', '\\u0104': 'A',\r\n    '\\u0101': 'a',  '\\u0103': 'a', '\\u0105': 'a',\r\n    '\\u0106': 'C',  '\\u0108': 'C', '\\u010a': 'C', '\\u010c': 'C',\r\n    '\\u0107': 'c',  '\\u0109': 'c', '\\u010b': 'c', '\\u010d': 'c',\r\n    '\\u010e': 'D',  '\\u0110': 'D', '\\u010f': 'd', '\\u0111': 'd',\r\n    '\\u0112': 'E',  '\\u0114': 'E', '\\u0116': 'E', '\\u0118': 'E', '\\u011a': 'E',\r\n    '\\u0113': 'e',  '\\u0115': 'e', '\\u0117': 'e', '\\u0119': 'e', '\\u011b': 'e',\r\n    '\\u011c': 'G',  '\\u011e': 'G', '\\u0120': 'G', '\\u0122': 'G',\r\n    '\\u011d': 'g',  '\\u011f': 'g', '\\u0121': 'g', '\\u0123': 'g',\r\n    '\\u0124': 'H',  '\\u0126': 'H', '\\u0125': 'h', '\\u0127': 'h',\r\n    '\\u0128': 'I',  '\\u012a': 'I', '\\u012c': 'I', '\\u012e': 'I', '\\u0130': 'I',\r\n    '\\u0129': 'i',  '\\u012b': 'i', '\\u012d': 'i', '\\u012f': 'i', '\\u0131': 'i',\r\n    '\\u0134': 'J',  '\\u0135': 'j',\r\n    '\\u0136': 'K',  '\\u0137': 'k', '\\u0138': 'k',\r\n    '\\u0139': 'L',  '\\u013b': 'L', '\\u013d': 'L', '\\u013f': 'L', '\\u0141': 'L',\r\n    '\\u013a': 'l',  '\\u013c': 'l', '\\u013e': 'l', '\\u0140': 'l', '\\u0142': 'l',\r\n    '\\u0143': 'N',  '\\u0145': 'N', '\\u0147': 'N', '\\u014a': 'N',\r\n    '\\u0144': 'n',  '\\u0146': 'n', '\\u0148': 'n', '\\u014b': 'n',\r\n    '\\u014c': 'O',  '\\u014e': 'O', '\\u0150': 'O',\r\n    '\\u014d': 'o',  '\\u014f': 'o', '\\u0151': 'o',\r\n    '\\u0154': 'R',  '\\u0156': 'R', '\\u0158': 'R',\r\n    '\\u0155': 'r',  '\\u0157': 'r', '\\u0159': 'r',\r\n    '\\u015a': 'S',  '\\u015c': 'S', '\\u015e': 'S', '\\u0160': 'S',\r\n    '\\u015b': 's',  '\\u015d': 's', '\\u015f': 's', '\\u0161': 's',\r\n    '\\u0162': 'T',  '\\u0164': 'T', '\\u0166': 'T',\r\n    '\\u0163': 't',  '\\u0165': 't', '\\u0167': 't',\r\n    '\\u0168': 'U',  '\\u016a': 'U', '\\u016c': 'U', '\\u016e': 'U', '\\u0170': 'U', '\\u0172': 'U',\r\n    '\\u0169': 'u',  '\\u016b': 'u', '\\u016d': 'u', '\\u016f': 'u', '\\u0171': 'u', '\\u0173': 'u',\r\n    '\\u0174': 'W',  '\\u0175': 'w',\r\n    '\\u0176': 'Y',  '\\u0177': 'y', '\\u0178': 'Y',\r\n    '\\u0179': 'Z',  '\\u017b': 'Z', '\\u017d': 'Z',\r\n    '\\u017a': 'z',  '\\u017c': 'z', '\\u017e': 'z',\r\n    '\\u0132': 'IJ', '\\u0133': 'ij',\r\n    '\\u0152': 'Oe', '\\u0153': 'oe',\r\n    '\\u0149': \"'n\", '\\u017f': 's'\r\n  };\r\n\r\n  /** Used to map characters to HTML entities. */\r\n  var htmlEscapes = {\r\n    '&': '&amp;',\r\n    '<': '&lt;',\r\n    '>': '&gt;',\r\n    '\"': '&quot;',\r\n    \"'\": '&#39;'\r\n  };\r\n\r\n  /** Used to map HTML entities to characters. */\r\n  var htmlUnescapes = {\r\n    '&amp;': '&',\r\n    '&lt;': '<',\r\n    '&gt;': '>',\r\n    '&quot;': '\"',\r\n    '&#39;': \"'\"\r\n  };\r\n\r\n  /** Used to escape characters for inclusion in compiled string literals. */\r\n  var stringEscapes = {\r\n    '\\\\': '\\\\',\r\n    \"'\": \"'\",\r\n    '\\n': 'n',\r\n    '\\r': 'r',\r\n    '\\u2028': 'u2028',\r\n    '\\u2029': 'u2029'\r\n  };\r\n\r\n  /** Built-in method references without a dependency on `root`. */\r\n  var freeParseFloat = parseFloat,\r\n      freeParseInt = parseInt;\r\n\r\n  /** Detect free variable `global` from Node.js. */\r\n  var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;\r\n\r\n  /** Detect free variable `self`. */\r\n  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;\r\n\r\n  /** Used as a reference to the global object. */\r\n  var root = freeGlobal || freeSelf || Function('return this')();\r\n\r\n  /** Detect free variable `exports`. */\r\n  var freeExports =  true && exports && !exports.nodeType && exports;\r\n\r\n  /** Detect free variable `module`. */\r\n  var freeModule = freeExports && \"object\" == 'object' && module && !module.nodeType && module;\r\n\r\n  /** Detect the popular CommonJS extension `module.exports`. */\r\n  var moduleExports = freeModule && freeModule.exports === freeExports;\r\n\r\n  /** Detect free variable `process` from Node.js. */\r\n  var freeProcess = moduleExports && freeGlobal.process;\r\n\r\n  /** Used to access faster Node.js helpers. */\r\n  var nodeUtil = (function() {\r\n    try {\r\n      // Use `util.types` for Node.js 10+.\r\n      var types = freeModule && freeModule.require && freeModule.require('util').types;\r\n\r\n      if (types) {\r\n        return types;\r\n      }\r\n\r\n      // Legacy `process.binding('util')` for Node.js < 10.\r\n      return freeProcess && freeProcess.binding && freeProcess.binding('util');\r\n    } catch (e) {}\r\n  }());\r\n\r\n  /* Node.js helper references. */\r\n  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,\r\n      nodeIsDate = nodeUtil && nodeUtil.isDate,\r\n      nodeIsMap = nodeUtil && nodeUtil.isMap,\r\n      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,\r\n      nodeIsSet = nodeUtil && nodeUtil.isSet,\r\n      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\r\n\r\n  /*--------------------------------------------------------------------------*/\r\n\r\n  /**\r\n   * A faster alternative to `Function#apply`, this function invokes `func`\r\n   * with the `this` binding of `thisArg` and the arguments of `args`.\r\n   *\r\n   * @private\r\n   * @param {Function} func The function to invoke.\r\n   * @param {*} thisArg The `this` binding of `func`.\r\n   * @param {Array} args The arguments to invoke `func` with.\r\n   * @returns {*} Returns the result of `func`.\r\n   */\r\n  function apply(func, thisArg, args) {\r\n    switch (args.length) {\r\n      case 0: return func.call(thisArg);\r\n      case 1: return func.call(thisArg, args[0]);\r\n      case 2: return func.call(thisArg, args[0], args[1]);\r\n      case 3: return func.call(thisArg, args[0], args[1], args[2]);\r\n    }\r\n    return func.apply(thisArg, args);\r\n  }\r\n\r\n  /**\r\n   * A specialized version of `baseAggregator` for arrays.\r\n   *\r\n   * @private\r\n   * @param {Array} [array] The array to iterate over.\r\n   * @param {Function} setter The function to set `accumulator` values.\r\n   * @param {Function} iteratee The iteratee to transform keys.\r\n   * @param {Object} accumulator The initial aggregated object.\r\n   * @returns {Function} Returns `accumulator`.\r\n   */\r\n  function arrayAggregator(array, setter, iteratee, accumulator) {\r\n    var index = -1,\r\n        length = array == null ? 0 : array.length;\r\n\r\n    while (++index < length) {\r\n      var value = array[index];\r\n      setter(accumulator, value, iteratee(value), array);\r\n    }\r\n    return accumulator;\r\n  }\r\n\r\n  /**\r\n   * A specialized version of `_.forEach` for arrays without support for\r\n   * iteratee shorthands.\r\n   *\r\n   * @private\r\n   * @param {Array} [array] The array to iterate over.\r\n   * @param {Function} iteratee The function invoked per iteration.\r\n   * @returns {Array} Returns `array`.\r\n   */\r\n  function arrayEach(array, iteratee) {\r\n    var index = -1,\r\n        length = array == null ? 0 : array.length;\r\n\r\n    while (++index < length) {\r\n      if (iteratee(array[index], index, array) === false) {\r\n        break;\r\n      }\r\n    }\r\n    return array;\r\n  }\r\n\r\n  /**\r\n   * A specialized version of `_.forEachRight` for arrays without support for\r\n   * iteratee shorthands.\r\n   *\r\n   * @private\r\n   * @param {Array} [array] The array to iterate over.\r\n   * @param {Function} iteratee The function invoked per iteration.\r\n   * @returns {Array} Returns `array`.\r\n   */\r\n  function arrayEachRight(array, iteratee) {\r\n    var length = array == null ? 0 : array.length;\r\n\r\n    while (length--) {\r\n      if (iteratee(array[length], length, array) === false) {\r\n        break;\r\n      }\r\n    }\r\n    return array;\r\n  }\r\n\r\n  /**\r\n   * A specialized version of `_.every` for arrays without support for\r\n   * iteratee shorthands.\r\n   *\r\n   * @private\r\n   * @param {Array} [array] The array to iterate over.\r\n   * @param {Function} predicate The function invoked per iteration.\r\n   * @returns {boolean} Returns `true` if all elements pass the predicate check,\r\n   *  else `false`.\r\n   */\r\n  function arrayEvery(array, predicate) {\r\n    var index = -1,\r\n        length = array == null ? 0 : array.length;\r\n\r\n    while (++index < length) {\r\n      if (!predicate(array[index], index, array)) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * A specialized version of `_.filter` for arrays without support for\r\n   * iteratee shorthands.\r\n   *\r\n   * @private\r\n   * @param {Array} [array] The array to iterate over.\r\n   * @param {Function} predicate The function invoked per iteration.\r\n   * @returns {Array} Returns the new filtered array.\r\n   */\r\n  function arrayFilter(array, predicate) {\r\n    var index = -1,\r\n        length = array == null ? 0 : array.length,\r\n        resIndex = 0,\r\n        result = [];\r\n\r\n    while (++index < length) {\r\n      var value = array[index];\r\n      if (predicate(value, index, array)) {\r\n        result[resIndex++] = value;\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * A specialized version of `_.includes` for arrays without support for\r\n   * specifying an index to search from.\r\n   *\r\n   * @private\r\n   * @param {Array} [array] The array to inspect.\r\n   * @param {*} target The value to search for.\r\n   * @returns {boolean} Returns `true` if `target` is found, else `false`.\r\n   */\r\n  function arrayIncludes(array, value) {\r\n    var length = array == null ? 0 : array.length;\r\n    return !!length && baseIndexOf(array, value, 0) > -1;\r\n  }\r\n\r\n  /**\r\n   * This function is like `arrayIncludes` except that it accepts a comparator.\r\n   *\r\n   * @private\r\n   * @param {Array} [array] The array to inspect.\r\n   * @param {*} target The value to search for.\r\n   * @param {Function} comparator The comparator invoked per element.\r\n   * @returns {boolean} Returns `true` if `target` is found, else `false`.\r\n   */\r\n  function arrayIncludesWith(array, value, comparator) {\r\n    var index = -1,\r\n        length = array == null ? 0 : array.length;\r\n\r\n    while (++index < length) {\r\n      if (comparator(value, array[index])) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * A specialized version of `_.map` for arrays without support for iteratee\r\n   * shorthands.\r\n   *\r\n   * @private\r\n   * @param {Array} [array] The array to iterate over.\r\n   * @param {Function} iteratee The function invoked per iteration.\r\n   * @returns {Array} Returns the new mapped array.\r\n   */\r\n  function arrayMap(array, iteratee) {\r\n    var index = -1,\r\n        length = array == null ? 0 : array.length,\r\n        result = Array(length);\r\n\r\n    while (++index < length) {\r\n      result[index] = iteratee(array[index], index, array);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Appends the elements of `values` to `array`.\r\n   *\r\n   * @private\r\n   * @param {Array} array The array to modify.\r\n   * @param {Array} values The values to append.\r\n   * @returns {Array} Returns `array`.\r\n   */\r\n  function arrayPush(array, values) {\r\n    var index = -1,\r\n        length = values.length,\r\n        offset = array.length;\r\n\r\n    while (++index < length) {\r\n      array[offset + index] = values[index];\r\n    }\r\n    return array;\r\n  }\r\n\r\n  /**\r\n   * A specialized version of `_.reduce` for arrays without support for\r\n   * iteratee shorthands.\r\n   *\r\n   * @private\r\n   * @param {Array} [array] The array to iterate over.\r\n   * @param {Function} iteratee The function invoked per iteration.\r\n   * @param {*} [accumulator] The initial value.\r\n   * @param {boolean} [initAccum] Specify using the first element of `array` as\r\n   *  the initial value.\r\n   * @returns {*} Returns the accumulated value.\r\n   */\r\n  function arrayReduce(array, iteratee, accumulator, initAccum) {\r\n    var index = -1,\r\n        length = array == null ? 0 : array.length;\r\n\r\n    if (initAccum && length) {\r\n      accumulator = array[++index];\r\n    }\r\n    while (++index < length) {\r\n      accumulator = iteratee(accumulator, array[index], index, array);\r\n    }\r\n    return accumulator;\r\n  }\r\n\r\n  /**\r\n   * A specialized version of `_.reduceRight` for arrays without support for\r\n   * iteratee shorthands.\r\n   *\r\n   * @private\r\n   * @param {Array} [array] The array to iterate over.\r\n   * @param {Function} iteratee The function invoked per iteration.\r\n   * @param {*} [accumulator] The initial value.\r\n   * @param {boolean} [initAccum] Specify using the last element of `array` as\r\n   *  the initial value.\r\n   * @returns {*} Returns the accumulated value.\r\n   */\r\n  function arrayReduceRight(array, iteratee, accumulator, initAccum) {\r\n    var length = array == null ? 0 : array.length;\r\n    if (initAccum && length) {\r\n      accumulator = array[--length];\r\n    }\r\n    while (length--) {\r\n      accumulator = iteratee(accumulator, array[length], length, array);\r\n    }\r\n    return accumulator;\r\n  }\r\n\r\n  /**\r\n   * A specialized version of `_.some` for arrays without support for iteratee\r\n   * shorthands.\r\n   *\r\n   * @private\r\n   * @param {Array} [array] The array to iterate over.\r\n   * @param {Function} predicate The function invoked per iteration.\r\n   * @returns {boolean} Returns `true` if any element passes the predicate check,\r\n   *  else `false`.\r\n   */\r\n  function arraySome(array, predicate) {\r\n    var index = -1,\r\n        length = array == null ? 0 : array.length;\r\n\r\n    while (++index < length) {\r\n      if (predicate(array[index], index, array)) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Gets the size of an ASCII `string`.\r\n   *\r\n   * @private\r\n   * @param {string} string The string inspect.\r\n   * @returns {number} Returns the string size.\r\n   */\r\n  var asciiSize = baseProperty('length');\r\n\r\n  /**\r\n   * Converts an ASCII `string` to an array.\r\n   *\r\n   * @private\r\n   * @param {string} string The string to convert.\r\n   * @returns {Array} Returns the converted array.\r\n   */\r\n  function asciiToArray(string) {\r\n    return string.split('');\r\n  }\r\n\r\n  /**\r\n   * Splits an ASCII `string` into an array of its words.\r\n   *\r\n   * @private\r\n   * @param {string} The string to inspect.\r\n   * @returns {Array} Returns the words of `string`.\r\n   */\r\n  function asciiWords(string) {\r\n    return string.match(reAsciiWord) || [];\r\n  }\r\n\r\n  /**\r\n   * The base implementation of methods like `_.findKey` and `_.findLastKey`,\r\n   * without support for iteratee shorthands, which iterates over `collection`\r\n   * using `eachFunc`.\r\n   *\r\n   * @private\r\n   * @param {Array|Object} collection The collection to inspect.\r\n   * @param {Function} predicate The function invoked per iteration.\r\n   * @param {Function} eachFunc The function to iterate over `collection`.\r\n   * @returns {*} Returns the found element or its key, else `undefined`.\r\n   */\r\n  function baseFindKey(collection, predicate, eachFunc) {\r\n    var result;\r\n    eachFunc(collection, function(value, key, collection) {\r\n      if (predicate(value, key, collection)) {\r\n        result = key;\r\n        return false;\r\n      }\r\n    });\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * The base implementation of `_.findIndex` and `_.findLastIndex` without\r\n   * support for iteratee shorthands.\r\n   *\r\n   * @private\r\n   * @param {Array} array The array to inspect.\r\n   * @param {Function} predicate The function invoked per iteration.\r\n   * @param {number} fromIndex The index to search from.\r\n   * @param {boolean} [fromRight] Specify iterating from right to left.\r\n   * @returns {number} Returns the index of the matched value, else `-1`.\r\n   */\r\n  function baseFindIndex(array, predicate, fromIndex, fromRight) {\r\n    var length = array.length,\r\n        index = fromIndex + (fromRight ? 1 : -1);\r\n\r\n    while ((fromRight ? index-- : ++index < length)) {\r\n      if (predicate(array[index], index, array)) {\r\n        return index;\r\n      }\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  /**\r\n   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\r\n   *\r\n   * @private\r\n   * @param {Array} array The array to inspect.\r\n   * @param {*} value The value to search for.\r\n   * @param {number} fromIndex The index to search from.\r\n   * @returns {number} Returns the index of the matched value, else `-1`.\r\n   */\r\n  function baseIndexOf(array, value, fromIndex) {\r\n    return value === value\r\n      ? strictIndexOf(array, value, fromIndex)\r\n      : baseFindIndex(array, baseIsNaN, fromIndex);\r\n  }\r\n\r\n  /**\r\n   * This function is like `baseIndexOf` except that it accepts a comparator.\r\n   *\r\n   * @private\r\n   * @param {Array} array The array to inspect.\r\n   * @param {*} value The value to search for.\r\n   * @param {number} fromIndex The index to search from.\r\n   * @param {Function} comparator The comparator invoked per element.\r\n   * @returns {number} Returns the index of the matched value, else `-1`.\r\n   */\r\n  function baseIndexOfWith(array, value, fromIndex, comparator) {\r\n    var index = fromIndex - 1,\r\n        length = array.length;\r\n\r\n    while (++index < length) {\r\n      if (comparator(array[index], value)) {\r\n        return index;\r\n      }\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  /**\r\n   * The base implementation of `_.isNaN` without support for number objects.\r\n   *\r\n   * @private\r\n   * @param {*} value The value to check.\r\n   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\r\n   */\r\n  function baseIsNaN(value) {\r\n    return value !== value;\r\n  }\r\n\r\n  /**\r\n   * The base implementation of `_.mean` and `_.meanBy` without support for\r\n   * iteratee shorthands.\r\n   *\r\n   * @private\r\n   * @param {Array} array The array to iterate over.\r\n   * @param {Function} iteratee The function invoked per iteration.\r\n   * @returns {number} Returns the mean.\r\n   */\r\n  function baseMean(array, iteratee) {\r\n    var length = array == null ? 0 : array.length;\r\n    return length ? (baseSum(array, iteratee) / length) : NAN;\r\n  }\r\n\r\n  /**\r\n   * The base implementation of `_.property` without support for deep paths.\r\n   *\r\n   * @private\r\n   * @param {string} key The key of the property to get.\r\n   * @returns {Function} Returns the new accessor function.\r\n   */\r\n  function baseProperty(key) {\r\n    return function(object) {\r\n      return object == null ? undefined : object[key];\r\n    };\r\n  }\r\n\r\n  /**\r\n   * The base implementation of `_.propertyOf` without support for deep paths.\r\n   *\r\n   * @private\r\n   * @param {Object} object The object to query.\r\n   * @returns {Function} Returns the new accessor function.\r\n   */\r\n  function basePropertyOf(object) {\r\n    return function(key) {\r\n      return object == null ? undefined : object[key];\r\n    };\r\n  }\r\n\r\n  /**\r\n   * The base implementation of `_.reduce` and `_.reduceRight`, without support\r\n   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.\r\n   *\r\n   * @private\r\n   * @param {Array|Object} collection The collection to iterate over.\r\n   * @param {Function} iteratee The function invoked per iteration.\r\n   * @param {*} accumulator The initial value.\r\n   * @param {boolean} initAccum Specify using the first or last element of\r\n   *  `collection` as the initial value.\r\n   * @param {Function} eachFunc The function to iterate over `collection`.\r\n   * @returns {*} Returns the accumulated value.\r\n   */\r\n  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {\r\n    eachFunc(collection, function(value, index, collection) {\r\n      accumulator = initAccum\r\n        ? (initAccum = false, value)\r\n        : iteratee(accumulator, value, index, collection);\r\n    });\r\n    return accumulator;\r\n  }\r\n\r\n  /**\r\n   * The base implementation of `_.sortBy` which uses `comparer` to define the\r\n   * sort order of `array` and replaces criteria objects with their corresponding\r\n   * values.\r\n   *\r\n   * @private\r\n   * @param {Array} array The array to sort.\r\n   * @param {Function} comparer The function to define sort order.\r\n   * @returns {Array} Returns `array`.\r\n   */\r\n  function baseSortBy(array, comparer) {\r\n    var length = array.length;\r\n\r\n    array.sort(comparer);\r\n    while (length--) {\r\n      array[length] = array[length].value;\r\n    }\r\n    return array;\r\n  }\r\n\r\n  /**\r\n   * The base implementation of `_.sum` and `_.sumBy` without support for\r\n   * iteratee shorthands.\r\n   *\r\n   * @private\r\n   * @param {Array} array The array to iterate over.\r\n   * @param {Function} iteratee The function invoked per iteration.\r\n   * @returns {number} Returns the sum.\r\n   */\r\n  function baseSum(array, iteratee) {\r\n    var result,\r\n        index = -1,\r\n        length = array.length;\r\n\r\n    while (++index < length) {\r\n      var current = iteratee(array[index]);\r\n      if (current !== undefined) {\r\n        result = result === undefined ? current : (result + current);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * The base implementation of `_.times` without support for iteratee shorthands\r\n   * or max array length checks.\r\n   *\r\n   * @private\r\n   * @param {number} n The number of times to invoke `iteratee`.\r\n   * @param {Function} iteratee The function invoked per iteration.\r\n   * @returns {Array} Returns the array of results.\r\n   */\r\n  function baseTimes(n, iteratee) {\r\n    var index = -1,\r\n        result = Array(n);\r\n\r\n    while (++index < n) {\r\n      result[index] = iteratee(index);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array\r\n   * of key-value pairs for `object` corresponding to the property names of `props`.\r\n   *\r\n   * @private\r\n   * @param {Object} object The object to query.\r\n   * @param {Array} props The property names to get values for.\r\n   * @returns {Object} Returns the key-value pairs.\r\n   */\r\n  function baseToPairs(object, props) {\r\n    return arrayMap(props, function(key) {\r\n      return [key, object[key]];\r\n    });\r\n  }\r\n\r\n  /**\r\n   * The base implementation of `_.trim`.\r\n   *\r\n   * @private\r\n   * @param {string} string The string to trim.\r\n   * @returns {string} Returns the trimmed string.\r\n   */\r\n  function baseTrim(string) {\r\n    return string\r\n      ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')\r\n      : string;\r\n  }\r\n\r\n  /**\r\n   * The base implementation of `_.unary` without support for storing metadata.\r\n   *\r\n   * @private\r\n   * @param {Function} func The function to cap arguments for.\r\n   * @returns {Function} Returns the new capped function.\r\n   */\r\n  function baseUnary(func) {\r\n    return function(value) {\r\n      return func(value);\r\n    };\r\n  }\r\n\r\n  /**\r\n   * The base implementation of `_.values` and `_.valuesIn` which creates an\r\n   * array of `object` property values corresponding to the property names\r\n   * of `props`.\r\n   *\r\n   * @private\r\n   * @param {Object} object The object to query.\r\n   * @param {Array} props The property names to get values for.\r\n   * @returns {Object} Returns the array of property values.\r\n   */\r\n  function baseValues(object, props) {\r\n    return arrayMap(props, function(key) {\r\n      return object[key];\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Checks if a `cache` value for `key` exists.\r\n   *\r\n   * @private\r\n   * @param {Object} cache The cache to query.\r\n   * @param {string} key The key of the entry to check.\r\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\r\n   */\r\n  function cacheHas(cache, key) {\r\n    return cache.has(key);\r\n  }\r\n\r\n  /**\r\n   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol\r\n   * that is not found in the character symbols.\r\n   *\r\n   * @private\r\n   * @param {Array} strSymbols The string symbols to inspect.\r\n   * @param {Array} chrSymbols The character symbols to find.\r\n   * @returns {number} Returns the index of the first unmatched string symbol.\r\n   */\r\n  function charsStartIndex(strSymbols, chrSymbols) {\r\n    var index = -1,\r\n        length = strSymbols.length;\r\n\r\n    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\r\n    return index;\r\n  }\r\n\r\n  /**\r\n   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol\r\n   * that is not found in the character symbols.\r\n   *\r\n   * @private\r\n   * @param {Array} strSymbols The string symbols to inspect.\r\n   * @param {Array} chrSymbols The character symbols to find.\r\n   * @returns {number} Returns the index of the last unmatched string symbol.\r\n   */\r\n  function charsEndIndex(strSymbols, chrSymbols) {\r\n    var index = strSymbols.length;\r\n\r\n    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\r\n    return index;\r\n  }\r\n\r\n  /**\r\n   * Gets the number of `placeholder` occurrences in `array`.\r\n   *\r\n   * @private\r\n   * @param {Array} array The array to inspect.\r\n   * @param {*} placeholder The placeholder to search for.\r\n   * @returns {number} Returns the placeholder count.\r\n   */\r\n  function countHolders(array, placeholder) {\r\n    var length = array.length,\r\n        result = 0;\r\n\r\n    while (length--) {\r\n      if (array[length] === placeholder) {\r\n        ++result;\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A\r\n   * letters to basic Latin letters.\r\n   *\r\n   * @private\r\n   * @param {string} letter The matched letter to deburr.\r\n   * @returns {string} Returns the deburred letter.\r\n   */\r\n  var deburrLetter = basePropertyOf(deburredLetters);\r\n\r\n  /**\r\n   * Used by `_.escape` to convert characters to HTML entities.\r\n   *\r\n   * @private\r\n   * @param {string} chr The matched character to escape.\r\n   * @returns {string} Returns the escaped character.\r\n   */\r\n  var escapeHtmlChar = basePropertyOf(htmlEscapes);\r\n\r\n  /**\r\n   * Used by `_.template` to escape characters for inclusion in compiled string literals.\r\n   *\r\n   * @private\r\n   * @param {string} chr The matched character to escape.\r\n   * @returns {string} Returns the escaped character.\r\n   */\r\n  function escapeStringChar(chr) {\r\n    return '\\\\' + stringEscapes[chr];\r\n  }\r\n\r\n  /**\r\n   * Gets the value at `key` of `object`.\r\n   *\r\n   * @private\r\n   * @param {Object} [object] The object to query.\r\n   * @param {string} key The key of the property to get.\r\n   * @returns {*} Returns the property value.\r\n   */\r\n  function getValue(object, key) {\r\n    return object == null ? undefined : object[key];\r\n  }\r\n\r\n  /**\r\n   * Checks if `string` contains Unicode symbols.\r\n   *\r\n   * @private\r\n   * @param {string} string The string to inspect.\r\n   * @returns {boolean} Returns `true` if a symbol is found, else `false`.\r\n   */\r\n  function hasUnicode(string) {\r\n    return reHasUnicode.test(string);\r\n  }\r\n\r\n  /**\r\n   * Checks if `string` contains a word composed of Unicode symbols.\r\n   *\r\n   * @private\r\n   * @param {string} string The string to inspect.\r\n   * @returns {boolean} Returns `true` if a word is found, else `false`.\r\n   */\r\n  function hasUnicodeWord(string) {\r\n    return reHasUnicodeWord.test(string);\r\n  }\r\n\r\n  /**\r\n   * Converts `iterator` to an array.\r\n   *\r\n   * @private\r\n   * @param {Object} iterator The iterator to convert.\r\n   * @returns {Array} Returns the converted array.\r\n   */\r\n  function iteratorToArray(iterator) {\r\n    var data,\r\n        result = [];\r\n\r\n    while (!(data = iterator.next()).done) {\r\n      result.push(data.value);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Converts `map` to its key-value pairs.\r\n   *\r\n   * @private\r\n   * @param {Object} map The map to convert.\r\n   * @returns {Array} Returns the key-value pairs.\r\n   */\r\n  function mapToArray(map) {\r\n    var index = -1,\r\n        result = Array(map.size);\r\n\r\n    map.forEach(function(value, key) {\r\n      result[++index] = [key, value];\r\n    });\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Creates a unary function that invokes `func` with its argument transformed.\r\n   *\r\n   * @private\r\n   * @param {Function} func The function to wrap.\r\n   * @param {Function} transform The argument transform.\r\n   * @returns {Function} Returns the new function.\r\n   */\r\n  function overArg(func, transform) {\r\n    return function(arg) {\r\n      return func(transform(arg));\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Replaces all `placeholder` elements in `array` with an internal placeholder\r\n   * and returns an array of their indexes.\r\n   *\r\n   * @private\r\n   * @param {Array} array The array to modify.\r\n   * @param {*} placeholder The placeholder to replace.\r\n   * @returns {Array} Returns the new array of placeholder indexes.\r\n   */\r\n  function replaceHolders(array, placeholder) {\r\n    var index = -1,\r\n        length = array.length,\r\n        resIndex = 0,\r\n        result = [];\r\n\r\n    while (++index < length) {\r\n      var value = array[index];\r\n      if (value === placeholder || value === PLACEHOLDER) {\r\n        array[index] = PLACEHOLDER;\r\n        result[resIndex++] = index;\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Converts `set` to an array of its values.\r\n   *\r\n   * @private\r\n   * @param {Object} set The set to convert.\r\n   * @returns {Array} Returns the values.\r\n   */\r\n  function setToArray(set) {\r\n    var index = -1,\r\n        result = Array(set.size);\r\n\r\n    set.forEach(function(value) {\r\n      result[++index] = value;\r\n    });\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Converts `set` to its value-value pairs.\r\n   *\r\n   * @private\r\n   * @param {Object} set The set to convert.\r\n   * @returns {Array} Returns the value-value pairs.\r\n   */\r\n  function setToPairs(set) {\r\n    var index = -1,\r\n        result = Array(set.size);\r\n\r\n    set.forEach(function(value) {\r\n      result[++index] = [value, value];\r\n    });\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * A specialized version of `_.indexOf` which performs strict equality\r\n   * comparisons of values, i.e. `===`.\r\n   *\r\n   * @private\r\n   * @param {Array} array The array to inspect.\r\n   * @param {*} value The value to search for.\r\n   * @param {number} fromIndex The index to search from.\r\n   * @returns {number} Returns the index of the matched value, else `-1`.\r\n   */\r\n  function strictIndexOf(array, value, fromIndex) {\r\n    var index = fromIndex - 1,\r\n        length = array.length;\r\n\r\n    while (++index < length) {\r\n      if (array[index] === value) {\r\n        return index;\r\n      }\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  /**\r\n   * A specialized version of `_.lastIndexOf` which performs strict equality\r\n   * comparisons of values, i.e. `===`.\r\n   *\r\n   * @private\r\n   * @param {Array} array The array to inspect.\r\n   * @param {*} value The value to search for.\r\n   * @param {number} fromIndex The index to search from.\r\n   * @returns {number} Returns the index of the matched value, else `-1`.\r\n   */\r\n  function strictLastIndexOf(array, value, fromIndex) {\r\n    var index = fromIndex + 1;\r\n    while (index--) {\r\n      if (array[index] === value) {\r\n        return index;\r\n      }\r\n    }\r\n    return index;\r\n  }\r\n\r\n  /**\r\n   * Gets the number of symbols in `string`.\r\n   *\r\n   * @private\r\n   * @param {string} string The string to inspect.\r\n   * @returns {number} Returns the string size.\r\n   */\r\n  function stringSize(string) {\r\n    return hasUnicode(string)\r\n      ? unicodeSize(string)\r\n      : asciiSize(string);\r\n  }\r\n\r\n  /**\r\n   * Converts `string` to an array.\r\n   *\r\n   * @private\r\n   * @param {string} string The string to convert.\r\n   * @returns {Array} Returns the converted array.\r\n   */\r\n  function stringToArray(string) {\r\n    return hasUnicode(string)\r\n      ? unicodeToArray(string)\r\n      : asciiToArray(string);\r\n  }\r\n\r\n  /**\r\n   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\r\n   * character of `string`.\r\n   *\r\n   * @private\r\n   * @param {string} string The string to inspect.\r\n   * @returns {number} Returns the index of the last non-whitespace character.\r\n   */\r\n  function trimmedEndIndex(string) {\r\n    var index = string.length;\r\n\r\n    while (index-- && reWhitespace.test(string.charAt(index))) {}\r\n    return index;\r\n  }\r\n\r\n  /**\r\n   * Used by `_.unescape` to convert HTML entities to characters.\r\n   *\r\n   * @private\r\n   * @param {string} chr The matched character to unescape.\r\n   * @returns {string} Returns the unescaped character.\r\n   */\r\n  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);\r\n\r\n  /**\r\n   * Gets the size of a Unicode `string`.\r\n   *\r\n   * @private\r\n   * @param {string} string The string inspect.\r\n   * @returns {number} Returns the string size.\r\n   */\r\n  function unicodeSize(string) {\r\n    var result = reUnicode.lastIndex = 0;\r\n    while (reUnicode.test(string)) {\r\n      ++result;\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Converts a Unicode `string` to an array.\r\n   *\r\n   * @private\r\n   * @param {string} string The string to convert.\r\n   * @returns {Array} Returns the converted array.\r\n   */\r\n  function unicodeToArray(string) {\r\n    return string.match(reUnicode) || [];\r\n  }\r\n\r\n  /**\r\n   * Splits a Unicode `string` into an array of its words.\r\n   *\r\n   * @private\r\n   * @param {string} The string to inspect.\r\n   * @returns {Array} Returns the words of `string`.\r\n   */\r\n  function unicodeWords(string) {\r\n    return string.match(reUnicodeWord) || [];\r\n  }\r\n\r\n  /*--------------------------------------------------------------------------*/\r\n\r\n  /**\r\n   * Create a new pristine `lodash` function using the `context` object.\r\n   *\r\n   * @static\r\n   * @memberOf _\r\n   * @since 1.1.0\r\n   * @category Util\r\n   * @param {Object} [context=root] The context object.\r\n   * @returns {Function} Returns a new `lodash` function.\r\n   * @example\r\n   *\r\n   * _.mixin({ 'foo': _.constant('foo') });\r\n   *\r\n   * var lodash = _.runInContext();\r\n   * lodash.mixin({ 'bar': lodash.constant('bar') });\r\n   *\r\n   * _.isFunction(_.foo);\r\n   * // => true\r\n   * _.isFunction(_.bar);\r\n   * // => false\r\n   *\r\n   * lodash.isFunction(lodash.foo);\r\n   * // => false\r\n   * lodash.isFunction(lodash.bar);\r\n   * // => true\r\n   *\r\n   * // Create a suped-up `defer` in Node.js.\r\n   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;\r\n   */\r\n  var runInContext = (function runInContext(context) {\r\n    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));\r\n\r\n    /** Built-in constructor references. */\r\n    var Array = context.Array,\r\n        Date = context.Date,\r\n        Error = context.Error,\r\n        Function = context.Function,\r\n        Math = context.Math,\r\n        Object = context.Object,\r\n        RegExp = context.RegExp,\r\n        String = context.String,\r\n        TypeError = context.TypeError;\r\n\r\n    /** Used for built-in method references. */\r\n    var arrayProto = Array.prototype,\r\n        funcProto = Function.prototype,\r\n        objectProto = Object.prototype;\r\n\r\n    /** Used to detect overreaching core-js shims. */\r\n    var coreJsData = context['__core-js_shared__'];\r\n\r\n    /** Used to resolve the decompiled source of functions. */\r\n    var funcToString = funcProto.toString;\r\n\r\n    /** Used to check objects for own properties. */\r\n    var hasOwnProperty = objectProto.hasOwnProperty;\r\n\r\n    /** Used to generate unique IDs. */\r\n    var idCounter = 0;\r\n\r\n    /** Used to detect methods masquerading as native. */\r\n    var maskSrcKey = (function() {\r\n      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\r\n      return uid ? ('Symbol(src)_1.' + uid) : '';\r\n    }());\r\n\r\n    /**\r\n     * Used to resolve the\r\n     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\r\n     * of values.\r\n     */\r\n    var nativeObjectToString = objectProto.toString;\r\n\r\n    /** Used to infer the `Object` constructor. */\r\n    var objectCtorString = funcToString.call(Object);\r\n\r\n    /** Used to restore the original `_` reference in `_.noConflict`. */\r\n    var oldDash = root._;\r\n\r\n    /** Used to detect if a method is native. */\r\n    var reIsNative = RegExp('^' +\r\n      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\r\n      .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\r\n    );\r\n\r\n    /** Built-in value references. */\r\n    var Buffer = moduleExports ? context.Buffer : undefined,\r\n        Symbol = context.Symbol,\r\n        Uint8Array = context.Uint8Array,\r\n        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,\r\n        getPrototype = overArg(Object.getPrototypeOf, Object),\r\n        objectCreate = Object.create,\r\n        propertyIsEnumerable = objectProto.propertyIsEnumerable,\r\n        splice = arrayProto.splice,\r\n        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,\r\n        symIterator = Symbol ? Symbol.iterator : undefined,\r\n        symToStringTag = Symbol ? Symbol.toStringTag : undefined;\r\n\r\n    var defineProperty = (function() {\r\n      try {\r\n        var func = getNative(Object, 'defineProperty');\r\n        func({}, '', {});\r\n        return func;\r\n      } catch (e) {}\r\n    }());\r\n\r\n    /** Mocked built-ins. */\r\n    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,\r\n        ctxNow = Date && Date.now !== root.Date.now && Date.now,\r\n        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;\r\n\r\n    /* Built-in method references for those with the same name as other `lodash` methods. */\r\n    var nativeCeil = Math.ceil,\r\n        nativeFloor = Math.floor,\r\n        nativeGetSymbols = Object.getOwnPropertySymbols,\r\n        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\r\n        nativeIsFinite = context.isFinite,\r\n        nativeJoin = arrayProto.join,\r\n        nativeKeys = overArg(Object.keys, Object),\r\n        nativeMax = Math.max,\r\n        nativeMin = Math.min,\r\n        nativeNow = Date.now,\r\n        nativeParseInt = context.parseInt,\r\n        nativeRandom = Math.random,\r\n        nativeReverse = arrayProto.reverse;\r\n\r\n    /* Built-in method references that are verified to be native. */\r\n    var DataView = getNative(context, 'DataView'),\r\n        Map = getNative(context, 'Map'),\r\n        Promise = getNative(context, 'Promise'),\r\n        Set = getNative(context, 'Set'),\r\n        WeakMap = getNative(context, 'WeakMap'),\r\n        nativeCreate = getNative(Object, 'create');\r\n\r\n    /** Used to store function metadata. */\r\n    var metaMap = WeakMap && new WeakMap;\r\n\r\n    /** Used to lookup unminified function names. */\r\n    var realNames = {};\r\n\r\n    /** Used to detect maps, sets, and weakmaps. */\r\n    var dataViewCtorString = toSource(DataView),\r\n        mapCtorString = toSource(Map),\r\n        promiseCtorString = toSource(Promise),\r\n        setCtorString = toSource(Set),\r\n        weakMapCtorString = toSource(WeakMap);\r\n\r\n    /** Used to convert symbols to primitives and strings. */\r\n    var symbolProto = Symbol ? Symbol.prototype : undefined,\r\n        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,\r\n        symbolToString = symbolProto ? symbolProto.toString : undefined;\r\n\r\n    /*------------------------------------------------------------------------*/\r\n\r\n    /**\r\n     * Creates a `lodash` object which wraps `value` to enable implicit method\r\n     * chain sequences. Methods that operate on and return arrays, collections,\r\n     * and functions can be chained together. Methods that retrieve a single value\r\n     * or may return a primitive value will automatically end the chain sequence\r\n     * and return the unwrapped value. Otherwise, the value must be unwrapped\r\n     * with `_#value`.\r\n     *\r\n     * Explicit chain sequences, which must be unwrapped with `_#value`, may be\r\n     * enabled using `_.chain`.\r\n     *\r\n     * The execution of chained methods is lazy, that is, it's deferred until\r\n     * `_#value` is implicitly or explicitly called.\r\n     *\r\n     * Lazy evaluation allows several methods to support shortcut fusion.\r\n     * Shortcut fusion is an optimization to merge iteratee calls; this avoids\r\n     * the creation of intermediate arrays and can greatly reduce the number of\r\n     * iteratee executions. Sections of a chain sequence qualify for shortcut\r\n     * fusion if the section is applied to an array and iteratees accept only\r\n     * one argument. The heuristic for whether a section qualifies for shortcut\r\n     * fusion is subject to change.\r\n     *\r\n     * Chaining is supported in custom builds as long as the `_#value` method is\r\n     * directly or indirectly included in the build.\r\n     *\r\n     * In addition to lodash methods, wrappers have `Array` and `String` methods.\r\n     *\r\n     * The wrapper `Array` methods are:\r\n     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`\r\n     *\r\n     * The wrapper `String` methods are:\r\n     * `replace` and `split`\r\n     *\r\n     * The wrapper methods that support shortcut fusion are:\r\n     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,\r\n     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,\r\n     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`\r\n     *\r\n     * The chainable wrapper methods are:\r\n     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,\r\n     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,\r\n     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,\r\n     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,\r\n     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,\r\n     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,\r\n     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,\r\n     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,\r\n     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,\r\n     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,\r\n     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,\r\n     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,\r\n     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,\r\n     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,\r\n     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,\r\n     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,\r\n     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,\r\n     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,\r\n     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,\r\n     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,\r\n     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,\r\n     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,\r\n     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,\r\n     * `zipObject`, `zipObjectDeep`, and `zipWith`\r\n     *\r\n     * The wrapper methods that are **not** chainable by default are:\r\n     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,\r\n     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,\r\n     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,\r\n     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,\r\n     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,\r\n     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,\r\n     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,\r\n     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,\r\n     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,\r\n     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,\r\n     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,\r\n     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,\r\n     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,\r\n     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,\r\n     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,\r\n     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,\r\n     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,\r\n     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,\r\n     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,\r\n     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,\r\n     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,\r\n     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,\r\n     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,\r\n     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,\r\n     * `upperFirst`, `value`, and `words`\r\n     *\r\n     * @name _\r\n     * @constructor\r\n     * @category Seq\r\n     * @param {*} value The value to wrap in a `lodash` instance.\r\n     * @returns {Object} Returns the new `lodash` wrapper instance.\r\n     * @example\r\n     *\r\n     * function square(n) {\r\n     *   return n * n;\r\n     * }\r\n     *\r\n     * var wrapped = _([1, 2, 3]);\r\n     *\r\n     * // Returns an unwrapped value.\r\n     * wrapped.reduce(_.add);\r\n     * // => 6\r\n     *\r\n     * // Returns a wrapped value.\r\n     * var squares = wrapped.map(square);\r\n     *\r\n     * _.isArray(squares);\r\n     * // => false\r\n     *\r\n     * _.isArray(squares.value());\r\n     * // => true\r\n     */\r\n    function lodash(value) {\r\n      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {\r\n        if (value instanceof LodashWrapper) {\r\n          return value;\r\n        }\r\n        if (hasOwnProperty.call(value, '__wrapped__')) {\r\n          return wrapperClone(value);\r\n        }\r\n      }\r\n      return new LodashWrapper(value);\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.create` without support for assigning\r\n     * properties to the created object.\r\n     *\r\n     * @private\r\n     * @param {Object} proto The object to inherit from.\r\n     * @returns {Object} Returns the new object.\r\n     */\r\n    var baseCreate = (function() {\r\n      function object() {}\r\n      return function(proto) {\r\n        if (!isObject(proto)) {\r\n          return {};\r\n        }\r\n        if (objectCreate) {\r\n          return objectCreate(proto);\r\n        }\r\n        object.prototype = proto;\r\n        var result = new object;\r\n        object.prototype = undefined;\r\n        return result;\r\n      };\r\n    }());\r\n\r\n    /**\r\n     * The function whose prototype chain sequence wrappers inherit from.\r\n     *\r\n     * @private\r\n     */\r\n    function baseLodash() {\r\n      // No operation performed.\r\n    }\r\n\r\n    /**\r\n     * The base constructor for creating `lodash` wrapper objects.\r\n     *\r\n     * @private\r\n     * @param {*} value The value to wrap.\r\n     * @param {boolean} [chainAll] Enable explicit method chain sequences.\r\n     */\r\n    function LodashWrapper(value, chainAll) {\r\n      this.__wrapped__ = value;\r\n      this.__actions__ = [];\r\n      this.__chain__ = !!chainAll;\r\n      this.__index__ = 0;\r\n      this.__values__ = undefined;\r\n    }\r\n\r\n    /**\r\n     * By default, the template delimiters used by lodash are like those in\r\n     * embedded Ruby (ERB) as well as ES2015 template strings. Change the\r\n     * following template settings to use alternative delimiters.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @type {Object}\r\n     */\r\n    lodash.templateSettings = {\r\n\r\n      /**\r\n       * Used to detect `data` property values to be HTML-escaped.\r\n       *\r\n       * @memberOf _.templateSettings\r\n       * @type {RegExp}\r\n       */\r\n      'escape': reEscape,\r\n\r\n      /**\r\n       * Used to detect code to be evaluated.\r\n       *\r\n       * @memberOf _.templateSettings\r\n       * @type {RegExp}\r\n       */\r\n      'evaluate': reEvaluate,\r\n\r\n      /**\r\n       * Used to detect `data` property values to inject.\r\n       *\r\n       * @memberOf _.templateSettings\r\n       * @type {RegExp}\r\n       */\r\n      'interpolate': reInterpolate,\r\n\r\n      /**\r\n       * Used to reference the data object in the template text.\r\n       *\r\n       * @memberOf _.templateSettings\r\n       * @type {string}\r\n       */\r\n      'variable': '',\r\n\r\n      /**\r\n       * Used to import variables into the compiled template.\r\n       *\r\n       * @memberOf _.templateSettings\r\n       * @type {Object}\r\n       */\r\n      'imports': {\r\n\r\n        /**\r\n         * A reference to the `lodash` function.\r\n         *\r\n         * @memberOf _.templateSettings.imports\r\n         * @type {Function}\r\n         */\r\n        '_': lodash\r\n      }\r\n    };\r\n\r\n    // Ensure wrappers are instances of `baseLodash`.\r\n    lodash.prototype = baseLodash.prototype;\r\n    lodash.prototype.constructor = lodash;\r\n\r\n    LodashWrapper.prototype = baseCreate(baseLodash.prototype);\r\n    LodashWrapper.prototype.constructor = LodashWrapper;\r\n\r\n    /*------------------------------------------------------------------------*/\r\n\r\n    /**\r\n     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.\r\n     *\r\n     * @private\r\n     * @constructor\r\n     * @param {*} value The value to wrap.\r\n     */\r\n    function LazyWrapper(value) {\r\n      this.__wrapped__ = value;\r\n      this.__actions__ = [];\r\n      this.__dir__ = 1;\r\n      this.__filtered__ = false;\r\n      this.__iteratees__ = [];\r\n      this.__takeCount__ = MAX_ARRAY_LENGTH;\r\n      this.__views__ = [];\r\n    }\r\n\r\n    /**\r\n     * Creates a clone of the lazy wrapper object.\r\n     *\r\n     * @private\r\n     * @name clone\r\n     * @memberOf LazyWrapper\r\n     * @returns {Object} Returns the cloned `LazyWrapper` object.\r\n     */\r\n    function lazyClone() {\r\n      var result = new LazyWrapper(this.__wrapped__);\r\n      result.__actions__ = copyArray(this.__actions__);\r\n      result.__dir__ = this.__dir__;\r\n      result.__filtered__ = this.__filtered__;\r\n      result.__iteratees__ = copyArray(this.__iteratees__);\r\n      result.__takeCount__ = this.__takeCount__;\r\n      result.__views__ = copyArray(this.__views__);\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Reverses the direction of lazy iteration.\r\n     *\r\n     * @private\r\n     * @name reverse\r\n     * @memberOf LazyWrapper\r\n     * @returns {Object} Returns the new reversed `LazyWrapper` object.\r\n     */\r\n    function lazyReverse() {\r\n      if (this.__filtered__) {\r\n        var result = new LazyWrapper(this);\r\n        result.__dir__ = -1;\r\n        result.__filtered__ = true;\r\n      } else {\r\n        result = this.clone();\r\n        result.__dir__ *= -1;\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Extracts the unwrapped value from its lazy wrapper.\r\n     *\r\n     * @private\r\n     * @name value\r\n     * @memberOf LazyWrapper\r\n     * @returns {*} Returns the unwrapped value.\r\n     */\r\n    function lazyValue() {\r\n      var array = this.__wrapped__.value(),\r\n          dir = this.__dir__,\r\n          isArr = isArray(array),\r\n          isRight = dir < 0,\r\n          arrLength = isArr ? array.length : 0,\r\n          view = getView(0, arrLength, this.__views__),\r\n          start = view.start,\r\n          end = view.end,\r\n          length = end - start,\r\n          index = isRight ? end : (start - 1),\r\n          iteratees = this.__iteratees__,\r\n          iterLength = iteratees.length,\r\n          resIndex = 0,\r\n          takeCount = nativeMin(length, this.__takeCount__);\r\n\r\n      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {\r\n        return baseWrapperValue(array, this.__actions__);\r\n      }\r\n      var result = [];\r\n\r\n      outer:\r\n      while (length-- && resIndex < takeCount) {\r\n        index += dir;\r\n\r\n        var iterIndex = -1,\r\n            value = array[index];\r\n\r\n        while (++iterIndex < iterLength) {\r\n          var data = iteratees[iterIndex],\r\n              iteratee = data.iteratee,\r\n              type = data.type,\r\n              computed = iteratee(value);\r\n\r\n          if (type == LAZY_MAP_FLAG) {\r\n            value = computed;\r\n          } else if (!computed) {\r\n            if (type == LAZY_FILTER_FLAG) {\r\n              continue outer;\r\n            } else {\r\n              break outer;\r\n            }\r\n          }\r\n        }\r\n        result[resIndex++] = value;\r\n      }\r\n      return result;\r\n    }\r\n\r\n    // Ensure `LazyWrapper` is an instance of `baseLodash`.\r\n    LazyWrapper.prototype = baseCreate(baseLodash.prototype);\r\n    LazyWrapper.prototype.constructor = LazyWrapper;\r\n\r\n    /*------------------------------------------------------------------------*/\r\n\r\n    /**\r\n     * Creates a hash object.\r\n     *\r\n     * @private\r\n     * @constructor\r\n     * @param {Array} [entries] The key-value pairs to cache.\r\n     */\r\n    function Hash(entries) {\r\n      var index = -1,\r\n          length = entries == null ? 0 : entries.length;\r\n\r\n      this.clear();\r\n      while (++index < length) {\r\n        var entry = entries[index];\r\n        this.set(entry[0], entry[1]);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Removes all key-value entries from the hash.\r\n     *\r\n     * @private\r\n     * @name clear\r\n     * @memberOf Hash\r\n     */\r\n    function hashClear() {\r\n      this.__data__ = nativeCreate ? nativeCreate(null) : {};\r\n      this.size = 0;\r\n    }\r\n\r\n    /**\r\n     * Removes `key` and its value from the hash.\r\n     *\r\n     * @private\r\n     * @name delete\r\n     * @memberOf Hash\r\n     * @param {Object} hash The hash to modify.\r\n     * @param {string} key The key of the value to remove.\r\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\r\n     */\r\n    function hashDelete(key) {\r\n      var result = this.has(key) && delete this.__data__[key];\r\n      this.size -= result ? 1 : 0;\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Gets the hash value for `key`.\r\n     *\r\n     * @private\r\n     * @name get\r\n     * @memberOf Hash\r\n     * @param {string} key The key of the value to get.\r\n     * @returns {*} Returns the entry value.\r\n     */\r\n    function hashGet(key) {\r\n      var data = this.__data__;\r\n      if (nativeCreate) {\r\n        var result = data[key];\r\n        return result === HASH_UNDEFINED ? undefined : result;\r\n      }\r\n      return hasOwnProperty.call(data, key) ? data[key] : undefined;\r\n    }\r\n\r\n    /**\r\n     * Checks if a hash value for `key` exists.\r\n     *\r\n     * @private\r\n     * @name has\r\n     * @memberOf Hash\r\n     * @param {string} key The key of the entry to check.\r\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\r\n     */\r\n    function hashHas(key) {\r\n      var data = this.__data__;\r\n      return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\r\n    }\r\n\r\n    /**\r\n     * Sets the hash `key` to `value`.\r\n     *\r\n     * @private\r\n     * @name set\r\n     * @memberOf Hash\r\n     * @param {string} key The key of the value to set.\r\n     * @param {*} value The value to set.\r\n     * @returns {Object} Returns the hash instance.\r\n     */\r\n    function hashSet(key, value) {\r\n      var data = this.__data__;\r\n      this.size += this.has(key) ? 0 : 1;\r\n      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\r\n      return this;\r\n    }\r\n\r\n    // Add methods to `Hash`.\r\n    Hash.prototype.clear = hashClear;\r\n    Hash.prototype['delete'] = hashDelete;\r\n    Hash.prototype.get = hashGet;\r\n    Hash.prototype.has = hashHas;\r\n    Hash.prototype.set = hashSet;\r\n\r\n    /*------------------------------------------------------------------------*/\r\n\r\n    /**\r\n     * Creates an list cache object.\r\n     *\r\n     * @private\r\n     * @constructor\r\n     * @param {Array} [entries] The key-value pairs to cache.\r\n     */\r\n    function ListCache(entries) {\r\n      var index = -1,\r\n          length = entries == null ? 0 : entries.length;\r\n\r\n      this.clear();\r\n      while (++index < length) {\r\n        var entry = entries[index];\r\n        this.set(entry[0], entry[1]);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Removes all key-value entries from the list cache.\r\n     *\r\n     * @private\r\n     * @name clear\r\n     * @memberOf ListCache\r\n     */\r\n    function listCacheClear() {\r\n      this.__data__ = [];\r\n      this.size = 0;\r\n    }\r\n\r\n    /**\r\n     * Removes `key` and its value from the list cache.\r\n     *\r\n     * @private\r\n     * @name delete\r\n     * @memberOf ListCache\r\n     * @param {string} key The key of the value to remove.\r\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\r\n     */\r\n    function listCacheDelete(key) {\r\n      var data = this.__data__,\r\n          index = assocIndexOf(data, key);\r\n\r\n      if (index < 0) {\r\n        return false;\r\n      }\r\n      var lastIndex = data.length - 1;\r\n      if (index == lastIndex) {\r\n        data.pop();\r\n      } else {\r\n        splice.call(data, index, 1);\r\n      }\r\n      --this.size;\r\n      return true;\r\n    }\r\n\r\n    /**\r\n     * Gets the list cache value for `key`.\r\n     *\r\n     * @private\r\n     * @name get\r\n     * @memberOf ListCache\r\n     * @param {string} key The key of the value to get.\r\n     * @returns {*} Returns the entry value.\r\n     */\r\n    function listCacheGet(key) {\r\n      var data = this.__data__,\r\n          index = assocIndexOf(data, key);\r\n\r\n      return index < 0 ? undefined : data[index][1];\r\n    }\r\n\r\n    /**\r\n     * Checks if a list cache value for `key` exists.\r\n     *\r\n     * @private\r\n     * @name has\r\n     * @memberOf ListCache\r\n     * @param {string} key The key of the entry to check.\r\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\r\n     */\r\n    function listCacheHas(key) {\r\n      return assocIndexOf(this.__data__, key) > -1;\r\n    }\r\n\r\n    /**\r\n     * Sets the list cache `key` to `value`.\r\n     *\r\n     * @private\r\n     * @name set\r\n     * @memberOf ListCache\r\n     * @param {string} key The key of the value to set.\r\n     * @param {*} value The value to set.\r\n     * @returns {Object} Returns the list cache instance.\r\n     */\r\n    function listCacheSet(key, value) {\r\n      var data = this.__data__,\r\n          index = assocIndexOf(data, key);\r\n\r\n      if (index < 0) {\r\n        ++this.size;\r\n        data.push([key, value]);\r\n      } else {\r\n        data[index][1] = value;\r\n      }\r\n      return this;\r\n    }\r\n\r\n    // Add methods to `ListCache`.\r\n    ListCache.prototype.clear = listCacheClear;\r\n    ListCache.prototype['delete'] = listCacheDelete;\r\n    ListCache.prototype.get = listCacheGet;\r\n    ListCache.prototype.has = listCacheHas;\r\n    ListCache.prototype.set = listCacheSet;\r\n\r\n    /*------------------------------------------------------------------------*/\r\n\r\n    /**\r\n     * Creates a map cache object to store key-value pairs.\r\n     *\r\n     * @private\r\n     * @constructor\r\n     * @param {Array} [entries] The key-value pairs to cache.\r\n     */\r\n    function MapCache(entries) {\r\n      var index = -1,\r\n          length = entries == null ? 0 : entries.length;\r\n\r\n      this.clear();\r\n      while (++index < length) {\r\n        var entry = entries[index];\r\n        this.set(entry[0], entry[1]);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Removes all key-value entries from the map.\r\n     *\r\n     * @private\r\n     * @name clear\r\n     * @memberOf MapCache\r\n     */\r\n    function mapCacheClear() {\r\n      this.size = 0;\r\n      this.__data__ = {\r\n        'hash': new Hash,\r\n        'map': new (Map || ListCache),\r\n        'string': new Hash\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Removes `key` and its value from the map.\r\n     *\r\n     * @private\r\n     * @name delete\r\n     * @memberOf MapCache\r\n     * @param {string} key The key of the value to remove.\r\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\r\n     */\r\n    function mapCacheDelete(key) {\r\n      var result = getMapData(this, key)['delete'](key);\r\n      this.size -= result ? 1 : 0;\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Gets the map value for `key`.\r\n     *\r\n     * @private\r\n     * @name get\r\n     * @memberOf MapCache\r\n     * @param {string} key The key of the value to get.\r\n     * @returns {*} Returns the entry value.\r\n     */\r\n    function mapCacheGet(key) {\r\n      return getMapData(this, key).get(key);\r\n    }\r\n\r\n    /**\r\n     * Checks if a map value for `key` exists.\r\n     *\r\n     * @private\r\n     * @name has\r\n     * @memberOf MapCache\r\n     * @param {string} key The key of the entry to check.\r\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\r\n     */\r\n    function mapCacheHas(key) {\r\n      return getMapData(this, key).has(key);\r\n    }\r\n\r\n    /**\r\n     * Sets the map `key` to `value`.\r\n     *\r\n     * @private\r\n     * @name set\r\n     * @memberOf MapCache\r\n     * @param {string} key The key of the value to set.\r\n     * @param {*} value The value to set.\r\n     * @returns {Object} Returns the map cache instance.\r\n     */\r\n    function mapCacheSet(key, value) {\r\n      var data = getMapData(this, key),\r\n          size = data.size;\r\n\r\n      data.set(key, value);\r\n      this.size += data.size == size ? 0 : 1;\r\n      return this;\r\n    }\r\n\r\n    // Add methods to `MapCache`.\r\n    MapCache.prototype.clear = mapCacheClear;\r\n    MapCache.prototype['delete'] = mapCacheDelete;\r\n    MapCache.prototype.get = mapCacheGet;\r\n    MapCache.prototype.has = mapCacheHas;\r\n    MapCache.prototype.set = mapCacheSet;\r\n\r\n    /*------------------------------------------------------------------------*/\r\n\r\n    /**\r\n     *\r\n     * Creates an array cache object to store unique values.\r\n     *\r\n     * @private\r\n     * @constructor\r\n     * @param {Array} [values] The values to cache.\r\n     */\r\n    function SetCache(values) {\r\n      var index = -1,\r\n          length = values == null ? 0 : values.length;\r\n\r\n      this.__data__ = new MapCache;\r\n      while (++index < length) {\r\n        this.add(values[index]);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Adds `value` to the array cache.\r\n     *\r\n     * @private\r\n     * @name add\r\n     * @memberOf SetCache\r\n     * @alias push\r\n     * @param {*} value The value to cache.\r\n     * @returns {Object} Returns the cache instance.\r\n     */\r\n    function setCacheAdd(value) {\r\n      this.__data__.set(value, HASH_UNDEFINED);\r\n      return this;\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is in the array cache.\r\n     *\r\n     * @private\r\n     * @name has\r\n     * @memberOf SetCache\r\n     * @param {*} value The value to search for.\r\n     * @returns {number} Returns `true` if `value` is found, else `false`.\r\n     */\r\n    function setCacheHas(value) {\r\n      return this.__data__.has(value);\r\n    }\r\n\r\n    // Add methods to `SetCache`.\r\n    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\r\n    SetCache.prototype.has = setCacheHas;\r\n\r\n    /*------------------------------------------------------------------------*/\r\n\r\n    /**\r\n     * Creates a stack cache object to store key-value pairs.\r\n     *\r\n     * @private\r\n     * @constructor\r\n     * @param {Array} [entries] The key-value pairs to cache.\r\n     */\r\n    function Stack(entries) {\r\n      var data = this.__data__ = new ListCache(entries);\r\n      this.size = data.size;\r\n    }\r\n\r\n    /**\r\n     * Removes all key-value entries from the stack.\r\n     *\r\n     * @private\r\n     * @name clear\r\n     * @memberOf Stack\r\n     */\r\n    function stackClear() {\r\n      this.__data__ = new ListCache;\r\n      this.size = 0;\r\n    }\r\n\r\n    /**\r\n     * Removes `key` and its value from the stack.\r\n     *\r\n     * @private\r\n     * @name delete\r\n     * @memberOf Stack\r\n     * @param {string} key The key of the value to remove.\r\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\r\n     */\r\n    function stackDelete(key) {\r\n      var data = this.__data__,\r\n          result = data['delete'](key);\r\n\r\n      this.size = data.size;\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Gets the stack value for `key`.\r\n     *\r\n     * @private\r\n     * @name get\r\n     * @memberOf Stack\r\n     * @param {string} key The key of the value to get.\r\n     * @returns {*} Returns the entry value.\r\n     */\r\n    function stackGet(key) {\r\n      return this.__data__.get(key);\r\n    }\r\n\r\n    /**\r\n     * Checks if a stack value for `key` exists.\r\n     *\r\n     * @private\r\n     * @name has\r\n     * @memberOf Stack\r\n     * @param {string} key The key of the entry to check.\r\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\r\n     */\r\n    function stackHas(key) {\r\n      return this.__data__.has(key);\r\n    }\r\n\r\n    /**\r\n     * Sets the stack `key` to `value`.\r\n     *\r\n     * @private\r\n     * @name set\r\n     * @memberOf Stack\r\n     * @param {string} key The key of the value to set.\r\n     * @param {*} value The value to set.\r\n     * @returns {Object} Returns the stack cache instance.\r\n     */\r\n    function stackSet(key, value) {\r\n      var data = this.__data__;\r\n      if (data instanceof ListCache) {\r\n        var pairs = data.__data__;\r\n        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\r\n          pairs.push([key, value]);\r\n          this.size = ++data.size;\r\n          return this;\r\n        }\r\n        data = this.__data__ = new MapCache(pairs);\r\n      }\r\n      data.set(key, value);\r\n      this.size = data.size;\r\n      return this;\r\n    }\r\n\r\n    // Add methods to `Stack`.\r\n    Stack.prototype.clear = stackClear;\r\n    Stack.prototype['delete'] = stackDelete;\r\n    Stack.prototype.get = stackGet;\r\n    Stack.prototype.has = stackHas;\r\n    Stack.prototype.set = stackSet;\r\n\r\n    /*------------------------------------------------------------------------*/\r\n\r\n    /**\r\n     * Creates an array of the enumerable property names of the array-like `value`.\r\n     *\r\n     * @private\r\n     * @param {*} value The value to query.\r\n     * @param {boolean} inherited Specify returning inherited property names.\r\n     * @returns {Array} Returns the array of property names.\r\n     */\r\n    function arrayLikeKeys(value, inherited) {\r\n      var isArr = isArray(value),\r\n          isArg = !isArr && isArguments(value),\r\n          isBuff = !isArr && !isArg && isBuffer(value),\r\n          isType = !isArr && !isArg && !isBuff && isTypedArray(value),\r\n          skipIndexes = isArr || isArg || isBuff || isType,\r\n          result = skipIndexes ? baseTimes(value.length, String) : [],\r\n          length = result.length;\r\n\r\n      for (var key in value) {\r\n        if ((inherited || hasOwnProperty.call(value, key)) &&\r\n            !(skipIndexes && (\r\n               // Safari 9 has enumerable `arguments.length` in strict mode.\r\n               key == 'length' ||\r\n               // Node.js 0.10 has enumerable non-index properties on buffers.\r\n               (isBuff && (key == 'offset' || key == 'parent')) ||\r\n               // PhantomJS 2 has enumerable non-index properties on typed arrays.\r\n               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\r\n               // Skip index properties.\r\n               isIndex(key, length)\r\n            ))) {\r\n          result.push(key);\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * A specialized version of `_.sample` for arrays.\r\n     *\r\n     * @private\r\n     * @param {Array} array The array to sample.\r\n     * @returns {*} Returns the random element.\r\n     */\r\n    function arraySample(array) {\r\n      var length = array.length;\r\n      return length ? array[baseRandom(0, length - 1)] : undefined;\r\n    }\r\n\r\n    /**\r\n     * A specialized version of `_.sampleSize` for arrays.\r\n     *\r\n     * @private\r\n     * @param {Array} array The array to sample.\r\n     * @param {number} n The number of elements to sample.\r\n     * @returns {Array} Returns the random elements.\r\n     */\r\n    function arraySampleSize(array, n) {\r\n      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));\r\n    }\r\n\r\n    /**\r\n     * A specialized version of `_.shuffle` for arrays.\r\n     *\r\n     * @private\r\n     * @param {Array} array The array to shuffle.\r\n     * @returns {Array} Returns the new shuffled array.\r\n     */\r\n    function arrayShuffle(array) {\r\n      return shuffleSelf(copyArray(array));\r\n    }\r\n\r\n    /**\r\n     * This function is like `assignValue` except that it doesn't assign\r\n     * `undefined` values.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to modify.\r\n     * @param {string} key The key of the property to assign.\r\n     * @param {*} value The value to assign.\r\n     */\r\n    function assignMergeValue(object, key, value) {\r\n      if ((value !== undefined && !eq(object[key], value)) ||\r\n          (value === undefined && !(key in object))) {\r\n        baseAssignValue(object, key, value);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Assigns `value` to `key` of `object` if the existing value is not equivalent\r\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\r\n     * for equality comparisons.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to modify.\r\n     * @param {string} key The key of the property to assign.\r\n     * @param {*} value The value to assign.\r\n     */\r\n    function assignValue(object, key, value) {\r\n      var objValue = object[key];\r\n      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\r\n          (value === undefined && !(key in object))) {\r\n        baseAssignValue(object, key, value);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Gets the index at which the `key` is found in `array` of key-value pairs.\r\n     *\r\n     * @private\r\n     * @param {Array} array The array to inspect.\r\n     * @param {*} key The key to search for.\r\n     * @returns {number} Returns the index of the matched value, else `-1`.\r\n     */\r\n    function assocIndexOf(array, key) {\r\n      var length = array.length;\r\n      while (length--) {\r\n        if (eq(array[length][0], key)) {\r\n          return length;\r\n        }\r\n      }\r\n      return -1;\r\n    }\r\n\r\n    /**\r\n     * Aggregates elements of `collection` on `accumulator` with keys transformed\r\n     * by `iteratee` and values set by `setter`.\r\n     *\r\n     * @private\r\n     * @param {Array|Object} collection The collection to iterate over.\r\n     * @param {Function} setter The function to set `accumulator` values.\r\n     * @param {Function} iteratee The iteratee to transform keys.\r\n     * @param {Object} accumulator The initial aggregated object.\r\n     * @returns {Function} Returns `accumulator`.\r\n     */\r\n    function baseAggregator(collection, setter, iteratee, accumulator) {\r\n      baseEach(collection, function(value, key, collection) {\r\n        setter(accumulator, value, iteratee(value), collection);\r\n      });\r\n      return accumulator;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.assign` without support for multiple sources\r\n     * or `customizer` functions.\r\n     *\r\n     * @private\r\n     * @param {Object} object The destination object.\r\n     * @param {Object} source The source object.\r\n     * @returns {Object} Returns `object`.\r\n     */\r\n    function baseAssign(object, source) {\r\n      return object && copyObject(source, keys(source), object);\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.assignIn` without support for multiple sources\r\n     * or `customizer` functions.\r\n     *\r\n     * @private\r\n     * @param {Object} object The destination object.\r\n     * @param {Object} source The source object.\r\n     * @returns {Object} Returns `object`.\r\n     */\r\n    function baseAssignIn(object, source) {\r\n      return object && copyObject(source, keysIn(source), object);\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `assignValue` and `assignMergeValue` without\r\n     * value checks.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to modify.\r\n     * @param {string} key The key of the property to assign.\r\n     * @param {*} value The value to assign.\r\n     */\r\n    function baseAssignValue(object, key, value) {\r\n      if (key == '__proto__' && defineProperty) {\r\n        defineProperty(object, key, {\r\n          'configurable': true,\r\n          'enumerable': true,\r\n          'value': value,\r\n          'writable': true\r\n        });\r\n      } else {\r\n        object[key] = value;\r\n      }\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.at` without support for individual paths.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to iterate over.\r\n     * @param {string[]} paths The property paths to pick.\r\n     * @returns {Array} Returns the picked elements.\r\n     */\r\n    function baseAt(object, paths) {\r\n      var index = -1,\r\n          length = paths.length,\r\n          result = Array(length),\r\n          skip = object == null;\r\n\r\n      while (++index < length) {\r\n        result[index] = skip ? undefined : get(object, paths[index]);\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.clamp` which doesn't coerce arguments.\r\n     *\r\n     * @private\r\n     * @param {number} number The number to clamp.\r\n     * @param {number} [lower] The lower bound.\r\n     * @param {number} upper The upper bound.\r\n     * @returns {number} Returns the clamped number.\r\n     */\r\n    function baseClamp(number, lower, upper) {\r\n      if (number === number) {\r\n        if (upper !== undefined) {\r\n          number = number <= upper ? number : upper;\r\n        }\r\n        if (lower !== undefined) {\r\n          number = number >= lower ? number : lower;\r\n        }\r\n      }\r\n      return number;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.clone` and `_.cloneDeep` which tracks\r\n     * traversed objects.\r\n     *\r\n     * @private\r\n     * @param {*} value The value to clone.\r\n     * @param {boolean} bitmask The bitmask flags.\r\n     *  1 - Deep clone\r\n     *  2 - Flatten inherited properties\r\n     *  4 - Clone symbols\r\n     * @param {Function} [customizer] The function to customize cloning.\r\n     * @param {string} [key] The key of `value`.\r\n     * @param {Object} [object] The parent object of `value`.\r\n     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\r\n     * @returns {*} Returns the cloned value.\r\n     */\r\n    function baseClone(value, bitmask, customizer, key, object, stack) {\r\n      var result,\r\n          isDeep = bitmask & CLONE_DEEP_FLAG,\r\n          isFlat = bitmask & CLONE_FLAT_FLAG,\r\n          isFull = bitmask & CLONE_SYMBOLS_FLAG;\r\n\r\n      if (customizer) {\r\n        result = object ? customizer(value, key, object, stack) : customizer(value);\r\n      }\r\n      if (result !== undefined) {\r\n        return result;\r\n      }\r\n      if (!isObject(value)) {\r\n        return value;\r\n      }\r\n      var isArr = isArray(value);\r\n      if (isArr) {\r\n        result = initCloneArray(value);\r\n        if (!isDeep) {\r\n          return copyArray(value, result);\r\n        }\r\n      } else {\r\n        var tag = getTag(value),\r\n            isFunc = tag == funcTag || tag == genTag;\r\n\r\n        if (isBuffer(value)) {\r\n          return cloneBuffer(value, isDeep);\r\n        }\r\n        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\r\n          result = (isFlat || isFunc) ? {} : initCloneObject(value);\r\n          if (!isDeep) {\r\n            return isFlat\r\n              ? copySymbolsIn(value, baseAssignIn(result, value))\r\n              : copySymbols(value, baseAssign(result, value));\r\n          }\r\n        } else {\r\n          if (!cloneableTags[tag]) {\r\n            return object ? value : {};\r\n          }\r\n          result = initCloneByTag(value, tag, isDeep);\r\n        }\r\n      }\r\n      // Check for circular references and return its corresponding clone.\r\n      stack || (stack = new Stack);\r\n      var stacked = stack.get(value);\r\n      if (stacked) {\r\n        return stacked;\r\n      }\r\n      stack.set(value, result);\r\n\r\n      if (isSet(value)) {\r\n        value.forEach(function(subValue) {\r\n          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));\r\n        });\r\n      } else if (isMap(value)) {\r\n        value.forEach(function(subValue, key) {\r\n          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));\r\n        });\r\n      }\r\n\r\n      var keysFunc = isFull\r\n        ? (isFlat ? getAllKeysIn : getAllKeys)\r\n        : (isFlat ? keysIn : keys);\r\n\r\n      var props = isArr ? undefined : keysFunc(value);\r\n      arrayEach(props || value, function(subValue, key) {\r\n        if (props) {\r\n          key = subValue;\r\n          subValue = value[key];\r\n        }\r\n        // Recursively populate clone (susceptible to call stack limits).\r\n        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));\r\n      });\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.conforms` which doesn't clone `source`.\r\n     *\r\n     * @private\r\n     * @param {Object} source The object of property predicates to conform to.\r\n     * @returns {Function} Returns the new spec function.\r\n     */\r\n    function baseConforms(source) {\r\n      var props = keys(source);\r\n      return function(object) {\r\n        return baseConformsTo(object, source, props);\r\n      };\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.conformsTo` which accepts `props` to check.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to inspect.\r\n     * @param {Object} source The object of property predicates to conform to.\r\n     * @returns {boolean} Returns `true` if `object` conforms, else `false`.\r\n     */\r\n    function baseConformsTo(object, source, props) {\r\n      var length = props.length;\r\n      if (object == null) {\r\n        return !length;\r\n      }\r\n      object = Object(object);\r\n      while (length--) {\r\n        var key = props[length],\r\n            predicate = source[key],\r\n            value = object[key];\r\n\r\n        if ((value === undefined && !(key in object)) || !predicate(value)) {\r\n          return false;\r\n        }\r\n      }\r\n      return true;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.delay` and `_.defer` which accepts `args`\r\n     * to provide to `func`.\r\n     *\r\n     * @private\r\n     * @param {Function} func The function to delay.\r\n     * @param {number} wait The number of milliseconds to delay invocation.\r\n     * @param {Array} args The arguments to provide to `func`.\r\n     * @returns {number|Object} Returns the timer id or timeout object.\r\n     */\r\n    function baseDelay(func, wait, args) {\r\n      if (typeof func != 'function') {\r\n        throw new TypeError(FUNC_ERROR_TEXT);\r\n      }\r\n      return setTimeout(function() { func.apply(undefined, args); }, wait);\r\n    }\r\n\r\n    /**\r\n     * The base implementation of methods like `_.difference` without support\r\n     * for excluding multiple arrays or iteratee shorthands.\r\n     *\r\n     * @private\r\n     * @param {Array} array The array to inspect.\r\n     * @param {Array} values The values to exclude.\r\n     * @param {Function} [iteratee] The iteratee invoked per element.\r\n     * @param {Function} [comparator] The comparator invoked per element.\r\n     * @returns {Array} Returns the new array of filtered values.\r\n     */\r\n    function baseDifference(array, values, iteratee, comparator) {\r\n      var index = -1,\r\n          includes = arrayIncludes,\r\n          isCommon = true,\r\n          length = array.length,\r\n          result = [],\r\n          valuesLength = values.length;\r\n\r\n      if (!length) {\r\n        return result;\r\n      }\r\n      if (iteratee) {\r\n        values = arrayMap(values, baseUnary(iteratee));\r\n      }\r\n      if (comparator) {\r\n        includes = arrayIncludesWith;\r\n        isCommon = false;\r\n      }\r\n      else if (values.length >= LARGE_ARRAY_SIZE) {\r\n        includes = cacheHas;\r\n        isCommon = false;\r\n        values = new SetCache(values);\r\n      }\r\n      outer:\r\n      while (++index < length) {\r\n        var value = array[index],\r\n            computed = iteratee == null ? value : iteratee(value);\r\n\r\n        value = (comparator || value !== 0) ? value : 0;\r\n        if (isCommon && computed === computed) {\r\n          var valuesIndex = valuesLength;\r\n          while (valuesIndex--) {\r\n            if (values[valuesIndex] === computed) {\r\n              continue outer;\r\n            }\r\n          }\r\n          result.push(value);\r\n        }\r\n        else if (!includes(values, computed, comparator)) {\r\n          result.push(value);\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.forEach` without support for iteratee shorthands.\r\n     *\r\n     * @private\r\n     * @param {Array|Object} collection The collection to iterate over.\r\n     * @param {Function} iteratee The function invoked per iteration.\r\n     * @returns {Array|Object} Returns `collection`.\r\n     */\r\n    var baseEach = createBaseEach(baseForOwn);\r\n\r\n    /**\r\n     * The base implementation of `_.forEachRight` without support for iteratee shorthands.\r\n     *\r\n     * @private\r\n     * @param {Array|Object} collection The collection to iterate over.\r\n     * @param {Function} iteratee The function invoked per iteration.\r\n     * @returns {Array|Object} Returns `collection`.\r\n     */\r\n    var baseEachRight = createBaseEach(baseForOwnRight, true);\r\n\r\n    /**\r\n     * The base implementation of `_.every` without support for iteratee shorthands.\r\n     *\r\n     * @private\r\n     * @param {Array|Object} collection The collection to iterate over.\r\n     * @param {Function} predicate The function invoked per iteration.\r\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\r\n     *  else `false`\r\n     */\r\n    function baseEvery(collection, predicate) {\r\n      var result = true;\r\n      baseEach(collection, function(value, index, collection) {\r\n        result = !!predicate(value, index, collection);\r\n        return result;\r\n      });\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of methods like `_.max` and `_.min` which accepts a\r\n     * `comparator` to determine the extremum value.\r\n     *\r\n     * @private\r\n     * @param {Array} array The array to iterate over.\r\n     * @param {Function} iteratee The iteratee invoked per iteration.\r\n     * @param {Function} comparator The comparator used to compare values.\r\n     * @returns {*} Returns the extremum value.\r\n     */\r\n    function baseExtremum(array, iteratee, comparator) {\r\n      var index = -1,\r\n          length = array.length;\r\n\r\n      while (++index < length) {\r\n        var value = array[index],\r\n            current = iteratee(value);\r\n\r\n        if (current != null && (computed === undefined\r\n              ? (current === current && !isSymbol(current))\r\n              : comparator(current, computed)\r\n            )) {\r\n          var computed = current,\r\n              result = value;\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.fill` without an iteratee call guard.\r\n     *\r\n     * @private\r\n     * @param {Array} array The array to fill.\r\n     * @param {*} value The value to fill `array` with.\r\n     * @param {number} [start=0] The start position.\r\n     * @param {number} [end=array.length] The end position.\r\n     * @returns {Array} Returns `array`.\r\n     */\r\n    function baseFill(array, value, start, end) {\r\n      var length = array.length;\r\n\r\n      start = toInteger(start);\r\n      if (start < 0) {\r\n        start = -start > length ? 0 : (length + start);\r\n      }\r\n      end = (end === undefined || end > length) ? length : toInteger(end);\r\n      if (end < 0) {\r\n        end += length;\r\n      }\r\n      end = start > end ? 0 : toLength(end);\r\n      while (start < end) {\r\n        array[start++] = value;\r\n      }\r\n      return array;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.filter` without support for iteratee shorthands.\r\n     *\r\n     * @private\r\n     * @param {Array|Object} collection The collection to iterate over.\r\n     * @param {Function} predicate The function invoked per iteration.\r\n     * @returns {Array} Returns the new filtered array.\r\n     */\r\n    function baseFilter(collection, predicate) {\r\n      var result = [];\r\n      baseEach(collection, function(value, index, collection) {\r\n        if (predicate(value, index, collection)) {\r\n          result.push(value);\r\n        }\r\n      });\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.flatten` with support for restricting flattening.\r\n     *\r\n     * @private\r\n     * @param {Array} array The array to flatten.\r\n     * @param {number} depth The maximum recursion depth.\r\n     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\r\n     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\r\n     * @param {Array} [result=[]] The initial result value.\r\n     * @returns {Array} Returns the new flattened array.\r\n     */\r\n    function baseFlatten(array, depth, predicate, isStrict, result) {\r\n      var index = -1,\r\n          length = array.length;\r\n\r\n      predicate || (predicate = isFlattenable);\r\n      result || (result = []);\r\n\r\n      while (++index < length) {\r\n        var value = array[index];\r\n        if (depth > 0 && predicate(value)) {\r\n          if (depth > 1) {\r\n            // Recursively flatten arrays (susceptible to call stack limits).\r\n            baseFlatten(value, depth - 1, predicate, isStrict, result);\r\n          } else {\r\n            arrayPush(result, value);\r\n          }\r\n        } else if (!isStrict) {\r\n          result[result.length] = value;\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `baseForOwn` which iterates over `object`\r\n     * properties returned by `keysFunc` and invokes `iteratee` for each property.\r\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to iterate over.\r\n     * @param {Function} iteratee The function invoked per iteration.\r\n     * @param {Function} keysFunc The function to get the keys of `object`.\r\n     * @returns {Object} Returns `object`.\r\n     */\r\n    var baseFor = createBaseFor();\r\n\r\n    /**\r\n     * This function is like `baseFor` except that it iterates over properties\r\n     * in the opposite order.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to iterate over.\r\n     * @param {Function} iteratee The function invoked per iteration.\r\n     * @param {Function} keysFunc The function to get the keys of `object`.\r\n     * @returns {Object} Returns `object`.\r\n     */\r\n    var baseForRight = createBaseFor(true);\r\n\r\n    /**\r\n     * The base implementation of `_.forOwn` without support for iteratee shorthands.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to iterate over.\r\n     * @param {Function} iteratee The function invoked per iteration.\r\n     * @returns {Object} Returns `object`.\r\n     */\r\n    function baseForOwn(object, iteratee) {\r\n      return object && baseFor(object, iteratee, keys);\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to iterate over.\r\n     * @param {Function} iteratee The function invoked per iteration.\r\n     * @returns {Object} Returns `object`.\r\n     */\r\n    function baseForOwnRight(object, iteratee) {\r\n      return object && baseForRight(object, iteratee, keys);\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.functions` which creates an array of\r\n     * `object` function property names filtered from `props`.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to inspect.\r\n     * @param {Array} props The property names to filter.\r\n     * @returns {Array} Returns the function names.\r\n     */\r\n    function baseFunctions(object, props) {\r\n      return arrayFilter(props, function(key) {\r\n        return isFunction(object[key]);\r\n      });\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.get` without support for default values.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to query.\r\n     * @param {Array|string} path The path of the property to get.\r\n     * @returns {*} Returns the resolved value.\r\n     */\r\n    function baseGet(object, path) {\r\n      path = castPath(path, object);\r\n\r\n      var index = 0,\r\n          length = path.length;\r\n\r\n      while (object != null && index < length) {\r\n        object = object[toKey(path[index++])];\r\n      }\r\n      return (index && index == length) ? object : undefined;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\r\n     * `keysFunc` and `symbolsFunc` to get the enumerable property names and\r\n     * symbols of `object`.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to query.\r\n     * @param {Function} keysFunc The function to get the keys of `object`.\r\n     * @param {Function} symbolsFunc The function to get the symbols of `object`.\r\n     * @returns {Array} Returns the array of property names and symbols.\r\n     */\r\n    function baseGetAllKeys(object, keysFunc, symbolsFunc) {\r\n      var result = keysFunc(object);\r\n      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `getTag` without fallbacks for buggy environments.\r\n     *\r\n     * @private\r\n     * @param {*} value The value to query.\r\n     * @returns {string} Returns the `toStringTag`.\r\n     */\r\n    function baseGetTag(value) {\r\n      if (value == null) {\r\n        return value === undefined ? undefinedTag : nullTag;\r\n      }\r\n      return (symToStringTag && symToStringTag in Object(value))\r\n        ? getRawTag(value)\r\n        : objectToString(value);\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.gt` which doesn't coerce arguments.\r\n     *\r\n     * @private\r\n     * @param {*} value The value to compare.\r\n     * @param {*} other The other value to compare.\r\n     * @returns {boolean} Returns `true` if `value` is greater than `other`,\r\n     *  else `false`.\r\n     */\r\n    function baseGt(value, other) {\r\n      return value > other;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.has` without support for deep paths.\r\n     *\r\n     * @private\r\n     * @param {Object} [object] The object to query.\r\n     * @param {Array|string} key The key to check.\r\n     * @returns {boolean} Returns `true` if `key` exists, else `false`.\r\n     */\r\n    function baseHas(object, key) {\r\n      return object != null && hasOwnProperty.call(object, key);\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.hasIn` without support for deep paths.\r\n     *\r\n     * @private\r\n     * @param {Object} [object] The object to query.\r\n     * @param {Array|string} key The key to check.\r\n     * @returns {boolean} Returns `true` if `key` exists, else `false`.\r\n     */\r\n    function baseHasIn(object, key) {\r\n      return object != null && key in Object(object);\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.inRange` which doesn't coerce arguments.\r\n     *\r\n     * @private\r\n     * @param {number} number The number to check.\r\n     * @param {number} start The start of the range.\r\n     * @param {number} end The end of the range.\r\n     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\r\n     */\r\n    function baseInRange(number, start, end) {\r\n      return number >= nativeMin(start, end) && number < nativeMax(start, end);\r\n    }\r\n\r\n    /**\r\n     * The base implementation of methods like `_.intersection`, without support\r\n     * for iteratee shorthands, that accepts an array of arrays to inspect.\r\n     *\r\n     * @private\r\n     * @param {Array} arrays The arrays to inspect.\r\n     * @param {Function} [iteratee] The iteratee invoked per element.\r\n     * @param {Function} [comparator] The comparator invoked per element.\r\n     * @returns {Array} Returns the new array of shared values.\r\n     */\r\n    function baseIntersection(arrays, iteratee, comparator) {\r\n      var includes = comparator ? arrayIncludesWith : arrayIncludes,\r\n          length = arrays[0].length,\r\n          othLength = arrays.length,\r\n          othIndex = othLength,\r\n          caches = Array(othLength),\r\n          maxLength = Infinity,\r\n          result = [];\r\n\r\n      while (othIndex--) {\r\n        var array = arrays[othIndex];\r\n        if (othIndex && iteratee) {\r\n          array = arrayMap(array, baseUnary(iteratee));\r\n        }\r\n        maxLength = nativeMin(array.length, maxLength);\r\n        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))\r\n          ? new SetCache(othIndex && array)\r\n          : undefined;\r\n      }\r\n      array = arrays[0];\r\n\r\n      var index = -1,\r\n          seen = caches[0];\r\n\r\n      outer:\r\n      while (++index < length && result.length < maxLength) {\r\n        var value = array[index],\r\n            computed = iteratee ? iteratee(value) : value;\r\n\r\n        value = (comparator || value !== 0) ? value : 0;\r\n        if (!(seen\r\n              ? cacheHas(seen, computed)\r\n              : includes(result, computed, comparator)\r\n            )) {\r\n          othIndex = othLength;\r\n          while (--othIndex) {\r\n            var cache = caches[othIndex];\r\n            if (!(cache\r\n                  ? cacheHas(cache, computed)\r\n                  : includes(arrays[othIndex], computed, comparator))\r\n                ) {\r\n              continue outer;\r\n            }\r\n          }\r\n          if (seen) {\r\n            seen.push(computed);\r\n          }\r\n          result.push(value);\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.invert` and `_.invertBy` which inverts\r\n     * `object` with values transformed by `iteratee` and set by `setter`.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to iterate over.\r\n     * @param {Function} setter The function to set `accumulator` values.\r\n     * @param {Function} iteratee The iteratee to transform values.\r\n     * @param {Object} accumulator The initial inverted object.\r\n     * @returns {Function} Returns `accumulator`.\r\n     */\r\n    function baseInverter(object, setter, iteratee, accumulator) {\r\n      baseForOwn(object, function(value, key, object) {\r\n        setter(accumulator, iteratee(value), key, object);\r\n      });\r\n      return accumulator;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.invoke` without support for individual\r\n     * method arguments.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to query.\r\n     * @param {Array|string} path The path of the method to invoke.\r\n     * @param {Array} args The arguments to invoke the method with.\r\n     * @returns {*} Returns the result of the invoked method.\r\n     */\r\n    function baseInvoke(object, path, args) {\r\n      path = castPath(path, object);\r\n      object = parent(object, path);\r\n      var func = object == null ? object : object[toKey(last(path))];\r\n      return func == null ? undefined : apply(func, object, args);\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.isArguments`.\r\n     *\r\n     * @private\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is an `arguments` object,\r\n     */\r\n    function baseIsArguments(value) {\r\n      return isObjectLike(value) && baseGetTag(value) == argsTag;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.\r\n     *\r\n     * @private\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.\r\n     */\r\n    function baseIsArrayBuffer(value) {\r\n      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.isDate` without Node.js optimizations.\r\n     *\r\n     * @private\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\r\n     */\r\n    function baseIsDate(value) {\r\n      return isObjectLike(value) && baseGetTag(value) == dateTag;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.isEqual` which supports partial comparisons\r\n     * and tracks traversed objects.\r\n     *\r\n     * @private\r\n     * @param {*} value The value to compare.\r\n     * @param {*} other The other value to compare.\r\n     * @param {boolean} bitmask The bitmask flags.\r\n     *  1 - Unordered comparison\r\n     *  2 - Partial comparison\r\n     * @param {Function} [customizer] The function to customize comparisons.\r\n     * @param {Object} [stack] Tracks traversed `value` and `other` objects.\r\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\r\n     */\r\n    function baseIsEqual(value, other, bitmask, customizer, stack) {\r\n      if (value === other) {\r\n        return true;\r\n      }\r\n      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\r\n        return value !== value && other !== other;\r\n      }\r\n      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\r\n    }\r\n\r\n    /**\r\n     * A specialized version of `baseIsEqual` for arrays and objects which performs\r\n     * deep comparisons and tracks traversed objects enabling objects with circular\r\n     * references to be compared.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to compare.\r\n     * @param {Object} other The other object to compare.\r\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\r\n     * @param {Function} customizer The function to customize comparisons.\r\n     * @param {Function} equalFunc The function to determine equivalents of values.\r\n     * @param {Object} [stack] Tracks traversed `object` and `other` objects.\r\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\r\n     */\r\n    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\r\n      var objIsArr = isArray(object),\r\n          othIsArr = isArray(other),\r\n          objTag = objIsArr ? arrayTag : getTag(object),\r\n          othTag = othIsArr ? arrayTag : getTag(other);\r\n\r\n      objTag = objTag == argsTag ? objectTag : objTag;\r\n      othTag = othTag == argsTag ? objectTag : othTag;\r\n\r\n      var objIsObj = objTag == objectTag,\r\n          othIsObj = othTag == objectTag,\r\n          isSameTag = objTag == othTag;\r\n\r\n      if (isSameTag && isBuffer(object)) {\r\n        if (!isBuffer(other)) {\r\n          return false;\r\n        }\r\n        objIsArr = true;\r\n        objIsObj = false;\r\n      }\r\n      if (isSameTag && !objIsObj) {\r\n        stack || (stack = new Stack);\r\n        return (objIsArr || isTypedArray(object))\r\n          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\r\n          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\r\n      }\r\n      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\r\n        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\r\n            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\r\n\r\n        if (objIsWrapped || othIsWrapped) {\r\n          var objUnwrapped = objIsWrapped ? object.value() : object,\r\n              othUnwrapped = othIsWrapped ? other.value() : other;\r\n\r\n          stack || (stack = new Stack);\r\n          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\r\n        }\r\n      }\r\n      if (!isSameTag) {\r\n        return false;\r\n      }\r\n      stack || (stack = new Stack);\r\n      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.isMap` without Node.js optimizations.\r\n     *\r\n     * @private\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is a map, else `false`.\r\n     */\r\n    function baseIsMap(value) {\r\n      return isObjectLike(value) && getTag(value) == mapTag;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.isMatch` without support for iteratee shorthands.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to inspect.\r\n     * @param {Object} source The object of property values to match.\r\n     * @param {Array} matchData The property names, values, and compare flags to match.\r\n     * @param {Function} [customizer] The function to customize comparisons.\r\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\r\n     */\r\n    function baseIsMatch(object, source, matchData, customizer) {\r\n      var index = matchData.length,\r\n          length = index,\r\n          noCustomizer = !customizer;\r\n\r\n      if (object == null) {\r\n        return !length;\r\n      }\r\n      object = Object(object);\r\n      while (index--) {\r\n        var data = matchData[index];\r\n        if ((noCustomizer && data[2])\r\n              ? data[1] !== object[data[0]]\r\n              : !(data[0] in object)\r\n            ) {\r\n          return false;\r\n        }\r\n      }\r\n      while (++index < length) {\r\n        data = matchData[index];\r\n        var key = data[0],\r\n            objValue = object[key],\r\n            srcValue = data[1];\r\n\r\n        if (noCustomizer && data[2]) {\r\n          if (objValue === undefined && !(key in object)) {\r\n            return false;\r\n          }\r\n        } else {\r\n          var stack = new Stack;\r\n          if (customizer) {\r\n            var result = customizer(objValue, srcValue, key, object, source, stack);\r\n          }\r\n          if (!(result === undefined\r\n                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\r\n                : result\r\n              )) {\r\n            return false;\r\n          }\r\n        }\r\n      }\r\n      return true;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.isNative` without bad shim checks.\r\n     *\r\n     * @private\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is a native function,\r\n     *  else `false`.\r\n     */\r\n    function baseIsNative(value) {\r\n      if (!isObject(value) || isMasked(value)) {\r\n        return false;\r\n      }\r\n      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\r\n      return pattern.test(toSource(value));\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.isRegExp` without Node.js optimizations.\r\n     *\r\n     * @private\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\r\n     */\r\n    function baseIsRegExp(value) {\r\n      return isObjectLike(value) && baseGetTag(value) == regexpTag;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.isSet` without Node.js optimizations.\r\n     *\r\n     * @private\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is a set, else `false`.\r\n     */\r\n    function baseIsSet(value) {\r\n      return isObjectLike(value) && getTag(value) == setTag;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.isTypedArray` without Node.js optimizations.\r\n     *\r\n     * @private\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\r\n     */\r\n    function baseIsTypedArray(value) {\r\n      return isObjectLike(value) &&\r\n        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.iteratee`.\r\n     *\r\n     * @private\r\n     * @param {*} [value=_.identity] The value to convert to an iteratee.\r\n     * @returns {Function} Returns the iteratee.\r\n     */\r\n    function baseIteratee(value) {\r\n      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\r\n      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\r\n      if (typeof value == 'function') {\r\n        return value;\r\n      }\r\n      if (value == null) {\r\n        return identity;\r\n      }\r\n      if (typeof value == 'object') {\r\n        return isArray(value)\r\n          ? baseMatchesProperty(value[0], value[1])\r\n          : baseMatches(value);\r\n      }\r\n      return property(value);\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to query.\r\n     * @returns {Array} Returns the array of property names.\r\n     */\r\n    function baseKeys(object) {\r\n      if (!isPrototype(object)) {\r\n        return nativeKeys(object);\r\n      }\r\n      var result = [];\r\n      for (var key in Object(object)) {\r\n        if (hasOwnProperty.call(object, key) && key != 'constructor') {\r\n          result.push(key);\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to query.\r\n     * @returns {Array} Returns the array of property names.\r\n     */\r\n    function baseKeysIn(object) {\r\n      if (!isObject(object)) {\r\n        return nativeKeysIn(object);\r\n      }\r\n      var isProto = isPrototype(object),\r\n          result = [];\r\n\r\n      for (var key in object) {\r\n        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\r\n          result.push(key);\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.lt` which doesn't coerce arguments.\r\n     *\r\n     * @private\r\n     * @param {*} value The value to compare.\r\n     * @param {*} other The other value to compare.\r\n     * @returns {boolean} Returns `true` if `value` is less than `other`,\r\n     *  else `false`.\r\n     */\r\n    function baseLt(value, other) {\r\n      return value < other;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.map` without support for iteratee shorthands.\r\n     *\r\n     * @private\r\n     * @param {Array|Object} collection The collection to iterate over.\r\n     * @param {Function} iteratee The function invoked per iteration.\r\n     * @returns {Array} Returns the new mapped array.\r\n     */\r\n    function baseMap(collection, iteratee) {\r\n      var index = -1,\r\n          result = isArrayLike(collection) ? Array(collection.length) : [];\r\n\r\n      baseEach(collection, function(value, key, collection) {\r\n        result[++index] = iteratee(value, key, collection);\r\n      });\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.matches` which doesn't clone `source`.\r\n     *\r\n     * @private\r\n     * @param {Object} source The object of property values to match.\r\n     * @returns {Function} Returns the new spec function.\r\n     */\r\n    function baseMatches(source) {\r\n      var matchData = getMatchData(source);\r\n      if (matchData.length == 1 && matchData[0][2]) {\r\n        return matchesStrictComparable(matchData[0][0], matchData[0][1]);\r\n      }\r\n      return function(object) {\r\n        return object === source || baseIsMatch(object, source, matchData);\r\n      };\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\r\n     *\r\n     * @private\r\n     * @param {string} path The path of the property to get.\r\n     * @param {*} srcValue The value to match.\r\n     * @returns {Function} Returns the new spec function.\r\n     */\r\n    function baseMatchesProperty(path, srcValue) {\r\n      if (isKey(path) && isStrictComparable(srcValue)) {\r\n        return matchesStrictComparable(toKey(path), srcValue);\r\n      }\r\n      return function(object) {\r\n        var objValue = get(object, path);\r\n        return (objValue === undefined && objValue === srcValue)\r\n          ? hasIn(object, path)\r\n          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\r\n      };\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.merge` without support for multiple sources.\r\n     *\r\n     * @private\r\n     * @param {Object} object The destination object.\r\n     * @param {Object} source The source object.\r\n     * @param {number} srcIndex The index of `source`.\r\n     * @param {Function} [customizer] The function to customize merged values.\r\n     * @param {Object} [stack] Tracks traversed source values and their merged\r\n     *  counterparts.\r\n     */\r\n    function baseMerge(object, source, srcIndex, customizer, stack) {\r\n      if (object === source) {\r\n        return;\r\n      }\r\n      baseFor(source, function(srcValue, key) {\r\n        stack || (stack = new Stack);\r\n        if (isObject(srcValue)) {\r\n          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\r\n        }\r\n        else {\r\n          var newValue = customizer\r\n            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)\r\n            : undefined;\r\n\r\n          if (newValue === undefined) {\r\n            newValue = srcValue;\r\n          }\r\n          assignMergeValue(object, key, newValue);\r\n        }\r\n      }, keysIn);\r\n    }\r\n\r\n    /**\r\n     * A specialized version of `baseMerge` for arrays and objects which performs\r\n     * deep merges and tracks traversed objects enabling objects with circular\r\n     * references to be merged.\r\n     *\r\n     * @private\r\n     * @param {Object} object The destination object.\r\n     * @param {Object} source The source object.\r\n     * @param {string} key The key of the value to merge.\r\n     * @param {number} srcIndex The index of `source`.\r\n     * @param {Function} mergeFunc The function to merge values.\r\n     * @param {Function} [customizer] The function to customize assigned values.\r\n     * @param {Object} [stack] Tracks traversed source values and their merged\r\n     *  counterparts.\r\n     */\r\n    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\r\n      var objValue = safeGet(object, key),\r\n          srcValue = safeGet(source, key),\r\n          stacked = stack.get(srcValue);\r\n\r\n      if (stacked) {\r\n        assignMergeValue(object, key, stacked);\r\n        return;\r\n      }\r\n      var newValue = customizer\r\n        ? customizer(objValue, srcValue, (key + ''), object, source, stack)\r\n        : undefined;\r\n\r\n      var isCommon = newValue === undefined;\r\n\r\n      if (isCommon) {\r\n        var isArr = isArray(srcValue),\r\n            isBuff = !isArr && isBuffer(srcValue),\r\n            isTyped = !isArr && !isBuff && isTypedArray(srcValue);\r\n\r\n        newValue = srcValue;\r\n        if (isArr || isBuff || isTyped) {\r\n          if (isArray(objValue)) {\r\n            newValue = objValue;\r\n          }\r\n          else if (isArrayLikeObject(objValue)) {\r\n            newValue = copyArray(objValue);\r\n          }\r\n          else if (isBuff) {\r\n            isCommon = false;\r\n            newValue = cloneBuffer(srcValue, true);\r\n          }\r\n          else if (isTyped) {\r\n            isCommon = false;\r\n            newValue = cloneTypedArray(srcValue, true);\r\n          }\r\n          else {\r\n            newValue = [];\r\n          }\r\n        }\r\n        else if (isPlainObject(srcValue) || isArguments(srcValue)) {\r\n          newValue = objValue;\r\n          if (isArguments(objValue)) {\r\n            newValue = toPlainObject(objValue);\r\n          }\r\n          else if (!isObject(objValue) || isFunction(objValue)) {\r\n            newValue = initCloneObject(srcValue);\r\n          }\r\n        }\r\n        else {\r\n          isCommon = false;\r\n        }\r\n      }\r\n      if (isCommon) {\r\n        // Recursively merge objects and arrays (susceptible to call stack limits).\r\n        stack.set(srcValue, newValue);\r\n        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\r\n        stack['delete'](srcValue);\r\n      }\r\n      assignMergeValue(object, key, newValue);\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.nth` which doesn't coerce arguments.\r\n     *\r\n     * @private\r\n     * @param {Array} array The array to query.\r\n     * @param {number} n The index of the element to return.\r\n     * @returns {*} Returns the nth element of `array`.\r\n     */\r\n    function baseNth(array, n) {\r\n      var length = array.length;\r\n      if (!length) {\r\n        return;\r\n      }\r\n      n += n < 0 ? length : 0;\r\n      return isIndex(n, length) ? array[n] : undefined;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.orderBy` without param guards.\r\n     *\r\n     * @private\r\n     * @param {Array|Object} collection The collection to iterate over.\r\n     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\r\n     * @param {string[]} orders The sort orders of `iteratees`.\r\n     * @returns {Array} Returns the new sorted array.\r\n     */\r\n    function baseOrderBy(collection, iteratees, orders) {\r\n      if (iteratees.length) {\r\n        iteratees = arrayMap(iteratees, function(iteratee) {\r\n          if (isArray(iteratee)) {\r\n            return function(value) {\r\n              return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);\r\n            }\r\n          }\r\n          return iteratee;\r\n        });\r\n      } else {\r\n        iteratees = [identity];\r\n      }\r\n\r\n      var index = -1;\r\n      iteratees = arrayMap(iteratees, baseUnary(getIteratee()));\r\n\r\n      var result = baseMap(collection, function(value, key, collection) {\r\n        var criteria = arrayMap(iteratees, function(iteratee) {\r\n          return iteratee(value);\r\n        });\r\n        return { 'criteria': criteria, 'index': ++index, 'value': value };\r\n      });\r\n\r\n      return baseSortBy(result, function(object, other) {\r\n        return compareMultiple(object, other, orders);\r\n      });\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.pick` without support for individual\r\n     * property identifiers.\r\n     *\r\n     * @private\r\n     * @param {Object} object The source object.\r\n     * @param {string[]} paths The property paths to pick.\r\n     * @returns {Object} Returns the new object.\r\n     */\r\n    function basePick(object, paths) {\r\n      return basePickBy(object, paths, function(value, path) {\r\n        return hasIn(object, path);\r\n      });\r\n    }\r\n\r\n    /**\r\n     * The base implementation of  `_.pickBy` without support for iteratee shorthands.\r\n     *\r\n     * @private\r\n     * @param {Object} object The source object.\r\n     * @param {string[]} paths The property paths to pick.\r\n     * @param {Function} predicate The function invoked per property.\r\n     * @returns {Object} Returns the new object.\r\n     */\r\n    function basePickBy(object, paths, predicate) {\r\n      var index = -1,\r\n          length = paths.length,\r\n          result = {};\r\n\r\n      while (++index < length) {\r\n        var path = paths[index],\r\n            value = baseGet(object, path);\r\n\r\n        if (predicate(value, path)) {\r\n          baseSet(result, castPath(path, object), value);\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * A specialized version of `baseProperty` which supports deep paths.\r\n     *\r\n     * @private\r\n     * @param {Array|string} path The path of the property to get.\r\n     * @returns {Function} Returns the new accessor function.\r\n     */\r\n    function basePropertyDeep(path) {\r\n      return function(object) {\r\n        return baseGet(object, path);\r\n      };\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.pullAllBy` without support for iteratee\r\n     * shorthands.\r\n     *\r\n     * @private\r\n     * @param {Array} array The array to modify.\r\n     * @param {Array} values The values to remove.\r\n     * @param {Function} [iteratee] The iteratee invoked per element.\r\n     * @param {Function} [comparator] The comparator invoked per element.\r\n     * @returns {Array} Returns `array`.\r\n     */\r\n    function basePullAll(array, values, iteratee, comparator) {\r\n      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,\r\n          index = -1,\r\n          length = values.length,\r\n          seen = array;\r\n\r\n      if (array === values) {\r\n        values = copyArray(values);\r\n      }\r\n      if (iteratee) {\r\n        seen = arrayMap(array, baseUnary(iteratee));\r\n      }\r\n      while (++index < length) {\r\n        var fromIndex = 0,\r\n            value = values[index],\r\n            computed = iteratee ? iteratee(value) : value;\r\n\r\n        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {\r\n          if (seen !== array) {\r\n            splice.call(seen, fromIndex, 1);\r\n          }\r\n          splice.call(array, fromIndex, 1);\r\n        }\r\n      }\r\n      return array;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.pullAt` without support for individual\r\n     * indexes or capturing the removed elements.\r\n     *\r\n     * @private\r\n     * @param {Array} array The array to modify.\r\n     * @param {number[]} indexes The indexes of elements to remove.\r\n     * @returns {Array} Returns `array`.\r\n     */\r\n    function basePullAt(array, indexes) {\r\n      var length = array ? indexes.length : 0,\r\n          lastIndex = length - 1;\r\n\r\n      while (length--) {\r\n        var index = indexes[length];\r\n        if (length == lastIndex || index !== previous) {\r\n          var previous = index;\r\n          if (isIndex(index)) {\r\n            splice.call(array, index, 1);\r\n          } else {\r\n            baseUnset(array, index);\r\n          }\r\n        }\r\n      }\r\n      return array;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.random` without support for returning\r\n     * floating-point numbers.\r\n     *\r\n     * @private\r\n     * @param {number} lower The lower bound.\r\n     * @param {number} upper The upper bound.\r\n     * @returns {number} Returns the random number.\r\n     */\r\n    function baseRandom(lower, upper) {\r\n      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.range` and `_.rangeRight` which doesn't\r\n     * coerce arguments.\r\n     *\r\n     * @private\r\n     * @param {number} start The start of the range.\r\n     * @param {number} end The end of the range.\r\n     * @param {number} step The value to increment or decrement by.\r\n     * @param {boolean} [fromRight] Specify iterating from right to left.\r\n     * @returns {Array} Returns the range of numbers.\r\n     */\r\n    function baseRange(start, end, step, fromRight) {\r\n      var index = -1,\r\n          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),\r\n          result = Array(length);\r\n\r\n      while (length--) {\r\n        result[fromRight ? length : ++index] = start;\r\n        start += step;\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.repeat` which doesn't coerce arguments.\r\n     *\r\n     * @private\r\n     * @param {string} string The string to repeat.\r\n     * @param {number} n The number of times to repeat the string.\r\n     * @returns {string} Returns the repeated string.\r\n     */\r\n    function baseRepeat(string, n) {\r\n      var result = '';\r\n      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {\r\n        return result;\r\n      }\r\n      // Leverage the exponentiation by squaring algorithm for a faster repeat.\r\n      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.\r\n      do {\r\n        if (n % 2) {\r\n          result += string;\r\n        }\r\n        n = nativeFloor(n / 2);\r\n        if (n) {\r\n          string += string;\r\n        }\r\n      } while (n);\r\n\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.rest` which doesn't validate or coerce arguments.\r\n     *\r\n     * @private\r\n     * @param {Function} func The function to apply a rest parameter to.\r\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\r\n     * @returns {Function} Returns the new function.\r\n     */\r\n    function baseRest(func, start) {\r\n      return setToString(overRest(func, start, identity), func + '');\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.sample`.\r\n     *\r\n     * @private\r\n     * @param {Array|Object} collection The collection to sample.\r\n     * @returns {*} Returns the random element.\r\n     */\r\n    function baseSample(collection) {\r\n      return arraySample(values(collection));\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.sampleSize` without param guards.\r\n     *\r\n     * @private\r\n     * @param {Array|Object} collection The collection to sample.\r\n     * @param {number} n The number of elements to sample.\r\n     * @returns {Array} Returns the random elements.\r\n     */\r\n    function baseSampleSize(collection, n) {\r\n      var array = values(collection);\r\n      return shuffleSelf(array, baseClamp(n, 0, array.length));\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.set`.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to modify.\r\n     * @param {Array|string} path The path of the property to set.\r\n     * @param {*} value The value to set.\r\n     * @param {Function} [customizer] The function to customize path creation.\r\n     * @returns {Object} Returns `object`.\r\n     */\r\n    function baseSet(object, path, value, customizer) {\r\n      if (!isObject(object)) {\r\n        return object;\r\n      }\r\n      path = castPath(path, object);\r\n\r\n      var index = -1,\r\n          length = path.length,\r\n          lastIndex = length - 1,\r\n          nested = object;\r\n\r\n      while (nested != null && ++index < length) {\r\n        var key = toKey(path[index]),\r\n            newValue = value;\r\n\r\n        if (key === '__proto__' || key === 'constructor' || key === 'prototype') {\r\n          return object;\r\n        }\r\n\r\n        if (index != lastIndex) {\r\n          var objValue = nested[key];\r\n          newValue = customizer ? customizer(objValue, key, nested) : undefined;\r\n          if (newValue === undefined) {\r\n            newValue = isObject(objValue)\r\n              ? objValue\r\n              : (isIndex(path[index + 1]) ? [] : {});\r\n          }\r\n        }\r\n        assignValue(nested, key, newValue);\r\n        nested = nested[key];\r\n      }\r\n      return object;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `setData` without support for hot loop shorting.\r\n     *\r\n     * @private\r\n     * @param {Function} func The function to associate metadata with.\r\n     * @param {*} data The metadata.\r\n     * @returns {Function} Returns `func`.\r\n     */\r\n    var baseSetData = !metaMap ? identity : function(func, data) {\r\n      metaMap.set(func, data);\r\n      return func;\r\n    };\r\n\r\n    /**\r\n     * The base implementation of `setToString` without support for hot loop shorting.\r\n     *\r\n     * @private\r\n     * @param {Function} func The function to modify.\r\n     * @param {Function} string The `toString` result.\r\n     * @returns {Function} Returns `func`.\r\n     */\r\n    var baseSetToString = !defineProperty ? identity : function(func, string) {\r\n      return defineProperty(func, 'toString', {\r\n        'configurable': true,\r\n        'enumerable': false,\r\n        'value': constant(string),\r\n        'writable': true\r\n      });\r\n    };\r\n\r\n    /**\r\n     * The base implementation of `_.shuffle`.\r\n     *\r\n     * @private\r\n     * @param {Array|Object} collection The collection to shuffle.\r\n     * @returns {Array} Returns the new shuffled array.\r\n     */\r\n    function baseShuffle(collection) {\r\n      return shuffleSelf(values(collection));\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.slice` without an iteratee call guard.\r\n     *\r\n     * @private\r\n     * @param {Array} array The array to slice.\r\n     * @param {number} [start=0] The start position.\r\n     * @param {number} [end=array.length] The end position.\r\n     * @returns {Array} Returns the slice of `array`.\r\n     */\r\n    function baseSlice(array, start, end) {\r\n      var index = -1,\r\n          length = array.length;\r\n\r\n      if (start < 0) {\r\n        start = -start > length ? 0 : (length + start);\r\n      }\r\n      end = end > length ? length : end;\r\n      if (end < 0) {\r\n        end += length;\r\n      }\r\n      length = start > end ? 0 : ((end - start) >>> 0);\r\n      start >>>= 0;\r\n\r\n      var result = Array(length);\r\n      while (++index < length) {\r\n        result[index] = array[index + start];\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.some` without support for iteratee shorthands.\r\n     *\r\n     * @private\r\n     * @param {Array|Object} collection The collection to iterate over.\r\n     * @param {Function} predicate The function invoked per iteration.\r\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\r\n     *  else `false`.\r\n     */\r\n    function baseSome(collection, predicate) {\r\n      var result;\r\n\r\n      baseEach(collection, function(value, index, collection) {\r\n        result = predicate(value, index, collection);\r\n        return !result;\r\n      });\r\n      return !!result;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which\r\n     * performs a binary search of `array` to determine the index at which `value`\r\n     * should be inserted into `array` in order to maintain its sort order.\r\n     *\r\n     * @private\r\n     * @param {Array} array The sorted array to inspect.\r\n     * @param {*} value The value to evaluate.\r\n     * @param {boolean} [retHighest] Specify returning the highest qualified index.\r\n     * @returns {number} Returns the index at which `value` should be inserted\r\n     *  into `array`.\r\n     */\r\n    function baseSortedIndex(array, value, retHighest) {\r\n      var low = 0,\r\n          high = array == null ? low : array.length;\r\n\r\n      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {\r\n        while (low < high) {\r\n          var mid = (low + high) >>> 1,\r\n              computed = array[mid];\r\n\r\n          if (computed !== null && !isSymbol(computed) &&\r\n              (retHighest ? (computed <= value) : (computed < value))) {\r\n            low = mid + 1;\r\n          } else {\r\n            high = mid;\r\n          }\r\n        }\r\n        return high;\r\n      }\r\n      return baseSortedIndexBy(array, value, identity, retHighest);\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`\r\n     * which invokes `iteratee` for `value` and each element of `array` to compute\r\n     * their sort ranking. The iteratee is invoked with one argument; (value).\r\n     *\r\n     * @private\r\n     * @param {Array} array The sorted array to inspect.\r\n     * @param {*} value The value to evaluate.\r\n     * @param {Function} iteratee The iteratee invoked per element.\r\n     * @param {boolean} [retHighest] Specify returning the highest qualified index.\r\n     * @returns {number} Returns the index at which `value` should be inserted\r\n     *  into `array`.\r\n     */\r\n    function baseSortedIndexBy(array, value, iteratee, retHighest) {\r\n      var low = 0,\r\n          high = array == null ? 0 : array.length;\r\n      if (high === 0) {\r\n        return 0;\r\n      }\r\n\r\n      value = iteratee(value);\r\n      var valIsNaN = value !== value,\r\n          valIsNull = value === null,\r\n          valIsSymbol = isSymbol(value),\r\n          valIsUndefined = value === undefined;\r\n\r\n      while (low < high) {\r\n        var mid = nativeFloor((low + high) / 2),\r\n            computed = iteratee(array[mid]),\r\n            othIsDefined = computed !== undefined,\r\n            othIsNull = computed === null,\r\n            othIsReflexive = computed === computed,\r\n            othIsSymbol = isSymbol(computed);\r\n\r\n        if (valIsNaN) {\r\n          var setLow = retHighest || othIsReflexive;\r\n        } else if (valIsUndefined) {\r\n          setLow = othIsReflexive && (retHighest || othIsDefined);\r\n        } else if (valIsNull) {\r\n          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);\r\n        } else if (valIsSymbol) {\r\n          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);\r\n        } else if (othIsNull || othIsSymbol) {\r\n          setLow = false;\r\n        } else {\r\n          setLow = retHighest ? (computed <= value) : (computed < value);\r\n        }\r\n        if (setLow) {\r\n          low = mid + 1;\r\n        } else {\r\n          high = mid;\r\n        }\r\n      }\r\n      return nativeMin(high, MAX_ARRAY_INDEX);\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without\r\n     * support for iteratee shorthands.\r\n     *\r\n     * @private\r\n     * @param {Array} array The array to inspect.\r\n     * @param {Function} [iteratee] The iteratee invoked per element.\r\n     * @returns {Array} Returns the new duplicate free array.\r\n     */\r\n    function baseSortedUniq(array, iteratee) {\r\n      var index = -1,\r\n          length = array.length,\r\n          resIndex = 0,\r\n          result = [];\r\n\r\n      while (++index < length) {\r\n        var value = array[index],\r\n            computed = iteratee ? iteratee(value) : value;\r\n\r\n        if (!index || !eq(computed, seen)) {\r\n          var seen = computed;\r\n          result[resIndex++] = value === 0 ? 0 : value;\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.toNumber` which doesn't ensure correct\r\n     * conversions of binary, hexadecimal, or octal string values.\r\n     *\r\n     * @private\r\n     * @param {*} value The value to process.\r\n     * @returns {number} Returns the number.\r\n     */\r\n    function baseToNumber(value) {\r\n      if (typeof value == 'number') {\r\n        return value;\r\n      }\r\n      if (isSymbol(value)) {\r\n        return NAN;\r\n      }\r\n      return +value;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.toString` which doesn't convert nullish\r\n     * values to empty strings.\r\n     *\r\n     * @private\r\n     * @param {*} value The value to process.\r\n     * @returns {string} Returns the string.\r\n     */\r\n    function baseToString(value) {\r\n      // Exit early for strings to avoid a performance hit in some environments.\r\n      if (typeof value == 'string') {\r\n        return value;\r\n      }\r\n      if (isArray(value)) {\r\n        // Recursively convert values (susceptible to call stack limits).\r\n        return arrayMap(value, baseToString) + '';\r\n      }\r\n      if (isSymbol(value)) {\r\n        return symbolToString ? symbolToString.call(value) : '';\r\n      }\r\n      var result = (value + '');\r\n      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.uniqBy` without support for iteratee shorthands.\r\n     *\r\n     * @private\r\n     * @param {Array} array The array to inspect.\r\n     * @param {Function} [iteratee] The iteratee invoked per element.\r\n     * @param {Function} [comparator] The comparator invoked per element.\r\n     * @returns {Array} Returns the new duplicate free array.\r\n     */\r\n    function baseUniq(array, iteratee, comparator) {\r\n      var index = -1,\r\n          includes = arrayIncludes,\r\n          length = array.length,\r\n          isCommon = true,\r\n          result = [],\r\n          seen = result;\r\n\r\n      if (comparator) {\r\n        isCommon = false;\r\n        includes = arrayIncludesWith;\r\n      }\r\n      else if (length >= LARGE_ARRAY_SIZE) {\r\n        var set = iteratee ? null : createSet(array);\r\n        if (set) {\r\n          return setToArray(set);\r\n        }\r\n        isCommon = false;\r\n        includes = cacheHas;\r\n        seen = new SetCache;\r\n      }\r\n      else {\r\n        seen = iteratee ? [] : result;\r\n      }\r\n      outer:\r\n      while (++index < length) {\r\n        var value = array[index],\r\n            computed = iteratee ? iteratee(value) : value;\r\n\r\n        value = (comparator || value !== 0) ? value : 0;\r\n        if (isCommon && computed === computed) {\r\n          var seenIndex = seen.length;\r\n          while (seenIndex--) {\r\n            if (seen[seenIndex] === computed) {\r\n              continue outer;\r\n            }\r\n          }\r\n          if (iteratee) {\r\n            seen.push(computed);\r\n          }\r\n          result.push(value);\r\n        }\r\n        else if (!includes(seen, computed, comparator)) {\r\n          if (seen !== result) {\r\n            seen.push(computed);\r\n          }\r\n          result.push(value);\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.unset`.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to modify.\r\n     * @param {Array|string} path The property path to unset.\r\n     * @returns {boolean} Returns `true` if the property is deleted, else `false`.\r\n     */\r\n    function baseUnset(object, path) {\r\n      path = castPath(path, object);\r\n      object = parent(object, path);\r\n      return object == null || delete object[toKey(last(path))];\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.update`.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to modify.\r\n     * @param {Array|string} path The path of the property to update.\r\n     * @param {Function} updater The function to produce the updated value.\r\n     * @param {Function} [customizer] The function to customize path creation.\r\n     * @returns {Object} Returns `object`.\r\n     */\r\n    function baseUpdate(object, path, updater, customizer) {\r\n      return baseSet(object, path, updater(baseGet(object, path)), customizer);\r\n    }\r\n\r\n    /**\r\n     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`\r\n     * without support for iteratee shorthands.\r\n     *\r\n     * @private\r\n     * @param {Array} array The array to query.\r\n     * @param {Function} predicate The function invoked per iteration.\r\n     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.\r\n     * @param {boolean} [fromRight] Specify iterating from right to left.\r\n     * @returns {Array} Returns the slice of `array`.\r\n     */\r\n    function baseWhile(array, predicate, isDrop, fromRight) {\r\n      var length = array.length,\r\n          index = fromRight ? length : -1;\r\n\r\n      while ((fromRight ? index-- : ++index < length) &&\r\n        predicate(array[index], index, array)) {}\r\n\r\n      return isDrop\r\n        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))\r\n        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `wrapperValue` which returns the result of\r\n     * performing a sequence of actions on the unwrapped `value`, where each\r\n     * successive action is supplied the return value of the previous.\r\n     *\r\n     * @private\r\n     * @param {*} value The unwrapped value.\r\n     * @param {Array} actions Actions to perform to resolve the unwrapped value.\r\n     * @returns {*} Returns the resolved value.\r\n     */\r\n    function baseWrapperValue(value, actions) {\r\n      var result = value;\r\n      if (result instanceof LazyWrapper) {\r\n        result = result.value();\r\n      }\r\n      return arrayReduce(actions, function(result, action) {\r\n        return action.func.apply(action.thisArg, arrayPush([result], action.args));\r\n      }, result);\r\n    }\r\n\r\n    /**\r\n     * The base implementation of methods like `_.xor`, without support for\r\n     * iteratee shorthands, that accepts an array of arrays to inspect.\r\n     *\r\n     * @private\r\n     * @param {Array} arrays The arrays to inspect.\r\n     * @param {Function} [iteratee] The iteratee invoked per element.\r\n     * @param {Function} [comparator] The comparator invoked per element.\r\n     * @returns {Array} Returns the new array of values.\r\n     */\r\n    function baseXor(arrays, iteratee, comparator) {\r\n      var length = arrays.length;\r\n      if (length < 2) {\r\n        return length ? baseUniq(arrays[0]) : [];\r\n      }\r\n      var index = -1,\r\n          result = Array(length);\r\n\r\n      while (++index < length) {\r\n        var array = arrays[index],\r\n            othIndex = -1;\r\n\r\n        while (++othIndex < length) {\r\n          if (othIndex != index) {\r\n            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);\r\n          }\r\n        }\r\n      }\r\n      return baseUniq(baseFlatten(result, 1), iteratee, comparator);\r\n    }\r\n\r\n    /**\r\n     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.\r\n     *\r\n     * @private\r\n     * @param {Array} props The property identifiers.\r\n     * @param {Array} values The property values.\r\n     * @param {Function} assignFunc The function to assign values.\r\n     * @returns {Object} Returns the new object.\r\n     */\r\n    function baseZipObject(props, values, assignFunc) {\r\n      var index = -1,\r\n          length = props.length,\r\n          valsLength = values.length,\r\n          result = {};\r\n\r\n      while (++index < length) {\r\n        var value = index < valsLength ? values[index] : undefined;\r\n        assignFunc(result, props[index], value);\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Casts `value` to an empty array if it's not an array like object.\r\n     *\r\n     * @private\r\n     * @param {*} value The value to inspect.\r\n     * @returns {Array|Object} Returns the cast array-like object.\r\n     */\r\n    function castArrayLikeObject(value) {\r\n      return isArrayLikeObject(value) ? value : [];\r\n    }\r\n\r\n    /**\r\n     * Casts `value` to `identity` if it's not a function.\r\n     *\r\n     * @private\r\n     * @param {*} value The value to inspect.\r\n     * @returns {Function} Returns cast function.\r\n     */\r\n    function castFunction(value) {\r\n      return typeof value == 'function' ? value : identity;\r\n    }\r\n\r\n    /**\r\n     * Casts `value` to a path array if it's not one.\r\n     *\r\n     * @private\r\n     * @param {*} value The value to inspect.\r\n     * @param {Object} [object] The object to query keys on.\r\n     * @returns {Array} Returns the cast property path array.\r\n     */\r\n    function castPath(value, object) {\r\n      if (isArray(value)) {\r\n        return value;\r\n      }\r\n      return isKey(value, object) ? [value] : stringToPath(toString(value));\r\n    }\r\n\r\n    /**\r\n     * A `baseRest` alias which can be replaced with `identity` by module\r\n     * replacement plugins.\r\n     *\r\n     * @private\r\n     * @type {Function}\r\n     * @param {Function} func The function to apply a rest parameter to.\r\n     * @returns {Function} Returns the new function.\r\n     */\r\n    var castRest = baseRest;\r\n\r\n    /**\r\n     * Casts `array` to a slice if it's needed.\r\n     *\r\n     * @private\r\n     * @param {Array} array The array to inspect.\r\n     * @param {number} start The start position.\r\n     * @param {number} [end=array.length] The end position.\r\n     * @returns {Array} Returns the cast slice.\r\n     */\r\n    function castSlice(array, start, end) {\r\n      var length = array.length;\r\n      end = end === undefined ? length : end;\r\n      return (!start && end >= length) ? array : baseSlice(array, start, end);\r\n    }\r\n\r\n    /**\r\n     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).\r\n     *\r\n     * @private\r\n     * @param {number|Object} id The timer id or timeout object of the timer to clear.\r\n     */\r\n    var clearTimeout = ctxClearTimeout || function(id) {\r\n      return root.clearTimeout(id);\r\n    };\r\n\r\n    /**\r\n     * Creates a clone of  `buffer`.\r\n     *\r\n     * @private\r\n     * @param {Buffer} buffer The buffer to clone.\r\n     * @param {boolean} [isDeep] Specify a deep clone.\r\n     * @returns {Buffer} Returns the cloned buffer.\r\n     */\r\n    function cloneBuffer(buffer, isDeep) {\r\n      if (isDeep) {\r\n        return buffer.slice();\r\n      }\r\n      var length = buffer.length,\r\n          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\r\n\r\n      buffer.copy(result);\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a clone of `arrayBuffer`.\r\n     *\r\n     * @private\r\n     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\r\n     * @returns {ArrayBuffer} Returns the cloned array buffer.\r\n     */\r\n    function cloneArrayBuffer(arrayBuffer) {\r\n      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\r\n      new Uint8Array(result).set(new Uint8Array(arrayBuffer));\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a clone of `dataView`.\r\n     *\r\n     * @private\r\n     * @param {Object} dataView The data view to clone.\r\n     * @param {boolean} [isDeep] Specify a deep clone.\r\n     * @returns {Object} Returns the cloned data view.\r\n     */\r\n    function cloneDataView(dataView, isDeep) {\r\n      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\r\n      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\r\n    }\r\n\r\n    /**\r\n     * Creates a clone of `regexp`.\r\n     *\r\n     * @private\r\n     * @param {Object} regexp The regexp to clone.\r\n     * @returns {Object} Returns the cloned regexp.\r\n     */\r\n    function cloneRegExp(regexp) {\r\n      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\r\n      result.lastIndex = regexp.lastIndex;\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a clone of the `symbol` object.\r\n     *\r\n     * @private\r\n     * @param {Object} symbol The symbol object to clone.\r\n     * @returns {Object} Returns the cloned symbol object.\r\n     */\r\n    function cloneSymbol(symbol) {\r\n      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\r\n    }\r\n\r\n    /**\r\n     * Creates a clone of `typedArray`.\r\n     *\r\n     * @private\r\n     * @param {Object} typedArray The typed array to clone.\r\n     * @param {boolean} [isDeep] Specify a deep clone.\r\n     * @returns {Object} Returns the cloned typed array.\r\n     */\r\n    function cloneTypedArray(typedArray, isDeep) {\r\n      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\r\n      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\r\n    }\r\n\r\n    /**\r\n     * Compares values to sort them in ascending order.\r\n     *\r\n     * @private\r\n     * @param {*} value The value to compare.\r\n     * @param {*} other The other value to compare.\r\n     * @returns {number} Returns the sort order indicator for `value`.\r\n     */\r\n    function compareAscending(value, other) {\r\n      if (value !== other) {\r\n        var valIsDefined = value !== undefined,\r\n            valIsNull = value === null,\r\n            valIsReflexive = value === value,\r\n            valIsSymbol = isSymbol(value);\r\n\r\n        var othIsDefined = other !== undefined,\r\n            othIsNull = other === null,\r\n            othIsReflexive = other === other,\r\n            othIsSymbol = isSymbol(other);\r\n\r\n        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||\r\n            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||\r\n            (valIsNull && othIsDefined && othIsReflexive) ||\r\n            (!valIsDefined && othIsReflexive) ||\r\n            !valIsReflexive) {\r\n          return 1;\r\n        }\r\n        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||\r\n            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||\r\n            (othIsNull && valIsDefined && valIsReflexive) ||\r\n            (!othIsDefined && valIsReflexive) ||\r\n            !othIsReflexive) {\r\n          return -1;\r\n        }\r\n      }\r\n      return 0;\r\n    }\r\n\r\n    /**\r\n     * Used by `_.orderBy` to compare multiple properties of a value to another\r\n     * and stable sort them.\r\n     *\r\n     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,\r\n     * specify an order of \"desc\" for descending or \"asc\" for ascending sort order\r\n     * of corresponding values.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to compare.\r\n     * @param {Object} other The other object to compare.\r\n     * @param {boolean[]|string[]} orders The order to sort by for each property.\r\n     * @returns {number} Returns the sort order indicator for `object`.\r\n     */\r\n    function compareMultiple(object, other, orders) {\r\n      var index = -1,\r\n          objCriteria = object.criteria,\r\n          othCriteria = other.criteria,\r\n          length = objCriteria.length,\r\n          ordersLength = orders.length;\r\n\r\n      while (++index < length) {\r\n        var result = compareAscending(objCriteria[index], othCriteria[index]);\r\n        if (result) {\r\n          if (index >= ordersLength) {\r\n            return result;\r\n          }\r\n          var order = orders[index];\r\n          return result * (order == 'desc' ? -1 : 1);\r\n        }\r\n      }\r\n      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\r\n      // that causes it, under certain circumstances, to provide the same value for\r\n      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\r\n      // for more details.\r\n      //\r\n      // This also ensures a stable sort in V8 and other engines.\r\n      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.\r\n      return object.index - other.index;\r\n    }\r\n\r\n    /**\r\n     * Creates an array that is the composition of partially applied arguments,\r\n     * placeholders, and provided arguments into a single array of arguments.\r\n     *\r\n     * @private\r\n     * @param {Array} args The provided arguments.\r\n     * @param {Array} partials The arguments to prepend to those provided.\r\n     * @param {Array} holders The `partials` placeholder indexes.\r\n     * @params {boolean} [isCurried] Specify composing for a curried function.\r\n     * @returns {Array} Returns the new array of composed arguments.\r\n     */\r\n    function composeArgs(args, partials, holders, isCurried) {\r\n      var argsIndex = -1,\r\n          argsLength = args.length,\r\n          holdersLength = holders.length,\r\n          leftIndex = -1,\r\n          leftLength = partials.length,\r\n          rangeLength = nativeMax(argsLength - holdersLength, 0),\r\n          result = Array(leftLength + rangeLength),\r\n          isUncurried = !isCurried;\r\n\r\n      while (++leftIndex < leftLength) {\r\n        result[leftIndex] = partials[leftIndex];\r\n      }\r\n      while (++argsIndex < holdersLength) {\r\n        if (isUncurried || argsIndex < argsLength) {\r\n          result[holders[argsIndex]] = args[argsIndex];\r\n        }\r\n      }\r\n      while (rangeLength--) {\r\n        result[leftIndex++] = args[argsIndex++];\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * This function is like `composeArgs` except that the arguments composition\r\n     * is tailored for `_.partialRight`.\r\n     *\r\n     * @private\r\n     * @param {Array} args The provided arguments.\r\n     * @param {Array} partials The arguments to append to those provided.\r\n     * @param {Array} holders The `partials` placeholder indexes.\r\n     * @params {boolean} [isCurried] Specify composing for a curried function.\r\n     * @returns {Array} Returns the new array of composed arguments.\r\n     */\r\n    function composeArgsRight(args, partials, holders, isCurried) {\r\n      var argsIndex = -1,\r\n          argsLength = args.length,\r\n          holdersIndex = -1,\r\n          holdersLength = holders.length,\r\n          rightIndex = -1,\r\n          rightLength = partials.length,\r\n          rangeLength = nativeMax(argsLength - holdersLength, 0),\r\n          result = Array(rangeLength + rightLength),\r\n          isUncurried = !isCurried;\r\n\r\n      while (++argsIndex < rangeLength) {\r\n        result[argsIndex] = args[argsIndex];\r\n      }\r\n      var offset = argsIndex;\r\n      while (++rightIndex < rightLength) {\r\n        result[offset + rightIndex] = partials[rightIndex];\r\n      }\r\n      while (++holdersIndex < holdersLength) {\r\n        if (isUncurried || argsIndex < argsLength) {\r\n          result[offset + holders[holdersIndex]] = args[argsIndex++];\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Copies the values of `source` to `array`.\r\n     *\r\n     * @private\r\n     * @param {Array} source The array to copy values from.\r\n     * @param {Array} [array=[]] The array to copy values to.\r\n     * @returns {Array} Returns `array`.\r\n     */\r\n    function copyArray(source, array) {\r\n      var index = -1,\r\n          length = source.length;\r\n\r\n      array || (array = Array(length));\r\n      while (++index < length) {\r\n        array[index] = source[index];\r\n      }\r\n      return array;\r\n    }\r\n\r\n    /**\r\n     * Copies properties of `source` to `object`.\r\n     *\r\n     * @private\r\n     * @param {Object} source The object to copy properties from.\r\n     * @param {Array} props The property identifiers to copy.\r\n     * @param {Object} [object={}] The object to copy properties to.\r\n     * @param {Function} [customizer] The function to customize copied values.\r\n     * @returns {Object} Returns `object`.\r\n     */\r\n    function copyObject(source, props, object, customizer) {\r\n      var isNew = !object;\r\n      object || (object = {});\r\n\r\n      var index = -1,\r\n          length = props.length;\r\n\r\n      while (++index < length) {\r\n        var key = props[index];\r\n\r\n        var newValue = customizer\r\n          ? customizer(object[key], source[key], key, object, source)\r\n          : undefined;\r\n\r\n        if (newValue === undefined) {\r\n          newValue = source[key];\r\n        }\r\n        if (isNew) {\r\n          baseAssignValue(object, key, newValue);\r\n        } else {\r\n          assignValue(object, key, newValue);\r\n        }\r\n      }\r\n      return object;\r\n    }\r\n\r\n    /**\r\n     * Copies own symbols of `source` to `object`.\r\n     *\r\n     * @private\r\n     * @param {Object} source The object to copy symbols from.\r\n     * @param {Object} [object={}] The object to copy symbols to.\r\n     * @returns {Object} Returns `object`.\r\n     */\r\n    function copySymbols(source, object) {\r\n      return copyObject(source, getSymbols(source), object);\r\n    }\r\n\r\n    /**\r\n     * Copies own and inherited symbols of `source` to `object`.\r\n     *\r\n     * @private\r\n     * @param {Object} source The object to copy symbols from.\r\n     * @param {Object} [object={}] The object to copy symbols to.\r\n     * @returns {Object} Returns `object`.\r\n     */\r\n    function copySymbolsIn(source, object) {\r\n      return copyObject(source, getSymbolsIn(source), object);\r\n    }\r\n\r\n    /**\r\n     * Creates a function like `_.groupBy`.\r\n     *\r\n     * @private\r\n     * @param {Function} setter The function to set accumulator values.\r\n     * @param {Function} [initializer] The accumulator object initializer.\r\n     * @returns {Function} Returns the new aggregator function.\r\n     */\r\n    function createAggregator(setter, initializer) {\r\n      return function(collection, iteratee) {\r\n        var func = isArray(collection) ? arrayAggregator : baseAggregator,\r\n            accumulator = initializer ? initializer() : {};\r\n\r\n        return func(collection, setter, getIteratee(iteratee, 2), accumulator);\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Creates a function like `_.assign`.\r\n     *\r\n     * @private\r\n     * @param {Function} assigner The function to assign values.\r\n     * @returns {Function} Returns the new assigner function.\r\n     */\r\n    function createAssigner(assigner) {\r\n      return baseRest(function(object, sources) {\r\n        var index = -1,\r\n            length = sources.length,\r\n            customizer = length > 1 ? sources[length - 1] : undefined,\r\n            guard = length > 2 ? sources[2] : undefined;\r\n\r\n        customizer = (assigner.length > 3 && typeof customizer == 'function')\r\n          ? (length--, customizer)\r\n          : undefined;\r\n\r\n        if (guard && isIterateeCall(sources[0], sources[1], guard)) {\r\n          customizer = length < 3 ? undefined : customizer;\r\n          length = 1;\r\n        }\r\n        object = Object(object);\r\n        while (++index < length) {\r\n          var source = sources[index];\r\n          if (source) {\r\n            assigner(object, source, index, customizer);\r\n          }\r\n        }\r\n        return object;\r\n      });\r\n    }\r\n\r\n    /**\r\n     * Creates a `baseEach` or `baseEachRight` function.\r\n     *\r\n     * @private\r\n     * @param {Function} eachFunc The function to iterate over a collection.\r\n     * @param {boolean} [fromRight] Specify iterating from right to left.\r\n     * @returns {Function} Returns the new base function.\r\n     */\r\n    function createBaseEach(eachFunc, fromRight) {\r\n      return function(collection, iteratee) {\r\n        if (collection == null) {\r\n          return collection;\r\n        }\r\n        if (!isArrayLike(collection)) {\r\n          return eachFunc(collection, iteratee);\r\n        }\r\n        var length = collection.length,\r\n            index = fromRight ? length : -1,\r\n            iterable = Object(collection);\r\n\r\n        while ((fromRight ? index-- : ++index < length)) {\r\n          if (iteratee(iterable[index], index, iterable) === false) {\r\n            break;\r\n          }\r\n        }\r\n        return collection;\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Creates a base function for methods like `_.forIn` and `_.forOwn`.\r\n     *\r\n     * @private\r\n     * @param {boolean} [fromRight] Specify iterating from right to left.\r\n     * @returns {Function} Returns the new base function.\r\n     */\r\n    function createBaseFor(fromRight) {\r\n      return function(object, iteratee, keysFunc) {\r\n        var index = -1,\r\n            iterable = Object(object),\r\n            props = keysFunc(object),\r\n            length = props.length;\r\n\r\n        while (length--) {\r\n          var key = props[fromRight ? length : ++index];\r\n          if (iteratee(iterable[key], key, iterable) === false) {\r\n            break;\r\n          }\r\n        }\r\n        return object;\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Creates a function that wraps `func` to invoke it with the optional `this`\r\n     * binding of `thisArg`.\r\n     *\r\n     * @private\r\n     * @param {Function} func The function to wrap.\r\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\r\n     * @param {*} [thisArg] The `this` binding of `func`.\r\n     * @returns {Function} Returns the new wrapped function.\r\n     */\r\n    function createBind(func, bitmask, thisArg) {\r\n      var isBind = bitmask & WRAP_BIND_FLAG,\r\n          Ctor = createCtor(func);\r\n\r\n      function wrapper() {\r\n        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\r\n        return fn.apply(isBind ? thisArg : this, arguments);\r\n      }\r\n      return wrapper;\r\n    }\r\n\r\n    /**\r\n     * Creates a function like `_.lowerFirst`.\r\n     *\r\n     * @private\r\n     * @param {string} methodName The name of the `String` case method to use.\r\n     * @returns {Function} Returns the new case function.\r\n     */\r\n    function createCaseFirst(methodName) {\r\n      return function(string) {\r\n        string = toString(string);\r\n\r\n        var strSymbols = hasUnicode(string)\r\n          ? stringToArray(string)\r\n          : undefined;\r\n\r\n        var chr = strSymbols\r\n          ? strSymbols[0]\r\n          : string.charAt(0);\r\n\r\n        var trailing = strSymbols\r\n          ? castSlice(strSymbols, 1).join('')\r\n          : string.slice(1);\r\n\r\n        return chr[methodName]() + trailing;\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Creates a function like `_.camelCase`.\r\n     *\r\n     * @private\r\n     * @param {Function} callback The function to combine each word.\r\n     * @returns {Function} Returns the new compounder function.\r\n     */\r\n    function createCompounder(callback) {\r\n      return function(string) {\r\n        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Creates a function that produces an instance of `Ctor` regardless of\r\n     * whether it was invoked as part of a `new` expression or by `call` or `apply`.\r\n     *\r\n     * @private\r\n     * @param {Function} Ctor The constructor to wrap.\r\n     * @returns {Function} Returns the new wrapped function.\r\n     */\r\n    function createCtor(Ctor) {\r\n      return function() {\r\n        // Use a `switch` statement to work with class constructors. See\r\n        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist\r\n        // for more details.\r\n        var args = arguments;\r\n        switch (args.length) {\r\n          case 0: return new Ctor;\r\n          case 1: return new Ctor(args[0]);\r\n          case 2: return new Ctor(args[0], args[1]);\r\n          case 3: return new Ctor(args[0], args[1], args[2]);\r\n          case 4: return new Ctor(args[0], args[1], args[2], args[3]);\r\n          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);\r\n          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);\r\n          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);\r\n        }\r\n        var thisBinding = baseCreate(Ctor.prototype),\r\n            result = Ctor.apply(thisBinding, args);\r\n\r\n        // Mimic the constructor's `return` behavior.\r\n        // See https://es5.github.io/#x13.2.2 for more details.\r\n        return isObject(result) ? result : thisBinding;\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Creates a function that wraps `func` to enable currying.\r\n     *\r\n     * @private\r\n     * @param {Function} func The function to wrap.\r\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\r\n     * @param {number} arity The arity of `func`.\r\n     * @returns {Function} Returns the new wrapped function.\r\n     */\r\n    function createCurry(func, bitmask, arity) {\r\n      var Ctor = createCtor(func);\r\n\r\n      function wrapper() {\r\n        var length = arguments.length,\r\n            args = Array(length),\r\n            index = length,\r\n            placeholder = getHolder(wrapper);\r\n\r\n        while (index--) {\r\n          args[index] = arguments[index];\r\n        }\r\n        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)\r\n          ? []\r\n          : replaceHolders(args, placeholder);\r\n\r\n        length -= holders.length;\r\n        if (length < arity) {\r\n          return createRecurry(\r\n            func, bitmask, createHybrid, wrapper.placeholder, undefined,\r\n            args, holders, undefined, undefined, arity - length);\r\n        }\r\n        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\r\n        return apply(fn, this, args);\r\n      }\r\n      return wrapper;\r\n    }\r\n\r\n    /**\r\n     * Creates a `_.find` or `_.findLast` function.\r\n     *\r\n     * @private\r\n     * @param {Function} findIndexFunc The function to find the collection index.\r\n     * @returns {Function} Returns the new find function.\r\n     */\r\n    function createFind(findIndexFunc) {\r\n      return function(collection, predicate, fromIndex) {\r\n        var iterable = Object(collection);\r\n        if (!isArrayLike(collection)) {\r\n          var iteratee = getIteratee(predicate, 3);\r\n          collection = keys(collection);\r\n          predicate = function(key) { return iteratee(iterable[key], key, iterable); };\r\n        }\r\n        var index = findIndexFunc(collection, predicate, fromIndex);\r\n        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Creates a `_.flow` or `_.flowRight` function.\r\n     *\r\n     * @private\r\n     * @param {boolean} [fromRight] Specify iterating from right to left.\r\n     * @returns {Function} Returns the new flow function.\r\n     */\r\n    function createFlow(fromRight) {\r\n      return flatRest(function(funcs) {\r\n        var length = funcs.length,\r\n            index = length,\r\n            prereq = LodashWrapper.prototype.thru;\r\n\r\n        if (fromRight) {\r\n          funcs.reverse();\r\n        }\r\n        while (index--) {\r\n          var func = funcs[index];\r\n          if (typeof func != 'function') {\r\n            throw new TypeError(FUNC_ERROR_TEXT);\r\n          }\r\n          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {\r\n            var wrapper = new LodashWrapper([], true);\r\n          }\r\n        }\r\n        index = wrapper ? index : length;\r\n        while (++index < length) {\r\n          func = funcs[index];\r\n\r\n          var funcName = getFuncName(func),\r\n              data = funcName == 'wrapper' ? getData(func) : undefined;\r\n\r\n          if (data && isLaziable(data[0]) &&\r\n                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&\r\n                !data[4].length && data[9] == 1\r\n              ) {\r\n            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);\r\n          } else {\r\n            wrapper = (func.length == 1 && isLaziable(func))\r\n              ? wrapper[funcName]()\r\n              : wrapper.thru(func);\r\n          }\r\n        }\r\n        return function() {\r\n          var args = arguments,\r\n              value = args[0];\r\n\r\n          if (wrapper && args.length == 1 && isArray(value)) {\r\n            return wrapper.plant(value).value();\r\n          }\r\n          var index = 0,\r\n              result = length ? funcs[index].apply(this, args) : value;\r\n\r\n          while (++index < length) {\r\n            result = funcs[index].call(this, result);\r\n          }\r\n          return result;\r\n        };\r\n      });\r\n    }\r\n\r\n    /**\r\n     * Creates a function that wraps `func` to invoke it with optional `this`\r\n     * binding of `thisArg`, partial application, and currying.\r\n     *\r\n     * @private\r\n     * @param {Function|string} func The function or method name to wrap.\r\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\r\n     * @param {*} [thisArg] The `this` binding of `func`.\r\n     * @param {Array} [partials] The arguments to prepend to those provided to\r\n     *  the new function.\r\n     * @param {Array} [holders] The `partials` placeholder indexes.\r\n     * @param {Array} [partialsRight] The arguments to append to those provided\r\n     *  to the new function.\r\n     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.\r\n     * @param {Array} [argPos] The argument positions of the new function.\r\n     * @param {number} [ary] The arity cap of `func`.\r\n     * @param {number} [arity] The arity of `func`.\r\n     * @returns {Function} Returns the new wrapped function.\r\n     */\r\n    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {\r\n      var isAry = bitmask & WRAP_ARY_FLAG,\r\n          isBind = bitmask & WRAP_BIND_FLAG,\r\n          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,\r\n          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),\r\n          isFlip = bitmask & WRAP_FLIP_FLAG,\r\n          Ctor = isBindKey ? undefined : createCtor(func);\r\n\r\n      function wrapper() {\r\n        var length = arguments.length,\r\n            args = Array(length),\r\n            index = length;\r\n\r\n        while (index--) {\r\n          args[index] = arguments[index];\r\n        }\r\n        if (isCurried) {\r\n          var placeholder = getHolder(wrapper),\r\n              holdersCount = countHolders(args, placeholder);\r\n        }\r\n        if (partials) {\r\n          args = composeArgs(args, partials, holders, isCurried);\r\n        }\r\n        if (partialsRight) {\r\n          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);\r\n        }\r\n        length -= holdersCount;\r\n        if (isCurried && length < arity) {\r\n          var newHolders = replaceHolders(args, placeholder);\r\n          return createRecurry(\r\n            func, bitmask, createHybrid, wrapper.placeholder, thisArg,\r\n            args, newHolders, argPos, ary, arity - length\r\n          );\r\n        }\r\n        var thisBinding = isBind ? thisArg : this,\r\n            fn = isBindKey ? thisBinding[func] : func;\r\n\r\n        length = args.length;\r\n        if (argPos) {\r\n          args = reorder(args, argPos);\r\n        } else if (isFlip && length > 1) {\r\n          args.reverse();\r\n        }\r\n        if (isAry && ary < length) {\r\n          args.length = ary;\r\n        }\r\n        if (this && this !== root && this instanceof wrapper) {\r\n          fn = Ctor || createCtor(fn);\r\n        }\r\n        return fn.apply(thisBinding, args);\r\n      }\r\n      return wrapper;\r\n    }\r\n\r\n    /**\r\n     * Creates a function like `_.invertBy`.\r\n     *\r\n     * @private\r\n     * @param {Function} setter The function to set accumulator values.\r\n     * @param {Function} toIteratee The function to resolve iteratees.\r\n     * @returns {Function} Returns the new inverter function.\r\n     */\r\n    function createInverter(setter, toIteratee) {\r\n      return function(object, iteratee) {\r\n        return baseInverter(object, setter, toIteratee(iteratee), {});\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Creates a function that performs a mathematical operation on two values.\r\n     *\r\n     * @private\r\n     * @param {Function} operator The function to perform the operation.\r\n     * @param {number} [defaultValue] The value used for `undefined` arguments.\r\n     * @returns {Function} Returns the new mathematical operation function.\r\n     */\r\n    function createMathOperation(operator, defaultValue) {\r\n      return function(value, other) {\r\n        var result;\r\n        if (value === undefined && other === undefined) {\r\n          return defaultValue;\r\n        }\r\n        if (value !== undefined) {\r\n          result = value;\r\n        }\r\n        if (other !== undefined) {\r\n          if (result === undefined) {\r\n            return other;\r\n          }\r\n          if (typeof value == 'string' || typeof other == 'string') {\r\n            value = baseToString(value);\r\n            other = baseToString(other);\r\n          } else {\r\n            value = baseToNumber(value);\r\n            other = baseToNumber(other);\r\n          }\r\n          result = operator(value, other);\r\n        }\r\n        return result;\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Creates a function like `_.over`.\r\n     *\r\n     * @private\r\n     * @param {Function} arrayFunc The function to iterate over iteratees.\r\n     * @returns {Function} Returns the new over function.\r\n     */\r\n    function createOver(arrayFunc) {\r\n      return flatRest(function(iteratees) {\r\n        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));\r\n        return baseRest(function(args) {\r\n          var thisArg = this;\r\n          return arrayFunc(iteratees, function(iteratee) {\r\n            return apply(iteratee, thisArg, args);\r\n          });\r\n        });\r\n      });\r\n    }\r\n\r\n    /**\r\n     * Creates the padding for `string` based on `length`. The `chars` string\r\n     * is truncated if the number of characters exceeds `length`.\r\n     *\r\n     * @private\r\n     * @param {number} length The padding length.\r\n     * @param {string} [chars=' '] The string used as padding.\r\n     * @returns {string} Returns the padding for `string`.\r\n     */\r\n    function createPadding(length, chars) {\r\n      chars = chars === undefined ? ' ' : baseToString(chars);\r\n\r\n      var charsLength = chars.length;\r\n      if (charsLength < 2) {\r\n        return charsLength ? baseRepeat(chars, length) : chars;\r\n      }\r\n      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));\r\n      return hasUnicode(chars)\r\n        ? castSlice(stringToArray(result), 0, length).join('')\r\n        : result.slice(0, length);\r\n    }\r\n\r\n    /**\r\n     * Creates a function that wraps `func` to invoke it with the `this` binding\r\n     * of `thisArg` and `partials` prepended to the arguments it receives.\r\n     *\r\n     * @private\r\n     * @param {Function} func The function to wrap.\r\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\r\n     * @param {*} thisArg The `this` binding of `func`.\r\n     * @param {Array} partials The arguments to prepend to those provided to\r\n     *  the new function.\r\n     * @returns {Function} Returns the new wrapped function.\r\n     */\r\n    function createPartial(func, bitmask, thisArg, partials) {\r\n      var isBind = bitmask & WRAP_BIND_FLAG,\r\n          Ctor = createCtor(func);\r\n\r\n      function wrapper() {\r\n        var argsIndex = -1,\r\n            argsLength = arguments.length,\r\n            leftIndex = -1,\r\n            leftLength = partials.length,\r\n            args = Array(leftLength + argsLength),\r\n            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\r\n\r\n        while (++leftIndex < leftLength) {\r\n          args[leftIndex] = partials[leftIndex];\r\n        }\r\n        while (argsLength--) {\r\n          args[leftIndex++] = arguments[++argsIndex];\r\n        }\r\n        return apply(fn, isBind ? thisArg : this, args);\r\n      }\r\n      return wrapper;\r\n    }\r\n\r\n    /**\r\n     * Creates a `_.range` or `_.rangeRight` function.\r\n     *\r\n     * @private\r\n     * @param {boolean} [fromRight] Specify iterating from right to left.\r\n     * @returns {Function} Returns the new range function.\r\n     */\r\n    function createRange(fromRight) {\r\n      return function(start, end, step) {\r\n        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {\r\n          end = step = undefined;\r\n        }\r\n        // Ensure the sign of `-0` is preserved.\r\n        start = toFinite(start);\r\n        if (end === undefined) {\r\n          end = start;\r\n          start = 0;\r\n        } else {\r\n          end = toFinite(end);\r\n        }\r\n        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);\r\n        return baseRange(start, end, step, fromRight);\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Creates a function that performs a relational operation on two values.\r\n     *\r\n     * @private\r\n     * @param {Function} operator The function to perform the operation.\r\n     * @returns {Function} Returns the new relational operation function.\r\n     */\r\n    function createRelationalOperation(operator) {\r\n      return function(value, other) {\r\n        if (!(typeof value == 'string' && typeof other == 'string')) {\r\n          value = toNumber(value);\r\n          other = toNumber(other);\r\n        }\r\n        return operator(value, other);\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Creates a function that wraps `func` to continue currying.\r\n     *\r\n     * @private\r\n     * @param {Function} func The function to wrap.\r\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\r\n     * @param {Function} wrapFunc The function to create the `func` wrapper.\r\n     * @param {*} placeholder The placeholder value.\r\n     * @param {*} [thisArg] The `this` binding of `func`.\r\n     * @param {Array} [partials] The arguments to prepend to those provided to\r\n     *  the new function.\r\n     * @param {Array} [holders] The `partials` placeholder indexes.\r\n     * @param {Array} [argPos] The argument positions of the new function.\r\n     * @param {number} [ary] The arity cap of `func`.\r\n     * @param {number} [arity] The arity of `func`.\r\n     * @returns {Function} Returns the new wrapped function.\r\n     */\r\n    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {\r\n      var isCurry = bitmask & WRAP_CURRY_FLAG,\r\n          newHolders = isCurry ? holders : undefined,\r\n          newHoldersRight = isCurry ? undefined : holders,\r\n          newPartials = isCurry ? partials : undefined,\r\n          newPartialsRight = isCurry ? undefined : partials;\r\n\r\n      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);\r\n      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);\r\n\r\n      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {\r\n        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);\r\n      }\r\n      var newData = [\r\n        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,\r\n        newHoldersRight, argPos, ary, arity\r\n      ];\r\n\r\n      var result = wrapFunc.apply(undefined, newData);\r\n      if (isLaziable(func)) {\r\n        setData(result, newData);\r\n      }\r\n      result.placeholder = placeholder;\r\n      return setWrapToString(result, func, bitmask);\r\n    }\r\n\r\n    /**\r\n     * Creates a function like `_.round`.\r\n     *\r\n     * @private\r\n     * @param {string} methodName The name of the `Math` method to use when rounding.\r\n     * @returns {Function} Returns the new round function.\r\n     */\r\n    function createRound(methodName) {\r\n      var func = Math[methodName];\r\n      return function(number, precision) {\r\n        number = toNumber(number);\r\n        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);\r\n        if (precision && nativeIsFinite(number)) {\r\n          // Shift with exponential notation to avoid floating-point issues.\r\n          // See [MDN](https://mdn.io/round#Examples) for more details.\r\n          var pair = (toString(number) + 'e').split('e'),\r\n              value = func(pair[0] + 'e' + (+pair[1] + precision));\r\n\r\n          pair = (toString(value) + 'e').split('e');\r\n          return +(pair[0] + 'e' + (+pair[1] - precision));\r\n        }\r\n        return func(number);\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Creates a set object of `values`.\r\n     *\r\n     * @private\r\n     * @param {Array} values The values to add to the set.\r\n     * @returns {Object} Returns the new set.\r\n     */\r\n    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {\r\n      return new Set(values);\r\n    };\r\n\r\n    /**\r\n     * Creates a `_.toPairs` or `_.toPairsIn` function.\r\n     *\r\n     * @private\r\n     * @param {Function} keysFunc The function to get the keys of a given object.\r\n     * @returns {Function} Returns the new pairs function.\r\n     */\r\n    function createToPairs(keysFunc) {\r\n      return function(object) {\r\n        var tag = getTag(object);\r\n        if (tag == mapTag) {\r\n          return mapToArray(object);\r\n        }\r\n        if (tag == setTag) {\r\n          return setToPairs(object);\r\n        }\r\n        return baseToPairs(object, keysFunc(object));\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Creates a function that either curries or invokes `func` with optional\r\n     * `this` binding and partially applied arguments.\r\n     *\r\n     * @private\r\n     * @param {Function|string} func The function or method name to wrap.\r\n     * @param {number} bitmask The bitmask flags.\r\n     *    1 - `_.bind`\r\n     *    2 - `_.bindKey`\r\n     *    4 - `_.curry` or `_.curryRight` of a bound function\r\n     *    8 - `_.curry`\r\n     *   16 - `_.curryRight`\r\n     *   32 - `_.partial`\r\n     *   64 - `_.partialRight`\r\n     *  128 - `_.rearg`\r\n     *  256 - `_.ary`\r\n     *  512 - `_.flip`\r\n     * @param {*} [thisArg] The `this` binding of `func`.\r\n     * @param {Array} [partials] The arguments to be partially applied.\r\n     * @param {Array} [holders] The `partials` placeholder indexes.\r\n     * @param {Array} [argPos] The argument positions of the new function.\r\n     * @param {number} [ary] The arity cap of `func`.\r\n     * @param {number} [arity] The arity of `func`.\r\n     * @returns {Function} Returns the new wrapped function.\r\n     */\r\n    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {\r\n      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;\r\n      if (!isBindKey && typeof func != 'function') {\r\n        throw new TypeError(FUNC_ERROR_TEXT);\r\n      }\r\n      var length = partials ? partials.length : 0;\r\n      if (!length) {\r\n        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);\r\n        partials = holders = undefined;\r\n      }\r\n      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);\r\n      arity = arity === undefined ? arity : toInteger(arity);\r\n      length -= holders ? holders.length : 0;\r\n\r\n      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {\r\n        var partialsRight = partials,\r\n            holdersRight = holders;\r\n\r\n        partials = holders = undefined;\r\n      }\r\n      var data = isBindKey ? undefined : getData(func);\r\n\r\n      var newData = [\r\n        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,\r\n        argPos, ary, arity\r\n      ];\r\n\r\n      if (data) {\r\n        mergeData(newData, data);\r\n      }\r\n      func = newData[0];\r\n      bitmask = newData[1];\r\n      thisArg = newData[2];\r\n      partials = newData[3];\r\n      holders = newData[4];\r\n      arity = newData[9] = newData[9] === undefined\r\n        ? (isBindKey ? 0 : func.length)\r\n        : nativeMax(newData[9] - length, 0);\r\n\r\n      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {\r\n        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);\r\n      }\r\n      if (!bitmask || bitmask == WRAP_BIND_FLAG) {\r\n        var result = createBind(func, bitmask, thisArg);\r\n      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {\r\n        result = createCurry(func, bitmask, arity);\r\n      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {\r\n        result = createPartial(func, bitmask, thisArg, partials);\r\n      } else {\r\n        result = createHybrid.apply(undefined, newData);\r\n      }\r\n      var setter = data ? baseSetData : setData;\r\n      return setWrapToString(setter(result, newData), func, bitmask);\r\n    }\r\n\r\n    /**\r\n     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties\r\n     * of source objects to the destination object for all destination properties\r\n     * that resolve to `undefined`.\r\n     *\r\n     * @private\r\n     * @param {*} objValue The destination value.\r\n     * @param {*} srcValue The source value.\r\n     * @param {string} key The key of the property to assign.\r\n     * @param {Object} object The parent object of `objValue`.\r\n     * @returns {*} Returns the value to assign.\r\n     */\r\n    function customDefaultsAssignIn(objValue, srcValue, key, object) {\r\n      if (objValue === undefined ||\r\n          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {\r\n        return srcValue;\r\n      }\r\n      return objValue;\r\n    }\r\n\r\n    /**\r\n     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source\r\n     * objects into destination objects that are passed thru.\r\n     *\r\n     * @private\r\n     * @param {*} objValue The destination value.\r\n     * @param {*} srcValue The source value.\r\n     * @param {string} key The key of the property to merge.\r\n     * @param {Object} object The parent object of `objValue`.\r\n     * @param {Object} source The parent object of `srcValue`.\r\n     * @param {Object} [stack] Tracks traversed source values and their merged\r\n     *  counterparts.\r\n     * @returns {*} Returns the value to assign.\r\n     */\r\n    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {\r\n      if (isObject(objValue) && isObject(srcValue)) {\r\n        // Recursively merge objects and arrays (susceptible to call stack limits).\r\n        stack.set(srcValue, objValue);\r\n        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);\r\n        stack['delete'](srcValue);\r\n      }\r\n      return objValue;\r\n    }\r\n\r\n    /**\r\n     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain\r\n     * objects.\r\n     *\r\n     * @private\r\n     * @param {*} value The value to inspect.\r\n     * @param {string} key The key of the property to inspect.\r\n     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.\r\n     */\r\n    function customOmitClone(value) {\r\n      return isPlainObject(value) ? undefined : value;\r\n    }\r\n\r\n    /**\r\n     * A specialized version of `baseIsEqualDeep` for arrays with support for\r\n     * partial deep comparisons.\r\n     *\r\n     * @private\r\n     * @param {Array} array The array to compare.\r\n     * @param {Array} other The other array to compare.\r\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\r\n     * @param {Function} customizer The function to customize comparisons.\r\n     * @param {Function} equalFunc The function to determine equivalents of values.\r\n     * @param {Object} stack Tracks traversed `array` and `other` objects.\r\n     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\r\n     */\r\n    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\r\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\r\n          arrLength = array.length,\r\n          othLength = other.length;\r\n\r\n      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\r\n        return false;\r\n      }\r\n      // Check that cyclic values are equal.\r\n      var arrStacked = stack.get(array);\r\n      var othStacked = stack.get(other);\r\n      if (arrStacked && othStacked) {\r\n        return arrStacked == other && othStacked == array;\r\n      }\r\n      var index = -1,\r\n          result = true,\r\n          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\r\n\r\n      stack.set(array, other);\r\n      stack.set(other, array);\r\n\r\n      // Ignore non-index properties.\r\n      while (++index < arrLength) {\r\n        var arrValue = array[index],\r\n            othValue = other[index];\r\n\r\n        if (customizer) {\r\n          var compared = isPartial\r\n            ? customizer(othValue, arrValue, index, other, array, stack)\r\n            : customizer(arrValue, othValue, index, array, other, stack);\r\n        }\r\n        if (compared !== undefined) {\r\n          if (compared) {\r\n            continue;\r\n          }\r\n          result = false;\r\n          break;\r\n        }\r\n        // Recursively compare arrays (susceptible to call stack limits).\r\n        if (seen) {\r\n          if (!arraySome(other, function(othValue, othIndex) {\r\n                if (!cacheHas(seen, othIndex) &&\r\n                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\r\n                  return seen.push(othIndex);\r\n                }\r\n              })) {\r\n            result = false;\r\n            break;\r\n          }\r\n        } else if (!(\r\n              arrValue === othValue ||\r\n                equalFunc(arrValue, othValue, bitmask, customizer, stack)\r\n            )) {\r\n          result = false;\r\n          break;\r\n        }\r\n      }\r\n      stack['delete'](array);\r\n      stack['delete'](other);\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * A specialized version of `baseIsEqualDeep` for comparing objects of\r\n     * the same `toStringTag`.\r\n     *\r\n     * **Note:** This function only supports comparing values with tags of\r\n     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to compare.\r\n     * @param {Object} other The other object to compare.\r\n     * @param {string} tag The `toStringTag` of the objects to compare.\r\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\r\n     * @param {Function} customizer The function to customize comparisons.\r\n     * @param {Function} equalFunc The function to determine equivalents of values.\r\n     * @param {Object} stack Tracks traversed `object` and `other` objects.\r\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\r\n     */\r\n    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\r\n      switch (tag) {\r\n        case dataViewTag:\r\n          if ((object.byteLength != other.byteLength) ||\r\n              (object.byteOffset != other.byteOffset)) {\r\n            return false;\r\n          }\r\n          object = object.buffer;\r\n          other = other.buffer;\r\n\r\n        case arrayBufferTag:\r\n          if ((object.byteLength != other.byteLength) ||\r\n              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\r\n            return false;\r\n          }\r\n          return true;\r\n\r\n        case boolTag:\r\n        case dateTag:\r\n        case numberTag:\r\n          // Coerce booleans to `1` or `0` and dates to milliseconds.\r\n          // Invalid dates are coerced to `NaN`.\r\n          return eq(+object, +other);\r\n\r\n        case errorTag:\r\n          return object.name == other.name && object.message == other.message;\r\n\r\n        case regexpTag:\r\n        case stringTag:\r\n          // Coerce regexes to strings and treat strings, primitives and objects,\r\n          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\r\n          // for more details.\r\n          return object == (other + '');\r\n\r\n        case mapTag:\r\n          var convert = mapToArray;\r\n\r\n        case setTag:\r\n          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\r\n          convert || (convert = setToArray);\r\n\r\n          if (object.size != other.size && !isPartial) {\r\n            return false;\r\n          }\r\n          // Assume cyclic values are equal.\r\n          var stacked = stack.get(object);\r\n          if (stacked) {\r\n            return stacked == other;\r\n          }\r\n          bitmask |= COMPARE_UNORDERED_FLAG;\r\n\r\n          // Recursively compare objects (susceptible to call stack limits).\r\n          stack.set(object, other);\r\n          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\r\n          stack['delete'](object);\r\n          return result;\r\n\r\n        case symbolTag:\r\n          if (symbolValueOf) {\r\n            return symbolValueOf.call(object) == symbolValueOf.call(other);\r\n          }\r\n      }\r\n      return false;\r\n    }\r\n\r\n    /**\r\n     * A specialized version of `baseIsEqualDeep` for objects with support for\r\n     * partial deep comparisons.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to compare.\r\n     * @param {Object} other The other object to compare.\r\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\r\n     * @param {Function} customizer The function to customize comparisons.\r\n     * @param {Function} equalFunc The function to determine equivalents of values.\r\n     * @param {Object} stack Tracks traversed `object` and `other` objects.\r\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\r\n     */\r\n    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\r\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\r\n          objProps = getAllKeys(object),\r\n          objLength = objProps.length,\r\n          othProps = getAllKeys(other),\r\n          othLength = othProps.length;\r\n\r\n      if (objLength != othLength && !isPartial) {\r\n        return false;\r\n      }\r\n      var index = objLength;\r\n      while (index--) {\r\n        var key = objProps[index];\r\n        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\r\n          return false;\r\n        }\r\n      }\r\n      // Check that cyclic values are equal.\r\n      var objStacked = stack.get(object);\r\n      var othStacked = stack.get(other);\r\n      if (objStacked && othStacked) {\r\n        return objStacked == other && othStacked == object;\r\n      }\r\n      var result = true;\r\n      stack.set(object, other);\r\n      stack.set(other, object);\r\n\r\n      var skipCtor = isPartial;\r\n      while (++index < objLength) {\r\n        key = objProps[index];\r\n        var objValue = object[key],\r\n            othValue = other[key];\r\n\r\n        if (customizer) {\r\n          var compared = isPartial\r\n            ? customizer(othValue, objValue, key, other, object, stack)\r\n            : customizer(objValue, othValue, key, object, other, stack);\r\n        }\r\n        // Recursively compare objects (susceptible to call stack limits).\r\n        if (!(compared === undefined\r\n              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\r\n              : compared\r\n            )) {\r\n          result = false;\r\n          break;\r\n        }\r\n        skipCtor || (skipCtor = key == 'constructor');\r\n      }\r\n      if (result && !skipCtor) {\r\n        var objCtor = object.constructor,\r\n            othCtor = other.constructor;\r\n\r\n        // Non `Object` object instances with different constructors are not equal.\r\n        if (objCtor != othCtor &&\r\n            ('constructor' in object && 'constructor' in other) &&\r\n            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\r\n              typeof othCtor == 'function' && othCtor instanceof othCtor)) {\r\n          result = false;\r\n        }\r\n      }\r\n      stack['delete'](object);\r\n      stack['delete'](other);\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * A specialized version of `baseRest` which flattens the rest array.\r\n     *\r\n     * @private\r\n     * @param {Function} func The function to apply a rest parameter to.\r\n     * @returns {Function} Returns the new function.\r\n     */\r\n    function flatRest(func) {\r\n      return setToString(overRest(func, undefined, flatten), func + '');\r\n    }\r\n\r\n    /**\r\n     * Creates an array of own enumerable property names and symbols of `object`.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to query.\r\n     * @returns {Array} Returns the array of property names and symbols.\r\n     */\r\n    function getAllKeys(object) {\r\n      return baseGetAllKeys(object, keys, getSymbols);\r\n    }\r\n\r\n    /**\r\n     * Creates an array of own and inherited enumerable property names and\r\n     * symbols of `object`.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to query.\r\n     * @returns {Array} Returns the array of property names and symbols.\r\n     */\r\n    function getAllKeysIn(object) {\r\n      return baseGetAllKeys(object, keysIn, getSymbolsIn);\r\n    }\r\n\r\n    /**\r\n     * Gets metadata for `func`.\r\n     *\r\n     * @private\r\n     * @param {Function} func The function to query.\r\n     * @returns {*} Returns the metadata for `func`.\r\n     */\r\n    var getData = !metaMap ? noop : function(func) {\r\n      return metaMap.get(func);\r\n    };\r\n\r\n    /**\r\n     * Gets the name of `func`.\r\n     *\r\n     * @private\r\n     * @param {Function} func The function to query.\r\n     * @returns {string} Returns the function name.\r\n     */\r\n    function getFuncName(func) {\r\n      var result = (func.name + ''),\r\n          array = realNames[result],\r\n          length = hasOwnProperty.call(realNames, result) ? array.length : 0;\r\n\r\n      while (length--) {\r\n        var data = array[length],\r\n            otherFunc = data.func;\r\n        if (otherFunc == null || otherFunc == func) {\r\n          return data.name;\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Gets the argument placeholder value for `func`.\r\n     *\r\n     * @private\r\n     * @param {Function} func The function to inspect.\r\n     * @returns {*} Returns the placeholder value.\r\n     */\r\n    function getHolder(func) {\r\n      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;\r\n      return object.placeholder;\r\n    }\r\n\r\n    /**\r\n     * Gets the appropriate \"iteratee\" function. If `_.iteratee` is customized,\r\n     * this function returns the custom method, otherwise it returns `baseIteratee`.\r\n     * If arguments are provided, the chosen function is invoked with them and\r\n     * its result is returned.\r\n     *\r\n     * @private\r\n     * @param {*} [value] The value to convert to an iteratee.\r\n     * @param {number} [arity] The arity of the created iteratee.\r\n     * @returns {Function} Returns the chosen function or its result.\r\n     */\r\n    function getIteratee() {\r\n      var result = lodash.iteratee || iteratee;\r\n      result = result === iteratee ? baseIteratee : result;\r\n      return arguments.length ? result(arguments[0], arguments[1]) : result;\r\n    }\r\n\r\n    /**\r\n     * Gets the data for `map`.\r\n     *\r\n     * @private\r\n     * @param {Object} map The map to query.\r\n     * @param {string} key The reference key.\r\n     * @returns {*} Returns the map data.\r\n     */\r\n    function getMapData(map, key) {\r\n      var data = map.__data__;\r\n      return isKeyable(key)\r\n        ? data[typeof key == 'string' ? 'string' : 'hash']\r\n        : data.map;\r\n    }\r\n\r\n    /**\r\n     * Gets the property names, values, and compare flags of `object`.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to query.\r\n     * @returns {Array} Returns the match data of `object`.\r\n     */\r\n    function getMatchData(object) {\r\n      var result = keys(object),\r\n          length = result.length;\r\n\r\n      while (length--) {\r\n        var key = result[length],\r\n            value = object[key];\r\n\r\n        result[length] = [key, value, isStrictComparable(value)];\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Gets the native function at `key` of `object`.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to query.\r\n     * @param {string} key The key of the method to get.\r\n     * @returns {*} Returns the function if it's native, else `undefined`.\r\n     */\r\n    function getNative(object, key) {\r\n      var value = getValue(object, key);\r\n      return baseIsNative(value) ? value : undefined;\r\n    }\r\n\r\n    /**\r\n     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\r\n     *\r\n     * @private\r\n     * @param {*} value The value to query.\r\n     * @returns {string} Returns the raw `toStringTag`.\r\n     */\r\n    function getRawTag(value) {\r\n      var isOwn = hasOwnProperty.call(value, symToStringTag),\r\n          tag = value[symToStringTag];\r\n\r\n      try {\r\n        value[symToStringTag] = undefined;\r\n        var unmasked = true;\r\n      } catch (e) {}\r\n\r\n      var result = nativeObjectToString.call(value);\r\n      if (unmasked) {\r\n        if (isOwn) {\r\n          value[symToStringTag] = tag;\r\n        } else {\r\n          delete value[symToStringTag];\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Creates an array of the own enumerable symbols of `object`.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to query.\r\n     * @returns {Array} Returns the array of symbols.\r\n     */\r\n    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {\r\n      if (object == null) {\r\n        return [];\r\n      }\r\n      object = Object(object);\r\n      return arrayFilter(nativeGetSymbols(object), function(symbol) {\r\n        return propertyIsEnumerable.call(object, symbol);\r\n      });\r\n    };\r\n\r\n    /**\r\n     * Creates an array of the own and inherited enumerable symbols of `object`.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to query.\r\n     * @returns {Array} Returns the array of symbols.\r\n     */\r\n    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {\r\n      var result = [];\r\n      while (object) {\r\n        arrayPush(result, getSymbols(object));\r\n        object = getPrototype(object);\r\n      }\r\n      return result;\r\n    };\r\n\r\n    /**\r\n     * Gets the `toStringTag` of `value`.\r\n     *\r\n     * @private\r\n     * @param {*} value The value to query.\r\n     * @returns {string} Returns the `toStringTag`.\r\n     */\r\n    var getTag = baseGetTag;\r\n\r\n    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\r\n    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\r\n        (Map && getTag(new Map) != mapTag) ||\r\n        (Promise && getTag(Promise.resolve()) != promiseTag) ||\r\n        (Set && getTag(new Set) != setTag) ||\r\n        (WeakMap && getTag(new WeakMap) != weakMapTag)) {\r\n      getTag = function(value) {\r\n        var result = baseGetTag(value),\r\n            Ctor = result == objectTag ? value.constructor : undefined,\r\n            ctorString = Ctor ? toSource(Ctor) : '';\r\n\r\n        if (ctorString) {\r\n          switch (ctorString) {\r\n            case dataViewCtorString: return dataViewTag;\r\n            case mapCtorString: return mapTag;\r\n            case promiseCtorString: return promiseTag;\r\n            case setCtorString: return setTag;\r\n            case weakMapCtorString: return weakMapTag;\r\n          }\r\n        }\r\n        return result;\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Gets the view, applying any `transforms` to the `start` and `end` positions.\r\n     *\r\n     * @private\r\n     * @param {number} start The start of the view.\r\n     * @param {number} end The end of the view.\r\n     * @param {Array} transforms The transformations to apply to the view.\r\n     * @returns {Object} Returns an object containing the `start` and `end`\r\n     *  positions of the view.\r\n     */\r\n    function getView(start, end, transforms) {\r\n      var index = -1,\r\n          length = transforms.length;\r\n\r\n      while (++index < length) {\r\n        var data = transforms[index],\r\n            size = data.size;\r\n\r\n        switch (data.type) {\r\n          case 'drop':      start += size; break;\r\n          case 'dropRight': end -= size; break;\r\n          case 'take':      end = nativeMin(end, start + size); break;\r\n          case 'takeRight': start = nativeMax(start, end - size); break;\r\n        }\r\n      }\r\n      return { 'start': start, 'end': end };\r\n    }\r\n\r\n    /**\r\n     * Extracts wrapper details from the `source` body comment.\r\n     *\r\n     * @private\r\n     * @param {string} source The source to inspect.\r\n     * @returns {Array} Returns the wrapper details.\r\n     */\r\n    function getWrapDetails(source) {\r\n      var match = source.match(reWrapDetails);\r\n      return match ? match[1].split(reSplitDetails) : [];\r\n    }\r\n\r\n    /**\r\n     * Checks if `path` exists on `object`.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to query.\r\n     * @param {Array|string} path The path to check.\r\n     * @param {Function} hasFunc The function to check properties.\r\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\r\n     */\r\n    function hasPath(object, path, hasFunc) {\r\n      path = castPath(path, object);\r\n\r\n      var index = -1,\r\n          length = path.length,\r\n          result = false;\r\n\r\n      while (++index < length) {\r\n        var key = toKey(path[index]);\r\n        if (!(result = object != null && hasFunc(object, key))) {\r\n          break;\r\n        }\r\n        object = object[key];\r\n      }\r\n      if (result || ++index != length) {\r\n        return result;\r\n      }\r\n      length = object == null ? 0 : object.length;\r\n      return !!length && isLength(length) && isIndex(key, length) &&\r\n        (isArray(object) || isArguments(object));\r\n    }\r\n\r\n    /**\r\n     * Initializes an array clone.\r\n     *\r\n     * @private\r\n     * @param {Array} array The array to clone.\r\n     * @returns {Array} Returns the initialized clone.\r\n     */\r\n    function initCloneArray(array) {\r\n      var length = array.length,\r\n          result = new array.constructor(length);\r\n\r\n      // Add properties assigned by `RegExp#exec`.\r\n      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\r\n        result.index = array.index;\r\n        result.input = array.input;\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Initializes an object clone.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to clone.\r\n     * @returns {Object} Returns the initialized clone.\r\n     */\r\n    function initCloneObject(object) {\r\n      return (typeof object.constructor == 'function' && !isPrototype(object))\r\n        ? baseCreate(getPrototype(object))\r\n        : {};\r\n    }\r\n\r\n    /**\r\n     * Initializes an object clone based on its `toStringTag`.\r\n     *\r\n     * **Note:** This function only supports cloning values with tags of\r\n     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to clone.\r\n     * @param {string} tag The `toStringTag` of the object to clone.\r\n     * @param {boolean} [isDeep] Specify a deep clone.\r\n     * @returns {Object} Returns the initialized clone.\r\n     */\r\n    function initCloneByTag(object, tag, isDeep) {\r\n      var Ctor = object.constructor;\r\n      switch (tag) {\r\n        case arrayBufferTag:\r\n          return cloneArrayBuffer(object);\r\n\r\n        case boolTag:\r\n        case dateTag:\r\n          return new Ctor(+object);\r\n\r\n        case dataViewTag:\r\n          return cloneDataView(object, isDeep);\r\n\r\n        case float32Tag: case float64Tag:\r\n        case int8Tag: case int16Tag: case int32Tag:\r\n        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\r\n          return cloneTypedArray(object, isDeep);\r\n\r\n        case mapTag:\r\n          return new Ctor;\r\n\r\n        case numberTag:\r\n        case stringTag:\r\n          return new Ctor(object);\r\n\r\n        case regexpTag:\r\n          return cloneRegExp(object);\r\n\r\n        case setTag:\r\n          return new Ctor;\r\n\r\n        case symbolTag:\r\n          return cloneSymbol(object);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Inserts wrapper `details` in a comment at the top of the `source` body.\r\n     *\r\n     * @private\r\n     * @param {string} source The source to modify.\r\n     * @returns {Array} details The details to insert.\r\n     * @returns {string} Returns the modified source.\r\n     */\r\n    function insertWrapDetails(source, details) {\r\n      var length = details.length;\r\n      if (!length) {\r\n        return source;\r\n      }\r\n      var lastIndex = length - 1;\r\n      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];\r\n      details = details.join(length > 2 ? ', ' : ' ');\r\n      return source.replace(reWrapComment, '{\\n/* [wrapped with ' + details + '] */\\n');\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is a flattenable `arguments` object or array.\r\n     *\r\n     * @private\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\r\n     */\r\n    function isFlattenable(value) {\r\n      return isArray(value) || isArguments(value) ||\r\n        !!(spreadableSymbol && value && value[spreadableSymbol]);\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is a valid array-like index.\r\n     *\r\n     * @private\r\n     * @param {*} value The value to check.\r\n     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\r\n     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\r\n     */\r\n    function isIndex(value, length) {\r\n      var type = typeof value;\r\n      length = length == null ? MAX_SAFE_INTEGER : length;\r\n\r\n      return !!length &&\r\n        (type == 'number' ||\r\n          (type != 'symbol' && reIsUint.test(value))) &&\r\n            (value > -1 && value % 1 == 0 && value < length);\r\n    }\r\n\r\n    /**\r\n     * Checks if the given arguments are from an iteratee call.\r\n     *\r\n     * @private\r\n     * @param {*} value The potential iteratee value argument.\r\n     * @param {*} index The potential iteratee index or key argument.\r\n     * @param {*} object The potential iteratee object argument.\r\n     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\r\n     *  else `false`.\r\n     */\r\n    function isIterateeCall(value, index, object) {\r\n      if (!isObject(object)) {\r\n        return false;\r\n      }\r\n      var type = typeof index;\r\n      if (type == 'number'\r\n            ? (isArrayLike(object) && isIndex(index, object.length))\r\n            : (type == 'string' && index in object)\r\n          ) {\r\n        return eq(object[index], value);\r\n      }\r\n      return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is a property name and not a property path.\r\n     *\r\n     * @private\r\n     * @param {*} value The value to check.\r\n     * @param {Object} [object] The object to query keys on.\r\n     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\r\n     */\r\n    function isKey(value, object) {\r\n      if (isArray(value)) {\r\n        return false;\r\n      }\r\n      var type = typeof value;\r\n      if (type == 'number' || type == 'symbol' || type == 'boolean' ||\r\n          value == null || isSymbol(value)) {\r\n        return true;\r\n      }\r\n      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\r\n        (object != null && value in Object(object));\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is suitable for use as unique object key.\r\n     *\r\n     * @private\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\r\n     */\r\n    function isKeyable(value) {\r\n      var type = typeof value;\r\n      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\r\n        ? (value !== '__proto__')\r\n        : (value === null);\r\n    }\r\n\r\n    /**\r\n     * Checks if `func` has a lazy counterpart.\r\n     *\r\n     * @private\r\n     * @param {Function} func The function to check.\r\n     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,\r\n     *  else `false`.\r\n     */\r\n    function isLaziable(func) {\r\n      var funcName = getFuncName(func),\r\n          other = lodash[funcName];\r\n\r\n      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {\r\n        return false;\r\n      }\r\n      if (func === other) {\r\n        return true;\r\n      }\r\n      var data = getData(other);\r\n      return !!data && func === data[0];\r\n    }\r\n\r\n    /**\r\n     * Checks if `func` has its source masked.\r\n     *\r\n     * @private\r\n     * @param {Function} func The function to check.\r\n     * @returns {boolean} Returns `true` if `func` is masked, else `false`.\r\n     */\r\n    function isMasked(func) {\r\n      return !!maskSrcKey && (maskSrcKey in func);\r\n    }\r\n\r\n    /**\r\n     * Checks if `func` is capable of being masked.\r\n     *\r\n     * @private\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.\r\n     */\r\n    var isMaskable = coreJsData ? isFunction : stubFalse;\r\n\r\n    /**\r\n     * Checks if `value` is likely a prototype object.\r\n     *\r\n     * @private\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\r\n     */\r\n    function isPrototype(value) {\r\n      var Ctor = value && value.constructor,\r\n          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\r\n\r\n      return value === proto;\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\r\n     *\r\n     * @private\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` if suitable for strict\r\n     *  equality comparisons, else `false`.\r\n     */\r\n    function isStrictComparable(value) {\r\n      return value === value && !isObject(value);\r\n    }\r\n\r\n    /**\r\n     * A specialized version of `matchesProperty` for source values suitable\r\n     * for strict equality comparisons, i.e. `===`.\r\n     *\r\n     * @private\r\n     * @param {string} key The key of the property to get.\r\n     * @param {*} srcValue The value to match.\r\n     * @returns {Function} Returns the new spec function.\r\n     */\r\n    function matchesStrictComparable(key, srcValue) {\r\n      return function(object) {\r\n        if (object == null) {\r\n          return false;\r\n        }\r\n        return object[key] === srcValue &&\r\n          (srcValue !== undefined || (key in Object(object)));\r\n      };\r\n    }\r\n\r\n    /**\r\n     * A specialized version of `_.memoize` which clears the memoized function's\r\n     * cache when it exceeds `MAX_MEMOIZE_SIZE`.\r\n     *\r\n     * @private\r\n     * @param {Function} func The function to have its output memoized.\r\n     * @returns {Function} Returns the new memoized function.\r\n     */\r\n    function memoizeCapped(func) {\r\n      var result = memoize(func, function(key) {\r\n        if (cache.size === MAX_MEMOIZE_SIZE) {\r\n          cache.clear();\r\n        }\r\n        return key;\r\n      });\r\n\r\n      var cache = result.cache;\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Merges the function metadata of `source` into `data`.\r\n     *\r\n     * Merging metadata reduces the number of wrappers used to invoke a function.\r\n     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`\r\n     * may be applied regardless of execution order. Methods like `_.ary` and\r\n     * `_.rearg` modify function arguments, making the order in which they are\r\n     * executed important, preventing the merging of metadata. However, we make\r\n     * an exception for a safe combined case where curried functions have `_.ary`\r\n     * and or `_.rearg` applied.\r\n     *\r\n     * @private\r\n     * @param {Array} data The destination metadata.\r\n     * @param {Array} source The source metadata.\r\n     * @returns {Array} Returns `data`.\r\n     */\r\n    function mergeData(data, source) {\r\n      var bitmask = data[1],\r\n          srcBitmask = source[1],\r\n          newBitmask = bitmask | srcBitmask,\r\n          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);\r\n\r\n      var isCombo =\r\n        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||\r\n        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||\r\n        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));\r\n\r\n      // Exit early if metadata can't be merged.\r\n      if (!(isCommon || isCombo)) {\r\n        return data;\r\n      }\r\n      // Use source `thisArg` if available.\r\n      if (srcBitmask & WRAP_BIND_FLAG) {\r\n        data[2] = source[2];\r\n        // Set when currying a bound function.\r\n        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;\r\n      }\r\n      // Compose partial arguments.\r\n      var value = source[3];\r\n      if (value) {\r\n        var partials = data[3];\r\n        data[3] = partials ? composeArgs(partials, value, source[4]) : value;\r\n        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];\r\n      }\r\n      // Compose partial right arguments.\r\n      value = source[5];\r\n      if (value) {\r\n        partials = data[5];\r\n        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;\r\n        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];\r\n      }\r\n      // Use source `argPos` if available.\r\n      value = source[7];\r\n      if (value) {\r\n        data[7] = value;\r\n      }\r\n      // Use source `ary` if it's smaller.\r\n      if (srcBitmask & WRAP_ARY_FLAG) {\r\n        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);\r\n      }\r\n      // Use source `arity` if one is not provided.\r\n      if (data[9] == null) {\r\n        data[9] = source[9];\r\n      }\r\n      // Use source `func` and merge bitmasks.\r\n      data[0] = source[0];\r\n      data[1] = newBitmask;\r\n\r\n      return data;\r\n    }\r\n\r\n    /**\r\n     * This function is like\r\n     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\r\n     * except that it includes inherited enumerable properties.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to query.\r\n     * @returns {Array} Returns the array of property names.\r\n     */\r\n    function nativeKeysIn(object) {\r\n      var result = [];\r\n      if (object != null) {\r\n        for (var key in Object(object)) {\r\n          result.push(key);\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Converts `value` to a string using `Object.prototype.toString`.\r\n     *\r\n     * @private\r\n     * @param {*} value The value to convert.\r\n     * @returns {string} Returns the converted string.\r\n     */\r\n    function objectToString(value) {\r\n      return nativeObjectToString.call(value);\r\n    }\r\n\r\n    /**\r\n     * A specialized version of `baseRest` which transforms the rest array.\r\n     *\r\n     * @private\r\n     * @param {Function} func The function to apply a rest parameter to.\r\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\r\n     * @param {Function} transform The rest array transform.\r\n     * @returns {Function} Returns the new function.\r\n     */\r\n    function overRest(func, start, transform) {\r\n      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\r\n      return function() {\r\n        var args = arguments,\r\n            index = -1,\r\n            length = nativeMax(args.length - start, 0),\r\n            array = Array(length);\r\n\r\n        while (++index < length) {\r\n          array[index] = args[start + index];\r\n        }\r\n        index = -1;\r\n        var otherArgs = Array(start + 1);\r\n        while (++index < start) {\r\n          otherArgs[index] = args[index];\r\n        }\r\n        otherArgs[start] = transform(array);\r\n        return apply(func, this, otherArgs);\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Gets the parent value at `path` of `object`.\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to query.\r\n     * @param {Array} path The path to get the parent value of.\r\n     * @returns {*} Returns the parent value.\r\n     */\r\n    function parent(object, path) {\r\n      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));\r\n    }\r\n\r\n    /**\r\n     * Reorder `array` according to the specified indexes where the element at\r\n     * the first index is assigned as the first element, the element at\r\n     * the second index is assigned as the second element, and so on.\r\n     *\r\n     * @private\r\n     * @param {Array} array The array to reorder.\r\n     * @param {Array} indexes The arranged array indexes.\r\n     * @returns {Array} Returns `array`.\r\n     */\r\n    function reorder(array, indexes) {\r\n      var arrLength = array.length,\r\n          length = nativeMin(indexes.length, arrLength),\r\n          oldArray = copyArray(array);\r\n\r\n      while (length--) {\r\n        var index = indexes[length];\r\n        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;\r\n      }\r\n      return array;\r\n    }\r\n\r\n    /**\r\n     * Gets the value at `key`, unless `key` is \"__proto__\" or \"constructor\".\r\n     *\r\n     * @private\r\n     * @param {Object} object The object to query.\r\n     * @param {string} key The key of the property to get.\r\n     * @returns {*} Returns the property value.\r\n     */\r\n    function safeGet(object, key) {\r\n      if (key === 'constructor' && typeof object[key] === 'function') {\r\n        return;\r\n      }\r\n\r\n      if (key == '__proto__') {\r\n        return;\r\n      }\r\n\r\n      return object[key];\r\n    }\r\n\r\n    /**\r\n     * Sets metadata for `func`.\r\n     *\r\n     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short\r\n     * period of time, it will trip its breaker and transition to an identity\r\n     * function to avoid garbage collection pauses in V8. See\r\n     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)\r\n     * for more details.\r\n     *\r\n     * @private\r\n     * @param {Function} func The function to associate metadata with.\r\n     * @param {*} data The metadata.\r\n     * @returns {Function} Returns `func`.\r\n     */\r\n    var setData = shortOut(baseSetData);\r\n\r\n    /**\r\n     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).\r\n     *\r\n     * @private\r\n     * @param {Function} func The function to delay.\r\n     * @param {number} wait The number of milliseconds to delay invocation.\r\n     * @returns {number|Object} Returns the timer id or timeout object.\r\n     */\r\n    var setTimeout = ctxSetTimeout || function(func, wait) {\r\n      return root.setTimeout(func, wait);\r\n    };\r\n\r\n    /**\r\n     * Sets the `toString` method of `func` to return `string`.\r\n     *\r\n     * @private\r\n     * @param {Function} func The function to modify.\r\n     * @param {Function} string The `toString` result.\r\n     * @returns {Function} Returns `func`.\r\n     */\r\n    var setToString = shortOut(baseSetToString);\r\n\r\n    /**\r\n     * Sets the `toString` method of `wrapper` to mimic the source of `reference`\r\n     * with wrapper details in a comment at the top of the source body.\r\n     *\r\n     * @private\r\n     * @param {Function} wrapper The function to modify.\r\n     * @param {Function} reference The reference function.\r\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\r\n     * @returns {Function} Returns `wrapper`.\r\n     */\r\n    function setWrapToString(wrapper, reference, bitmask) {\r\n      var source = (reference + '');\r\n      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));\r\n    }\r\n\r\n    /**\r\n     * Creates a function that'll short out and invoke `identity` instead\r\n     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\r\n     * milliseconds.\r\n     *\r\n     * @private\r\n     * @param {Function} func The function to restrict.\r\n     * @returns {Function} Returns the new shortable function.\r\n     */\r\n    function shortOut(func) {\r\n      var count = 0,\r\n          lastCalled = 0;\r\n\r\n      return function() {\r\n        var stamp = nativeNow(),\r\n            remaining = HOT_SPAN - (stamp - lastCalled);\r\n\r\n        lastCalled = stamp;\r\n        if (remaining > 0) {\r\n          if (++count >= HOT_COUNT) {\r\n            return arguments[0];\r\n          }\r\n        } else {\r\n          count = 0;\r\n        }\r\n        return func.apply(undefined, arguments);\r\n      };\r\n    }\r\n\r\n    /**\r\n     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.\r\n     *\r\n     * @private\r\n     * @param {Array} array The array to shuffle.\r\n     * @param {number} [size=array.length] The size of `array`.\r\n     * @returns {Array} Returns `array`.\r\n     */\r\n    function shuffleSelf(array, size) {\r\n      var index = -1,\r\n          length = array.length,\r\n          lastIndex = length - 1;\r\n\r\n      size = size === undefined ? length : size;\r\n      while (++index < size) {\r\n        var rand = baseRandom(index, lastIndex),\r\n            value = array[rand];\r\n\r\n        array[rand] = array[index];\r\n        array[index] = value;\r\n      }\r\n      array.length = size;\r\n      return array;\r\n    }\r\n\r\n    /**\r\n     * Converts `string` to a property path array.\r\n     *\r\n     * @private\r\n     * @param {string} string The string to convert.\r\n     * @returns {Array} Returns the property path array.\r\n     */\r\n    var stringToPath = memoizeCapped(function(string) {\r\n      var result = [];\r\n      if (string.charCodeAt(0) === 46 /* . */) {\r\n        result.push('');\r\n      }\r\n      string.replace(rePropName, function(match, number, quote, subString) {\r\n        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\r\n      });\r\n      return result;\r\n    });\r\n\r\n    /**\r\n     * Converts `value` to a string key if it's not a string or symbol.\r\n     *\r\n     * @private\r\n     * @param {*} value The value to inspect.\r\n     * @returns {string|symbol} Returns the key.\r\n     */\r\n    function toKey(value) {\r\n      if (typeof value == 'string' || isSymbol(value)) {\r\n        return value;\r\n      }\r\n      var result = (value + '');\r\n      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\r\n    }\r\n\r\n    /**\r\n     * Converts `func` to its source code.\r\n     *\r\n     * @private\r\n     * @param {Function} func The function to convert.\r\n     * @returns {string} Returns the source code.\r\n     */\r\n    function toSource(func) {\r\n      if (func != null) {\r\n        try {\r\n          return funcToString.call(func);\r\n        } catch (e) {}\r\n        try {\r\n          return (func + '');\r\n        } catch (e) {}\r\n      }\r\n      return '';\r\n    }\r\n\r\n    /**\r\n     * Updates wrapper `details` based on `bitmask` flags.\r\n     *\r\n     * @private\r\n     * @returns {Array} details The details to modify.\r\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\r\n     * @returns {Array} Returns `details`.\r\n     */\r\n    function updateWrapDetails(details, bitmask) {\r\n      arrayEach(wrapFlags, function(pair) {\r\n        var value = '_.' + pair[0];\r\n        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {\r\n          details.push(value);\r\n        }\r\n      });\r\n      return details.sort();\r\n    }\r\n\r\n    /**\r\n     * Creates a clone of `wrapper`.\r\n     *\r\n     * @private\r\n     * @param {Object} wrapper The wrapper to clone.\r\n     * @returns {Object} Returns the cloned wrapper.\r\n     */\r\n    function wrapperClone(wrapper) {\r\n      if (wrapper instanceof LazyWrapper) {\r\n        return wrapper.clone();\r\n      }\r\n      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);\r\n      result.__actions__ = copyArray(wrapper.__actions__);\r\n      result.__index__  = wrapper.__index__;\r\n      result.__values__ = wrapper.__values__;\r\n      return result;\r\n    }\r\n\r\n    /*------------------------------------------------------------------------*/\r\n\r\n    /**\r\n     * Creates an array of elements split into groups the length of `size`.\r\n     * If `array` can't be split evenly, the final chunk will be the remaining\r\n     * elements.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.0.0\r\n     * @category Array\r\n     * @param {Array} array The array to process.\r\n     * @param {number} [size=1] The length of each chunk\r\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\r\n     * @returns {Array} Returns the new array of chunks.\r\n     * @example\r\n     *\r\n     * _.chunk(['a', 'b', 'c', 'd'], 2);\r\n     * // => [['a', 'b'], ['c', 'd']]\r\n     *\r\n     * _.chunk(['a', 'b', 'c', 'd'], 3);\r\n     * // => [['a', 'b', 'c'], ['d']]\r\n     */\r\n    function chunk(array, size, guard) {\r\n      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {\r\n        size = 1;\r\n      } else {\r\n        size = nativeMax(toInteger(size), 0);\r\n      }\r\n      var length = array == null ? 0 : array.length;\r\n      if (!length || size < 1) {\r\n        return [];\r\n      }\r\n      var index = 0,\r\n          resIndex = 0,\r\n          result = Array(nativeCeil(length / size));\r\n\r\n      while (index < length) {\r\n        result[resIndex++] = baseSlice(array, index, (index += size));\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Creates an array with all falsey values removed. The values `false`, `null`,\r\n     * `0`, `\"\"`, `undefined`, and `NaN` are falsey.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Array\r\n     * @param {Array} array The array to compact.\r\n     * @returns {Array} Returns the new array of filtered values.\r\n     * @example\r\n     *\r\n     * _.compact([0, 1, false, 2, '', 3]);\r\n     * // => [1, 2, 3]\r\n     */\r\n    function compact(array) {\r\n      var index = -1,\r\n          length = array == null ? 0 : array.length,\r\n          resIndex = 0,\r\n          result = [];\r\n\r\n      while (++index < length) {\r\n        var value = array[index];\r\n        if (value) {\r\n          result[resIndex++] = value;\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a new array concatenating `array` with any additional arrays\r\n     * and/or values.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Array\r\n     * @param {Array} array The array to concatenate.\r\n     * @param {...*} [values] The values to concatenate.\r\n     * @returns {Array} Returns the new concatenated array.\r\n     * @example\r\n     *\r\n     * var array = [1];\r\n     * var other = _.concat(array, 2, [3], [[4]]);\r\n     *\r\n     * console.log(other);\r\n     * // => [1, 2, 3, [4]]\r\n     *\r\n     * console.log(array);\r\n     * // => [1]\r\n     */\r\n    function concat() {\r\n      var length = arguments.length;\r\n      if (!length) {\r\n        return [];\r\n      }\r\n      var args = Array(length - 1),\r\n          array = arguments[0],\r\n          index = length;\r\n\r\n      while (index--) {\r\n        args[index - 1] = arguments[index];\r\n      }\r\n      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));\r\n    }\r\n\r\n    /**\r\n     * Creates an array of `array` values not included in the other given arrays\r\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\r\n     * for equality comparisons. The order and references of result values are\r\n     * determined by the first array.\r\n     *\r\n     * **Note:** Unlike `_.pullAll`, this method returns a new array.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Array\r\n     * @param {Array} array The array to inspect.\r\n     * @param {...Array} [values] The values to exclude.\r\n     * @returns {Array} Returns the new array of filtered values.\r\n     * @see _.without, _.xor\r\n     * @example\r\n     *\r\n     * _.difference([2, 1], [2, 3]);\r\n     * // => [1]\r\n     */\r\n    var difference = baseRest(function(array, values) {\r\n      return isArrayLikeObject(array)\r\n        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))\r\n        : [];\r\n    });\r\n\r\n    /**\r\n     * This method is like `_.difference` except that it accepts `iteratee` which\r\n     * is invoked for each element of `array` and `values` to generate the criterion\r\n     * by which they're compared. The order and references of result values are\r\n     * determined by the first array. The iteratee is invoked with one argument:\r\n     * (value).\r\n     *\r\n     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Array\r\n     * @param {Array} array The array to inspect.\r\n     * @param {...Array} [values] The values to exclude.\r\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\r\n     * @returns {Array} Returns the new array of filtered values.\r\n     * @example\r\n     *\r\n     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);\r\n     * // => [1.2]\r\n     *\r\n     * // The `_.property` iteratee shorthand.\r\n     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');\r\n     * // => [{ 'x': 2 }]\r\n     */\r\n    var differenceBy = baseRest(function(array, values) {\r\n      var iteratee = last(values);\r\n      if (isArrayLikeObject(iteratee)) {\r\n        iteratee = undefined;\r\n      }\r\n      return isArrayLikeObject(array)\r\n        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))\r\n        : [];\r\n    });\r\n\r\n    /**\r\n     * This method is like `_.difference` except that it accepts `comparator`\r\n     * which is invoked to compare elements of `array` to `values`. The order and\r\n     * references of result values are determined by the first array. The comparator\r\n     * is invoked with two arguments: (arrVal, othVal).\r\n     *\r\n     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Array\r\n     * @param {Array} array The array to inspect.\r\n     * @param {...Array} [values] The values to exclude.\r\n     * @param {Function} [comparator] The comparator invoked per element.\r\n     * @returns {Array} Returns the new array of filtered values.\r\n     * @example\r\n     *\r\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\r\n     *\r\n     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);\r\n     * // => [{ 'x': 2, 'y': 1 }]\r\n     */\r\n    var differenceWith = baseRest(function(array, values) {\r\n      var comparator = last(values);\r\n      if (isArrayLikeObject(comparator)) {\r\n        comparator = undefined;\r\n      }\r\n      return isArrayLikeObject(array)\r\n        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)\r\n        : [];\r\n    });\r\n\r\n    /**\r\n     * Creates a slice of `array` with `n` elements dropped from the beginning.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.5.0\r\n     * @category Array\r\n     * @param {Array} array The array to query.\r\n     * @param {number} [n=1] The number of elements to drop.\r\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\r\n     * @returns {Array} Returns the slice of `array`.\r\n     * @example\r\n     *\r\n     * _.drop([1, 2, 3]);\r\n     * // => [2, 3]\r\n     *\r\n     * _.drop([1, 2, 3], 2);\r\n     * // => [3]\r\n     *\r\n     * _.drop([1, 2, 3], 5);\r\n     * // => []\r\n     *\r\n     * _.drop([1, 2, 3], 0);\r\n     * // => [1, 2, 3]\r\n     */\r\n    function drop(array, n, guard) {\r\n      var length = array == null ? 0 : array.length;\r\n      if (!length) {\r\n        return [];\r\n      }\r\n      n = (guard || n === undefined) ? 1 : toInteger(n);\r\n      return baseSlice(array, n < 0 ? 0 : n, length);\r\n    }\r\n\r\n    /**\r\n     * Creates a slice of `array` with `n` elements dropped from the end.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.0.0\r\n     * @category Array\r\n     * @param {Array} array The array to query.\r\n     * @param {number} [n=1] The number of elements to drop.\r\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\r\n     * @returns {Array} Returns the slice of `array`.\r\n     * @example\r\n     *\r\n     * _.dropRight([1, 2, 3]);\r\n     * // => [1, 2]\r\n     *\r\n     * _.dropRight([1, 2, 3], 2);\r\n     * // => [1]\r\n     *\r\n     * _.dropRight([1, 2, 3], 5);\r\n     * // => []\r\n     *\r\n     * _.dropRight([1, 2, 3], 0);\r\n     * // => [1, 2, 3]\r\n     */\r\n    function dropRight(array, n, guard) {\r\n      var length = array == null ? 0 : array.length;\r\n      if (!length) {\r\n        return [];\r\n      }\r\n      n = (guard || n === undefined) ? 1 : toInteger(n);\r\n      n = length - n;\r\n      return baseSlice(array, 0, n < 0 ? 0 : n);\r\n    }\r\n\r\n    /**\r\n     * Creates a slice of `array` excluding elements dropped from the end.\r\n     * Elements are dropped until `predicate` returns falsey. The predicate is\r\n     * invoked with three arguments: (value, index, array).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.0.0\r\n     * @category Array\r\n     * @param {Array} array The array to query.\r\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\r\n     * @returns {Array} Returns the slice of `array`.\r\n     * @example\r\n     *\r\n     * var users = [\r\n     *   { 'user': 'barney',  'active': true },\r\n     *   { 'user': 'fred',    'active': false },\r\n     *   { 'user': 'pebbles', 'active': false }\r\n     * ];\r\n     *\r\n     * _.dropRightWhile(users, function(o) { return !o.active; });\r\n     * // => objects for ['barney']\r\n     *\r\n     * // The `_.matches` iteratee shorthand.\r\n     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });\r\n     * // => objects for ['barney', 'fred']\r\n     *\r\n     * // The `_.matchesProperty` iteratee shorthand.\r\n     * _.dropRightWhile(users, ['active', false]);\r\n     * // => objects for ['barney']\r\n     *\r\n     * // The `_.property` iteratee shorthand.\r\n     * _.dropRightWhile(users, 'active');\r\n     * // => objects for ['barney', 'fred', 'pebbles']\r\n     */\r\n    function dropRightWhile(array, predicate) {\r\n      return (array && array.length)\r\n        ? baseWhile(array, getIteratee(predicate, 3), true, true)\r\n        : [];\r\n    }\r\n\r\n    /**\r\n     * Creates a slice of `array` excluding elements dropped from the beginning.\r\n     * Elements are dropped until `predicate` returns falsey. The predicate is\r\n     * invoked with three arguments: (value, index, array).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.0.0\r\n     * @category Array\r\n     * @param {Array} array The array to query.\r\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\r\n     * @returns {Array} Returns the slice of `array`.\r\n     * @example\r\n     *\r\n     * var users = [\r\n     *   { 'user': 'barney',  'active': false },\r\n     *   { 'user': 'fred',    'active': false },\r\n     *   { 'user': 'pebbles', 'active': true }\r\n     * ];\r\n     *\r\n     * _.dropWhile(users, function(o) { return !o.active; });\r\n     * // => objects for ['pebbles']\r\n     *\r\n     * // The `_.matches` iteratee shorthand.\r\n     * _.dropWhile(users, { 'user': 'barney', 'active': false });\r\n     * // => objects for ['fred', 'pebbles']\r\n     *\r\n     * // The `_.matchesProperty` iteratee shorthand.\r\n     * _.dropWhile(users, ['active', false]);\r\n     * // => objects for ['pebbles']\r\n     *\r\n     * // The `_.property` iteratee shorthand.\r\n     * _.dropWhile(users, 'active');\r\n     * // => objects for ['barney', 'fred', 'pebbles']\r\n     */\r\n    function dropWhile(array, predicate) {\r\n      return (array && array.length)\r\n        ? baseWhile(array, getIteratee(predicate, 3), true)\r\n        : [];\r\n    }\r\n\r\n    /**\r\n     * Fills elements of `array` with `value` from `start` up to, but not\r\n     * including, `end`.\r\n     *\r\n     * **Note:** This method mutates `array`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.2.0\r\n     * @category Array\r\n     * @param {Array} array The array to fill.\r\n     * @param {*} value The value to fill `array` with.\r\n     * @param {number} [start=0] The start position.\r\n     * @param {number} [end=array.length] The end position.\r\n     * @returns {Array} Returns `array`.\r\n     * @example\r\n     *\r\n     * var array = [1, 2, 3];\r\n     *\r\n     * _.fill(array, 'a');\r\n     * console.log(array);\r\n     * // => ['a', 'a', 'a']\r\n     *\r\n     * _.fill(Array(3), 2);\r\n     * // => [2, 2, 2]\r\n     *\r\n     * _.fill([4, 6, 8, 10], '*', 1, 3);\r\n     * // => [4, '*', '*', 10]\r\n     */\r\n    function fill(array, value, start, end) {\r\n      var length = array == null ? 0 : array.length;\r\n      if (!length) {\r\n        return [];\r\n      }\r\n      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {\r\n        start = 0;\r\n        end = length;\r\n      }\r\n      return baseFill(array, value, start, end);\r\n    }\r\n\r\n    /**\r\n     * This method is like `_.find` except that it returns the index of the first\r\n     * element `predicate` returns truthy for instead of the element itself.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 1.1.0\r\n     * @category Array\r\n     * @param {Array} array The array to inspect.\r\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\r\n     * @param {number} [fromIndex=0] The index to search from.\r\n     * @returns {number} Returns the index of the found element, else `-1`.\r\n     * @example\r\n     *\r\n     * var users = [\r\n     *   { 'user': 'barney',  'active': false },\r\n     *   { 'user': 'fred',    'active': false },\r\n     *   { 'user': 'pebbles', 'active': true }\r\n     * ];\r\n     *\r\n     * _.findIndex(users, function(o) { return o.user == 'barney'; });\r\n     * // => 0\r\n     *\r\n     * // The `_.matches` iteratee shorthand.\r\n     * _.findIndex(users, { 'user': 'fred', 'active': false });\r\n     * // => 1\r\n     *\r\n     * // The `_.matchesProperty` iteratee shorthand.\r\n     * _.findIndex(users, ['active', false]);\r\n     * // => 0\r\n     *\r\n     * // The `_.property` iteratee shorthand.\r\n     * _.findIndex(users, 'active');\r\n     * // => 2\r\n     */\r\n    function findIndex(array, predicate, fromIndex) {\r\n      var length = array == null ? 0 : array.length;\r\n      if (!length) {\r\n        return -1;\r\n      }\r\n      var index = fromIndex == null ? 0 : toInteger(fromIndex);\r\n      if (index < 0) {\r\n        index = nativeMax(length + index, 0);\r\n      }\r\n      return baseFindIndex(array, getIteratee(predicate, 3), index);\r\n    }\r\n\r\n    /**\r\n     * This method is like `_.findIndex` except that it iterates over elements\r\n     * of `collection` from right to left.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 2.0.0\r\n     * @category Array\r\n     * @param {Array} array The array to inspect.\r\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\r\n     * @param {number} [fromIndex=array.length-1] The index to search from.\r\n     * @returns {number} Returns the index of the found element, else `-1`.\r\n     * @example\r\n     *\r\n     * var users = [\r\n     *   { 'user': 'barney',  'active': true },\r\n     *   { 'user': 'fred',    'active': false },\r\n     *   { 'user': 'pebbles', 'active': false }\r\n     * ];\r\n     *\r\n     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });\r\n     * // => 2\r\n     *\r\n     * // The `_.matches` iteratee shorthand.\r\n     * _.findLastIndex(users, { 'user': 'barney', 'active': true });\r\n     * // => 0\r\n     *\r\n     * // The `_.matchesProperty` iteratee shorthand.\r\n     * _.findLastIndex(users, ['active', false]);\r\n     * // => 2\r\n     *\r\n     * // The `_.property` iteratee shorthand.\r\n     * _.findLastIndex(users, 'active');\r\n     * // => 0\r\n     */\r\n    function findLastIndex(array, predicate, fromIndex) {\r\n      var length = array == null ? 0 : array.length;\r\n      if (!length) {\r\n        return -1;\r\n      }\r\n      var index = length - 1;\r\n      if (fromIndex !== undefined) {\r\n        index = toInteger(fromIndex);\r\n        index = fromIndex < 0\r\n          ? nativeMax(length + index, 0)\r\n          : nativeMin(index, length - 1);\r\n      }\r\n      return baseFindIndex(array, getIteratee(predicate, 3), index, true);\r\n    }\r\n\r\n    /**\r\n     * Flattens `array` a single level deep.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Array\r\n     * @param {Array} array The array to flatten.\r\n     * @returns {Array} Returns the new flattened array.\r\n     * @example\r\n     *\r\n     * _.flatten([1, [2, [3, [4]], 5]]);\r\n     * // => [1, 2, [3, [4]], 5]\r\n     */\r\n    function flatten(array) {\r\n      var length = array == null ? 0 : array.length;\r\n      return length ? baseFlatten(array, 1) : [];\r\n    }\r\n\r\n    /**\r\n     * Recursively flattens `array`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.0.0\r\n     * @category Array\r\n     * @param {Array} array The array to flatten.\r\n     * @returns {Array} Returns the new flattened array.\r\n     * @example\r\n     *\r\n     * _.flattenDeep([1, [2, [3, [4]], 5]]);\r\n     * // => [1, 2, 3, 4, 5]\r\n     */\r\n    function flattenDeep(array) {\r\n      var length = array == null ? 0 : array.length;\r\n      return length ? baseFlatten(array, INFINITY) : [];\r\n    }\r\n\r\n    /**\r\n     * Recursively flatten `array` up to `depth` times.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.4.0\r\n     * @category Array\r\n     * @param {Array} array The array to flatten.\r\n     * @param {number} [depth=1] The maximum recursion depth.\r\n     * @returns {Array} Returns the new flattened array.\r\n     * @example\r\n     *\r\n     * var array = [1, [2, [3, [4]], 5]];\r\n     *\r\n     * _.flattenDepth(array, 1);\r\n     * // => [1, 2, [3, [4]], 5]\r\n     *\r\n     * _.flattenDepth(array, 2);\r\n     * // => [1, 2, 3, [4], 5]\r\n     */\r\n    function flattenDepth(array, depth) {\r\n      var length = array == null ? 0 : array.length;\r\n      if (!length) {\r\n        return [];\r\n      }\r\n      depth = depth === undefined ? 1 : toInteger(depth);\r\n      return baseFlatten(array, depth);\r\n    }\r\n\r\n    /**\r\n     * The inverse of `_.toPairs`; this method returns an object composed\r\n     * from key-value `pairs`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Array\r\n     * @param {Array} pairs The key-value pairs.\r\n     * @returns {Object} Returns the new object.\r\n     * @example\r\n     *\r\n     * _.fromPairs([['a', 1], ['b', 2]]);\r\n     * // => { 'a': 1, 'b': 2 }\r\n     */\r\n    function fromPairs(pairs) {\r\n      var index = -1,\r\n          length = pairs == null ? 0 : pairs.length,\r\n          result = {};\r\n\r\n      while (++index < length) {\r\n        var pair = pairs[index];\r\n        result[pair[0]] = pair[1];\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Gets the first element of `array`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @alias first\r\n     * @category Array\r\n     * @param {Array} array The array to query.\r\n     * @returns {*} Returns the first element of `array`.\r\n     * @example\r\n     *\r\n     * _.head([1, 2, 3]);\r\n     * // => 1\r\n     *\r\n     * _.head([]);\r\n     * // => undefined\r\n     */\r\n    function head(array) {\r\n      return (array && array.length) ? array[0] : undefined;\r\n    }\r\n\r\n    /**\r\n     * Gets the index at which the first occurrence of `value` is found in `array`\r\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\r\n     * for equality comparisons. If `fromIndex` is negative, it's used as the\r\n     * offset from the end of `array`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Array\r\n     * @param {Array} array The array to inspect.\r\n     * @param {*} value The value to search for.\r\n     * @param {number} [fromIndex=0] The index to search from.\r\n     * @returns {number} Returns the index of the matched value, else `-1`.\r\n     * @example\r\n     *\r\n     * _.indexOf([1, 2, 1, 2], 2);\r\n     * // => 1\r\n     *\r\n     * // Search from the `fromIndex`.\r\n     * _.indexOf([1, 2, 1, 2], 2, 2);\r\n     * // => 3\r\n     */\r\n    function indexOf(array, value, fromIndex) {\r\n      var length = array == null ? 0 : array.length;\r\n      if (!length) {\r\n        return -1;\r\n      }\r\n      var index = fromIndex == null ? 0 : toInteger(fromIndex);\r\n      if (index < 0) {\r\n        index = nativeMax(length + index, 0);\r\n      }\r\n      return baseIndexOf(array, value, index);\r\n    }\r\n\r\n    /**\r\n     * Gets all but the last element of `array`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Array\r\n     * @param {Array} array The array to query.\r\n     * @returns {Array} Returns the slice of `array`.\r\n     * @example\r\n     *\r\n     * _.initial([1, 2, 3]);\r\n     * // => [1, 2]\r\n     */\r\n    function initial(array) {\r\n      var length = array == null ? 0 : array.length;\r\n      return length ? baseSlice(array, 0, -1) : [];\r\n    }\r\n\r\n    /**\r\n     * Creates an array of unique values that are included in all given arrays\r\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\r\n     * for equality comparisons. The order and references of result values are\r\n     * determined by the first array.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Array\r\n     * @param {...Array} [arrays] The arrays to inspect.\r\n     * @returns {Array} Returns the new array of intersecting values.\r\n     * @example\r\n     *\r\n     * _.intersection([2, 1], [2, 3]);\r\n     * // => [2]\r\n     */\r\n    var intersection = baseRest(function(arrays) {\r\n      var mapped = arrayMap(arrays, castArrayLikeObject);\r\n      return (mapped.length && mapped[0] === arrays[0])\r\n        ? baseIntersection(mapped)\r\n        : [];\r\n    });\r\n\r\n    /**\r\n     * This method is like `_.intersection` except that it accepts `iteratee`\r\n     * which is invoked for each element of each `arrays` to generate the criterion\r\n     * by which they're compared. The order and references of result values are\r\n     * determined by the first array. The iteratee is invoked with one argument:\r\n     * (value).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Array\r\n     * @param {...Array} [arrays] The arrays to inspect.\r\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\r\n     * @returns {Array} Returns the new array of intersecting values.\r\n     * @example\r\n     *\r\n     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);\r\n     * // => [2.1]\r\n     *\r\n     * // The `_.property` iteratee shorthand.\r\n     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\r\n     * // => [{ 'x': 1 }]\r\n     */\r\n    var intersectionBy = baseRest(function(arrays) {\r\n      var iteratee = last(arrays),\r\n          mapped = arrayMap(arrays, castArrayLikeObject);\r\n\r\n      if (iteratee === last(mapped)) {\r\n        iteratee = undefined;\r\n      } else {\r\n        mapped.pop();\r\n      }\r\n      return (mapped.length && mapped[0] === arrays[0])\r\n        ? baseIntersection(mapped, getIteratee(iteratee, 2))\r\n        : [];\r\n    });\r\n\r\n    /**\r\n     * This method is like `_.intersection` except that it accepts `comparator`\r\n     * which is invoked to compare elements of `arrays`. The order and references\r\n     * of result values are determined by the first array. The comparator is\r\n     * invoked with two arguments: (arrVal, othVal).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Array\r\n     * @param {...Array} [arrays] The arrays to inspect.\r\n     * @param {Function} [comparator] The comparator invoked per element.\r\n     * @returns {Array} Returns the new array of intersecting values.\r\n     * @example\r\n     *\r\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\r\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\r\n     *\r\n     * _.intersectionWith(objects, others, _.isEqual);\r\n     * // => [{ 'x': 1, 'y': 2 }]\r\n     */\r\n    var intersectionWith = baseRest(function(arrays) {\r\n      var comparator = last(arrays),\r\n          mapped = arrayMap(arrays, castArrayLikeObject);\r\n\r\n      comparator = typeof comparator == 'function' ? comparator : undefined;\r\n      if (comparator) {\r\n        mapped.pop();\r\n      }\r\n      return (mapped.length && mapped[0] === arrays[0])\r\n        ? baseIntersection(mapped, undefined, comparator)\r\n        : [];\r\n    });\r\n\r\n    /**\r\n     * Converts all elements in `array` into a string separated by `separator`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Array\r\n     * @param {Array} array The array to convert.\r\n     * @param {string} [separator=','] The element separator.\r\n     * @returns {string} Returns the joined string.\r\n     * @example\r\n     *\r\n     * _.join(['a', 'b', 'c'], '~');\r\n     * // => 'a~b~c'\r\n     */\r\n    function join(array, separator) {\r\n      return array == null ? '' : nativeJoin.call(array, separator);\r\n    }\r\n\r\n    /**\r\n     * Gets the last element of `array`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Array\r\n     * @param {Array} array The array to query.\r\n     * @returns {*} Returns the last element of `array`.\r\n     * @example\r\n     *\r\n     * _.last([1, 2, 3]);\r\n     * // => 3\r\n     */\r\n    function last(array) {\r\n      var length = array == null ? 0 : array.length;\r\n      return length ? array[length - 1] : undefined;\r\n    }\r\n\r\n    /**\r\n     * This method is like `_.indexOf` except that it iterates over elements of\r\n     * `array` from right to left.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Array\r\n     * @param {Array} array The array to inspect.\r\n     * @param {*} value The value to search for.\r\n     * @param {number} [fromIndex=array.length-1] The index to search from.\r\n     * @returns {number} Returns the index of the matched value, else `-1`.\r\n     * @example\r\n     *\r\n     * _.lastIndexOf([1, 2, 1, 2], 2);\r\n     * // => 3\r\n     *\r\n     * // Search from the `fromIndex`.\r\n     * _.lastIndexOf([1, 2, 1, 2], 2, 2);\r\n     * // => 1\r\n     */\r\n    function lastIndexOf(array, value, fromIndex) {\r\n      var length = array == null ? 0 : array.length;\r\n      if (!length) {\r\n        return -1;\r\n      }\r\n      var index = length;\r\n      if (fromIndex !== undefined) {\r\n        index = toInteger(fromIndex);\r\n        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);\r\n      }\r\n      return value === value\r\n        ? strictLastIndexOf(array, value, index)\r\n        : baseFindIndex(array, baseIsNaN, index, true);\r\n    }\r\n\r\n    /**\r\n     * Gets the element at index `n` of `array`. If `n` is negative, the nth\r\n     * element from the end is returned.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.11.0\r\n     * @category Array\r\n     * @param {Array} array The array to query.\r\n     * @param {number} [n=0] The index of the element to return.\r\n     * @returns {*} Returns the nth element of `array`.\r\n     * @example\r\n     *\r\n     * var array = ['a', 'b', 'c', 'd'];\r\n     *\r\n     * _.nth(array, 1);\r\n     * // => 'b'\r\n     *\r\n     * _.nth(array, -2);\r\n     * // => 'c';\r\n     */\r\n    function nth(array, n) {\r\n      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;\r\n    }\r\n\r\n    /**\r\n     * Removes all given values from `array` using\r\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\r\n     * for equality comparisons.\r\n     *\r\n     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`\r\n     * to remove elements from an array by predicate.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 2.0.0\r\n     * @category Array\r\n     * @param {Array} array The array to modify.\r\n     * @param {...*} [values] The values to remove.\r\n     * @returns {Array} Returns `array`.\r\n     * @example\r\n     *\r\n     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];\r\n     *\r\n     * _.pull(array, 'a', 'c');\r\n     * console.log(array);\r\n     * // => ['b', 'b']\r\n     */\r\n    var pull = baseRest(pullAll);\r\n\r\n    /**\r\n     * This method is like `_.pull` except that it accepts an array of values to remove.\r\n     *\r\n     * **Note:** Unlike `_.difference`, this method mutates `array`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Array\r\n     * @param {Array} array The array to modify.\r\n     * @param {Array} values The values to remove.\r\n     * @returns {Array} Returns `array`.\r\n     * @example\r\n     *\r\n     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];\r\n     *\r\n     * _.pullAll(array, ['a', 'c']);\r\n     * console.log(array);\r\n     * // => ['b', 'b']\r\n     */\r\n    function pullAll(array, values) {\r\n      return (array && array.length && values && values.length)\r\n        ? basePullAll(array, values)\r\n        : array;\r\n    }\r\n\r\n    /**\r\n     * This method is like `_.pullAll` except that it accepts `iteratee` which is\r\n     * invoked for each element of `array` and `values` to generate the criterion\r\n     * by which they're compared. The iteratee is invoked with one argument: (value).\r\n     *\r\n     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Array\r\n     * @param {Array} array The array to modify.\r\n     * @param {Array} values The values to remove.\r\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\r\n     * @returns {Array} Returns `array`.\r\n     * @example\r\n     *\r\n     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];\r\n     *\r\n     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');\r\n     * console.log(array);\r\n     * // => [{ 'x': 2 }]\r\n     */\r\n    function pullAllBy(array, values, iteratee) {\r\n      return (array && array.length && values && values.length)\r\n        ? basePullAll(array, values, getIteratee(iteratee, 2))\r\n        : array;\r\n    }\r\n\r\n    /**\r\n     * This method is like `_.pullAll` except that it accepts `comparator` which\r\n     * is invoked to compare elements of `array` to `values`. The comparator is\r\n     * invoked with two arguments: (arrVal, othVal).\r\n     *\r\n     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.6.0\r\n     * @category Array\r\n     * @param {Array} array The array to modify.\r\n     * @param {Array} values The values to remove.\r\n     * @param {Function} [comparator] The comparator invoked per element.\r\n     * @returns {Array} Returns `array`.\r\n     * @example\r\n     *\r\n     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];\r\n     *\r\n     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);\r\n     * console.log(array);\r\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]\r\n     */\r\n    function pullAllWith(array, values, comparator) {\r\n      return (array && array.length && values && values.length)\r\n        ? basePullAll(array, values, undefined, comparator)\r\n        : array;\r\n    }\r\n\r\n    /**\r\n     * Removes elements from `array` corresponding to `indexes` and returns an\r\n     * array of removed elements.\r\n     *\r\n     * **Note:** Unlike `_.at`, this method mutates `array`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.0.0\r\n     * @category Array\r\n     * @param {Array} array The array to modify.\r\n     * @param {...(number|number[])} [indexes] The indexes of elements to remove.\r\n     * @returns {Array} Returns the new array of removed elements.\r\n     * @example\r\n     *\r\n     * var array = ['a', 'b', 'c', 'd'];\r\n     * var pulled = _.pullAt(array, [1, 3]);\r\n     *\r\n     * console.log(array);\r\n     * // => ['a', 'c']\r\n     *\r\n     * console.log(pulled);\r\n     * // => ['b', 'd']\r\n     */\r\n    var pullAt = flatRest(function(array, indexes) {\r\n      var length = array == null ? 0 : array.length,\r\n          result = baseAt(array, indexes);\r\n\r\n      basePullAt(array, arrayMap(indexes, function(index) {\r\n        return isIndex(index, length) ? +index : index;\r\n      }).sort(compareAscending));\r\n\r\n      return result;\r\n    });\r\n\r\n    /**\r\n     * Removes all elements from `array` that `predicate` returns truthy for\r\n     * and returns an array of the removed elements. The predicate is invoked\r\n     * with three arguments: (value, index, array).\r\n     *\r\n     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`\r\n     * to pull elements from an array by value.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 2.0.0\r\n     * @category Array\r\n     * @param {Array} array The array to modify.\r\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\r\n     * @returns {Array} Returns the new array of removed elements.\r\n     * @example\r\n     *\r\n     * var array = [1, 2, 3, 4];\r\n     * var evens = _.remove(array, function(n) {\r\n     *   return n % 2 == 0;\r\n     * });\r\n     *\r\n     * console.log(array);\r\n     * // => [1, 3]\r\n     *\r\n     * console.log(evens);\r\n     * // => [2, 4]\r\n     */\r\n    function remove(array, predicate) {\r\n      var result = [];\r\n      if (!(array && array.length)) {\r\n        return result;\r\n      }\r\n      var index = -1,\r\n          indexes = [],\r\n          length = array.length;\r\n\r\n      predicate = getIteratee(predicate, 3);\r\n      while (++index < length) {\r\n        var value = array[index];\r\n        if (predicate(value, index, array)) {\r\n          result.push(value);\r\n          indexes.push(index);\r\n        }\r\n      }\r\n      basePullAt(array, indexes);\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Reverses `array` so that the first element becomes the last, the second\r\n     * element becomes the second to last, and so on.\r\n     *\r\n     * **Note:** This method mutates `array` and is based on\r\n     * [`Array#reverse`](https://mdn.io/Array/reverse).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Array\r\n     * @param {Array} array The array to modify.\r\n     * @returns {Array} Returns `array`.\r\n     * @example\r\n     *\r\n     * var array = [1, 2, 3];\r\n     *\r\n     * _.reverse(array);\r\n     * // => [3, 2, 1]\r\n     *\r\n     * console.log(array);\r\n     * // => [3, 2, 1]\r\n     */\r\n    function reverse(array) {\r\n      return array == null ? array : nativeReverse.call(array);\r\n    }\r\n\r\n    /**\r\n     * Creates a slice of `array` from `start` up to, but not including, `end`.\r\n     *\r\n     * **Note:** This method is used instead of\r\n     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are\r\n     * returned.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.0.0\r\n     * @category Array\r\n     * @param {Array} array The array to slice.\r\n     * @param {number} [start=0] The start position.\r\n     * @param {number} [end=array.length] The end position.\r\n     * @returns {Array} Returns the slice of `array`.\r\n     */\r\n    function slice(array, start, end) {\r\n      var length = array == null ? 0 : array.length;\r\n      if (!length) {\r\n        return [];\r\n      }\r\n      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {\r\n        start = 0;\r\n        end = length;\r\n      }\r\n      else {\r\n        start = start == null ? 0 : toInteger(start);\r\n        end = end === undefined ? length : toInteger(end);\r\n      }\r\n      return baseSlice(array, start, end);\r\n    }\r\n\r\n    /**\r\n     * Uses a binary search to determine the lowest index at which `value`\r\n     * should be inserted into `array` in order to maintain its sort order.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Array\r\n     * @param {Array} array The sorted array to inspect.\r\n     * @param {*} value The value to evaluate.\r\n     * @returns {number} Returns the index at which `value` should be inserted\r\n     *  into `array`.\r\n     * @example\r\n     *\r\n     * _.sortedIndex([30, 50], 40);\r\n     * // => 1\r\n     */\r\n    function sortedIndex(array, value) {\r\n      return baseSortedIndex(array, value);\r\n    }\r\n\r\n    /**\r\n     * This method is like `_.sortedIndex` except that it accepts `iteratee`\r\n     * which is invoked for `value` and each element of `array` to compute their\r\n     * sort ranking. The iteratee is invoked with one argument: (value).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Array\r\n     * @param {Array} array The sorted array to inspect.\r\n     * @param {*} value The value to evaluate.\r\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\r\n     * @returns {number} Returns the index at which `value` should be inserted\r\n     *  into `array`.\r\n     * @example\r\n     *\r\n     * var objects = [{ 'x': 4 }, { 'x': 5 }];\r\n     *\r\n     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });\r\n     * // => 0\r\n     *\r\n     * // The `_.property` iteratee shorthand.\r\n     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');\r\n     * // => 0\r\n     */\r\n    function sortedIndexBy(array, value, iteratee) {\r\n      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));\r\n    }\r\n\r\n    /**\r\n     * This method is like `_.indexOf` except that it performs a binary\r\n     * search on a sorted `array`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Array\r\n     * @param {Array} array The array to inspect.\r\n     * @param {*} value The value to search for.\r\n     * @returns {number} Returns the index of the matched value, else `-1`.\r\n     * @example\r\n     *\r\n     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);\r\n     * // => 1\r\n     */\r\n    function sortedIndexOf(array, value) {\r\n      var length = array == null ? 0 : array.length;\r\n      if (length) {\r\n        var index = baseSortedIndex(array, value);\r\n        if (index < length && eq(array[index], value)) {\r\n          return index;\r\n        }\r\n      }\r\n      return -1;\r\n    }\r\n\r\n    /**\r\n     * This method is like `_.sortedIndex` except that it returns the highest\r\n     * index at which `value` should be inserted into `array` in order to\r\n     * maintain its sort order.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.0.0\r\n     * @category Array\r\n     * @param {Array} array The sorted array to inspect.\r\n     * @param {*} value The value to evaluate.\r\n     * @returns {number} Returns the index at which `value` should be inserted\r\n     *  into `array`.\r\n     * @example\r\n     *\r\n     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);\r\n     * // => 4\r\n     */\r\n    function sortedLastIndex(array, value) {\r\n      return baseSortedIndex(array, value, true);\r\n    }\r\n\r\n    /**\r\n     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`\r\n     * which is invoked for `value` and each element of `array` to compute their\r\n     * sort ranking. The iteratee is invoked with one argument: (value).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Array\r\n     * @param {Array} array The sorted array to inspect.\r\n     * @param {*} value The value to evaluate.\r\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\r\n     * @returns {number} Returns the index at which `value` should be inserted\r\n     *  into `array`.\r\n     * @example\r\n     *\r\n     * var objects = [{ 'x': 4 }, { 'x': 5 }];\r\n     *\r\n     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });\r\n     * // => 1\r\n     *\r\n     * // The `_.property` iteratee shorthand.\r\n     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');\r\n     * // => 1\r\n     */\r\n    function sortedLastIndexBy(array, value, iteratee) {\r\n      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);\r\n    }\r\n\r\n    /**\r\n     * This method is like `_.lastIndexOf` except that it performs a binary\r\n     * search on a sorted `array`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Array\r\n     * @param {Array} array The array to inspect.\r\n     * @param {*} value The value to search for.\r\n     * @returns {number} Returns the index of the matched value, else `-1`.\r\n     * @example\r\n     *\r\n     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);\r\n     * // => 3\r\n     */\r\n    function sortedLastIndexOf(array, value) {\r\n      var length = array == null ? 0 : array.length;\r\n      if (length) {\r\n        var index = baseSortedIndex(array, value, true) - 1;\r\n        if (eq(array[index], value)) {\r\n          return index;\r\n        }\r\n      }\r\n      return -1;\r\n    }\r\n\r\n    /**\r\n     * This method is like `_.uniq` except that it's designed and optimized\r\n     * for sorted arrays.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Array\r\n     * @param {Array} array The array to inspect.\r\n     * @returns {Array} Returns the new duplicate free array.\r\n     * @example\r\n     *\r\n     * _.sortedUniq([1, 1, 2]);\r\n     * // => [1, 2]\r\n     */\r\n    function sortedUniq(array) {\r\n      return (array && array.length)\r\n        ? baseSortedUniq(array)\r\n        : [];\r\n    }\r\n\r\n    /**\r\n     * This method is like `_.uniqBy` except that it's designed and optimized\r\n     * for sorted arrays.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Array\r\n     * @param {Array} array The array to inspect.\r\n     * @param {Function} [iteratee] The iteratee invoked per element.\r\n     * @returns {Array} Returns the new duplicate free array.\r\n     * @example\r\n     *\r\n     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);\r\n     * // => [1.1, 2.3]\r\n     */\r\n    function sortedUniqBy(array, iteratee) {\r\n      return (array && array.length)\r\n        ? baseSortedUniq(array, getIteratee(iteratee, 2))\r\n        : [];\r\n    }\r\n\r\n    /**\r\n     * Gets all but the first element of `array`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Array\r\n     * @param {Array} array The array to query.\r\n     * @returns {Array} Returns the slice of `array`.\r\n     * @example\r\n     *\r\n     * _.tail([1, 2, 3]);\r\n     * // => [2, 3]\r\n     */\r\n    function tail(array) {\r\n      var length = array == null ? 0 : array.length;\r\n      return length ? baseSlice(array, 1, length) : [];\r\n    }\r\n\r\n    /**\r\n     * Creates a slice of `array` with `n` elements taken from the beginning.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Array\r\n     * @param {Array} array The array to query.\r\n     * @param {number} [n=1] The number of elements to take.\r\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\r\n     * @returns {Array} Returns the slice of `array`.\r\n     * @example\r\n     *\r\n     * _.take([1, 2, 3]);\r\n     * // => [1]\r\n     *\r\n     * _.take([1, 2, 3], 2);\r\n     * // => [1, 2]\r\n     *\r\n     * _.take([1, 2, 3], 5);\r\n     * // => [1, 2, 3]\r\n     *\r\n     * _.take([1, 2, 3], 0);\r\n     * // => []\r\n     */\r\n    function take(array, n, guard) {\r\n      if (!(array && array.length)) {\r\n        return [];\r\n      }\r\n      n = (guard || n === undefined) ? 1 : toInteger(n);\r\n      return baseSlice(array, 0, n < 0 ? 0 : n);\r\n    }\r\n\r\n    /**\r\n     * Creates a slice of `array` with `n` elements taken from the end.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.0.0\r\n     * @category Array\r\n     * @param {Array} array The array to query.\r\n     * @param {number} [n=1] The number of elements to take.\r\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\r\n     * @returns {Array} Returns the slice of `array`.\r\n     * @example\r\n     *\r\n     * _.takeRight([1, 2, 3]);\r\n     * // => [3]\r\n     *\r\n     * _.takeRight([1, 2, 3], 2);\r\n     * // => [2, 3]\r\n     *\r\n     * _.takeRight([1, 2, 3], 5);\r\n     * // => [1, 2, 3]\r\n     *\r\n     * _.takeRight([1, 2, 3], 0);\r\n     * // => []\r\n     */\r\n    function takeRight(array, n, guard) {\r\n      var length = array == null ? 0 : array.length;\r\n      if (!length) {\r\n        return [];\r\n      }\r\n      n = (guard || n === undefined) ? 1 : toInteger(n);\r\n      n = length - n;\r\n      return baseSlice(array, n < 0 ? 0 : n, length);\r\n    }\r\n\r\n    /**\r\n     * Creates a slice of `array` with elements taken from the end. Elements are\r\n     * taken until `predicate` returns falsey. The predicate is invoked with\r\n     * three arguments: (value, index, array).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.0.0\r\n     * @category Array\r\n     * @param {Array} array The array to query.\r\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\r\n     * @returns {Array} Returns the slice of `array`.\r\n     * @example\r\n     *\r\n     * var users = [\r\n     *   { 'user': 'barney',  'active': true },\r\n     *   { 'user': 'fred',    'active': false },\r\n     *   { 'user': 'pebbles', 'active': false }\r\n     * ];\r\n     *\r\n     * _.takeRightWhile(users, function(o) { return !o.active; });\r\n     * // => objects for ['fred', 'pebbles']\r\n     *\r\n     * // The `_.matches` iteratee shorthand.\r\n     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });\r\n     * // => objects for ['pebbles']\r\n     *\r\n     * // The `_.matchesProperty` iteratee shorthand.\r\n     * _.takeRightWhile(users, ['active', false]);\r\n     * // => objects for ['fred', 'pebbles']\r\n     *\r\n     * // The `_.property` iteratee shorthand.\r\n     * _.takeRightWhile(users, 'active');\r\n     * // => []\r\n     */\r\n    function takeRightWhile(array, predicate) {\r\n      return (array && array.length)\r\n        ? baseWhile(array, getIteratee(predicate, 3), false, true)\r\n        : [];\r\n    }\r\n\r\n    /**\r\n     * Creates a slice of `array` with elements taken from the beginning. Elements\r\n     * are taken until `predicate` returns falsey. The predicate is invoked with\r\n     * three arguments: (value, index, array).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.0.0\r\n     * @category Array\r\n     * @param {Array} array The array to query.\r\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\r\n     * @returns {Array} Returns the slice of `array`.\r\n     * @example\r\n     *\r\n     * var users = [\r\n     *   { 'user': 'barney',  'active': false },\r\n     *   { 'user': 'fred',    'active': false },\r\n     *   { 'user': 'pebbles', 'active': true }\r\n     * ];\r\n     *\r\n     * _.takeWhile(users, function(o) { return !o.active; });\r\n     * // => objects for ['barney', 'fred']\r\n     *\r\n     * // The `_.matches` iteratee shorthand.\r\n     * _.takeWhile(users, { 'user': 'barney', 'active': false });\r\n     * // => objects for ['barney']\r\n     *\r\n     * // The `_.matchesProperty` iteratee shorthand.\r\n     * _.takeWhile(users, ['active', false]);\r\n     * // => objects for ['barney', 'fred']\r\n     *\r\n     * // The `_.property` iteratee shorthand.\r\n     * _.takeWhile(users, 'active');\r\n     * // => []\r\n     */\r\n    function takeWhile(array, predicate) {\r\n      return (array && array.length)\r\n        ? baseWhile(array, getIteratee(predicate, 3))\r\n        : [];\r\n    }\r\n\r\n    /**\r\n     * Creates an array of unique values, in order, from all given arrays using\r\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\r\n     * for equality comparisons.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Array\r\n     * @param {...Array} [arrays] The arrays to inspect.\r\n     * @returns {Array} Returns the new array of combined values.\r\n     * @example\r\n     *\r\n     * _.union([2], [1, 2]);\r\n     * // => [2, 1]\r\n     */\r\n    var union = baseRest(function(arrays) {\r\n      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));\r\n    });\r\n\r\n    /**\r\n     * This method is like `_.union` except that it accepts `iteratee` which is\r\n     * invoked for each element of each `arrays` to generate the criterion by\r\n     * which uniqueness is computed. Result values are chosen from the first\r\n     * array in which the value occurs. The iteratee is invoked with one argument:\r\n     * (value).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Array\r\n     * @param {...Array} [arrays] The arrays to inspect.\r\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\r\n     * @returns {Array} Returns the new array of combined values.\r\n     * @example\r\n     *\r\n     * _.unionBy([2.1], [1.2, 2.3], Math.floor);\r\n     * // => [2.1, 1.2]\r\n     *\r\n     * // The `_.property` iteratee shorthand.\r\n     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\r\n     * // => [{ 'x': 1 }, { 'x': 2 }]\r\n     */\r\n    var unionBy = baseRest(function(arrays) {\r\n      var iteratee = last(arrays);\r\n      if (isArrayLikeObject(iteratee)) {\r\n        iteratee = undefined;\r\n      }\r\n      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));\r\n    });\r\n\r\n    /**\r\n     * This method is like `_.union` except that it accepts `comparator` which\r\n     * is invoked to compare elements of `arrays`. Result values are chosen from\r\n     * the first array in which the value occurs. The comparator is invoked\r\n     * with two arguments: (arrVal, othVal).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Array\r\n     * @param {...Array} [arrays] The arrays to inspect.\r\n     * @param {Function} [comparator] The comparator invoked per element.\r\n     * @returns {Array} Returns the new array of combined values.\r\n     * @example\r\n     *\r\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\r\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\r\n     *\r\n     * _.unionWith(objects, others, _.isEqual);\r\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\r\n     */\r\n    var unionWith = baseRest(function(arrays) {\r\n      var comparator = last(arrays);\r\n      comparator = typeof comparator == 'function' ? comparator : undefined;\r\n      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);\r\n    });\r\n\r\n    /**\r\n     * Creates a duplicate-free version of an array, using\r\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\r\n     * for equality comparisons, in which only the first occurrence of each element\r\n     * is kept. The order of result values is determined by the order they occur\r\n     * in the array.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Array\r\n     * @param {Array} array The array to inspect.\r\n     * @returns {Array} Returns the new duplicate free array.\r\n     * @example\r\n     *\r\n     * _.uniq([2, 1, 2]);\r\n     * // => [2, 1]\r\n     */\r\n    function uniq(array) {\r\n      return (array && array.length) ? baseUniq(array) : [];\r\n    }\r\n\r\n    /**\r\n     * This method is like `_.uniq` except that it accepts `iteratee` which is\r\n     * invoked for each element in `array` to generate the criterion by which\r\n     * uniqueness is computed. The order of result values is determined by the\r\n     * order they occur in the array. The iteratee is invoked with one argument:\r\n     * (value).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Array\r\n     * @param {Array} array The array to inspect.\r\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\r\n     * @returns {Array} Returns the new duplicate free array.\r\n     * @example\r\n     *\r\n     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);\r\n     * // => [2.1, 1.2]\r\n     *\r\n     * // The `_.property` iteratee shorthand.\r\n     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\r\n     * // => [{ 'x': 1 }, { 'x': 2 }]\r\n     */\r\n    function uniqBy(array, iteratee) {\r\n      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];\r\n    }\r\n\r\n    /**\r\n     * This method is like `_.uniq` except that it accepts `comparator` which\r\n     * is invoked to compare elements of `array`. The order of result values is\r\n     * determined by the order they occur in the array.The comparator is invoked\r\n     * with two arguments: (arrVal, othVal).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Array\r\n     * @param {Array} array The array to inspect.\r\n     * @param {Function} [comparator] The comparator invoked per element.\r\n     * @returns {Array} Returns the new duplicate free array.\r\n     * @example\r\n     *\r\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];\r\n     *\r\n     * _.uniqWith(objects, _.isEqual);\r\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]\r\n     */\r\n    function uniqWith(array, comparator) {\r\n      comparator = typeof comparator == 'function' ? comparator : undefined;\r\n      return (array && array.length) ? baseUniq(array, undefined, comparator) : [];\r\n    }\r\n\r\n    /**\r\n     * This method is like `_.zip` except that it accepts an array of grouped\r\n     * elements and creates an array regrouping the elements to their pre-zip\r\n     * configuration.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 1.2.0\r\n     * @category Array\r\n     * @param {Array} array The array of grouped elements to process.\r\n     * @returns {Array} Returns the new array of regrouped elements.\r\n     * @example\r\n     *\r\n     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);\r\n     * // => [['a', 1, true], ['b', 2, false]]\r\n     *\r\n     * _.unzip(zipped);\r\n     * // => [['a', 'b'], [1, 2], [true, false]]\r\n     */\r\n    function unzip(array) {\r\n      if (!(array && array.length)) {\r\n        return [];\r\n      }\r\n      var length = 0;\r\n      array = arrayFilter(array, function(group) {\r\n        if (isArrayLikeObject(group)) {\r\n          length = nativeMax(group.length, length);\r\n          return true;\r\n        }\r\n      });\r\n      return baseTimes(length, function(index) {\r\n        return arrayMap(array, baseProperty(index));\r\n      });\r\n    }\r\n\r\n    /**\r\n     * This method is like `_.unzip` except that it accepts `iteratee` to specify\r\n     * how regrouped values should be combined. The iteratee is invoked with the\r\n     * elements of each group: (...group).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.8.0\r\n     * @category Array\r\n     * @param {Array} array The array of grouped elements to process.\r\n     * @param {Function} [iteratee=_.identity] The function to combine\r\n     *  regrouped values.\r\n     * @returns {Array} Returns the new array of regrouped elements.\r\n     * @example\r\n     *\r\n     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);\r\n     * // => [[1, 10, 100], [2, 20, 200]]\r\n     *\r\n     * _.unzipWith(zipped, _.add);\r\n     * // => [3, 30, 300]\r\n     */\r\n    function unzipWith(array, iteratee) {\r\n      if (!(array && array.length)) {\r\n        return [];\r\n      }\r\n      var result = unzip(array);\r\n      if (iteratee == null) {\r\n        return result;\r\n      }\r\n      return arrayMap(result, function(group) {\r\n        return apply(iteratee, undefined, group);\r\n      });\r\n    }\r\n\r\n    /**\r\n     * Creates an array excluding all given values using\r\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\r\n     * for equality comparisons.\r\n     *\r\n     * **Note:** Unlike `_.pull`, this method returns a new array.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Array\r\n     * @param {Array} array The array to inspect.\r\n     * @param {...*} [values] The values to exclude.\r\n     * @returns {Array} Returns the new array of filtered values.\r\n     * @see _.difference, _.xor\r\n     * @example\r\n     *\r\n     * _.without([2, 1, 2, 3], 1, 2);\r\n     * // => [3]\r\n     */\r\n    var without = baseRest(function(array, values) {\r\n      return isArrayLikeObject(array)\r\n        ? baseDifference(array, values)\r\n        : [];\r\n    });\r\n\r\n    /**\r\n     * Creates an array of unique values that is the\r\n     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)\r\n     * of the given arrays. The order of result values is determined by the order\r\n     * they occur in the arrays.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 2.4.0\r\n     * @category Array\r\n     * @param {...Array} [arrays] The arrays to inspect.\r\n     * @returns {Array} Returns the new array of filtered values.\r\n     * @see _.difference, _.without\r\n     * @example\r\n     *\r\n     * _.xor([2, 1], [2, 3]);\r\n     * // => [1, 3]\r\n     */\r\n    var xor = baseRest(function(arrays) {\r\n      return baseXor(arrayFilter(arrays, isArrayLikeObject));\r\n    });\r\n\r\n    /**\r\n     * This method is like `_.xor` except that it accepts `iteratee` which is\r\n     * invoked for each element of each `arrays` to generate the criterion by\r\n     * which by which they're compared. The order of result values is determined\r\n     * by the order they occur in the arrays. The iteratee is invoked with one\r\n     * argument: (value).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Array\r\n     * @param {...Array} [arrays] The arrays to inspect.\r\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\r\n     * @returns {Array} Returns the new array of filtered values.\r\n     * @example\r\n     *\r\n     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);\r\n     * // => [1.2, 3.4]\r\n     *\r\n     * // The `_.property` iteratee shorthand.\r\n     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\r\n     * // => [{ 'x': 2 }]\r\n     */\r\n    var xorBy = baseRest(function(arrays) {\r\n      var iteratee = last(arrays);\r\n      if (isArrayLikeObject(iteratee)) {\r\n        iteratee = undefined;\r\n      }\r\n      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));\r\n    });\r\n\r\n    /**\r\n     * This method is like `_.xor` except that it accepts `comparator` which is\r\n     * invoked to compare elements of `arrays`. The order of result values is\r\n     * determined by the order they occur in the arrays. The comparator is invoked\r\n     * with two arguments: (arrVal, othVal).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Array\r\n     * @param {...Array} [arrays] The arrays to inspect.\r\n     * @param {Function} [comparator] The comparator invoked per element.\r\n     * @returns {Array} Returns the new array of filtered values.\r\n     * @example\r\n     *\r\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\r\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\r\n     *\r\n     * _.xorWith(objects, others, _.isEqual);\r\n     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\r\n     */\r\n    var xorWith = baseRest(function(arrays) {\r\n      var comparator = last(arrays);\r\n      comparator = typeof comparator == 'function' ? comparator : undefined;\r\n      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);\r\n    });\r\n\r\n    /**\r\n     * Creates an array of grouped elements, the first of which contains the\r\n     * first elements of the given arrays, the second of which contains the\r\n     * second elements of the given arrays, and so on.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Array\r\n     * @param {...Array} [arrays] The arrays to process.\r\n     * @returns {Array} Returns the new array of grouped elements.\r\n     * @example\r\n     *\r\n     * _.zip(['a', 'b'], [1, 2], [true, false]);\r\n     * // => [['a', 1, true], ['b', 2, false]]\r\n     */\r\n    var zip = baseRest(unzip);\r\n\r\n    /**\r\n     * This method is like `_.fromPairs` except that it accepts two arrays,\r\n     * one of property identifiers and one of corresponding values.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.4.0\r\n     * @category Array\r\n     * @param {Array} [props=[]] The property identifiers.\r\n     * @param {Array} [values=[]] The property values.\r\n     * @returns {Object} Returns the new object.\r\n     * @example\r\n     *\r\n     * _.zipObject(['a', 'b'], [1, 2]);\r\n     * // => { 'a': 1, 'b': 2 }\r\n     */\r\n    function zipObject(props, values) {\r\n      return baseZipObject(props || [], values || [], assignValue);\r\n    }\r\n\r\n    /**\r\n     * This method is like `_.zipObject` except that it supports property paths.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.1.0\r\n     * @category Array\r\n     * @param {Array} [props=[]] The property identifiers.\r\n     * @param {Array} [values=[]] The property values.\r\n     * @returns {Object} Returns the new object.\r\n     * @example\r\n     *\r\n     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);\r\n     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }\r\n     */\r\n    function zipObjectDeep(props, values) {\r\n      return baseZipObject(props || [], values || [], baseSet);\r\n    }\r\n\r\n    /**\r\n     * This method is like `_.zip` except that it accepts `iteratee` to specify\r\n     * how grouped values should be combined. The iteratee is invoked with the\r\n     * elements of each group: (...group).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.8.0\r\n     * @category Array\r\n     * @param {...Array} [arrays] The arrays to process.\r\n     * @param {Function} [iteratee=_.identity] The function to combine\r\n     *  grouped values.\r\n     * @returns {Array} Returns the new array of grouped elements.\r\n     * @example\r\n     *\r\n     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {\r\n     *   return a + b + c;\r\n     * });\r\n     * // => [111, 222]\r\n     */\r\n    var zipWith = baseRest(function(arrays) {\r\n      var length = arrays.length,\r\n          iteratee = length > 1 ? arrays[length - 1] : undefined;\r\n\r\n      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;\r\n      return unzipWith(arrays, iteratee);\r\n    });\r\n\r\n    /*------------------------------------------------------------------------*/\r\n\r\n    /**\r\n     * Creates a `lodash` wrapper instance that wraps `value` with explicit method\r\n     * chain sequences enabled. The result of such sequences must be unwrapped\r\n     * with `_#value`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 1.3.0\r\n     * @category Seq\r\n     * @param {*} value The value to wrap.\r\n     * @returns {Object} Returns the new `lodash` wrapper instance.\r\n     * @example\r\n     *\r\n     * var users = [\r\n     *   { 'user': 'barney',  'age': 36 },\r\n     *   { 'user': 'fred',    'age': 40 },\r\n     *   { 'user': 'pebbles', 'age': 1 }\r\n     * ];\r\n     *\r\n     * var youngest = _\r\n     *   .chain(users)\r\n     *   .sortBy('age')\r\n     *   .map(function(o) {\r\n     *     return o.user + ' is ' + o.age;\r\n     *   })\r\n     *   .head()\r\n     *   .value();\r\n     * // => 'pebbles is 1'\r\n     */\r\n    function chain(value) {\r\n      var result = lodash(value);\r\n      result.__chain__ = true;\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * This method invokes `interceptor` and returns `value`. The interceptor\r\n     * is invoked with one argument; (value). The purpose of this method is to\r\n     * \"tap into\" a method chain sequence in order to modify intermediate results.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Seq\r\n     * @param {*} value The value to provide to `interceptor`.\r\n     * @param {Function} interceptor The function to invoke.\r\n     * @returns {*} Returns `value`.\r\n     * @example\r\n     *\r\n     * _([1, 2, 3])\r\n     *  .tap(function(array) {\r\n     *    // Mutate input array.\r\n     *    array.pop();\r\n     *  })\r\n     *  .reverse()\r\n     *  .value();\r\n     * // => [2, 1]\r\n     */\r\n    function tap(value, interceptor) {\r\n      interceptor(value);\r\n      return value;\r\n    }\r\n\r\n    /**\r\n     * This method is like `_.tap` except that it returns the result of `interceptor`.\r\n     * The purpose of this method is to \"pass thru\" values replacing intermediate\r\n     * results in a method chain sequence.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.0.0\r\n     * @category Seq\r\n     * @param {*} value The value to provide to `interceptor`.\r\n     * @param {Function} interceptor The function to invoke.\r\n     * @returns {*} Returns the result of `interceptor`.\r\n     * @example\r\n     *\r\n     * _('  abc  ')\r\n     *  .chain()\r\n     *  .trim()\r\n     *  .thru(function(value) {\r\n     *    return [value];\r\n     *  })\r\n     *  .value();\r\n     * // => ['abc']\r\n     */\r\n    function thru(value, interceptor) {\r\n      return interceptor(value);\r\n    }\r\n\r\n    /**\r\n     * This method is the wrapper version of `_.at`.\r\n     *\r\n     * @name at\r\n     * @memberOf _\r\n     * @since 1.0.0\r\n     * @category Seq\r\n     * @param {...(string|string[])} [paths] The property paths to pick.\r\n     * @returns {Object} Returns the new `lodash` wrapper instance.\r\n     * @example\r\n     *\r\n     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };\r\n     *\r\n     * _(object).at(['a[0].b.c', 'a[1]']).value();\r\n     * // => [3, 4]\r\n     */\r\n    var wrapperAt = flatRest(function(paths) {\r\n      var length = paths.length,\r\n          start = length ? paths[0] : 0,\r\n          value = this.__wrapped__,\r\n          interceptor = function(object) { return baseAt(object, paths); };\r\n\r\n      if (length > 1 || this.__actions__.length ||\r\n          !(value instanceof LazyWrapper) || !isIndex(start)) {\r\n        return this.thru(interceptor);\r\n      }\r\n      value = value.slice(start, +start + (length ? 1 : 0));\r\n      value.__actions__.push({\r\n        'func': thru,\r\n        'args': [interceptor],\r\n        'thisArg': undefined\r\n      });\r\n      return new LodashWrapper(value, this.__chain__).thru(function(array) {\r\n        if (length && !array.length) {\r\n          array.push(undefined);\r\n        }\r\n        return array;\r\n      });\r\n    });\r\n\r\n    /**\r\n     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.\r\n     *\r\n     * @name chain\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Seq\r\n     * @returns {Object} Returns the new `lodash` wrapper instance.\r\n     * @example\r\n     *\r\n     * var users = [\r\n     *   { 'user': 'barney', 'age': 36 },\r\n     *   { 'user': 'fred',   'age': 40 }\r\n     * ];\r\n     *\r\n     * // A sequence without explicit chaining.\r\n     * _(users).head();\r\n     * // => { 'user': 'barney', 'age': 36 }\r\n     *\r\n     * // A sequence with explicit chaining.\r\n     * _(users)\r\n     *   .chain()\r\n     *   .head()\r\n     *   .pick('user')\r\n     *   .value();\r\n     * // => { 'user': 'barney' }\r\n     */\r\n    function wrapperChain() {\r\n      return chain(this);\r\n    }\r\n\r\n    /**\r\n     * Executes the chain sequence and returns the wrapped result.\r\n     *\r\n     * @name commit\r\n     * @memberOf _\r\n     * @since 3.2.0\r\n     * @category Seq\r\n     * @returns {Object} Returns the new `lodash` wrapper instance.\r\n     * @example\r\n     *\r\n     * var array = [1, 2];\r\n     * var wrapped = _(array).push(3);\r\n     *\r\n     * console.log(array);\r\n     * // => [1, 2]\r\n     *\r\n     * wrapped = wrapped.commit();\r\n     * console.log(array);\r\n     * // => [1, 2, 3]\r\n     *\r\n     * wrapped.last();\r\n     * // => 3\r\n     *\r\n     * console.log(array);\r\n     * // => [1, 2, 3]\r\n     */\r\n    function wrapperCommit() {\r\n      return new LodashWrapper(this.value(), this.__chain__);\r\n    }\r\n\r\n    /**\r\n     * Gets the next value on a wrapped object following the\r\n     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).\r\n     *\r\n     * @name next\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Seq\r\n     * @returns {Object} Returns the next iterator value.\r\n     * @example\r\n     *\r\n     * var wrapped = _([1, 2]);\r\n     *\r\n     * wrapped.next();\r\n     * // => { 'done': false, 'value': 1 }\r\n     *\r\n     * wrapped.next();\r\n     * // => { 'done': false, 'value': 2 }\r\n     *\r\n     * wrapped.next();\r\n     * // => { 'done': true, 'value': undefined }\r\n     */\r\n    function wrapperNext() {\r\n      if (this.__values__ === undefined) {\r\n        this.__values__ = toArray(this.value());\r\n      }\r\n      var done = this.__index__ >= this.__values__.length,\r\n          value = done ? undefined : this.__values__[this.__index__++];\r\n\r\n      return { 'done': done, 'value': value };\r\n    }\r\n\r\n    /**\r\n     * Enables the wrapper to be iterable.\r\n     *\r\n     * @name Symbol.iterator\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Seq\r\n     * @returns {Object} Returns the wrapper object.\r\n     * @example\r\n     *\r\n     * var wrapped = _([1, 2]);\r\n     *\r\n     * wrapped[Symbol.iterator]() === wrapped;\r\n     * // => true\r\n     *\r\n     * Array.from(wrapped);\r\n     * // => [1, 2]\r\n     */\r\n    function wrapperToIterator() {\r\n      return this;\r\n    }\r\n\r\n    /**\r\n     * Creates a clone of the chain sequence planting `value` as the wrapped value.\r\n     *\r\n     * @name plant\r\n     * @memberOf _\r\n     * @since 3.2.0\r\n     * @category Seq\r\n     * @param {*} value The value to plant.\r\n     * @returns {Object} Returns the new `lodash` wrapper instance.\r\n     * @example\r\n     *\r\n     * function square(n) {\r\n     *   return n * n;\r\n     * }\r\n     *\r\n     * var wrapped = _([1, 2]).map(square);\r\n     * var other = wrapped.plant([3, 4]);\r\n     *\r\n     * other.value();\r\n     * // => [9, 16]\r\n     *\r\n     * wrapped.value();\r\n     * // => [1, 4]\r\n     */\r\n    function wrapperPlant(value) {\r\n      var result,\r\n          parent = this;\r\n\r\n      while (parent instanceof baseLodash) {\r\n        var clone = wrapperClone(parent);\r\n        clone.__index__ = 0;\r\n        clone.__values__ = undefined;\r\n        if (result) {\r\n          previous.__wrapped__ = clone;\r\n        } else {\r\n          result = clone;\r\n        }\r\n        var previous = clone;\r\n        parent = parent.__wrapped__;\r\n      }\r\n      previous.__wrapped__ = value;\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * This method is the wrapper version of `_.reverse`.\r\n     *\r\n     * **Note:** This method mutates the wrapped array.\r\n     *\r\n     * @name reverse\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Seq\r\n     * @returns {Object} Returns the new `lodash` wrapper instance.\r\n     * @example\r\n     *\r\n     * var array = [1, 2, 3];\r\n     *\r\n     * _(array).reverse().value()\r\n     * // => [3, 2, 1]\r\n     *\r\n     * console.log(array);\r\n     * // => [3, 2, 1]\r\n     */\r\n    function wrapperReverse() {\r\n      var value = this.__wrapped__;\r\n      if (value instanceof LazyWrapper) {\r\n        var wrapped = value;\r\n        if (this.__actions__.length) {\r\n          wrapped = new LazyWrapper(this);\r\n        }\r\n        wrapped = wrapped.reverse();\r\n        wrapped.__actions__.push({\r\n          'func': thru,\r\n          'args': [reverse],\r\n          'thisArg': undefined\r\n        });\r\n        return new LodashWrapper(wrapped, this.__chain__);\r\n      }\r\n      return this.thru(reverse);\r\n    }\r\n\r\n    /**\r\n     * Executes the chain sequence to resolve the unwrapped value.\r\n     *\r\n     * @name value\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @alias toJSON, valueOf\r\n     * @category Seq\r\n     * @returns {*} Returns the resolved unwrapped value.\r\n     * @example\r\n     *\r\n     * _([1, 2, 3]).value();\r\n     * // => [1, 2, 3]\r\n     */\r\n    function wrapperValue() {\r\n      return baseWrapperValue(this.__wrapped__, this.__actions__);\r\n    }\r\n\r\n    /*------------------------------------------------------------------------*/\r\n\r\n    /**\r\n     * Creates an object composed of keys generated from the results of running\r\n     * each element of `collection` thru `iteratee`. The corresponding value of\r\n     * each key is the number of times the key was returned by `iteratee`. The\r\n     * iteratee is invoked with one argument: (value).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.5.0\r\n     * @category Collection\r\n     * @param {Array|Object} collection The collection to iterate over.\r\n     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\r\n     * @returns {Object} Returns the composed aggregate object.\r\n     * @example\r\n     *\r\n     * _.countBy([6.1, 4.2, 6.3], Math.floor);\r\n     * // => { '4': 1, '6': 2 }\r\n     *\r\n     * // The `_.property` iteratee shorthand.\r\n     * _.countBy(['one', 'two', 'three'], 'length');\r\n     * // => { '3': 2, '5': 1 }\r\n     */\r\n    var countBy = createAggregator(function(result, value, key) {\r\n      if (hasOwnProperty.call(result, key)) {\r\n        ++result[key];\r\n      } else {\r\n        baseAssignValue(result, key, 1);\r\n      }\r\n    });\r\n\r\n    /**\r\n     * Checks if `predicate` returns truthy for **all** elements of `collection`.\r\n     * Iteration is stopped once `predicate` returns falsey. The predicate is\r\n     * invoked with three arguments: (value, index|key, collection).\r\n     *\r\n     * **Note:** This method returns `true` for\r\n     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because\r\n     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of\r\n     * elements of empty collections.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Collection\r\n     * @param {Array|Object} collection The collection to iterate over.\r\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\r\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\r\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\r\n     *  else `false`.\r\n     * @example\r\n     *\r\n     * _.every([true, 1, null, 'yes'], Boolean);\r\n     * // => false\r\n     *\r\n     * var users = [\r\n     *   { 'user': 'barney', 'age': 36, 'active': false },\r\n     *   { 'user': 'fred',   'age': 40, 'active': false }\r\n     * ];\r\n     *\r\n     * // The `_.matches` iteratee shorthand.\r\n     * _.every(users, { 'user': 'barney', 'active': false });\r\n     * // => false\r\n     *\r\n     * // The `_.matchesProperty` iteratee shorthand.\r\n     * _.every(users, ['active', false]);\r\n     * // => true\r\n     *\r\n     * // The `_.property` iteratee shorthand.\r\n     * _.every(users, 'active');\r\n     * // => false\r\n     */\r\n    function every(collection, predicate, guard) {\r\n      var func = isArray(collection) ? arrayEvery : baseEvery;\r\n      if (guard && isIterateeCall(collection, predicate, guard)) {\r\n        predicate = undefined;\r\n      }\r\n      return func(collection, getIteratee(predicate, 3));\r\n    }\r\n\r\n    /**\r\n     * Iterates over elements of `collection`, returning an array of all elements\r\n     * `predicate` returns truthy for. The predicate is invoked with three\r\n     * arguments: (value, index|key, collection).\r\n     *\r\n     * **Note:** Unlike `_.remove`, this method returns a new array.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Collection\r\n     * @param {Array|Object} collection The collection to iterate over.\r\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\r\n     * @returns {Array} Returns the new filtered array.\r\n     * @see _.reject\r\n     * @example\r\n     *\r\n     * var users = [\r\n     *   { 'user': 'barney', 'age': 36, 'active': true },\r\n     *   { 'user': 'fred',   'age': 40, 'active': false }\r\n     * ];\r\n     *\r\n     * _.filter(users, function(o) { return !o.active; });\r\n     * // => objects for ['fred']\r\n     *\r\n     * // The `_.matches` iteratee shorthand.\r\n     * _.filter(users, { 'age': 36, 'active': true });\r\n     * // => objects for ['barney']\r\n     *\r\n     * // The `_.matchesProperty` iteratee shorthand.\r\n     * _.filter(users, ['active', false]);\r\n     * // => objects for ['fred']\r\n     *\r\n     * // The `_.property` iteratee shorthand.\r\n     * _.filter(users, 'active');\r\n     * // => objects for ['barney']\r\n     *\r\n     * // Combining several predicates using `_.overEvery` or `_.overSome`.\r\n     * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));\r\n     * // => objects for ['fred', 'barney']\r\n     */\r\n    function filter(collection, predicate) {\r\n      var func = isArray(collection) ? arrayFilter : baseFilter;\r\n      return func(collection, getIteratee(predicate, 3));\r\n    }\r\n\r\n    /**\r\n     * Iterates over elements of `collection`, returning the first element\r\n     * `predicate` returns truthy for. The predicate is invoked with three\r\n     * arguments: (value, index|key, collection).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Collection\r\n     * @param {Array|Object} collection The collection to inspect.\r\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\r\n     * @param {number} [fromIndex=0] The index to search from.\r\n     * @returns {*} Returns the matched element, else `undefined`.\r\n     * @example\r\n     *\r\n     * var users = [\r\n     *   { 'user': 'barney',  'age': 36, 'active': true },\r\n     *   { 'user': 'fred',    'age': 40, 'active': false },\r\n     *   { 'user': 'pebbles', 'age': 1,  'active': true }\r\n     * ];\r\n     *\r\n     * _.find(users, function(o) { return o.age < 40; });\r\n     * // => object for 'barney'\r\n     *\r\n     * // The `_.matches` iteratee shorthand.\r\n     * _.find(users, { 'age': 1, 'active': true });\r\n     * // => object for 'pebbles'\r\n     *\r\n     * // The `_.matchesProperty` iteratee shorthand.\r\n     * _.find(users, ['active', false]);\r\n     * // => object for 'fred'\r\n     *\r\n     * // The `_.property` iteratee shorthand.\r\n     * _.find(users, 'active');\r\n     * // => object for 'barney'\r\n     */\r\n    var find = createFind(findIndex);\r\n\r\n    /**\r\n     * This method is like `_.find` except that it iterates over elements of\r\n     * `collection` from right to left.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 2.0.0\r\n     * @category Collection\r\n     * @param {Array|Object} collection The collection to inspect.\r\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\r\n     * @param {number} [fromIndex=collection.length-1] The index to search from.\r\n     * @returns {*} Returns the matched element, else `undefined`.\r\n     * @example\r\n     *\r\n     * _.findLast([1, 2, 3, 4], function(n) {\r\n     *   return n % 2 == 1;\r\n     * });\r\n     * // => 3\r\n     */\r\n    var findLast = createFind(findLastIndex);\r\n\r\n    /**\r\n     * Creates a flattened array of values by running each element in `collection`\r\n     * thru `iteratee` and flattening the mapped results. The iteratee is invoked\r\n     * with three arguments: (value, index|key, collection).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Collection\r\n     * @param {Array|Object} collection The collection to iterate over.\r\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\r\n     * @returns {Array} Returns the new flattened array.\r\n     * @example\r\n     *\r\n     * function duplicate(n) {\r\n     *   return [n, n];\r\n     * }\r\n     *\r\n     * _.flatMap([1, 2], duplicate);\r\n     * // => [1, 1, 2, 2]\r\n     */\r\n    function flatMap(collection, iteratee) {\r\n      return baseFlatten(map(collection, iteratee), 1);\r\n    }\r\n\r\n    /**\r\n     * This method is like `_.flatMap` except that it recursively flattens the\r\n     * mapped results.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.7.0\r\n     * @category Collection\r\n     * @param {Array|Object} collection The collection to iterate over.\r\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\r\n     * @returns {Array} Returns the new flattened array.\r\n     * @example\r\n     *\r\n     * function duplicate(n) {\r\n     *   return [[[n, n]]];\r\n     * }\r\n     *\r\n     * _.flatMapDeep([1, 2], duplicate);\r\n     * // => [1, 1, 2, 2]\r\n     */\r\n    function flatMapDeep(collection, iteratee) {\r\n      return baseFlatten(map(collection, iteratee), INFINITY);\r\n    }\r\n\r\n    /**\r\n     * This method is like `_.flatMap` except that it recursively flattens the\r\n     * mapped results up to `depth` times.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.7.0\r\n     * @category Collection\r\n     * @param {Array|Object} collection The collection to iterate over.\r\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\r\n     * @param {number} [depth=1] The maximum recursion depth.\r\n     * @returns {Array} Returns the new flattened array.\r\n     * @example\r\n     *\r\n     * function duplicate(n) {\r\n     *   return [[[n, n]]];\r\n     * }\r\n     *\r\n     * _.flatMapDepth([1, 2], duplicate, 2);\r\n     * // => [[1, 1], [2, 2]]\r\n     */\r\n    function flatMapDepth(collection, iteratee, depth) {\r\n      depth = depth === undefined ? 1 : toInteger(depth);\r\n      return baseFlatten(map(collection, iteratee), depth);\r\n    }\r\n\r\n    /**\r\n     * Iterates over elements of `collection` and invokes `iteratee` for each element.\r\n     * The iteratee is invoked with three arguments: (value, index|key, collection).\r\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\r\n     *\r\n     * **Note:** As with other \"Collections\" methods, objects with a \"length\"\r\n     * property are iterated like arrays. To avoid this behavior use `_.forIn`\r\n     * or `_.forOwn` for object iteration.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @alias each\r\n     * @category Collection\r\n     * @param {Array|Object} collection The collection to iterate over.\r\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\r\n     * @returns {Array|Object} Returns `collection`.\r\n     * @see _.forEachRight\r\n     * @example\r\n     *\r\n     * _.forEach([1, 2], function(value) {\r\n     *   console.log(value);\r\n     * });\r\n     * // => Logs `1` then `2`.\r\n     *\r\n     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {\r\n     *   console.log(key);\r\n     * });\r\n     * // => Logs 'a' then 'b' (iteration order is not guaranteed).\r\n     */\r\n    function forEach(collection, iteratee) {\r\n      var func = isArray(collection) ? arrayEach : baseEach;\r\n      return func(collection, getIteratee(iteratee, 3));\r\n    }\r\n\r\n    /**\r\n     * This method is like `_.forEach` except that it iterates over elements of\r\n     * `collection` from right to left.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 2.0.0\r\n     * @alias eachRight\r\n     * @category Collection\r\n     * @param {Array|Object} collection The collection to iterate over.\r\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\r\n     * @returns {Array|Object} Returns `collection`.\r\n     * @see _.forEach\r\n     * @example\r\n     *\r\n     * _.forEachRight([1, 2], function(value) {\r\n     *   console.log(value);\r\n     * });\r\n     * // => Logs `2` then `1`.\r\n     */\r\n    function forEachRight(collection, iteratee) {\r\n      var func = isArray(collection) ? arrayEachRight : baseEachRight;\r\n      return func(collection, getIteratee(iteratee, 3));\r\n    }\r\n\r\n    /**\r\n     * Creates an object composed of keys generated from the results of running\r\n     * each element of `collection` thru `iteratee`. The order of grouped values\r\n     * is determined by the order they occur in `collection`. The corresponding\r\n     * value of each key is an array of elements responsible for generating the\r\n     * key. The iteratee is invoked with one argument: (value).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Collection\r\n     * @param {Array|Object} collection The collection to iterate over.\r\n     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\r\n     * @returns {Object} Returns the composed aggregate object.\r\n     * @example\r\n     *\r\n     * _.groupBy([6.1, 4.2, 6.3], Math.floor);\r\n     * // => { '4': [4.2], '6': [6.1, 6.3] }\r\n     *\r\n     * // The `_.property` iteratee shorthand.\r\n     * _.groupBy(['one', 'two', 'three'], 'length');\r\n     * // => { '3': ['one', 'two'], '5': ['three'] }\r\n     */\r\n    var groupBy = createAggregator(function(result, value, key) {\r\n      if (hasOwnProperty.call(result, key)) {\r\n        result[key].push(value);\r\n      } else {\r\n        baseAssignValue(result, key, [value]);\r\n      }\r\n    });\r\n\r\n    /**\r\n     * Checks if `value` is in `collection`. If `collection` is a string, it's\r\n     * checked for a substring of `value`, otherwise\r\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\r\n     * is used for equality comparisons. If `fromIndex` is negative, it's used as\r\n     * the offset from the end of `collection`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Collection\r\n     * @param {Array|Object|string} collection The collection to inspect.\r\n     * @param {*} value The value to search for.\r\n     * @param {number} [fromIndex=0] The index to search from.\r\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\r\n     * @returns {boolean} Returns `true` if `value` is found, else `false`.\r\n     * @example\r\n     *\r\n     * _.includes([1, 2, 3], 1);\r\n     * // => true\r\n     *\r\n     * _.includes([1, 2, 3], 1, 2);\r\n     * // => false\r\n     *\r\n     * _.includes({ 'a': 1, 'b': 2 }, 1);\r\n     * // => true\r\n     *\r\n     * _.includes('abcd', 'bc');\r\n     * // => true\r\n     */\r\n    function includes(collection, value, fromIndex, guard) {\r\n      collection = isArrayLike(collection) ? collection : values(collection);\r\n      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;\r\n\r\n      var length = collection.length;\r\n      if (fromIndex < 0) {\r\n        fromIndex = nativeMax(length + fromIndex, 0);\r\n      }\r\n      return isString(collection)\r\n        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)\r\n        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);\r\n    }\r\n\r\n    /**\r\n     * Invokes the method at `path` of each element in `collection`, returning\r\n     * an array of the results of each invoked method. Any additional arguments\r\n     * are provided to each invoked method. If `path` is a function, it's invoked\r\n     * for, and `this` bound to, each element in `collection`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Collection\r\n     * @param {Array|Object} collection The collection to iterate over.\r\n     * @param {Array|Function|string} path The path of the method to invoke or\r\n     *  the function invoked per iteration.\r\n     * @param {...*} [args] The arguments to invoke each method with.\r\n     * @returns {Array} Returns the array of results.\r\n     * @example\r\n     *\r\n     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');\r\n     * // => [[1, 5, 7], [1, 2, 3]]\r\n     *\r\n     * _.invokeMap([123, 456], String.prototype.split, '');\r\n     * // => [['1', '2', '3'], ['4', '5', '6']]\r\n     */\r\n    var invokeMap = baseRest(function(collection, path, args) {\r\n      var index = -1,\r\n          isFunc = typeof path == 'function',\r\n          result = isArrayLike(collection) ? Array(collection.length) : [];\r\n\r\n      baseEach(collection, function(value) {\r\n        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);\r\n      });\r\n      return result;\r\n    });\r\n\r\n    /**\r\n     * Creates an object composed of keys generated from the results of running\r\n     * each element of `collection` thru `iteratee`. The corresponding value of\r\n     * each key is the last element responsible for generating the key. The\r\n     * iteratee is invoked with one argument: (value).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Collection\r\n     * @param {Array|Object} collection The collection to iterate over.\r\n     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\r\n     * @returns {Object} Returns the composed aggregate object.\r\n     * @example\r\n     *\r\n     * var array = [\r\n     *   { 'dir': 'left', 'code': 97 },\r\n     *   { 'dir': 'right', 'code': 100 }\r\n     * ];\r\n     *\r\n     * _.keyBy(array, function(o) {\r\n     *   return String.fromCharCode(o.code);\r\n     * });\r\n     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\r\n     *\r\n     * _.keyBy(array, 'dir');\r\n     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }\r\n     */\r\n    var keyBy = createAggregator(function(result, value, key) {\r\n      baseAssignValue(result, key, value);\r\n    });\r\n\r\n    /**\r\n     * Creates an array of values by running each element in `collection` thru\r\n     * `iteratee`. The iteratee is invoked with three arguments:\r\n     * (value, index|key, collection).\r\n     *\r\n     * Many lodash methods are guarded to work as iteratees for methods like\r\n     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\r\n     *\r\n     * The guarded methods are:\r\n     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\r\n     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\r\n     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\r\n     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Collection\r\n     * @param {Array|Object} collection The collection to iterate over.\r\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\r\n     * @returns {Array} Returns the new mapped array.\r\n     * @example\r\n     *\r\n     * function square(n) {\r\n     *   return n * n;\r\n     * }\r\n     *\r\n     * _.map([4, 8], square);\r\n     * // => [16, 64]\r\n     *\r\n     * _.map({ 'a': 4, 'b': 8 }, square);\r\n     * // => [16, 64] (iteration order is not guaranteed)\r\n     *\r\n     * var users = [\r\n     *   { 'user': 'barney' },\r\n     *   { 'user': 'fred' }\r\n     * ];\r\n     *\r\n     * // The `_.property` iteratee shorthand.\r\n     * _.map(users, 'user');\r\n     * // => ['barney', 'fred']\r\n     */\r\n    function map(collection, iteratee) {\r\n      var func = isArray(collection) ? arrayMap : baseMap;\r\n      return func(collection, getIteratee(iteratee, 3));\r\n    }\r\n\r\n    /**\r\n     * This method is like `_.sortBy` except that it allows specifying the sort\r\n     * orders of the iteratees to sort by. If `orders` is unspecified, all values\r\n     * are sorted in ascending order. Otherwise, specify an order of \"desc\" for\r\n     * descending or \"asc\" for ascending sort order of corresponding values.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Collection\r\n     * @param {Array|Object} collection The collection to iterate over.\r\n     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]\r\n     *  The iteratees to sort by.\r\n     * @param {string[]} [orders] The sort orders of `iteratees`.\r\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\r\n     * @returns {Array} Returns the new sorted array.\r\n     * @example\r\n     *\r\n     * var users = [\r\n     *   { 'user': 'fred',   'age': 48 },\r\n     *   { 'user': 'barney', 'age': 34 },\r\n     *   { 'user': 'fred',   'age': 40 },\r\n     *   { 'user': 'barney', 'age': 36 }\r\n     * ];\r\n     *\r\n     * // Sort by `user` in ascending order and by `age` in descending order.\r\n     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);\r\n     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]\r\n     */\r\n    function orderBy(collection, iteratees, orders, guard) {\r\n      if (collection == null) {\r\n        return [];\r\n      }\r\n      if (!isArray(iteratees)) {\r\n        iteratees = iteratees == null ? [] : [iteratees];\r\n      }\r\n      orders = guard ? undefined : orders;\r\n      if (!isArray(orders)) {\r\n        orders = orders == null ? [] : [orders];\r\n      }\r\n      return baseOrderBy(collection, iteratees, orders);\r\n    }\r\n\r\n    /**\r\n     * Creates an array of elements split into two groups, the first of which\r\n     * contains elements `predicate` returns truthy for, the second of which\r\n     * contains elements `predicate` returns falsey for. The predicate is\r\n     * invoked with one argument: (value).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.0.0\r\n     * @category Collection\r\n     * @param {Array|Object} collection The collection to iterate over.\r\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\r\n     * @returns {Array} Returns the array of grouped elements.\r\n     * @example\r\n     *\r\n     * var users = [\r\n     *   { 'user': 'barney',  'age': 36, 'active': false },\r\n     *   { 'user': 'fred',    'age': 40, 'active': true },\r\n     *   { 'user': 'pebbles', 'age': 1,  'active': false }\r\n     * ];\r\n     *\r\n     * _.partition(users, function(o) { return o.active; });\r\n     * // => objects for [['fred'], ['barney', 'pebbles']]\r\n     *\r\n     * // The `_.matches` iteratee shorthand.\r\n     * _.partition(users, { 'age': 1, 'active': false });\r\n     * // => objects for [['pebbles'], ['barney', 'fred']]\r\n     *\r\n     * // The `_.matchesProperty` iteratee shorthand.\r\n     * _.partition(users, ['active', false]);\r\n     * // => objects for [['barney', 'pebbles'], ['fred']]\r\n     *\r\n     * // The `_.property` iteratee shorthand.\r\n     * _.partition(users, 'active');\r\n     * // => objects for [['fred'], ['barney', 'pebbles']]\r\n     */\r\n    var partition = createAggregator(function(result, value, key) {\r\n      result[key ? 0 : 1].push(value);\r\n    }, function() { return [[], []]; });\r\n\r\n    /**\r\n     * Reduces `collection` to a value which is the accumulated result of running\r\n     * each element in `collection` thru `iteratee`, where each successive\r\n     * invocation is supplied the return value of the previous. If `accumulator`\r\n     * is not given, the first element of `collection` is used as the initial\r\n     * value. The iteratee is invoked with four arguments:\r\n     * (accumulator, value, index|key, collection).\r\n     *\r\n     * Many lodash methods are guarded to work as iteratees for methods like\r\n     * `_.reduce`, `_.reduceRight`, and `_.transform`.\r\n     *\r\n     * The guarded methods are:\r\n     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,\r\n     * and `sortBy`\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Collection\r\n     * @param {Array|Object} collection The collection to iterate over.\r\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\r\n     * @param {*} [accumulator] The initial value.\r\n     * @returns {*} Returns the accumulated value.\r\n     * @see _.reduceRight\r\n     * @example\r\n     *\r\n     * _.reduce([1, 2], function(sum, n) {\r\n     *   return sum + n;\r\n     * }, 0);\r\n     * // => 3\r\n     *\r\n     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\r\n     *   (result[value] || (result[value] = [])).push(key);\r\n     *   return result;\r\n     * }, {});\r\n     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)\r\n     */\r\n    function reduce(collection, iteratee, accumulator) {\r\n      var func = isArray(collection) ? arrayReduce : baseReduce,\r\n          initAccum = arguments.length < 3;\r\n\r\n      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);\r\n    }\r\n\r\n    /**\r\n     * This method is like `_.reduce` except that it iterates over elements of\r\n     * `collection` from right to left.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Collection\r\n     * @param {Array|Object} collection The collection to iterate over.\r\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\r\n     * @param {*} [accumulator] The initial value.\r\n     * @returns {*} Returns the accumulated value.\r\n     * @see _.reduce\r\n     * @example\r\n     *\r\n     * var array = [[0, 1], [2, 3], [4, 5]];\r\n     *\r\n     * _.reduceRight(array, function(flattened, other) {\r\n     *   return flattened.concat(other);\r\n     * }, []);\r\n     * // => [4, 5, 2, 3, 0, 1]\r\n     */\r\n    function reduceRight(collection, iteratee, accumulator) {\r\n      var func = isArray(collection) ? arrayReduceRight : baseReduce,\r\n          initAccum = arguments.length < 3;\r\n\r\n      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);\r\n    }\r\n\r\n    /**\r\n     * The opposite of `_.filter`; this method returns the elements of `collection`\r\n     * that `predicate` does **not** return truthy for.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Collection\r\n     * @param {Array|Object} collection The collection to iterate over.\r\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\r\n     * @returns {Array} Returns the new filtered array.\r\n     * @see _.filter\r\n     * @example\r\n     *\r\n     * var users = [\r\n     *   { 'user': 'barney', 'age': 36, 'active': false },\r\n     *   { 'user': 'fred',   'age': 40, 'active': true }\r\n     * ];\r\n     *\r\n     * _.reject(users, function(o) { return !o.active; });\r\n     * // => objects for ['fred']\r\n     *\r\n     * // The `_.matches` iteratee shorthand.\r\n     * _.reject(users, { 'age': 40, 'active': true });\r\n     * // => objects for ['barney']\r\n     *\r\n     * // The `_.matchesProperty` iteratee shorthand.\r\n     * _.reject(users, ['active', false]);\r\n     * // => objects for ['fred']\r\n     *\r\n     * // The `_.property` iteratee shorthand.\r\n     * _.reject(users, 'active');\r\n     * // => objects for ['barney']\r\n     */\r\n    function reject(collection, predicate) {\r\n      var func = isArray(collection) ? arrayFilter : baseFilter;\r\n      return func(collection, negate(getIteratee(predicate, 3)));\r\n    }\r\n\r\n    /**\r\n     * Gets a random element from `collection`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 2.0.0\r\n     * @category Collection\r\n     * @param {Array|Object} collection The collection to sample.\r\n     * @returns {*} Returns the random element.\r\n     * @example\r\n     *\r\n     * _.sample([1, 2, 3, 4]);\r\n     * // => 2\r\n     */\r\n    function sample(collection) {\r\n      var func = isArray(collection) ? arraySample : baseSample;\r\n      return func(collection);\r\n    }\r\n\r\n    /**\r\n     * Gets `n` random elements at unique keys from `collection` up to the\r\n     * size of `collection`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Collection\r\n     * @param {Array|Object} collection The collection to sample.\r\n     * @param {number} [n=1] The number of elements to sample.\r\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\r\n     * @returns {Array} Returns the random elements.\r\n     * @example\r\n     *\r\n     * _.sampleSize([1, 2, 3], 2);\r\n     * // => [3, 1]\r\n     *\r\n     * _.sampleSize([1, 2, 3], 4);\r\n     * // => [2, 3, 1]\r\n     */\r\n    function sampleSize(collection, n, guard) {\r\n      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {\r\n        n = 1;\r\n      } else {\r\n        n = toInteger(n);\r\n      }\r\n      var func = isArray(collection) ? arraySampleSize : baseSampleSize;\r\n      return func(collection, n);\r\n    }\r\n\r\n    /**\r\n     * Creates an array of shuffled values, using a version of the\r\n     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Collection\r\n     * @param {Array|Object} collection The collection to shuffle.\r\n     * @returns {Array} Returns the new shuffled array.\r\n     * @example\r\n     *\r\n     * _.shuffle([1, 2, 3, 4]);\r\n     * // => [4, 1, 3, 2]\r\n     */\r\n    function shuffle(collection) {\r\n      var func = isArray(collection) ? arrayShuffle : baseShuffle;\r\n      return func(collection);\r\n    }\r\n\r\n    /**\r\n     * Gets the size of `collection` by returning its length for array-like\r\n     * values or the number of own enumerable string keyed properties for objects.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Collection\r\n     * @param {Array|Object|string} collection The collection to inspect.\r\n     * @returns {number} Returns the collection size.\r\n     * @example\r\n     *\r\n     * _.size([1, 2, 3]);\r\n     * // => 3\r\n     *\r\n     * _.size({ 'a': 1, 'b': 2 });\r\n     * // => 2\r\n     *\r\n     * _.size('pebbles');\r\n     * // => 7\r\n     */\r\n    function size(collection) {\r\n      if (collection == null) {\r\n        return 0;\r\n      }\r\n      if (isArrayLike(collection)) {\r\n        return isString(collection) ? stringSize(collection) : collection.length;\r\n      }\r\n      var tag = getTag(collection);\r\n      if (tag == mapTag || tag == setTag) {\r\n        return collection.size;\r\n      }\r\n      return baseKeys(collection).length;\r\n    }\r\n\r\n    /**\r\n     * Checks if `predicate` returns truthy for **any** element of `collection`.\r\n     * Iteration is stopped once `predicate` returns truthy. The predicate is\r\n     * invoked with three arguments: (value, index|key, collection).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Collection\r\n     * @param {Array|Object} collection The collection to iterate over.\r\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\r\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\r\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\r\n     *  else `false`.\r\n     * @example\r\n     *\r\n     * _.some([null, 0, 'yes', false], Boolean);\r\n     * // => true\r\n     *\r\n     * var users = [\r\n     *   { 'user': 'barney', 'active': true },\r\n     *   { 'user': 'fred',   'active': false }\r\n     * ];\r\n     *\r\n     * // The `_.matches` iteratee shorthand.\r\n     * _.some(users, { 'user': 'barney', 'active': false });\r\n     * // => false\r\n     *\r\n     * // The `_.matchesProperty` iteratee shorthand.\r\n     * _.some(users, ['active', false]);\r\n     * // => true\r\n     *\r\n     * // The `_.property` iteratee shorthand.\r\n     * _.some(users, 'active');\r\n     * // => true\r\n     */\r\n    function some(collection, predicate, guard) {\r\n      var func = isArray(collection) ? arraySome : baseSome;\r\n      if (guard && isIterateeCall(collection, predicate, guard)) {\r\n        predicate = undefined;\r\n      }\r\n      return func(collection, getIteratee(predicate, 3));\r\n    }\r\n\r\n    /**\r\n     * Creates an array of elements, sorted in ascending order by the results of\r\n     * running each element in a collection thru each iteratee. This method\r\n     * performs a stable sort, that is, it preserves the original sort order of\r\n     * equal elements. The iteratees are invoked with one argument: (value).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Collection\r\n     * @param {Array|Object} collection The collection to iterate over.\r\n     * @param {...(Function|Function[])} [iteratees=[_.identity]]\r\n     *  The iteratees to sort by.\r\n     * @returns {Array} Returns the new sorted array.\r\n     * @example\r\n     *\r\n     * var users = [\r\n     *   { 'user': 'fred',   'age': 48 },\r\n     *   { 'user': 'barney', 'age': 36 },\r\n     *   { 'user': 'fred',   'age': 30 },\r\n     *   { 'user': 'barney', 'age': 34 }\r\n     * ];\r\n     *\r\n     * _.sortBy(users, [function(o) { return o.user; }]);\r\n     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]\r\n     *\r\n     * _.sortBy(users, ['user', 'age']);\r\n     * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]\r\n     */\r\n    var sortBy = baseRest(function(collection, iteratees) {\r\n      if (collection == null) {\r\n        return [];\r\n      }\r\n      var length = iteratees.length;\r\n      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\r\n        iteratees = [];\r\n      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\r\n        iteratees = [iteratees[0]];\r\n      }\r\n      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);\r\n    });\r\n\r\n    /*------------------------------------------------------------------------*/\r\n\r\n    /**\r\n     * Gets the timestamp of the number of milliseconds that have elapsed since\r\n     * the Unix epoch (1 January 1970 00:00:00 UTC).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 2.4.0\r\n     * @category Date\r\n     * @returns {number} Returns the timestamp.\r\n     * @example\r\n     *\r\n     * _.defer(function(stamp) {\r\n     *   console.log(_.now() - stamp);\r\n     * }, _.now());\r\n     * // => Logs the number of milliseconds it took for the deferred invocation.\r\n     */\r\n    var now = ctxNow || function() {\r\n      return root.Date.now();\r\n    };\r\n\r\n    /*------------------------------------------------------------------------*/\r\n\r\n    /**\r\n     * The opposite of `_.before`; this method creates a function that invokes\r\n     * `func` once it's called `n` or more times.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Function\r\n     * @param {number} n The number of calls before `func` is invoked.\r\n     * @param {Function} func The function to restrict.\r\n     * @returns {Function} Returns the new restricted function.\r\n     * @example\r\n     *\r\n     * var saves = ['profile', 'settings'];\r\n     *\r\n     * var done = _.after(saves.length, function() {\r\n     *   console.log('done saving!');\r\n     * });\r\n     *\r\n     * _.forEach(saves, function(type) {\r\n     *   asyncSave({ 'type': type, 'complete': done });\r\n     * });\r\n     * // => Logs 'done saving!' after the two async saves have completed.\r\n     */\r\n    function after(n, func) {\r\n      if (typeof func != 'function') {\r\n        throw new TypeError(FUNC_ERROR_TEXT);\r\n      }\r\n      n = toInteger(n);\r\n      return function() {\r\n        if (--n < 1) {\r\n          return func.apply(this, arguments);\r\n        }\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Creates a function that invokes `func`, with up to `n` arguments,\r\n     * ignoring any additional arguments.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.0.0\r\n     * @category Function\r\n     * @param {Function} func The function to cap arguments for.\r\n     * @param {number} [n=func.length] The arity cap.\r\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\r\n     * @returns {Function} Returns the new capped function.\r\n     * @example\r\n     *\r\n     * _.map(['6', '8', '10'], _.ary(parseInt, 1));\r\n     * // => [6, 8, 10]\r\n     */\r\n    function ary(func, n, guard) {\r\n      n = guard ? undefined : n;\r\n      n = (func && n == null) ? func.length : n;\r\n      return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);\r\n    }\r\n\r\n    /**\r\n     * Creates a function that invokes `func`, with the `this` binding and arguments\r\n     * of the created function, while it's called less than `n` times. Subsequent\r\n     * calls to the created function return the result of the last `func` invocation.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.0.0\r\n     * @category Function\r\n     * @param {number} n The number of calls at which `func` is no longer invoked.\r\n     * @param {Function} func The function to restrict.\r\n     * @returns {Function} Returns the new restricted function.\r\n     * @example\r\n     *\r\n     * jQuery(element).on('click', _.before(5, addContactToList));\r\n     * // => Allows adding up to 4 contacts to the list.\r\n     */\r\n    function before(n, func) {\r\n      var result;\r\n      if (typeof func != 'function') {\r\n        throw new TypeError(FUNC_ERROR_TEXT);\r\n      }\r\n      n = toInteger(n);\r\n      return function() {\r\n        if (--n > 0) {\r\n          result = func.apply(this, arguments);\r\n        }\r\n        if (n <= 1) {\r\n          func = undefined;\r\n        }\r\n        return result;\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Creates a function that invokes `func` with the `this` binding of `thisArg`\r\n     * and `partials` prepended to the arguments it receives.\r\n     *\r\n     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,\r\n     * may be used as a placeholder for partially applied arguments.\r\n     *\r\n     * **Note:** Unlike native `Function#bind`, this method doesn't set the \"length\"\r\n     * property of bound functions.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Function\r\n     * @param {Function} func The function to bind.\r\n     * @param {*} thisArg The `this` binding of `func`.\r\n     * @param {...*} [partials] The arguments to be partially applied.\r\n     * @returns {Function} Returns the new bound function.\r\n     * @example\r\n     *\r\n     * function greet(greeting, punctuation) {\r\n     *   return greeting + ' ' + this.user + punctuation;\r\n     * }\r\n     *\r\n     * var object = { 'user': 'fred' };\r\n     *\r\n     * var bound = _.bind(greet, object, 'hi');\r\n     * bound('!');\r\n     * // => 'hi fred!'\r\n     *\r\n     * // Bound with placeholders.\r\n     * var bound = _.bind(greet, object, _, '!');\r\n     * bound('hi');\r\n     * // => 'hi fred!'\r\n     */\r\n    var bind = baseRest(function(func, thisArg, partials) {\r\n      var bitmask = WRAP_BIND_FLAG;\r\n      if (partials.length) {\r\n        var holders = replaceHolders(partials, getHolder(bind));\r\n        bitmask |= WRAP_PARTIAL_FLAG;\r\n      }\r\n      return createWrap(func, bitmask, thisArg, partials, holders);\r\n    });\r\n\r\n    /**\r\n     * Creates a function that invokes the method at `object[key]` with `partials`\r\n     * prepended to the arguments it receives.\r\n     *\r\n     * This method differs from `_.bind` by allowing bound functions to reference\r\n     * methods that may be redefined or don't yet exist. See\r\n     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)\r\n     * for more details.\r\n     *\r\n     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic\r\n     * builds, may be used as a placeholder for partially applied arguments.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.10.0\r\n     * @category Function\r\n     * @param {Object} object The object to invoke the method on.\r\n     * @param {string} key The key of the method.\r\n     * @param {...*} [partials] The arguments to be partially applied.\r\n     * @returns {Function} Returns the new bound function.\r\n     * @example\r\n     *\r\n     * var object = {\r\n     *   'user': 'fred',\r\n     *   'greet': function(greeting, punctuation) {\r\n     *     return greeting + ' ' + this.user + punctuation;\r\n     *   }\r\n     * };\r\n     *\r\n     * var bound = _.bindKey(object, 'greet', 'hi');\r\n     * bound('!');\r\n     * // => 'hi fred!'\r\n     *\r\n     * object.greet = function(greeting, punctuation) {\r\n     *   return greeting + 'ya ' + this.user + punctuation;\r\n     * };\r\n     *\r\n     * bound('!');\r\n     * // => 'hiya fred!'\r\n     *\r\n     * // Bound with placeholders.\r\n     * var bound = _.bindKey(object, 'greet', _, '!');\r\n     * bound('hi');\r\n     * // => 'hiya fred!'\r\n     */\r\n    var bindKey = baseRest(function(object, key, partials) {\r\n      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;\r\n      if (partials.length) {\r\n        var holders = replaceHolders(partials, getHolder(bindKey));\r\n        bitmask |= WRAP_PARTIAL_FLAG;\r\n      }\r\n      return createWrap(key, bitmask, object, partials, holders);\r\n    });\r\n\r\n    /**\r\n     * Creates a function that accepts arguments of `func` and either invokes\r\n     * `func` returning its result, if at least `arity` number of arguments have\r\n     * been provided, or returns a function that accepts the remaining `func`\r\n     * arguments, and so on. The arity of `func` may be specified if `func.length`\r\n     * is not sufficient.\r\n     *\r\n     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,\r\n     * may be used as a placeholder for provided arguments.\r\n     *\r\n     * **Note:** This method doesn't set the \"length\" property of curried functions.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 2.0.0\r\n     * @category Function\r\n     * @param {Function} func The function to curry.\r\n     * @param {number} [arity=func.length] The arity of `func`.\r\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\r\n     * @returns {Function} Returns the new curried function.\r\n     * @example\r\n     *\r\n     * var abc = function(a, b, c) {\r\n     *   return [a, b, c];\r\n     * };\r\n     *\r\n     * var curried = _.curry(abc);\r\n     *\r\n     * curried(1)(2)(3);\r\n     * // => [1, 2, 3]\r\n     *\r\n     * curried(1, 2)(3);\r\n     * // => [1, 2, 3]\r\n     *\r\n     * curried(1, 2, 3);\r\n     * // => [1, 2, 3]\r\n     *\r\n     * // Curried with placeholders.\r\n     * curried(1)(_, 3)(2);\r\n     * // => [1, 2, 3]\r\n     */\r\n    function curry(func, arity, guard) {\r\n      arity = guard ? undefined : arity;\r\n      var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);\r\n      result.placeholder = curry.placeholder;\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * This method is like `_.curry` except that arguments are applied to `func`\r\n     * in the manner of `_.partialRight` instead of `_.partial`.\r\n     *\r\n     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic\r\n     * builds, may be used as a placeholder for provided arguments.\r\n     *\r\n     * **Note:** This method doesn't set the \"length\" property of curried functions.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.0.0\r\n     * @category Function\r\n     * @param {Function} func The function to curry.\r\n     * @param {number} [arity=func.length] The arity of `func`.\r\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\r\n     * @returns {Function} Returns the new curried function.\r\n     * @example\r\n     *\r\n     * var abc = function(a, b, c) {\r\n     *   return [a, b, c];\r\n     * };\r\n     *\r\n     * var curried = _.curryRight(abc);\r\n     *\r\n     * curried(3)(2)(1);\r\n     * // => [1, 2, 3]\r\n     *\r\n     * curried(2, 3)(1);\r\n     * // => [1, 2, 3]\r\n     *\r\n     * curried(1, 2, 3);\r\n     * // => [1, 2, 3]\r\n     *\r\n     * // Curried with placeholders.\r\n     * curried(3)(1, _)(2);\r\n     * // => [1, 2, 3]\r\n     */\r\n    function curryRight(func, arity, guard) {\r\n      arity = guard ? undefined : arity;\r\n      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);\r\n      result.placeholder = curryRight.placeholder;\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a debounced function that delays invoking `func` until after `wait`\r\n     * milliseconds have elapsed since the last time the debounced function was\r\n     * invoked. The debounced function comes with a `cancel` method to cancel\r\n     * delayed `func` invocations and a `flush` method to immediately invoke them.\r\n     * Provide `options` to indicate whether `func` should be invoked on the\r\n     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\r\n     * with the last arguments provided to the debounced function. Subsequent\r\n     * calls to the debounced function return the result of the last `func`\r\n     * invocation.\r\n     *\r\n     * **Note:** If `leading` and `trailing` options are `true`, `func` is\r\n     * invoked on the trailing edge of the timeout only if the debounced function\r\n     * is invoked more than once during the `wait` timeout.\r\n     *\r\n     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\r\n     * until to the next tick, similar to `setTimeout` with a timeout of `0`.\r\n     *\r\n     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\r\n     * for details over the differences between `_.debounce` and `_.throttle`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Function\r\n     * @param {Function} func The function to debounce.\r\n     * @param {number} [wait=0] The number of milliseconds to delay.\r\n     * @param {Object} [options={}] The options object.\r\n     * @param {boolean} [options.leading=false]\r\n     *  Specify invoking on the leading edge of the timeout.\r\n     * @param {number} [options.maxWait]\r\n     *  The maximum time `func` is allowed to be delayed before it's invoked.\r\n     * @param {boolean} [options.trailing=true]\r\n     *  Specify invoking on the trailing edge of the timeout.\r\n     * @returns {Function} Returns the new debounced function.\r\n     * @example\r\n     *\r\n     * // Avoid costly calculations while the window size is in flux.\r\n     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\r\n     *\r\n     * // Invoke `sendMail` when clicked, debouncing subsequent calls.\r\n     * jQuery(element).on('click', _.debounce(sendMail, 300, {\r\n     *   'leading': true,\r\n     *   'trailing': false\r\n     * }));\r\n     *\r\n     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\r\n     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\r\n     * var source = new EventSource('/stream');\r\n     * jQuery(source).on('message', debounced);\r\n     *\r\n     * // Cancel the trailing debounced invocation.\r\n     * jQuery(window).on('popstate', debounced.cancel);\r\n     */\r\n    function debounce(func, wait, options) {\r\n      var lastArgs,\r\n          lastThis,\r\n          maxWait,\r\n          result,\r\n          timerId,\r\n          lastCallTime,\r\n          lastInvokeTime = 0,\r\n          leading = false,\r\n          maxing = false,\r\n          trailing = true;\r\n\r\n      if (typeof func != 'function') {\r\n        throw new TypeError(FUNC_ERROR_TEXT);\r\n      }\r\n      wait = toNumber(wait) || 0;\r\n      if (isObject(options)) {\r\n        leading = !!options.leading;\r\n        maxing = 'maxWait' in options;\r\n        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\r\n        trailing = 'trailing' in options ? !!options.trailing : trailing;\r\n      }\r\n\r\n      function invokeFunc(time) {\r\n        var args = lastArgs,\r\n            thisArg = lastThis;\r\n\r\n        lastArgs = lastThis = undefined;\r\n        lastInvokeTime = time;\r\n        result = func.apply(thisArg, args);\r\n        return result;\r\n      }\r\n\r\n      function leadingEdge(time) {\r\n        // Reset any `maxWait` timer.\r\n        lastInvokeTime = time;\r\n        // Start the timer for the trailing edge.\r\n        timerId = setTimeout(timerExpired, wait);\r\n        // Invoke the leading edge.\r\n        return leading ? invokeFunc(time) : result;\r\n      }\r\n\r\n      function remainingWait(time) {\r\n        var timeSinceLastCall = time - lastCallTime,\r\n            timeSinceLastInvoke = time - lastInvokeTime,\r\n            timeWaiting = wait - timeSinceLastCall;\r\n\r\n        return maxing\r\n          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\r\n          : timeWaiting;\r\n      }\r\n\r\n      function shouldInvoke(time) {\r\n        var timeSinceLastCall = time - lastCallTime,\r\n            timeSinceLastInvoke = time - lastInvokeTime;\r\n\r\n        // Either this is the first call, activity has stopped and we're at the\r\n        // trailing edge, the system time has gone backwards and we're treating\r\n        // it as the trailing edge, or we've hit the `maxWait` limit.\r\n        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\r\n          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\r\n      }\r\n\r\n      function timerExpired() {\r\n        var time = now();\r\n        if (shouldInvoke(time)) {\r\n          return trailingEdge(time);\r\n        }\r\n        // Restart the timer.\r\n        timerId = setTimeout(timerExpired, remainingWait(time));\r\n      }\r\n\r\n      function trailingEdge(time) {\r\n        timerId = undefined;\r\n\r\n        // Only invoke if we have `lastArgs` which means `func` has been\r\n        // debounced at least once.\r\n        if (trailing && lastArgs) {\r\n          return invokeFunc(time);\r\n        }\r\n        lastArgs = lastThis = undefined;\r\n        return result;\r\n      }\r\n\r\n      function cancel() {\r\n        if (timerId !== undefined) {\r\n          clearTimeout(timerId);\r\n        }\r\n        lastInvokeTime = 0;\r\n        lastArgs = lastCallTime = lastThis = timerId = undefined;\r\n      }\r\n\r\n      function flush() {\r\n        return timerId === undefined ? result : trailingEdge(now());\r\n      }\r\n\r\n      function debounced() {\r\n        var time = now(),\r\n            isInvoking = shouldInvoke(time);\r\n\r\n        lastArgs = arguments;\r\n        lastThis = this;\r\n        lastCallTime = time;\r\n\r\n        if (isInvoking) {\r\n          if (timerId === undefined) {\r\n            return leadingEdge(lastCallTime);\r\n          }\r\n          if (maxing) {\r\n            // Handle invocations in a tight loop.\r\n            clearTimeout(timerId);\r\n            timerId = setTimeout(timerExpired, wait);\r\n            return invokeFunc(lastCallTime);\r\n          }\r\n        }\r\n        if (timerId === undefined) {\r\n          timerId = setTimeout(timerExpired, wait);\r\n        }\r\n        return result;\r\n      }\r\n      debounced.cancel = cancel;\r\n      debounced.flush = flush;\r\n      return debounced;\r\n    }\r\n\r\n    /**\r\n     * Defers invoking the `func` until the current call stack has cleared. Any\r\n     * additional arguments are provided to `func` when it's invoked.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Function\r\n     * @param {Function} func The function to defer.\r\n     * @param {...*} [args] The arguments to invoke `func` with.\r\n     * @returns {number} Returns the timer id.\r\n     * @example\r\n     *\r\n     * _.defer(function(text) {\r\n     *   console.log(text);\r\n     * }, 'deferred');\r\n     * // => Logs 'deferred' after one millisecond.\r\n     */\r\n    var defer = baseRest(function(func, args) {\r\n      return baseDelay(func, 1, args);\r\n    });\r\n\r\n    /**\r\n     * Invokes `func` after `wait` milliseconds. Any additional arguments are\r\n     * provided to `func` when it's invoked.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Function\r\n     * @param {Function} func The function to delay.\r\n     * @param {number} wait The number of milliseconds to delay invocation.\r\n     * @param {...*} [args] The arguments to invoke `func` with.\r\n     * @returns {number} Returns the timer id.\r\n     * @example\r\n     *\r\n     * _.delay(function(text) {\r\n     *   console.log(text);\r\n     * }, 1000, 'later');\r\n     * // => Logs 'later' after one second.\r\n     */\r\n    var delay = baseRest(function(func, wait, args) {\r\n      return baseDelay(func, toNumber(wait) || 0, args);\r\n    });\r\n\r\n    /**\r\n     * Creates a function that invokes `func` with arguments reversed.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Function\r\n     * @param {Function} func The function to flip arguments for.\r\n     * @returns {Function} Returns the new flipped function.\r\n     * @example\r\n     *\r\n     * var flipped = _.flip(function() {\r\n     *   return _.toArray(arguments);\r\n     * });\r\n     *\r\n     * flipped('a', 'b', 'c', 'd');\r\n     * // => ['d', 'c', 'b', 'a']\r\n     */\r\n    function flip(func) {\r\n      return createWrap(func, WRAP_FLIP_FLAG);\r\n    }\r\n\r\n    /**\r\n     * Creates a function that memoizes the result of `func`. If `resolver` is\r\n     * provided, it determines the cache key for storing the result based on the\r\n     * arguments provided to the memoized function. By default, the first argument\r\n     * provided to the memoized function is used as the map cache key. The `func`\r\n     * is invoked with the `this` binding of the memoized function.\r\n     *\r\n     * **Note:** The cache is exposed as the `cache` property on the memoized\r\n     * function. Its creation may be customized by replacing the `_.memoize.Cache`\r\n     * constructor with one whose instances implement the\r\n     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\r\n     * method interface of `clear`, `delete`, `get`, `has`, and `set`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Function\r\n     * @param {Function} func The function to have its output memoized.\r\n     * @param {Function} [resolver] The function to resolve the cache key.\r\n     * @returns {Function} Returns the new memoized function.\r\n     * @example\r\n     *\r\n     * var object = { 'a': 1, 'b': 2 };\r\n     * var other = { 'c': 3, 'd': 4 };\r\n     *\r\n     * var values = _.memoize(_.values);\r\n     * values(object);\r\n     * // => [1, 2]\r\n     *\r\n     * values(other);\r\n     * // => [3, 4]\r\n     *\r\n     * object.a = 2;\r\n     * values(object);\r\n     * // => [1, 2]\r\n     *\r\n     * // Modify the result cache.\r\n     * values.cache.set(object, ['a', 'b']);\r\n     * values(object);\r\n     * // => ['a', 'b']\r\n     *\r\n     * // Replace `_.memoize.Cache`.\r\n     * _.memoize.Cache = WeakMap;\r\n     */\r\n    function memoize(func, resolver) {\r\n      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\r\n        throw new TypeError(FUNC_ERROR_TEXT);\r\n      }\r\n      var memoized = function() {\r\n        var args = arguments,\r\n            key = resolver ? resolver.apply(this, args) : args[0],\r\n            cache = memoized.cache;\r\n\r\n        if (cache.has(key)) {\r\n          return cache.get(key);\r\n        }\r\n        var result = func.apply(this, args);\r\n        memoized.cache = cache.set(key, result) || cache;\r\n        return result;\r\n      };\r\n      memoized.cache = new (memoize.Cache || MapCache);\r\n      return memoized;\r\n    }\r\n\r\n    // Expose `MapCache`.\r\n    memoize.Cache = MapCache;\r\n\r\n    /**\r\n     * Creates a function that negates the result of the predicate `func`. The\r\n     * `func` predicate is invoked with the `this` binding and arguments of the\r\n     * created function.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.0.0\r\n     * @category Function\r\n     * @param {Function} predicate The predicate to negate.\r\n     * @returns {Function} Returns the new negated function.\r\n     * @example\r\n     *\r\n     * function isEven(n) {\r\n     *   return n % 2 == 0;\r\n     * }\r\n     *\r\n     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));\r\n     * // => [1, 3, 5]\r\n     */\r\n    function negate(predicate) {\r\n      if (typeof predicate != 'function') {\r\n        throw new TypeError(FUNC_ERROR_TEXT);\r\n      }\r\n      return function() {\r\n        var args = arguments;\r\n        switch (args.length) {\r\n          case 0: return !predicate.call(this);\r\n          case 1: return !predicate.call(this, args[0]);\r\n          case 2: return !predicate.call(this, args[0], args[1]);\r\n          case 3: return !predicate.call(this, args[0], args[1], args[2]);\r\n        }\r\n        return !predicate.apply(this, args);\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Creates a function that is restricted to invoking `func` once. Repeat calls\r\n     * to the function return the value of the first invocation. The `func` is\r\n     * invoked with the `this` binding and arguments of the created function.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Function\r\n     * @param {Function} func The function to restrict.\r\n     * @returns {Function} Returns the new restricted function.\r\n     * @example\r\n     *\r\n     * var initialize = _.once(createApplication);\r\n     * initialize();\r\n     * initialize();\r\n     * // => `createApplication` is invoked once\r\n     */\r\n    function once(func) {\r\n      return before(2, func);\r\n    }\r\n\r\n    /**\r\n     * Creates a function that invokes `func` with its arguments transformed.\r\n     *\r\n     * @static\r\n     * @since 4.0.0\r\n     * @memberOf _\r\n     * @category Function\r\n     * @param {Function} func The function to wrap.\r\n     * @param {...(Function|Function[])} [transforms=[_.identity]]\r\n     *  The argument transforms.\r\n     * @returns {Function} Returns the new function.\r\n     * @example\r\n     *\r\n     * function doubled(n) {\r\n     *   return n * 2;\r\n     * }\r\n     *\r\n     * function square(n) {\r\n     *   return n * n;\r\n     * }\r\n     *\r\n     * var func = _.overArgs(function(x, y) {\r\n     *   return [x, y];\r\n     * }, [square, doubled]);\r\n     *\r\n     * func(9, 3);\r\n     * // => [81, 6]\r\n     *\r\n     * func(10, 5);\r\n     * // => [100, 10]\r\n     */\r\n    var overArgs = castRest(function(func, transforms) {\r\n      transforms = (transforms.length == 1 && isArray(transforms[0]))\r\n        ? arrayMap(transforms[0], baseUnary(getIteratee()))\r\n        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));\r\n\r\n      var funcsLength = transforms.length;\r\n      return baseRest(function(args) {\r\n        var index = -1,\r\n            length = nativeMin(args.length, funcsLength);\r\n\r\n        while (++index < length) {\r\n          args[index] = transforms[index].call(this, args[index]);\r\n        }\r\n        return apply(func, this, args);\r\n      });\r\n    });\r\n\r\n    /**\r\n     * Creates a function that invokes `func` with `partials` prepended to the\r\n     * arguments it receives. This method is like `_.bind` except it does **not**\r\n     * alter the `this` binding.\r\n     *\r\n     * The `_.partial.placeholder` value, which defaults to `_` in monolithic\r\n     * builds, may be used as a placeholder for partially applied arguments.\r\n     *\r\n     * **Note:** This method doesn't set the \"length\" property of partially\r\n     * applied functions.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.2.0\r\n     * @category Function\r\n     * @param {Function} func The function to partially apply arguments to.\r\n     * @param {...*} [partials] The arguments to be partially applied.\r\n     * @returns {Function} Returns the new partially applied function.\r\n     * @example\r\n     *\r\n     * function greet(greeting, name) {\r\n     *   return greeting + ' ' + name;\r\n     * }\r\n     *\r\n     * var sayHelloTo = _.partial(greet, 'hello');\r\n     * sayHelloTo('fred');\r\n     * // => 'hello fred'\r\n     *\r\n     * // Partially applied with placeholders.\r\n     * var greetFred = _.partial(greet, _, 'fred');\r\n     * greetFred('hi');\r\n     * // => 'hi fred'\r\n     */\r\n    var partial = baseRest(function(func, partials) {\r\n      var holders = replaceHolders(partials, getHolder(partial));\r\n      return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);\r\n    });\r\n\r\n    /**\r\n     * This method is like `_.partial` except that partially applied arguments\r\n     * are appended to the arguments it receives.\r\n     *\r\n     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic\r\n     * builds, may be used as a placeholder for partially applied arguments.\r\n     *\r\n     * **Note:** This method doesn't set the \"length\" property of partially\r\n     * applied functions.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 1.0.0\r\n     * @category Function\r\n     * @param {Function} func The function to partially apply arguments to.\r\n     * @param {...*} [partials] The arguments to be partially applied.\r\n     * @returns {Function} Returns the new partially applied function.\r\n     * @example\r\n     *\r\n     * function greet(greeting, name) {\r\n     *   return greeting + ' ' + name;\r\n     * }\r\n     *\r\n     * var greetFred = _.partialRight(greet, 'fred');\r\n     * greetFred('hi');\r\n     * // => 'hi fred'\r\n     *\r\n     * // Partially applied with placeholders.\r\n     * var sayHelloTo = _.partialRight(greet, 'hello', _);\r\n     * sayHelloTo('fred');\r\n     * // => 'hello fred'\r\n     */\r\n    var partialRight = baseRest(function(func, partials) {\r\n      var holders = replaceHolders(partials, getHolder(partialRight));\r\n      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);\r\n    });\r\n\r\n    /**\r\n     * Creates a function that invokes `func` with arguments arranged according\r\n     * to the specified `indexes` where the argument value at the first index is\r\n     * provided as the first argument, the argument value at the second index is\r\n     * provided as the second argument, and so on.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.0.0\r\n     * @category Function\r\n     * @param {Function} func The function to rearrange arguments for.\r\n     * @param {...(number|number[])} indexes The arranged argument indexes.\r\n     * @returns {Function} Returns the new function.\r\n     * @example\r\n     *\r\n     * var rearged = _.rearg(function(a, b, c) {\r\n     *   return [a, b, c];\r\n     * }, [2, 0, 1]);\r\n     *\r\n     * rearged('b', 'c', 'a')\r\n     * // => ['a', 'b', 'c']\r\n     */\r\n    var rearg = flatRest(function(func, indexes) {\r\n      return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);\r\n    });\r\n\r\n    /**\r\n     * Creates a function that invokes `func` with the `this` binding of the\r\n     * created function and arguments from `start` and beyond provided as\r\n     * an array.\r\n     *\r\n     * **Note:** This method is based on the\r\n     * [rest parameter](https://mdn.io/rest_parameters).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Function\r\n     * @param {Function} func The function to apply a rest parameter to.\r\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\r\n     * @returns {Function} Returns the new function.\r\n     * @example\r\n     *\r\n     * var say = _.rest(function(what, names) {\r\n     *   return what + ' ' + _.initial(names).join(', ') +\r\n     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);\r\n     * });\r\n     *\r\n     * say('hello', 'fred', 'barney', 'pebbles');\r\n     * // => 'hello fred, barney, & pebbles'\r\n     */\r\n    function rest(func, start) {\r\n      if (typeof func != 'function') {\r\n        throw new TypeError(FUNC_ERROR_TEXT);\r\n      }\r\n      start = start === undefined ? start : toInteger(start);\r\n      return baseRest(func, start);\r\n    }\r\n\r\n    /**\r\n     * Creates a function that invokes `func` with the `this` binding of the\r\n     * create function and an array of arguments much like\r\n     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).\r\n     *\r\n     * **Note:** This method is based on the\r\n     * [spread operator](https://mdn.io/spread_operator).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.2.0\r\n     * @category Function\r\n     * @param {Function} func The function to spread arguments over.\r\n     * @param {number} [start=0] The start position of the spread.\r\n     * @returns {Function} Returns the new function.\r\n     * @example\r\n     *\r\n     * var say = _.spread(function(who, what) {\r\n     *   return who + ' says ' + what;\r\n     * });\r\n     *\r\n     * say(['fred', 'hello']);\r\n     * // => 'fred says hello'\r\n     *\r\n     * var numbers = Promise.all([\r\n     *   Promise.resolve(40),\r\n     *   Promise.resolve(36)\r\n     * ]);\r\n     *\r\n     * numbers.then(_.spread(function(x, y) {\r\n     *   return x + y;\r\n     * }));\r\n     * // => a Promise of 76\r\n     */\r\n    function spread(func, start) {\r\n      if (typeof func != 'function') {\r\n        throw new TypeError(FUNC_ERROR_TEXT);\r\n      }\r\n      start = start == null ? 0 : nativeMax(toInteger(start), 0);\r\n      return baseRest(function(args) {\r\n        var array = args[start],\r\n            otherArgs = castSlice(args, 0, start);\r\n\r\n        if (array) {\r\n          arrayPush(otherArgs, array);\r\n        }\r\n        return apply(func, this, otherArgs);\r\n      });\r\n    }\r\n\r\n    /**\r\n     * Creates a throttled function that only invokes `func` at most once per\r\n     * every `wait` milliseconds. The throttled function comes with a `cancel`\r\n     * method to cancel delayed `func` invocations and a `flush` method to\r\n     * immediately invoke them. Provide `options` to indicate whether `func`\r\n     * should be invoked on the leading and/or trailing edge of the `wait`\r\n     * timeout. The `func` is invoked with the last arguments provided to the\r\n     * throttled function. Subsequent calls to the throttled function return the\r\n     * result of the last `func` invocation.\r\n     *\r\n     * **Note:** If `leading` and `trailing` options are `true`, `func` is\r\n     * invoked on the trailing edge of the timeout only if the throttled function\r\n     * is invoked more than once during the `wait` timeout.\r\n     *\r\n     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\r\n     * until to the next tick, similar to `setTimeout` with a timeout of `0`.\r\n     *\r\n     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\r\n     * for details over the differences between `_.throttle` and `_.debounce`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Function\r\n     * @param {Function} func The function to throttle.\r\n     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\r\n     * @param {Object} [options={}] The options object.\r\n     * @param {boolean} [options.leading=true]\r\n     *  Specify invoking on the leading edge of the timeout.\r\n     * @param {boolean} [options.trailing=true]\r\n     *  Specify invoking on the trailing edge of the timeout.\r\n     * @returns {Function} Returns the new throttled function.\r\n     * @example\r\n     *\r\n     * // Avoid excessively updating the position while scrolling.\r\n     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\r\n     *\r\n     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\r\n     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\r\n     * jQuery(element).on('click', throttled);\r\n     *\r\n     * // Cancel the trailing throttled invocation.\r\n     * jQuery(window).on('popstate', throttled.cancel);\r\n     */\r\n    function throttle(func, wait, options) {\r\n      var leading = true,\r\n          trailing = true;\r\n\r\n      if (typeof func != 'function') {\r\n        throw new TypeError(FUNC_ERROR_TEXT);\r\n      }\r\n      if (isObject(options)) {\r\n        leading = 'leading' in options ? !!options.leading : leading;\r\n        trailing = 'trailing' in options ? !!options.trailing : trailing;\r\n      }\r\n      return debounce(func, wait, {\r\n        'leading': leading,\r\n        'maxWait': wait,\r\n        'trailing': trailing\r\n      });\r\n    }\r\n\r\n    /**\r\n     * Creates a function that accepts up to one argument, ignoring any\r\n     * additional arguments.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Function\r\n     * @param {Function} func The function to cap arguments for.\r\n     * @returns {Function} Returns the new capped function.\r\n     * @example\r\n     *\r\n     * _.map(['6', '8', '10'], _.unary(parseInt));\r\n     * // => [6, 8, 10]\r\n     */\r\n    function unary(func) {\r\n      return ary(func, 1);\r\n    }\r\n\r\n    /**\r\n     * Creates a function that provides `value` to `wrapper` as its first\r\n     * argument. Any additional arguments provided to the function are appended\r\n     * to those provided to the `wrapper`. The wrapper is invoked with the `this`\r\n     * binding of the created function.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Function\r\n     * @param {*} value The value to wrap.\r\n     * @param {Function} [wrapper=identity] The wrapper function.\r\n     * @returns {Function} Returns the new function.\r\n     * @example\r\n     *\r\n     * var p = _.wrap(_.escape, function(func, text) {\r\n     *   return '<p>' + func(text) + '</p>';\r\n     * });\r\n     *\r\n     * p('fred, barney, & pebbles');\r\n     * // => '<p>fred, barney, &amp; pebbles</p>'\r\n     */\r\n    function wrap(value, wrapper) {\r\n      return partial(castFunction(wrapper), value);\r\n    }\r\n\r\n    /*------------------------------------------------------------------------*/\r\n\r\n    /**\r\n     * Casts `value` as an array if it's not one.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.4.0\r\n     * @category Lang\r\n     * @param {*} value The value to inspect.\r\n     * @returns {Array} Returns the cast array.\r\n     * @example\r\n     *\r\n     * _.castArray(1);\r\n     * // => [1]\r\n     *\r\n     * _.castArray({ 'a': 1 });\r\n     * // => [{ 'a': 1 }]\r\n     *\r\n     * _.castArray('abc');\r\n     * // => ['abc']\r\n     *\r\n     * _.castArray(null);\r\n     * // => [null]\r\n     *\r\n     * _.castArray(undefined);\r\n     * // => [undefined]\r\n     *\r\n     * _.castArray();\r\n     * // => []\r\n     *\r\n     * var array = [1, 2, 3];\r\n     * console.log(_.castArray(array) === array);\r\n     * // => true\r\n     */\r\n    function castArray() {\r\n      if (!arguments.length) {\r\n        return [];\r\n      }\r\n      var value = arguments[0];\r\n      return isArray(value) ? value : [value];\r\n    }\r\n\r\n    /**\r\n     * Creates a shallow clone of `value`.\r\n     *\r\n     * **Note:** This method is loosely based on the\r\n     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\r\n     * and supports cloning arrays, array buffers, booleans, date objects, maps,\r\n     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\r\n     * arrays. The own enumerable properties of `arguments` objects are cloned\r\n     * as plain objects. An empty object is returned for uncloneable values such\r\n     * as error objects, functions, DOM nodes, and WeakMaps.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Lang\r\n     * @param {*} value The value to clone.\r\n     * @returns {*} Returns the cloned value.\r\n     * @see _.cloneDeep\r\n     * @example\r\n     *\r\n     * var objects = [{ 'a': 1 }, { 'b': 2 }];\r\n     *\r\n     * var shallow = _.clone(objects);\r\n     * console.log(shallow[0] === objects[0]);\r\n     * // => true\r\n     */\r\n    function clone(value) {\r\n      return baseClone(value, CLONE_SYMBOLS_FLAG);\r\n    }\r\n\r\n    /**\r\n     * This method is like `_.clone` except that it accepts `customizer` which\r\n     * is invoked to produce the cloned value. If `customizer` returns `undefined`,\r\n     * cloning is handled by the method instead. The `customizer` is invoked with\r\n     * up to four arguments; (value [, index|key, object, stack]).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Lang\r\n     * @param {*} value The value to clone.\r\n     * @param {Function} [customizer] The function to customize cloning.\r\n     * @returns {*} Returns the cloned value.\r\n     * @see _.cloneDeepWith\r\n     * @example\r\n     *\r\n     * function customizer(value) {\r\n     *   if (_.isElement(value)) {\r\n     *     return value.cloneNode(false);\r\n     *   }\r\n     * }\r\n     *\r\n     * var el = _.cloneWith(document.body, customizer);\r\n     *\r\n     * console.log(el === document.body);\r\n     * // => false\r\n     * console.log(el.nodeName);\r\n     * // => 'BODY'\r\n     * console.log(el.childNodes.length);\r\n     * // => 0\r\n     */\r\n    function cloneWith(value, customizer) {\r\n      customizer = typeof customizer == 'function' ? customizer : undefined;\r\n      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);\r\n    }\r\n\r\n    /**\r\n     * This method is like `_.clone` except that it recursively clones `value`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 1.0.0\r\n     * @category Lang\r\n     * @param {*} value The value to recursively clone.\r\n     * @returns {*} Returns the deep cloned value.\r\n     * @see _.clone\r\n     * @example\r\n     *\r\n     * var objects = [{ 'a': 1 }, { 'b': 2 }];\r\n     *\r\n     * var deep = _.cloneDeep(objects);\r\n     * console.log(deep[0] === objects[0]);\r\n     * // => false\r\n     */\r\n    function cloneDeep(value) {\r\n      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);\r\n    }\r\n\r\n    /**\r\n     * This method is like `_.cloneWith` except that it recursively clones `value`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Lang\r\n     * @param {*} value The value to recursively clone.\r\n     * @param {Function} [customizer] The function to customize cloning.\r\n     * @returns {*} Returns the deep cloned value.\r\n     * @see _.cloneWith\r\n     * @example\r\n     *\r\n     * function customizer(value) {\r\n     *   if (_.isElement(value)) {\r\n     *     return value.cloneNode(true);\r\n     *   }\r\n     * }\r\n     *\r\n     * var el = _.cloneDeepWith(document.body, customizer);\r\n     *\r\n     * console.log(el === document.body);\r\n     * // => false\r\n     * console.log(el.nodeName);\r\n     * // => 'BODY'\r\n     * console.log(el.childNodes.length);\r\n     * // => 20\r\n     */\r\n    function cloneDeepWith(value, customizer) {\r\n      customizer = typeof customizer == 'function' ? customizer : undefined;\r\n      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);\r\n    }\r\n\r\n    /**\r\n     * Checks if `object` conforms to `source` by invoking the predicate\r\n     * properties of `source` with the corresponding property values of `object`.\r\n     *\r\n     * **Note:** This method is equivalent to `_.conforms` when `source` is\r\n     * partially applied.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.14.0\r\n     * @category Lang\r\n     * @param {Object} object The object to inspect.\r\n     * @param {Object} source The object of property predicates to conform to.\r\n     * @returns {boolean} Returns `true` if `object` conforms, else `false`.\r\n     * @example\r\n     *\r\n     * var object = { 'a': 1, 'b': 2 };\r\n     *\r\n     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });\r\n     * // => true\r\n     *\r\n     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });\r\n     * // => false\r\n     */\r\n    function conformsTo(object, source) {\r\n      return source == null || baseConformsTo(object, source, keys(source));\r\n    }\r\n\r\n    /**\r\n     * Performs a\r\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\r\n     * comparison between two values to determine if they are equivalent.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Lang\r\n     * @param {*} value The value to compare.\r\n     * @param {*} other The other value to compare.\r\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\r\n     * @example\r\n     *\r\n     * var object = { 'a': 1 };\r\n     * var other = { 'a': 1 };\r\n     *\r\n     * _.eq(object, object);\r\n     * // => true\r\n     *\r\n     * _.eq(object, other);\r\n     * // => false\r\n     *\r\n     * _.eq('a', 'a');\r\n     * // => true\r\n     *\r\n     * _.eq('a', Object('a'));\r\n     * // => false\r\n     *\r\n     * _.eq(NaN, NaN);\r\n     * // => true\r\n     */\r\n    function eq(value, other) {\r\n      return value === other || (value !== value && other !== other);\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is greater than `other`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.9.0\r\n     * @category Lang\r\n     * @param {*} value The value to compare.\r\n     * @param {*} other The other value to compare.\r\n     * @returns {boolean} Returns `true` if `value` is greater than `other`,\r\n     *  else `false`.\r\n     * @see _.lt\r\n     * @example\r\n     *\r\n     * _.gt(3, 1);\r\n     * // => true\r\n     *\r\n     * _.gt(3, 3);\r\n     * // => false\r\n     *\r\n     * _.gt(1, 3);\r\n     * // => false\r\n     */\r\n    var gt = createRelationalOperation(baseGt);\r\n\r\n    /**\r\n     * Checks if `value` is greater than or equal to `other`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.9.0\r\n     * @category Lang\r\n     * @param {*} value The value to compare.\r\n     * @param {*} other The other value to compare.\r\n     * @returns {boolean} Returns `true` if `value` is greater than or equal to\r\n     *  `other`, else `false`.\r\n     * @see _.lte\r\n     * @example\r\n     *\r\n     * _.gte(3, 1);\r\n     * // => true\r\n     *\r\n     * _.gte(3, 3);\r\n     * // => true\r\n     *\r\n     * _.gte(1, 3);\r\n     * // => false\r\n     */\r\n    var gte = createRelationalOperation(function(value, other) {\r\n      return value >= other;\r\n    });\r\n\r\n    /**\r\n     * Checks if `value` is likely an `arguments` object.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is an `arguments` object,\r\n     *  else `false`.\r\n     * @example\r\n     *\r\n     * _.isArguments(function() { return arguments; }());\r\n     * // => true\r\n     *\r\n     * _.isArguments([1, 2, 3]);\r\n     * // => false\r\n     */\r\n    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\r\n      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\r\n        !propertyIsEnumerable.call(value, 'callee');\r\n    };\r\n\r\n    /**\r\n     * Checks if `value` is classified as an `Array` object.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is an array, else `false`.\r\n     * @example\r\n     *\r\n     * _.isArray([1, 2, 3]);\r\n     * // => true\r\n     *\r\n     * _.isArray(document.body.children);\r\n     * // => false\r\n     *\r\n     * _.isArray('abc');\r\n     * // => false\r\n     *\r\n     * _.isArray(_.noop);\r\n     * // => false\r\n     */\r\n    var isArray = Array.isArray;\r\n\r\n    /**\r\n     * Checks if `value` is classified as an `ArrayBuffer` object.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.3.0\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.\r\n     * @example\r\n     *\r\n     * _.isArrayBuffer(new ArrayBuffer(2));\r\n     * // => true\r\n     *\r\n     * _.isArrayBuffer(new Array(2));\r\n     * // => false\r\n     */\r\n    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;\r\n\r\n    /**\r\n     * Checks if `value` is array-like. A value is considered array-like if it's\r\n     * not a function and has a `value.length` that's an integer greater than or\r\n     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\r\n     * @example\r\n     *\r\n     * _.isArrayLike([1, 2, 3]);\r\n     * // => true\r\n     *\r\n     * _.isArrayLike(document.body.children);\r\n     * // => true\r\n     *\r\n     * _.isArrayLike('abc');\r\n     * // => true\r\n     *\r\n     * _.isArrayLike(_.noop);\r\n     * // => false\r\n     */\r\n    function isArrayLike(value) {\r\n      return value != null && isLength(value.length) && !isFunction(value);\r\n    }\r\n\r\n    /**\r\n     * This method is like `_.isArrayLike` except that it also checks if `value`\r\n     * is an object.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is an array-like object,\r\n     *  else `false`.\r\n     * @example\r\n     *\r\n     * _.isArrayLikeObject([1, 2, 3]);\r\n     * // => true\r\n     *\r\n     * _.isArrayLikeObject(document.body.children);\r\n     * // => true\r\n     *\r\n     * _.isArrayLikeObject('abc');\r\n     * // => false\r\n     *\r\n     * _.isArrayLikeObject(_.noop);\r\n     * // => false\r\n     */\r\n    function isArrayLikeObject(value) {\r\n      return isObjectLike(value) && isArrayLike(value);\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is classified as a boolean primitive or object.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.\r\n     * @example\r\n     *\r\n     * _.isBoolean(false);\r\n     * // => true\r\n     *\r\n     * _.isBoolean(null);\r\n     * // => false\r\n     */\r\n    function isBoolean(value) {\r\n      return value === true || value === false ||\r\n        (isObjectLike(value) && baseGetTag(value) == boolTag);\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is a buffer.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.3.0\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\r\n     * @example\r\n     *\r\n     * _.isBuffer(new Buffer(2));\r\n     * // => true\r\n     *\r\n     * _.isBuffer(new Uint8Array(2));\r\n     * // => false\r\n     */\r\n    var isBuffer = nativeIsBuffer || stubFalse;\r\n\r\n    /**\r\n     * Checks if `value` is classified as a `Date` object.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\r\n     * @example\r\n     *\r\n     * _.isDate(new Date);\r\n     * // => true\r\n     *\r\n     * _.isDate('Mon April 23 2012');\r\n     * // => false\r\n     */\r\n    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;\r\n\r\n    /**\r\n     * Checks if `value` is likely a DOM element.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.\r\n     * @example\r\n     *\r\n     * _.isElement(document.body);\r\n     * // => true\r\n     *\r\n     * _.isElement('<body>');\r\n     * // => false\r\n     */\r\n    function isElement(value) {\r\n      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is an empty object, collection, map, or set.\r\n     *\r\n     * Objects are considered empty if they have no own enumerable string keyed\r\n     * properties.\r\n     *\r\n     * Array-like values such as `arguments` objects, arrays, buffers, strings, or\r\n     * jQuery-like collections are considered empty if they have a `length` of `0`.\r\n     * Similarly, maps and sets are considered empty if they have a `size` of `0`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is empty, else `false`.\r\n     * @example\r\n     *\r\n     * _.isEmpty(null);\r\n     * // => true\r\n     *\r\n     * _.isEmpty(true);\r\n     * // => true\r\n     *\r\n     * _.isEmpty(1);\r\n     * // => true\r\n     *\r\n     * _.isEmpty([1, 2, 3]);\r\n     * // => false\r\n     *\r\n     * _.isEmpty({ 'a': 1 });\r\n     * // => false\r\n     */\r\n    function isEmpty(value) {\r\n      if (value == null) {\r\n        return true;\r\n      }\r\n      if (isArrayLike(value) &&\r\n          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||\r\n            isBuffer(value) || isTypedArray(value) || isArguments(value))) {\r\n        return !value.length;\r\n      }\r\n      var tag = getTag(value);\r\n      if (tag == mapTag || tag == setTag) {\r\n        return !value.size;\r\n      }\r\n      if (isPrototype(value)) {\r\n        return !baseKeys(value).length;\r\n      }\r\n      for (var key in value) {\r\n        if (hasOwnProperty.call(value, key)) {\r\n          return false;\r\n        }\r\n      }\r\n      return true;\r\n    }\r\n\r\n    /**\r\n     * Performs a deep comparison between two values to determine if they are\r\n     * equivalent.\r\n     *\r\n     * **Note:** This method supports comparing arrays, array buffers, booleans,\r\n     * date objects, error objects, maps, numbers, `Object` objects, regexes,\r\n     * sets, strings, symbols, and typed arrays. `Object` objects are compared\r\n     * by their own, not inherited, enumerable properties. Functions and DOM\r\n     * nodes are compared by strict equality, i.e. `===`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Lang\r\n     * @param {*} value The value to compare.\r\n     * @param {*} other The other value to compare.\r\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\r\n     * @example\r\n     *\r\n     * var object = { 'a': 1 };\r\n     * var other = { 'a': 1 };\r\n     *\r\n     * _.isEqual(object, other);\r\n     * // => true\r\n     *\r\n     * object === other;\r\n     * // => false\r\n     */\r\n    function isEqual(value, other) {\r\n      return baseIsEqual(value, other);\r\n    }\r\n\r\n    /**\r\n     * This method is like `_.isEqual` except that it accepts `customizer` which\r\n     * is invoked to compare values. If `customizer` returns `undefined`, comparisons\r\n     * are handled by the method instead. The `customizer` is invoked with up to\r\n     * six arguments: (objValue, othValue [, index|key, object, other, stack]).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Lang\r\n     * @param {*} value The value to compare.\r\n     * @param {*} other The other value to compare.\r\n     * @param {Function} [customizer] The function to customize comparisons.\r\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\r\n     * @example\r\n     *\r\n     * function isGreeting(value) {\r\n     *   return /^h(?:i|ello)$/.test(value);\r\n     * }\r\n     *\r\n     * function customizer(objValue, othValue) {\r\n     *   if (isGreeting(objValue) && isGreeting(othValue)) {\r\n     *     return true;\r\n     *   }\r\n     * }\r\n     *\r\n     * var array = ['hello', 'goodbye'];\r\n     * var other = ['hi', 'goodbye'];\r\n     *\r\n     * _.isEqualWith(array, other, customizer);\r\n     * // => true\r\n     */\r\n    function isEqualWith(value, other, customizer) {\r\n      customizer = typeof customizer == 'function' ? customizer : undefined;\r\n      var result = customizer ? customizer(value, other) : undefined;\r\n      return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,\r\n     * `SyntaxError`, `TypeError`, or `URIError` object.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.0.0\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.\r\n     * @example\r\n     *\r\n     * _.isError(new Error);\r\n     * // => true\r\n     *\r\n     * _.isError(Error);\r\n     * // => false\r\n     */\r\n    function isError(value) {\r\n      if (!isObjectLike(value)) {\r\n        return false;\r\n      }\r\n      var tag = baseGetTag(value);\r\n      return tag == errorTag || tag == domExcTag ||\r\n        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is a finite primitive number.\r\n     *\r\n     * **Note:** This method is based on\r\n     * [`Number.isFinite`](https://mdn.io/Number/isFinite).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.\r\n     * @example\r\n     *\r\n     * _.isFinite(3);\r\n     * // => true\r\n     *\r\n     * _.isFinite(Number.MIN_VALUE);\r\n     * // => true\r\n     *\r\n     * _.isFinite(Infinity);\r\n     * // => false\r\n     *\r\n     * _.isFinite('3');\r\n     * // => false\r\n     */\r\n    function isFinite(value) {\r\n      return typeof value == 'number' && nativeIsFinite(value);\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is classified as a `Function` object.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is a function, else `false`.\r\n     * @example\r\n     *\r\n     * _.isFunction(_);\r\n     * // => true\r\n     *\r\n     * _.isFunction(/abc/);\r\n     * // => false\r\n     */\r\n    function isFunction(value) {\r\n      if (!isObject(value)) {\r\n        return false;\r\n      }\r\n      // The use of `Object#toString` avoids issues with the `typeof` operator\r\n      // in Safari 9 which returns 'object' for typed arrays and other constructors.\r\n      var tag = baseGetTag(value);\r\n      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is an integer.\r\n     *\r\n     * **Note:** This method is based on\r\n     * [`Number.isInteger`](https://mdn.io/Number/isInteger).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.\r\n     * @example\r\n     *\r\n     * _.isInteger(3);\r\n     * // => true\r\n     *\r\n     * _.isInteger(Number.MIN_VALUE);\r\n     * // => false\r\n     *\r\n     * _.isInteger(Infinity);\r\n     * // => false\r\n     *\r\n     * _.isInteger('3');\r\n     * // => false\r\n     */\r\n    function isInteger(value) {\r\n      return typeof value == 'number' && value == toInteger(value);\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is a valid array-like length.\r\n     *\r\n     * **Note:** This method is loosely based on\r\n     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\r\n     * @example\r\n     *\r\n     * _.isLength(3);\r\n     * // => true\r\n     *\r\n     * _.isLength(Number.MIN_VALUE);\r\n     * // => false\r\n     *\r\n     * _.isLength(Infinity);\r\n     * // => false\r\n     *\r\n     * _.isLength('3');\r\n     * // => false\r\n     */\r\n    function isLength(value) {\r\n      return typeof value == 'number' &&\r\n        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is the\r\n     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\r\n     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is an object, else `false`.\r\n     * @example\r\n     *\r\n     * _.isObject({});\r\n     * // => true\r\n     *\r\n     * _.isObject([1, 2, 3]);\r\n     * // => true\r\n     *\r\n     * _.isObject(_.noop);\r\n     * // => true\r\n     *\r\n     * _.isObject(null);\r\n     * // => false\r\n     */\r\n    function isObject(value) {\r\n      var type = typeof value;\r\n      return value != null && (type == 'object' || type == 'function');\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is object-like. A value is object-like if it's not `null`\r\n     * and has a `typeof` result of \"object\".\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\r\n     * @example\r\n     *\r\n     * _.isObjectLike({});\r\n     * // => true\r\n     *\r\n     * _.isObjectLike([1, 2, 3]);\r\n     * // => true\r\n     *\r\n     * _.isObjectLike(_.noop);\r\n     * // => false\r\n     *\r\n     * _.isObjectLike(null);\r\n     * // => false\r\n     */\r\n    function isObjectLike(value) {\r\n      return value != null && typeof value == 'object';\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is classified as a `Map` object.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.3.0\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is a map, else `false`.\r\n     * @example\r\n     *\r\n     * _.isMap(new Map);\r\n     * // => true\r\n     *\r\n     * _.isMap(new WeakMap);\r\n     * // => false\r\n     */\r\n    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;\r\n\r\n    /**\r\n     * Performs a partial deep comparison between `object` and `source` to\r\n     * determine if `object` contains equivalent property values.\r\n     *\r\n     * **Note:** This method is equivalent to `_.matches` when `source` is\r\n     * partially applied.\r\n     *\r\n     * Partial comparisons will match empty array and empty object `source`\r\n     * values against any array or object value, respectively. See `_.isEqual`\r\n     * for a list of supported value comparisons.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.0.0\r\n     * @category Lang\r\n     * @param {Object} object The object to inspect.\r\n     * @param {Object} source The object of property values to match.\r\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\r\n     * @example\r\n     *\r\n     * var object = { 'a': 1, 'b': 2 };\r\n     *\r\n     * _.isMatch(object, { 'b': 2 });\r\n     * // => true\r\n     *\r\n     * _.isMatch(object, { 'b': 1 });\r\n     * // => false\r\n     */\r\n    function isMatch(object, source) {\r\n      return object === source || baseIsMatch(object, source, getMatchData(source));\r\n    }\r\n\r\n    /**\r\n     * This method is like `_.isMatch` except that it accepts `customizer` which\r\n     * is invoked to compare values. If `customizer` returns `undefined`, comparisons\r\n     * are handled by the method instead. The `customizer` is invoked with five\r\n     * arguments: (objValue, srcValue, index|key, object, source).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Lang\r\n     * @param {Object} object The object to inspect.\r\n     * @param {Object} source The object of property values to match.\r\n     * @param {Function} [customizer] The function to customize comparisons.\r\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\r\n     * @example\r\n     *\r\n     * function isGreeting(value) {\r\n     *   return /^h(?:i|ello)$/.test(value);\r\n     * }\r\n     *\r\n     * function customizer(objValue, srcValue) {\r\n     *   if (isGreeting(objValue) && isGreeting(srcValue)) {\r\n     *     return true;\r\n     *   }\r\n     * }\r\n     *\r\n     * var object = { 'greeting': 'hello' };\r\n     * var source = { 'greeting': 'hi' };\r\n     *\r\n     * _.isMatchWith(object, source, customizer);\r\n     * // => true\r\n     */\r\n    function isMatchWith(object, source, customizer) {\r\n      customizer = typeof customizer == 'function' ? customizer : undefined;\r\n      return baseIsMatch(object, source, getMatchData(source), customizer);\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is `NaN`.\r\n     *\r\n     * **Note:** This method is based on\r\n     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as\r\n     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for\r\n     * `undefined` and other non-number values.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\r\n     * @example\r\n     *\r\n     * _.isNaN(NaN);\r\n     * // => true\r\n     *\r\n     * _.isNaN(new Number(NaN));\r\n     * // => true\r\n     *\r\n     * isNaN(undefined);\r\n     * // => true\r\n     *\r\n     * _.isNaN(undefined);\r\n     * // => false\r\n     */\r\n    function isNaN(value) {\r\n      // An `NaN` primitive is the only value that is not equal to itself.\r\n      // Perform the `toStringTag` check first to avoid errors with some\r\n      // ActiveX objects in IE.\r\n      return isNumber(value) && value != +value;\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is a pristine native function.\r\n     *\r\n     * **Note:** This method can't reliably detect native functions in the presence\r\n     * of the core-js package because core-js circumvents this kind of detection.\r\n     * Despite multiple requests, the core-js maintainer has made it clear: any\r\n     * attempt to fix the detection will be obstructed. As a result, we're left\r\n     * with little choice but to throw an error. Unfortunately, this also affects\r\n     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),\r\n     * which rely on core-js.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.0.0\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is a native function,\r\n     *  else `false`.\r\n     * @example\r\n     *\r\n     * _.isNative(Array.prototype.push);\r\n     * // => true\r\n     *\r\n     * _.isNative(_);\r\n     * // => false\r\n     */\r\n    function isNative(value) {\r\n      if (isMaskable(value)) {\r\n        throw new Error(CORE_ERROR_TEXT);\r\n      }\r\n      return baseIsNative(value);\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is `null`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.\r\n     * @example\r\n     *\r\n     * _.isNull(null);\r\n     * // => true\r\n     *\r\n     * _.isNull(void 0);\r\n     * // => false\r\n     */\r\n    function isNull(value) {\r\n      return value === null;\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is `null` or `undefined`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.\r\n     * @example\r\n     *\r\n     * _.isNil(null);\r\n     * // => true\r\n     *\r\n     * _.isNil(void 0);\r\n     * // => true\r\n     *\r\n     * _.isNil(NaN);\r\n     * // => false\r\n     */\r\n    function isNil(value) {\r\n      return value == null;\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is classified as a `Number` primitive or object.\r\n     *\r\n     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are\r\n     * classified as numbers, use the `_.isFinite` method.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is a number, else `false`.\r\n     * @example\r\n     *\r\n     * _.isNumber(3);\r\n     * // => true\r\n     *\r\n     * _.isNumber(Number.MIN_VALUE);\r\n     * // => true\r\n     *\r\n     * _.isNumber(Infinity);\r\n     * // => true\r\n     *\r\n     * _.isNumber('3');\r\n     * // => false\r\n     */\r\n    function isNumber(value) {\r\n      return typeof value == 'number' ||\r\n        (isObjectLike(value) && baseGetTag(value) == numberTag);\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is a plain object, that is, an object created by the\r\n     * `Object` constructor or one with a `[[Prototype]]` of `null`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.8.0\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\r\n     * @example\r\n     *\r\n     * function Foo() {\r\n     *   this.a = 1;\r\n     * }\r\n     *\r\n     * _.isPlainObject(new Foo);\r\n     * // => false\r\n     *\r\n     * _.isPlainObject([1, 2, 3]);\r\n     * // => false\r\n     *\r\n     * _.isPlainObject({ 'x': 0, 'y': 0 });\r\n     * // => true\r\n     *\r\n     * _.isPlainObject(Object.create(null));\r\n     * // => true\r\n     */\r\n    function isPlainObject(value) {\r\n      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\r\n        return false;\r\n      }\r\n      var proto = getPrototype(value);\r\n      if (proto === null) {\r\n        return true;\r\n      }\r\n      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\r\n      return typeof Ctor == 'function' && Ctor instanceof Ctor &&\r\n        funcToString.call(Ctor) == objectCtorString;\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is classified as a `RegExp` object.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\r\n     * @example\r\n     *\r\n     * _.isRegExp(/abc/);\r\n     * // => true\r\n     *\r\n     * _.isRegExp('/abc/');\r\n     * // => false\r\n     */\r\n    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;\r\n\r\n    /**\r\n     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754\r\n     * double precision number which isn't the result of a rounded unsafe integer.\r\n     *\r\n     * **Note:** This method is based on\r\n     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.\r\n     * @example\r\n     *\r\n     * _.isSafeInteger(3);\r\n     * // => true\r\n     *\r\n     * _.isSafeInteger(Number.MIN_VALUE);\r\n     * // => false\r\n     *\r\n     * _.isSafeInteger(Infinity);\r\n     * // => false\r\n     *\r\n     * _.isSafeInteger('3');\r\n     * // => false\r\n     */\r\n    function isSafeInteger(value) {\r\n      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is classified as a `Set` object.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.3.0\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is a set, else `false`.\r\n     * @example\r\n     *\r\n     * _.isSet(new Set);\r\n     * // => true\r\n     *\r\n     * _.isSet(new WeakSet);\r\n     * // => false\r\n     */\r\n    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\r\n\r\n    /**\r\n     * Checks if `value` is classified as a `String` primitive or object.\r\n     *\r\n     * @static\r\n     * @since 0.1.0\r\n     * @memberOf _\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is a string, else `false`.\r\n     * @example\r\n     *\r\n     * _.isString('abc');\r\n     * // => true\r\n     *\r\n     * _.isString(1);\r\n     * // => false\r\n     */\r\n    function isString(value) {\r\n      return typeof value == 'string' ||\r\n        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is classified as a `Symbol` primitive or object.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\r\n     * @example\r\n     *\r\n     * _.isSymbol(Symbol.iterator);\r\n     * // => true\r\n     *\r\n     * _.isSymbol('abc');\r\n     * // => false\r\n     */\r\n    function isSymbol(value) {\r\n      return typeof value == 'symbol' ||\r\n        (isObjectLike(value) && baseGetTag(value) == symbolTag);\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is classified as a typed array.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.0.0\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\r\n     * @example\r\n     *\r\n     * _.isTypedArray(new Uint8Array);\r\n     * // => true\r\n     *\r\n     * _.isTypedArray([]);\r\n     * // => false\r\n     */\r\n    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\r\n\r\n    /**\r\n     * Checks if `value` is `undefined`.\r\n     *\r\n     * @static\r\n     * @since 0.1.0\r\n     * @memberOf _\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.\r\n     * @example\r\n     *\r\n     * _.isUndefined(void 0);\r\n     * // => true\r\n     *\r\n     * _.isUndefined(null);\r\n     * // => false\r\n     */\r\n    function isUndefined(value) {\r\n      return value === undefined;\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is classified as a `WeakMap` object.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.3.0\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.\r\n     * @example\r\n     *\r\n     * _.isWeakMap(new WeakMap);\r\n     * // => true\r\n     *\r\n     * _.isWeakMap(new Map);\r\n     * // => false\r\n     */\r\n    function isWeakMap(value) {\r\n      return isObjectLike(value) && getTag(value) == weakMapTag;\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is classified as a `WeakSet` object.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.3.0\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.\r\n     * @example\r\n     *\r\n     * _.isWeakSet(new WeakSet);\r\n     * // => true\r\n     *\r\n     * _.isWeakSet(new Set);\r\n     * // => false\r\n     */\r\n    function isWeakSet(value) {\r\n      return isObjectLike(value) && baseGetTag(value) == weakSetTag;\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is less than `other`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.9.0\r\n     * @category Lang\r\n     * @param {*} value The value to compare.\r\n     * @param {*} other The other value to compare.\r\n     * @returns {boolean} Returns `true` if `value` is less than `other`,\r\n     *  else `false`.\r\n     * @see _.gt\r\n     * @example\r\n     *\r\n     * _.lt(1, 3);\r\n     * // => true\r\n     *\r\n     * _.lt(3, 3);\r\n     * // => false\r\n     *\r\n     * _.lt(3, 1);\r\n     * // => false\r\n     */\r\n    var lt = createRelationalOperation(baseLt);\r\n\r\n    /**\r\n     * Checks if `value` is less than or equal to `other`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.9.0\r\n     * @category Lang\r\n     * @param {*} value The value to compare.\r\n     * @param {*} other The other value to compare.\r\n     * @returns {boolean} Returns `true` if `value` is less than or equal to\r\n     *  `other`, else `false`.\r\n     * @see _.gte\r\n     * @example\r\n     *\r\n     * _.lte(1, 3);\r\n     * // => true\r\n     *\r\n     * _.lte(3, 3);\r\n     * // => true\r\n     *\r\n     * _.lte(3, 1);\r\n     * // => false\r\n     */\r\n    var lte = createRelationalOperation(function(value, other) {\r\n      return value <= other;\r\n    });\r\n\r\n    /**\r\n     * Converts `value` to an array.\r\n     *\r\n     * @static\r\n     * @since 0.1.0\r\n     * @memberOf _\r\n     * @category Lang\r\n     * @param {*} value The value to convert.\r\n     * @returns {Array} Returns the converted array.\r\n     * @example\r\n     *\r\n     * _.toArray({ 'a': 1, 'b': 2 });\r\n     * // => [1, 2]\r\n     *\r\n     * _.toArray('abc');\r\n     * // => ['a', 'b', 'c']\r\n     *\r\n     * _.toArray(1);\r\n     * // => []\r\n     *\r\n     * _.toArray(null);\r\n     * // => []\r\n     */\r\n    function toArray(value) {\r\n      if (!value) {\r\n        return [];\r\n      }\r\n      if (isArrayLike(value)) {\r\n        return isString(value) ? stringToArray(value) : copyArray(value);\r\n      }\r\n      if (symIterator && value[symIterator]) {\r\n        return iteratorToArray(value[symIterator]());\r\n      }\r\n      var tag = getTag(value),\r\n          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);\r\n\r\n      return func(value);\r\n    }\r\n\r\n    /**\r\n     * Converts `value` to a finite number.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.12.0\r\n     * @category Lang\r\n     * @param {*} value The value to convert.\r\n     * @returns {number} Returns the converted number.\r\n     * @example\r\n     *\r\n     * _.toFinite(3.2);\r\n     * // => 3.2\r\n     *\r\n     * _.toFinite(Number.MIN_VALUE);\r\n     * // => 5e-324\r\n     *\r\n     * _.toFinite(Infinity);\r\n     * // => 1.7976931348623157e+308\r\n     *\r\n     * _.toFinite('3.2');\r\n     * // => 3.2\r\n     */\r\n    function toFinite(value) {\r\n      if (!value) {\r\n        return value === 0 ? value : 0;\r\n      }\r\n      value = toNumber(value);\r\n      if (value === INFINITY || value === -INFINITY) {\r\n        var sign = (value < 0 ? -1 : 1);\r\n        return sign * MAX_INTEGER;\r\n      }\r\n      return value === value ? value : 0;\r\n    }\r\n\r\n    /**\r\n     * Converts `value` to an integer.\r\n     *\r\n     * **Note:** This method is loosely based on\r\n     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Lang\r\n     * @param {*} value The value to convert.\r\n     * @returns {number} Returns the converted integer.\r\n     * @example\r\n     *\r\n     * _.toInteger(3.2);\r\n     * // => 3\r\n     *\r\n     * _.toInteger(Number.MIN_VALUE);\r\n     * // => 0\r\n     *\r\n     * _.toInteger(Infinity);\r\n     * // => 1.7976931348623157e+308\r\n     *\r\n     * _.toInteger('3.2');\r\n     * // => 3\r\n     */\r\n    function toInteger(value) {\r\n      var result = toFinite(value),\r\n          remainder = result % 1;\r\n\r\n      return result === result ? (remainder ? result - remainder : result) : 0;\r\n    }\r\n\r\n    /**\r\n     * Converts `value` to an integer suitable for use as the length of an\r\n     * array-like object.\r\n     *\r\n     * **Note:** This method is based on\r\n     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Lang\r\n     * @param {*} value The value to convert.\r\n     * @returns {number} Returns the converted integer.\r\n     * @example\r\n     *\r\n     * _.toLength(3.2);\r\n     * // => 3\r\n     *\r\n     * _.toLength(Number.MIN_VALUE);\r\n     * // => 0\r\n     *\r\n     * _.toLength(Infinity);\r\n     * // => 4294967295\r\n     *\r\n     * _.toLength('3.2');\r\n     * // => 3\r\n     */\r\n    function toLength(value) {\r\n      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;\r\n    }\r\n\r\n    /**\r\n     * Converts `value` to a number.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Lang\r\n     * @param {*} value The value to process.\r\n     * @returns {number} Returns the number.\r\n     * @example\r\n     *\r\n     * _.toNumber(3.2);\r\n     * // => 3.2\r\n     *\r\n     * _.toNumber(Number.MIN_VALUE);\r\n     * // => 5e-324\r\n     *\r\n     * _.toNumber(Infinity);\r\n     * // => Infinity\r\n     *\r\n     * _.toNumber('3.2');\r\n     * // => 3.2\r\n     */\r\n    function toNumber(value) {\r\n      if (typeof value == 'number') {\r\n        return value;\r\n      }\r\n      if (isSymbol(value)) {\r\n        return NAN;\r\n      }\r\n      if (isObject(value)) {\r\n        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\r\n        value = isObject(other) ? (other + '') : other;\r\n      }\r\n      if (typeof value != 'string') {\r\n        return value === 0 ? value : +value;\r\n      }\r\n      value = baseTrim(value);\r\n      var isBinary = reIsBinary.test(value);\r\n      return (isBinary || reIsOctal.test(value))\r\n        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\r\n        : (reIsBadHex.test(value) ? NAN : +value);\r\n    }\r\n\r\n    /**\r\n     * Converts `value` to a plain object flattening inherited enumerable string\r\n     * keyed properties of `value` to own properties of the plain object.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.0.0\r\n     * @category Lang\r\n     * @param {*} value The value to convert.\r\n     * @returns {Object} Returns the converted plain object.\r\n     * @example\r\n     *\r\n     * function Foo() {\r\n     *   this.b = 2;\r\n     * }\r\n     *\r\n     * Foo.prototype.c = 3;\r\n     *\r\n     * _.assign({ 'a': 1 }, new Foo);\r\n     * // => { 'a': 1, 'b': 2 }\r\n     *\r\n     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\r\n     * // => { 'a': 1, 'b': 2, 'c': 3 }\r\n     */\r\n    function toPlainObject(value) {\r\n      return copyObject(value, keysIn(value));\r\n    }\r\n\r\n    /**\r\n     * Converts `value` to a safe integer. A safe integer can be compared and\r\n     * represented correctly.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Lang\r\n     * @param {*} value The value to convert.\r\n     * @returns {number} Returns the converted integer.\r\n     * @example\r\n     *\r\n     * _.toSafeInteger(3.2);\r\n     * // => 3\r\n     *\r\n     * _.toSafeInteger(Number.MIN_VALUE);\r\n     * // => 0\r\n     *\r\n     * _.toSafeInteger(Infinity);\r\n     * // => 9007199254740991\r\n     *\r\n     * _.toSafeInteger('3.2');\r\n     * // => 3\r\n     */\r\n    function toSafeInteger(value) {\r\n      return value\r\n        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)\r\n        : (value === 0 ? value : 0);\r\n    }\r\n\r\n    /**\r\n     * Converts `value` to a string. An empty string is returned for `null`\r\n     * and `undefined` values. The sign of `-0` is preserved.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Lang\r\n     * @param {*} value The value to convert.\r\n     * @returns {string} Returns the converted string.\r\n     * @example\r\n     *\r\n     * _.toString(null);\r\n     * // => ''\r\n     *\r\n     * _.toString(-0);\r\n     * // => '-0'\r\n     *\r\n     * _.toString([1, 2, 3]);\r\n     * // => '1,2,3'\r\n     */\r\n    function toString(value) {\r\n      return value == null ? '' : baseToString(value);\r\n    }\r\n\r\n    /*------------------------------------------------------------------------*/\r\n\r\n    /**\r\n     * Assigns own enumerable string keyed properties of source objects to the\r\n     * destination object. Source objects are applied from left to right.\r\n     * Subsequent sources overwrite property assignments of previous sources.\r\n     *\r\n     * **Note:** This method mutates `object` and is loosely based on\r\n     * [`Object.assign`](https://mdn.io/Object/assign).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.10.0\r\n     * @category Object\r\n     * @param {Object} object The destination object.\r\n     * @param {...Object} [sources] The source objects.\r\n     * @returns {Object} Returns `object`.\r\n     * @see _.assignIn\r\n     * @example\r\n     *\r\n     * function Foo() {\r\n     *   this.a = 1;\r\n     * }\r\n     *\r\n     * function Bar() {\r\n     *   this.c = 3;\r\n     * }\r\n     *\r\n     * Foo.prototype.b = 2;\r\n     * Bar.prototype.d = 4;\r\n     *\r\n     * _.assign({ 'a': 0 }, new Foo, new Bar);\r\n     * // => { 'a': 1, 'c': 3 }\r\n     */\r\n    var assign = createAssigner(function(object, source) {\r\n      if (isPrototype(source) || isArrayLike(source)) {\r\n        copyObject(source, keys(source), object);\r\n        return;\r\n      }\r\n      for (var key in source) {\r\n        if (hasOwnProperty.call(source, key)) {\r\n          assignValue(object, key, source[key]);\r\n        }\r\n      }\r\n    });\r\n\r\n    /**\r\n     * This method is like `_.assign` except that it iterates over own and\r\n     * inherited source properties.\r\n     *\r\n     * **Note:** This method mutates `object`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @alias extend\r\n     * @category Object\r\n     * @param {Object} object The destination object.\r\n     * @param {...Object} [sources] The source objects.\r\n     * @returns {Object} Returns `object`.\r\n     * @see _.assign\r\n     * @example\r\n     *\r\n     * function Foo() {\r\n     *   this.a = 1;\r\n     * }\r\n     *\r\n     * function Bar() {\r\n     *   this.c = 3;\r\n     * }\r\n     *\r\n     * Foo.prototype.b = 2;\r\n     * Bar.prototype.d = 4;\r\n     *\r\n     * _.assignIn({ 'a': 0 }, new Foo, new Bar);\r\n     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }\r\n     */\r\n    var assignIn = createAssigner(function(object, source) {\r\n      copyObject(source, keysIn(source), object);\r\n    });\r\n\r\n    /**\r\n     * This method is like `_.assignIn` except that it accepts `customizer`\r\n     * which is invoked to produce the assigned values. If `customizer` returns\r\n     * `undefined`, assignment is handled by the method instead. The `customizer`\r\n     * is invoked with five arguments: (objValue, srcValue, key, object, source).\r\n     *\r\n     * **Note:** This method mutates `object`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @alias extendWith\r\n     * @category Object\r\n     * @param {Object} object The destination object.\r\n     * @param {...Object} sources The source objects.\r\n     * @param {Function} [customizer] The function to customize assigned values.\r\n     * @returns {Object} Returns `object`.\r\n     * @see _.assignWith\r\n     * @example\r\n     *\r\n     * function customizer(objValue, srcValue) {\r\n     *   return _.isUndefined(objValue) ? srcValue : objValue;\r\n     * }\r\n     *\r\n     * var defaults = _.partialRight(_.assignInWith, customizer);\r\n     *\r\n     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\r\n     * // => { 'a': 1, 'b': 2 }\r\n     */\r\n    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {\r\n      copyObject(source, keysIn(source), object, customizer);\r\n    });\r\n\r\n    /**\r\n     * This method is like `_.assign` except that it accepts `customizer`\r\n     * which is invoked to produce the assigned values. If `customizer` returns\r\n     * `undefined`, assignment is handled by the method instead. The `customizer`\r\n     * is invoked with five arguments: (objValue, srcValue, key, object, source).\r\n     *\r\n     * **Note:** This method mutates `object`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Object\r\n     * @param {Object} object The destination object.\r\n     * @param {...Object} sources The source objects.\r\n     * @param {Function} [customizer] The function to customize assigned values.\r\n     * @returns {Object} Returns `object`.\r\n     * @see _.assignInWith\r\n     * @example\r\n     *\r\n     * function customizer(objValue, srcValue) {\r\n     *   return _.isUndefined(objValue) ? srcValue : objValue;\r\n     * }\r\n     *\r\n     * var defaults = _.partialRight(_.assignWith, customizer);\r\n     *\r\n     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\r\n     * // => { 'a': 1, 'b': 2 }\r\n     */\r\n    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {\r\n      copyObject(source, keys(source), object, customizer);\r\n    });\r\n\r\n    /**\r\n     * Creates an array of values corresponding to `paths` of `object`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 1.0.0\r\n     * @category Object\r\n     * @param {Object} object The object to iterate over.\r\n     * @param {...(string|string[])} [paths] The property paths to pick.\r\n     * @returns {Array} Returns the picked values.\r\n     * @example\r\n     *\r\n     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };\r\n     *\r\n     * _.at(object, ['a[0].b.c', 'a[1]']);\r\n     * // => [3, 4]\r\n     */\r\n    var at = flatRest(baseAt);\r\n\r\n    /**\r\n     * Creates an object that inherits from the `prototype` object. If a\r\n     * `properties` object is given, its own enumerable string keyed properties\r\n     * are assigned to the created object.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 2.3.0\r\n     * @category Object\r\n     * @param {Object} prototype The object to inherit from.\r\n     * @param {Object} [properties] The properties to assign to the object.\r\n     * @returns {Object} Returns the new object.\r\n     * @example\r\n     *\r\n     * function Shape() {\r\n     *   this.x = 0;\r\n     *   this.y = 0;\r\n     * }\r\n     *\r\n     * function Circle() {\r\n     *   Shape.call(this);\r\n     * }\r\n     *\r\n     * Circle.prototype = _.create(Shape.prototype, {\r\n     *   'constructor': Circle\r\n     * });\r\n     *\r\n     * var circle = new Circle;\r\n     * circle instanceof Circle;\r\n     * // => true\r\n     *\r\n     * circle instanceof Shape;\r\n     * // => true\r\n     */\r\n    function create(prototype, properties) {\r\n      var result = baseCreate(prototype);\r\n      return properties == null ? result : baseAssign(result, properties);\r\n    }\r\n\r\n    /**\r\n     * Assigns own and inherited enumerable string keyed properties of source\r\n     * objects to the destination object for all destination properties that\r\n     * resolve to `undefined`. Source objects are applied from left to right.\r\n     * Once a property is set, additional values of the same property are ignored.\r\n     *\r\n     * **Note:** This method mutates `object`.\r\n     *\r\n     * @static\r\n     * @since 0.1.0\r\n     * @memberOf _\r\n     * @category Object\r\n     * @param {Object} object The destination object.\r\n     * @param {...Object} [sources] The source objects.\r\n     * @returns {Object} Returns `object`.\r\n     * @see _.defaultsDeep\r\n     * @example\r\n     *\r\n     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\r\n     * // => { 'a': 1, 'b': 2 }\r\n     */\r\n    var defaults = baseRest(function(object, sources) {\r\n      object = Object(object);\r\n\r\n      var index = -1;\r\n      var length = sources.length;\r\n      var guard = length > 2 ? sources[2] : undefined;\r\n\r\n      if (guard && isIterateeCall(sources[0], sources[1], guard)) {\r\n        length = 1;\r\n      }\r\n\r\n      while (++index < length) {\r\n        var source = sources[index];\r\n        var props = keysIn(source);\r\n        var propsIndex = -1;\r\n        var propsLength = props.length;\r\n\r\n        while (++propsIndex < propsLength) {\r\n          var key = props[propsIndex];\r\n          var value = object[key];\r\n\r\n          if (value === undefined ||\r\n              (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {\r\n            object[key] = source[key];\r\n          }\r\n        }\r\n      }\r\n\r\n      return object;\r\n    });\r\n\r\n    /**\r\n     * This method is like `_.defaults` except that it recursively assigns\r\n     * default properties.\r\n     *\r\n     * **Note:** This method mutates `object`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.10.0\r\n     * @category Object\r\n     * @param {Object} object The destination object.\r\n     * @param {...Object} [sources] The source objects.\r\n     * @returns {Object} Returns `object`.\r\n     * @see _.defaults\r\n     * @example\r\n     *\r\n     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });\r\n     * // => { 'a': { 'b': 2, 'c': 3 } }\r\n     */\r\n    var defaultsDeep = baseRest(function(args) {\r\n      args.push(undefined, customDefaultsMerge);\r\n      return apply(mergeWith, undefined, args);\r\n    });\r\n\r\n    /**\r\n     * This method is like `_.find` except that it returns the key of the first\r\n     * element `predicate` returns truthy for instead of the element itself.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 1.1.0\r\n     * @category Object\r\n     * @param {Object} object The object to inspect.\r\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\r\n     * @returns {string|undefined} Returns the key of the matched element,\r\n     *  else `undefined`.\r\n     * @example\r\n     *\r\n     * var users = {\r\n     *   'barney':  { 'age': 36, 'active': true },\r\n     *   'fred':    { 'age': 40, 'active': false },\r\n     *   'pebbles': { 'age': 1,  'active': true }\r\n     * };\r\n     *\r\n     * _.findKey(users, function(o) { return o.age < 40; });\r\n     * // => 'barney' (iteration order is not guaranteed)\r\n     *\r\n     * // The `_.matches` iteratee shorthand.\r\n     * _.findKey(users, { 'age': 1, 'active': true });\r\n     * // => 'pebbles'\r\n     *\r\n     * // The `_.matchesProperty` iteratee shorthand.\r\n     * _.findKey(users, ['active', false]);\r\n     * // => 'fred'\r\n     *\r\n     * // The `_.property` iteratee shorthand.\r\n     * _.findKey(users, 'active');\r\n     * // => 'barney'\r\n     */\r\n    function findKey(object, predicate) {\r\n      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);\r\n    }\r\n\r\n    /**\r\n     * This method is like `_.findKey` except that it iterates over elements of\r\n     * a collection in the opposite order.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 2.0.0\r\n     * @category Object\r\n     * @param {Object} object The object to inspect.\r\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\r\n     * @returns {string|undefined} Returns the key of the matched element,\r\n     *  else `undefined`.\r\n     * @example\r\n     *\r\n     * var users = {\r\n     *   'barney':  { 'age': 36, 'active': true },\r\n     *   'fred':    { 'age': 40, 'active': false },\r\n     *   'pebbles': { 'age': 1,  'active': true }\r\n     * };\r\n     *\r\n     * _.findLastKey(users, function(o) { return o.age < 40; });\r\n     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'\r\n     *\r\n     * // The `_.matches` iteratee shorthand.\r\n     * _.findLastKey(users, { 'age': 36, 'active': true });\r\n     * // => 'barney'\r\n     *\r\n     * // The `_.matchesProperty` iteratee shorthand.\r\n     * _.findLastKey(users, ['active', false]);\r\n     * // => 'fred'\r\n     *\r\n     * // The `_.property` iteratee shorthand.\r\n     * _.findLastKey(users, 'active');\r\n     * // => 'pebbles'\r\n     */\r\n    function findLastKey(object, predicate) {\r\n      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);\r\n    }\r\n\r\n    /**\r\n     * Iterates over own and inherited enumerable string keyed properties of an\r\n     * object and invokes `iteratee` for each property. The iteratee is invoked\r\n     * with three arguments: (value, key, object). Iteratee functions may exit\r\n     * iteration early by explicitly returning `false`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.3.0\r\n     * @category Object\r\n     * @param {Object} object The object to iterate over.\r\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\r\n     * @returns {Object} Returns `object`.\r\n     * @see _.forInRight\r\n     * @example\r\n     *\r\n     * function Foo() {\r\n     *   this.a = 1;\r\n     *   this.b = 2;\r\n     * }\r\n     *\r\n     * Foo.prototype.c = 3;\r\n     *\r\n     * _.forIn(new Foo, function(value, key) {\r\n     *   console.log(key);\r\n     * });\r\n     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).\r\n     */\r\n    function forIn(object, iteratee) {\r\n      return object == null\r\n        ? object\r\n        : baseFor(object, getIteratee(iteratee, 3), keysIn);\r\n    }\r\n\r\n    /**\r\n     * This method is like `_.forIn` except that it iterates over properties of\r\n     * `object` in the opposite order.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 2.0.0\r\n     * @category Object\r\n     * @param {Object} object The object to iterate over.\r\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\r\n     * @returns {Object} Returns `object`.\r\n     * @see _.forIn\r\n     * @example\r\n     *\r\n     * function Foo() {\r\n     *   this.a = 1;\r\n     *   this.b = 2;\r\n     * }\r\n     *\r\n     * Foo.prototype.c = 3;\r\n     *\r\n     * _.forInRight(new Foo, function(value, key) {\r\n     *   console.log(key);\r\n     * });\r\n     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.\r\n     */\r\n    function forInRight(object, iteratee) {\r\n      return object == null\r\n        ? object\r\n        : baseForRight(object, getIteratee(iteratee, 3), keysIn);\r\n    }\r\n\r\n    /**\r\n     * Iterates over own enumerable string keyed properties of an object and\r\n     * invokes `iteratee` for each property. The iteratee is invoked with three\r\n     * arguments: (value, key, object). Iteratee functions may exit iteration\r\n     * early by explicitly returning `false`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.3.0\r\n     * @category Object\r\n     * @param {Object} object The object to iterate over.\r\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\r\n     * @returns {Object} Returns `object`.\r\n     * @see _.forOwnRight\r\n     * @example\r\n     *\r\n     * function Foo() {\r\n     *   this.a = 1;\r\n     *   this.b = 2;\r\n     * }\r\n     *\r\n     * Foo.prototype.c = 3;\r\n     *\r\n     * _.forOwn(new Foo, function(value, key) {\r\n     *   console.log(key);\r\n     * });\r\n     * // => Logs 'a' then 'b' (iteration order is not guaranteed).\r\n     */\r\n    function forOwn(object, iteratee) {\r\n      return object && baseForOwn(object, getIteratee(iteratee, 3));\r\n    }\r\n\r\n    /**\r\n     * This method is like `_.forOwn` except that it iterates over properties of\r\n     * `object` in the opposite order.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 2.0.0\r\n     * @category Object\r\n     * @param {Object} object The object to iterate over.\r\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\r\n     * @returns {Object} Returns `object`.\r\n     * @see _.forOwn\r\n     * @example\r\n     *\r\n     * function Foo() {\r\n     *   this.a = 1;\r\n     *   this.b = 2;\r\n     * }\r\n     *\r\n     * Foo.prototype.c = 3;\r\n     *\r\n     * _.forOwnRight(new Foo, function(value, key) {\r\n     *   console.log(key);\r\n     * });\r\n     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.\r\n     */\r\n    function forOwnRight(object, iteratee) {\r\n      return object && baseForOwnRight(object, getIteratee(iteratee, 3));\r\n    }\r\n\r\n    /**\r\n     * Creates an array of function property names from own enumerable properties\r\n     * of `object`.\r\n     *\r\n     * @static\r\n     * @since 0.1.0\r\n     * @memberOf _\r\n     * @category Object\r\n     * @param {Object} object The object to inspect.\r\n     * @returns {Array} Returns the function names.\r\n     * @see _.functionsIn\r\n     * @example\r\n     *\r\n     * function Foo() {\r\n     *   this.a = _.constant('a');\r\n     *   this.b = _.constant('b');\r\n     * }\r\n     *\r\n     * Foo.prototype.c = _.constant('c');\r\n     *\r\n     * _.functions(new Foo);\r\n     * // => ['a', 'b']\r\n     */\r\n    function functions(object) {\r\n      return object == null ? [] : baseFunctions(object, keys(object));\r\n    }\r\n\r\n    /**\r\n     * Creates an array of function property names from own and inherited\r\n     * enumerable properties of `object`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Object\r\n     * @param {Object} object The object to inspect.\r\n     * @returns {Array} Returns the function names.\r\n     * @see _.functions\r\n     * @example\r\n     *\r\n     * function Foo() {\r\n     *   this.a = _.constant('a');\r\n     *   this.b = _.constant('b');\r\n     * }\r\n     *\r\n     * Foo.prototype.c = _.constant('c');\r\n     *\r\n     * _.functionsIn(new Foo);\r\n     * // => ['a', 'b', 'c']\r\n     */\r\n    function functionsIn(object) {\r\n      return object == null ? [] : baseFunctions(object, keysIn(object));\r\n    }\r\n\r\n    /**\r\n     * Gets the value at `path` of `object`. If the resolved value is\r\n     * `undefined`, the `defaultValue` is returned in its place.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.7.0\r\n     * @category Object\r\n     * @param {Object} object The object to query.\r\n     * @param {Array|string} path The path of the property to get.\r\n     * @param {*} [defaultValue] The value returned for `undefined` resolved values.\r\n     * @returns {*} Returns the resolved value.\r\n     * @example\r\n     *\r\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\r\n     *\r\n     * _.get(object, 'a[0].b.c');\r\n     * // => 3\r\n     *\r\n     * _.get(object, ['a', '0', 'b', 'c']);\r\n     * // => 3\r\n     *\r\n     * _.get(object, 'a.b.c', 'default');\r\n     * // => 'default'\r\n     */\r\n    function get(object, path, defaultValue) {\r\n      var result = object == null ? undefined : baseGet(object, path);\r\n      return result === undefined ? defaultValue : result;\r\n    }\r\n\r\n    /**\r\n     * Checks if `path` is a direct property of `object`.\r\n     *\r\n     * @static\r\n     * @since 0.1.0\r\n     * @memberOf _\r\n     * @category Object\r\n     * @param {Object} object The object to query.\r\n     * @param {Array|string} path The path to check.\r\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\r\n     * @example\r\n     *\r\n     * var object = { 'a': { 'b': 2 } };\r\n     * var other = _.create({ 'a': _.create({ 'b': 2 }) });\r\n     *\r\n     * _.has(object, 'a');\r\n     * // => true\r\n     *\r\n     * _.has(object, 'a.b');\r\n     * // => true\r\n     *\r\n     * _.has(object, ['a', 'b']);\r\n     * // => true\r\n     *\r\n     * _.has(other, 'a');\r\n     * // => false\r\n     */\r\n    function has(object, path) {\r\n      return object != null && hasPath(object, path, baseHas);\r\n    }\r\n\r\n    /**\r\n     * Checks if `path` is a direct or inherited property of `object`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Object\r\n     * @param {Object} object The object to query.\r\n     * @param {Array|string} path The path to check.\r\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\r\n     * @example\r\n     *\r\n     * var object = _.create({ 'a': _.create({ 'b': 2 }) });\r\n     *\r\n     * _.hasIn(object, 'a');\r\n     * // => true\r\n     *\r\n     * _.hasIn(object, 'a.b');\r\n     * // => true\r\n     *\r\n     * _.hasIn(object, ['a', 'b']);\r\n     * // => true\r\n     *\r\n     * _.hasIn(object, 'b');\r\n     * // => false\r\n     */\r\n    function hasIn(object, path) {\r\n      return object != null && hasPath(object, path, baseHasIn);\r\n    }\r\n\r\n    /**\r\n     * Creates an object composed of the inverted keys and values of `object`.\r\n     * If `object` contains duplicate values, subsequent values overwrite\r\n     * property assignments of previous values.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.7.0\r\n     * @category Object\r\n     * @param {Object} object The object to invert.\r\n     * @returns {Object} Returns the new inverted object.\r\n     * @example\r\n     *\r\n     * var object = { 'a': 1, 'b': 2, 'c': 1 };\r\n     *\r\n     * _.invert(object);\r\n     * // => { '1': 'c', '2': 'b' }\r\n     */\r\n    var invert = createInverter(function(result, value, key) {\r\n      if (value != null &&\r\n          typeof value.toString != 'function') {\r\n        value = nativeObjectToString.call(value);\r\n      }\r\n\r\n      result[value] = key;\r\n    }, constant(identity));\r\n\r\n    /**\r\n     * This method is like `_.invert` except that the inverted object is generated\r\n     * from the results of running each element of `object` thru `iteratee`. The\r\n     * corresponding inverted value of each inverted key is an array of keys\r\n     * responsible for generating the inverted value. The iteratee is invoked\r\n     * with one argument: (value).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.1.0\r\n     * @category Object\r\n     * @param {Object} object The object to invert.\r\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\r\n     * @returns {Object} Returns the new inverted object.\r\n     * @example\r\n     *\r\n     * var object = { 'a': 1, 'b': 2, 'c': 1 };\r\n     *\r\n     * _.invertBy(object);\r\n     * // => { '1': ['a', 'c'], '2': ['b'] }\r\n     *\r\n     * _.invertBy(object, function(value) {\r\n     *   return 'group' + value;\r\n     * });\r\n     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }\r\n     */\r\n    var invertBy = createInverter(function(result, value, key) {\r\n      if (value != null &&\r\n          typeof value.toString != 'function') {\r\n        value = nativeObjectToString.call(value);\r\n      }\r\n\r\n      if (hasOwnProperty.call(result, value)) {\r\n        result[value].push(key);\r\n      } else {\r\n        result[value] = [key];\r\n      }\r\n    }, getIteratee);\r\n\r\n    /**\r\n     * Invokes the method at `path` of `object`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Object\r\n     * @param {Object} object The object to query.\r\n     * @param {Array|string} path The path of the method to invoke.\r\n     * @param {...*} [args] The arguments to invoke the method with.\r\n     * @returns {*} Returns the result of the invoked method.\r\n     * @example\r\n     *\r\n     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };\r\n     *\r\n     * _.invoke(object, 'a[0].b.c.slice', 1, 3);\r\n     * // => [2, 3]\r\n     */\r\n    var invoke = baseRest(baseInvoke);\r\n\r\n    /**\r\n     * Creates an array of the own enumerable property names of `object`.\r\n     *\r\n     * **Note:** Non-object values are coerced to objects. See the\r\n     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\r\n     * for more details.\r\n     *\r\n     * @static\r\n     * @since 0.1.0\r\n     * @memberOf _\r\n     * @category Object\r\n     * @param {Object} object The object to query.\r\n     * @returns {Array} Returns the array of property names.\r\n     * @example\r\n     *\r\n     * function Foo() {\r\n     *   this.a = 1;\r\n     *   this.b = 2;\r\n     * }\r\n     *\r\n     * Foo.prototype.c = 3;\r\n     *\r\n     * _.keys(new Foo);\r\n     * // => ['a', 'b'] (iteration order is not guaranteed)\r\n     *\r\n     * _.keys('hi');\r\n     * // => ['0', '1']\r\n     */\r\n    function keys(object) {\r\n      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\r\n    }\r\n\r\n    /**\r\n     * Creates an array of the own and inherited enumerable property names of `object`.\r\n     *\r\n     * **Note:** Non-object values are coerced to objects.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.0.0\r\n     * @category Object\r\n     * @param {Object} object The object to query.\r\n     * @returns {Array} Returns the array of property names.\r\n     * @example\r\n     *\r\n     * function Foo() {\r\n     *   this.a = 1;\r\n     *   this.b = 2;\r\n     * }\r\n     *\r\n     * Foo.prototype.c = 3;\r\n     *\r\n     * _.keysIn(new Foo);\r\n     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\r\n     */\r\n    function keysIn(object) {\r\n      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\r\n    }\r\n\r\n    /**\r\n     * The opposite of `_.mapValues`; this method creates an object with the\r\n     * same values as `object` and keys generated by running each own enumerable\r\n     * string keyed property of `object` thru `iteratee`. The iteratee is invoked\r\n     * with three arguments: (value, key, object).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.8.0\r\n     * @category Object\r\n     * @param {Object} object The object to iterate over.\r\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\r\n     * @returns {Object} Returns the new mapped object.\r\n     * @see _.mapValues\r\n     * @example\r\n     *\r\n     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {\r\n     *   return key + value;\r\n     * });\r\n     * // => { 'a1': 1, 'b2': 2 }\r\n     */\r\n    function mapKeys(object, iteratee) {\r\n      var result = {};\r\n      iteratee = getIteratee(iteratee, 3);\r\n\r\n      baseForOwn(object, function(value, key, object) {\r\n        baseAssignValue(result, iteratee(value, key, object), value);\r\n      });\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Creates an object with the same keys as `object` and values generated\r\n     * by running each own enumerable string keyed property of `object` thru\r\n     * `iteratee`. The iteratee is invoked with three arguments:\r\n     * (value, key, object).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 2.4.0\r\n     * @category Object\r\n     * @param {Object} object The object to iterate over.\r\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\r\n     * @returns {Object} Returns the new mapped object.\r\n     * @see _.mapKeys\r\n     * @example\r\n     *\r\n     * var users = {\r\n     *   'fred':    { 'user': 'fred',    'age': 40 },\r\n     *   'pebbles': { 'user': 'pebbles', 'age': 1 }\r\n     * };\r\n     *\r\n     * _.mapValues(users, function(o) { return o.age; });\r\n     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\r\n     *\r\n     * // The `_.property` iteratee shorthand.\r\n     * _.mapValues(users, 'age');\r\n     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\r\n     */\r\n    function mapValues(object, iteratee) {\r\n      var result = {};\r\n      iteratee = getIteratee(iteratee, 3);\r\n\r\n      baseForOwn(object, function(value, key, object) {\r\n        baseAssignValue(result, key, iteratee(value, key, object));\r\n      });\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * This method is like `_.assign` except that it recursively merges own and\r\n     * inherited enumerable string keyed properties of source objects into the\r\n     * destination object. Source properties that resolve to `undefined` are\r\n     * skipped if a destination value exists. Array and plain object properties\r\n     * are merged recursively. Other objects and value types are overridden by\r\n     * assignment. Source objects are applied from left to right. Subsequent\r\n     * sources overwrite property assignments of previous sources.\r\n     *\r\n     * **Note:** This method mutates `object`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.5.0\r\n     * @category Object\r\n     * @param {Object} object The destination object.\r\n     * @param {...Object} [sources] The source objects.\r\n     * @returns {Object} Returns `object`.\r\n     * @example\r\n     *\r\n     * var object = {\r\n     *   'a': [{ 'b': 2 }, { 'd': 4 }]\r\n     * };\r\n     *\r\n     * var other = {\r\n     *   'a': [{ 'c': 3 }, { 'e': 5 }]\r\n     * };\r\n     *\r\n     * _.merge(object, other);\r\n     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }\r\n     */\r\n    var merge = createAssigner(function(object, source, srcIndex) {\r\n      baseMerge(object, source, srcIndex);\r\n    });\r\n\r\n    /**\r\n     * This method is like `_.merge` except that it accepts `customizer` which\r\n     * is invoked to produce the merged values of the destination and source\r\n     * properties. If `customizer` returns `undefined`, merging is handled by the\r\n     * method instead. The `customizer` is invoked with six arguments:\r\n     * (objValue, srcValue, key, object, source, stack).\r\n     *\r\n     * **Note:** This method mutates `object`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Object\r\n     * @param {Object} object The destination object.\r\n     * @param {...Object} sources The source objects.\r\n     * @param {Function} customizer The function to customize assigned values.\r\n     * @returns {Object} Returns `object`.\r\n     * @example\r\n     *\r\n     * function customizer(objValue, srcValue) {\r\n     *   if (_.isArray(objValue)) {\r\n     *     return objValue.concat(srcValue);\r\n     *   }\r\n     * }\r\n     *\r\n     * var object = { 'a': [1], 'b': [2] };\r\n     * var other = { 'a': [3], 'b': [4] };\r\n     *\r\n     * _.mergeWith(object, other, customizer);\r\n     * // => { 'a': [1, 3], 'b': [2, 4] }\r\n     */\r\n    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {\r\n      baseMerge(object, source, srcIndex, customizer);\r\n    });\r\n\r\n    /**\r\n     * The opposite of `_.pick`; this method creates an object composed of the\r\n     * own and inherited enumerable property paths of `object` that are not omitted.\r\n     *\r\n     * **Note:** This method is considerably slower than `_.pick`.\r\n     *\r\n     * @static\r\n     * @since 0.1.0\r\n     * @memberOf _\r\n     * @category Object\r\n     * @param {Object} object The source object.\r\n     * @param {...(string|string[])} [paths] The property paths to omit.\r\n     * @returns {Object} Returns the new object.\r\n     * @example\r\n     *\r\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\r\n     *\r\n     * _.omit(object, ['a', 'c']);\r\n     * // => { 'b': '2' }\r\n     */\r\n    var omit = flatRest(function(object, paths) {\r\n      var result = {};\r\n      if (object == null) {\r\n        return result;\r\n      }\r\n      var isDeep = false;\r\n      paths = arrayMap(paths, function(path) {\r\n        path = castPath(path, object);\r\n        isDeep || (isDeep = path.length > 1);\r\n        return path;\r\n      });\r\n      copyObject(object, getAllKeysIn(object), result);\r\n      if (isDeep) {\r\n        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);\r\n      }\r\n      var length = paths.length;\r\n      while (length--) {\r\n        baseUnset(result, paths[length]);\r\n      }\r\n      return result;\r\n    });\r\n\r\n    /**\r\n     * The opposite of `_.pickBy`; this method creates an object composed of\r\n     * the own and inherited enumerable string keyed properties of `object` that\r\n     * `predicate` doesn't return truthy for. The predicate is invoked with two\r\n     * arguments: (value, key).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Object\r\n     * @param {Object} object The source object.\r\n     * @param {Function} [predicate=_.identity] The function invoked per property.\r\n     * @returns {Object} Returns the new object.\r\n     * @example\r\n     *\r\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\r\n     *\r\n     * _.omitBy(object, _.isNumber);\r\n     * // => { 'b': '2' }\r\n     */\r\n    function omitBy(object, predicate) {\r\n      return pickBy(object, negate(getIteratee(predicate)));\r\n    }\r\n\r\n    /**\r\n     * Creates an object composed of the picked `object` properties.\r\n     *\r\n     * @static\r\n     * @since 0.1.0\r\n     * @memberOf _\r\n     * @category Object\r\n     * @param {Object} object The source object.\r\n     * @param {...(string|string[])} [paths] The property paths to pick.\r\n     * @returns {Object} Returns the new object.\r\n     * @example\r\n     *\r\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\r\n     *\r\n     * _.pick(object, ['a', 'c']);\r\n     * // => { 'a': 1, 'c': 3 }\r\n     */\r\n    var pick = flatRest(function(object, paths) {\r\n      return object == null ? {} : basePick(object, paths);\r\n    });\r\n\r\n    /**\r\n     * Creates an object composed of the `object` properties `predicate` returns\r\n     * truthy for. The predicate is invoked with two arguments: (value, key).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Object\r\n     * @param {Object} object The source object.\r\n     * @param {Function} [predicate=_.identity] The function invoked per property.\r\n     * @returns {Object} Returns the new object.\r\n     * @example\r\n     *\r\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\r\n     *\r\n     * _.pickBy(object, _.isNumber);\r\n     * // => { 'a': 1, 'c': 3 }\r\n     */\r\n    function pickBy(object, predicate) {\r\n      if (object == null) {\r\n        return {};\r\n      }\r\n      var props = arrayMap(getAllKeysIn(object), function(prop) {\r\n        return [prop];\r\n      });\r\n      predicate = getIteratee(predicate);\r\n      return basePickBy(object, props, function(value, path) {\r\n        return predicate(value, path[0]);\r\n      });\r\n    }\r\n\r\n    /**\r\n     * This method is like `_.get` except that if the resolved value is a\r\n     * function it's invoked with the `this` binding of its parent object and\r\n     * its result is returned.\r\n     *\r\n     * @static\r\n     * @since 0.1.0\r\n     * @memberOf _\r\n     * @category Object\r\n     * @param {Object} object The object to query.\r\n     * @param {Array|string} path The path of the property to resolve.\r\n     * @param {*} [defaultValue] The value returned for `undefined` resolved values.\r\n     * @returns {*} Returns the resolved value.\r\n     * @example\r\n     *\r\n     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };\r\n     *\r\n     * _.result(object, 'a[0].b.c1');\r\n     * // => 3\r\n     *\r\n     * _.result(object, 'a[0].b.c2');\r\n     * // => 4\r\n     *\r\n     * _.result(object, 'a[0].b.c3', 'default');\r\n     * // => 'default'\r\n     *\r\n     * _.result(object, 'a[0].b.c3', _.constant('default'));\r\n     * // => 'default'\r\n     */\r\n    function result(object, path, defaultValue) {\r\n      path = castPath(path, object);\r\n\r\n      var index = -1,\r\n          length = path.length;\r\n\r\n      // Ensure the loop is entered when path is empty.\r\n      if (!length) {\r\n        length = 1;\r\n        object = undefined;\r\n      }\r\n      while (++index < length) {\r\n        var value = object == null ? undefined : object[toKey(path[index])];\r\n        if (value === undefined) {\r\n          index = length;\r\n          value = defaultValue;\r\n        }\r\n        object = isFunction(value) ? value.call(object) : value;\r\n      }\r\n      return object;\r\n    }\r\n\r\n    /**\r\n     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,\r\n     * it's created. Arrays are created for missing index properties while objects\r\n     * are created for all other missing properties. Use `_.setWith` to customize\r\n     * `path` creation.\r\n     *\r\n     * **Note:** This method mutates `object`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.7.0\r\n     * @category Object\r\n     * @param {Object} object The object to modify.\r\n     * @param {Array|string} path The path of the property to set.\r\n     * @param {*} value The value to set.\r\n     * @returns {Object} Returns `object`.\r\n     * @example\r\n     *\r\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\r\n     *\r\n     * _.set(object, 'a[0].b.c', 4);\r\n     * console.log(object.a[0].b.c);\r\n     * // => 4\r\n     *\r\n     * _.set(object, ['x', '0', 'y', 'z'], 5);\r\n     * console.log(object.x[0].y.z);\r\n     * // => 5\r\n     */\r\n    function set(object, path, value) {\r\n      return object == null ? object : baseSet(object, path, value);\r\n    }\r\n\r\n    /**\r\n     * This method is like `_.set` except that it accepts `customizer` which is\r\n     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`\r\n     * path creation is handled by the method instead. The `customizer` is invoked\r\n     * with three arguments: (nsValue, key, nsObject).\r\n     *\r\n     * **Note:** This method mutates `object`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Object\r\n     * @param {Object} object The object to modify.\r\n     * @param {Array|string} path The path of the property to set.\r\n     * @param {*} value The value to set.\r\n     * @param {Function} [customizer] The function to customize assigned values.\r\n     * @returns {Object} Returns `object`.\r\n     * @example\r\n     *\r\n     * var object = {};\r\n     *\r\n     * _.setWith(object, '[0][1]', 'a', Object);\r\n     * // => { '0': { '1': 'a' } }\r\n     */\r\n    function setWith(object, path, value, customizer) {\r\n      customizer = typeof customizer == 'function' ? customizer : undefined;\r\n      return object == null ? object : baseSet(object, path, value, customizer);\r\n    }\r\n\r\n    /**\r\n     * Creates an array of own enumerable string keyed-value pairs for `object`\r\n     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its\r\n     * entries are returned.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @alias entries\r\n     * @category Object\r\n     * @param {Object} object The object to query.\r\n     * @returns {Array} Returns the key-value pairs.\r\n     * @example\r\n     *\r\n     * function Foo() {\r\n     *   this.a = 1;\r\n     *   this.b = 2;\r\n     * }\r\n     *\r\n     * Foo.prototype.c = 3;\r\n     *\r\n     * _.toPairs(new Foo);\r\n     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)\r\n     */\r\n    var toPairs = createToPairs(keys);\r\n\r\n    /**\r\n     * Creates an array of own and inherited enumerable string keyed-value pairs\r\n     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map\r\n     * or set, its entries are returned.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @alias entriesIn\r\n     * @category Object\r\n     * @param {Object} object The object to query.\r\n     * @returns {Array} Returns the key-value pairs.\r\n     * @example\r\n     *\r\n     * function Foo() {\r\n     *   this.a = 1;\r\n     *   this.b = 2;\r\n     * }\r\n     *\r\n     * Foo.prototype.c = 3;\r\n     *\r\n     * _.toPairsIn(new Foo);\r\n     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)\r\n     */\r\n    var toPairsIn = createToPairs(keysIn);\r\n\r\n    /**\r\n     * An alternative to `_.reduce`; this method transforms `object` to a new\r\n     * `accumulator` object which is the result of running each of its own\r\n     * enumerable string keyed properties thru `iteratee`, with each invocation\r\n     * potentially mutating the `accumulator` object. If `accumulator` is not\r\n     * provided, a new object with the same `[[Prototype]]` will be used. The\r\n     * iteratee is invoked with four arguments: (accumulator, value, key, object).\r\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 1.3.0\r\n     * @category Object\r\n     * @param {Object} object The object to iterate over.\r\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\r\n     * @param {*} [accumulator] The custom accumulator value.\r\n     * @returns {*} Returns the accumulated value.\r\n     * @example\r\n     *\r\n     * _.transform([2, 3, 4], function(result, n) {\r\n     *   result.push(n *= n);\r\n     *   return n % 2 == 0;\r\n     * }, []);\r\n     * // => [4, 9]\r\n     *\r\n     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\r\n     *   (result[value] || (result[value] = [])).push(key);\r\n     * }, {});\r\n     * // => { '1': ['a', 'c'], '2': ['b'] }\r\n     */\r\n    function transform(object, iteratee, accumulator) {\r\n      var isArr = isArray(object),\r\n          isArrLike = isArr || isBuffer(object) || isTypedArray(object);\r\n\r\n      iteratee = getIteratee(iteratee, 4);\r\n      if (accumulator == null) {\r\n        var Ctor = object && object.constructor;\r\n        if (isArrLike) {\r\n          accumulator = isArr ? new Ctor : [];\r\n        }\r\n        else if (isObject(object)) {\r\n          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};\r\n        }\r\n        else {\r\n          accumulator = {};\r\n        }\r\n      }\r\n      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {\r\n        return iteratee(accumulator, value, index, object);\r\n      });\r\n      return accumulator;\r\n    }\r\n\r\n    /**\r\n     * Removes the property at `path` of `object`.\r\n     *\r\n     * **Note:** This method mutates `object`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Object\r\n     * @param {Object} object The object to modify.\r\n     * @param {Array|string} path The path of the property to unset.\r\n     * @returns {boolean} Returns `true` if the property is deleted, else `false`.\r\n     * @example\r\n     *\r\n     * var object = { 'a': [{ 'b': { 'c': 7 } }] };\r\n     * _.unset(object, 'a[0].b.c');\r\n     * // => true\r\n     *\r\n     * console.log(object);\r\n     * // => { 'a': [{ 'b': {} }] };\r\n     *\r\n     * _.unset(object, ['a', '0', 'b', 'c']);\r\n     * // => true\r\n     *\r\n     * console.log(object);\r\n     * // => { 'a': [{ 'b': {} }] };\r\n     */\r\n    function unset(object, path) {\r\n      return object == null ? true : baseUnset(object, path);\r\n    }\r\n\r\n    /**\r\n     * This method is like `_.set` except that accepts `updater` to produce the\r\n     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`\r\n     * is invoked with one argument: (value).\r\n     *\r\n     * **Note:** This method mutates `object`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.6.0\r\n     * @category Object\r\n     * @param {Object} object The object to modify.\r\n     * @param {Array|string} path The path of the property to set.\r\n     * @param {Function} updater The function to produce the updated value.\r\n     * @returns {Object} Returns `object`.\r\n     * @example\r\n     *\r\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\r\n     *\r\n     * _.update(object, 'a[0].b.c', function(n) { return n * n; });\r\n     * console.log(object.a[0].b.c);\r\n     * // => 9\r\n     *\r\n     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });\r\n     * console.log(object.x[0].y.z);\r\n     * // => 0\r\n     */\r\n    function update(object, path, updater) {\r\n      return object == null ? object : baseUpdate(object, path, castFunction(updater));\r\n    }\r\n\r\n    /**\r\n     * This method is like `_.update` except that it accepts `customizer` which is\r\n     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`\r\n     * path creation is handled by the method instead. The `customizer` is invoked\r\n     * with three arguments: (nsValue, key, nsObject).\r\n     *\r\n     * **Note:** This method mutates `object`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.6.0\r\n     * @category Object\r\n     * @param {Object} object The object to modify.\r\n     * @param {Array|string} path The path of the property to set.\r\n     * @param {Function} updater The function to produce the updated value.\r\n     * @param {Function} [customizer] The function to customize assigned values.\r\n     * @returns {Object} Returns `object`.\r\n     * @example\r\n     *\r\n     * var object = {};\r\n     *\r\n     * _.updateWith(object, '[0][1]', _.constant('a'), Object);\r\n     * // => { '0': { '1': 'a' } }\r\n     */\r\n    function updateWith(object, path, updater, customizer) {\r\n      customizer = typeof customizer == 'function' ? customizer : undefined;\r\n      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);\r\n    }\r\n\r\n    /**\r\n     * Creates an array of the own enumerable string keyed property values of `object`.\r\n     *\r\n     * **Note:** Non-object values are coerced to objects.\r\n     *\r\n     * @static\r\n     * @since 0.1.0\r\n     * @memberOf _\r\n     * @category Object\r\n     * @param {Object} object The object to query.\r\n     * @returns {Array} Returns the array of property values.\r\n     * @example\r\n     *\r\n     * function Foo() {\r\n     *   this.a = 1;\r\n     *   this.b = 2;\r\n     * }\r\n     *\r\n     * Foo.prototype.c = 3;\r\n     *\r\n     * _.values(new Foo);\r\n     * // => [1, 2] (iteration order is not guaranteed)\r\n     *\r\n     * _.values('hi');\r\n     * // => ['h', 'i']\r\n     */\r\n    function values(object) {\r\n      return object == null ? [] : baseValues(object, keys(object));\r\n    }\r\n\r\n    /**\r\n     * Creates an array of the own and inherited enumerable string keyed property\r\n     * values of `object`.\r\n     *\r\n     * **Note:** Non-object values are coerced to objects.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.0.0\r\n     * @category Object\r\n     * @param {Object} object The object to query.\r\n     * @returns {Array} Returns the array of property values.\r\n     * @example\r\n     *\r\n     * function Foo() {\r\n     *   this.a = 1;\r\n     *   this.b = 2;\r\n     * }\r\n     *\r\n     * Foo.prototype.c = 3;\r\n     *\r\n     * _.valuesIn(new Foo);\r\n     * // => [1, 2, 3] (iteration order is not guaranteed)\r\n     */\r\n    function valuesIn(object) {\r\n      return object == null ? [] : baseValues(object, keysIn(object));\r\n    }\r\n\r\n    /*------------------------------------------------------------------------*/\r\n\r\n    /**\r\n     * Clamps `number` within the inclusive `lower` and `upper` bounds.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Number\r\n     * @param {number} number The number to clamp.\r\n     * @param {number} [lower] The lower bound.\r\n     * @param {number} upper The upper bound.\r\n     * @returns {number} Returns the clamped number.\r\n     * @example\r\n     *\r\n     * _.clamp(-10, -5, 5);\r\n     * // => -5\r\n     *\r\n     * _.clamp(10, -5, 5);\r\n     * // => 5\r\n     */\r\n    function clamp(number, lower, upper) {\r\n      if (upper === undefined) {\r\n        upper = lower;\r\n        lower = undefined;\r\n      }\r\n      if (upper !== undefined) {\r\n        upper = toNumber(upper);\r\n        upper = upper === upper ? upper : 0;\r\n      }\r\n      if (lower !== undefined) {\r\n        lower = toNumber(lower);\r\n        lower = lower === lower ? lower : 0;\r\n      }\r\n      return baseClamp(toNumber(number), lower, upper);\r\n    }\r\n\r\n    /**\r\n     * Checks if `n` is between `start` and up to, but not including, `end`. If\r\n     * `end` is not specified, it's set to `start` with `start` then set to `0`.\r\n     * If `start` is greater than `end` the params are swapped to support\r\n     * negative ranges.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.3.0\r\n     * @category Number\r\n     * @param {number} number The number to check.\r\n     * @param {number} [start=0] The start of the range.\r\n     * @param {number} end The end of the range.\r\n     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\r\n     * @see _.range, _.rangeRight\r\n     * @example\r\n     *\r\n     * _.inRange(3, 2, 4);\r\n     * // => true\r\n     *\r\n     * _.inRange(4, 8);\r\n     * // => true\r\n     *\r\n     * _.inRange(4, 2);\r\n     * // => false\r\n     *\r\n     * _.inRange(2, 2);\r\n     * // => false\r\n     *\r\n     * _.inRange(1.2, 2);\r\n     * // => true\r\n     *\r\n     * _.inRange(5.2, 4);\r\n     * // => false\r\n     *\r\n     * _.inRange(-3, -2, -6);\r\n     * // => true\r\n     */\r\n    function inRange(number, start, end) {\r\n      start = toFinite(start);\r\n      if (end === undefined) {\r\n        end = start;\r\n        start = 0;\r\n      } else {\r\n        end = toFinite(end);\r\n      }\r\n      number = toNumber(number);\r\n      return baseInRange(number, start, end);\r\n    }\r\n\r\n    /**\r\n     * Produces a random number between the inclusive `lower` and `upper` bounds.\r\n     * If only one argument is provided a number between `0` and the given number\r\n     * is returned. If `floating` is `true`, or either `lower` or `upper` are\r\n     * floats, a floating-point number is returned instead of an integer.\r\n     *\r\n     * **Note:** JavaScript follows the IEEE-754 standard for resolving\r\n     * floating-point values which can produce unexpected results.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.7.0\r\n     * @category Number\r\n     * @param {number} [lower=0] The lower bound.\r\n     * @param {number} [upper=1] The upper bound.\r\n     * @param {boolean} [floating] Specify returning a floating-point number.\r\n     * @returns {number} Returns the random number.\r\n     * @example\r\n     *\r\n     * _.random(0, 5);\r\n     * // => an integer between 0 and 5\r\n     *\r\n     * _.random(5);\r\n     * // => also an integer between 0 and 5\r\n     *\r\n     * _.random(5, true);\r\n     * // => a floating-point number between 0 and 5\r\n     *\r\n     * _.random(1.2, 5.2);\r\n     * // => a floating-point number between 1.2 and 5.2\r\n     */\r\n    function random(lower, upper, floating) {\r\n      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {\r\n        upper = floating = undefined;\r\n      }\r\n      if (floating === undefined) {\r\n        if (typeof upper == 'boolean') {\r\n          floating = upper;\r\n          upper = undefined;\r\n        }\r\n        else if (typeof lower == 'boolean') {\r\n          floating = lower;\r\n          lower = undefined;\r\n        }\r\n      }\r\n      if (lower === undefined && upper === undefined) {\r\n        lower = 0;\r\n        upper = 1;\r\n      }\r\n      else {\r\n        lower = toFinite(lower);\r\n        if (upper === undefined) {\r\n          upper = lower;\r\n          lower = 0;\r\n        } else {\r\n          upper = toFinite(upper);\r\n        }\r\n      }\r\n      if (lower > upper) {\r\n        var temp = lower;\r\n        lower = upper;\r\n        upper = temp;\r\n      }\r\n      if (floating || lower % 1 || upper % 1) {\r\n        var rand = nativeRandom();\r\n        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);\r\n      }\r\n      return baseRandom(lower, upper);\r\n    }\r\n\r\n    /*------------------------------------------------------------------------*/\r\n\r\n    /**\r\n     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.0.0\r\n     * @category String\r\n     * @param {string} [string=''] The string to convert.\r\n     * @returns {string} Returns the camel cased string.\r\n     * @example\r\n     *\r\n     * _.camelCase('Foo Bar');\r\n     * // => 'fooBar'\r\n     *\r\n     * _.camelCase('--foo-bar--');\r\n     * // => 'fooBar'\r\n     *\r\n     * _.camelCase('__FOO_BAR__');\r\n     * // => 'fooBar'\r\n     */\r\n    var camelCase = createCompounder(function(result, word, index) {\r\n      word = word.toLowerCase();\r\n      return result + (index ? capitalize(word) : word);\r\n    });\r\n\r\n    /**\r\n     * Converts the first character of `string` to upper case and the remaining\r\n     * to lower case.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.0.0\r\n     * @category String\r\n     * @param {string} [string=''] The string to capitalize.\r\n     * @returns {string} Returns the capitalized string.\r\n     * @example\r\n     *\r\n     * _.capitalize('FRED');\r\n     * // => 'Fred'\r\n     */\r\n    function capitalize(string) {\r\n      return upperFirst(toString(string).toLowerCase());\r\n    }\r\n\r\n    /**\r\n     * Deburrs `string` by converting\r\n     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)\r\n     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)\r\n     * letters to basic Latin letters and removing\r\n     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.0.0\r\n     * @category String\r\n     * @param {string} [string=''] The string to deburr.\r\n     * @returns {string} Returns the deburred string.\r\n     * @example\r\n     *\r\n     * _.deburr('déjà vu');\r\n     * // => 'deja vu'\r\n     */\r\n    function deburr(string) {\r\n      string = toString(string);\r\n      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');\r\n    }\r\n\r\n    /**\r\n     * Checks if `string` ends with the given target string.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.0.0\r\n     * @category String\r\n     * @param {string} [string=''] The string to inspect.\r\n     * @param {string} [target] The string to search for.\r\n     * @param {number} [position=string.length] The position to search up to.\r\n     * @returns {boolean} Returns `true` if `string` ends with `target`,\r\n     *  else `false`.\r\n     * @example\r\n     *\r\n     * _.endsWith('abc', 'c');\r\n     * // => true\r\n     *\r\n     * _.endsWith('abc', 'b');\r\n     * // => false\r\n     *\r\n     * _.endsWith('abc', 'b', 2);\r\n     * // => true\r\n     */\r\n    function endsWith(string, target, position) {\r\n      string = toString(string);\r\n      target = baseToString(target);\r\n\r\n      var length = string.length;\r\n      position = position === undefined\r\n        ? length\r\n        : baseClamp(toInteger(position), 0, length);\r\n\r\n      var end = position;\r\n      position -= target.length;\r\n      return position >= 0 && string.slice(position, end) == target;\r\n    }\r\n\r\n    /**\r\n     * Converts the characters \"&\", \"<\", \">\", '\"', and \"'\" in `string` to their\r\n     * corresponding HTML entities.\r\n     *\r\n     * **Note:** No other characters are escaped. To escape additional\r\n     * characters use a third-party library like [_he_](https://mths.be/he).\r\n     *\r\n     * Though the \">\" character is escaped for symmetry, characters like\r\n     * \">\" and \"/\" don't need escaping in HTML and have no special meaning\r\n     * unless they're part of a tag or unquoted attribute value. See\r\n     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)\r\n     * (under \"semi-related fun fact\") for more details.\r\n     *\r\n     * When working with HTML you should always\r\n     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce\r\n     * XSS vectors.\r\n     *\r\n     * @static\r\n     * @since 0.1.0\r\n     * @memberOf _\r\n     * @category String\r\n     * @param {string} [string=''] The string to escape.\r\n     * @returns {string} Returns the escaped string.\r\n     * @example\r\n     *\r\n     * _.escape('fred, barney, & pebbles');\r\n     * // => 'fred, barney, &amp; pebbles'\r\n     */\r\n    function escape(string) {\r\n      string = toString(string);\r\n      return (string && reHasUnescapedHtml.test(string))\r\n        ? string.replace(reUnescapedHtml, escapeHtmlChar)\r\n        : string;\r\n    }\r\n\r\n    /**\r\n     * Escapes the `RegExp` special characters \"^\", \"$\", \"\\\", \".\", \"*\", \"+\",\r\n     * \"?\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", and \"|\" in `string`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.0.0\r\n     * @category String\r\n     * @param {string} [string=''] The string to escape.\r\n     * @returns {string} Returns the escaped string.\r\n     * @example\r\n     *\r\n     * _.escapeRegExp('[lodash](https://lodash.com/)');\r\n     * // => '\\[lodash\\]\\(https://lodash\\.com/\\)'\r\n     */\r\n    function escapeRegExp(string) {\r\n      string = toString(string);\r\n      return (string && reHasRegExpChar.test(string))\r\n        ? string.replace(reRegExpChar, '\\\\$&')\r\n        : string;\r\n    }\r\n\r\n    /**\r\n     * Converts `string` to\r\n     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.0.0\r\n     * @category String\r\n     * @param {string} [string=''] The string to convert.\r\n     * @returns {string} Returns the kebab cased string.\r\n     * @example\r\n     *\r\n     * _.kebabCase('Foo Bar');\r\n     * // => 'foo-bar'\r\n     *\r\n     * _.kebabCase('fooBar');\r\n     * // => 'foo-bar'\r\n     *\r\n     * _.kebabCase('__FOO_BAR__');\r\n     * // => 'foo-bar'\r\n     */\r\n    var kebabCase = createCompounder(function(result, word, index) {\r\n      return result + (index ? '-' : '') + word.toLowerCase();\r\n    });\r\n\r\n    /**\r\n     * Converts `string`, as space separated words, to lower case.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category String\r\n     * @param {string} [string=''] The string to convert.\r\n     * @returns {string} Returns the lower cased string.\r\n     * @example\r\n     *\r\n     * _.lowerCase('--Foo-Bar--');\r\n     * // => 'foo bar'\r\n     *\r\n     * _.lowerCase('fooBar');\r\n     * // => 'foo bar'\r\n     *\r\n     * _.lowerCase('__FOO_BAR__');\r\n     * // => 'foo bar'\r\n     */\r\n    var lowerCase = createCompounder(function(result, word, index) {\r\n      return result + (index ? ' ' : '') + word.toLowerCase();\r\n    });\r\n\r\n    /**\r\n     * Converts the first character of `string` to lower case.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category String\r\n     * @param {string} [string=''] The string to convert.\r\n     * @returns {string} Returns the converted string.\r\n     * @example\r\n     *\r\n     * _.lowerFirst('Fred');\r\n     * // => 'fred'\r\n     *\r\n     * _.lowerFirst('FRED');\r\n     * // => 'fRED'\r\n     */\r\n    var lowerFirst = createCaseFirst('toLowerCase');\r\n\r\n    /**\r\n     * Pads `string` on the left and right sides if it's shorter than `length`.\r\n     * Padding characters are truncated if they can't be evenly divided by `length`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.0.0\r\n     * @category String\r\n     * @param {string} [string=''] The string to pad.\r\n     * @param {number} [length=0] The padding length.\r\n     * @param {string} [chars=' '] The string used as padding.\r\n     * @returns {string} Returns the padded string.\r\n     * @example\r\n     *\r\n     * _.pad('abc', 8);\r\n     * // => '  abc   '\r\n     *\r\n     * _.pad('abc', 8, '_-');\r\n     * // => '_-abc_-_'\r\n     *\r\n     * _.pad('abc', 3);\r\n     * // => 'abc'\r\n     */\r\n    function pad(string, length, chars) {\r\n      string = toString(string);\r\n      length = toInteger(length);\r\n\r\n      var strLength = length ? stringSize(string) : 0;\r\n      if (!length || strLength >= length) {\r\n        return string;\r\n      }\r\n      var mid = (length - strLength) / 2;\r\n      return (\r\n        createPadding(nativeFloor(mid), chars) +\r\n        string +\r\n        createPadding(nativeCeil(mid), chars)\r\n      );\r\n    }\r\n\r\n    /**\r\n     * Pads `string` on the right side if it's shorter than `length`. Padding\r\n     * characters are truncated if they exceed `length`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category String\r\n     * @param {string} [string=''] The string to pad.\r\n     * @param {number} [length=0] The padding length.\r\n     * @param {string} [chars=' '] The string used as padding.\r\n     * @returns {string} Returns the padded string.\r\n     * @example\r\n     *\r\n     * _.padEnd('abc', 6);\r\n     * // => 'abc   '\r\n     *\r\n     * _.padEnd('abc', 6, '_-');\r\n     * // => 'abc_-_'\r\n     *\r\n     * _.padEnd('abc', 3);\r\n     * // => 'abc'\r\n     */\r\n    function padEnd(string, length, chars) {\r\n      string = toString(string);\r\n      length = toInteger(length);\r\n\r\n      var strLength = length ? stringSize(string) : 0;\r\n      return (length && strLength < length)\r\n        ? (string + createPadding(length - strLength, chars))\r\n        : string;\r\n    }\r\n\r\n    /**\r\n     * Pads `string` on the left side if it's shorter than `length`. Padding\r\n     * characters are truncated if they exceed `length`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category String\r\n     * @param {string} [string=''] The string to pad.\r\n     * @param {number} [length=0] The padding length.\r\n     * @param {string} [chars=' '] The string used as padding.\r\n     * @returns {string} Returns the padded string.\r\n     * @example\r\n     *\r\n     * _.padStart('abc', 6);\r\n     * // => '   abc'\r\n     *\r\n     * _.padStart('abc', 6, '_-');\r\n     * // => '_-_abc'\r\n     *\r\n     * _.padStart('abc', 3);\r\n     * // => 'abc'\r\n     */\r\n    function padStart(string, length, chars) {\r\n      string = toString(string);\r\n      length = toInteger(length);\r\n\r\n      var strLength = length ? stringSize(string) : 0;\r\n      return (length && strLength < length)\r\n        ? (createPadding(length - strLength, chars) + string)\r\n        : string;\r\n    }\r\n\r\n    /**\r\n     * Converts `string` to an integer of the specified radix. If `radix` is\r\n     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a\r\n     * hexadecimal, in which case a `radix` of `16` is used.\r\n     *\r\n     * **Note:** This method aligns with the\r\n     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 1.1.0\r\n     * @category String\r\n     * @param {string} string The string to convert.\r\n     * @param {number} [radix=10] The radix to interpret `value` by.\r\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\r\n     * @returns {number} Returns the converted integer.\r\n     * @example\r\n     *\r\n     * _.parseInt('08');\r\n     * // => 8\r\n     *\r\n     * _.map(['6', '08', '10'], _.parseInt);\r\n     * // => [6, 8, 10]\r\n     */\r\n    function parseInt(string, radix, guard) {\r\n      if (guard || radix == null) {\r\n        radix = 0;\r\n      } else if (radix) {\r\n        radix = +radix;\r\n      }\r\n      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);\r\n    }\r\n\r\n    /**\r\n     * Repeats the given string `n` times.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.0.0\r\n     * @category String\r\n     * @param {string} [string=''] The string to repeat.\r\n     * @param {number} [n=1] The number of times to repeat the string.\r\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\r\n     * @returns {string} Returns the repeated string.\r\n     * @example\r\n     *\r\n     * _.repeat('*', 3);\r\n     * // => '***'\r\n     *\r\n     * _.repeat('abc', 2);\r\n     * // => 'abcabc'\r\n     *\r\n     * _.repeat('abc', 0);\r\n     * // => ''\r\n     */\r\n    function repeat(string, n, guard) {\r\n      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {\r\n        n = 1;\r\n      } else {\r\n        n = toInteger(n);\r\n      }\r\n      return baseRepeat(toString(string), n);\r\n    }\r\n\r\n    /**\r\n     * Replaces matches for `pattern` in `string` with `replacement`.\r\n     *\r\n     * **Note:** This method is based on\r\n     * [`String#replace`](https://mdn.io/String/replace).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category String\r\n     * @param {string} [string=''] The string to modify.\r\n     * @param {RegExp|string} pattern The pattern to replace.\r\n     * @param {Function|string} replacement The match replacement.\r\n     * @returns {string} Returns the modified string.\r\n     * @example\r\n     *\r\n     * _.replace('Hi Fred', 'Fred', 'Barney');\r\n     * // => 'Hi Barney'\r\n     */\r\n    function replace() {\r\n      var args = arguments,\r\n          string = toString(args[0]);\r\n\r\n      return args.length < 3 ? string : string.replace(args[1], args[2]);\r\n    }\r\n\r\n    /**\r\n     * Converts `string` to\r\n     * [snake case](https://en.wikipedia.org/wiki/Snake_case).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.0.0\r\n     * @category String\r\n     * @param {string} [string=''] The string to convert.\r\n     * @returns {string} Returns the snake cased string.\r\n     * @example\r\n     *\r\n     * _.snakeCase('Foo Bar');\r\n     * // => 'foo_bar'\r\n     *\r\n     * _.snakeCase('fooBar');\r\n     * // => 'foo_bar'\r\n     *\r\n     * _.snakeCase('--FOO-BAR--');\r\n     * // => 'foo_bar'\r\n     */\r\n    var snakeCase = createCompounder(function(result, word, index) {\r\n      return result + (index ? '_' : '') + word.toLowerCase();\r\n    });\r\n\r\n    /**\r\n     * Splits `string` by `separator`.\r\n     *\r\n     * **Note:** This method is based on\r\n     * [`String#split`](https://mdn.io/String/split).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category String\r\n     * @param {string} [string=''] The string to split.\r\n     * @param {RegExp|string} separator The separator pattern to split by.\r\n     * @param {number} [limit] The length to truncate results to.\r\n     * @returns {Array} Returns the string segments.\r\n     * @example\r\n     *\r\n     * _.split('a-b-c', '-', 2);\r\n     * // => ['a', 'b']\r\n     */\r\n    function split(string, separator, limit) {\r\n      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {\r\n        separator = limit = undefined;\r\n      }\r\n      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;\r\n      if (!limit) {\r\n        return [];\r\n      }\r\n      string = toString(string);\r\n      if (string && (\r\n            typeof separator == 'string' ||\r\n            (separator != null && !isRegExp(separator))\r\n          )) {\r\n        separator = baseToString(separator);\r\n        if (!separator && hasUnicode(string)) {\r\n          return castSlice(stringToArray(string), 0, limit);\r\n        }\r\n      }\r\n      return string.split(separator, limit);\r\n    }\r\n\r\n    /**\r\n     * Converts `string` to\r\n     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.1.0\r\n     * @category String\r\n     * @param {string} [string=''] The string to convert.\r\n     * @returns {string} Returns the start cased string.\r\n     * @example\r\n     *\r\n     * _.startCase('--foo-bar--');\r\n     * // => 'Foo Bar'\r\n     *\r\n     * _.startCase('fooBar');\r\n     * // => 'Foo Bar'\r\n     *\r\n     * _.startCase('__FOO_BAR__');\r\n     * // => 'FOO BAR'\r\n     */\r\n    var startCase = createCompounder(function(result, word, index) {\r\n      return result + (index ? ' ' : '') + upperFirst(word);\r\n    });\r\n\r\n    /**\r\n     * Checks if `string` starts with the given target string.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.0.0\r\n     * @category String\r\n     * @param {string} [string=''] The string to inspect.\r\n     * @param {string} [target] The string to search for.\r\n     * @param {number} [position=0] The position to search from.\r\n     * @returns {boolean} Returns `true` if `string` starts with `target`,\r\n     *  else `false`.\r\n     * @example\r\n     *\r\n     * _.startsWith('abc', 'a');\r\n     * // => true\r\n     *\r\n     * _.startsWith('abc', 'b');\r\n     * // => false\r\n     *\r\n     * _.startsWith('abc', 'b', 1);\r\n     * // => true\r\n     */\r\n    function startsWith(string, target, position) {\r\n      string = toString(string);\r\n      position = position == null\r\n        ? 0\r\n        : baseClamp(toInteger(position), 0, string.length);\r\n\r\n      target = baseToString(target);\r\n      return string.slice(position, position + target.length) == target;\r\n    }\r\n\r\n    /**\r\n     * Creates a compiled template function that can interpolate data properties\r\n     * in \"interpolate\" delimiters, HTML-escape interpolated data properties in\r\n     * \"escape\" delimiters, and execute JavaScript in \"evaluate\" delimiters. Data\r\n     * properties may be accessed as free variables in the template. If a setting\r\n     * object is given, it takes precedence over `_.templateSettings` values.\r\n     *\r\n     * **Note:** In the development build `_.template` utilizes\r\n     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)\r\n     * for easier debugging.\r\n     *\r\n     * For more information on precompiling templates see\r\n     * [lodash's custom builds documentation](https://lodash.com/custom-builds).\r\n     *\r\n     * For more information on Chrome extension sandboxes see\r\n     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).\r\n     *\r\n     * @static\r\n     * @since 0.1.0\r\n     * @memberOf _\r\n     * @category String\r\n     * @param {string} [string=''] The template string.\r\n     * @param {Object} [options={}] The options object.\r\n     * @param {RegExp} [options.escape=_.templateSettings.escape]\r\n     *  The HTML \"escape\" delimiter.\r\n     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]\r\n     *  The \"evaluate\" delimiter.\r\n     * @param {Object} [options.imports=_.templateSettings.imports]\r\n     *  An object to import into the template as free variables.\r\n     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]\r\n     *  The \"interpolate\" delimiter.\r\n     * @param {string} [options.sourceURL='lodash.templateSources[n]']\r\n     *  The sourceURL of the compiled template.\r\n     * @param {string} [options.variable='obj']\r\n     *  The data object variable name.\r\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\r\n     * @returns {Function} Returns the compiled template function.\r\n     * @example\r\n     *\r\n     * // Use the \"interpolate\" delimiter to create a compiled template.\r\n     * var compiled = _.template('hello <%= user %>!');\r\n     * compiled({ 'user': 'fred' });\r\n     * // => 'hello fred!'\r\n     *\r\n     * // Use the HTML \"escape\" delimiter to escape data property values.\r\n     * var compiled = _.template('<b><%- value %></b>');\r\n     * compiled({ 'value': '<script>' });\r\n     * // => '<b>&lt;script&gt;</b>'\r\n     *\r\n     * // Use the \"evaluate\" delimiter to execute JavaScript and generate HTML.\r\n     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');\r\n     * compiled({ 'users': ['fred', 'barney'] });\r\n     * // => '<li>fred</li><li>barney</li>'\r\n     *\r\n     * // Use the internal `print` function in \"evaluate\" delimiters.\r\n     * var compiled = _.template('<% print(\"hello \" + user); %>!');\r\n     * compiled({ 'user': 'barney' });\r\n     * // => 'hello barney!'\r\n     *\r\n     * // Use the ES template literal delimiter as an \"interpolate\" delimiter.\r\n     * // Disable support by replacing the \"interpolate\" delimiter.\r\n     * var compiled = _.template('hello ${ user }!');\r\n     * compiled({ 'user': 'pebbles' });\r\n     * // => 'hello pebbles!'\r\n     *\r\n     * // Use backslashes to treat delimiters as plain text.\r\n     * var compiled = _.template('<%= \"\\\\<%- value %\\\\>\" %>');\r\n     * compiled({ 'value': 'ignored' });\r\n     * // => '<%- value %>'\r\n     *\r\n     * // Use the `imports` option to import `jQuery` as `jq`.\r\n     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';\r\n     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });\r\n     * compiled({ 'users': ['fred', 'barney'] });\r\n     * // => '<li>fred</li><li>barney</li>'\r\n     *\r\n     * // Use the `sourceURL` option to specify a custom sourceURL for the template.\r\n     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });\r\n     * compiled(data);\r\n     * // => Find the source of \"greeting.jst\" under the Sources tab or Resources panel of the web inspector.\r\n     *\r\n     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.\r\n     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });\r\n     * compiled.source;\r\n     * // => function(data) {\r\n     * //   var __t, __p = '';\r\n     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';\r\n     * //   return __p;\r\n     * // }\r\n     *\r\n     * // Use custom template delimiters.\r\n     * _.templateSettings.interpolate = /{{([\\s\\S]+?)}}/g;\r\n     * var compiled = _.template('hello {{ user }}!');\r\n     * compiled({ 'user': 'mustache' });\r\n     * // => 'hello mustache!'\r\n     *\r\n     * // Use the `source` property to inline compiled templates for meaningful\r\n     * // line numbers in error messages and stack traces.\r\n     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\\\r\n     *   var JST = {\\\r\n     *     \"main\": ' + _.template(mainText).source + '\\\r\n     *   };\\\r\n     * ');\r\n     */\r\n    function template(string, options, guard) {\r\n      // Based on John Resig's `tmpl` implementation\r\n      // (http://ejohn.org/blog/javascript-micro-templating/)\r\n      // and Laura Doktorova's doT.js (https://github.com/olado/doT).\r\n      var settings = lodash.templateSettings;\r\n\r\n      if (guard && isIterateeCall(string, options, guard)) {\r\n        options = undefined;\r\n      }\r\n      string = toString(string);\r\n      options = assignInWith({}, options, settings, customDefaultsAssignIn);\r\n\r\n      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),\r\n          importsKeys = keys(imports),\r\n          importsValues = baseValues(imports, importsKeys);\r\n\r\n      var isEscaping,\r\n          isEvaluating,\r\n          index = 0,\r\n          interpolate = options.interpolate || reNoMatch,\r\n          source = \"__p += '\";\r\n\r\n      // Compile the regexp to match each delimiter.\r\n      var reDelimiters = RegExp(\r\n        (options.escape || reNoMatch).source + '|' +\r\n        interpolate.source + '|' +\r\n        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +\r\n        (options.evaluate || reNoMatch).source + '|$'\r\n      , 'g');\r\n\r\n      // Use a sourceURL for easier debugging.\r\n      // The sourceURL gets injected into the source that's eval-ed, so be careful\r\n      // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in\r\n      // and escape the comment, thus injecting code that gets evaled.\r\n      var sourceURL = '//# sourceURL=' +\r\n        (hasOwnProperty.call(options, 'sourceURL')\r\n          ? (options.sourceURL + '').replace(/\\s/g, ' ')\r\n          : ('lodash.templateSources[' + (++templateCounter) + ']')\r\n        ) + '\\n';\r\n\r\n      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {\r\n        interpolateValue || (interpolateValue = esTemplateValue);\r\n\r\n        // Escape characters that can't be included in string literals.\r\n        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);\r\n\r\n        // Replace delimiters with snippets.\r\n        if (escapeValue) {\r\n          isEscaping = true;\r\n          source += \"' +\\n__e(\" + escapeValue + \") +\\n'\";\r\n        }\r\n        if (evaluateValue) {\r\n          isEvaluating = true;\r\n          source += \"';\\n\" + evaluateValue + \";\\n__p += '\";\r\n        }\r\n        if (interpolateValue) {\r\n          source += \"' +\\n((__t = (\" + interpolateValue + \")) == null ? '' : __t) +\\n'\";\r\n        }\r\n        index = offset + match.length;\r\n\r\n        // The JS engine embedded in Adobe products needs `match` returned in\r\n        // order to produce the correct `offset` value.\r\n        return match;\r\n      });\r\n\r\n      source += \"';\\n\";\r\n\r\n      // If `variable` is not specified wrap a with-statement around the generated\r\n      // code to add the data object to the top of the scope chain.\r\n      var variable = hasOwnProperty.call(options, 'variable') && options.variable;\r\n      if (!variable) {\r\n        source = 'with (obj) {\\n' + source + '\\n}\\n';\r\n      }\r\n      // Throw an error if a forbidden character was found in `variable`, to prevent\r\n      // potential command injection attacks.\r\n      else if (reForbiddenIdentifierChars.test(variable)) {\r\n        throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);\r\n      }\r\n\r\n      // Cleanup code by stripping empty strings.\r\n      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)\r\n        .replace(reEmptyStringMiddle, '$1')\r\n        .replace(reEmptyStringTrailing, '$1;');\r\n\r\n      // Frame code as the function body.\r\n      source = 'function(' + (variable || 'obj') + ') {\\n' +\r\n        (variable\r\n          ? ''\r\n          : 'obj || (obj = {});\\n'\r\n        ) +\r\n        \"var __t, __p = ''\" +\r\n        (isEscaping\r\n           ? ', __e = _.escape'\r\n           : ''\r\n        ) +\r\n        (isEvaluating\r\n          ? ', __j = Array.prototype.join;\\n' +\r\n            \"function print() { __p += __j.call(arguments, '') }\\n\"\r\n          : ';\\n'\r\n        ) +\r\n        source +\r\n        'return __p\\n}';\r\n\r\n      var result = attempt(function() {\r\n        return Function(importsKeys, sourceURL + 'return ' + source)\r\n          .apply(undefined, importsValues);\r\n      });\r\n\r\n      // Provide the compiled function's source by its `toString` method or\r\n      // the `source` property as a convenience for inlining compiled templates.\r\n      result.source = source;\r\n      if (isError(result)) {\r\n        throw result;\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Converts `string`, as a whole, to lower case just like\r\n     * [String#toLowerCase](https://mdn.io/toLowerCase).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category String\r\n     * @param {string} [string=''] The string to convert.\r\n     * @returns {string} Returns the lower cased string.\r\n     * @example\r\n     *\r\n     * _.toLower('--Foo-Bar--');\r\n     * // => '--foo-bar--'\r\n     *\r\n     * _.toLower('fooBar');\r\n     * // => 'foobar'\r\n     *\r\n     * _.toLower('__FOO_BAR__');\r\n     * // => '__foo_bar__'\r\n     */\r\n    function toLower(value) {\r\n      return toString(value).toLowerCase();\r\n    }\r\n\r\n    /**\r\n     * Converts `string`, as a whole, to upper case just like\r\n     * [String#toUpperCase](https://mdn.io/toUpperCase).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category String\r\n     * @param {string} [string=''] The string to convert.\r\n     * @returns {string} Returns the upper cased string.\r\n     * @example\r\n     *\r\n     * _.toUpper('--foo-bar--');\r\n     * // => '--FOO-BAR--'\r\n     *\r\n     * _.toUpper('fooBar');\r\n     * // => 'FOOBAR'\r\n     *\r\n     * _.toUpper('__foo_bar__');\r\n     * // => '__FOO_BAR__'\r\n     */\r\n    function toUpper(value) {\r\n      return toString(value).toUpperCase();\r\n    }\r\n\r\n    /**\r\n     * Removes leading and trailing whitespace or specified characters from `string`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.0.0\r\n     * @category String\r\n     * @param {string} [string=''] The string to trim.\r\n     * @param {string} [chars=whitespace] The characters to trim.\r\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\r\n     * @returns {string} Returns the trimmed string.\r\n     * @example\r\n     *\r\n     * _.trim('  abc  ');\r\n     * // => 'abc'\r\n     *\r\n     * _.trim('-_-abc-_-', '_-');\r\n     * // => 'abc'\r\n     *\r\n     * _.map(['  foo  ', '  bar  '], _.trim);\r\n     * // => ['foo', 'bar']\r\n     */\r\n    function trim(string, chars, guard) {\r\n      string = toString(string);\r\n      if (string && (guard || chars === undefined)) {\r\n        return baseTrim(string);\r\n      }\r\n      if (!string || !(chars = baseToString(chars))) {\r\n        return string;\r\n      }\r\n      var strSymbols = stringToArray(string),\r\n          chrSymbols = stringToArray(chars),\r\n          start = charsStartIndex(strSymbols, chrSymbols),\r\n          end = charsEndIndex(strSymbols, chrSymbols) + 1;\r\n\r\n      return castSlice(strSymbols, start, end).join('');\r\n    }\r\n\r\n    /**\r\n     * Removes trailing whitespace or specified characters from `string`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category String\r\n     * @param {string} [string=''] The string to trim.\r\n     * @param {string} [chars=whitespace] The characters to trim.\r\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\r\n     * @returns {string} Returns the trimmed string.\r\n     * @example\r\n     *\r\n     * _.trimEnd('  abc  ');\r\n     * // => '  abc'\r\n     *\r\n     * _.trimEnd('-_-abc-_-', '_-');\r\n     * // => '-_-abc'\r\n     */\r\n    function trimEnd(string, chars, guard) {\r\n      string = toString(string);\r\n      if (string && (guard || chars === undefined)) {\r\n        return string.slice(0, trimmedEndIndex(string) + 1);\r\n      }\r\n      if (!string || !(chars = baseToString(chars))) {\r\n        return string;\r\n      }\r\n      var strSymbols = stringToArray(string),\r\n          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;\r\n\r\n      return castSlice(strSymbols, 0, end).join('');\r\n    }\r\n\r\n    /**\r\n     * Removes leading whitespace or specified characters from `string`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category String\r\n     * @param {string} [string=''] The string to trim.\r\n     * @param {string} [chars=whitespace] The characters to trim.\r\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\r\n     * @returns {string} Returns the trimmed string.\r\n     * @example\r\n     *\r\n     * _.trimStart('  abc  ');\r\n     * // => 'abc  '\r\n     *\r\n     * _.trimStart('-_-abc-_-', '_-');\r\n     * // => 'abc-_-'\r\n     */\r\n    function trimStart(string, chars, guard) {\r\n      string = toString(string);\r\n      if (string && (guard || chars === undefined)) {\r\n        return string.replace(reTrimStart, '');\r\n      }\r\n      if (!string || !(chars = baseToString(chars))) {\r\n        return string;\r\n      }\r\n      var strSymbols = stringToArray(string),\r\n          start = charsStartIndex(strSymbols, stringToArray(chars));\r\n\r\n      return castSlice(strSymbols, start).join('');\r\n    }\r\n\r\n    /**\r\n     * Truncates `string` if it's longer than the given maximum string length.\r\n     * The last characters of the truncated string are replaced with the omission\r\n     * string which defaults to \"...\".\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category String\r\n     * @param {string} [string=''] The string to truncate.\r\n     * @param {Object} [options={}] The options object.\r\n     * @param {number} [options.length=30] The maximum string length.\r\n     * @param {string} [options.omission='...'] The string to indicate text is omitted.\r\n     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.\r\n     * @returns {string} Returns the truncated string.\r\n     * @example\r\n     *\r\n     * _.truncate('hi-diddly-ho there, neighborino');\r\n     * // => 'hi-diddly-ho there, neighbo...'\r\n     *\r\n     * _.truncate('hi-diddly-ho there, neighborino', {\r\n     *   'length': 24,\r\n     *   'separator': ' '\r\n     * });\r\n     * // => 'hi-diddly-ho there,...'\r\n     *\r\n     * _.truncate('hi-diddly-ho there, neighborino', {\r\n     *   'length': 24,\r\n     *   'separator': /,? +/\r\n     * });\r\n     * // => 'hi-diddly-ho there...'\r\n     *\r\n     * _.truncate('hi-diddly-ho there, neighborino', {\r\n     *   'omission': ' [...]'\r\n     * });\r\n     * // => 'hi-diddly-ho there, neig [...]'\r\n     */\r\n    function truncate(string, options) {\r\n      var length = DEFAULT_TRUNC_LENGTH,\r\n          omission = DEFAULT_TRUNC_OMISSION;\r\n\r\n      if (isObject(options)) {\r\n        var separator = 'separator' in options ? options.separator : separator;\r\n        length = 'length' in options ? toInteger(options.length) : length;\r\n        omission = 'omission' in options ? baseToString(options.omission) : omission;\r\n      }\r\n      string = toString(string);\r\n\r\n      var strLength = string.length;\r\n      if (hasUnicode(string)) {\r\n        var strSymbols = stringToArray(string);\r\n        strLength = strSymbols.length;\r\n      }\r\n      if (length >= strLength) {\r\n        return string;\r\n      }\r\n      var end = length - stringSize(omission);\r\n      if (end < 1) {\r\n        return omission;\r\n      }\r\n      var result = strSymbols\r\n        ? castSlice(strSymbols, 0, end).join('')\r\n        : string.slice(0, end);\r\n\r\n      if (separator === undefined) {\r\n        return result + omission;\r\n      }\r\n      if (strSymbols) {\r\n        end += (result.length - end);\r\n      }\r\n      if (isRegExp(separator)) {\r\n        if (string.slice(end).search(separator)) {\r\n          var match,\r\n              substring = result;\r\n\r\n          if (!separator.global) {\r\n            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');\r\n          }\r\n          separator.lastIndex = 0;\r\n          while ((match = separator.exec(substring))) {\r\n            var newEnd = match.index;\r\n          }\r\n          result = result.slice(0, newEnd === undefined ? end : newEnd);\r\n        }\r\n      } else if (string.indexOf(baseToString(separator), end) != end) {\r\n        var index = result.lastIndexOf(separator);\r\n        if (index > -1) {\r\n          result = result.slice(0, index);\r\n        }\r\n      }\r\n      return result + omission;\r\n    }\r\n\r\n    /**\r\n     * The inverse of `_.escape`; this method converts the HTML entities\r\n     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to\r\n     * their corresponding characters.\r\n     *\r\n     * **Note:** No other HTML entities are unescaped. To unescape additional\r\n     * HTML entities use a third-party library like [_he_](https://mths.be/he).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.6.0\r\n     * @category String\r\n     * @param {string} [string=''] The string to unescape.\r\n     * @returns {string} Returns the unescaped string.\r\n     * @example\r\n     *\r\n     * _.unescape('fred, barney, &amp; pebbles');\r\n     * // => 'fred, barney, & pebbles'\r\n     */\r\n    function unescape(string) {\r\n      string = toString(string);\r\n      return (string && reHasEscapedHtml.test(string))\r\n        ? string.replace(reEscapedHtml, unescapeHtmlChar)\r\n        : string;\r\n    }\r\n\r\n    /**\r\n     * Converts `string`, as space separated words, to upper case.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category String\r\n     * @param {string} [string=''] The string to convert.\r\n     * @returns {string} Returns the upper cased string.\r\n     * @example\r\n     *\r\n     * _.upperCase('--foo-bar');\r\n     * // => 'FOO BAR'\r\n     *\r\n     * _.upperCase('fooBar');\r\n     * // => 'FOO BAR'\r\n     *\r\n     * _.upperCase('__foo_bar__');\r\n     * // => 'FOO BAR'\r\n     */\r\n    var upperCase = createCompounder(function(result, word, index) {\r\n      return result + (index ? ' ' : '') + word.toUpperCase();\r\n    });\r\n\r\n    /**\r\n     * Converts the first character of `string` to upper case.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category String\r\n     * @param {string} [string=''] The string to convert.\r\n     * @returns {string} Returns the converted string.\r\n     * @example\r\n     *\r\n     * _.upperFirst('fred');\r\n     * // => 'Fred'\r\n     *\r\n     * _.upperFirst('FRED');\r\n     * // => 'FRED'\r\n     */\r\n    var upperFirst = createCaseFirst('toUpperCase');\r\n\r\n    /**\r\n     * Splits `string` into an array of its words.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.0.0\r\n     * @category String\r\n     * @param {string} [string=''] The string to inspect.\r\n     * @param {RegExp|string} [pattern] The pattern to match words.\r\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\r\n     * @returns {Array} Returns the words of `string`.\r\n     * @example\r\n     *\r\n     * _.words('fred, barney, & pebbles');\r\n     * // => ['fred', 'barney', 'pebbles']\r\n     *\r\n     * _.words('fred, barney, & pebbles', /[^, ]+/g);\r\n     * // => ['fred', 'barney', '&', 'pebbles']\r\n     */\r\n    function words(string, pattern, guard) {\r\n      string = toString(string);\r\n      pattern = guard ? undefined : pattern;\r\n\r\n      if (pattern === undefined) {\r\n        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);\r\n      }\r\n      return string.match(pattern) || [];\r\n    }\r\n\r\n    /*------------------------------------------------------------------------*/\r\n\r\n    /**\r\n     * Attempts to invoke `func`, returning either the result or the caught error\r\n     * object. Any additional arguments are provided to `func` when it's invoked.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.0.0\r\n     * @category Util\r\n     * @param {Function} func The function to attempt.\r\n     * @param {...*} [args] The arguments to invoke `func` with.\r\n     * @returns {*} Returns the `func` result or error object.\r\n     * @example\r\n     *\r\n     * // Avoid throwing errors for invalid selectors.\r\n     * var elements = _.attempt(function(selector) {\r\n     *   return document.querySelectorAll(selector);\r\n     * }, '>_>');\r\n     *\r\n     * if (_.isError(elements)) {\r\n     *   elements = [];\r\n     * }\r\n     */\r\n    var attempt = baseRest(function(func, args) {\r\n      try {\r\n        return apply(func, undefined, args);\r\n      } catch (e) {\r\n        return isError(e) ? e : new Error(e);\r\n      }\r\n    });\r\n\r\n    /**\r\n     * Binds methods of an object to the object itself, overwriting the existing\r\n     * method.\r\n     *\r\n     * **Note:** This method doesn't set the \"length\" property of bound functions.\r\n     *\r\n     * @static\r\n     * @since 0.1.0\r\n     * @memberOf _\r\n     * @category Util\r\n     * @param {Object} object The object to bind and assign the bound methods to.\r\n     * @param {...(string|string[])} methodNames The object method names to bind.\r\n     * @returns {Object} Returns `object`.\r\n     * @example\r\n     *\r\n     * var view = {\r\n     *   'label': 'docs',\r\n     *   'click': function() {\r\n     *     console.log('clicked ' + this.label);\r\n     *   }\r\n     * };\r\n     *\r\n     * _.bindAll(view, ['click']);\r\n     * jQuery(element).on('click', view.click);\r\n     * // => Logs 'clicked docs' when clicked.\r\n     */\r\n    var bindAll = flatRest(function(object, methodNames) {\r\n      arrayEach(methodNames, function(key) {\r\n        key = toKey(key);\r\n        baseAssignValue(object, key, bind(object[key], object));\r\n      });\r\n      return object;\r\n    });\r\n\r\n    /**\r\n     * Creates a function that iterates over `pairs` and invokes the corresponding\r\n     * function of the first predicate to return truthy. The predicate-function\r\n     * pairs are invoked with the `this` binding and arguments of the created\r\n     * function.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Util\r\n     * @param {Array} pairs The predicate-function pairs.\r\n     * @returns {Function} Returns the new composite function.\r\n     * @example\r\n     *\r\n     * var func = _.cond([\r\n     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],\r\n     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],\r\n     *   [_.stubTrue,                      _.constant('no match')]\r\n     * ]);\r\n     *\r\n     * func({ 'a': 1, 'b': 2 });\r\n     * // => 'matches A'\r\n     *\r\n     * func({ 'a': 0, 'b': 1 });\r\n     * // => 'matches B'\r\n     *\r\n     * func({ 'a': '1', 'b': '2' });\r\n     * // => 'no match'\r\n     */\r\n    function cond(pairs) {\r\n      var length = pairs == null ? 0 : pairs.length,\r\n          toIteratee = getIteratee();\r\n\r\n      pairs = !length ? [] : arrayMap(pairs, function(pair) {\r\n        if (typeof pair[1] != 'function') {\r\n          throw new TypeError(FUNC_ERROR_TEXT);\r\n        }\r\n        return [toIteratee(pair[0]), pair[1]];\r\n      });\r\n\r\n      return baseRest(function(args) {\r\n        var index = -1;\r\n        while (++index < length) {\r\n          var pair = pairs[index];\r\n          if (apply(pair[0], this, args)) {\r\n            return apply(pair[1], this, args);\r\n          }\r\n        }\r\n      });\r\n    }\r\n\r\n    /**\r\n     * Creates a function that invokes the predicate properties of `source` with\r\n     * the corresponding property values of a given object, returning `true` if\r\n     * all predicates return truthy, else `false`.\r\n     *\r\n     * **Note:** The created function is equivalent to `_.conformsTo` with\r\n     * `source` partially applied.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Util\r\n     * @param {Object} source The object of property predicates to conform to.\r\n     * @returns {Function} Returns the new spec function.\r\n     * @example\r\n     *\r\n     * var objects = [\r\n     *   { 'a': 2, 'b': 1 },\r\n     *   { 'a': 1, 'b': 2 }\r\n     * ];\r\n     *\r\n     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));\r\n     * // => [{ 'a': 1, 'b': 2 }]\r\n     */\r\n    function conforms(source) {\r\n      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));\r\n    }\r\n\r\n    /**\r\n     * Creates a function that returns `value`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 2.4.0\r\n     * @category Util\r\n     * @param {*} value The value to return from the new function.\r\n     * @returns {Function} Returns the new constant function.\r\n     * @example\r\n     *\r\n     * var objects = _.times(2, _.constant({ 'a': 1 }));\r\n     *\r\n     * console.log(objects);\r\n     * // => [{ 'a': 1 }, { 'a': 1 }]\r\n     *\r\n     * console.log(objects[0] === objects[1]);\r\n     * // => true\r\n     */\r\n    function constant(value) {\r\n      return function() {\r\n        return value;\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Checks `value` to determine whether a default value should be returned in\r\n     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,\r\n     * or `undefined`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.14.0\r\n     * @category Util\r\n     * @param {*} value The value to check.\r\n     * @param {*} defaultValue The default value.\r\n     * @returns {*} Returns the resolved value.\r\n     * @example\r\n     *\r\n     * _.defaultTo(1, 10);\r\n     * // => 1\r\n     *\r\n     * _.defaultTo(undefined, 10);\r\n     * // => 10\r\n     */\r\n    function defaultTo(value, defaultValue) {\r\n      return (value == null || value !== value) ? defaultValue : value;\r\n    }\r\n\r\n    /**\r\n     * Creates a function that returns the result of invoking the given functions\r\n     * with the `this` binding of the created function, where each successive\r\n     * invocation is supplied the return value of the previous.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.0.0\r\n     * @category Util\r\n     * @param {...(Function|Function[])} [funcs] The functions to invoke.\r\n     * @returns {Function} Returns the new composite function.\r\n     * @see _.flowRight\r\n     * @example\r\n     *\r\n     * function square(n) {\r\n     *   return n * n;\r\n     * }\r\n     *\r\n     * var addSquare = _.flow([_.add, square]);\r\n     * addSquare(1, 2);\r\n     * // => 9\r\n     */\r\n    var flow = createFlow();\r\n\r\n    /**\r\n     * This method is like `_.flow` except that it creates a function that\r\n     * invokes the given functions from right to left.\r\n     *\r\n     * @static\r\n     * @since 3.0.0\r\n     * @memberOf _\r\n     * @category Util\r\n     * @param {...(Function|Function[])} [funcs] The functions to invoke.\r\n     * @returns {Function} Returns the new composite function.\r\n     * @see _.flow\r\n     * @example\r\n     *\r\n     * function square(n) {\r\n     *   return n * n;\r\n     * }\r\n     *\r\n     * var addSquare = _.flowRight([square, _.add]);\r\n     * addSquare(1, 2);\r\n     * // => 9\r\n     */\r\n    var flowRight = createFlow(true);\r\n\r\n    /**\r\n     * This method returns the first argument it receives.\r\n     *\r\n     * @static\r\n     * @since 0.1.0\r\n     * @memberOf _\r\n     * @category Util\r\n     * @param {*} value Any value.\r\n     * @returns {*} Returns `value`.\r\n     * @example\r\n     *\r\n     * var object = { 'a': 1 };\r\n     *\r\n     * console.log(_.identity(object) === object);\r\n     * // => true\r\n     */\r\n    function identity(value) {\r\n      return value;\r\n    }\r\n\r\n    /**\r\n     * Creates a function that invokes `func` with the arguments of the created\r\n     * function. If `func` is a property name, the created function returns the\r\n     * property value for a given element. If `func` is an array or object, the\r\n     * created function returns `true` for elements that contain the equivalent\r\n     * source properties, otherwise it returns `false`.\r\n     *\r\n     * @static\r\n     * @since 4.0.0\r\n     * @memberOf _\r\n     * @category Util\r\n     * @param {*} [func=_.identity] The value to convert to a callback.\r\n     * @returns {Function} Returns the callback.\r\n     * @example\r\n     *\r\n     * var users = [\r\n     *   { 'user': 'barney', 'age': 36, 'active': true },\r\n     *   { 'user': 'fred',   'age': 40, 'active': false }\r\n     * ];\r\n     *\r\n     * // The `_.matches` iteratee shorthand.\r\n     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));\r\n     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]\r\n     *\r\n     * // The `_.matchesProperty` iteratee shorthand.\r\n     * _.filter(users, _.iteratee(['user', 'fred']));\r\n     * // => [{ 'user': 'fred', 'age': 40 }]\r\n     *\r\n     * // The `_.property` iteratee shorthand.\r\n     * _.map(users, _.iteratee('user'));\r\n     * // => ['barney', 'fred']\r\n     *\r\n     * // Create custom iteratee shorthands.\r\n     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {\r\n     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {\r\n     *     return func.test(string);\r\n     *   };\r\n     * });\r\n     *\r\n     * _.filter(['abc', 'def'], /ef/);\r\n     * // => ['def']\r\n     */\r\n    function iteratee(func) {\r\n      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));\r\n    }\r\n\r\n    /**\r\n     * Creates a function that performs a partial deep comparison between a given\r\n     * object and `source`, returning `true` if the given object has equivalent\r\n     * property values, else `false`.\r\n     *\r\n     * **Note:** The created function is equivalent to `_.isMatch` with `source`\r\n     * partially applied.\r\n     *\r\n     * Partial comparisons will match empty array and empty object `source`\r\n     * values against any array or object value, respectively. See `_.isEqual`\r\n     * for a list of supported value comparisons.\r\n     *\r\n     * **Note:** Multiple values can be checked by combining several matchers\r\n     * using `_.overSome`\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.0.0\r\n     * @category Util\r\n     * @param {Object} source The object of property values to match.\r\n     * @returns {Function} Returns the new spec function.\r\n     * @example\r\n     *\r\n     * var objects = [\r\n     *   { 'a': 1, 'b': 2, 'c': 3 },\r\n     *   { 'a': 4, 'b': 5, 'c': 6 }\r\n     * ];\r\n     *\r\n     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));\r\n     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]\r\n     *\r\n     * // Checking for several possible values\r\n     * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));\r\n     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]\r\n     */\r\n    function matches(source) {\r\n      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));\r\n    }\r\n\r\n    /**\r\n     * Creates a function that performs a partial deep comparison between the\r\n     * value at `path` of a given object to `srcValue`, returning `true` if the\r\n     * object value is equivalent, else `false`.\r\n     *\r\n     * **Note:** Partial comparisons will match empty array and empty object\r\n     * `srcValue` values against any array or object value, respectively. See\r\n     * `_.isEqual` for a list of supported value comparisons.\r\n     *\r\n     * **Note:** Multiple values can be checked by combining several matchers\r\n     * using `_.overSome`\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.2.0\r\n     * @category Util\r\n     * @param {Array|string} path The path of the property to get.\r\n     * @param {*} srcValue The value to match.\r\n     * @returns {Function} Returns the new spec function.\r\n     * @example\r\n     *\r\n     * var objects = [\r\n     *   { 'a': 1, 'b': 2, 'c': 3 },\r\n     *   { 'a': 4, 'b': 5, 'c': 6 }\r\n     * ];\r\n     *\r\n     * _.find(objects, _.matchesProperty('a', 4));\r\n     * // => { 'a': 4, 'b': 5, 'c': 6 }\r\n     *\r\n     * // Checking for several possible values\r\n     * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));\r\n     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]\r\n     */\r\n    function matchesProperty(path, srcValue) {\r\n      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));\r\n    }\r\n\r\n    /**\r\n     * Creates a function that invokes the method at `path` of a given object.\r\n     * Any additional arguments are provided to the invoked method.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.7.0\r\n     * @category Util\r\n     * @param {Array|string} path The path of the method to invoke.\r\n     * @param {...*} [args] The arguments to invoke the method with.\r\n     * @returns {Function} Returns the new invoker function.\r\n     * @example\r\n     *\r\n     * var objects = [\r\n     *   { 'a': { 'b': _.constant(2) } },\r\n     *   { 'a': { 'b': _.constant(1) } }\r\n     * ];\r\n     *\r\n     * _.map(objects, _.method('a.b'));\r\n     * // => [2, 1]\r\n     *\r\n     * _.map(objects, _.method(['a', 'b']));\r\n     * // => [2, 1]\r\n     */\r\n    var method = baseRest(function(path, args) {\r\n      return function(object) {\r\n        return baseInvoke(object, path, args);\r\n      };\r\n    });\r\n\r\n    /**\r\n     * The opposite of `_.method`; this method creates a function that invokes\r\n     * the method at a given path of `object`. Any additional arguments are\r\n     * provided to the invoked method.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.7.0\r\n     * @category Util\r\n     * @param {Object} object The object to query.\r\n     * @param {...*} [args] The arguments to invoke the method with.\r\n     * @returns {Function} Returns the new invoker function.\r\n     * @example\r\n     *\r\n     * var array = _.times(3, _.constant),\r\n     *     object = { 'a': array, 'b': array, 'c': array };\r\n     *\r\n     * _.map(['a[2]', 'c[0]'], _.methodOf(object));\r\n     * // => [2, 0]\r\n     *\r\n     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));\r\n     * // => [2, 0]\r\n     */\r\n    var methodOf = baseRest(function(object, args) {\r\n      return function(path) {\r\n        return baseInvoke(object, path, args);\r\n      };\r\n    });\r\n\r\n    /**\r\n     * Adds all own enumerable string keyed function properties of a source\r\n     * object to the destination object. If `object` is a function, then methods\r\n     * are added to its prototype as well.\r\n     *\r\n     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to\r\n     * avoid conflicts caused by modifying the original.\r\n     *\r\n     * @static\r\n     * @since 0.1.0\r\n     * @memberOf _\r\n     * @category Util\r\n     * @param {Function|Object} [object=lodash] The destination object.\r\n     * @param {Object} source The object of functions to add.\r\n     * @param {Object} [options={}] The options object.\r\n     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.\r\n     * @returns {Function|Object} Returns `object`.\r\n     * @example\r\n     *\r\n     * function vowels(string) {\r\n     *   return _.filter(string, function(v) {\r\n     *     return /[aeiou]/i.test(v);\r\n     *   });\r\n     * }\r\n     *\r\n     * _.mixin({ 'vowels': vowels });\r\n     * _.vowels('fred');\r\n     * // => ['e']\r\n     *\r\n     * _('fred').vowels().value();\r\n     * // => ['e']\r\n     *\r\n     * _.mixin({ 'vowels': vowels }, { 'chain': false });\r\n     * _('fred').vowels();\r\n     * // => ['e']\r\n     */\r\n    function mixin(object, source, options) {\r\n      var props = keys(source),\r\n          methodNames = baseFunctions(source, props);\r\n\r\n      if (options == null &&\r\n          !(isObject(source) && (methodNames.length || !props.length))) {\r\n        options = source;\r\n        source = object;\r\n        object = this;\r\n        methodNames = baseFunctions(source, keys(source));\r\n      }\r\n      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,\r\n          isFunc = isFunction(object);\r\n\r\n      arrayEach(methodNames, function(methodName) {\r\n        var func = source[methodName];\r\n        object[methodName] = func;\r\n        if (isFunc) {\r\n          object.prototype[methodName] = function() {\r\n            var chainAll = this.__chain__;\r\n            if (chain || chainAll) {\r\n              var result = object(this.__wrapped__),\r\n                  actions = result.__actions__ = copyArray(this.__actions__);\r\n\r\n              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });\r\n              result.__chain__ = chainAll;\r\n              return result;\r\n            }\r\n            return func.apply(object, arrayPush([this.value()], arguments));\r\n          };\r\n        }\r\n      });\r\n\r\n      return object;\r\n    }\r\n\r\n    /**\r\n     * Reverts the `_` variable to its previous value and returns a reference to\r\n     * the `lodash` function.\r\n     *\r\n     * @static\r\n     * @since 0.1.0\r\n     * @memberOf _\r\n     * @category Util\r\n     * @returns {Function} Returns the `lodash` function.\r\n     * @example\r\n     *\r\n     * var lodash = _.noConflict();\r\n     */\r\n    function noConflict() {\r\n      if (root._ === this) {\r\n        root._ = oldDash;\r\n      }\r\n      return this;\r\n    }\r\n\r\n    /**\r\n     * This method returns `undefined`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 2.3.0\r\n     * @category Util\r\n     * @example\r\n     *\r\n     * _.times(2, _.noop);\r\n     * // => [undefined, undefined]\r\n     */\r\n    function noop() {\r\n      // No operation performed.\r\n    }\r\n\r\n    /**\r\n     * Creates a function that gets the argument at index `n`. If `n` is negative,\r\n     * the nth argument from the end is returned.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Util\r\n     * @param {number} [n=0] The index of the argument to return.\r\n     * @returns {Function} Returns the new pass-thru function.\r\n     * @example\r\n     *\r\n     * var func = _.nthArg(1);\r\n     * func('a', 'b', 'c', 'd');\r\n     * // => 'b'\r\n     *\r\n     * var func = _.nthArg(-2);\r\n     * func('a', 'b', 'c', 'd');\r\n     * // => 'c'\r\n     */\r\n    function nthArg(n) {\r\n      n = toInteger(n);\r\n      return baseRest(function(args) {\r\n        return baseNth(args, n);\r\n      });\r\n    }\r\n\r\n    /**\r\n     * Creates a function that invokes `iteratees` with the arguments it receives\r\n     * and returns their results.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Util\r\n     * @param {...(Function|Function[])} [iteratees=[_.identity]]\r\n     *  The iteratees to invoke.\r\n     * @returns {Function} Returns the new function.\r\n     * @example\r\n     *\r\n     * var func = _.over([Math.max, Math.min]);\r\n     *\r\n     * func(1, 2, 3, 4);\r\n     * // => [4, 1]\r\n     */\r\n    var over = createOver(arrayMap);\r\n\r\n    /**\r\n     * Creates a function that checks if **all** of the `predicates` return\r\n     * truthy when invoked with the arguments it receives.\r\n     *\r\n     * Following shorthands are possible for providing predicates.\r\n     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.\r\n     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Util\r\n     * @param {...(Function|Function[])} [predicates=[_.identity]]\r\n     *  The predicates to check.\r\n     * @returns {Function} Returns the new function.\r\n     * @example\r\n     *\r\n     * var func = _.overEvery([Boolean, isFinite]);\r\n     *\r\n     * func('1');\r\n     * // => true\r\n     *\r\n     * func(null);\r\n     * // => false\r\n     *\r\n     * func(NaN);\r\n     * // => false\r\n     */\r\n    var overEvery = createOver(arrayEvery);\r\n\r\n    /**\r\n     * Creates a function that checks if **any** of the `predicates` return\r\n     * truthy when invoked with the arguments it receives.\r\n     *\r\n     * Following shorthands are possible for providing predicates.\r\n     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.\r\n     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Util\r\n     * @param {...(Function|Function[])} [predicates=[_.identity]]\r\n     *  The predicates to check.\r\n     * @returns {Function} Returns the new function.\r\n     * @example\r\n     *\r\n     * var func = _.overSome([Boolean, isFinite]);\r\n     *\r\n     * func('1');\r\n     * // => true\r\n     *\r\n     * func(null);\r\n     * // => true\r\n     *\r\n     * func(NaN);\r\n     * // => false\r\n     *\r\n     * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])\r\n     * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])\r\n     */\r\n    var overSome = createOver(arraySome);\r\n\r\n    /**\r\n     * Creates a function that returns the value at `path` of a given object.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 2.4.0\r\n     * @category Util\r\n     * @param {Array|string} path The path of the property to get.\r\n     * @returns {Function} Returns the new accessor function.\r\n     * @example\r\n     *\r\n     * var objects = [\r\n     *   { 'a': { 'b': 2 } },\r\n     *   { 'a': { 'b': 1 } }\r\n     * ];\r\n     *\r\n     * _.map(objects, _.property('a.b'));\r\n     * // => [2, 1]\r\n     *\r\n     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\r\n     * // => [1, 2]\r\n     */\r\n    function property(path) {\r\n      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\r\n    }\r\n\r\n    /**\r\n     * The opposite of `_.property`; this method creates a function that returns\r\n     * the value at a given path of `object`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.0.0\r\n     * @category Util\r\n     * @param {Object} object The object to query.\r\n     * @returns {Function} Returns the new accessor function.\r\n     * @example\r\n     *\r\n     * var array = [0, 1, 2],\r\n     *     object = { 'a': array, 'b': array, 'c': array };\r\n     *\r\n     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));\r\n     * // => [2, 0]\r\n     *\r\n     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));\r\n     * // => [2, 0]\r\n     */\r\n    function propertyOf(object) {\r\n      return function(path) {\r\n        return object == null ? undefined : baseGet(object, path);\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Creates an array of numbers (positive and/or negative) progressing from\r\n     * `start` up to, but not including, `end`. A step of `-1` is used if a negative\r\n     * `start` is specified without an `end` or `step`. If `end` is not specified,\r\n     * it's set to `start` with `start` then set to `0`.\r\n     *\r\n     * **Note:** JavaScript follows the IEEE-754 standard for resolving\r\n     * floating-point values which can produce unexpected results.\r\n     *\r\n     * @static\r\n     * @since 0.1.0\r\n     * @memberOf _\r\n     * @category Util\r\n     * @param {number} [start=0] The start of the range.\r\n     * @param {number} end The end of the range.\r\n     * @param {number} [step=1] The value to increment or decrement by.\r\n     * @returns {Array} Returns the range of numbers.\r\n     * @see _.inRange, _.rangeRight\r\n     * @example\r\n     *\r\n     * _.range(4);\r\n     * // => [0, 1, 2, 3]\r\n     *\r\n     * _.range(-4);\r\n     * // => [0, -1, -2, -3]\r\n     *\r\n     * _.range(1, 5);\r\n     * // => [1, 2, 3, 4]\r\n     *\r\n     * _.range(0, 20, 5);\r\n     * // => [0, 5, 10, 15]\r\n     *\r\n     * _.range(0, -4, -1);\r\n     * // => [0, -1, -2, -3]\r\n     *\r\n     * _.range(1, 4, 0);\r\n     * // => [1, 1, 1]\r\n     *\r\n     * _.range(0);\r\n     * // => []\r\n     */\r\n    var range = createRange();\r\n\r\n    /**\r\n     * This method is like `_.range` except that it populates values in\r\n     * descending order.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Util\r\n     * @param {number} [start=0] The start of the range.\r\n     * @param {number} end The end of the range.\r\n     * @param {number} [step=1] The value to increment or decrement by.\r\n     * @returns {Array} Returns the range of numbers.\r\n     * @see _.inRange, _.range\r\n     * @example\r\n     *\r\n     * _.rangeRight(4);\r\n     * // => [3, 2, 1, 0]\r\n     *\r\n     * _.rangeRight(-4);\r\n     * // => [-3, -2, -1, 0]\r\n     *\r\n     * _.rangeRight(1, 5);\r\n     * // => [4, 3, 2, 1]\r\n     *\r\n     * _.rangeRight(0, 20, 5);\r\n     * // => [15, 10, 5, 0]\r\n     *\r\n     * _.rangeRight(0, -4, -1);\r\n     * // => [-3, -2, -1, 0]\r\n     *\r\n     * _.rangeRight(1, 4, 0);\r\n     * // => [1, 1, 1]\r\n     *\r\n     * _.rangeRight(0);\r\n     * // => []\r\n     */\r\n    var rangeRight = createRange(true);\r\n\r\n    /**\r\n     * This method returns a new empty array.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.13.0\r\n     * @category Util\r\n     * @returns {Array} Returns the new empty array.\r\n     * @example\r\n     *\r\n     * var arrays = _.times(2, _.stubArray);\r\n     *\r\n     * console.log(arrays);\r\n     * // => [[], []]\r\n     *\r\n     * console.log(arrays[0] === arrays[1]);\r\n     * // => false\r\n     */\r\n    function stubArray() {\r\n      return [];\r\n    }\r\n\r\n    /**\r\n     * This method returns `false`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.13.0\r\n     * @category Util\r\n     * @returns {boolean} Returns `false`.\r\n     * @example\r\n     *\r\n     * _.times(2, _.stubFalse);\r\n     * // => [false, false]\r\n     */\r\n    function stubFalse() {\r\n      return false;\r\n    }\r\n\r\n    /**\r\n     * This method returns a new empty object.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.13.0\r\n     * @category Util\r\n     * @returns {Object} Returns the new empty object.\r\n     * @example\r\n     *\r\n     * var objects = _.times(2, _.stubObject);\r\n     *\r\n     * console.log(objects);\r\n     * // => [{}, {}]\r\n     *\r\n     * console.log(objects[0] === objects[1]);\r\n     * // => false\r\n     */\r\n    function stubObject() {\r\n      return {};\r\n    }\r\n\r\n    /**\r\n     * This method returns an empty string.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.13.0\r\n     * @category Util\r\n     * @returns {string} Returns the empty string.\r\n     * @example\r\n     *\r\n     * _.times(2, _.stubString);\r\n     * // => ['', '']\r\n     */\r\n    function stubString() {\r\n      return '';\r\n    }\r\n\r\n    /**\r\n     * This method returns `true`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.13.0\r\n     * @category Util\r\n     * @returns {boolean} Returns `true`.\r\n     * @example\r\n     *\r\n     * _.times(2, _.stubTrue);\r\n     * // => [true, true]\r\n     */\r\n    function stubTrue() {\r\n      return true;\r\n    }\r\n\r\n    /**\r\n     * Invokes the iteratee `n` times, returning an array of the results of\r\n     * each invocation. The iteratee is invoked with one argument; (index).\r\n     *\r\n     * @static\r\n     * @since 0.1.0\r\n     * @memberOf _\r\n     * @category Util\r\n     * @param {number} n The number of times to invoke `iteratee`.\r\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\r\n     * @returns {Array} Returns the array of results.\r\n     * @example\r\n     *\r\n     * _.times(3, String);\r\n     * // => ['0', '1', '2']\r\n     *\r\n     *  _.times(4, _.constant(0));\r\n     * // => [0, 0, 0, 0]\r\n     */\r\n    function times(n, iteratee) {\r\n      n = toInteger(n);\r\n      if (n < 1 || n > MAX_SAFE_INTEGER) {\r\n        return [];\r\n      }\r\n      var index = MAX_ARRAY_LENGTH,\r\n          length = nativeMin(n, MAX_ARRAY_LENGTH);\r\n\r\n      iteratee = getIteratee(iteratee);\r\n      n -= MAX_ARRAY_LENGTH;\r\n\r\n      var result = baseTimes(length, iteratee);\r\n      while (++index < n) {\r\n        iteratee(index);\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * Converts `value` to a property path array.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Util\r\n     * @param {*} value The value to convert.\r\n     * @returns {Array} Returns the new property path array.\r\n     * @example\r\n     *\r\n     * _.toPath('a.b.c');\r\n     * // => ['a', 'b', 'c']\r\n     *\r\n     * _.toPath('a[0].b.c');\r\n     * // => ['a', '0', 'b', 'c']\r\n     */\r\n    function toPath(value) {\r\n      if (isArray(value)) {\r\n        return arrayMap(value, toKey);\r\n      }\r\n      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));\r\n    }\r\n\r\n    /**\r\n     * Generates a unique ID. If `prefix` is given, the ID is appended to it.\r\n     *\r\n     * @static\r\n     * @since 0.1.0\r\n     * @memberOf _\r\n     * @category Util\r\n     * @param {string} [prefix=''] The value to prefix the ID with.\r\n     * @returns {string} Returns the unique ID.\r\n     * @example\r\n     *\r\n     * _.uniqueId('contact_');\r\n     * // => 'contact_104'\r\n     *\r\n     * _.uniqueId();\r\n     * // => '105'\r\n     */\r\n    function uniqueId(prefix) {\r\n      var id = ++idCounter;\r\n      return toString(prefix) + id;\r\n    }\r\n\r\n    /*------------------------------------------------------------------------*/\r\n\r\n    /**\r\n     * Adds two numbers.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.4.0\r\n     * @category Math\r\n     * @param {number} augend The first number in an addition.\r\n     * @param {number} addend The second number in an addition.\r\n     * @returns {number} Returns the total.\r\n     * @example\r\n     *\r\n     * _.add(6, 4);\r\n     * // => 10\r\n     */\r\n    var add = createMathOperation(function(augend, addend) {\r\n      return augend + addend;\r\n    }, 0);\r\n\r\n    /**\r\n     * Computes `number` rounded up to `precision`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.10.0\r\n     * @category Math\r\n     * @param {number} number The number to round up.\r\n     * @param {number} [precision=0] The precision to round up to.\r\n     * @returns {number} Returns the rounded up number.\r\n     * @example\r\n     *\r\n     * _.ceil(4.006);\r\n     * // => 5\r\n     *\r\n     * _.ceil(6.004, 2);\r\n     * // => 6.01\r\n     *\r\n     * _.ceil(6040, -2);\r\n     * // => 6100\r\n     */\r\n    var ceil = createRound('ceil');\r\n\r\n    /**\r\n     * Divide two numbers.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.7.0\r\n     * @category Math\r\n     * @param {number} dividend The first number in a division.\r\n     * @param {number} divisor The second number in a division.\r\n     * @returns {number} Returns the quotient.\r\n     * @example\r\n     *\r\n     * _.divide(6, 4);\r\n     * // => 1.5\r\n     */\r\n    var divide = createMathOperation(function(dividend, divisor) {\r\n      return dividend / divisor;\r\n    }, 1);\r\n\r\n    /**\r\n     * Computes `number` rounded down to `precision`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.10.0\r\n     * @category Math\r\n     * @param {number} number The number to round down.\r\n     * @param {number} [precision=0] The precision to round down to.\r\n     * @returns {number} Returns the rounded down number.\r\n     * @example\r\n     *\r\n     * _.floor(4.006);\r\n     * // => 4\r\n     *\r\n     * _.floor(0.046, 2);\r\n     * // => 0.04\r\n     *\r\n     * _.floor(4060, -2);\r\n     * // => 4000\r\n     */\r\n    var floor = createRound('floor');\r\n\r\n    /**\r\n     * Computes the maximum value of `array`. If `array` is empty or falsey,\r\n     * `undefined` is returned.\r\n     *\r\n     * @static\r\n     * @since 0.1.0\r\n     * @memberOf _\r\n     * @category Math\r\n     * @param {Array} array The array to iterate over.\r\n     * @returns {*} Returns the maximum value.\r\n     * @example\r\n     *\r\n     * _.max([4, 2, 8, 6]);\r\n     * // => 8\r\n     *\r\n     * _.max([]);\r\n     * // => undefined\r\n     */\r\n    function max(array) {\r\n      return (array && array.length)\r\n        ? baseExtremum(array, identity, baseGt)\r\n        : undefined;\r\n    }\r\n\r\n    /**\r\n     * This method is like `_.max` except that it accepts `iteratee` which is\r\n     * invoked for each element in `array` to generate the criterion by which\r\n     * the value is ranked. The iteratee is invoked with one argument: (value).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Math\r\n     * @param {Array} array The array to iterate over.\r\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\r\n     * @returns {*} Returns the maximum value.\r\n     * @example\r\n     *\r\n     * var objects = [{ 'n': 1 }, { 'n': 2 }];\r\n     *\r\n     * _.maxBy(objects, function(o) { return o.n; });\r\n     * // => { 'n': 2 }\r\n     *\r\n     * // The `_.property` iteratee shorthand.\r\n     * _.maxBy(objects, 'n');\r\n     * // => { 'n': 2 }\r\n     */\r\n    function maxBy(array, iteratee) {\r\n      return (array && array.length)\r\n        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)\r\n        : undefined;\r\n    }\r\n\r\n    /**\r\n     * Computes the mean of the values in `array`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Math\r\n     * @param {Array} array The array to iterate over.\r\n     * @returns {number} Returns the mean.\r\n     * @example\r\n     *\r\n     * _.mean([4, 2, 8, 6]);\r\n     * // => 5\r\n     */\r\n    function mean(array) {\r\n      return baseMean(array, identity);\r\n    }\r\n\r\n    /**\r\n     * This method is like `_.mean` except that it accepts `iteratee` which is\r\n     * invoked for each element in `array` to generate the value to be averaged.\r\n     * The iteratee is invoked with one argument: (value).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.7.0\r\n     * @category Math\r\n     * @param {Array} array The array to iterate over.\r\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\r\n     * @returns {number} Returns the mean.\r\n     * @example\r\n     *\r\n     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];\r\n     *\r\n     * _.meanBy(objects, function(o) { return o.n; });\r\n     * // => 5\r\n     *\r\n     * // The `_.property` iteratee shorthand.\r\n     * _.meanBy(objects, 'n');\r\n     * // => 5\r\n     */\r\n    function meanBy(array, iteratee) {\r\n      return baseMean(array, getIteratee(iteratee, 2));\r\n    }\r\n\r\n    /**\r\n     * Computes the minimum value of `array`. If `array` is empty or falsey,\r\n     * `undefined` is returned.\r\n     *\r\n     * @static\r\n     * @since 0.1.0\r\n     * @memberOf _\r\n     * @category Math\r\n     * @param {Array} array The array to iterate over.\r\n     * @returns {*} Returns the minimum value.\r\n     * @example\r\n     *\r\n     * _.min([4, 2, 8, 6]);\r\n     * // => 2\r\n     *\r\n     * _.min([]);\r\n     * // => undefined\r\n     */\r\n    function min(array) {\r\n      return (array && array.length)\r\n        ? baseExtremum(array, identity, baseLt)\r\n        : undefined;\r\n    }\r\n\r\n    /**\r\n     * This method is like `_.min` except that it accepts `iteratee` which is\r\n     * invoked for each element in `array` to generate the criterion by which\r\n     * the value is ranked. The iteratee is invoked with one argument: (value).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Math\r\n     * @param {Array} array The array to iterate over.\r\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\r\n     * @returns {*} Returns the minimum value.\r\n     * @example\r\n     *\r\n     * var objects = [{ 'n': 1 }, { 'n': 2 }];\r\n     *\r\n     * _.minBy(objects, function(o) { return o.n; });\r\n     * // => { 'n': 1 }\r\n     *\r\n     * // The `_.property` iteratee shorthand.\r\n     * _.minBy(objects, 'n');\r\n     * // => { 'n': 1 }\r\n     */\r\n    function minBy(array, iteratee) {\r\n      return (array && array.length)\r\n        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)\r\n        : undefined;\r\n    }\r\n\r\n    /**\r\n     * Multiply two numbers.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.7.0\r\n     * @category Math\r\n     * @param {number} multiplier The first number in a multiplication.\r\n     * @param {number} multiplicand The second number in a multiplication.\r\n     * @returns {number} Returns the product.\r\n     * @example\r\n     *\r\n     * _.multiply(6, 4);\r\n     * // => 24\r\n     */\r\n    var multiply = createMathOperation(function(multiplier, multiplicand) {\r\n      return multiplier * multiplicand;\r\n    }, 1);\r\n\r\n    /**\r\n     * Computes `number` rounded to `precision`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.10.0\r\n     * @category Math\r\n     * @param {number} number The number to round.\r\n     * @param {number} [precision=0] The precision to round to.\r\n     * @returns {number} Returns the rounded number.\r\n     * @example\r\n     *\r\n     * _.round(4.006);\r\n     * // => 4\r\n     *\r\n     * _.round(4.006, 2);\r\n     * // => 4.01\r\n     *\r\n     * _.round(4060, -2);\r\n     * // => 4100\r\n     */\r\n    var round = createRound('round');\r\n\r\n    /**\r\n     * Subtract two numbers.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Math\r\n     * @param {number} minuend The first number in a subtraction.\r\n     * @param {number} subtrahend The second number in a subtraction.\r\n     * @returns {number} Returns the difference.\r\n     * @example\r\n     *\r\n     * _.subtract(6, 4);\r\n     * // => 2\r\n     */\r\n    var subtract = createMathOperation(function(minuend, subtrahend) {\r\n      return minuend - subtrahend;\r\n    }, 0);\r\n\r\n    /**\r\n     * Computes the sum of the values in `array`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 3.4.0\r\n     * @category Math\r\n     * @param {Array} array The array to iterate over.\r\n     * @returns {number} Returns the sum.\r\n     * @example\r\n     *\r\n     * _.sum([4, 2, 8, 6]);\r\n     * // => 20\r\n     */\r\n    function sum(array) {\r\n      return (array && array.length)\r\n        ? baseSum(array, identity)\r\n        : 0;\r\n    }\r\n\r\n    /**\r\n     * This method is like `_.sum` except that it accepts `iteratee` which is\r\n     * invoked for each element in `array` to generate the value to be summed.\r\n     * The iteratee is invoked with one argument: (value).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Math\r\n     * @param {Array} array The array to iterate over.\r\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\r\n     * @returns {number} Returns the sum.\r\n     * @example\r\n     *\r\n     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];\r\n     *\r\n     * _.sumBy(objects, function(o) { return o.n; });\r\n     * // => 20\r\n     *\r\n     * // The `_.property` iteratee shorthand.\r\n     * _.sumBy(objects, 'n');\r\n     * // => 20\r\n     */\r\n    function sumBy(array, iteratee) {\r\n      return (array && array.length)\r\n        ? baseSum(array, getIteratee(iteratee, 2))\r\n        : 0;\r\n    }\r\n\r\n    /*------------------------------------------------------------------------*/\r\n\r\n    // Add methods that return wrapped values in chain sequences.\r\n    lodash.after = after;\r\n    lodash.ary = ary;\r\n    lodash.assign = assign;\r\n    lodash.assignIn = assignIn;\r\n    lodash.assignInWith = assignInWith;\r\n    lodash.assignWith = assignWith;\r\n    lodash.at = at;\r\n    lodash.before = before;\r\n    lodash.bind = bind;\r\n    lodash.bindAll = bindAll;\r\n    lodash.bindKey = bindKey;\r\n    lodash.castArray = castArray;\r\n    lodash.chain = chain;\r\n    lodash.chunk = chunk;\r\n    lodash.compact = compact;\r\n    lodash.concat = concat;\r\n    lodash.cond = cond;\r\n    lodash.conforms = conforms;\r\n    lodash.constant = constant;\r\n    lodash.countBy = countBy;\r\n    lodash.create = create;\r\n    lodash.curry = curry;\r\n    lodash.curryRight = curryRight;\r\n    lodash.debounce = debounce;\r\n    lodash.defaults = defaults;\r\n    lodash.defaultsDeep = defaultsDeep;\r\n    lodash.defer = defer;\r\n    lodash.delay = delay;\r\n    lodash.difference = difference;\r\n    lodash.differenceBy = differenceBy;\r\n    lodash.differenceWith = differenceWith;\r\n    lodash.drop = drop;\r\n    lodash.dropRight = dropRight;\r\n    lodash.dropRightWhile = dropRightWhile;\r\n    lodash.dropWhile = dropWhile;\r\n    lodash.fill = fill;\r\n    lodash.filter = filter;\r\n    lodash.flatMap = flatMap;\r\n    lodash.flatMapDeep = flatMapDeep;\r\n    lodash.flatMapDepth = flatMapDepth;\r\n    lodash.flatten = flatten;\r\n    lodash.flattenDeep = flattenDeep;\r\n    lodash.flattenDepth = flattenDepth;\r\n    lodash.flip = flip;\r\n    lodash.flow = flow;\r\n    lodash.flowRight = flowRight;\r\n    lodash.fromPairs = fromPairs;\r\n    lodash.functions = functions;\r\n    lodash.functionsIn = functionsIn;\r\n    lodash.groupBy = groupBy;\r\n    lodash.initial = initial;\r\n    lodash.intersection = intersection;\r\n    lodash.intersectionBy = intersectionBy;\r\n    lodash.intersectionWith = intersectionWith;\r\n    lodash.invert = invert;\r\n    lodash.invertBy = invertBy;\r\n    lodash.invokeMap = invokeMap;\r\n    lodash.iteratee = iteratee;\r\n    lodash.keyBy = keyBy;\r\n    lodash.keys = keys;\r\n    lodash.keysIn = keysIn;\r\n    lodash.map = map;\r\n    lodash.mapKeys = mapKeys;\r\n    lodash.mapValues = mapValues;\r\n    lodash.matches = matches;\r\n    lodash.matchesProperty = matchesProperty;\r\n    lodash.memoize = memoize;\r\n    lodash.merge = merge;\r\n    lodash.mergeWith = mergeWith;\r\n    lodash.method = method;\r\n    lodash.methodOf = methodOf;\r\n    lodash.mixin = mixin;\r\n    lodash.negate = negate;\r\n    lodash.nthArg = nthArg;\r\n    lodash.omit = omit;\r\n    lodash.omitBy = omitBy;\r\n    lodash.once = once;\r\n    lodash.orderBy = orderBy;\r\n    lodash.over = over;\r\n    lodash.overArgs = overArgs;\r\n    lodash.overEvery = overEvery;\r\n    lodash.overSome = overSome;\r\n    lodash.partial = partial;\r\n    lodash.partialRight = partialRight;\r\n    lodash.partition = partition;\r\n    lodash.pick = pick;\r\n    lodash.pickBy = pickBy;\r\n    lodash.property = property;\r\n    lodash.propertyOf = propertyOf;\r\n    lodash.pull = pull;\r\n    lodash.pullAll = pullAll;\r\n    lodash.pullAllBy = pullAllBy;\r\n    lodash.pullAllWith = pullAllWith;\r\n    lodash.pullAt = pullAt;\r\n    lodash.range = range;\r\n    lodash.rangeRight = rangeRight;\r\n    lodash.rearg = rearg;\r\n    lodash.reject = reject;\r\n    lodash.remove = remove;\r\n    lodash.rest = rest;\r\n    lodash.reverse = reverse;\r\n    lodash.sampleSize = sampleSize;\r\n    lodash.set = set;\r\n    lodash.setWith = setWith;\r\n    lodash.shuffle = shuffle;\r\n    lodash.slice = slice;\r\n    lodash.sortBy = sortBy;\r\n    lodash.sortedUniq = sortedUniq;\r\n    lodash.sortedUniqBy = sortedUniqBy;\r\n    lodash.split = split;\r\n    lodash.spread = spread;\r\n    lodash.tail = tail;\r\n    lodash.take = take;\r\n    lodash.takeRight = takeRight;\r\n    lodash.takeRightWhile = takeRightWhile;\r\n    lodash.takeWhile = takeWhile;\r\n    lodash.tap = tap;\r\n    lodash.throttle = throttle;\r\n    lodash.thru = thru;\r\n    lodash.toArray = toArray;\r\n    lodash.toPairs = toPairs;\r\n    lodash.toPairsIn = toPairsIn;\r\n    lodash.toPath = toPath;\r\n    lodash.toPlainObject = toPlainObject;\r\n    lodash.transform = transform;\r\n    lodash.unary = unary;\r\n    lodash.union = union;\r\n    lodash.unionBy = unionBy;\r\n    lodash.unionWith = unionWith;\r\n    lodash.uniq = uniq;\r\n    lodash.uniqBy = uniqBy;\r\n    lodash.uniqWith = uniqWith;\r\n    lodash.unset = unset;\r\n    lodash.unzip = unzip;\r\n    lodash.unzipWith = unzipWith;\r\n    lodash.update = update;\r\n    lodash.updateWith = updateWith;\r\n    lodash.values = values;\r\n    lodash.valuesIn = valuesIn;\r\n    lodash.without = without;\r\n    lodash.words = words;\r\n    lodash.wrap = wrap;\r\n    lodash.xor = xor;\r\n    lodash.xorBy = xorBy;\r\n    lodash.xorWith = xorWith;\r\n    lodash.zip = zip;\r\n    lodash.zipObject = zipObject;\r\n    lodash.zipObjectDeep = zipObjectDeep;\r\n    lodash.zipWith = zipWith;\r\n\r\n    // Add aliases.\r\n    lodash.entries = toPairs;\r\n    lodash.entriesIn = toPairsIn;\r\n    lodash.extend = assignIn;\r\n    lodash.extendWith = assignInWith;\r\n\r\n    // Add methods to `lodash.prototype`.\r\n    mixin(lodash, lodash);\r\n\r\n    /*------------------------------------------------------------------------*/\r\n\r\n    // Add methods that return unwrapped values in chain sequences.\r\n    lodash.add = add;\r\n    lodash.attempt = attempt;\r\n    lodash.camelCase = camelCase;\r\n    lodash.capitalize = capitalize;\r\n    lodash.ceil = ceil;\r\n    lodash.clamp = clamp;\r\n    lodash.clone = clone;\r\n    lodash.cloneDeep = cloneDeep;\r\n    lodash.cloneDeepWith = cloneDeepWith;\r\n    lodash.cloneWith = cloneWith;\r\n    lodash.conformsTo = conformsTo;\r\n    lodash.deburr = deburr;\r\n    lodash.defaultTo = defaultTo;\r\n    lodash.divide = divide;\r\n    lodash.endsWith = endsWith;\r\n    lodash.eq = eq;\r\n    lodash.escape = escape;\r\n    lodash.escapeRegExp = escapeRegExp;\r\n    lodash.every = every;\r\n    lodash.find = find;\r\n    lodash.findIndex = findIndex;\r\n    lodash.findKey = findKey;\r\n    lodash.findLast = findLast;\r\n    lodash.findLastIndex = findLastIndex;\r\n    lodash.findLastKey = findLastKey;\r\n    lodash.floor = floor;\r\n    lodash.forEach = forEach;\r\n    lodash.forEachRight = forEachRight;\r\n    lodash.forIn = forIn;\r\n    lodash.forInRight = forInRight;\r\n    lodash.forOwn = forOwn;\r\n    lodash.forOwnRight = forOwnRight;\r\n    lodash.get = get;\r\n    lodash.gt = gt;\r\n    lodash.gte = gte;\r\n    lodash.has = has;\r\n    lodash.hasIn = hasIn;\r\n    lodash.head = head;\r\n    lodash.identity = identity;\r\n    lodash.includes = includes;\r\n    lodash.indexOf = indexOf;\r\n    lodash.inRange = inRange;\r\n    lodash.invoke = invoke;\r\n    lodash.isArguments = isArguments;\r\n    lodash.isArray = isArray;\r\n    lodash.isArrayBuffer = isArrayBuffer;\r\n    lodash.isArrayLike = isArrayLike;\r\n    lodash.isArrayLikeObject = isArrayLikeObject;\r\n    lodash.isBoolean = isBoolean;\r\n    lodash.isBuffer = isBuffer;\r\n    lodash.isDate = isDate;\r\n    lodash.isElement = isElement;\r\n    lodash.isEmpty = isEmpty;\r\n    lodash.isEqual = isEqual;\r\n    lodash.isEqualWith = isEqualWith;\r\n    lodash.isError = isError;\r\n    lodash.isFinite = isFinite;\r\n    lodash.isFunction = isFunction;\r\n    lodash.isInteger = isInteger;\r\n    lodash.isLength = isLength;\r\n    lodash.isMap = isMap;\r\n    lodash.isMatch = isMatch;\r\n    lodash.isMatchWith = isMatchWith;\r\n    lodash.isNaN = isNaN;\r\n    lodash.isNative = isNative;\r\n    lodash.isNil = isNil;\r\n    lodash.isNull = isNull;\r\n    lodash.isNumber = isNumber;\r\n    lodash.isObject = isObject;\r\n    lodash.isObjectLike = isObjectLike;\r\n    lodash.isPlainObject = isPlainObject;\r\n    lodash.isRegExp = isRegExp;\r\n    lodash.isSafeInteger = isSafeInteger;\r\n    lodash.isSet = isSet;\r\n    lodash.isString = isString;\r\n    lodash.isSymbol = isSymbol;\r\n    lodash.isTypedArray = isTypedArray;\r\n    lodash.isUndefined = isUndefined;\r\n    lodash.isWeakMap = isWeakMap;\r\n    lodash.isWeakSet = isWeakSet;\r\n    lodash.join = join;\r\n    lodash.kebabCase = kebabCase;\r\n    lodash.last = last;\r\n    lodash.lastIndexOf = lastIndexOf;\r\n    lodash.lowerCase = lowerCase;\r\n    lodash.lowerFirst = lowerFirst;\r\n    lodash.lt = lt;\r\n    lodash.lte = lte;\r\n    lodash.max = max;\r\n    lodash.maxBy = maxBy;\r\n    lodash.mean = mean;\r\n    lodash.meanBy = meanBy;\r\n    lodash.min = min;\r\n    lodash.minBy = minBy;\r\n    lodash.stubArray = stubArray;\r\n    lodash.stubFalse = stubFalse;\r\n    lodash.stubObject = stubObject;\r\n    lodash.stubString = stubString;\r\n    lodash.stubTrue = stubTrue;\r\n    lodash.multiply = multiply;\r\n    lodash.nth = nth;\r\n    lodash.noConflict = noConflict;\r\n    lodash.noop = noop;\r\n    lodash.now = now;\r\n    lodash.pad = pad;\r\n    lodash.padEnd = padEnd;\r\n    lodash.padStart = padStart;\r\n    lodash.parseInt = parseInt;\r\n    lodash.random = random;\r\n    lodash.reduce = reduce;\r\n    lodash.reduceRight = reduceRight;\r\n    lodash.repeat = repeat;\r\n    lodash.replace = replace;\r\n    lodash.result = result;\r\n    lodash.round = round;\r\n    lodash.runInContext = runInContext;\r\n    lodash.sample = sample;\r\n    lodash.size = size;\r\n    lodash.snakeCase = snakeCase;\r\n    lodash.some = some;\r\n    lodash.sortedIndex = sortedIndex;\r\n    lodash.sortedIndexBy = sortedIndexBy;\r\n    lodash.sortedIndexOf = sortedIndexOf;\r\n    lodash.sortedLastIndex = sortedLastIndex;\r\n    lodash.sortedLastIndexBy = sortedLastIndexBy;\r\n    lodash.sortedLastIndexOf = sortedLastIndexOf;\r\n    lodash.startCase = startCase;\r\n    lodash.startsWith = startsWith;\r\n    lodash.subtract = subtract;\r\n    lodash.sum = sum;\r\n    lodash.sumBy = sumBy;\r\n    lodash.template = template;\r\n    lodash.times = times;\r\n    lodash.toFinite = toFinite;\r\n    lodash.toInteger = toInteger;\r\n    lodash.toLength = toLength;\r\n    lodash.toLower = toLower;\r\n    lodash.toNumber = toNumber;\r\n    lodash.toSafeInteger = toSafeInteger;\r\n    lodash.toString = toString;\r\n    lodash.toUpper = toUpper;\r\n    lodash.trim = trim;\r\n    lodash.trimEnd = trimEnd;\r\n    lodash.trimStart = trimStart;\r\n    lodash.truncate = truncate;\r\n    lodash.unescape = unescape;\r\n    lodash.uniqueId = uniqueId;\r\n    lodash.upperCase = upperCase;\r\n    lodash.upperFirst = upperFirst;\r\n\r\n    // Add aliases.\r\n    lodash.each = forEach;\r\n    lodash.eachRight = forEachRight;\r\n    lodash.first = head;\r\n\r\n    mixin(lodash, (function() {\r\n      var source = {};\r\n      baseForOwn(lodash, function(func, methodName) {\r\n        if (!hasOwnProperty.call(lodash.prototype, methodName)) {\r\n          source[methodName] = func;\r\n        }\r\n      });\r\n      return source;\r\n    }()), { 'chain': false });\r\n\r\n    /*------------------------------------------------------------------------*/\r\n\r\n    /**\r\n     * The semantic version number.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @type {string}\r\n     */\r\n    lodash.VERSION = VERSION;\r\n\r\n    // Assign default placeholders.\r\n    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {\r\n      lodash[methodName].placeholder = lodash;\r\n    });\r\n\r\n    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.\r\n    arrayEach(['drop', 'take'], function(methodName, index) {\r\n      LazyWrapper.prototype[methodName] = function(n) {\r\n        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);\r\n\r\n        var result = (this.__filtered__ && !index)\r\n          ? new LazyWrapper(this)\r\n          : this.clone();\r\n\r\n        if (result.__filtered__) {\r\n          result.__takeCount__ = nativeMin(n, result.__takeCount__);\r\n        } else {\r\n          result.__views__.push({\r\n            'size': nativeMin(n, MAX_ARRAY_LENGTH),\r\n            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')\r\n          });\r\n        }\r\n        return result;\r\n      };\r\n\r\n      LazyWrapper.prototype[methodName + 'Right'] = function(n) {\r\n        return this.reverse()[methodName](n).reverse();\r\n      };\r\n    });\r\n\r\n    // Add `LazyWrapper` methods that accept an `iteratee` value.\r\n    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {\r\n      var type = index + 1,\r\n          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;\r\n\r\n      LazyWrapper.prototype[methodName] = function(iteratee) {\r\n        var result = this.clone();\r\n        result.__iteratees__.push({\r\n          'iteratee': getIteratee(iteratee, 3),\r\n          'type': type\r\n        });\r\n        result.__filtered__ = result.__filtered__ || isFilter;\r\n        return result;\r\n      };\r\n    });\r\n\r\n    // Add `LazyWrapper` methods for `_.head` and `_.last`.\r\n    arrayEach(['head', 'last'], function(methodName, index) {\r\n      var takeName = 'take' + (index ? 'Right' : '');\r\n\r\n      LazyWrapper.prototype[methodName] = function() {\r\n        return this[takeName](1).value()[0];\r\n      };\r\n    });\r\n\r\n    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.\r\n    arrayEach(['initial', 'tail'], function(methodName, index) {\r\n      var dropName = 'drop' + (index ? '' : 'Right');\r\n\r\n      LazyWrapper.prototype[methodName] = function() {\r\n        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);\r\n      };\r\n    });\r\n\r\n    LazyWrapper.prototype.compact = function() {\r\n      return this.filter(identity);\r\n    };\r\n\r\n    LazyWrapper.prototype.find = function(predicate) {\r\n      return this.filter(predicate).head();\r\n    };\r\n\r\n    LazyWrapper.prototype.findLast = function(predicate) {\r\n      return this.reverse().find(predicate);\r\n    };\r\n\r\n    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {\r\n      if (typeof path == 'function') {\r\n        return new LazyWrapper(this);\r\n      }\r\n      return this.map(function(value) {\r\n        return baseInvoke(value, path, args);\r\n      });\r\n    });\r\n\r\n    LazyWrapper.prototype.reject = function(predicate) {\r\n      return this.filter(negate(getIteratee(predicate)));\r\n    };\r\n\r\n    LazyWrapper.prototype.slice = function(start, end) {\r\n      start = toInteger(start);\r\n\r\n      var result = this;\r\n      if (result.__filtered__ && (start > 0 || end < 0)) {\r\n        return new LazyWrapper(result);\r\n      }\r\n      if (start < 0) {\r\n        result = result.takeRight(-start);\r\n      } else if (start) {\r\n        result = result.drop(start);\r\n      }\r\n      if (end !== undefined) {\r\n        end = toInteger(end);\r\n        result = end < 0 ? result.dropRight(-end) : result.take(end - start);\r\n      }\r\n      return result;\r\n    };\r\n\r\n    LazyWrapper.prototype.takeRightWhile = function(predicate) {\r\n      return this.reverse().takeWhile(predicate).reverse();\r\n    };\r\n\r\n    LazyWrapper.prototype.toArray = function() {\r\n      return this.take(MAX_ARRAY_LENGTH);\r\n    };\r\n\r\n    // Add `LazyWrapper` methods to `lodash.prototype`.\r\n    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\r\n      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),\r\n          isTaker = /^(?:head|last)$/.test(methodName),\r\n          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],\r\n          retUnwrapped = isTaker || /^find/.test(methodName);\r\n\r\n      if (!lodashFunc) {\r\n        return;\r\n      }\r\n      lodash.prototype[methodName] = function() {\r\n        var value = this.__wrapped__,\r\n            args = isTaker ? [1] : arguments,\r\n            isLazy = value instanceof LazyWrapper,\r\n            iteratee = args[0],\r\n            useLazy = isLazy || isArray(value);\r\n\r\n        var interceptor = function(value) {\r\n          var result = lodashFunc.apply(lodash, arrayPush([value], args));\r\n          return (isTaker && chainAll) ? result[0] : result;\r\n        };\r\n\r\n        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {\r\n          // Avoid lazy use if the iteratee has a \"length\" value other than `1`.\r\n          isLazy = useLazy = false;\r\n        }\r\n        var chainAll = this.__chain__,\r\n            isHybrid = !!this.__actions__.length,\r\n            isUnwrapped = retUnwrapped && !chainAll,\r\n            onlyLazy = isLazy && !isHybrid;\r\n\r\n        if (!retUnwrapped && useLazy) {\r\n          value = onlyLazy ? value : new LazyWrapper(this);\r\n          var result = func.apply(value, args);\r\n          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });\r\n          return new LodashWrapper(result, chainAll);\r\n        }\r\n        if (isUnwrapped && onlyLazy) {\r\n          return func.apply(this, args);\r\n        }\r\n        result = this.thru(interceptor);\r\n        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;\r\n      };\r\n    });\r\n\r\n    // Add `Array` methods to `lodash.prototype`.\r\n    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {\r\n      var func = arrayProto[methodName],\r\n          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',\r\n          retUnwrapped = /^(?:pop|shift)$/.test(methodName);\r\n\r\n      lodash.prototype[methodName] = function() {\r\n        var args = arguments;\r\n        if (retUnwrapped && !this.__chain__) {\r\n          var value = this.value();\r\n          return func.apply(isArray(value) ? value : [], args);\r\n        }\r\n        return this[chainName](function(value) {\r\n          return func.apply(isArray(value) ? value : [], args);\r\n        });\r\n      };\r\n    });\r\n\r\n    // Map minified method names to their real names.\r\n    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\r\n      var lodashFunc = lodash[methodName];\r\n      if (lodashFunc) {\r\n        var key = lodashFunc.name + '';\r\n        if (!hasOwnProperty.call(realNames, key)) {\r\n          realNames[key] = [];\r\n        }\r\n        realNames[key].push({ 'name': methodName, 'func': lodashFunc });\r\n      }\r\n    });\r\n\r\n    realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{\r\n      'name': 'wrapper',\r\n      'func': undefined\r\n    }];\r\n\r\n    // Add methods to `LazyWrapper`.\r\n    LazyWrapper.prototype.clone = lazyClone;\r\n    LazyWrapper.prototype.reverse = lazyReverse;\r\n    LazyWrapper.prototype.value = lazyValue;\r\n\r\n    // Add chain sequence methods to the `lodash` wrapper.\r\n    lodash.prototype.at = wrapperAt;\r\n    lodash.prototype.chain = wrapperChain;\r\n    lodash.prototype.commit = wrapperCommit;\r\n    lodash.prototype.next = wrapperNext;\r\n    lodash.prototype.plant = wrapperPlant;\r\n    lodash.prototype.reverse = wrapperReverse;\r\n    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;\r\n\r\n    // Add lazy aliases.\r\n    lodash.prototype.first = lodash.prototype.head;\r\n\r\n    if (symIterator) {\r\n      lodash.prototype[symIterator] = wrapperToIterator;\r\n    }\r\n    return lodash;\r\n  });\r\n\r\n  /*--------------------------------------------------------------------------*/\r\n\r\n  // Export lodash.\r\n  var _ = runInContext();\r\n\r\n  // Some AMD build optimizers, like r.js, check for condition patterns like:\r\n  if (true) {\r\n    // Expose Lodash on the global object to prevent errors when Lodash is\r\n    // loaded by a script tag in the presence of an AMD loader.\r\n    // See http://requirejs.org/docs/errors.html#mismatch for more details.\r\n    // Use `_.noConflict` to remove Lodash from the global object.\r\n    root._ = _;\r\n\r\n    // Define as an anonymous module so, through path mapping, it can be\r\n    // referenced as the \"underscore\" module.\r\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\r\n      return _;\r\n    }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n  }\r\n  // Check for `exports` after `define` in case a build optimizer adds it.\r\n  else {}\r\n}.call(this));\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9kYXNoL2xvZGFzaC5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixNQUFNLGFBQWEsT0FBTztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEVBQUU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsRUFBRTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixHQUFHO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixHQUFHO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixHQUFHO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsR0FBRztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxl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QixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsR0FBRztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtB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dkIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsR0FBRztBQUNsQixlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7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Q0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUSxJQUFJLFFBQVEsTUFBTSxRQUFRO0FBQzNELGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFVBQVU7QUFDekIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCLElBQUksZ0JBQWdCO0FBQzVEO0FBQ0Esb0NBQW9DLGdCQUFnQjtBQUNwRCxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0IsUUFBUTtBQUN4QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFVBQVU7QUFDekIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQ0FBbUM7QUFDOUMsV0FBVyxvQ0FBb0M7QUFDL0MsV0FBVztBQUNYO0FBQ0E7QUFDQSw2Q0FBNkMsbUJBQW1CO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxvQ0FBb0M7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0NBQW9DO0FBQy9DLFdBQVcsb0NBQW9DO0FBQy9DLFdBQVc7QUFDWDtBQUNBO0FBQ0Esd0NBQXdDLG1CQUFtQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbUNBQW1DO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9DQUFvQztBQUMvQyxXQUFXLG9DQUFvQztBQUMvQyxXQUFXO0FBQ1g7QUFDQTtBQUNBLHdDQUF3Qyw0QkFBNEI7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlDQUFpQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1DQUFtQztBQUM5QyxXQUFXLG9DQUFvQztBQUMvQyxXQUFXO0FBQ1g7QUFDQTtBQUNBLDRDQUE0Qyw2QkFBNkI7QUFDekU7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGtDQUFrQztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsR0FBRztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLEdBQUc7QUFDbEIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsUUFBUSxNQUFNLFFBQVEsSUFBSSxRQUFRO0FBQzdELGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLFVBQVU7QUFDekIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0IsSUFBSSxnQkFBZ0I7QUFDNUQsdUJBQXVCLGdCQUFnQixJQUFJLGdCQUFnQjtBQUMzRDtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCLEdBQUc7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsR0FBRztBQUNsQixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLEdBQUc7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE1BQU07QUFDckIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLEdBQUc7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsVUFBVTtBQUN6QixnQkFBZ0IsUUFBUTtBQUN4QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsOENBQThDO0FBQ3pELFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUNBQW1DO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw2Q0FBNkM7QUFDeEQsV0FBVztBQUNYO0FBQ0E7QUFDQSxxQ0FBcUMsbUJBQW1CO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwyQkFBMkI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxXQUFXO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLEdBQUc7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsV0FBVyw4Q0FBOEM7QUFDekQsV0FBVywrQ0FBK0M7QUFDMUQsV0FBVztBQUNYO0FBQ0E7QUFDQSxtQ0FBbUMsb0JBQW9CO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwQkFBMEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLFVBQVU7QUFDekIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixHQUFHO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLFVBQVU7QUFDekIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsY0FBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsY0FBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLFVBQVU7QUFDekIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscUJBQXFCO0FBQ3BDLGVBQWUsR0FBRztBQUNsQixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSx1QkFBdUI7QUFDdEM7QUFDQSxlQUFlLE1BQU07QUFDckIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMkJBQTJCO0FBQ3RDLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixlQUFlLE9BQU8sMkJBQTJCLFNBQVM7QUFDMUQ7QUFDQTtBQUNBLGVBQWUsVUFBVSwyQkFBMkIsYUFBYTtBQUNqRTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSxzQ0FBc0M7QUFDckQ7QUFDQSxlQUFlLFVBQVU7QUFDekIsZ0JBQWdCLFFBQVE7QUFDeEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0EsV0FBVyw2QkFBNkI7QUFDeEMsV0FBVyw2QkFBNkI7QUFDeEMsV0FBVyw2QkFBNkI7QUFDeEMsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLFVBQVU7QUFDekIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0EsV0FBVywrQ0FBK0M7QUFDMUQsV0FBVyw4Q0FBOEM7QUFDekQsV0FBVztBQUNYO0FBQ0E7QUFDQSx3Q0FBd0Msa0JBQWtCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwyQkFBMkI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxlQUFlLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsVUFBVTtBQUN6QixlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLEdBQUc7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0Esa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0EsUUFBUSxJQUFJO0FBQ1osZUFBZSw4QkFBOEI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsR0FBRztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw4Q0FBOEM7QUFDekQsV0FBVztBQUNYO0FBQ0E7QUFDQSxxQ0FBcUMsbUJBQW1CO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwyQkFBMkI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsaUJBQWlCLEdBQUc7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0IsUUFBUTtBQUN4QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQkFBcUI7QUFDcEMsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSxVQUFVO0FBQ3pCLGdCQUFnQixRQUFRO0FBQ3hCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQ0FBa0M7QUFDN0MsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQ0FBbUM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSwwQkFBMEI7QUFDekM7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxXQUFXLDZCQUE2QjtBQUN4QyxXQUFXLDZCQUE2QjtBQUN4QyxXQUFXLDZCQUE2QjtBQUN4QyxXQUFXO0FBQ1g7QUFDQTtBQUNBLHNDQUFzQyxnQkFBZ0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxxQkFBcUIsZ0NBQWdDO0FBQ3JELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsR0FBRztBQUNsQixlQUFlLE1BQU07QUFDckIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRLFdBQVc7QUFDbEMsZUFBZSxTQUFTO0FBQ3hCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0EsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxtREFBbUQsaUJBQWlCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsTUFBTTtBQUNyQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsTUFBTTtBQUNyQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSwwQkFBMEI7QUFDekM7QUFDQSxpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLE1BQU07QUFDckIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLE1BQU07QUFDckIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxzQkFBc0I7QUFDckMsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsR0FBRztBQUNsQixlQUFlLFVBQVU7QUFDekIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLDJCQUEyQixRQUFRO0FBQ25DO0FBQ0E7QUFDQSwyQkFBMkIsUUFBUTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0JBQWdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCLGVBQWU7QUFDZjtBQUNBLGtCQUFrQixRQUFRO0FBQzFCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsV0FBVztBQUMxQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFD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O0FBQ3pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGNBQWM7QUFDN0IsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixHQUFHO0FBQ3BCO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUSxPQUFPLFVBQVU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxjQUFjO0FBQzdCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3Qiw4QkFBOEIsZ0JBQWdCLFFBQVEsR0FBRztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxjQUFjO0FBQzdCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQSwrQkFBK0IsZ0JBQWdCLFFBQVEsR0FBRztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGNBQWM7QUFDN0IsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQixHQUFHO0FBQ3BCO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUSxPQUFPLHFCQUFxQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBLFFBQVE7QUFDUixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDhCQUE4QjtBQUNwRCxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLHdDQUF3QyxlQUFlO0FBQ3ZELGVBQWUsMkJBQTJCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMkJBQTJCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFdBQVc7QUFDMUIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVEsSUFBSSxRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRLElBQUksUUFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVEsZ0JBQWdCLElBQUksZ0JBQWdCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsV0FBVztBQUMxQixlQUFlLFVBQVU7QUFDekIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsc0JBQXNCO0FBQ3JDLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxzQkFBc0I7QUFDckMsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsY0FBYztBQUM3QixlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLEdBQUc7QUFDcEI7QUFDQTtBQUNBLHNCQUFzQixRQUFRLE9BQU8sZ0NBQWdDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxjQUFjO0FBQzdCLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0Esc0JBQXNCLFFBQVEsT0FBTyxVQUFVO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsY0FBYztBQUM3QixlQUFlLEdBQUc7QUFDbEIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLEdBQUc7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EscUJBQXFCLHdCQUF3QjtBQUM3QztBQUNBLFFBQVEsSUFBSTtBQUNaLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGNBQWM7QUFDN0IsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBLHNCQUFzQixRQUFRLE9BQU8sVUFBVTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUSxTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVEsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGNBQWM7QUFDN0IsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUSxPQUFPLFVBQVU7QUFDL0M7QUFDQSxrREFBa0QsZUFBZTtBQUNqRTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsdUJBQXVCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsY0FBYztBQUM3QixlQUFlLFVBQVU7QUFDekIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsS0FBSztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLLE9BQU8sZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywyREFBMkQ7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHdDQUF3QztBQUN0RTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBMEU7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksbUNBQU87QUFDWDtBQUNBLEtBQUs7QUFBQSxrR0FBQztBQUNOO0FBQ0E7QUFDQSxPQUFPLEVBU0o7QUFDSCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvbG9kYXNoLmpzPzkwZGMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIExvZGFzaCA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cclxuICogQ29weXJpZ2h0IE9wZW5KUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vb3BlbmpzZi5vcmcvPlxyXG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XHJcbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XHJcbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xyXG4gKi9cclxuOyhmdW5jdGlvbigpIHtcclxuXHJcbiAgLyoqIFVzZWQgYXMgYSBzYWZlIHJlZmVyZW5jZSBmb3IgYHVuZGVmaW5lZGAgaW4gcHJlLUVTNSBlbnZpcm9ubWVudHMuICovXHJcbiAgdmFyIHVuZGVmaW5lZDtcclxuXHJcbiAgLyoqIFVzZWQgYXMgdGhlIHNlbWFudGljIHZlcnNpb24gbnVtYmVyLiAqL1xyXG4gIHZhciBWRVJTSU9OID0gJzQuMTcuMjEnO1xyXG5cclxuICAvKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cclxuICB2YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcclxuXHJcbiAgLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xyXG4gIHZhciBDT1JFX0VSUk9SX1RFWFQgPSAnVW5zdXBwb3J0ZWQgY29yZS1qcyB1c2UuIFRyeSBodHRwczovL25wbXMuaW8vc2VhcmNoP3E9cG9ueWZpbGwuJyxcclxuICAgICAgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nLFxyXG4gICAgICBJTlZBTElEX1RFTVBMX1ZBUl9FUlJPUl9URVhUID0gJ0ludmFsaWQgYHZhcmlhYmxlYCBvcHRpb24gcGFzc2VkIGludG8gYF8udGVtcGxhdGVgJztcclxuXHJcbiAgLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xyXG4gIHZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcclxuXHJcbiAgLyoqIFVzZWQgYXMgdGhlIG1heGltdW0gbWVtb2l6ZSBjYWNoZSBzaXplLiAqL1xyXG4gIHZhciBNQVhfTUVNT0laRV9TSVpFID0gNTAwO1xyXG5cclxuICAvKiogVXNlZCBhcyB0aGUgaW50ZXJuYWwgYXJndW1lbnQgcGxhY2Vob2xkZXIuICovXHJcbiAgdmFyIFBMQUNFSE9MREVSID0gJ19fbG9kYXNoX3BsYWNlaG9sZGVyX18nO1xyXG5cclxuICAvKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xyXG4gIHZhciBDTE9ORV9ERUVQX0ZMQUcgPSAxLFxyXG4gICAgICBDTE9ORV9GTEFUX0ZMQUcgPSAyLFxyXG4gICAgICBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xyXG5cclxuICAvKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cclxuICB2YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxyXG4gICAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcclxuXHJcbiAgLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgZnVuY3Rpb24gbWV0YWRhdGEuICovXHJcbiAgdmFyIFdSQVBfQklORF9GTEFHID0gMSxcclxuICAgICAgV1JBUF9CSU5EX0tFWV9GTEFHID0gMixcclxuICAgICAgV1JBUF9DVVJSWV9CT1VORF9GTEFHID0gNCxcclxuICAgICAgV1JBUF9DVVJSWV9GTEFHID0gOCxcclxuICAgICAgV1JBUF9DVVJSWV9SSUdIVF9GTEFHID0gMTYsXHJcbiAgICAgIFdSQVBfUEFSVElBTF9GTEFHID0gMzIsXHJcbiAgICAgIFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHID0gNjQsXHJcbiAgICAgIFdSQVBfQVJZX0ZMQUcgPSAxMjgsXHJcbiAgICAgIFdSQVBfUkVBUkdfRkxBRyA9IDI1NixcclxuICAgICAgV1JBUF9GTElQX0ZMQUcgPSA1MTI7XHJcblxyXG4gIC8qKiBVc2VkIGFzIGRlZmF1bHQgb3B0aW9ucyBmb3IgYF8udHJ1bmNhdGVgLiAqL1xyXG4gIHZhciBERUZBVUxUX1RSVU5DX0xFTkdUSCA9IDMwLFxyXG4gICAgICBERUZBVUxUX1RSVU5DX09NSVNTSU9OID0gJy4uLic7XHJcblxyXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBob3QgZnVuY3Rpb25zIGJ5IG51bWJlciBvZiBjYWxscyB3aXRoaW4gYSBzcGFuIG9mIG1pbGxpc2Vjb25kcy4gKi9cclxuICB2YXIgSE9UX0NPVU5UID0gODAwLFxyXG4gICAgICBIT1RfU1BBTiA9IDE2O1xyXG5cclxuICAvKiogVXNlZCB0byBpbmRpY2F0ZSB0aGUgdHlwZSBvZiBsYXp5IGl0ZXJhdGVlcy4gKi9cclxuICB2YXIgTEFaWV9GSUxURVJfRkxBRyA9IDEsXHJcbiAgICAgIExBWllfTUFQX0ZMQUcgPSAyLFxyXG4gICAgICBMQVpZX1dISUxFX0ZMQUcgPSAzO1xyXG5cclxuICAvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cclxuICB2YXIgSU5GSU5JVFkgPSAxIC8gMCxcclxuICAgICAgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTEsXHJcbiAgICAgIE1BWF9JTlRFR0VSID0gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDgsXHJcbiAgICAgIE5BTiA9IDAgLyAwO1xyXG5cclxuICAvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB0aGUgbWF4aW11bSBsZW5ndGggYW5kIGluZGV4IG9mIGFuIGFycmF5LiAqL1xyXG4gIHZhciBNQVhfQVJSQVlfTEVOR1RIID0gNDI5NDk2NzI5NSxcclxuICAgICAgTUFYX0FSUkFZX0lOREVYID0gTUFYX0FSUkFZX0xFTkdUSCAtIDEsXHJcbiAgICAgIEhBTEZfTUFYX0FSUkFZX0xFTkdUSCA9IE1BWF9BUlJBWV9MRU5HVEggPj4+IDE7XHJcblxyXG4gIC8qKiBVc2VkIHRvIGFzc29jaWF0ZSB3cmFwIG1ldGhvZHMgd2l0aCB0aGVpciBiaXQgZmxhZ3MuICovXHJcbiAgdmFyIHdyYXBGbGFncyA9IFtcclxuICAgIFsnYXJ5JywgV1JBUF9BUllfRkxBR10sXHJcbiAgICBbJ2JpbmQnLCBXUkFQX0JJTkRfRkxBR10sXHJcbiAgICBbJ2JpbmRLZXknLCBXUkFQX0JJTkRfS0VZX0ZMQUddLFxyXG4gICAgWydjdXJyeScsIFdSQVBfQ1VSUllfRkxBR10sXHJcbiAgICBbJ2N1cnJ5UmlnaHQnLCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUddLFxyXG4gICAgWydmbGlwJywgV1JBUF9GTElQX0ZMQUddLFxyXG4gICAgWydwYXJ0aWFsJywgV1JBUF9QQVJUSUFMX0ZMQUddLFxyXG4gICAgWydwYXJ0aWFsUmlnaHQnLCBXUkFQX1BBUlRJQUxfUklHSFRfRkxBR10sXHJcbiAgICBbJ3JlYXJnJywgV1JBUF9SRUFSR19GTEFHXVxyXG4gIF07XHJcblxyXG4gIC8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cclxuICB2YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxyXG4gICAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXHJcbiAgICAgIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxyXG4gICAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxyXG4gICAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxyXG4gICAgICBkb21FeGNUYWcgPSAnW29iamVjdCBET01FeGNlcHRpb25dJyxcclxuICAgICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxyXG4gICAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcclxuICAgICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcclxuICAgICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXHJcbiAgICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxyXG4gICAgICBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxyXG4gICAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcclxuICAgICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcclxuICAgICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nLFxyXG4gICAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcclxuICAgICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXHJcbiAgICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxyXG4gICAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJyxcclxuICAgICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXScsXHJcbiAgICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXScsXHJcbiAgICAgIHdlYWtTZXRUYWcgPSAnW29iamVjdCBXZWFrU2V0XSc7XHJcblxyXG4gIHZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXHJcbiAgICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcclxuICAgICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxyXG4gICAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXHJcbiAgICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcclxuICAgICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXHJcbiAgICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxyXG4gICAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcclxuICAgICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcclxuICAgICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcclxuICAgICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcclxuXHJcbiAgLyoqIFVzZWQgdG8gbWF0Y2ggZW1wdHkgc3RyaW5nIGxpdGVyYWxzIGluIGNvbXBpbGVkIHRlbXBsYXRlIHNvdXJjZS4gKi9cclxuICB2YXIgcmVFbXB0eVN0cmluZ0xlYWRpbmcgPSAvXFxiX19wIFxcKz0gJyc7L2csXHJcbiAgICAgIHJlRW1wdHlTdHJpbmdNaWRkbGUgPSAvXFxiKF9fcCBcXCs9KSAnJyBcXCsvZyxcclxuICAgICAgcmVFbXB0eVN0cmluZ1RyYWlsaW5nID0gLyhfX2VcXCguKj9cXCl8XFxiX190XFwpKSBcXCtcXG4nJzsvZztcclxuXHJcbiAgLyoqIFVzZWQgdG8gbWF0Y2ggSFRNTCBlbnRpdGllcyBhbmQgSFRNTCBjaGFyYWN0ZXJzLiAqL1xyXG4gIHZhciByZUVzY2FwZWRIdG1sID0gLyYoPzphbXB8bHR8Z3R8cXVvdHwjMzkpOy9nLFxyXG4gICAgICByZVVuZXNjYXBlZEh0bWwgPSAvWyY8PlwiJ10vZyxcclxuICAgICAgcmVIYXNFc2NhcGVkSHRtbCA9IFJlZ0V4cChyZUVzY2FwZWRIdG1sLnNvdXJjZSksXHJcbiAgICAgIHJlSGFzVW5lc2NhcGVkSHRtbCA9IFJlZ0V4cChyZVVuZXNjYXBlZEh0bWwuc291cmNlKTtcclxuXHJcbiAgLyoqIFVzZWQgdG8gbWF0Y2ggdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cclxuICB2YXIgcmVFc2NhcGUgPSAvPCUtKFtcXHNcXFNdKz8pJT4vZyxcclxuICAgICAgcmVFdmFsdWF0ZSA9IC88JShbXFxzXFxTXSs/KSU+L2csXHJcbiAgICAgIHJlSW50ZXJwb2xhdGUgPSAvPCU9KFtcXHNcXFNdKz8pJT4vZztcclxuXHJcbiAgLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xyXG4gIHZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxyXG4gICAgICByZUlzUGxhaW5Qcm9wID0gL15cXHcqJC8sXHJcbiAgICAgIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XHJcblxyXG4gIC8qKlxyXG4gICAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcclxuICAgKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cclxuICAgKi9cclxuICB2YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nLFxyXG4gICAgICByZUhhc1JlZ0V4cENoYXIgPSBSZWdFeHAocmVSZWdFeHBDaGFyLnNvdXJjZSk7XHJcblxyXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgd2hpdGVzcGFjZS4gKi9cclxuICB2YXIgcmVUcmltU3RhcnQgPSAvXlxccysvO1xyXG5cclxuICAvKiogVXNlZCB0byBtYXRjaCBhIHNpbmdsZSB3aGl0ZXNwYWNlIGNoYXJhY3Rlci4gKi9cclxuICB2YXIgcmVXaGl0ZXNwYWNlID0gL1xccy87XHJcblxyXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHdyYXAgZGV0YWlsIGNvbW1lbnRzLiAqL1xyXG4gIHZhciByZVdyYXBDb21tZW50ID0gL1xceyg/OlxcblxcL1xcKiBcXFt3cmFwcGVkIHdpdGggLitcXF0gXFwqXFwvKT9cXG4/LyxcclxuICAgICAgcmVXcmFwRGV0YWlscyA9IC9cXHtcXG5cXC9cXCogXFxbd3JhcHBlZCB3aXRoICguKylcXF0gXFwqLyxcclxuICAgICAgcmVTcGxpdERldGFpbHMgPSAvLD8gJiAvO1xyXG5cclxuICAvKiogVXNlZCB0byBtYXRjaCB3b3JkcyBjb21wb3NlZCBvZiBhbHBoYW51bWVyaWMgY2hhcmFjdGVycy4gKi9cclxuICB2YXIgcmVBc2NpaVdvcmQgPSAvW15cXHgwMC1cXHgyZlxceDNhLVxceDQwXFx4NWItXFx4NjBcXHg3Yi1cXHg3Zl0rL2c7XHJcblxyXG4gIC8qKlxyXG4gICAqIFVzZWQgdG8gdmFsaWRhdGUgdGhlIGB2YWxpZGF0ZWAgb3B0aW9uIGluIGBfLnRlbXBsYXRlYCB2YXJpYWJsZS5cclxuICAgKlxyXG4gICAqIEZvcmJpZHMgY2hhcmFjdGVycyB3aGljaCBjb3VsZCBwb3RlbnRpYWxseSBjaGFuZ2UgdGhlIG1lYW5pbmcgb2YgdGhlIGZ1bmN0aW9uIGFyZ3VtZW50IGRlZmluaXRpb246XHJcbiAgICogLSBcIigpLFwiIChtb2RpZmljYXRpb24gb2YgZnVuY3Rpb24gcGFyYW1ldGVycylcclxuICAgKiAtIFwiPVwiIChkZWZhdWx0IHZhbHVlKVxyXG4gICAqIC0gXCJbXXt9XCIgKGRlc3RydWN0dXJpbmcgb2YgZnVuY3Rpb24gcGFyYW1ldGVycylcclxuICAgKiAtIFwiL1wiIChiZWdpbm5pbmcgb2YgYSBjb21tZW50KVxyXG4gICAqIC0gd2hpdGVzcGFjZVxyXG4gICAqL1xyXG4gIHZhciByZUZvcmJpZGRlbklkZW50aWZpZXJDaGFycyA9IC9bKCk9LHt9XFxbXFxdXFwvXFxzXS87XHJcblxyXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xyXG4gIHZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcclxuXHJcbiAgLyoqXHJcbiAgICogVXNlZCB0byBtYXRjaFxyXG4gICAqIFtFUyB0ZW1wbGF0ZSBkZWxpbWl0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10ZW1wbGF0ZS1saXRlcmFsLWxleGljYWwtY29tcG9uZW50cykuXHJcbiAgICovXHJcbiAgdmFyIHJlRXNUZW1wbGF0ZSA9IC9cXCRcXHsoW15cXFxcfV0qKD86XFxcXC5bXlxcXFx9XSopKilcXH0vZztcclxuXHJcbiAgLyoqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGAgZmxhZ3MgZnJvbSB0aGVpciBjb2VyY2VkIHN0cmluZyB2YWx1ZXMuICovXHJcbiAgdmFyIHJlRmxhZ3MgPSAvXFx3KiQvO1xyXG5cclxuICAvKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xyXG4gIHZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XHJcblxyXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cclxuICB2YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcclxuXHJcbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xyXG4gIHZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xyXG5cclxuICAvKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cclxuICB2YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcclxuXHJcbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xyXG4gIHZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XHJcblxyXG4gIC8qKiBVc2VkIHRvIG1hdGNoIExhdGluIFVuaWNvZGUgbGV0dGVycyAoZXhjbHVkaW5nIG1hdGhlbWF0aWNhbCBvcGVyYXRvcnMpLiAqL1xyXG4gIHZhciByZUxhdGluID0gL1tcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx4ZmZcXHUwMTAwLVxcdTAxN2ZdL2c7XHJcblxyXG4gIC8qKiBVc2VkIHRvIGVuc3VyZSBjYXB0dXJpbmcgb3JkZXIgb2YgdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cclxuICB2YXIgcmVOb01hdGNoID0gLygkXikvO1xyXG5cclxuICAvKiogVXNlZCB0byBtYXRjaCB1bmVzY2FwZWQgY2hhcmFjdGVycyBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuICovXHJcbiAgdmFyIHJlVW5lc2NhcGVkU3RyaW5nID0gL1snXFxuXFxyXFx1MjAyOFxcdTIwMjlcXFxcXS9nO1xyXG5cclxuICAvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXHJcbiAgdmFyIHJzQXN0cmFsUmFuZ2UgPSAnXFxcXHVkODAwLVxcXFx1ZGZmZicsXHJcbiAgICAgIHJzQ29tYm9NYXJrc1JhbmdlID0gJ1xcXFx1MDMwMC1cXFxcdTAzNmYnLFxyXG4gICAgICByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgPSAnXFxcXHVmZTIwLVxcXFx1ZmUyZicsXHJcbiAgICAgIHJzQ29tYm9TeW1ib2xzUmFuZ2UgPSAnXFxcXHUyMGQwLVxcXFx1MjBmZicsXHJcbiAgICAgIHJzQ29tYm9SYW5nZSA9IHJzQ29tYm9NYXJrc1JhbmdlICsgcmVDb21ib0hhbGZNYXJrc1JhbmdlICsgcnNDb21ib1N5bWJvbHNSYW5nZSxcclxuICAgICAgcnNEaW5nYmF0UmFuZ2UgPSAnXFxcXHUyNzAwLVxcXFx1MjdiZicsXHJcbiAgICAgIHJzTG93ZXJSYW5nZSA9ICdhLXpcXFxceGRmLVxcXFx4ZjZcXFxceGY4LVxcXFx4ZmYnLFxyXG4gICAgICByc01hdGhPcFJhbmdlID0gJ1xcXFx4YWNcXFxceGIxXFxcXHhkN1xcXFx4ZjcnLFxyXG4gICAgICByc05vbkNoYXJSYW5nZSA9ICdcXFxceDAwLVxcXFx4MmZcXFxceDNhLVxcXFx4NDBcXFxceDViLVxcXFx4NjBcXFxceDdiLVxcXFx4YmYnLFxyXG4gICAgICByc1B1bmN0dWF0aW9uUmFuZ2UgPSAnXFxcXHUyMDAwLVxcXFx1MjA2ZicsXHJcbiAgICAgIHJzU3BhY2VSYW5nZSA9ICcgXFxcXHRcXFxceDBiXFxcXGZcXFxceGEwXFxcXHVmZWZmXFxcXG5cXFxcclxcXFx1MjAyOFxcXFx1MjAyOVxcXFx1MTY4MFxcXFx1MTgwZVxcXFx1MjAwMFxcXFx1MjAwMVxcXFx1MjAwMlxcXFx1MjAwM1xcXFx1MjAwNFxcXFx1MjAwNVxcXFx1MjAwNlxcXFx1MjAwN1xcXFx1MjAwOFxcXFx1MjAwOVxcXFx1MjAwYVxcXFx1MjAyZlxcXFx1MjA1ZlxcXFx1MzAwMCcsXHJcbiAgICAgIHJzVXBwZXJSYW5nZSA9ICdBLVpcXFxceGMwLVxcXFx4ZDZcXFxceGQ4LVxcXFx4ZGUnLFxyXG4gICAgICByc1ZhclJhbmdlID0gJ1xcXFx1ZmUwZVxcXFx1ZmUwZicsXHJcbiAgICAgIHJzQnJlYWtSYW5nZSA9IHJzTWF0aE9wUmFuZ2UgKyByc05vbkNoYXJSYW5nZSArIHJzUHVuY3R1YXRpb25SYW5nZSArIHJzU3BhY2VSYW5nZTtcclxuXHJcbiAgLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xyXG4gIHZhciByc0Fwb3MgPSBcIlsnXFx1MjAxOV1cIixcclxuICAgICAgcnNBc3RyYWwgPSAnWycgKyByc0FzdHJhbFJhbmdlICsgJ10nLFxyXG4gICAgICByc0JyZWFrID0gJ1snICsgcnNCcmVha1JhbmdlICsgJ10nLFxyXG4gICAgICByc0NvbWJvID0gJ1snICsgcnNDb21ib1JhbmdlICsgJ10nLFxyXG4gICAgICByc0RpZ2l0cyA9ICdcXFxcZCsnLFxyXG4gICAgICByc0RpbmdiYXQgPSAnWycgKyByc0RpbmdiYXRSYW5nZSArICddJyxcclxuICAgICAgcnNMb3dlciA9ICdbJyArIHJzTG93ZXJSYW5nZSArICddJyxcclxuICAgICAgcnNNaXNjID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UgKyByc0JyZWFrUmFuZ2UgKyByc0RpZ2l0cyArIHJzRGluZ2JhdFJhbmdlICsgcnNMb3dlclJhbmdlICsgcnNVcHBlclJhbmdlICsgJ10nLFxyXG4gICAgICByc0ZpdHogPSAnXFxcXHVkODNjW1xcXFx1ZGZmYi1cXFxcdWRmZmZdJyxcclxuICAgICAgcnNNb2RpZmllciA9ICcoPzonICsgcnNDb21ibyArICd8JyArIHJzRml0eiArICcpJyxcclxuICAgICAgcnNOb25Bc3RyYWwgPSAnW14nICsgcnNBc3RyYWxSYW5nZSArICddJyxcclxuICAgICAgcnNSZWdpb25hbCA9ICcoPzpcXFxcdWQ4M2NbXFxcXHVkZGU2LVxcXFx1ZGRmZl0pezJ9JyxcclxuICAgICAgcnNTdXJyUGFpciA9ICdbXFxcXHVkODAwLVxcXFx1ZGJmZl1bXFxcXHVkYzAwLVxcXFx1ZGZmZl0nLFxyXG4gICAgICByc1VwcGVyID0gJ1snICsgcnNVcHBlclJhbmdlICsgJ10nLFxyXG4gICAgICByc1pXSiA9ICdcXFxcdTIwMGQnO1xyXG5cclxuICAvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgcmVnZXhlcy4gKi9cclxuICB2YXIgcnNNaXNjTG93ZXIgPSAnKD86JyArIHJzTG93ZXIgKyAnfCcgKyByc01pc2MgKyAnKScsXHJcbiAgICAgIHJzTWlzY1VwcGVyID0gJyg/OicgKyByc1VwcGVyICsgJ3wnICsgcnNNaXNjICsgJyknLFxyXG4gICAgICByc09wdENvbnRyTG93ZXIgPSAnKD86JyArIHJzQXBvcyArICcoPzpkfGxsfG18cmV8c3x0fHZlKSk/JyxcclxuICAgICAgcnNPcHRDb250clVwcGVyID0gJyg/OicgKyByc0Fwb3MgKyAnKD86RHxMTHxNfFJFfFN8VHxWRSkpPycsXHJcbiAgICAgIHJlT3B0TW9kID0gcnNNb2RpZmllciArICc/JyxcclxuICAgICAgcnNPcHRWYXIgPSAnWycgKyByc1ZhclJhbmdlICsgJ10/JyxcclxuICAgICAgcnNPcHRKb2luID0gJyg/OicgKyByc1pXSiArICcoPzonICsgW3JzTm9uQXN0cmFsLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKCd8JykgKyAnKScgKyByc09wdFZhciArIHJlT3B0TW9kICsgJykqJyxcclxuICAgICAgcnNPcmRMb3dlciA9ICdcXFxcZCooPzoxc3R8Mm5kfDNyZHwoPyFbMTIzXSlcXFxcZHRoKSg/PVxcXFxifFtBLVpfXSknLFxyXG4gICAgICByc09yZFVwcGVyID0gJ1xcXFxkKig/OjFTVHwyTkR8M1JEfCg/IVsxMjNdKVxcXFxkVEgpKD89XFxcXGJ8W2Etel9dKScsXHJcbiAgICAgIHJzU2VxID0gcnNPcHRWYXIgKyByZU9wdE1vZCArIHJzT3B0Sm9pbixcclxuICAgICAgcnNFbW9qaSA9ICcoPzonICsgW3JzRGluZ2JhdCwgcnNSZWdpb25hbCwgcnNTdXJyUGFpcl0uam9pbignfCcpICsgJyknICsgcnNTZXEsXHJcbiAgICAgIHJzU3ltYm9sID0gJyg/OicgKyBbcnNOb25Bc3RyYWwgKyByc0NvbWJvICsgJz8nLCByc0NvbWJvLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyLCByc0FzdHJhbF0uam9pbignfCcpICsgJyknO1xyXG5cclxuICAvKiogVXNlZCB0byBtYXRjaCBhcG9zdHJvcGhlcy4gKi9cclxuICB2YXIgcmVBcG9zID0gUmVnRXhwKHJzQXBvcywgJ2cnKTtcclxuXHJcbiAgLyoqXHJcbiAgICogVXNlZCB0byBtYXRjaCBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3MpIGFuZFxyXG4gICAqIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3MgZm9yIHN5bWJvbHNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrc19mb3JfU3ltYm9scykuXHJcbiAgICovXHJcbiAgdmFyIHJlQ29tYm9NYXJrID0gUmVnRXhwKHJzQ29tYm8sICdnJyk7XHJcblxyXG4gIC8qKiBVc2VkIHRvIG1hdGNoIFtzdHJpbmcgc3ltYm9sc10oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtdW5pY29kZSkuICovXHJcbiAgdmFyIHJlVW5pY29kZSA9IFJlZ0V4cChyc0ZpdHogKyAnKD89JyArIHJzRml0eiArICcpfCcgKyByc1N5bWJvbCArIHJzU2VxLCAnZycpO1xyXG5cclxuICAvKiogVXNlZCB0byBtYXRjaCBjb21wbGV4IG9yIGNvbXBvdW5kIHdvcmRzLiAqL1xyXG4gIHZhciByZVVuaWNvZGVXb3JkID0gUmVnRXhwKFtcclxuICAgIHJzVXBwZXIgKyAnPycgKyByc0xvd2VyICsgJysnICsgcnNPcHRDb250ckxvd2VyICsgJyg/PScgKyBbcnNCcmVhaywgcnNVcHBlciwgJyQnXS5qb2luKCd8JykgKyAnKScsXHJcbiAgICByc01pc2NVcHBlciArICcrJyArIHJzT3B0Q29udHJVcHBlciArICcoPz0nICsgW3JzQnJlYWssIHJzVXBwZXIgKyByc01pc2NMb3dlciwgJyQnXS5qb2luKCd8JykgKyAnKScsXHJcbiAgICByc1VwcGVyICsgJz8nICsgcnNNaXNjTG93ZXIgKyAnKycgKyByc09wdENvbnRyTG93ZXIsXHJcbiAgICByc1VwcGVyICsgJysnICsgcnNPcHRDb250clVwcGVyLFxyXG4gICAgcnNPcmRVcHBlcixcclxuICAgIHJzT3JkTG93ZXIsXHJcbiAgICByc0RpZ2l0cyxcclxuICAgIHJzRW1vamlcclxuICBdLmpvaW4oJ3wnKSwgJ2cnKTtcclxuXHJcbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IHN0cmluZ3Mgd2l0aCBbemVyby13aWR0aCBqb2luZXJzIG9yIGNvZGUgcG9pbnRzIGZyb20gdGhlIGFzdHJhbCBwbGFuZXNdKGh0dHA6Ly9lZXYuZWUvYmxvZy8yMDE1LzA5LzEyL2RhcmstY29ybmVycy1vZi11bmljb2RlLykuICovXHJcbiAgdmFyIHJlSGFzVW5pY29kZSA9IFJlZ0V4cCgnWycgKyByc1pXSiArIHJzQXN0cmFsUmFuZ2UgICsgcnNDb21ib1JhbmdlICsgcnNWYXJSYW5nZSArICddJyk7XHJcblxyXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBzdHJpbmdzIHRoYXQgbmVlZCBhIG1vcmUgcm9idXN0IHJlZ2V4cCB0byBtYXRjaCB3b3Jkcy4gKi9cclxuICB2YXIgcmVIYXNVbmljb2RlV29yZCA9IC9bYS16XVtBLVpdfFtBLVpdezJ9W2Etel18WzAtOV1bYS16QS1aXXxbYS16QS1aXVswLTldfFteYS16QS1aMC05IF0vO1xyXG5cclxuICAvKiogVXNlZCB0byBhc3NpZ24gZGVmYXVsdCBgY29udGV4dGAgb2JqZWN0IHByb3BlcnRpZXMuICovXHJcbiAgdmFyIGNvbnRleHRQcm9wcyA9IFtcclxuICAgICdBcnJheScsICdCdWZmZXInLCAnRGF0YVZpZXcnLCAnRGF0ZScsICdFcnJvcicsICdGbG9hdDMyQXJyYXknLCAnRmxvYXQ2NEFycmF5JyxcclxuICAgICdGdW5jdGlvbicsICdJbnQ4QXJyYXknLCAnSW50MTZBcnJheScsICdJbnQzMkFycmF5JywgJ01hcCcsICdNYXRoJywgJ09iamVjdCcsXHJcbiAgICAnUHJvbWlzZScsICdSZWdFeHAnLCAnU2V0JywgJ1N0cmluZycsICdTeW1ib2wnLCAnVHlwZUVycm9yJywgJ1VpbnQ4QXJyYXknLFxyXG4gICAgJ1VpbnQ4Q2xhbXBlZEFycmF5JywgJ1VpbnQxNkFycmF5JywgJ1VpbnQzMkFycmF5JywgJ1dlYWtNYXAnLFxyXG4gICAgJ18nLCAnY2xlYXJUaW1lb3V0JywgJ2lzRmluaXRlJywgJ3BhcnNlSW50JywgJ3NldFRpbWVvdXQnXHJcbiAgXTtcclxuXHJcbiAgLyoqIFVzZWQgdG8gbWFrZSB0ZW1wbGF0ZSBzb3VyY2VVUkxzIGVhc2llciB0byBpZGVudGlmeS4gKi9cclxuICB2YXIgdGVtcGxhdGVDb3VudGVyID0gLTE7XHJcblxyXG4gIC8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cclxuICB2YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcclxuICB0eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cclxuICB0eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XHJcbiAgdHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cclxuICB0eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XHJcbiAgdHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XHJcbiAgdHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxyXG4gIHR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cclxuICB0eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XHJcbiAgdHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxyXG4gIHR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cclxuICB0eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XHJcbiAgdHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxyXG4gIHR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XHJcblxyXG4gIC8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIHN1cHBvcnRlZCBieSBgXy5jbG9uZWAuICovXHJcbiAgdmFyIGNsb25lYWJsZVRhZ3MgPSB7fTtcclxuICBjbG9uZWFibGVUYWdzW2FyZ3NUYWddID0gY2xvbmVhYmxlVGFnc1thcnJheVRhZ10gPVxyXG4gIGNsb25lYWJsZVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRhVmlld1RhZ10gPVxyXG4gIGNsb25lYWJsZVRhZ3NbYm9vbFRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGVUYWddID1cclxuICBjbG9uZWFibGVUYWdzW2Zsb2F0MzJUYWddID0gY2xvbmVhYmxlVGFnc1tmbG9hdDY0VGFnXSA9XHJcbiAgY2xvbmVhYmxlVGFnc1tpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbaW50MTZUYWddID1cclxuICBjbG9uZWFibGVUYWdzW2ludDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbbWFwVGFnXSA9XHJcbiAgY2xvbmVhYmxlVGFnc1tudW1iZXJUYWddID0gY2xvbmVhYmxlVGFnc1tvYmplY3RUYWddID1cclxuICBjbG9uZWFibGVUYWdzW3JlZ2V4cFRhZ10gPSBjbG9uZWFibGVUYWdzW3NldFRhZ10gPVxyXG4gIGNsb25lYWJsZVRhZ3Nbc3RyaW5nVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc3ltYm9sVGFnXSA9XHJcbiAgY2xvbmVhYmxlVGFnc1t1aW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPVxyXG4gIGNsb25lYWJsZVRhZ3NbdWludDE2VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XHJcbiAgY2xvbmVhYmxlVGFnc1tlcnJvclRhZ10gPSBjbG9uZWFibGVUYWdzW2Z1bmNUYWddID1cclxuICBjbG9uZWFibGVUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XHJcblxyXG4gIC8qKiBVc2VkIHRvIG1hcCBMYXRpbiBVbmljb2RlIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycy4gKi9cclxuICB2YXIgZGVidXJyZWRMZXR0ZXJzID0ge1xyXG4gICAgLy8gTGF0aW4tMSBTdXBwbGVtZW50IGJsb2NrLlxyXG4gICAgJ1xceGMwJzogJ0EnLCAgJ1xceGMxJzogJ0EnLCAnXFx4YzInOiAnQScsICdcXHhjMyc6ICdBJywgJ1xceGM0JzogJ0EnLCAnXFx4YzUnOiAnQScsXHJcbiAgICAnXFx4ZTAnOiAnYScsICAnXFx4ZTEnOiAnYScsICdcXHhlMic6ICdhJywgJ1xceGUzJzogJ2EnLCAnXFx4ZTQnOiAnYScsICdcXHhlNSc6ICdhJyxcclxuICAgICdcXHhjNyc6ICdDJywgICdcXHhlNyc6ICdjJyxcclxuICAgICdcXHhkMCc6ICdEJywgICdcXHhmMCc6ICdkJyxcclxuICAgICdcXHhjOCc6ICdFJywgICdcXHhjOSc6ICdFJywgJ1xceGNhJzogJ0UnLCAnXFx4Y2InOiAnRScsXHJcbiAgICAnXFx4ZTgnOiAnZScsICAnXFx4ZTknOiAnZScsICdcXHhlYSc6ICdlJywgJ1xceGViJzogJ2UnLFxyXG4gICAgJ1xceGNjJzogJ0knLCAgJ1xceGNkJzogJ0knLCAnXFx4Y2UnOiAnSScsICdcXHhjZic6ICdJJyxcclxuICAgICdcXHhlYyc6ICdpJywgICdcXHhlZCc6ICdpJywgJ1xceGVlJzogJ2knLCAnXFx4ZWYnOiAnaScsXHJcbiAgICAnXFx4ZDEnOiAnTicsICAnXFx4ZjEnOiAnbicsXHJcbiAgICAnXFx4ZDInOiAnTycsICAnXFx4ZDMnOiAnTycsICdcXHhkNCc6ICdPJywgJ1xceGQ1JzogJ08nLCAnXFx4ZDYnOiAnTycsICdcXHhkOCc6ICdPJyxcclxuICAgICdcXHhmMic6ICdvJywgICdcXHhmMyc6ICdvJywgJ1xceGY0JzogJ28nLCAnXFx4ZjUnOiAnbycsICdcXHhmNic6ICdvJywgJ1xceGY4JzogJ28nLFxyXG4gICAgJ1xceGQ5JzogJ1UnLCAgJ1xceGRhJzogJ1UnLCAnXFx4ZGInOiAnVScsICdcXHhkYyc6ICdVJyxcclxuICAgICdcXHhmOSc6ICd1JywgICdcXHhmYSc6ICd1JywgJ1xceGZiJzogJ3UnLCAnXFx4ZmMnOiAndScsXHJcbiAgICAnXFx4ZGQnOiAnWScsICAnXFx4ZmQnOiAneScsICdcXHhmZic6ICd5JyxcclxuICAgICdcXHhjNic6ICdBZScsICdcXHhlNic6ICdhZScsXHJcbiAgICAnXFx4ZGUnOiAnVGgnLCAnXFx4ZmUnOiAndGgnLFxyXG4gICAgJ1xceGRmJzogJ3NzJyxcclxuICAgIC8vIExhdGluIEV4dGVuZGVkLUEgYmxvY2suXHJcbiAgICAnXFx1MDEwMCc6ICdBJywgICdcXHUwMTAyJzogJ0EnLCAnXFx1MDEwNCc6ICdBJyxcclxuICAgICdcXHUwMTAxJzogJ2EnLCAgJ1xcdTAxMDMnOiAnYScsICdcXHUwMTA1JzogJ2EnLFxyXG4gICAgJ1xcdTAxMDYnOiAnQycsICAnXFx1MDEwOCc6ICdDJywgJ1xcdTAxMGEnOiAnQycsICdcXHUwMTBjJzogJ0MnLFxyXG4gICAgJ1xcdTAxMDcnOiAnYycsICAnXFx1MDEwOSc6ICdjJywgJ1xcdTAxMGInOiAnYycsICdcXHUwMTBkJzogJ2MnLFxyXG4gICAgJ1xcdTAxMGUnOiAnRCcsICAnXFx1MDExMCc6ICdEJywgJ1xcdTAxMGYnOiAnZCcsICdcXHUwMTExJzogJ2QnLFxyXG4gICAgJ1xcdTAxMTInOiAnRScsICAnXFx1MDExNCc6ICdFJywgJ1xcdTAxMTYnOiAnRScsICdcXHUwMTE4JzogJ0UnLCAnXFx1MDExYSc6ICdFJyxcclxuICAgICdcXHUwMTEzJzogJ2UnLCAgJ1xcdTAxMTUnOiAnZScsICdcXHUwMTE3JzogJ2UnLCAnXFx1MDExOSc6ICdlJywgJ1xcdTAxMWInOiAnZScsXHJcbiAgICAnXFx1MDExYyc6ICdHJywgICdcXHUwMTFlJzogJ0cnLCAnXFx1MDEyMCc6ICdHJywgJ1xcdTAxMjInOiAnRycsXHJcbiAgICAnXFx1MDExZCc6ICdnJywgICdcXHUwMTFmJzogJ2cnLCAnXFx1MDEyMSc6ICdnJywgJ1xcdTAxMjMnOiAnZycsXHJcbiAgICAnXFx1MDEyNCc6ICdIJywgICdcXHUwMTI2JzogJ0gnLCAnXFx1MDEyNSc6ICdoJywgJ1xcdTAxMjcnOiAnaCcsXHJcbiAgICAnXFx1MDEyOCc6ICdJJywgICdcXHUwMTJhJzogJ0knLCAnXFx1MDEyYyc6ICdJJywgJ1xcdTAxMmUnOiAnSScsICdcXHUwMTMwJzogJ0knLFxyXG4gICAgJ1xcdTAxMjknOiAnaScsICAnXFx1MDEyYic6ICdpJywgJ1xcdTAxMmQnOiAnaScsICdcXHUwMTJmJzogJ2knLCAnXFx1MDEzMSc6ICdpJyxcclxuICAgICdcXHUwMTM0JzogJ0onLCAgJ1xcdTAxMzUnOiAnaicsXHJcbiAgICAnXFx1MDEzNic6ICdLJywgICdcXHUwMTM3JzogJ2snLCAnXFx1MDEzOCc6ICdrJyxcclxuICAgICdcXHUwMTM5JzogJ0wnLCAgJ1xcdTAxM2InOiAnTCcsICdcXHUwMTNkJzogJ0wnLCAnXFx1MDEzZic6ICdMJywgJ1xcdTAxNDEnOiAnTCcsXHJcbiAgICAnXFx1MDEzYSc6ICdsJywgICdcXHUwMTNjJzogJ2wnLCAnXFx1MDEzZSc6ICdsJywgJ1xcdTAxNDAnOiAnbCcsICdcXHUwMTQyJzogJ2wnLFxyXG4gICAgJ1xcdTAxNDMnOiAnTicsICAnXFx1MDE0NSc6ICdOJywgJ1xcdTAxNDcnOiAnTicsICdcXHUwMTRhJzogJ04nLFxyXG4gICAgJ1xcdTAxNDQnOiAnbicsICAnXFx1MDE0Nic6ICduJywgJ1xcdTAxNDgnOiAnbicsICdcXHUwMTRiJzogJ24nLFxyXG4gICAgJ1xcdTAxNGMnOiAnTycsICAnXFx1MDE0ZSc6ICdPJywgJ1xcdTAxNTAnOiAnTycsXHJcbiAgICAnXFx1MDE0ZCc6ICdvJywgICdcXHUwMTRmJzogJ28nLCAnXFx1MDE1MSc6ICdvJyxcclxuICAgICdcXHUwMTU0JzogJ1InLCAgJ1xcdTAxNTYnOiAnUicsICdcXHUwMTU4JzogJ1InLFxyXG4gICAgJ1xcdTAxNTUnOiAncicsICAnXFx1MDE1Nyc6ICdyJywgJ1xcdTAxNTknOiAncicsXHJcbiAgICAnXFx1MDE1YSc6ICdTJywgICdcXHUwMTVjJzogJ1MnLCAnXFx1MDE1ZSc6ICdTJywgJ1xcdTAxNjAnOiAnUycsXHJcbiAgICAnXFx1MDE1Yic6ICdzJywgICdcXHUwMTVkJzogJ3MnLCAnXFx1MDE1Zic6ICdzJywgJ1xcdTAxNjEnOiAncycsXHJcbiAgICAnXFx1MDE2Mic6ICdUJywgICdcXHUwMTY0JzogJ1QnLCAnXFx1MDE2Nic6ICdUJyxcclxuICAgICdcXHUwMTYzJzogJ3QnLCAgJ1xcdTAxNjUnOiAndCcsICdcXHUwMTY3JzogJ3QnLFxyXG4gICAgJ1xcdTAxNjgnOiAnVScsICAnXFx1MDE2YSc6ICdVJywgJ1xcdTAxNmMnOiAnVScsICdcXHUwMTZlJzogJ1UnLCAnXFx1MDE3MCc6ICdVJywgJ1xcdTAxNzInOiAnVScsXHJcbiAgICAnXFx1MDE2OSc6ICd1JywgICdcXHUwMTZiJzogJ3UnLCAnXFx1MDE2ZCc6ICd1JywgJ1xcdTAxNmYnOiAndScsICdcXHUwMTcxJzogJ3UnLCAnXFx1MDE3Myc6ICd1JyxcclxuICAgICdcXHUwMTc0JzogJ1cnLCAgJ1xcdTAxNzUnOiAndycsXHJcbiAgICAnXFx1MDE3Nic6ICdZJywgICdcXHUwMTc3JzogJ3knLCAnXFx1MDE3OCc6ICdZJyxcclxuICAgICdcXHUwMTc5JzogJ1onLCAgJ1xcdTAxN2InOiAnWicsICdcXHUwMTdkJzogJ1onLFxyXG4gICAgJ1xcdTAxN2EnOiAneicsICAnXFx1MDE3Yyc6ICd6JywgJ1xcdTAxN2UnOiAneicsXHJcbiAgICAnXFx1MDEzMic6ICdJSicsICdcXHUwMTMzJzogJ2lqJyxcclxuICAgICdcXHUwMTUyJzogJ09lJywgJ1xcdTAxNTMnOiAnb2UnLFxyXG4gICAgJ1xcdTAxNDknOiBcIiduXCIsICdcXHUwMTdmJzogJ3MnXHJcbiAgfTtcclxuXHJcbiAgLyoqIFVzZWQgdG8gbWFwIGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy4gKi9cclxuICB2YXIgaHRtbEVzY2FwZXMgPSB7XHJcbiAgICAnJic6ICcmYW1wOycsXHJcbiAgICAnPCc6ICcmbHQ7JyxcclxuICAgICc+JzogJyZndDsnLFxyXG4gICAgJ1wiJzogJyZxdW90OycsXHJcbiAgICBcIidcIjogJyYjMzk7J1xyXG4gIH07XHJcblxyXG4gIC8qKiBVc2VkIHRvIG1hcCBIVE1MIGVudGl0aWVzIHRvIGNoYXJhY3RlcnMuICovXHJcbiAgdmFyIGh0bWxVbmVzY2FwZXMgPSB7XHJcbiAgICAnJmFtcDsnOiAnJicsXHJcbiAgICAnJmx0Oyc6ICc8JyxcclxuICAgICcmZ3Q7JzogJz4nLFxyXG4gICAgJyZxdW90Oyc6ICdcIicsXHJcbiAgICAnJiMzOTsnOiBcIidcIlxyXG4gIH07XHJcblxyXG4gIC8qKiBVc2VkIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLiAqL1xyXG4gIHZhciBzdHJpbmdFc2NhcGVzID0ge1xyXG4gICAgJ1xcXFwnOiAnXFxcXCcsXHJcbiAgICBcIidcIjogXCInXCIsXHJcbiAgICAnXFxuJzogJ24nLFxyXG4gICAgJ1xccic6ICdyJyxcclxuICAgICdcXHUyMDI4JzogJ3UyMDI4JyxcclxuICAgICdcXHUyMDI5JzogJ3UyMDI5J1xyXG4gIH07XHJcblxyXG4gIC8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXHJcbiAgdmFyIGZyZWVQYXJzZUZsb2F0ID0gcGFyc2VGbG9hdCxcclxuICAgICAgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XHJcblxyXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXHJcbiAgdmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xyXG5cclxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xyXG4gIHZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xyXG5cclxuICAvKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cclxuICB2YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcclxuXHJcbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cclxuICB2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XHJcblxyXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cclxuICB2YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xyXG5cclxuICAvKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xyXG4gIHZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xyXG5cclxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cclxuICB2YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcclxuXHJcbiAgLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXHJcbiAgdmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gVXNlIGB1dGlsLnR5cGVzYCBmb3IgTm9kZS5qcyAxMCsuXHJcbiAgICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlICYmIGZyZWVNb2R1bGUucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xyXG5cclxuICAgICAgaWYgKHR5cGVzKSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVzO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBMZWdhY3kgYHByb2Nlc3MuYmluZGluZygndXRpbCcpYCBmb3IgTm9kZS5qcyA8IDEwLlxyXG4gICAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XHJcbiAgICB9IGNhdGNoIChlKSB7fVxyXG4gIH0oKSk7XHJcblxyXG4gIC8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXHJcbiAgdmFyIG5vZGVJc0FycmF5QnVmZmVyID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNBcnJheUJ1ZmZlcixcclxuICAgICAgbm9kZUlzRGF0ZSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzRGF0ZSxcclxuICAgICAgbm9kZUlzTWFwID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNNYXAsXHJcbiAgICAgIG5vZGVJc1JlZ0V4cCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzUmVnRXhwLFxyXG4gICAgICBub2RlSXNTZXQgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1NldCxcclxuICAgICAgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcclxuXHJcbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcblxyXG4gIC8qKlxyXG4gICAqIEEgZmFzdGVyIGFsdGVybmF0aXZlIHRvIGBGdW5jdGlvbiNhcHBseWAsIHRoaXMgZnVuY3Rpb24gaW52b2tlcyBgZnVuY2BcclxuICAgKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBhcmd1bWVudHMgb2YgYGFyZ3NgLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXHJcbiAgICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXHJcbiAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cclxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBmdW5jYC5cclxuICAgKi9cclxuICBmdW5jdGlvbiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKSB7XHJcbiAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XHJcbiAgICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcclxuICAgICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0pO1xyXG4gICAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSk7XHJcbiAgICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlQWdncmVnYXRvcmAgZm9yIGFycmF5cy5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGBhY2N1bXVsYXRvcmAgdmFsdWVzLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cclxuICAgKiBAcGFyYW0ge09iamVjdH0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgYWdncmVnYXRlZCBvYmplY3QuXHJcbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBhY2N1bXVsYXRvcmAuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gYXJyYXlBZ2dyZWdhdG9yKGFycmF5LCBzZXR0ZXIsIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xyXG4gICAgdmFyIGluZGV4ID0gLTEsXHJcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XHJcblxyXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcclxuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xyXG4gICAgICBzZXR0ZXIoYWNjdW11bGF0b3IsIHZhbHVlLCBpdGVyYXRlZSh2YWx1ZSksIGFycmF5KTtcclxuICAgIH1cclxuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cclxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cclxuICAgKi9cclxuICBmdW5jdGlvbiBhcnJheUVhY2goYXJyYXksIGl0ZXJhdGVlKSB7XHJcbiAgICB2YXIgaW5kZXggPSAtMSxcclxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcclxuXHJcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xyXG4gICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpID09PSBmYWxzZSkge1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXJyYXk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaFJpZ2h0YCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cclxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cclxuICAgKi9cclxuICBmdW5jdGlvbiBhcnJheUVhY2hSaWdodChhcnJheSwgaXRlcmF0ZWUpIHtcclxuICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcclxuXHJcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcclxuICAgICAgaWYgKGl0ZXJhdGVlKGFycmF5W2xlbmd0aF0sIGxlbmd0aCwgYXJyYXkpID09PSBmYWxzZSkge1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXJyYXk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZXZlcnlgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxyXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3MgdGhlIHByZWRpY2F0ZSBjaGVjayxcclxuICAgKiAgZWxzZSBgZmFsc2VgLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGFycmF5RXZlcnkoYXJyYXksIHByZWRpY2F0ZSkge1xyXG4gICAgdmFyIGluZGV4ID0gLTEsXHJcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XHJcblxyXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcclxuICAgICAgaWYgKCFwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5maWx0ZXJgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxyXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cclxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cclxuICAgKi9cclxuICBmdW5jdGlvbiBhcnJheUZpbHRlcihhcnJheSwgcHJlZGljYXRlKSB7XHJcbiAgICB2YXIgaW5kZXggPSAtMSxcclxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcclxuICAgICAgICByZXNJbmRleCA9IDAsXHJcbiAgICAgICAgcmVzdWx0ID0gW107XHJcblxyXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcclxuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xyXG4gICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XHJcbiAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uaW5jbHVkZXNgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxyXG4gICAqIHNwZWNpZnlpbmcgYW4gaW5kZXggdG8gc2VhcmNoIGZyb20uXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGluc3BlY3QuXHJcbiAgICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB0YXJnZXRgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gYXJyYXlJbmNsdWRlcyhhcnJheSwgdmFsdWUpIHtcclxuICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcclxuICAgIHJldHVybiAhIWxlbmd0aCAmJiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIDApID4gLTE7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFycmF5SW5jbHVkZXNgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYSBjb21wYXJhdG9yLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpbnNwZWN0LlxyXG4gICAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHRhcmdldGAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cclxuICAgKi9cclxuICBmdW5jdGlvbiBhcnJheUluY2x1ZGVzV2l0aChhcnJheSwgdmFsdWUsIGNvbXBhcmF0b3IpIHtcclxuICAgIHZhciBpbmRleCA9IC0xLFxyXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xyXG5cclxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XHJcbiAgICAgIGlmIChjb21wYXJhdG9yKHZhbHVlLCBhcnJheVtpbmRleF0pKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxyXG4gICAqIHNob3J0aGFuZHMuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxyXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cclxuICAgKi9cclxuICBmdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcclxuICAgIHZhciBpbmRleCA9IC0xLFxyXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxyXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XHJcblxyXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcclxuICAgICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxyXG4gICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cclxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cclxuICAgKi9cclxuICBmdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xyXG4gICAgdmFyIGluZGV4ID0gLTEsXHJcbiAgICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcclxuICAgICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XHJcblxyXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcclxuICAgICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcclxuICAgIH1cclxuICAgIHJldHVybiBhcnJheTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5yZWR1Y2VgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxyXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxyXG4gICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0QWNjdW1dIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YCBhc1xyXG4gICAqICB0aGUgaW5pdGlhbCB2YWx1ZS5cclxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gYXJyYXlSZWR1Y2UoYXJyYXksIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtKSB7XHJcbiAgICB2YXIgaW5kZXggPSAtMSxcclxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcclxuXHJcbiAgICBpZiAoaW5pdEFjY3VtICYmIGxlbmd0aCkge1xyXG4gICAgICBhY2N1bXVsYXRvciA9IGFycmF5WysraW5kZXhdO1xyXG4gICAgfVxyXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcclxuICAgICAgYWNjdW11bGF0b3IgPSBpdGVyYXRlZShhY2N1bXVsYXRvciwgYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnJlZHVjZVJpZ2h0YCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cclxuICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBbaW5pdEFjY3VtXSBTcGVjaWZ5IHVzaW5nIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YCBhc1xyXG4gICAqICB0aGUgaW5pdGlhbCB2YWx1ZS5cclxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gYXJyYXlSZWR1Y2VSaWdodChhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0pIHtcclxuICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcclxuICAgIGlmIChpbml0QWNjdW0gJiYgbGVuZ3RoKSB7XHJcbiAgICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbLS1sZW5ndGhdO1xyXG4gICAgfVxyXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XHJcbiAgICAgIGFjY3VtdWxhdG9yID0gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIGFycmF5W2xlbmd0aF0sIGxlbmd0aCwgYXJyYXkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNvbWVgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxyXG4gICAqIHNob3J0aGFuZHMuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXHJcbiAgICogIGVsc2UgYGZhbHNlYC5cclxuICAgKi9cclxuICBmdW5jdGlvbiBhcnJheVNvbWUoYXJyYXksIHByZWRpY2F0ZSkge1xyXG4gICAgdmFyIGluZGV4ID0gLTEsXHJcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XHJcblxyXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcclxuICAgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgc2l6ZSBvZiBhbiBBU0NJSSBgc3RyaW5nYC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIGluc3BlY3QuXHJcbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIHNpemUuXHJcbiAgICovXHJcbiAgdmFyIGFzY2lpU2l6ZSA9IGJhc2VQcm9wZXJ0eSgnbGVuZ3RoJyk7XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnZlcnRzIGFuIEFTQ0lJIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cclxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cclxuICAgKi9cclxuICBmdW5jdGlvbiBhc2NpaVRvQXJyYXkoc3RyaW5nKSB7XHJcbiAgICByZXR1cm4gc3RyaW5nLnNwbGl0KCcnKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNwbGl0cyBhbiBBU0NJSSBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGl0cyB3b3Jkcy5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cclxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdvcmRzIG9mIGBzdHJpbmdgLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGFzY2lpV29yZHMoc3RyaW5nKSB7XHJcbiAgICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlQXNjaWlXb3JkKSB8fCBbXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy5maW5kS2V5YCBhbmQgYF8uZmluZExhc3RLZXlgLFxyXG4gICAqIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcywgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgY29sbGVjdGlvbmBcclxuICAgKiB1c2luZyBgZWFjaEZ1bmNgLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYGNvbGxlY3Rpb25gLlxyXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmb3VuZCBlbGVtZW50IG9yIGl0cyBrZXksIGVsc2UgYHVuZGVmaW5lZGAuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gYmFzZUZpbmRLZXkoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBlYWNoRnVuYykge1xyXG4gICAgdmFyIHJlc3VsdDtcclxuICAgIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcclxuICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSkge1xyXG4gICAgICAgIHJlc3VsdCA9IGtleTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbmRJbmRleGAgYW5kIGBfLmZpbmRMYXN0SW5kZXhgIHdpdGhvdXRcclxuICAgKiBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGJhc2VGaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4LCBmcm9tUmlnaHQpIHtcclxuICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXHJcbiAgICAgICAgaW5kZXggPSBmcm9tSW5kZXggKyAoZnJvbVJpZ2h0ID8gMSA6IC0xKTtcclxuXHJcbiAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xyXG4gICAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xyXG4gICAgICAgIHJldHVybiBpbmRleDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIC0xO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW5kZXhPZmAgd2l0aG91dCBgZnJvbUluZGV4YCBib3VuZHMgY2hlY2tzLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cclxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcclxuICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWVcclxuICAgICAgPyBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KVxyXG4gICAgICA6IGJhc2VGaW5kSW5kZXgoYXJyYXksIGJhc2VJc05hTiwgZnJvbUluZGV4KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYmFzZUluZGV4T2ZgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYSBjb21wYXJhdG9yLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cclxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGJhc2VJbmRleE9mV2l0aChhcnJheSwgdmFsdWUsIGZyb21JbmRleCwgY29tcGFyYXRvcikge1xyXG4gICAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSxcclxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XHJcblxyXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcclxuICAgICAgaWYgKGNvbXBhcmF0b3IoYXJyYXlbaW5kZXhdLCB2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gaW5kZXg7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiAtMTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmFOYCB3aXRob3V0IHN1cHBvcnQgZm9yIG51bWJlciBvYmplY3RzLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGJhc2VJc05hTih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1lYW5gIGFuZCBgXy5tZWFuQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3JcclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXHJcbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbWVhbi5cclxuICAgKi9cclxuICBmdW5jdGlvbiBiYXNlTWVhbihhcnJheSwgaXRlcmF0ZWUpIHtcclxuICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcclxuICAgIHJldHVybiBsZW5ndGggPyAoYmFzZVN1bShhcnJheSwgaXRlcmF0ZWUpIC8gbGVuZ3RoKSA6IE5BTjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxyXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcclxuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlPZmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXHJcbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gYmFzZVByb3BlcnR5T2Yob2JqZWN0KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlZHVjZWAgYW5kIGBfLnJlZHVjZVJpZ2h0YCwgd2l0aG91dCBzdXBwb3J0XHJcbiAgICogZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMsIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYGNvbGxlY3Rpb25gIHVzaW5nIGBlYWNoRnVuY2AuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxyXG4gICAqIEBwYXJhbSB7Kn0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgdmFsdWUuXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBpbml0QWNjdW0gU3BlY2lmeSB1c2luZyB0aGUgZmlyc3Qgb3IgbGFzdCBlbGVtZW50IG9mXHJcbiAgICogIGBjb2xsZWN0aW9uYCBhcyB0aGUgaW5pdGlhbCB2YWx1ZS5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGBjb2xsZWN0aW9uYC5cclxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gYmFzZVJlZHVjZShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgZWFjaEZ1bmMpIHtcclxuICAgIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xyXG4gICAgICBhY2N1bXVsYXRvciA9IGluaXRBY2N1bVxyXG4gICAgICAgID8gKGluaXRBY2N1bSA9IGZhbHNlLCB2YWx1ZSlcclxuICAgICAgICA6IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0QnlgIHdoaWNoIHVzZXMgYGNvbXBhcmVyYCB0byBkZWZpbmUgdGhlXHJcbiAgICogc29ydCBvcmRlciBvZiBgYXJyYXlgIGFuZCByZXBsYWNlcyBjcml0ZXJpYSBvYmplY3RzIHdpdGggdGhlaXIgY29ycmVzcG9uZGluZ1xyXG4gICAqIHZhbHVlcy5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNvcnQuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyZXIgVGhlIGZ1bmN0aW9uIHRvIGRlZmluZSBzb3J0IG9yZGVyLlxyXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGJhc2VTb3J0QnkoYXJyYXksIGNvbXBhcmVyKSB7XHJcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xyXG5cclxuICAgIGFycmF5LnNvcnQoY29tcGFyZXIpO1xyXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XHJcbiAgICAgIGFycmF5W2xlbmd0aF0gPSBhcnJheVtsZW5ndGhdLnZhbHVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFycmF5O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc3VtYCBhbmQgYF8uc3VtQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3JcclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXHJcbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3VtLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGJhc2VTdW0oYXJyYXksIGl0ZXJhdGVlKSB7XHJcbiAgICB2YXIgcmVzdWx0LFxyXG4gICAgICAgIGluZGV4ID0gLTEsXHJcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xyXG5cclxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XHJcbiAgICAgIHZhciBjdXJyZW50ID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdKTtcclxuICAgICAgaWYgKGN1cnJlbnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gY3VycmVudCA6IChyZXN1bHQgKyBjdXJyZW50KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcclxuICAgKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxyXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cclxuICAgKi9cclxuICBmdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcclxuICAgIHZhciBpbmRleCA9IC0xLFxyXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xyXG5cclxuICAgIHdoaWxlICgrK2luZGV4IDwgbikge1xyXG4gICAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvUGFpcnNgIGFuZCBgXy50b1BhaXJzSW5gIHdoaWNoIGNyZWF0ZXMgYW4gYXJyYXlcclxuICAgKiBvZiBrZXktdmFsdWUgcGFpcnMgZm9yIGBvYmplY3RgIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3BlcnR5IG5hbWVzIG9mIGBwcm9wc2AuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cclxuICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZ2V0IHZhbHVlcyBmb3IuXHJcbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGJhc2VUb1BhaXJzKG9iamVjdCwgcHJvcHMpIHtcclxuICAgIHJldHVybiBhcnJheU1hcChwcm9wcywgZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgIHJldHVybiBba2V5LCBvYmplY3Rba2V5XV07XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRyaW1gLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gdHJpbS5cclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cclxuICAgKi9cclxuICBmdW5jdGlvbiBiYXNlVHJpbShzdHJpbmcpIHtcclxuICAgIHJldHVybiBzdHJpbmdcclxuICAgICAgPyBzdHJpbmcuc2xpY2UoMCwgdHJpbW1lZEVuZEluZGV4KHN0cmluZykgKyAxKS5yZXBsYWNlKHJlVHJpbVN0YXJ0LCAnJylcclxuICAgICAgOiBzdHJpbmc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cclxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udmFsdWVzYCBhbmQgYF8udmFsdWVzSW5gIHdoaWNoIGNyZWF0ZXMgYW5cclxuICAgKiBhcnJheSBvZiBgb2JqZWN0YCBwcm9wZXJ0eSB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvcGVydHkgbmFtZXNcclxuICAgKiBvZiBgcHJvcHNgLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXHJcbiAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGdldCB2YWx1ZXMgZm9yLlxyXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cclxuICAgKi9cclxuICBmdW5jdGlvbiBiYXNlVmFsdWVzKG9iamVjdCwgcHJvcHMpIHtcclxuICAgIHJldHVybiBhcnJheU1hcChwcm9wcywgZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgIHJldHVybiBvYmplY3Rba2V5XTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2tzIGlmIGEgYGNhY2hlYCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIHRvIHF1ZXJ5LlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cclxuICAgKi9cclxuICBmdW5jdGlvbiBjYWNoZUhhcyhjYWNoZSwga2V5KSB7XHJcbiAgICByZXR1cm4gY2FjaGUuaGFzKGtleSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVc2VkIGJ5IGBfLnRyaW1gIGFuZCBgXy50cmltU3RhcnRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IHN0cmluZyBzeW1ib2xcclxuICAgKiB0aGF0IGlzIG5vdCBmb3VuZCBpbiB0aGUgY2hhcmFjdGVyIHN5bWJvbHMuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7QXJyYXl9IHN0clN5bWJvbHMgVGhlIHN0cmluZyBzeW1ib2xzIHRvIGluc3BlY3QuXHJcbiAgICogQHBhcmFtIHtBcnJheX0gY2hyU3ltYm9scyBUaGUgY2hhcmFjdGVyIHN5bWJvbHMgdG8gZmluZC5cclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgdW5tYXRjaGVkIHN0cmluZyBzeW1ib2wuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gY2hhcnNTdGFydEluZGV4KHN0clN5bWJvbHMsIGNoclN5bWJvbHMpIHtcclxuICAgIHZhciBpbmRleCA9IC0xLFxyXG4gICAgICAgIGxlbmd0aCA9IHN0clN5bWJvbHMubGVuZ3RoO1xyXG5cclxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoICYmIGJhc2VJbmRleE9mKGNoclN5bWJvbHMsIHN0clN5bWJvbHNbaW5kZXhdLCAwKSA+IC0xKSB7fVxyXG4gICAgcmV0dXJuIGluZGV4O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbUVuZGAgdG8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBzdHJpbmcgc3ltYm9sXHJcbiAgICogdGhhdCBpcyBub3QgZm91bmQgaW4gdGhlIGNoYXJhY3RlciBzeW1ib2xzLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0FycmF5fSBzdHJTeW1ib2xzIFRoZSBzdHJpbmcgc3ltYm9scyB0byBpbnNwZWN0LlxyXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNoclN5bWJvbHMgVGhlIGNoYXJhY3RlciBzeW1ib2xzIHRvIGZpbmQuXHJcbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGxhc3QgdW5tYXRjaGVkIHN0cmluZyBzeW1ib2wuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gY2hhcnNFbmRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSB7XHJcbiAgICB2YXIgaW5kZXggPSBzdHJTeW1ib2xzLmxlbmd0aDtcclxuXHJcbiAgICB3aGlsZSAoaW5kZXgtLSAmJiBiYXNlSW5kZXhPZihjaHJTeW1ib2xzLCBzdHJTeW1ib2xzW2luZGV4XSwgMCkgPiAtMSkge31cclxuICAgIHJldHVybiBpbmRleDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIG51bWJlciBvZiBgcGxhY2Vob2xkZXJgIG9jY3VycmVuY2VzIGluIGBhcnJheWAuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxyXG4gICAqIEBwYXJhbSB7Kn0gcGxhY2Vob2xkZXIgVGhlIHBsYWNlaG9sZGVyIHRvIHNlYXJjaCBmb3IuXHJcbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcGxhY2Vob2xkZXIgY291bnQuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gY291bnRIb2xkZXJzKGFycmF5LCBwbGFjZWhvbGRlcikge1xyXG4gICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcclxuICAgICAgICByZXN1bHQgPSAwO1xyXG5cclxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xyXG4gICAgICBpZiAoYXJyYXlbbGVuZ3RoXSA9PT0gcGxhY2Vob2xkZXIpIHtcclxuICAgICAgICArK3Jlc3VsdDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVzZWQgYnkgYF8uZGVidXJyYCB0byBjb252ZXJ0IExhdGluLTEgU3VwcGxlbWVudCBhbmQgTGF0aW4gRXh0ZW5kZWQtQVxyXG4gICAqIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycy5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxldHRlciBUaGUgbWF0Y2hlZCBsZXR0ZXIgdG8gZGVidXJyLlxyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGRlYnVycmVkIGxldHRlci5cclxuICAgKi9cclxuICB2YXIgZGVidXJyTGV0dGVyID0gYmFzZVByb3BlcnR5T2YoZGVidXJyZWRMZXR0ZXJzKTtcclxuXHJcbiAgLyoqXHJcbiAgICogVXNlZCBieSBgXy5lc2NhcGVgIHRvIGNvbnZlcnQgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXHJcbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXHJcbiAgICovXHJcbiAgdmFyIGVzY2FwZUh0bWxDaGFyID0gYmFzZVByb3BlcnR5T2YoaHRtbEVzY2FwZXMpO1xyXG5cclxuICAvKipcclxuICAgKiBVc2VkIGJ5IGBfLnRlbXBsYXRlYCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGVzY2FwZVN0cmluZ0NoYXIoY2hyKSB7XHJcbiAgICByZXR1cm4gJ1xcXFwnICsgc3RyaW5nRXNjYXBlc1tjaHJdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxyXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cclxuICAgKi9cclxuICBmdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xyXG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGVja3MgaWYgYHN0cmluZ2AgY29udGFpbnMgVW5pY29kZSBzeW1ib2xzLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYSBzeW1ib2wgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cclxuICAgKi9cclxuICBmdW5jdGlvbiBoYXNVbmljb2RlKHN0cmluZykge1xyXG4gICAgcmV0dXJuIHJlSGFzVW5pY29kZS50ZXN0KHN0cmluZyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGVja3MgaWYgYHN0cmluZ2AgY29udGFpbnMgYSB3b3JkIGNvbXBvc2VkIG9mIFVuaWNvZGUgc3ltYm9scy5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGEgd29yZCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGhhc1VuaWNvZGVXb3JkKHN0cmluZykge1xyXG4gICAgcmV0dXJuIHJlSGFzVW5pY29kZVdvcmQudGVzdChzdHJpbmcpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29udmVydHMgYGl0ZXJhdG9yYCB0byBhbiBhcnJheS5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGl0ZXJhdG9yIFRoZSBpdGVyYXRvciB0byBjb252ZXJ0LlxyXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGl0ZXJhdG9yVG9BcnJheShpdGVyYXRvcikge1xyXG4gICAgdmFyIGRhdGEsXHJcbiAgICAgICAgcmVzdWx0ID0gW107XHJcblxyXG4gICAgd2hpbGUgKCEoZGF0YSA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xyXG4gICAgICByZXN1bHQucHVzaChkYXRhLnZhbHVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cclxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cclxuICAgKi9cclxuICBmdW5jdGlvbiBtYXBUb0FycmF5KG1hcCkge1xyXG4gICAgdmFyIGluZGV4ID0gLTEsXHJcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xyXG5cclxuICAgIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcclxuICAgICAgcmVzdWx0WysraW5kZXhdID0gW2tleSwgdmFsdWVdO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXHJcbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcclxuICAgIHJldHVybiBmdW5jdGlvbihhcmcpIHtcclxuICAgICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlcGxhY2VzIGFsbCBgcGxhY2Vob2xkZXJgIGVsZW1lbnRzIGluIGBhcnJheWAgd2l0aCBhbiBpbnRlcm5hbCBwbGFjZWhvbGRlclxyXG4gICAqIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHRoZWlyIGluZGV4ZXMuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXHJcbiAgICogQHBhcmFtIHsqfSBwbGFjZWhvbGRlciBUaGUgcGxhY2Vob2xkZXIgdG8gcmVwbGFjZS5cclxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBwbGFjZWhvbGRlciBpbmRleGVzLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIHJlcGxhY2VIb2xkZXJzKGFycmF5LCBwbGFjZWhvbGRlcikge1xyXG4gICAgdmFyIGluZGV4ID0gLTEsXHJcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxyXG4gICAgICAgIHJlc0luZGV4ID0gMCxcclxuICAgICAgICByZXN1bHQgPSBbXTtcclxuXHJcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xyXG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XHJcbiAgICAgIGlmICh2YWx1ZSA9PT0gcGxhY2Vob2xkZXIgfHwgdmFsdWUgPT09IFBMQUNFSE9MREVSKSB7XHJcbiAgICAgICAgYXJyYXlbaW5kZXhdID0gUExBQ0VIT0xERVI7XHJcbiAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gaW5kZXg7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cclxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlcy5cclxuICAgKi9cclxuICBmdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xyXG4gICAgdmFyIGluZGV4ID0gLTEsXHJcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xyXG5cclxuICAgIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29udmVydHMgYHNldGAgdG8gaXRzIHZhbHVlLXZhbHVlIHBhaXJzLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cclxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlLXZhbHVlIHBhaXJzLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIHNldFRvUGFpcnMoc2V0KSB7XHJcbiAgICB2YXIgaW5kZXggPSAtMSxcclxuICAgICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XHJcblxyXG4gICAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgcmVzdWx0WysraW5kZXhdID0gW3ZhbHVlLCB2YWx1ZV07XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uaW5kZXhPZmAgd2hpY2ggcGVyZm9ybXMgc3RyaWN0IGVxdWFsaXR5XHJcbiAgICogY29tcGFyaXNvbnMgb2YgdmFsdWVzLCBpLmUuIGA9PT1gLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cclxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xyXG4gICAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSxcclxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XHJcblxyXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcclxuICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gaW5kZXg7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiAtMTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5sYXN0SW5kZXhPZmAgd2hpY2ggcGVyZm9ybXMgc3RyaWN0IGVxdWFsaXR5XHJcbiAgICogY29tcGFyaXNvbnMgb2YgdmFsdWVzLCBpLmUuIGA9PT1gLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cclxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gc3RyaWN0TGFzdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcclxuICAgIHZhciBpbmRleCA9IGZyb21JbmRleCArIDE7XHJcbiAgICB3aGlsZSAoaW5kZXgtLSkge1xyXG4gICAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBpbmRleDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGluZGV4O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgbnVtYmVyIG9mIHN5bWJvbHMgaW4gYHN0cmluZ2AuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBzaXplLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIHN0cmluZ1NpemUoc3RyaW5nKSB7XHJcbiAgICByZXR1cm4gaGFzVW5pY29kZShzdHJpbmcpXHJcbiAgICAgID8gdW5pY29kZVNpemUoc3RyaW5nKVxyXG4gICAgICA6IGFzY2lpU2l6ZShzdHJpbmcpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxyXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIHN0cmluZ1RvQXJyYXkoc3RyaW5nKSB7XHJcbiAgICByZXR1cm4gaGFzVW5pY29kZShzdHJpbmcpXHJcbiAgICAgID8gdW5pY29kZVRvQXJyYXkoc3RyaW5nKVxyXG4gICAgICA6IGFzY2lpVG9BcnJheShzdHJpbmcpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbUVuZGAgdG8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBub24td2hpdGVzcGFjZVxyXG4gICAqIGNoYXJhY3RlciBvZiBgc3RyaW5nYC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXHJcbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVyLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIHRyaW1tZWRFbmRJbmRleChzdHJpbmcpIHtcclxuICAgIHZhciBpbmRleCA9IHN0cmluZy5sZW5ndGg7XHJcblxyXG4gICAgd2hpbGUgKGluZGV4LS0gJiYgcmVXaGl0ZXNwYWNlLnRlc3Qoc3RyaW5nLmNoYXJBdChpbmRleCkpKSB7fVxyXG4gICAgcmV0dXJuIGluZGV4O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXNlZCBieSBgXy51bmVzY2FwZWAgdG8gY29udmVydCBIVE1MIGVudGl0aWVzIHRvIGNoYXJhY3RlcnMuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIHVuZXNjYXBlLlxyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuZXNjYXBlZCBjaGFyYWN0ZXIuXHJcbiAgICovXHJcbiAgdmFyIHVuZXNjYXBlSHRtbENoYXIgPSBiYXNlUHJvcGVydHlPZihodG1sVW5lc2NhcGVzKTtcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgc2l6ZSBvZiBhIFVuaWNvZGUgYHN0cmluZ2AuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyBpbnNwZWN0LlxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBzaXplLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIHVuaWNvZGVTaXplKHN0cmluZykge1xyXG4gICAgdmFyIHJlc3VsdCA9IHJlVW5pY29kZS5sYXN0SW5kZXggPSAwO1xyXG4gICAgd2hpbGUgKHJlVW5pY29kZS50ZXN0KHN0cmluZykpIHtcclxuICAgICAgKytyZXN1bHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29udmVydHMgYSBVbmljb2RlIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cclxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cclxuICAgKi9cclxuICBmdW5jdGlvbiB1bmljb2RlVG9BcnJheShzdHJpbmcpIHtcclxuICAgIHJldHVybiBzdHJpbmcubWF0Y2gocmVVbmljb2RlKSB8fCBbXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNwbGl0cyBhIFVuaWNvZGUgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBpdHMgd29yZHMuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXHJcbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cclxuICAgKi9cclxuICBmdW5jdGlvbiB1bmljb2RlV29yZHMoc3RyaW5nKSB7XHJcbiAgICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlVW5pY29kZVdvcmQpIHx8IFtdO1xyXG4gIH1cclxuXHJcbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG5ldyBwcmlzdGluZSBgbG9kYXNoYCBmdW5jdGlvbiB1c2luZyB0aGUgYGNvbnRleHRgIG9iamVjdC5cclxuICAgKlxyXG4gICAqIEBzdGF0aWNcclxuICAgKiBAbWVtYmVyT2YgX1xyXG4gICAqIEBzaW5jZSAxLjEuMFxyXG4gICAqIEBjYXRlZ29yeSBVdGlsXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0PXJvb3RdIFRoZSBjb250ZXh0IG9iamVjdC5cclxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYSBuZXcgYGxvZGFzaGAgZnVuY3Rpb24uXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIF8ubWl4aW4oeyAnZm9vJzogXy5jb25zdGFudCgnZm9vJykgfSk7XHJcbiAgICpcclxuICAgKiB2YXIgbG9kYXNoID0gXy5ydW5JbkNvbnRleHQoKTtcclxuICAgKiBsb2Rhc2gubWl4aW4oeyAnYmFyJzogbG9kYXNoLmNvbnN0YW50KCdiYXInKSB9KTtcclxuICAgKlxyXG4gICAqIF8uaXNGdW5jdGlvbihfLmZvbyk7XHJcbiAgICogLy8gPT4gdHJ1ZVxyXG4gICAqIF8uaXNGdW5jdGlvbihfLmJhcik7XHJcbiAgICogLy8gPT4gZmFsc2VcclxuICAgKlxyXG4gICAqIGxvZGFzaC5pc0Z1bmN0aW9uKGxvZGFzaC5mb28pO1xyXG4gICAqIC8vID0+IGZhbHNlXHJcbiAgICogbG9kYXNoLmlzRnVuY3Rpb24obG9kYXNoLmJhcik7XHJcbiAgICogLy8gPT4gdHJ1ZVxyXG4gICAqXHJcbiAgICogLy8gQ3JlYXRlIGEgc3VwZWQtdXAgYGRlZmVyYCBpbiBOb2RlLmpzLlxyXG4gICAqIHZhciBkZWZlciA9IF8ucnVuSW5Db250ZXh0KHsgJ3NldFRpbWVvdXQnOiBzZXRJbW1lZGlhdGUgfSkuZGVmZXI7XHJcbiAgICovXHJcbiAgdmFyIHJ1bkluQ29udGV4dCA9IChmdW5jdGlvbiBydW5JbkNvbnRleHQoY29udGV4dCkge1xyXG4gICAgY29udGV4dCA9IGNvbnRleHQgPT0gbnVsbCA/IHJvb3QgOiBfLmRlZmF1bHRzKHJvb3QuT2JqZWN0KCksIGNvbnRleHQsIF8ucGljayhyb290LCBjb250ZXh0UHJvcHMpKTtcclxuXHJcbiAgICAvKiogQnVpbHQtaW4gY29uc3RydWN0b3IgcmVmZXJlbmNlcy4gKi9cclxuICAgIHZhciBBcnJheSA9IGNvbnRleHQuQXJyYXksXHJcbiAgICAgICAgRGF0ZSA9IGNvbnRleHQuRGF0ZSxcclxuICAgICAgICBFcnJvciA9IGNvbnRleHQuRXJyb3IsXHJcbiAgICAgICAgRnVuY3Rpb24gPSBjb250ZXh0LkZ1bmN0aW9uLFxyXG4gICAgICAgIE1hdGggPSBjb250ZXh0Lk1hdGgsXHJcbiAgICAgICAgT2JqZWN0ID0gY29udGV4dC5PYmplY3QsXHJcbiAgICAgICAgUmVnRXhwID0gY29udGV4dC5SZWdFeHAsXHJcbiAgICAgICAgU3RyaW5nID0gY29udGV4dC5TdHJpbmcsXHJcbiAgICAgICAgVHlwZUVycm9yID0gY29udGV4dC5UeXBlRXJyb3I7XHJcblxyXG4gICAgLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xyXG4gICAgdmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsXHJcbiAgICAgICAgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxyXG4gICAgICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcclxuXHJcbiAgICAvKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXHJcbiAgICB2YXIgY29yZUpzRGF0YSA9IGNvbnRleHRbJ19fY29yZS1qc19zaGFyZWRfXyddO1xyXG5cclxuICAgIC8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cclxuICAgIHZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XHJcblxyXG4gICAgLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXHJcbiAgICB2YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcclxuXHJcbiAgICAvKiogVXNlZCB0byBnZW5lcmF0ZSB1bmlxdWUgSURzLiAqL1xyXG4gICAgdmFyIGlkQ291bnRlciA9IDA7XHJcblxyXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cclxuICAgIHZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xyXG4gICAgICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XHJcbiAgICB9KCkpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXNlZCB0byByZXNvbHZlIHRoZVxyXG4gICAgICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXHJcbiAgICAgKiBvZiB2YWx1ZXMuXHJcbiAgICAgKi9cclxuICAgIHZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xyXG5cclxuICAgIC8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cclxuICAgIHZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcclxuXHJcbiAgICAvKiogVXNlZCB0byByZXN0b3JlIHRoZSBvcmlnaW5hbCBgX2AgcmVmZXJlbmNlIGluIGBfLm5vQ29uZmxpY3RgLiAqL1xyXG4gICAgdmFyIG9sZERhc2ggPSByb290Ll87XHJcblxyXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cclxuICAgIHZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXHJcbiAgICAgIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXHJcbiAgICAgIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xyXG4gICAgKTtcclxuXHJcbiAgICAvKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cclxuICAgIHZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gY29udGV4dC5CdWZmZXIgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgU3ltYm9sID0gY29udGV4dC5TeW1ib2wsXHJcbiAgICAgICAgVWludDhBcnJheSA9IGNvbnRleHQuVWludDhBcnJheSxcclxuICAgICAgICBhbGxvY1Vuc2FmZSA9IEJ1ZmZlciA/IEJ1ZmZlci5hbGxvY1Vuc2FmZSA6IHVuZGVmaW5lZCxcclxuICAgICAgICBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KSxcclxuICAgICAgICBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlLFxyXG4gICAgICAgIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGUsXHJcbiAgICAgICAgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2UsXHJcbiAgICAgICAgc3ByZWFkYWJsZVN5bWJvbCA9IFN5bWJvbCA/IFN5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGUgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgc3ltSXRlcmF0b3IgPSBTeW1ib2wgPyBTeW1ib2wuaXRlcmF0b3IgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XHJcblxyXG4gICAgdmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHZhciBmdW5jID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2RlZmluZVByb3BlcnR5Jyk7XHJcbiAgICAgICAgZnVuYyh7fSwgJycsIHt9KTtcclxuICAgICAgICByZXR1cm4gZnVuYztcclxuICAgICAgfSBjYXRjaCAoZSkge31cclxuICAgIH0oKSk7XHJcblxyXG4gICAgLyoqIE1vY2tlZCBidWlsdC1pbnMuICovXHJcbiAgICB2YXIgY3R4Q2xlYXJUaW1lb3V0ID0gY29udGV4dC5jbGVhclRpbWVvdXQgIT09IHJvb3QuY2xlYXJUaW1lb3V0ICYmIGNvbnRleHQuY2xlYXJUaW1lb3V0LFxyXG4gICAgICAgIGN0eE5vdyA9IERhdGUgJiYgRGF0ZS5ub3cgIT09IHJvb3QuRGF0ZS5ub3cgJiYgRGF0ZS5ub3csXHJcbiAgICAgICAgY3R4U2V0VGltZW91dCA9IGNvbnRleHQuc2V0VGltZW91dCAhPT0gcm9vdC5zZXRUaW1lb3V0ICYmIGNvbnRleHQuc2V0VGltZW91dDtcclxuXHJcbiAgICAvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXHJcbiAgICB2YXIgbmF0aXZlQ2VpbCA9IE1hdGguY2VpbCxcclxuICAgICAgICBuYXRpdmVGbG9vciA9IE1hdGguZmxvb3IsXHJcbiAgICAgICAgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsXHJcbiAgICAgICAgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgbmF0aXZlSXNGaW5pdGUgPSBjb250ZXh0LmlzRmluaXRlLFxyXG4gICAgICAgIG5hdGl2ZUpvaW4gPSBhcnJheVByb3RvLmpvaW4sXHJcbiAgICAgICAgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCksXHJcbiAgICAgICAgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXHJcbiAgICAgICAgbmF0aXZlTWluID0gTWF0aC5taW4sXHJcbiAgICAgICAgbmF0aXZlTm93ID0gRGF0ZS5ub3csXHJcbiAgICAgICAgbmF0aXZlUGFyc2VJbnQgPSBjb250ZXh0LnBhcnNlSW50LFxyXG4gICAgICAgIG5hdGl2ZVJhbmRvbSA9IE1hdGgucmFuZG9tLFxyXG4gICAgICAgIG5hdGl2ZVJldmVyc2UgPSBhcnJheVByb3RvLnJldmVyc2U7XHJcblxyXG4gICAgLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xyXG4gICAgdmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKGNvbnRleHQsICdEYXRhVmlldycpLFxyXG4gICAgICAgIE1hcCA9IGdldE5hdGl2ZShjb250ZXh0LCAnTWFwJyksXHJcbiAgICAgICAgUHJvbWlzZSA9IGdldE5hdGl2ZShjb250ZXh0LCAnUHJvbWlzZScpLFxyXG4gICAgICAgIFNldCA9IGdldE5hdGl2ZShjb250ZXh0LCAnU2V0JyksXHJcbiAgICAgICAgV2Vha01hcCA9IGdldE5hdGl2ZShjb250ZXh0LCAnV2Vha01hcCcpLFxyXG4gICAgICAgIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcclxuXHJcbiAgICAvKiogVXNlZCB0byBzdG9yZSBmdW5jdGlvbiBtZXRhZGF0YS4gKi9cclxuICAgIHZhciBtZXRhTWFwID0gV2Vha01hcCAmJiBuZXcgV2Vha01hcDtcclxuXHJcbiAgICAvKiogVXNlZCB0byBsb29rdXAgdW5taW5pZmllZCBmdW5jdGlvbiBuYW1lcy4gKi9cclxuICAgIHZhciByZWFsTmFtZXMgPSB7fTtcclxuXHJcbiAgICAvKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xyXG4gICAgdmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcclxuICAgICAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwKSxcclxuICAgICAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UpLFxyXG4gICAgICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxyXG4gICAgICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XHJcblxyXG4gICAgLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXHJcbiAgICB2YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxyXG4gICAgICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xyXG5cclxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBgbG9kYXNoYCBvYmplY3Qgd2hpY2ggd3JhcHMgYHZhbHVlYCB0byBlbmFibGUgaW1wbGljaXQgbWV0aG9kXHJcbiAgICAgKiBjaGFpbiBzZXF1ZW5jZXMuIE1ldGhvZHMgdGhhdCBvcGVyYXRlIG9uIGFuZCByZXR1cm4gYXJyYXlzLCBjb2xsZWN0aW9ucyxcclxuICAgICAqIGFuZCBmdW5jdGlvbnMgY2FuIGJlIGNoYWluZWQgdG9nZXRoZXIuIE1ldGhvZHMgdGhhdCByZXRyaWV2ZSBhIHNpbmdsZSB2YWx1ZVxyXG4gICAgICogb3IgbWF5IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZSB3aWxsIGF1dG9tYXRpY2FsbHkgZW5kIHRoZSBjaGFpbiBzZXF1ZW5jZVxyXG4gICAgICogYW5kIHJldHVybiB0aGUgdW53cmFwcGVkIHZhbHVlLiBPdGhlcndpc2UsIHRoZSB2YWx1ZSBtdXN0IGJlIHVud3JhcHBlZFxyXG4gICAgICogd2l0aCBgXyN2YWx1ZWAuXHJcbiAgICAgKlxyXG4gICAgICogRXhwbGljaXQgY2hhaW4gc2VxdWVuY2VzLCB3aGljaCBtdXN0IGJlIHVud3JhcHBlZCB3aXRoIGBfI3ZhbHVlYCwgbWF5IGJlXHJcbiAgICAgKiBlbmFibGVkIHVzaW5nIGBfLmNoYWluYC5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgZXhlY3V0aW9uIG9mIGNoYWluZWQgbWV0aG9kcyBpcyBsYXp5LCB0aGF0IGlzLCBpdCdzIGRlZmVycmVkIHVudGlsXHJcbiAgICAgKiBgXyN2YWx1ZWAgaXMgaW1wbGljaXRseSBvciBleHBsaWNpdGx5IGNhbGxlZC5cclxuICAgICAqXHJcbiAgICAgKiBMYXp5IGV2YWx1YXRpb24gYWxsb3dzIHNldmVyYWwgbWV0aG9kcyB0byBzdXBwb3J0IHNob3J0Y3V0IGZ1c2lvbi5cclxuICAgICAqIFNob3J0Y3V0IGZ1c2lvbiBpcyBhbiBvcHRpbWl6YXRpb24gdG8gbWVyZ2UgaXRlcmF0ZWUgY2FsbHM7IHRoaXMgYXZvaWRzXHJcbiAgICAgKiB0aGUgY3JlYXRpb24gb2YgaW50ZXJtZWRpYXRlIGFycmF5cyBhbmQgY2FuIGdyZWF0bHkgcmVkdWNlIHRoZSBudW1iZXIgb2ZcclxuICAgICAqIGl0ZXJhdGVlIGV4ZWN1dGlvbnMuIFNlY3Rpb25zIG9mIGEgY2hhaW4gc2VxdWVuY2UgcXVhbGlmeSBmb3Igc2hvcnRjdXRcclxuICAgICAqIGZ1c2lvbiBpZiB0aGUgc2VjdGlvbiBpcyBhcHBsaWVkIHRvIGFuIGFycmF5IGFuZCBpdGVyYXRlZXMgYWNjZXB0IG9ubHlcclxuICAgICAqIG9uZSBhcmd1bWVudC4gVGhlIGhldXJpc3RpYyBmb3Igd2hldGhlciBhIHNlY3Rpb24gcXVhbGlmaWVzIGZvciBzaG9ydGN1dFxyXG4gICAgICogZnVzaW9uIGlzIHN1YmplY3QgdG8gY2hhbmdlLlxyXG4gICAgICpcclxuICAgICAqIENoYWluaW5nIGlzIHN1cHBvcnRlZCBpbiBjdXN0b20gYnVpbGRzIGFzIGxvbmcgYXMgdGhlIGBfI3ZhbHVlYCBtZXRob2QgaXNcclxuICAgICAqIGRpcmVjdGx5IG9yIGluZGlyZWN0bHkgaW5jbHVkZWQgaW4gdGhlIGJ1aWxkLlxyXG4gICAgICpcclxuICAgICAqIEluIGFkZGl0aW9uIHRvIGxvZGFzaCBtZXRob2RzLCB3cmFwcGVycyBoYXZlIGBBcnJheWAgYW5kIGBTdHJpbmdgIG1ldGhvZHMuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIHdyYXBwZXIgYEFycmF5YCBtZXRob2RzIGFyZTpcclxuICAgICAqIGBjb25jYXRgLCBgam9pbmAsIGBwb3BgLCBgcHVzaGAsIGBzaGlmdGAsIGBzb3J0YCwgYHNwbGljZWAsIGFuZCBgdW5zaGlmdGBcclxuICAgICAqXHJcbiAgICAgKiBUaGUgd3JhcHBlciBgU3RyaW5nYCBtZXRob2RzIGFyZTpcclxuICAgICAqIGByZXBsYWNlYCBhbmQgYHNwbGl0YFxyXG4gICAgICpcclxuICAgICAqIFRoZSB3cmFwcGVyIG1ldGhvZHMgdGhhdCBzdXBwb3J0IHNob3J0Y3V0IGZ1c2lvbiBhcmU6XHJcbiAgICAgKiBgYXRgLCBgY29tcGFjdGAsIGBkcm9wYCwgYGRyb3BSaWdodGAsIGBkcm9wV2hpbGVgLCBgZmlsdGVyYCwgYGZpbmRgLFxyXG4gICAgICogYGZpbmRMYXN0YCwgYGhlYWRgLCBgaW5pdGlhbGAsIGBsYXN0YCwgYG1hcGAsIGByZWplY3RgLCBgcmV2ZXJzZWAsIGBzbGljZWAsXHJcbiAgICAgKiBgdGFpbGAsIGB0YWtlYCwgYHRha2VSaWdodGAsIGB0YWtlUmlnaHRXaGlsZWAsIGB0YWtlV2hpbGVgLCBhbmQgYHRvQXJyYXlgXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGNoYWluYWJsZSB3cmFwcGVyIG1ldGhvZHMgYXJlOlxyXG4gICAgICogYGFmdGVyYCwgYGFyeWAsIGBhc3NpZ25gLCBgYXNzaWduSW5gLCBgYXNzaWduSW5XaXRoYCwgYGFzc2lnbldpdGhgLCBgYXRgLFxyXG4gICAgICogYGJlZm9yZWAsIGBiaW5kYCwgYGJpbmRBbGxgLCBgYmluZEtleWAsIGBjYXN0QXJyYXlgLCBgY2hhaW5gLCBgY2h1bmtgLFxyXG4gICAgICogYGNvbW1pdGAsIGBjb21wYWN0YCwgYGNvbmNhdGAsIGBjb25mb3Jtc2AsIGBjb25zdGFudGAsIGBjb3VudEJ5YCwgYGNyZWF0ZWAsXHJcbiAgICAgKiBgY3VycnlgLCBgZGVib3VuY2VgLCBgZGVmYXVsdHNgLCBgZGVmYXVsdHNEZWVwYCwgYGRlZmVyYCwgYGRlbGF5YCxcclxuICAgICAqIGBkaWZmZXJlbmNlYCwgYGRpZmZlcmVuY2VCeWAsIGBkaWZmZXJlbmNlV2l0aGAsIGBkcm9wYCwgYGRyb3BSaWdodGAsXHJcbiAgICAgKiBgZHJvcFJpZ2h0V2hpbGVgLCBgZHJvcFdoaWxlYCwgYGV4dGVuZGAsIGBleHRlbmRXaXRoYCwgYGZpbGxgLCBgZmlsdGVyYCxcclxuICAgICAqIGBmbGF0TWFwYCwgYGZsYXRNYXBEZWVwYCwgYGZsYXRNYXBEZXB0aGAsIGBmbGF0dGVuYCwgYGZsYXR0ZW5EZWVwYCxcclxuICAgICAqIGBmbGF0dGVuRGVwdGhgLCBgZmxpcGAsIGBmbG93YCwgYGZsb3dSaWdodGAsIGBmcm9tUGFpcnNgLCBgZnVuY3Rpb25zYCxcclxuICAgICAqIGBmdW5jdGlvbnNJbmAsIGBncm91cEJ5YCwgYGluaXRpYWxgLCBgaW50ZXJzZWN0aW9uYCwgYGludGVyc2VjdGlvbkJ5YCxcclxuICAgICAqIGBpbnRlcnNlY3Rpb25XaXRoYCwgYGludmVydGAsIGBpbnZlcnRCeWAsIGBpbnZva2VNYXBgLCBgaXRlcmF0ZWVgLCBga2V5QnlgLFxyXG4gICAgICogYGtleXNgLCBga2V5c0luYCwgYG1hcGAsIGBtYXBLZXlzYCwgYG1hcFZhbHVlc2AsIGBtYXRjaGVzYCwgYG1hdGNoZXNQcm9wZXJ0eWAsXHJcbiAgICAgKiBgbWVtb2l6ZWAsIGBtZXJnZWAsIGBtZXJnZVdpdGhgLCBgbWV0aG9kYCwgYG1ldGhvZE9mYCwgYG1peGluYCwgYG5lZ2F0ZWAsXHJcbiAgICAgKiBgbnRoQXJnYCwgYG9taXRgLCBgb21pdEJ5YCwgYG9uY2VgLCBgb3JkZXJCeWAsIGBvdmVyYCwgYG92ZXJBcmdzYCxcclxuICAgICAqIGBvdmVyRXZlcnlgLCBgb3ZlclNvbWVgLCBgcGFydGlhbGAsIGBwYXJ0aWFsUmlnaHRgLCBgcGFydGl0aW9uYCwgYHBpY2tgLFxyXG4gICAgICogYHBpY2tCeWAsIGBwbGFudGAsIGBwcm9wZXJ0eWAsIGBwcm9wZXJ0eU9mYCwgYHB1bGxgLCBgcHVsbEFsbGAsIGBwdWxsQWxsQnlgLFxyXG4gICAgICogYHB1bGxBbGxXaXRoYCwgYHB1bGxBdGAsIGBwdXNoYCwgYHJhbmdlYCwgYHJhbmdlUmlnaHRgLCBgcmVhcmdgLCBgcmVqZWN0YCxcclxuICAgICAqIGByZW1vdmVgLCBgcmVzdGAsIGByZXZlcnNlYCwgYHNhbXBsZVNpemVgLCBgc2V0YCwgYHNldFdpdGhgLCBgc2h1ZmZsZWAsXHJcbiAgICAgKiBgc2xpY2VgLCBgc29ydGAsIGBzb3J0QnlgLCBgc3BsaWNlYCwgYHNwcmVhZGAsIGB0YWlsYCwgYHRha2VgLCBgdGFrZVJpZ2h0YCxcclxuICAgICAqIGB0YWtlUmlnaHRXaGlsZWAsIGB0YWtlV2hpbGVgLCBgdGFwYCwgYHRocm90dGxlYCwgYHRocnVgLCBgdG9BcnJheWAsXHJcbiAgICAgKiBgdG9QYWlyc2AsIGB0b1BhaXJzSW5gLCBgdG9QYXRoYCwgYHRvUGxhaW5PYmplY3RgLCBgdHJhbnNmb3JtYCwgYHVuYXJ5YCxcclxuICAgICAqIGB1bmlvbmAsIGB1bmlvbkJ5YCwgYHVuaW9uV2l0aGAsIGB1bmlxYCwgYHVuaXFCeWAsIGB1bmlxV2l0aGAsIGB1bnNldGAsXHJcbiAgICAgKiBgdW5zaGlmdGAsIGB1bnppcGAsIGB1bnppcFdpdGhgLCBgdXBkYXRlYCwgYHVwZGF0ZVdpdGhgLCBgdmFsdWVzYCxcclxuICAgICAqIGB2YWx1ZXNJbmAsIGB3aXRob3V0YCwgYHdyYXBgLCBgeG9yYCwgYHhvckJ5YCwgYHhvcldpdGhgLCBgemlwYCxcclxuICAgICAqIGB6aXBPYmplY3RgLCBgemlwT2JqZWN0RGVlcGAsIGFuZCBgemlwV2l0aGBcclxuICAgICAqXHJcbiAgICAgKiBUaGUgd3JhcHBlciBtZXRob2RzIHRoYXQgYXJlICoqbm90KiogY2hhaW5hYmxlIGJ5IGRlZmF1bHQgYXJlOlxyXG4gICAgICogYGFkZGAsIGBhdHRlbXB0YCwgYGNhbWVsQ2FzZWAsIGBjYXBpdGFsaXplYCwgYGNlaWxgLCBgY2xhbXBgLCBgY2xvbmVgLFxyXG4gICAgICogYGNsb25lRGVlcGAsIGBjbG9uZURlZXBXaXRoYCwgYGNsb25lV2l0aGAsIGBjb25mb3Jtc1RvYCwgYGRlYnVycmAsXHJcbiAgICAgKiBgZGVmYXVsdFRvYCwgYGRpdmlkZWAsIGBlYWNoYCwgYGVhY2hSaWdodGAsIGBlbmRzV2l0aGAsIGBlcWAsIGBlc2NhcGVgLFxyXG4gICAgICogYGVzY2FwZVJlZ0V4cGAsIGBldmVyeWAsIGBmaW5kYCwgYGZpbmRJbmRleGAsIGBmaW5kS2V5YCwgYGZpbmRMYXN0YCxcclxuICAgICAqIGBmaW5kTGFzdEluZGV4YCwgYGZpbmRMYXN0S2V5YCwgYGZpcnN0YCwgYGZsb29yYCwgYGZvckVhY2hgLCBgZm9yRWFjaFJpZ2h0YCxcclxuICAgICAqIGBmb3JJbmAsIGBmb3JJblJpZ2h0YCwgYGZvck93bmAsIGBmb3JPd25SaWdodGAsIGBnZXRgLCBgZ3RgLCBgZ3RlYCwgYGhhc2AsXHJcbiAgICAgKiBgaGFzSW5gLCBgaGVhZGAsIGBpZGVudGl0eWAsIGBpbmNsdWRlc2AsIGBpbmRleE9mYCwgYGluUmFuZ2VgLCBgaW52b2tlYCxcclxuICAgICAqIGBpc0FyZ3VtZW50c2AsIGBpc0FycmF5YCwgYGlzQXJyYXlCdWZmZXJgLCBgaXNBcnJheUxpa2VgLCBgaXNBcnJheUxpa2VPYmplY3RgLFxyXG4gICAgICogYGlzQm9vbGVhbmAsIGBpc0J1ZmZlcmAsIGBpc0RhdGVgLCBgaXNFbGVtZW50YCwgYGlzRW1wdHlgLCBgaXNFcXVhbGAsXHJcbiAgICAgKiBgaXNFcXVhbFdpdGhgLCBgaXNFcnJvcmAsIGBpc0Zpbml0ZWAsIGBpc0Z1bmN0aW9uYCwgYGlzSW50ZWdlcmAsIGBpc0xlbmd0aGAsXHJcbiAgICAgKiBgaXNNYXBgLCBgaXNNYXRjaGAsIGBpc01hdGNoV2l0aGAsIGBpc05hTmAsIGBpc05hdGl2ZWAsIGBpc05pbGAsIGBpc051bGxgLFxyXG4gICAgICogYGlzTnVtYmVyYCwgYGlzT2JqZWN0YCwgYGlzT2JqZWN0TGlrZWAsIGBpc1BsYWluT2JqZWN0YCwgYGlzUmVnRXhwYCxcclxuICAgICAqIGBpc1NhZmVJbnRlZ2VyYCwgYGlzU2V0YCwgYGlzU3RyaW5nYCwgYGlzVW5kZWZpbmVkYCwgYGlzVHlwZWRBcnJheWAsXHJcbiAgICAgKiBgaXNXZWFrTWFwYCwgYGlzV2Vha1NldGAsIGBqb2luYCwgYGtlYmFiQ2FzZWAsIGBsYXN0YCwgYGxhc3RJbmRleE9mYCxcclxuICAgICAqIGBsb3dlckNhc2VgLCBgbG93ZXJGaXJzdGAsIGBsdGAsIGBsdGVgLCBgbWF4YCwgYG1heEJ5YCwgYG1lYW5gLCBgbWVhbkJ5YCxcclxuICAgICAqIGBtaW5gLCBgbWluQnlgLCBgbXVsdGlwbHlgLCBgbm9Db25mbGljdGAsIGBub29wYCwgYG5vd2AsIGBudGhgLCBgcGFkYCxcclxuICAgICAqIGBwYWRFbmRgLCBgcGFkU3RhcnRgLCBgcGFyc2VJbnRgLCBgcG9wYCwgYHJhbmRvbWAsIGByZWR1Y2VgLCBgcmVkdWNlUmlnaHRgLFxyXG4gICAgICogYHJlcGVhdGAsIGByZXN1bHRgLCBgcm91bmRgLCBgcnVuSW5Db250ZXh0YCwgYHNhbXBsZWAsIGBzaGlmdGAsIGBzaXplYCxcclxuICAgICAqIGBzbmFrZUNhc2VgLCBgc29tZWAsIGBzb3J0ZWRJbmRleGAsIGBzb3J0ZWRJbmRleEJ5YCwgYHNvcnRlZExhc3RJbmRleGAsXHJcbiAgICAgKiBgc29ydGVkTGFzdEluZGV4QnlgLCBgc3RhcnRDYXNlYCwgYHN0YXJ0c1dpdGhgLCBgc3R1YkFycmF5YCwgYHN0dWJGYWxzZWAsXHJcbiAgICAgKiBgc3R1Yk9iamVjdGAsIGBzdHViU3RyaW5nYCwgYHN0dWJUcnVlYCwgYHN1YnRyYWN0YCwgYHN1bWAsIGBzdW1CeWAsXHJcbiAgICAgKiBgdGVtcGxhdGVgLCBgdGltZXNgLCBgdG9GaW5pdGVgLCBgdG9JbnRlZ2VyYCwgYHRvSlNPTmAsIGB0b0xlbmd0aGAsXHJcbiAgICAgKiBgdG9Mb3dlcmAsIGB0b051bWJlcmAsIGB0b1NhZmVJbnRlZ2VyYCwgYHRvU3RyaW5nYCwgYHRvVXBwZXJgLCBgdHJpbWAsXHJcbiAgICAgKiBgdHJpbUVuZGAsIGB0cmltU3RhcnRgLCBgdHJ1bmNhdGVgLCBgdW5lc2NhcGVgLCBgdW5pcXVlSWRgLCBgdXBwZXJDYXNlYCxcclxuICAgICAqIGB1cHBlckZpcnN0YCwgYHZhbHVlYCwgYW5kIGB3b3Jkc2BcclxuICAgICAqXHJcbiAgICAgKiBAbmFtZSBfXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBjYXRlZ29yeSBTZXFcclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAgaW4gYSBgbG9kYXNoYCBpbnN0YW5jZS5cclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xyXG4gICAgICogICByZXR1cm4gbiAqIG47XHJcbiAgICAgKiB9XHJcbiAgICAgKlxyXG4gICAgICogdmFyIHdyYXBwZWQgPSBfKFsxLCAyLCAzXSk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gUmV0dXJucyBhbiB1bndyYXBwZWQgdmFsdWUuXHJcbiAgICAgKiB3cmFwcGVkLnJlZHVjZShfLmFkZCk7XHJcbiAgICAgKiAvLyA9PiA2XHJcbiAgICAgKlxyXG4gICAgICogLy8gUmV0dXJucyBhIHdyYXBwZWQgdmFsdWUuXHJcbiAgICAgKiB2YXIgc3F1YXJlcyA9IHdyYXBwZWQubWFwKHNxdWFyZSk7XHJcbiAgICAgKlxyXG4gICAgICogXy5pc0FycmF5KHNxdWFyZXMpO1xyXG4gICAgICogLy8gPT4gZmFsc2VcclxuICAgICAqXHJcbiAgICAgKiBfLmlzQXJyYXkoc3F1YXJlcy52YWx1ZSgpKTtcclxuICAgICAqIC8vID0+IHRydWVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gbG9kYXNoKHZhbHVlKSB7XHJcbiAgICAgIGlmIChpc09iamVjdExpa2UodmFsdWUpICYmICFpc0FycmF5KHZhbHVlKSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTG9kYXNoV3JhcHBlcikge1xyXG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ19fd3JhcHBlZF9fJykpIHtcclxuICAgICAgICAgIHJldHVybiB3cmFwcGVyQ2xvbmUodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIodmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xyXG4gICAgICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90byBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIHZhciBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xyXG4gICAgICBmdW5jdGlvbiBvYmplY3QoKSB7fVxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24ocHJvdG8pIHtcclxuICAgICAgICBpZiAoIWlzT2JqZWN0KHByb3RvKSkge1xyXG4gICAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob2JqZWN0Q3JlYXRlKSB7XHJcbiAgICAgICAgICByZXR1cm4gb2JqZWN0Q3JlYXRlKHByb3RvKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgb2JqZWN0LnByb3RvdHlwZSA9IHByb3RvO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgb2JqZWN0O1xyXG4gICAgICAgIG9iamVjdC5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfTtcclxuICAgIH0oKSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZnVuY3Rpb24gd2hvc2UgcHJvdG90eXBlIGNoYWluIHNlcXVlbmNlIHdyYXBwZXJzIGluaGVyaXQgZnJvbS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBiYXNlTG9kYXNoKCkge1xyXG4gICAgICAvLyBObyBvcGVyYXRpb24gcGVyZm9ybWVkLlxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGJhc2UgY29uc3RydWN0b3IgZm9yIGNyZWF0aW5nIGBsb2Rhc2hgIHdyYXBwZXIgb2JqZWN0cy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NoYWluQWxsXSBFbmFibGUgZXhwbGljaXQgbWV0aG9kIGNoYWluIHNlcXVlbmNlcy5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gTG9kYXNoV3JhcHBlcih2YWx1ZSwgY2hhaW5BbGwpIHtcclxuICAgICAgdGhpcy5fX3dyYXBwZWRfXyA9IHZhbHVlO1xyXG4gICAgICB0aGlzLl9fYWN0aW9uc19fID0gW107XHJcbiAgICAgIHRoaXMuX19jaGFpbl9fID0gISFjaGFpbkFsbDtcclxuICAgICAgdGhpcy5fX2luZGV4X18gPSAwO1xyXG4gICAgICB0aGlzLl9fdmFsdWVzX18gPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCeSBkZWZhdWx0LCB0aGUgdGVtcGxhdGUgZGVsaW1pdGVycyB1c2VkIGJ5IGxvZGFzaCBhcmUgbGlrZSB0aG9zZSBpblxyXG4gICAgICogZW1iZWRkZWQgUnVieSAoRVJCKSBhcyB3ZWxsIGFzIEVTMjAxNSB0ZW1wbGF0ZSBzdHJpbmdzLiBDaGFuZ2UgdGhlXHJcbiAgICAgKiBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKi9cclxuICAgIGxvZGFzaC50ZW1wbGF0ZVNldHRpbmdzID0ge1xyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gYmUgSFRNTC1lc2NhcGVkLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXHJcbiAgICAgICAqIEB0eXBlIHtSZWdFeHB9XHJcbiAgICAgICAqL1xyXG4gICAgICAnZXNjYXBlJzogcmVFc2NhcGUsXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogVXNlZCB0byBkZXRlY3QgY29kZSB0byBiZSBldmFsdWF0ZWQuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcclxuICAgICAgICogQHR5cGUge1JlZ0V4cH1cclxuICAgICAgICovXHJcbiAgICAgICdldmFsdWF0ZSc6IHJlRXZhbHVhdGUsXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogVXNlZCB0byBkZXRlY3QgYGRhdGFgIHByb3BlcnR5IHZhbHVlcyB0byBpbmplY3QuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcclxuICAgICAgICogQHR5cGUge1JlZ0V4cH1cclxuICAgICAgICovXHJcbiAgICAgICdpbnRlcnBvbGF0ZSc6IHJlSW50ZXJwb2xhdGUsXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogVXNlZCB0byByZWZlcmVuY2UgdGhlIGRhdGEgb2JqZWN0IGluIHRoZSB0ZW1wbGF0ZSB0ZXh0LlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXHJcbiAgICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgICAqL1xyXG4gICAgICAndmFyaWFibGUnOiAnJyxcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBVc2VkIHRvIGltcG9ydCB2YXJpYWJsZXMgaW50byB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcclxuICAgICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAgICovXHJcbiAgICAgICdpbXBvcnRzJzoge1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHNcclxuICAgICAgICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgJ18nOiBsb2Rhc2hcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBFbnN1cmUgd3JhcHBlcnMgYXJlIGluc3RhbmNlcyBvZiBgYmFzZUxvZGFzaGAuXHJcbiAgICBsb2Rhc2gucHJvdG90eXBlID0gYmFzZUxvZGFzaC5wcm90b3R5cGU7XHJcbiAgICBsb2Rhc2gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbG9kYXNoO1xyXG5cclxuICAgIExvZGFzaFdyYXBwZXIucHJvdG90eXBlID0gYmFzZUNyZWF0ZShiYXNlTG9kYXNoLnByb3RvdHlwZSk7XHJcbiAgICBMb2Rhc2hXcmFwcGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExvZGFzaFdyYXBwZXI7XHJcblxyXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGxhenkgd3JhcHBlciBvYmplY3Qgd2hpY2ggd3JhcHMgYHZhbHVlYCB0byBlbmFibGUgbGF6eSBldmFsdWF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIExhenlXcmFwcGVyKHZhbHVlKSB7XHJcbiAgICAgIHRoaXMuX193cmFwcGVkX18gPSB2YWx1ZTtcclxuICAgICAgdGhpcy5fX2FjdGlvbnNfXyA9IFtdO1xyXG4gICAgICB0aGlzLl9fZGlyX18gPSAxO1xyXG4gICAgICB0aGlzLl9fZmlsdGVyZWRfXyA9IGZhbHNlO1xyXG4gICAgICB0aGlzLl9faXRlcmF0ZWVzX18gPSBbXTtcclxuICAgICAgdGhpcy5fX3Rha2VDb3VudF9fID0gTUFYX0FSUkFZX0xFTkdUSDtcclxuICAgICAgdGhpcy5fX3ZpZXdzX18gPSBbXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgbGF6eSB3cmFwcGVyIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG5hbWUgY2xvbmVcclxuICAgICAqIEBtZW1iZXJPZiBMYXp5V3JhcHBlclxyXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIGBMYXp5V3JhcHBlcmAgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBsYXp5Q2xvbmUoKSB7XHJcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgTGF6eVdyYXBwZXIodGhpcy5fX3dyYXBwZWRfXyk7XHJcbiAgICAgIHJlc3VsdC5fX2FjdGlvbnNfXyA9IGNvcHlBcnJheSh0aGlzLl9fYWN0aW9uc19fKTtcclxuICAgICAgcmVzdWx0Ll9fZGlyX18gPSB0aGlzLl9fZGlyX187XHJcbiAgICAgIHJlc3VsdC5fX2ZpbHRlcmVkX18gPSB0aGlzLl9fZmlsdGVyZWRfXztcclxuICAgICAgcmVzdWx0Ll9faXRlcmF0ZWVzX18gPSBjb3B5QXJyYXkodGhpcy5fX2l0ZXJhdGVlc19fKTtcclxuICAgICAgcmVzdWx0Ll9fdGFrZUNvdW50X18gPSB0aGlzLl9fdGFrZUNvdW50X187XHJcbiAgICAgIHJlc3VsdC5fX3ZpZXdzX18gPSBjb3B5QXJyYXkodGhpcy5fX3ZpZXdzX18pO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV2ZXJzZXMgdGhlIGRpcmVjdGlvbiBvZiBsYXp5IGl0ZXJhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG5hbWUgcmV2ZXJzZVxyXG4gICAgICogQG1lbWJlck9mIExhenlXcmFwcGVyXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgcmV2ZXJzZWQgYExhenlXcmFwcGVyYCBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGxhenlSZXZlcnNlKCkge1xyXG4gICAgICBpZiAodGhpcy5fX2ZpbHRlcmVkX18pIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IExhenlXcmFwcGVyKHRoaXMpO1xyXG4gICAgICAgIHJlc3VsdC5fX2Rpcl9fID0gLTE7XHJcbiAgICAgICAgcmVzdWx0Ll9fZmlsdGVyZWRfXyA9IHRydWU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5jbG9uZSgpO1xyXG4gICAgICAgIHJlc3VsdC5fX2Rpcl9fICo9IC0xO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFeHRyYWN0cyB0aGUgdW53cmFwcGVkIHZhbHVlIGZyb20gaXRzIGxhenkgd3JhcHBlci5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG5hbWUgdmFsdWVcclxuICAgICAqIEBtZW1iZXJPZiBMYXp5V3JhcHBlclxyXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHVud3JhcHBlZCB2YWx1ZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gbGF6eVZhbHVlKCkge1xyXG4gICAgICB2YXIgYXJyYXkgPSB0aGlzLl9fd3JhcHBlZF9fLnZhbHVlKCksXHJcbiAgICAgICAgICBkaXIgPSB0aGlzLl9fZGlyX18sXHJcbiAgICAgICAgICBpc0FyciA9IGlzQXJyYXkoYXJyYXkpLFxyXG4gICAgICAgICAgaXNSaWdodCA9IGRpciA8IDAsXHJcbiAgICAgICAgICBhcnJMZW5ndGggPSBpc0FyciA/IGFycmF5Lmxlbmd0aCA6IDAsXHJcbiAgICAgICAgICB2aWV3ID0gZ2V0VmlldygwLCBhcnJMZW5ndGgsIHRoaXMuX192aWV3c19fKSxcclxuICAgICAgICAgIHN0YXJ0ID0gdmlldy5zdGFydCxcclxuICAgICAgICAgIGVuZCA9IHZpZXcuZW5kLFxyXG4gICAgICAgICAgbGVuZ3RoID0gZW5kIC0gc3RhcnQsXHJcbiAgICAgICAgICBpbmRleCA9IGlzUmlnaHQgPyBlbmQgOiAoc3RhcnQgLSAxKSxcclxuICAgICAgICAgIGl0ZXJhdGVlcyA9IHRoaXMuX19pdGVyYXRlZXNfXyxcclxuICAgICAgICAgIGl0ZXJMZW5ndGggPSBpdGVyYXRlZXMubGVuZ3RoLFxyXG4gICAgICAgICAgcmVzSW5kZXggPSAwLFxyXG4gICAgICAgICAgdGFrZUNvdW50ID0gbmF0aXZlTWluKGxlbmd0aCwgdGhpcy5fX3Rha2VDb3VudF9fKTtcclxuXHJcbiAgICAgIGlmICghaXNBcnIgfHwgKCFpc1JpZ2h0ICYmIGFyckxlbmd0aCA9PSBsZW5ndGggJiYgdGFrZUNvdW50ID09IGxlbmd0aCkpIHtcclxuICAgICAgICByZXR1cm4gYmFzZVdyYXBwZXJWYWx1ZShhcnJheSwgdGhpcy5fX2FjdGlvbnNfXyk7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xyXG5cclxuICAgICAgb3V0ZXI6XHJcbiAgICAgIHdoaWxlIChsZW5ndGgtLSAmJiByZXNJbmRleCA8IHRha2VDb3VudCkge1xyXG4gICAgICAgIGluZGV4ICs9IGRpcjtcclxuXHJcbiAgICAgICAgdmFyIGl0ZXJJbmRleCA9IC0xLFxyXG4gICAgICAgICAgICB2YWx1ZSA9IGFycmF5W2luZGV4XTtcclxuXHJcbiAgICAgICAgd2hpbGUgKCsraXRlckluZGV4IDwgaXRlckxlbmd0aCkge1xyXG4gICAgICAgICAgdmFyIGRhdGEgPSBpdGVyYXRlZXNbaXRlckluZGV4XSxcclxuICAgICAgICAgICAgICBpdGVyYXRlZSA9IGRhdGEuaXRlcmF0ZWUsXHJcbiAgICAgICAgICAgICAgdHlwZSA9IGRhdGEudHlwZSxcclxuICAgICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKHZhbHVlKTtcclxuXHJcbiAgICAgICAgICBpZiAodHlwZSA9PSBMQVpZX01BUF9GTEFHKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gY29tcHV0ZWQ7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKCFjb21wdXRlZCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZSA9PSBMQVpZX0ZJTFRFUl9GTEFHKSB7XHJcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgYnJlYWsgb3V0ZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBFbnN1cmUgYExhenlXcmFwcGVyYCBpcyBhbiBpbnN0YW5jZSBvZiBgYmFzZUxvZGFzaGAuXHJcbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUgPSBiYXNlQ3JlYXRlKGJhc2VMb2Rhc2gucHJvdG90eXBlKTtcclxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExhenlXcmFwcGVyO1xyXG5cclxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XHJcbiAgICAgIHZhciBpbmRleCA9IC0xLFxyXG4gICAgICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xyXG5cclxuICAgICAgdGhpcy5jbGVhcigpO1xyXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xyXG4gICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xyXG4gICAgICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBuYW1lIGNsZWFyXHJcbiAgICAgKiBAbWVtYmVyT2YgSGFzaFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XHJcbiAgICAgIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcclxuICAgICAgdGhpcy5zaXplID0gMDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbmFtZSBkZWxldGVcclxuICAgICAqIEBtZW1iZXJPZiBIYXNoXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcclxuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcclxuICAgICAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBuYW1lIGdldFxyXG4gICAgICogQG1lbWJlck9mIEhhc2hcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxyXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBoYXNoR2V0KGtleSkge1xyXG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XHJcbiAgICAgIGlmIChuYXRpdmVDcmVhdGUpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBuYW1lIGhhc1xyXG4gICAgICogQG1lbWJlck9mIEhhc2hcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBoYXNoSGFzKGtleSkge1xyXG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XHJcbiAgICAgIHJldHVybiBuYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbmFtZSBzZXRcclxuICAgICAqIEBtZW1iZXJPZiBIYXNoXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xyXG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XHJcbiAgICAgIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XHJcbiAgICAgIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXHJcbiAgICBIYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcclxuICAgIEhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XHJcbiAgICBIYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xyXG4gICAgSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcclxuICAgIEhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XHJcblxyXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcclxuICAgICAgdmFyIGluZGV4ID0gLTEsXHJcbiAgICAgICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XHJcblxyXG4gICAgICB0aGlzLmNsZWFyKCk7XHJcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XHJcbiAgICAgICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG5hbWUgY2xlYXJcclxuICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XHJcbiAgICAgIHRoaXMuX19kYXRhX18gPSBbXTtcclxuICAgICAgdGhpcy5zaXplID0gMDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbmFtZSBkZWxldGVcclxuICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XHJcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcclxuICAgICAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XHJcblxyXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XHJcbiAgICAgIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcclxuICAgICAgICBkYXRhLnBvcCgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcclxuICAgICAgfVxyXG4gICAgICAtLXRoaXMuc2l6ZTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG5hbWUgZ2V0XHJcbiAgICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cclxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xyXG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXHJcbiAgICAgICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xyXG5cclxuICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbmFtZSBoYXNcclxuICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XHJcbiAgICAgIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbmFtZSBzZXRcclxuICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxyXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcclxuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxyXG4gICAgICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcclxuXHJcbiAgICAgIGlmIChpbmRleCA8IDApIHtcclxuICAgICAgICArK3RoaXMuc2l6ZTtcclxuICAgICAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxyXG4gICAgTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xyXG4gICAgTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XHJcbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcclxuICAgIExpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xyXG4gICAgTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XHJcblxyXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XHJcbiAgICAgIHZhciBpbmRleCA9IC0xLFxyXG4gICAgICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xyXG5cclxuICAgICAgdGhpcy5jbGVhcigpO1xyXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xyXG4gICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xyXG4gICAgICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG5hbWUgY2xlYXJcclxuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xyXG4gICAgICB0aGlzLnNpemUgPSAwO1xyXG4gICAgICB0aGlzLl9fZGF0YV9fID0ge1xyXG4gICAgICAgICdoYXNoJzogbmV3IEhhc2gsXHJcbiAgICAgICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXHJcbiAgICAgICAgJ3N0cmluZyc6IG5ldyBIYXNoXHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbmFtZSBkZWxldGVcclxuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xyXG4gICAgICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xyXG4gICAgICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbmFtZSBnZXRcclxuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXHJcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xyXG4gICAgICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBuYW1lIGhhc1xyXG4gICAgICogQG1lbWJlck9mIE1hcENhY2hlXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XHJcbiAgICAgIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG5hbWUgc2V0XHJcbiAgICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxyXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XHJcbiAgICAgIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxyXG4gICAgICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcclxuXHJcbiAgICAgIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xyXG4gICAgICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cclxuICAgIE1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XHJcbiAgICBNYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XHJcbiAgICBNYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XHJcbiAgICBNYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XHJcbiAgICBNYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XHJcblxyXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XHJcbiAgICAgIHZhciBpbmRleCA9IC0xLFxyXG4gICAgICAgICAgbGVuZ3RoID0gdmFsdWVzID09IG51bGwgPyAwIDogdmFsdWVzLmxlbmd0aDtcclxuXHJcbiAgICAgIHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGU7XHJcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYHZhbHVlYCB0byB0aGUgYXJyYXkgY2FjaGUuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBuYW1lIGFkZFxyXG4gICAgICogQG1lbWJlck9mIFNldENhY2hlXHJcbiAgICAgKiBAYWxpYXMgcHVzaFxyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gc2V0Q2FjaGVBZGQodmFsdWUpIHtcclxuICAgICAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiB0aGUgYXJyYXkgY2FjaGUuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBuYW1lIGhhc1xyXG4gICAgICogQG1lbWJlck9mIFNldENhY2hlXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBzZXRDYWNoZUhhcyh2YWx1ZSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXModmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBTZXRDYWNoZWAuXHJcbiAgICBTZXRDYWNoZS5wcm90b3R5cGUuYWRkID0gU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBzZXRDYWNoZUFkZDtcclxuICAgIFNldENhY2hlLnByb3RvdHlwZS5oYXMgPSBzZXRDYWNoZUhhcztcclxuXHJcbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xyXG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xyXG4gICAgICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG5hbWUgY2xlYXJcclxuICAgICAqIEBtZW1iZXJPZiBTdGFja1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBzdGFja0NsZWFyKCkge1xyXG4gICAgICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcclxuICAgICAgdGhpcy5zaXplID0gMDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG5hbWUgZGVsZXRlXHJcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcclxuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxyXG4gICAgICAgICAgcmVzdWx0ID0gZGF0YVsnZGVsZXRlJ10oa2V5KTtcclxuXHJcbiAgICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG5hbWUgZ2V0XHJcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxyXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBzdGFja0dldChrZXkpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbmFtZSBoYXNcclxuICAgICAqIEBtZW1iZXJPZiBTdGFja1xyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBuYW1lIHNldFxyXG4gICAgICogQG1lbWJlck9mIFN0YWNrXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XHJcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcclxuICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcclxuICAgICAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xyXG4gICAgICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcclxuICAgICAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcclxuICAgICAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcclxuICAgICAgfVxyXG4gICAgICBkYXRhLnNldChrZXksIHZhbHVlKTtcclxuICAgICAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxyXG4gICAgU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcclxuICAgIFN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcclxuICAgIFN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcclxuICAgIFN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcclxuICAgIFN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcclxuXHJcbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XHJcbiAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxyXG4gICAgICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxyXG4gICAgICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXHJcbiAgICAgICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcclxuICAgICAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcclxuICAgICAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxyXG4gICAgICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcclxuXHJcbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xyXG4gICAgICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXHJcbiAgICAgICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxyXG4gICAgICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXHJcbiAgICAgICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxyXG4gICAgICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cclxuICAgICAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XHJcbiAgICAgICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cclxuICAgICAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XHJcbiAgICAgICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cclxuICAgICAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcclxuICAgICAgICAgICAgKSkpIHtcclxuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc2FtcGxlYCBmb3IgYXJyYXlzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2FtcGxlLlxyXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBhcnJheVNhbXBsZShhcnJheSkge1xyXG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xyXG4gICAgICByZXR1cm4gbGVuZ3RoID8gYXJyYXlbYmFzZVJhbmRvbSgwLCBsZW5ndGggLSAxKV0gOiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc2FtcGxlU2l6ZWAgZm9yIGFycmF5cy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNhbXBsZS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gc2FtcGxlLlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudHMuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGFycmF5U2FtcGxlU2l6ZShhcnJheSwgbikge1xyXG4gICAgICByZXR1cm4gc2h1ZmZsZVNlbGYoY29weUFycmF5KGFycmF5KSwgYmFzZUNsYW1wKG4sIDAsIGFycmF5Lmxlbmd0aCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNodWZmbGVgIGZvciBhcnJheXMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzaHVmZmxlLlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGFycmF5U2h1ZmZsZShhcnJheSkge1xyXG4gICAgICByZXR1cm4gc2h1ZmZsZVNlbGYoY29weUFycmF5KGFycmF5KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFzc2lnblZhbHVlYCBleGNlcHQgdGhhdCBpdCBkb2Vzbid0IGFzc2lnblxyXG4gICAgICogYHVuZGVmaW5lZGAgdmFsdWVzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XHJcbiAgICAgIGlmICgodmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZXEob2JqZWN0W2tleV0sIHZhbHVlKSkgfHxcclxuICAgICAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XHJcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFzc2lnbnMgYHZhbHVlYCB0byBga2V5YCBvZiBgb2JqZWN0YCBpZiB0aGUgZXhpc3RpbmcgdmFsdWUgaXMgbm90IGVxdWl2YWxlbnRcclxuICAgICAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXHJcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XHJcbiAgICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xyXG4gICAgICBpZiAoIShoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBlcShvYmpWYWx1ZSwgdmFsdWUpKSB8fFxyXG4gICAgICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcclxuICAgICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cclxuICAgICAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XHJcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XHJcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xyXG4gICAgICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XHJcbiAgICAgICAgICByZXR1cm4gbGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZ2dyZWdhdGVzIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCBvbiBgYWNjdW11bGF0b3JgIHdpdGgga2V5cyB0cmFuc2Zvcm1lZFxyXG4gICAgICogYnkgYGl0ZXJhdGVlYCBhbmQgdmFsdWVzIHNldCBieSBgc2V0dGVyYC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYGFjY3VtdWxhdG9yYCB2YWx1ZXMuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgYWdncmVnYXRlZCBvYmplY3QuXHJcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGFjY3VtdWxhdG9yYC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYmFzZUFnZ3JlZ2F0b3IoY29sbGVjdGlvbiwgc2V0dGVyLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcclxuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xyXG4gICAgICAgIHNldHRlcihhY2N1bXVsYXRvciwgdmFsdWUsIGl0ZXJhdGVlKHZhbHVlKSwgY29sbGVjdGlvbik7XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xyXG4gICAgICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGJhc2VBc3NpZ24ob2JqZWN0LCBzb3VyY2UpIHtcclxuICAgICAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xyXG4gICAgICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGJhc2VBc3NpZ25JbihvYmplY3QsIHNvdXJjZSkge1xyXG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBhc3NpZ25WYWx1ZWAgYW5kIGBhc3NpZ25NZXJnZVZhbHVlYCB3aXRob3V0XHJcbiAgICAgKiB2YWx1ZSBjaGVja3MuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xyXG4gICAgICBpZiAoa2V5ID09ICdfX3Byb3RvX18nICYmIGRlZmluZVByb3BlcnR5KSB7XHJcbiAgICAgICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcclxuICAgICAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxyXG4gICAgICAgICAgJ2VudW1lcmFibGUnOiB0cnVlLFxyXG4gICAgICAgICAgJ3ZhbHVlJzogdmFsdWUsXHJcbiAgICAgICAgICAnd3JpdGFibGUnOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbCBwYXRocy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwaWNrZWQgZWxlbWVudHMuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGJhc2VBdChvYmplY3QsIHBhdGhzKSB7XHJcbiAgICAgIHZhciBpbmRleCA9IC0xLFxyXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aHMubGVuZ3RoLFxyXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKSxcclxuICAgICAgICAgIHNraXAgPSBvYmplY3QgPT0gbnVsbDtcclxuXHJcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IHNraXAgPyB1bmRlZmluZWQgOiBnZXQob2JqZWN0LCBwYXRoc1tpbmRleF0pO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbGFtcGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gY2xhbXAuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xvd2VyXSBUaGUgbG93ZXIgYm91bmQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVGhlIHVwcGVyIGJvdW5kLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY2xhbXBlZCBudW1iZXIuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGJhc2VDbGFtcChudW1iZXIsIGxvd2VyLCB1cHBlcikge1xyXG4gICAgICBpZiAobnVtYmVyID09PSBudW1iZXIpIHtcclxuICAgICAgICBpZiAodXBwZXIgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgbnVtYmVyID0gbnVtYmVyIDw9IHVwcGVyID8gbnVtYmVyIDogdXBwZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsb3dlciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICBudW1iZXIgPSBudW1iZXIgPj0gbG93ZXIgPyBudW1iZXIgOiBsb3dlcjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG51bWJlcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsb25lYCBhbmQgYF8uY2xvbmVEZWVwYCB3aGljaCB0cmFja3NcclxuICAgICAqIHRyYXZlcnNlZCBvYmplY3RzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cclxuICAgICAqICAxIC0gRGVlcCBjbG9uZVxyXG4gICAgICogIDIgLSBGbGF0dGVuIGluaGVyaXRlZCBwcm9wZXJ0aWVzXHJcbiAgICAgKiAgNCAtIENsb25lIHN5bWJvbHNcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gVGhlIGtleSBvZiBgdmFsdWVgLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGB2YWx1ZWAuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIG9iamVjdHMgYW5kIHRoZWlyIGNsb25lIGNvdW50ZXJwYXJ0cy5cclxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGJhc2VDbG9uZSh2YWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCBvYmplY3QsIHN0YWNrKSB7XHJcbiAgICAgIHZhciByZXN1bHQsXHJcbiAgICAgICAgICBpc0RlZXAgPSBiaXRtYXNrICYgQ0xPTkVfREVFUF9GTEFHLFxyXG4gICAgICAgICAgaXNGbGF0ID0gYml0bWFzayAmIENMT05FX0ZMQVRfRkxBRyxcclxuICAgICAgICAgIGlzRnVsbCA9IGJpdG1hc2sgJiBDTE9ORV9TWU1CT0xTX0ZMQUc7XHJcblxyXG4gICAgICBpZiAoY3VzdG9taXplcikge1xyXG4gICAgICAgIHJlc3VsdCA9IG9iamVjdCA/IGN1c3RvbWl6ZXIodmFsdWUsIGtleSwgb2JqZWN0LCBzdGFjaykgOiBjdXN0b21pemVyKHZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpO1xyXG4gICAgICBpZiAoaXNBcnIpIHtcclxuICAgICAgICByZXN1bHQgPSBpbml0Q2xvbmVBcnJheSh2YWx1ZSk7XHJcbiAgICAgICAgaWYgKCFpc0RlZXApIHtcclxuICAgICAgICAgIHJldHVybiBjb3B5QXJyYXkodmFsdWUsIHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpLFxyXG4gICAgICAgICAgICBpc0Z1bmMgPSB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnO1xyXG5cclxuICAgICAgICBpZiAoaXNCdWZmZXIodmFsdWUpKSB7XHJcbiAgICAgICAgICByZXR1cm4gY2xvbmVCdWZmZXIodmFsdWUsIGlzRGVlcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0YWcgPT0gb2JqZWN0VGFnIHx8IHRhZyA9PSBhcmdzVGFnIHx8IChpc0Z1bmMgJiYgIW9iamVjdCkpIHtcclxuICAgICAgICAgIHJlc3VsdCA9IChpc0ZsYXQgfHwgaXNGdW5jKSA/IHt9IDogaW5pdENsb25lT2JqZWN0KHZhbHVlKTtcclxuICAgICAgICAgIGlmICghaXNEZWVwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc0ZsYXRcclxuICAgICAgICAgICAgICA/IGNvcHlTeW1ib2xzSW4odmFsdWUsIGJhc2VBc3NpZ25JbihyZXN1bHQsIHZhbHVlKSlcclxuICAgICAgICAgICAgICA6IGNvcHlTeW1ib2xzKHZhbHVlLCBiYXNlQXNzaWduKHJlc3VsdCwgdmFsdWUpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaWYgKCFjbG9uZWFibGVUYWdzW3RhZ10pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdCA/IHZhbHVlIDoge307XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXN1bHQgPSBpbml0Q2xvbmVCeVRhZyh2YWx1ZSwgdGFnLCBpc0RlZXApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICAvLyBDaGVjayBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcyBhbmQgcmV0dXJuIGl0cyBjb3JyZXNwb25kaW5nIGNsb25lLlxyXG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xyXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldCh2YWx1ZSk7XHJcbiAgICAgIGlmIChzdGFja2VkKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQ7XHJcbiAgICAgIH1cclxuICAgICAgc3RhY2suc2V0KHZhbHVlLCByZXN1bHQpO1xyXG5cclxuICAgICAgaWYgKGlzU2V0KHZhbHVlKSkge1xyXG4gICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUpIHtcclxuICAgICAgICAgIHJlc3VsdC5hZGQoYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdWJWYWx1ZSwgdmFsdWUsIHN0YWNrKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoaXNNYXAodmFsdWUpKSB7XHJcbiAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XHJcbiAgICAgICAgICByZXN1bHQuc2V0KGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIga2V5c0Z1bmMgPSBpc0Z1bGxcclxuICAgICAgICA/IChpc0ZsYXQgPyBnZXRBbGxLZXlzSW4gOiBnZXRBbGxLZXlzKVxyXG4gICAgICAgIDogKGlzRmxhdCA/IGtleXNJbiA6IGtleXMpO1xyXG5cclxuICAgICAgdmFyIHByb3BzID0gaXNBcnIgPyB1bmRlZmluZWQgOiBrZXlzRnVuYyh2YWx1ZSk7XHJcbiAgICAgIGFycmF5RWFjaChwcm9wcyB8fCB2YWx1ZSwgZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xyXG4gICAgICAgIGlmIChwcm9wcykge1xyXG4gICAgICAgICAga2V5ID0gc3ViVmFsdWU7XHJcbiAgICAgICAgICBzdWJWYWx1ZSA9IHZhbHVlW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHBvcHVsYXRlIGNsb25lIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXHJcbiAgICAgICAgYXNzaWduVmFsdWUocmVzdWx0LCBrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jb25mb3Jtc2Agd2hpY2ggZG9lc24ndCBjbG9uZSBgc291cmNlYC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHByZWRpY2F0ZXMgdG8gY29uZm9ybSB0by5cclxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGJhc2VDb25mb3Jtcyhzb3VyY2UpIHtcclxuICAgICAgdmFyIHByb3BzID0ga2V5cyhzb3VyY2UpO1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XHJcbiAgICAgICAgcmV0dXJuIGJhc2VDb25mb3Jtc1RvKG9iamVjdCwgc291cmNlLCBwcm9wcyk7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jb25mb3Jtc1RvYCB3aGljaCBhY2NlcHRzIGBwcm9wc2AgdG8gY2hlY2suXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHByZWRpY2F0ZXMgdG8gY29uZm9ybSB0by5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBjb25mb3JtcywgZWxzZSBgZmFsc2VgLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBiYXNlQ29uZm9ybXNUbyhvYmplY3QsIHNvdXJjZSwgcHJvcHMpIHtcclxuICAgICAgdmFyIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcclxuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuICFsZW5ndGg7XHJcbiAgICAgIH1cclxuICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XHJcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xyXG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tsZW5ndGhdLFxyXG4gICAgICAgICAgICBwcmVkaWNhdGUgPSBzb3VyY2Vba2V5XSxcclxuICAgICAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcclxuXHJcbiAgICAgICAgaWYgKCh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpIHx8ICFwcmVkaWNhdGUodmFsdWUpKSB7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZGVsYXlgIGFuZCBgXy5kZWZlcmAgd2hpY2ggYWNjZXB0cyBgYXJnc2BcclxuICAgICAqIHRvIHByb3ZpZGUgdG8gYGZ1bmNgLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWxheS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGludm9jYXRpb24uXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gcHJvdmlkZSB0byBgZnVuY2AuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfE9iamVjdH0gUmV0dXJucyB0aGUgdGltZXIgaWQgb3IgdGltZW91dCBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGJhc2VEZWxheShmdW5jLCB3YWl0LCBhcmdzKSB7XHJcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7IH0sIHdhaXQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLmRpZmZlcmVuY2VgIHdpdGhvdXQgc3VwcG9ydFxyXG4gICAgICogZm9yIGV4Y2x1ZGluZyBtdWx0aXBsZSBhcnJheXMgb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBleGNsdWRlLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBiYXNlRGlmZmVyZW5jZShhcnJheSwgdmFsdWVzLCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xyXG4gICAgICB2YXIgaW5kZXggPSAtMSxcclxuICAgICAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlcyxcclxuICAgICAgICAgIGlzQ29tbW9uID0gdHJ1ZSxcclxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcclxuICAgICAgICAgIHJlc3VsdCA9IFtdLFxyXG4gICAgICAgICAgdmFsdWVzTGVuZ3RoID0gdmFsdWVzLmxlbmd0aDtcclxuXHJcbiAgICAgIGlmICghbGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfVxyXG4gICAgICBpZiAoaXRlcmF0ZWUpIHtcclxuICAgICAgICB2YWx1ZXMgPSBhcnJheU1hcCh2YWx1ZXMsIGJhc2VVbmFyeShpdGVyYXRlZSkpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChjb21wYXJhdG9yKSB7XHJcbiAgICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzV2l0aDtcclxuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKHZhbHVlcy5sZW5ndGggPj0gTEFSR0VfQVJSQVlfU0laRSkge1xyXG4gICAgICAgIGluY2x1ZGVzID0gY2FjaGVIYXM7XHJcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcclxuICAgICAgICB2YWx1ZXMgPSBuZXcgU2V0Q2FjaGUodmFsdWVzKTtcclxuICAgICAgfVxyXG4gICAgICBvdXRlcjpcclxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXHJcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPT0gbnVsbCA/IHZhbHVlIDogaXRlcmF0ZWUodmFsdWUpO1xyXG5cclxuICAgICAgICB2YWx1ZSA9IChjb21wYXJhdG9yIHx8IHZhbHVlICE9PSAwKSA/IHZhbHVlIDogMDtcclxuICAgICAgICBpZiAoaXNDb21tb24gJiYgY29tcHV0ZWQgPT09IGNvbXB1dGVkKSB7XHJcbiAgICAgICAgICB2YXIgdmFsdWVzSW5kZXggPSB2YWx1ZXNMZW5ndGg7XHJcbiAgICAgICAgICB3aGlsZSAodmFsdWVzSW5kZXgtLSkge1xyXG4gICAgICAgICAgICBpZiAodmFsdWVzW3ZhbHVlc0luZGV4XSA9PT0gY29tcHV0ZWQpIHtcclxuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICghaW5jbHVkZXModmFsdWVzLCBjb21wdXRlZCwgY29tcGFyYXRvcikpIHtcclxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cclxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxyXG4gICAgICovXHJcbiAgICB2YXIgYmFzZUVhY2ggPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hSaWdodGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxyXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXHJcbiAgICAgKi9cclxuICAgIHZhciBiYXNlRWFjaFJpZ2h0ID0gY3JlYXRlQmFzZUVhY2goYmFzZUZvck93blJpZ2h0LCB0cnVlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmV2ZXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXHJcbiAgICAgKiAgZWxzZSBgZmFsc2VgXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGJhc2VFdmVyeShjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcclxuICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XHJcbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xyXG4gICAgICAgIHJlc3VsdCA9ICEhcHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8ubWF4YCBhbmQgYF8ubWluYCB3aGljaCBhY2NlcHRzIGFcclxuICAgICAqIGBjb21wYXJhdG9yYCB0byBkZXRlcm1pbmUgdGhlIGV4dHJlbXVtIHZhbHVlLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGNvbXBhcmF0b3IgdXNlZCB0byBjb21wYXJlIHZhbHVlcy5cclxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBleHRyZW11bSB2YWx1ZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYmFzZUV4dHJlbXVtKGFycmF5LCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xyXG4gICAgICB2YXIgaW5kZXggPSAtMSxcclxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcclxuXHJcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxyXG4gICAgICAgICAgICBjdXJyZW50ID0gaXRlcmF0ZWUodmFsdWUpO1xyXG5cclxuICAgICAgICBpZiAoY3VycmVudCAhPSBudWxsICYmIChjb21wdXRlZCA9PT0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgPyAoY3VycmVudCA9PT0gY3VycmVudCAmJiAhaXNTeW1ib2woY3VycmVudCkpXHJcbiAgICAgICAgICAgICAgOiBjb21wYXJhdG9yKGN1cnJlbnQsIGNvbXB1dGVkKVxyXG4gICAgICAgICAgICApKSB7XHJcbiAgICAgICAgICB2YXIgY29tcHV0ZWQgPSBjdXJyZW50LFxyXG4gICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmlsbGAgd2l0aG91dCBhbiBpdGVyYXRlZSBjYWxsIGd1YXJkLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmlsbC5cclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGZpbGwgYGFycmF5YCB3aXRoLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYmFzZUZpbGwoYXJyYXksIHZhbHVlLCBzdGFydCwgZW5kKSB7XHJcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XHJcblxyXG4gICAgICBzdGFydCA9IHRvSW50ZWdlcihzdGFydCk7XHJcbiAgICAgIGlmIChzdGFydCA8IDApIHtcclxuICAgICAgICBzdGFydCA9IC1zdGFydCA+IGxlbmd0aCA/IDAgOiAobGVuZ3RoICsgc3RhcnQpO1xyXG4gICAgICB9XHJcbiAgICAgIGVuZCA9IChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiBsZW5ndGgpID8gbGVuZ3RoIDogdG9JbnRlZ2VyKGVuZCk7XHJcbiAgICAgIGlmIChlbmQgPCAwKSB7XHJcbiAgICAgICAgZW5kICs9IGxlbmd0aDtcclxuICAgICAgfVxyXG4gICAgICBlbmQgPSBzdGFydCA+IGVuZCA/IDAgOiB0b0xlbmd0aChlbmQpO1xyXG4gICAgICB3aGlsZSAoc3RhcnQgPCBlbmQpIHtcclxuICAgICAgICBhcnJheVtzdGFydCsrXSA9IHZhbHVlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBhcnJheTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbHRlcmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cclxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBiYXNlRmlsdGVyKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xyXG4gICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xyXG4gICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSkge1xyXG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mbGF0dGVuYCB3aXRoIHN1cHBvcnQgZm9yIHJlc3RyaWN0aW5nIGZsYXR0ZW5pbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlcHRoIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ByZWRpY2F0ZT1pc0ZsYXR0ZW5hYmxlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3RdIFJlc3RyaWN0IHRvIHZhbHVlcyB0aGF0IHBhc3MgYHByZWRpY2F0ZWAgY2hlY2tzLlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdD1bXV0gVGhlIGluaXRpYWwgcmVzdWx0IHZhbHVlLlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBiYXNlRmxhdHRlbihhcnJheSwgZGVwdGgsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCkge1xyXG4gICAgICB2YXIgaW5kZXggPSAtMSxcclxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcclxuXHJcbiAgICAgIHByZWRpY2F0ZSB8fCAocHJlZGljYXRlID0gaXNGbGF0dGVuYWJsZSk7XHJcbiAgICAgIHJlc3VsdCB8fCAocmVzdWx0ID0gW10pO1xyXG5cclxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XHJcbiAgICAgICAgaWYgKGRlcHRoID4gMCAmJiBwcmVkaWNhdGUodmFsdWUpKSB7XHJcbiAgICAgICAgICBpZiAoZGVwdGggPiAxKSB7XHJcbiAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGZsYXR0ZW4gYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXHJcbiAgICAgICAgICAgIGJhc2VGbGF0dGVuKHZhbHVlLCBkZXB0aCAtIDEsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBhcnJheVB1c2gocmVzdWx0LCB2YWx1ZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmICghaXNTdHJpY3QpIHtcclxuICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGJhc2VGb3JPd25gIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYG9iamVjdGBcclxuICAgICAqIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LlxyXG4gICAgICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxyXG4gICAgICovXHJcbiAgICB2YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYmFzZUZvcmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBwcm9wZXJ0aWVzXHJcbiAgICAgKiBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXHJcbiAgICAgKi9cclxuICAgIHZhciBiYXNlRm9yUmlnaHQgPSBjcmVhdGVCYXNlRm9yKHRydWUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxyXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYmFzZUZvck93bihvYmplY3QsIGl0ZXJhdGVlKSB7XHJcbiAgICAgIHJldHVybiBvYmplY3QgJiYgYmFzZUZvcihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93blJpZ2h0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxyXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYmFzZUZvck93blJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUpIHtcclxuICAgICAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yUmlnaHQob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mdW5jdGlvbnNgIHdoaWNoIGNyZWF0ZXMgYW4gYXJyYXkgb2ZcclxuICAgICAqIGBvYmplY3RgIGZ1bmN0aW9uIHByb3BlcnR5IG5hbWVzIGZpbHRlcmVkIGZyb20gYHByb3BzYC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZmlsdGVyLlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBuYW1lcy5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYmFzZUZ1bmN0aW9ucyhvYmplY3QsIHByb3BzKSB7XHJcbiAgICAgIHJldHVybiBhcnJheUZpbHRlcihwcm9wcywgZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24ob2JqZWN0W2tleV0pO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxyXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cclxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgpIHtcclxuICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XHJcblxyXG4gICAgICB2YXIgaW5kZXggPSAwLFxyXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XHJcblxyXG4gICAgICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcclxuICAgICAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkocGF0aFtpbmRleCsrXSldO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xyXG4gICAgICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXHJcbiAgICAgKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cclxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XHJcbiAgICAgIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xyXG4gICAgICByZXR1cm4gaXNBcnJheShvYmplY3QpID8gcmVzdWx0IDogYXJyYXlQdXNoKHJlc3VsdCwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcclxuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxyXG4gICAgICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxyXG4gICAgICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ3RgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cclxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gYG90aGVyYCxcclxuICAgICAqICBlbHNlIGBmYWxzZWAuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGJhc2VHdCh2YWx1ZSwgb3RoZXIpIHtcclxuICAgICAgcmV0dXJuIHZhbHVlID4gb3RoZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGJhc2VIYXMob2JqZWN0LCBrZXkpIHtcclxuICAgICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaGFzSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGJhc2VIYXNJbihvYmplY3QsIGtleSkge1xyXG4gICAgICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYga2V5IGluIE9iamVjdChvYmplY3QpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW5SYW5nZWAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gY2hlY2suXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG51bWJlcmAgaXMgaW4gdGhlIHJhbmdlLCBlbHNlIGBmYWxzZWAuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGJhc2VJblJhbmdlKG51bWJlciwgc3RhcnQsIGVuZCkge1xyXG4gICAgICByZXR1cm4gbnVtYmVyID49IG5hdGl2ZU1pbihzdGFydCwgZW5kKSAmJiBudW1iZXIgPCBuYXRpdmVNYXgoc3RhcnQsIGVuZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8uaW50ZXJzZWN0aW9uYCwgd2l0aG91dCBzdXBwb3J0XHJcbiAgICAgKiBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcywgdGhhdCBhY2NlcHRzIGFuIGFycmF5IG9mIGFycmF5cyB0byBpbnNwZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheXMgVGhlIGFycmF5cyB0byBpbnNwZWN0LlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2Ygc2hhcmVkIHZhbHVlcy5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYmFzZUludGVyc2VjdGlvbihhcnJheXMsIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XHJcbiAgICAgIHZhciBpbmNsdWRlcyA9IGNvbXBhcmF0b3IgPyBhcnJheUluY2x1ZGVzV2l0aCA6IGFycmF5SW5jbHVkZXMsXHJcbiAgICAgICAgICBsZW5ndGggPSBhcnJheXNbMF0ubGVuZ3RoLFxyXG4gICAgICAgICAgb3RoTGVuZ3RoID0gYXJyYXlzLmxlbmd0aCxcclxuICAgICAgICAgIG90aEluZGV4ID0gb3RoTGVuZ3RoLFxyXG4gICAgICAgICAgY2FjaGVzID0gQXJyYXkob3RoTGVuZ3RoKSxcclxuICAgICAgICAgIG1heExlbmd0aCA9IEluZmluaXR5LFxyXG4gICAgICAgICAgcmVzdWx0ID0gW107XHJcblxyXG4gICAgICB3aGlsZSAob3RoSW5kZXgtLSkge1xyXG4gICAgICAgIHZhciBhcnJheSA9IGFycmF5c1tvdGhJbmRleF07XHJcbiAgICAgICAgaWYgKG90aEluZGV4ICYmIGl0ZXJhdGVlKSB7XHJcbiAgICAgICAgICBhcnJheSA9IGFycmF5TWFwKGFycmF5LCBiYXNlVW5hcnkoaXRlcmF0ZWUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbWF4TGVuZ3RoID0gbmF0aXZlTWluKGFycmF5Lmxlbmd0aCwgbWF4TGVuZ3RoKTtcclxuICAgICAgICBjYWNoZXNbb3RoSW5kZXhdID0gIWNvbXBhcmF0b3IgJiYgKGl0ZXJhdGVlIHx8IChsZW5ndGggPj0gMTIwICYmIGFycmF5Lmxlbmd0aCA+PSAxMjApKVxyXG4gICAgICAgICAgPyBuZXcgU2V0Q2FjaGUob3RoSW5kZXggJiYgYXJyYXkpXHJcbiAgICAgICAgICA6IHVuZGVmaW5lZDtcclxuICAgICAgfVxyXG4gICAgICBhcnJheSA9IGFycmF5c1swXTtcclxuXHJcbiAgICAgIHZhciBpbmRleCA9IC0xLFxyXG4gICAgICAgICAgc2VlbiA9IGNhY2hlc1swXTtcclxuXHJcbiAgICAgIG91dGVyOlxyXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCAmJiByZXN1bHQubGVuZ3RoIDwgbWF4TGVuZ3RoKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxyXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XHJcblxyXG4gICAgICAgIHZhbHVlID0gKGNvbXBhcmF0b3IgfHwgdmFsdWUgIT09IDApID8gdmFsdWUgOiAwO1xyXG4gICAgICAgIGlmICghKHNlZW5cclxuICAgICAgICAgICAgICA/IGNhY2hlSGFzKHNlZW4sIGNvbXB1dGVkKVxyXG4gICAgICAgICAgICAgIDogaW5jbHVkZXMocmVzdWx0LCBjb21wdXRlZCwgY29tcGFyYXRvcilcclxuICAgICAgICAgICAgKSkge1xyXG4gICAgICAgICAgb3RoSW5kZXggPSBvdGhMZW5ndGg7XHJcbiAgICAgICAgICB3aGlsZSAoLS1vdGhJbmRleCkge1xyXG4gICAgICAgICAgICB2YXIgY2FjaGUgPSBjYWNoZXNbb3RoSW5kZXhdO1xyXG4gICAgICAgICAgICBpZiAoIShjYWNoZVxyXG4gICAgICAgICAgICAgICAgICA/IGNhY2hlSGFzKGNhY2hlLCBjb21wdXRlZClcclxuICAgICAgICAgICAgICAgICAgOiBpbmNsdWRlcyhhcnJheXNbb3RoSW5kZXhdLCBjb21wdXRlZCwgY29tcGFyYXRvcikpXHJcbiAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKHNlZW4pIHtcclxuICAgICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmludmVydGAgYW5kIGBfLmludmVydEJ5YCB3aGljaCBpbnZlcnRzXHJcbiAgICAgKiBgb2JqZWN0YCB3aXRoIHZhbHVlcyB0cmFuc2Zvcm1lZCBieSBgaXRlcmF0ZWVgIGFuZCBzZXQgYnkgYHNldHRlcmAuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIGZ1bmN0aW9uIHRvIHNldCBgYWNjdW11bGF0b3JgIHZhbHVlcy5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0gdmFsdWVzLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIGludmVydGVkIG9iamVjdC5cclxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgYWNjdW11bGF0b3JgLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBiYXNlSW52ZXJ0ZXIob2JqZWN0LCBzZXR0ZXIsIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xyXG4gICAgICBiYXNlRm9yT3duKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XHJcbiAgICAgICAgc2V0dGVyKGFjY3VtdWxhdG9yLCBpdGVyYXRlZSh2YWx1ZSksIGtleSwgb2JqZWN0KTtcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmludm9rZWAgd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsXHJcbiAgICAgKiBtZXRob2QgYXJndW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgbWV0aG9kIHRvIGludm9rZS5cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxyXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiB0aGUgaW52b2tlZCBtZXRob2QuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGJhc2VJbnZva2Uob2JqZWN0LCBwYXRoLCBhcmdzKSB7XHJcbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xyXG4gICAgICBvYmplY3QgPSBwYXJlbnQob2JqZWN0LCBwYXRoKTtcclxuICAgICAgdmFyIGZ1bmMgPSBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IG9iamVjdFt0b0tleShsYXN0KHBhdGgpKV07XHJcbiAgICAgIHJldHVybiBmdW5jID09IG51bGwgPyB1bmRlZmluZWQgOiBhcHBseShmdW5jLCBvYmplY3QsIGFyZ3MpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XHJcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FycmF5QnVmZmVyYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYmFzZUlzQXJyYXlCdWZmZXIodmFsdWUpIHtcclxuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJyYXlCdWZmZXJUYWc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0RhdGVgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZGF0ZSBvYmplY3QsIGVsc2UgYGZhbHNlYC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYmFzZUlzRGF0ZSh2YWx1ZSkge1xyXG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBkYXRlVGFnO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xyXG4gICAgICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cclxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXHJcbiAgICAgKiAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXHJcbiAgICAgKiAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIHtcclxuICAgICAgaWYgKHZhbHVlID09PSBvdGhlcikge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdExpa2UodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBiYXNlSXNFcXVhbCwgc3RhY2spO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbGAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xyXG4gICAgICogZGVlcCBjb21wYXJpc29ucyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxyXG4gICAgICogcmVmZXJlbmNlcyB0byBiZSBjb21wYXJlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcclxuICAgICAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxyXG4gICAgICAgICAgb3RoSXNBcnIgPSBpc0FycmF5KG90aGVyKSxcclxuICAgICAgICAgIG9ialRhZyA9IG9iaklzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob2JqZWN0KSxcclxuICAgICAgICAgIG90aFRhZyA9IG90aElzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob3RoZXIpO1xyXG5cclxuICAgICAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XHJcbiAgICAgIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xyXG5cclxuICAgICAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09IG9iamVjdFRhZyxcclxuICAgICAgICAgIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZyxcclxuICAgICAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XHJcblxyXG4gICAgICBpZiAoaXNTYW1lVGFnICYmIGlzQnVmZmVyKG9iamVjdCkpIHtcclxuICAgICAgICBpZiAoIWlzQnVmZmVyKG90aGVyKSkge1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvYmpJc0FyciA9IHRydWU7XHJcbiAgICAgICAgb2JqSXNPYmogPSBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoaXNTYW1lVGFnICYmICFvYmpJc09iaikge1xyXG4gICAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XHJcbiAgICAgICAgcmV0dXJuIChvYmpJc0FyciB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KSlcclxuICAgICAgICAgID8gZXF1YWxBcnJheXMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaylcclxuICAgICAgICAgIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghKGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRykpIHtcclxuICAgICAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxyXG4gICAgICAgICAgICBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcclxuXHJcbiAgICAgICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcclxuICAgICAgICAgIHZhciBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCxcclxuICAgICAgICAgICAgICBvdGhVbndyYXBwZWQgPSBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXI7XHJcblxyXG4gICAgICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcclxuICAgICAgICAgIHJldHVybiBlcXVhbEZ1bmMob2JqVW53cmFwcGVkLCBvdGhVbndyYXBwZWQsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFpc1NhbWVUYWcpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcclxuICAgICAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWFwYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG1hcCwgZWxzZSBgZmFsc2VgLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBiYXNlSXNNYXAodmFsdWUpIHtcclxuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSBtYXBUYWc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hdGNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG1hdGNoRGF0YSBUaGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3MgdG8gbWF0Y2guXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEsIGN1c3RvbWl6ZXIpIHtcclxuICAgICAgdmFyIGluZGV4ID0gbWF0Y2hEYXRhLmxlbmd0aCxcclxuICAgICAgICAgIGxlbmd0aCA9IGluZGV4LFxyXG4gICAgICAgICAgbm9DdXN0b21pemVyID0gIWN1c3RvbWl6ZXI7XHJcblxyXG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gIWxlbmd0aDtcclxuICAgICAgfVxyXG4gICAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcclxuICAgICAgd2hpbGUgKGluZGV4LS0pIHtcclxuICAgICAgICB2YXIgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XHJcbiAgICAgICAgaWYgKChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSlcclxuICAgICAgICAgICAgICA/IGRhdGFbMV0gIT09IG9iamVjdFtkYXRhWzBdXVxyXG4gICAgICAgICAgICAgIDogIShkYXRhWzBdIGluIG9iamVjdClcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XHJcbiAgICAgICAgdmFyIGtleSA9IGRhdGFbMF0sXHJcbiAgICAgICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXHJcbiAgICAgICAgICAgIHNyY1ZhbHVlID0gZGF0YVsxXTtcclxuXHJcbiAgICAgICAgaWYgKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKSB7XHJcbiAgICAgICAgICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdmFyIHN0YWNrID0gbmV3IFN0YWNrO1xyXG4gICAgICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjayk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoIShyZXN1bHQgPT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgPyBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRywgY3VzdG9taXplciwgc3RhY2spXHJcbiAgICAgICAgICAgICAgICA6IHJlc3VsdFxyXG4gICAgICAgICAgICAgICkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcclxuICAgICAqICBlbHNlIGBmYWxzZWAuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xyXG4gICAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XHJcbiAgICAgIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzUmVnRXhwYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHJlZ2V4cCwgZWxzZSBgZmFsc2VgLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBiYXNlSXNSZWdFeHAodmFsdWUpIHtcclxuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gcmVnZXhwVGFnO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNTZXRgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc2V0LCBlbHNlIGBmYWxzZWAuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGJhc2VJc1NldCh2YWx1ZSkge1xyXG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IHNldFRhZztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XHJcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXHJcbiAgICAgICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLml0ZXJhdGVlYC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHsqfSBbdmFsdWU9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYW4gaXRlcmF0ZWUuXHJcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGl0ZXJhdGVlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBiYXNlSXRlcmF0ZWUodmFsdWUpIHtcclxuICAgICAgLy8gRG9uJ3Qgc3RvcmUgdGhlIGB0eXBlb2ZgIHJlc3VsdCBpbiBhIHZhcmlhYmxlIHRvIGF2b2lkIGEgSklUIGJ1ZyBpbiBTYWZhcmkgOS5cclxuICAgICAgLy8gU2VlIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNTYwMzQgZm9yIG1vcmUgZGV0YWlscy5cclxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGlkZW50aXR5O1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcpIHtcclxuICAgICAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSlcclxuICAgICAgICAgID8gYmFzZU1hdGNoZXNQcm9wZXJ0eSh2YWx1ZVswXSwgdmFsdWVbMV0pXHJcbiAgICAgICAgICA6IGJhc2VNYXRjaGVzKHZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcHJvcGVydHkodmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcclxuICAgICAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XHJcbiAgICAgICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xyXG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xyXG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNJbmAgd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBiYXNlS2V5c0luKG9iamVjdCkge1xyXG4gICAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcclxuICAgICAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGlzUHJvdG8gPSBpc1Byb3RvdHlwZShvYmplY3QpLFxyXG4gICAgICAgICAgcmVzdWx0ID0gW107XHJcblxyXG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XHJcbiAgICAgICAgaWYgKCEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcclxuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5sdGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxyXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBgb3RoZXJgLFxyXG4gICAgICogIGVsc2UgYGZhbHNlYC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYmFzZUx0KHZhbHVlLCBvdGhlcikge1xyXG4gICAgICByZXR1cm4gdmFsdWUgPCBvdGhlcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hcGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBiYXNlTWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XHJcbiAgICAgIHZhciBpbmRleCA9IC0xLFxyXG4gICAgICAgICAgcmVzdWx0ID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBBcnJheShjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcclxuXHJcbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcclxuICAgICAgICByZXN1bHRbKytpbmRleF0gPSBpdGVyYXRlZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKTtcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XHJcbiAgICAgIHZhciBtYXRjaERhdGEgPSBnZXRNYXRjaERhdGEoc291cmNlKTtcclxuICAgICAgaWYgKG1hdGNoRGF0YS5sZW5ndGggPT0gMSAmJiBtYXRjaERhdGFbMF1bMl0pIHtcclxuICAgICAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUobWF0Y2hEYXRhWzBdWzBdLCBtYXRjaERhdGFbMF1bMV0pO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcclxuICAgICAgICByZXR1cm4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSk7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzUHJvcGVydHlgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNyY1ZhbHVlYC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cclxuICAgICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xyXG4gICAgICBpZiAoaXNLZXkocGF0aCkgJiYgaXNTdHJpY3RDb21wYXJhYmxlKHNyY1ZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSh0b0tleShwYXRoKSwgc3JjVmFsdWUpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcclxuICAgICAgICB2YXIgb2JqVmFsdWUgPSBnZXQob2JqZWN0LCBwYXRoKTtcclxuICAgICAgICByZXR1cm4gKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlKVxyXG4gICAgICAgICAgPyBoYXNJbihvYmplY3QsIHBhdGgpXHJcbiAgICAgICAgICA6IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHKTtcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1lcmdlYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2VkIHZhbHVlcy5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXHJcbiAgICAgKiAgY291bnRlcnBhcnRzLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjaykge1xyXG4gICAgICBpZiAob2JqZWN0ID09PSBzb3VyY2UpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgYmFzZUZvcihzb3VyY2UsIGZ1bmN0aW9uKHNyY1ZhbHVlLCBrZXkpIHtcclxuICAgICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xyXG4gICAgICAgIGlmIChpc09iamVjdChzcmNWYWx1ZSkpIHtcclxuICAgICAgICAgIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIGJhc2VNZXJnZSwgY3VzdG9taXplciwgc3RhY2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcclxuICAgICAgICAgICAgPyBjdXN0b21pemVyKHNhZmVHZXQob2JqZWN0LCBrZXkpLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxyXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSwga2V5c0luKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZU1lcmdlYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXHJcbiAgICAgKiBkZWVwIG1lcmdlcyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxyXG4gICAgICogcmVmZXJlbmNlcyB0byBiZSBtZXJnZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIG1lcmdlLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG1lcmdlRnVuYyBUaGUgZnVuY3Rpb24gdG8gbWVyZ2UgdmFsdWVzLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcclxuICAgICAqICBjb3VudGVycGFydHMuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIG1lcmdlRnVuYywgY3VzdG9taXplciwgc3RhY2spIHtcclxuICAgICAgdmFyIG9ialZhbHVlID0gc2FmZUdldChvYmplY3QsIGtleSksXHJcbiAgICAgICAgICBzcmNWYWx1ZSA9IHNhZmVHZXQoc291cmNlLCBrZXkpLFxyXG4gICAgICAgICAgc3RhY2tlZCA9IHN0YWNrLmdldChzcmNWYWx1ZSk7XHJcblxyXG4gICAgICBpZiAoc3RhY2tlZCkge1xyXG4gICAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHN0YWNrZWQpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXHJcbiAgICAgICAgPyBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxyXG4gICAgICAgIDogdW5kZWZpbmVkO1xyXG5cclxuICAgICAgdmFyIGlzQ29tbW9uID0gbmV3VmFsdWUgPT09IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgIGlmIChpc0NvbW1vbikge1xyXG4gICAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkoc3JjVmFsdWUpLFxyXG4gICAgICAgICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgaXNCdWZmZXIoc3JjVmFsdWUpLFxyXG4gICAgICAgICAgICBpc1R5cGVkID0gIWlzQXJyICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHNyY1ZhbHVlKTtcclxuXHJcbiAgICAgICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcclxuICAgICAgICBpZiAoaXNBcnIgfHwgaXNCdWZmIHx8IGlzVHlwZWQpIHtcclxuICAgICAgICAgIGlmIChpc0FycmF5KG9ialZhbHVlKSkge1xyXG4gICAgICAgICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSBpZiAoaXNBcnJheUxpa2VPYmplY3Qob2JqVmFsdWUpKSB7XHJcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gY29weUFycmF5KG9ialZhbHVlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2UgaWYgKGlzQnVmZikge1xyXG4gICAgICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGNsb25lQnVmZmVyKHNyY1ZhbHVlLCB0cnVlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2UgaWYgKGlzVHlwZWQpIHtcclxuICAgICAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcclxuICAgICAgICAgICAgbmV3VmFsdWUgPSBjbG9uZVR5cGVkQXJyYXkoc3JjVmFsdWUsIHRydWUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gW107XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzUGxhaW5PYmplY3Qoc3JjVmFsdWUpIHx8IGlzQXJndW1lbnRzKHNyY1ZhbHVlKSkge1xyXG4gICAgICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcclxuICAgICAgICAgIGlmIChpc0FyZ3VtZW50cyhvYmpWYWx1ZSkpIHtcclxuICAgICAgICAgICAgbmV3VmFsdWUgPSB0b1BsYWluT2JqZWN0KG9ialZhbHVlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2UgaWYgKCFpc09iamVjdChvYmpWYWx1ZSkgfHwgaXNGdW5jdGlvbihvYmpWYWx1ZSkpIHtcclxuICAgICAgICAgICAgbmV3VmFsdWUgPSBpbml0Q2xvbmVPYmplY3Qoc3JjVmFsdWUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChpc0NvbW1vbikge1xyXG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxyXG4gICAgICAgIHN0YWNrLnNldChzcmNWYWx1ZSwgbmV3VmFsdWUpO1xyXG4gICAgICAgIG1lcmdlRnVuYyhuZXdWYWx1ZSwgc3JjVmFsdWUsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjayk7XHJcbiAgICAgICAgc3RhY2tbJ2RlbGV0ZSddKHNyY1ZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5udGhgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IHRvIHJldHVybi5cclxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBudGggZWxlbWVudCBvZiBgYXJyYXlgLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBiYXNlTnRoKGFycmF5LCBuKSB7XHJcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XHJcbiAgICAgIGlmICghbGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIG4gKz0gbiA8IDAgPyBsZW5ndGggOiAwO1xyXG4gICAgICByZXR1cm4gaXNJbmRleChuLCBsZW5ndGgpID8gYXJyYXlbbl0gOiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5vcmRlckJ5YCB3aXRob3V0IHBhcmFtIGd1YXJkcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbltdfE9iamVjdFtdfHN0cmluZ1tdfSBpdGVyYXRlZXMgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gb3JkZXJzIFRoZSBzb3J0IG9yZGVycyBvZiBgaXRlcmF0ZWVzYC5cclxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYmFzZU9yZGVyQnkoY29sbGVjdGlvbiwgaXRlcmF0ZWVzLCBvcmRlcnMpIHtcclxuICAgICAgaWYgKGl0ZXJhdGVlcy5sZW5ndGgpIHtcclxuICAgICAgICBpdGVyYXRlZXMgPSBhcnJheU1hcChpdGVyYXRlZXMsIGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XHJcbiAgICAgICAgICBpZiAoaXNBcnJheShpdGVyYXRlZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2VHZXQodmFsdWUsIGl0ZXJhdGVlLmxlbmd0aCA9PT0gMSA/IGl0ZXJhdGVlWzBdIDogaXRlcmF0ZWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gaXRlcmF0ZWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaXRlcmF0ZWVzID0gW2lkZW50aXR5XTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGluZGV4ID0gLTE7XHJcbiAgICAgIGl0ZXJhdGVlcyA9IGFycmF5TWFwKGl0ZXJhdGVlcywgYmFzZVVuYXJ5KGdldEl0ZXJhdGVlKCkpKTtcclxuXHJcbiAgICAgIHZhciByZXN1bHQgPSBiYXNlTWFwKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcclxuICAgICAgICB2YXIgY3JpdGVyaWEgPSBhcnJheU1hcChpdGVyYXRlZXMsIGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XHJcbiAgICAgICAgICByZXR1cm4gaXRlcmF0ZWUodmFsdWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB7ICdjcml0ZXJpYSc6IGNyaXRlcmlhLCAnaW5kZXgnOiArK2luZGV4LCAndmFsdWUnOiB2YWx1ZSB9O1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHJldHVybiBiYXNlU29ydEJ5KHJlc3VsdCwgZnVuY3Rpb24ob2JqZWN0LCBvdGhlcikge1xyXG4gICAgICAgIHJldHVybiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LCBvdGhlciwgb3JkZXJzKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5waWNrYCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWxcclxuICAgICAqIHByb3BlcnR5IGlkZW50aWZpZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBiYXNlUGljayhvYmplY3QsIHBhdGhzKSB7XHJcbiAgICAgIHJldHVybiBiYXNlUGlja0J5KG9iamVjdCwgcGF0aHMsIGZ1bmN0aW9uKHZhbHVlLCBwYXRoKSB7XHJcbiAgICAgICAgcmV0dXJuIGhhc0luKG9iamVjdCwgcGF0aCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgIGBfLnBpY2tCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIHByb3BlcnR5LlxyXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYmFzZVBpY2tCeShvYmplY3QsIHBhdGhzLCBwcmVkaWNhdGUpIHtcclxuICAgICAgdmFyIGluZGV4ID0gLTEsXHJcbiAgICAgICAgICBsZW5ndGggPSBwYXRocy5sZW5ndGgsXHJcbiAgICAgICAgICByZXN1bHQgPSB7fTtcclxuXHJcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgdmFyIHBhdGggPSBwYXRoc1tpbmRleF0sXHJcbiAgICAgICAgICAgIHZhbHVlID0gYmFzZUdldChvYmplY3QsIHBhdGgpO1xyXG5cclxuICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBwYXRoKSkge1xyXG4gICAgICAgICAgYmFzZVNldChyZXN1bHQsIGNhc3RQYXRoKHBhdGgsIG9iamVjdCksIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVByb3BlcnR5YCB3aGljaCBzdXBwb3J0cyBkZWVwIHBhdGhzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGJhc2VQcm9wZXJ0eURlZXAocGF0aCkge1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XHJcbiAgICAgICAgcmV0dXJuIGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnB1bGxBbGxCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxyXG4gICAgICogc2hvcnRoYW5kcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cclxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBiYXNlUHVsbEFsbChhcnJheSwgdmFsdWVzLCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xyXG4gICAgICB2YXIgaW5kZXhPZiA9IGNvbXBhcmF0b3IgPyBiYXNlSW5kZXhPZldpdGggOiBiYXNlSW5kZXhPZixcclxuICAgICAgICAgIGluZGV4ID0gLTEsXHJcbiAgICAgICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxyXG4gICAgICAgICAgc2VlbiA9IGFycmF5O1xyXG5cclxuICAgICAgaWYgKGFycmF5ID09PSB2YWx1ZXMpIHtcclxuICAgICAgICB2YWx1ZXMgPSBjb3B5QXJyYXkodmFsdWVzKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoaXRlcmF0ZWUpIHtcclxuICAgICAgICBzZWVuID0gYXJyYXlNYXAoYXJyYXksIGJhc2VVbmFyeShpdGVyYXRlZSkpO1xyXG4gICAgICB9XHJcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgdmFyIGZyb21JbmRleCA9IDAsXHJcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWVzW2luZGV4XSxcclxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlKSA6IHZhbHVlO1xyXG5cclxuICAgICAgICB3aGlsZSAoKGZyb21JbmRleCA9IGluZGV4T2Yoc2VlbiwgY29tcHV0ZWQsIGZyb21JbmRleCwgY29tcGFyYXRvcikpID4gLTEpIHtcclxuICAgICAgICAgIGlmIChzZWVuICE9PSBhcnJheSkge1xyXG4gICAgICAgICAgICBzcGxpY2UuY2FsbChzZWVuLCBmcm9tSW5kZXgsIDEpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgc3BsaWNlLmNhbGwoYXJyYXksIGZyb21JbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBhcnJheTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnB1bGxBdGAgd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsXHJcbiAgICAgKiBpbmRleGVzIG9yIGNhcHR1cmluZyB0aGUgcmVtb3ZlZCBlbGVtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IGluZGV4ZXMgVGhlIGluZGV4ZXMgb2YgZWxlbWVudHMgdG8gcmVtb3ZlLlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGJhc2VQdWxsQXQoYXJyYXksIGluZGV4ZXMpIHtcclxuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gaW5kZXhlcy5sZW5ndGggOiAwLFxyXG4gICAgICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcclxuXHJcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xyXG4gICAgICAgIHZhciBpbmRleCA9IGluZGV4ZXNbbGVuZ3RoXTtcclxuICAgICAgICBpZiAobGVuZ3RoID09IGxhc3RJbmRleCB8fCBpbmRleCAhPT0gcHJldmlvdXMpIHtcclxuICAgICAgICAgIHZhciBwcmV2aW91cyA9IGluZGV4O1xyXG4gICAgICAgICAgaWYgKGlzSW5kZXgoaW5kZXgpKSB7XHJcbiAgICAgICAgICAgIHNwbGljZS5jYWxsKGFycmF5LCBpbmRleCwgMSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBiYXNlVW5zZXQoYXJyYXksIGluZGV4KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGFycmF5O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmFuZG9tYCB3aXRob3V0IHN1cHBvcnQgZm9yIHJldHVybmluZ1xyXG4gICAgICogZmxvYXRpbmctcG9pbnQgbnVtYmVycy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxvd2VyIFRoZSBsb3dlciBib3VuZC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB1cHBlciBUaGUgdXBwZXIgYm91bmQuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByYW5kb20gbnVtYmVyLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBiYXNlUmFuZG9tKGxvd2VyLCB1cHBlcikge1xyXG4gICAgICByZXR1cm4gbG93ZXIgKyBuYXRpdmVGbG9vcihuYXRpdmVSYW5kb20oKSAqICh1cHBlciAtIGxvd2VyICsgMSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmFuZ2VgIGFuZCBgXy5yYW5nZVJpZ2h0YCB3aGljaCBkb2Vzbid0XHJcbiAgICAgKiBjb2VyY2UgYXJndW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RlcCBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBieS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5nZSBvZiBudW1iZXJzLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBiYXNlUmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCwgZnJvbVJpZ2h0KSB7XHJcbiAgICAgIHZhciBpbmRleCA9IC0xLFxyXG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KG5hdGl2ZUNlaWwoKGVuZCAtIHN0YXJ0KSAvIChzdGVwIHx8IDEpKSwgMCksXHJcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xyXG5cclxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XHJcbiAgICAgICAgcmVzdWx0W2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdID0gc3RhcnQ7XHJcbiAgICAgICAgc3RhcnQgKz0gc3RlcDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVwZWF0YCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byByZXBlYXQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJlcGVhdCB0aGUgc3RyaW5nLlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmVwZWF0ZWQgc3RyaW5nLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBiYXNlUmVwZWF0KHN0cmluZywgbikge1xyXG4gICAgICB2YXIgcmVzdWx0ID0gJyc7XHJcbiAgICAgIGlmICghc3RyaW5nIHx8IG4gPCAxIHx8IG4gPiBNQVhfU0FGRV9JTlRFR0VSKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfVxyXG4gICAgICAvLyBMZXZlcmFnZSB0aGUgZXhwb25lbnRpYXRpb24gYnkgc3F1YXJpbmcgYWxnb3JpdGhtIGZvciBhIGZhc3RlciByZXBlYXQuXHJcbiAgICAgIC8vIFNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FeHBvbmVudGlhdGlvbl9ieV9zcXVhcmluZyBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gICAgICBkbyB7XHJcbiAgICAgICAgaWYgKG4gJSAyKSB7XHJcbiAgICAgICAgICByZXN1bHQgKz0gc3RyaW5nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBuID0gbmF0aXZlRmxvb3IobiAvIDIpO1xyXG4gICAgICAgIGlmIChuKSB7XHJcbiAgICAgICAgICBzdHJpbmcgKz0gc3RyaW5nO1xyXG4gICAgICAgIH1cclxuICAgICAgfSB3aGlsZSAobik7XHJcblxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVzdGAgd2hpY2ggZG9lc24ndCB2YWxpZGF0ZSBvciBjb2VyY2UgYXJndW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGJhc2VSZXN0KGZ1bmMsIHN0YXJ0KSB7XHJcbiAgICAgIHJldHVybiBzZXRUb1N0cmluZyhvdmVyUmVzdChmdW5jLCBzdGFydCwgaWRlbnRpdHkpLCBmdW5jICsgJycpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2FtcGxlYC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2FtcGxlLlxyXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBiYXNlU2FtcGxlKGNvbGxlY3Rpb24pIHtcclxuICAgICAgcmV0dXJuIGFycmF5U2FtcGxlKHZhbHVlcyhjb2xsZWN0aW9uKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zYW1wbGVTaXplYCB3aXRob3V0IHBhcmFtIGd1YXJkcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2FtcGxlLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBzYW1wbGUuXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50cy5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYmFzZVNhbXBsZVNpemUoY29sbGVjdGlvbiwgbikge1xyXG4gICAgICB2YXIgYXJyYXkgPSB2YWx1ZXMoY29sbGVjdGlvbik7XHJcbiAgICAgIHJldHVybiBzaHVmZmxlU2VsZihhcnJheSwgYmFzZUNsYW1wKG4sIDAsIGFycmF5Lmxlbmd0aCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2V0YC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cclxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBwYXRoIGNyZWF0aW9uLlxyXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlLCBjdXN0b21pemVyKSB7XHJcbiAgICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xyXG4gICAgICAgIHJldHVybiBvYmplY3Q7XHJcbiAgICAgIH1cclxuICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XHJcblxyXG4gICAgICB2YXIgaW5kZXggPSAtMSxcclxuICAgICAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxyXG4gICAgICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMSxcclxuICAgICAgICAgIG5lc3RlZCA9IG9iamVjdDtcclxuXHJcbiAgICAgIHdoaWxlIChuZXN0ZWQgIT0gbnVsbCAmJiArK2luZGV4IDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKSxcclxuICAgICAgICAgICAgbmV3VmFsdWUgPSB2YWx1ZTtcclxuXHJcbiAgICAgICAgaWYgKGtleSA9PT0gJ19fcHJvdG9fXycgfHwga2V5ID09PSAnY29uc3RydWN0b3InIHx8IGtleSA9PT0gJ3Byb3RvdHlwZScpIHtcclxuICAgICAgICAgIHJldHVybiBvYmplY3Q7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaW5kZXggIT0gbGFzdEluZGV4KSB7XHJcbiAgICAgICAgICB2YXIgb2JqVmFsdWUgPSBuZXN0ZWRba2V5XTtcclxuICAgICAgICAgIG5ld1ZhbHVlID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIGtleSwgbmVzdGVkKSA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gaXNPYmplY3Qob2JqVmFsdWUpXHJcbiAgICAgICAgICAgICAgPyBvYmpWYWx1ZVxyXG4gICAgICAgICAgICAgIDogKGlzSW5kZXgocGF0aFtpbmRleCArIDFdKSA/IFtdIDoge30pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBhc3NpZ25WYWx1ZShuZXN0ZWQsIGtleSwgbmV3VmFsdWUpO1xyXG4gICAgICAgIG5lc3RlZCA9IG5lc3RlZFtrZXldO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBvYmplY3Q7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0RGF0YWAgd2l0aG91dCBzdXBwb3J0IGZvciBob3QgbG9vcCBzaG9ydGluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXNzb2NpYXRlIG1ldGFkYXRhIHdpdGguXHJcbiAgICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1ldGFkYXRhLlxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cclxuICAgICAqL1xyXG4gICAgdmFyIGJhc2VTZXREYXRhID0gIW1ldGFNYXAgPyBpZGVudGl0eSA6IGZ1bmN0aW9uKGZ1bmMsIGRhdGEpIHtcclxuICAgICAgbWV0YU1hcC5zZXQoZnVuYywgZGF0YSk7XHJcbiAgICAgIHJldHVybiBmdW5jO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBzZXRUb1N0cmluZ2Agd2l0aG91dCBzdXBwb3J0IGZvciBob3QgbG9vcCBzaG9ydGluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cclxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXHJcbiAgICAgKi9cclxuICAgIHZhciBiYXNlU2V0VG9TdHJpbmcgPSAhZGVmaW5lUHJvcGVydHkgPyBpZGVudGl0eSA6IGZ1bmN0aW9uKGZ1bmMsIHN0cmluZykge1xyXG4gICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkoZnVuYywgJ3RvU3RyaW5nJywge1xyXG4gICAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxyXG4gICAgICAgICdlbnVtZXJhYmxlJzogZmFsc2UsXHJcbiAgICAgICAgJ3ZhbHVlJzogY29uc3RhbnQoc3RyaW5nKSxcclxuICAgICAgICAnd3JpdGFibGUnOiB0cnVlXHJcbiAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNodWZmbGVgLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzaHVmZmxlLlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGJhc2VTaHVmZmxlKGNvbGxlY3Rpb24pIHtcclxuICAgICAgcmV0dXJuIHNodWZmbGVTZWxmKHZhbHVlcyhjb2xsZWN0aW9uKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zbGljZWAgd2l0aG91dCBhbiBpdGVyYXRlZSBjYWxsIGd1YXJkLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2xpY2UuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cclxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XHJcbiAgICAgIHZhciBpbmRleCA9IC0xLFxyXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xyXG5cclxuICAgICAgaWYgKHN0YXJ0IDwgMCkge1xyXG4gICAgICAgIHN0YXJ0ID0gLXN0YXJ0ID4gbGVuZ3RoID8gMCA6IChsZW5ndGggKyBzdGFydCk7XHJcbiAgICAgIH1cclxuICAgICAgZW5kID0gZW5kID4gbGVuZ3RoID8gbGVuZ3RoIDogZW5kO1xyXG4gICAgICBpZiAoZW5kIDwgMCkge1xyXG4gICAgICAgIGVuZCArPSBsZW5ndGg7XHJcbiAgICAgIH1cclxuICAgICAgbGVuZ3RoID0gc3RhcnQgPiBlbmQgPyAwIDogKChlbmQgLSBzdGFydCkgPj4+IDApO1xyXG4gICAgICBzdGFydCA+Pj49IDA7XHJcblxyXG4gICAgICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcclxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcclxuICAgICAgICByZXN1bHRbaW5kZXhdID0gYXJyYXlbaW5kZXggKyBzdGFydF07XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvbWVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXHJcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBiYXNlU29tZShjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcclxuICAgICAgdmFyIHJlc3VsdDtcclxuXHJcbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xyXG4gICAgICAgIHJlc3VsdCA9IHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xyXG4gICAgICAgIHJldHVybiAhcmVzdWx0O1xyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuICEhcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29ydGVkSW5kZXhgIGFuZCBgXy5zb3J0ZWRMYXN0SW5kZXhgIHdoaWNoXHJcbiAgICAgKiBwZXJmb3JtcyBhIGJpbmFyeSBzZWFyY2ggb2YgYGFycmF5YCB0byBkZXRlcm1pbmUgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWBcclxuICAgICAqIHNob3VsZCBiZSBpbnNlcnRlZCBpbnRvIGBhcnJheWAgaW4gb3JkZXIgdG8gbWFpbnRhaW4gaXRzIHNvcnQgb3JkZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmV0SGlnaGVzdF0gU3BlY2lmeSByZXR1cm5pbmcgdGhlIGhpZ2hlc3QgcXVhbGlmaWVkIGluZGV4LlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcclxuICAgICAqICBpbnRvIGBhcnJheWAuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUsIHJldEhpZ2hlc3QpIHtcclxuICAgICAgdmFyIGxvdyA9IDAsXHJcbiAgICAgICAgICBoaWdoID0gYXJyYXkgPT0gbnVsbCA/IGxvdyA6IGFycmF5Lmxlbmd0aDtcclxuXHJcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgdmFsdWUgPT09IHZhbHVlICYmIGhpZ2ggPD0gSEFMRl9NQVhfQVJSQVlfTEVOR1RIKSB7XHJcbiAgICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcclxuICAgICAgICAgIHZhciBtaWQgPSAobG93ICsgaGlnaCkgPj4+IDEsXHJcbiAgICAgICAgICAgICAgY29tcHV0ZWQgPSBhcnJheVttaWRdO1xyXG5cclxuICAgICAgICAgIGlmIChjb21wdXRlZCAhPT0gbnVsbCAmJiAhaXNTeW1ib2woY29tcHV0ZWQpICYmXHJcbiAgICAgICAgICAgICAgKHJldEhpZ2hlc3QgPyAoY29tcHV0ZWQgPD0gdmFsdWUpIDogKGNvbXB1dGVkIDwgdmFsdWUpKSkge1xyXG4gICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaGlnaCA9IG1pZDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGhpZ2g7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleEJ5KGFycmF5LCB2YWx1ZSwgaWRlbnRpdHksIHJldEhpZ2hlc3QpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29ydGVkSW5kZXhCeWAgYW5kIGBfLnNvcnRlZExhc3RJbmRleEJ5YFxyXG4gICAgICogd2hpY2ggaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBgdmFsdWVgIGFuZCBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCB0byBjb21wdXRlXHJcbiAgICAgKiB0aGVpciBzb3J0IHJhbmtpbmcuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAodmFsdWUpLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmV0SGlnaGVzdF0gU3BlY2lmeSByZXR1cm5pbmcgdGhlIGhpZ2hlc3QgcXVhbGlmaWVkIGluZGV4LlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcclxuICAgICAqICBpbnRvIGBhcnJheWAuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGJhc2VTb3J0ZWRJbmRleEJ5KGFycmF5LCB2YWx1ZSwgaXRlcmF0ZWUsIHJldEhpZ2hlc3QpIHtcclxuICAgICAgdmFyIGxvdyA9IDAsXHJcbiAgICAgICAgICBoaWdoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XHJcbiAgICAgIGlmIChoaWdoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhbHVlID0gaXRlcmF0ZWUodmFsdWUpO1xyXG4gICAgICB2YXIgdmFsSXNOYU4gPSB2YWx1ZSAhPT0gdmFsdWUsXHJcbiAgICAgICAgICB2YWxJc051bGwgPSB2YWx1ZSA9PT0gbnVsbCxcclxuICAgICAgICAgIHZhbElzU3ltYm9sID0gaXNTeW1ib2wodmFsdWUpLFxyXG4gICAgICAgICAgdmFsSXNVbmRlZmluZWQgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcclxuICAgICAgICB2YXIgbWlkID0gbmF0aXZlRmxvb3IoKGxvdyArIGhpZ2gpIC8gMiksXHJcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUoYXJyYXlbbWlkXSksXHJcbiAgICAgICAgICAgIG90aElzRGVmaW5lZCA9IGNvbXB1dGVkICE9PSB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIG90aElzTnVsbCA9IGNvbXB1dGVkID09PSBudWxsLFxyXG4gICAgICAgICAgICBvdGhJc1JlZmxleGl2ZSA9IGNvbXB1dGVkID09PSBjb21wdXRlZCxcclxuICAgICAgICAgICAgb3RoSXNTeW1ib2wgPSBpc1N5bWJvbChjb21wdXRlZCk7XHJcblxyXG4gICAgICAgIGlmICh2YWxJc05hTikge1xyXG4gICAgICAgICAgdmFyIHNldExvdyA9IHJldEhpZ2hlc3QgfHwgb3RoSXNSZWZsZXhpdmU7XHJcbiAgICAgICAgfSBlbHNlIGlmICh2YWxJc1VuZGVmaW5lZCkge1xyXG4gICAgICAgICAgc2V0TG93ID0gb3RoSXNSZWZsZXhpdmUgJiYgKHJldEhpZ2hlc3QgfHwgb3RoSXNEZWZpbmVkKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHZhbElzTnVsbCkge1xyXG4gICAgICAgICAgc2V0TG93ID0gb3RoSXNSZWZsZXhpdmUgJiYgb3RoSXNEZWZpbmVkICYmIChyZXRIaWdoZXN0IHx8ICFvdGhJc051bGwpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodmFsSXNTeW1ib2wpIHtcclxuICAgICAgICAgIHNldExvdyA9IG90aElzUmVmbGV4aXZlICYmIG90aElzRGVmaW5lZCAmJiAhb3RoSXNOdWxsICYmIChyZXRIaWdoZXN0IHx8ICFvdGhJc1N5bWJvbCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChvdGhJc051bGwgfHwgb3RoSXNTeW1ib2wpIHtcclxuICAgICAgICAgIHNldExvdyA9IGZhbHNlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBzZXRMb3cgPSByZXRIaWdoZXN0ID8gKGNvbXB1dGVkIDw9IHZhbHVlKSA6IChjb21wdXRlZCA8IHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNldExvdykge1xyXG4gICAgICAgICAgbG93ID0gbWlkICsgMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaGlnaCA9IG1pZDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG5hdGl2ZU1pbihoaWdoLCBNQVhfQVJSQVlfSU5ERVgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29ydGVkVW5pcWAgYW5kIGBfLnNvcnRlZFVuaXFCeWAgd2l0aG91dFxyXG4gICAgICogc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGJhc2VTb3J0ZWRVbmlxKGFycmF5LCBpdGVyYXRlZSkge1xyXG4gICAgICB2YXIgaW5kZXggPSAtMSxcclxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcclxuICAgICAgICAgIHJlc0luZGV4ID0gMCxcclxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xyXG5cclxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXHJcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSkgOiB2YWx1ZTtcclxuXHJcbiAgICAgICAgaWYgKCFpbmRleCB8fCAhZXEoY29tcHV0ZWQsIHNlZW4pKSB7XHJcbiAgICAgICAgICB2YXIgc2VlbiA9IGNvbXB1dGVkO1xyXG4gICAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWUgPT09IDAgPyAwIDogdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b051bWJlcmAgd2hpY2ggZG9lc24ndCBlbnN1cmUgY29ycmVjdFxyXG4gICAgICogY29udmVyc2lvbnMgb2YgYmluYXJ5LCBoZXhhZGVjaW1hbCwgb3Igb2N0YWwgc3RyaW5nIHZhbHVlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYmFzZVRvTnVtYmVyKHZhbHVlKSB7XHJcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiBOQU47XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuICt2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxyXG4gICAgICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xyXG4gICAgICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxyXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXHJcbiAgICAgICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcclxuICAgICAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5pcUJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGJhc2VVbmlxKGFycmF5LCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xyXG4gICAgICB2YXIgaW5kZXggPSAtMSxcclxuICAgICAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlcyxcclxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcclxuICAgICAgICAgIGlzQ29tbW9uID0gdHJ1ZSxcclxuICAgICAgICAgIHJlc3VsdCA9IFtdLFxyXG4gICAgICAgICAgc2VlbiA9IHJlc3VsdDtcclxuXHJcbiAgICAgIGlmIChjb21wYXJhdG9yKSB7XHJcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcclxuICAgICAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXNXaXRoO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKGxlbmd0aCA+PSBMQVJHRV9BUlJBWV9TSVpFKSB7XHJcbiAgICAgICAgdmFyIHNldCA9IGl0ZXJhdGVlID8gbnVsbCA6IGNyZWF0ZVNldChhcnJheSk7XHJcbiAgICAgICAgaWYgKHNldCkge1xyXG4gICAgICAgICAgcmV0dXJuIHNldFRvQXJyYXkoc2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcclxuICAgICAgICBpbmNsdWRlcyA9IGNhY2hlSGFzO1xyXG4gICAgICAgIHNlZW4gPSBuZXcgU2V0Q2FjaGU7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgc2VlbiA9IGl0ZXJhdGVlID8gW10gOiByZXN1bHQ7XHJcbiAgICAgIH1cclxuICAgICAgb3V0ZXI6XHJcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxyXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XHJcblxyXG4gICAgICAgIHZhbHVlID0gKGNvbXBhcmF0b3IgfHwgdmFsdWUgIT09IDApID8gdmFsdWUgOiAwO1xyXG4gICAgICAgIGlmIChpc0NvbW1vbiAmJiBjb21wdXRlZCA9PT0gY29tcHV0ZWQpIHtcclxuICAgICAgICAgIHZhciBzZWVuSW5kZXggPSBzZWVuLmxlbmd0aDtcclxuICAgICAgICAgIHdoaWxlIChzZWVuSW5kZXgtLSkge1xyXG4gICAgICAgICAgICBpZiAoc2VlbltzZWVuSW5kZXhdID09PSBjb21wdXRlZCkge1xyXG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoaXRlcmF0ZWUpIHtcclxuICAgICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIWluY2x1ZGVzKHNlZW4sIGNvbXB1dGVkLCBjb21wYXJhdG9yKSkge1xyXG4gICAgICAgICAgaWYgKHNlZW4gIT09IHJlc3VsdCkge1xyXG4gICAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5zZXRgLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxyXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHByb3BlcnR5IHBhdGggdG8gdW5zZXQuXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHByb3BlcnR5IGlzIGRlbGV0ZWQsIGVsc2UgYGZhbHNlYC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYmFzZVVuc2V0KG9iamVjdCwgcGF0aCkge1xyXG4gICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcclxuICAgICAgb2JqZWN0ID0gcGFyZW50KG9iamVjdCwgcGF0aCk7XHJcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCB8fCBkZWxldGUgb2JqZWN0W3RvS2V5KGxhc3QocGF0aCkpXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVwZGF0ZWAuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gdXBkYXRlLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdXBkYXRlciBUaGUgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgdXBkYXRlZCB2YWx1ZS5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIHBhdGggY3JlYXRpb24uXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBiYXNlVXBkYXRlKG9iamVjdCwgcGF0aCwgdXBkYXRlciwgY3VzdG9taXplcikge1xyXG4gICAgICByZXR1cm4gYmFzZVNldChvYmplY3QsIHBhdGgsIHVwZGF0ZXIoYmFzZUdldChvYmplY3QsIHBhdGgpKSwgY3VzdG9taXplcik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8uZHJvcFdoaWxlYCBhbmQgYF8udGFrZVdoaWxlYFxyXG4gICAgICogd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRHJvcF0gU3BlY2lmeSBkcm9wcGluZyBlbGVtZW50cyBpbnN0ZWFkIG9mIHRha2luZyB0aGVtLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGJhc2VXaGlsZShhcnJheSwgcHJlZGljYXRlLCBpc0Ryb3AsIGZyb21SaWdodCkge1xyXG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxyXG4gICAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMTtcclxuXHJcbiAgICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpICYmXHJcbiAgICAgICAgcHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge31cclxuXHJcbiAgICAgIHJldHVybiBpc0Ryb3BcclxuICAgICAgICA/IGJhc2VTbGljZShhcnJheSwgKGZyb21SaWdodCA/IDAgOiBpbmRleCksIChmcm9tUmlnaHQgPyBpbmRleCArIDEgOiBsZW5ndGgpKVxyXG4gICAgICAgIDogYmFzZVNsaWNlKGFycmF5LCAoZnJvbVJpZ2h0ID8gaW5kZXggKyAxIDogMCksIChmcm9tUmlnaHQgPyBsZW5ndGggOiBpbmRleCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHdyYXBwZXJWYWx1ZWAgd2hpY2ggcmV0dXJucyB0aGUgcmVzdWx0IG9mXHJcbiAgICAgKiBwZXJmb3JtaW5nIGEgc2VxdWVuY2Ugb2YgYWN0aW9ucyBvbiB0aGUgdW53cmFwcGVkIGB2YWx1ZWAsIHdoZXJlIGVhY2hcclxuICAgICAqIHN1Y2Nlc3NpdmUgYWN0aW9uIGlzIHN1cHBsaWVkIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB1bndyYXBwZWQgdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhY3Rpb25zIEFjdGlvbnMgdG8gcGVyZm9ybSB0byByZXNvbHZlIHRoZSB1bndyYXBwZWQgdmFsdWUuXHJcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGJhc2VXcmFwcGVyVmFsdWUodmFsdWUsIGFjdGlvbnMpIHtcclxuICAgICAgdmFyIHJlc3VsdCA9IHZhbHVlO1xyXG4gICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHtcclxuICAgICAgICByZXN1bHQgPSByZXN1bHQudmFsdWUoKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gYXJyYXlSZWR1Y2UoYWN0aW9ucywgZnVuY3Rpb24ocmVzdWx0LCBhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gYWN0aW9uLmZ1bmMuYXBwbHkoYWN0aW9uLnRoaXNBcmcsIGFycmF5UHVzaChbcmVzdWx0XSwgYWN0aW9uLmFyZ3MpKTtcclxuICAgICAgfSwgcmVzdWx0KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy54b3JgLCB3aXRob3V0IHN1cHBvcnQgZm9yXHJcbiAgICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLCB0aGF0IGFjY2VwdHMgYW4gYXJyYXkgb2YgYXJyYXlzIHRvIGluc3BlY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5cyBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiB2YWx1ZXMuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGJhc2VYb3IoYXJyYXlzLCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xyXG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXlzLmxlbmd0aDtcclxuICAgICAgaWYgKGxlbmd0aCA8IDIpIHtcclxuICAgICAgICByZXR1cm4gbGVuZ3RoID8gYmFzZVVuaXEoYXJyYXlzWzBdKSA6IFtdO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBpbmRleCA9IC0xLFxyXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcclxuXHJcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgdmFyIGFycmF5ID0gYXJyYXlzW2luZGV4XSxcclxuICAgICAgICAgICAgb3RoSW5kZXggPSAtMTtcclxuXHJcbiAgICAgICAgd2hpbGUgKCsrb3RoSW5kZXggPCBsZW5ndGgpIHtcclxuICAgICAgICAgIGlmIChvdGhJbmRleCAhPSBpbmRleCkge1xyXG4gICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gYmFzZURpZmZlcmVuY2UocmVzdWx0W2luZGV4XSB8fCBhcnJheSwgYXJyYXlzW290aEluZGV4XSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4ocmVzdWx0LCAxKSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnppcE9iamVjdGAgd2hpY2ggYXNzaWducyB2YWx1ZXMgdXNpbmcgYGFzc2lnbkZ1bmNgLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMuXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHByb3BlcnR5IHZhbHVlcy5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbkZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBiYXNlWmlwT2JqZWN0KHByb3BzLCB2YWx1ZXMsIGFzc2lnbkZ1bmMpIHtcclxuICAgICAgdmFyIGluZGV4ID0gLTEsXHJcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXHJcbiAgICAgICAgICB2YWxzTGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcclxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xyXG5cclxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSBpbmRleCA8IHZhbHNMZW5ndGggPyB2YWx1ZXNbaW5kZXhdIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIGFzc2lnbkZ1bmMocmVzdWx0LCBwcm9wc1tpbmRleF0sIHZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FzdHMgYHZhbHVlYCB0byBhbiBlbXB0eSBhcnJheSBpZiBpdCdzIG5vdCBhbiBhcnJheSBsaWtlIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cclxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgdGhlIGNhc3QgYXJyYXktbGlrZSBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNhc3RBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcclxuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSA/IHZhbHVlIDogW107XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYXN0cyBgdmFsdWVgIHRvIGBpZGVudGl0eWAgaWYgaXQncyBub3QgYSBmdW5jdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cclxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBjYXN0IGZ1bmN0aW9uLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjYXN0RnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nID8gdmFsdWUgOiBpZGVudGl0eTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgcHJvcGVydHkgcGF0aCBhcnJheS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY2FzdFBhdGgodmFsdWUsIG9iamVjdCkge1xyXG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGlzS2V5KHZhbHVlLCBvYmplY3QpID8gW3ZhbHVlXSA6IHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBgYmFzZVJlc3RgIGFsaWFzIHdoaWNoIGNhbiBiZSByZXBsYWNlZCB3aXRoIGBpZGVudGl0eWAgYnkgbW9kdWxlXHJcbiAgICAgKiByZXBsYWNlbWVudCBwbHVnaW5zLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIHZhciBjYXN0UmVzdCA9IGJhc2VSZXN0O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FzdHMgYGFycmF5YCB0byBhIHNsaWNlIGlmIGl0J3MgbmVlZGVkLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgcG9zaXRpb24uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3Qgc2xpY2UuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNhc3RTbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xyXG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xyXG4gICAgICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IGVuZDtcclxuICAgICAgcmV0dXJuICghc3RhcnQgJiYgZW5kID49IGxlbmd0aCkgPyBhcnJheSA6IGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHNpbXBsZSB3cmFwcGVyIGFyb3VuZCB0aGUgZ2xvYmFsIFtgY2xlYXJUaW1lb3V0YF0oaHR0cHM6Ly9tZG4uaW8vY2xlYXJUaW1lb3V0KS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ8T2JqZWN0fSBpZCBUaGUgdGltZXIgaWQgb3IgdGltZW91dCBvYmplY3Qgb2YgdGhlIHRpbWVyIHRvIGNsZWFyLlxyXG4gICAgICovXHJcbiAgICB2YXIgY2xlYXJUaW1lb3V0ID0gY3R4Q2xlYXJUaW1lb3V0IHx8IGZ1bmN0aW9uKGlkKSB7XHJcbiAgICAgIHJldHVybiByb290LmNsZWFyVGltZW91dChpZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mICBgYnVmZmVyYC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIGNsb25lLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cclxuICAgICAqIEByZXR1cm5zIHtCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBidWZmZXIuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNsb25lQnVmZmVyKGJ1ZmZlciwgaXNEZWVwKSB7XHJcbiAgICAgIGlmIChpc0RlZXApIHtcclxuICAgICAgICByZXR1cm4gYnVmZmVyLnNsaWNlKCk7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGgsXHJcbiAgICAgICAgICByZXN1bHQgPSBhbGxvY1Vuc2FmZSA/IGFsbG9jVW5zYWZlKGxlbmd0aCkgOiBuZXcgYnVmZmVyLmNvbnN0cnVjdG9yKGxlbmd0aCk7XHJcblxyXG4gICAgICBidWZmZXIuY29weShyZXN1bHQpO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGBhcnJheUJ1ZmZlcmAuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcclxuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcclxuICAgICAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgZGF0YVZpZXdgLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVZpZXcgVGhlIGRhdGEgdmlldyB0byBjbG9uZS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgZGF0YSB2aWV3LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjbG9uZURhdGFWaWV3KGRhdGFWaWV3LCBpc0RlZXApIHtcclxuICAgICAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIoZGF0YVZpZXcuYnVmZmVyKSA6IGRhdGFWaWV3LmJ1ZmZlcjtcclxuICAgICAgcmV0dXJuIG5ldyBkYXRhVmlldy5jb25zdHJ1Y3RvcihidWZmZXIsIGRhdGFWaWV3LmJ5dGVPZmZzZXQsIGRhdGFWaWV3LmJ5dGVMZW5ndGgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGByZWdleHBgLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVnZXhwIFRoZSByZWdleHAgdG8gY2xvbmUuXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgcmVnZXhwLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjbG9uZVJlZ0V4cChyZWdleHApIHtcclxuICAgICAgdmFyIHJlc3VsdCA9IG5ldyByZWdleHAuY29uc3RydWN0b3IocmVnZXhwLnNvdXJjZSwgcmVGbGFncy5leGVjKHJlZ2V4cCkpO1xyXG4gICAgICByZXN1bHQubGFzdEluZGV4ID0gcmVnZXhwLmxhc3RJbmRleDtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgYHN5bWJvbGAgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3ltYm9sIFRoZSBzeW1ib2wgb2JqZWN0IHRvIGNsb25lLlxyXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHN5bWJvbCBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNsb25lU3ltYm9sKHN5bWJvbCkge1xyXG4gICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZiA/IE9iamVjdChzeW1ib2xWYWx1ZU9mLmNhbGwoc3ltYm9sKSkgOiB7fTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgdHlwZWRBcnJheWAuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlZEFycmF5IFRoZSB0eXBlZCBhcnJheSB0byBjbG9uZS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgdHlwZWQgYXJyYXkuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNsb25lVHlwZWRBcnJheSh0eXBlZEFycmF5LCBpc0RlZXApIHtcclxuICAgICAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIodHlwZWRBcnJheS5idWZmZXIpIDogdHlwZWRBcnJheS5idWZmZXI7XHJcbiAgICAgIHJldHVybiBuZXcgdHlwZWRBcnJheS5jb25zdHJ1Y3RvcihidWZmZXIsIHR5cGVkQXJyYXkuYnl0ZU9mZnNldCwgdHlwZWRBcnJheS5sZW5ndGgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tcGFyZXMgdmFsdWVzIHRvIHNvcnQgdGhlbSBpbiBhc2NlbmRpbmcgb3JkZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXHJcbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3IgZm9yIGB2YWx1ZWAuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNvbXBhcmVBc2NlbmRpbmcodmFsdWUsIG90aGVyKSB7XHJcbiAgICAgIGlmICh2YWx1ZSAhPT0gb3RoZXIpIHtcclxuICAgICAgICB2YXIgdmFsSXNEZWZpbmVkID0gdmFsdWUgIT09IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgdmFsSXNOdWxsID0gdmFsdWUgPT09IG51bGwsXHJcbiAgICAgICAgICAgIHZhbElzUmVmbGV4aXZlID0gdmFsdWUgPT09IHZhbHVlLFxyXG4gICAgICAgICAgICB2YWxJc1N5bWJvbCA9IGlzU3ltYm9sKHZhbHVlKTtcclxuXHJcbiAgICAgICAgdmFyIG90aElzRGVmaW5lZCA9IG90aGVyICE9PSB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIG90aElzTnVsbCA9IG90aGVyID09PSBudWxsLFxyXG4gICAgICAgICAgICBvdGhJc1JlZmxleGl2ZSA9IG90aGVyID09PSBvdGhlcixcclxuICAgICAgICAgICAgb3RoSXNTeW1ib2wgPSBpc1N5bWJvbChvdGhlcik7XHJcblxyXG4gICAgICAgIGlmICgoIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2wgJiYgIXZhbElzU3ltYm9sICYmIHZhbHVlID4gb3RoZXIpIHx8XHJcbiAgICAgICAgICAgICh2YWxJc1N5bWJvbCAmJiBvdGhJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUgJiYgIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2wpIHx8XHJcbiAgICAgICAgICAgICh2YWxJc051bGwgJiYgb3RoSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlKSB8fFxyXG4gICAgICAgICAgICAoIXZhbElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSkgfHxcclxuICAgICAgICAgICAgIXZhbElzUmVmbGV4aXZlKSB7XHJcbiAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCghdmFsSXNOdWxsICYmICF2YWxJc1N5bWJvbCAmJiAhb3RoSXNTeW1ib2wgJiYgdmFsdWUgPCBvdGhlcikgfHxcclxuICAgICAgICAgICAgKG90aElzU3ltYm9sICYmIHZhbElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSAmJiAhdmFsSXNOdWxsICYmICF2YWxJc1N5bWJvbCkgfHxcclxuICAgICAgICAgICAgKG90aElzTnVsbCAmJiB2YWxJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUpIHx8XHJcbiAgICAgICAgICAgICghb3RoSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlKSB8fFxyXG4gICAgICAgICAgICAhb3RoSXNSZWZsZXhpdmUpIHtcclxuICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VkIGJ5IGBfLm9yZGVyQnlgIHRvIGNvbXBhcmUgbXVsdGlwbGUgcHJvcGVydGllcyBvZiBhIHZhbHVlIHRvIGFub3RoZXJcclxuICAgICAqIGFuZCBzdGFibGUgc29ydCB0aGVtLlxyXG4gICAgICpcclxuICAgICAqIElmIGBvcmRlcnNgIGlzIHVuc3BlY2lmaWVkLCBhbGwgdmFsdWVzIGFyZSBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyLiBPdGhlcndpc2UsXHJcbiAgICAgKiBzcGVjaWZ5IGFuIG9yZGVyIG9mIFwiZGVzY1wiIGZvciBkZXNjZW5kaW5nIG9yIFwiYXNjXCIgZm9yIGFzY2VuZGluZyBzb3J0IG9yZGVyXHJcbiAgICAgKiBvZiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFuW118c3RyaW5nW119IG9yZGVycyBUaGUgb3JkZXIgdG8gc29ydCBieSBmb3IgZWFjaCBwcm9wZXJ0eS5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgb2JqZWN0YC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY29tcGFyZU11bHRpcGxlKG9iamVjdCwgb3RoZXIsIG9yZGVycykge1xyXG4gICAgICB2YXIgaW5kZXggPSAtMSxcclxuICAgICAgICAgIG9iakNyaXRlcmlhID0gb2JqZWN0LmNyaXRlcmlhLFxyXG4gICAgICAgICAgb3RoQ3JpdGVyaWEgPSBvdGhlci5jcml0ZXJpYSxcclxuICAgICAgICAgIGxlbmd0aCA9IG9iakNyaXRlcmlhLmxlbmd0aCxcclxuICAgICAgICAgIG9yZGVyc0xlbmd0aCA9IG9yZGVycy5sZW5ndGg7XHJcblxyXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBjb21wYXJlQXNjZW5kaW5nKG9iakNyaXRlcmlhW2luZGV4XSwgb3RoQ3JpdGVyaWFbaW5kZXhdKTtcclxuICAgICAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgICAgICBpZiAoaW5kZXggPj0gb3JkZXJzTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB2YXIgb3JkZXIgPSBvcmRlcnNbaW5kZXhdO1xyXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdCAqIChvcmRlciA9PSAnZGVzYycgPyAtMSA6IDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICAvLyBGaXhlcyBhbiBgQXJyYXkjc29ydGAgYnVnIGluIHRoZSBKUyBlbmdpbmUgZW1iZWRkZWQgaW4gQWRvYmUgYXBwbGljYXRpb25zXHJcbiAgICAgIC8vIHRoYXQgY2F1c2VzIGl0LCB1bmRlciBjZXJ0YWluIGNpcmN1bXN0YW5jZXMsIHRvIHByb3ZpZGUgdGhlIHNhbWUgdmFsdWUgZm9yXHJcbiAgICAgIC8vIGBvYmplY3RgIGFuZCBgb3RoZXJgLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlL3B1bGwvMTI0N1xyXG4gICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gICAgICAvL1xyXG4gICAgICAvLyBUaGlzIGFsc28gZW5zdXJlcyBhIHN0YWJsZSBzb3J0IGluIFY4IGFuZCBvdGhlciBlbmdpbmVzLlxyXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9OTAgZm9yIG1vcmUgZGV0YWlscy5cclxuICAgICAgcmV0dXJuIG9iamVjdC5pbmRleCAtIG90aGVyLmluZGV4O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSB0aGF0IGlzIHRoZSBjb21wb3NpdGlvbiBvZiBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMsXHJcbiAgICAgKiBwbGFjZWhvbGRlcnMsIGFuZCBwcm92aWRlZCBhcmd1bWVudHMgaW50byBhIHNpbmdsZSBhcnJheSBvZiBhcmd1bWVudHMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIHByb3ZpZGVkIGFyZ3VtZW50cy5cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcnRpYWxzIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZC5cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGhvbGRlcnMgVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cclxuICAgICAqIEBwYXJhbXMge2Jvb2xlYW59IFtpc0N1cnJpZWRdIFNwZWNpZnkgY29tcG9zaW5nIGZvciBhIGN1cnJpZWQgZnVuY3Rpb24uXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21wb3NlZCBhcmd1bWVudHMuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNvbXBvc2VBcmdzKGFyZ3MsIHBhcnRpYWxzLCBob2xkZXJzLCBpc0N1cnJpZWQpIHtcclxuICAgICAgdmFyIGFyZ3NJbmRleCA9IC0xLFxyXG4gICAgICAgICAgYXJnc0xlbmd0aCA9IGFyZ3MubGVuZ3RoLFxyXG4gICAgICAgICAgaG9sZGVyc0xlbmd0aCA9IGhvbGRlcnMubGVuZ3RoLFxyXG4gICAgICAgICAgbGVmdEluZGV4ID0gLTEsXHJcbiAgICAgICAgICBsZWZ0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLFxyXG4gICAgICAgICAgcmFuZ2VMZW5ndGggPSBuYXRpdmVNYXgoYXJnc0xlbmd0aCAtIGhvbGRlcnNMZW5ndGgsIDApLFxyXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVmdExlbmd0aCArIHJhbmdlTGVuZ3RoKSxcclxuICAgICAgICAgIGlzVW5jdXJyaWVkID0gIWlzQ3VycmllZDtcclxuXHJcbiAgICAgIHdoaWxlICgrK2xlZnRJbmRleCA8IGxlZnRMZW5ndGgpIHtcclxuICAgICAgICByZXN1bHRbbGVmdEluZGV4XSA9IHBhcnRpYWxzW2xlZnRJbmRleF07XHJcbiAgICAgIH1cclxuICAgICAgd2hpbGUgKCsrYXJnc0luZGV4IDwgaG9sZGVyc0xlbmd0aCkge1xyXG4gICAgICAgIGlmIChpc1VuY3VycmllZCB8fCBhcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XHJcbiAgICAgICAgICByZXN1bHRbaG9sZGVyc1thcmdzSW5kZXhdXSA9IGFyZ3NbYXJnc0luZGV4XTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgd2hpbGUgKHJhbmdlTGVuZ3RoLS0pIHtcclxuICAgICAgICByZXN1bHRbbGVmdEluZGV4KytdID0gYXJnc1thcmdzSW5kZXgrK107XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgY29tcG9zZUFyZ3NgIGV4Y2VwdCB0aGF0IHRoZSBhcmd1bWVudHMgY29tcG9zaXRpb25cclxuICAgICAqIGlzIHRhaWxvcmVkIGZvciBgXy5wYXJ0aWFsUmlnaHRgLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBwcm92aWRlZCBhcmd1bWVudHMuXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXJ0aWFscyBUaGUgYXJndW1lbnRzIHRvIGFwcGVuZCB0byB0aG9zZSBwcm92aWRlZC5cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGhvbGRlcnMgVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cclxuICAgICAqIEBwYXJhbXMge2Jvb2xlYW59IFtpc0N1cnJpZWRdIFNwZWNpZnkgY29tcG9zaW5nIGZvciBhIGN1cnJpZWQgZnVuY3Rpb24uXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21wb3NlZCBhcmd1bWVudHMuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNvbXBvc2VBcmdzUmlnaHQoYXJncywgcGFydGlhbHMsIGhvbGRlcnMsIGlzQ3VycmllZCkge1xyXG4gICAgICB2YXIgYXJnc0luZGV4ID0gLTEsXHJcbiAgICAgICAgICBhcmdzTGVuZ3RoID0gYXJncy5sZW5ndGgsXHJcbiAgICAgICAgICBob2xkZXJzSW5kZXggPSAtMSxcclxuICAgICAgICAgIGhvbGRlcnNMZW5ndGggPSBob2xkZXJzLmxlbmd0aCxcclxuICAgICAgICAgIHJpZ2h0SW5kZXggPSAtMSxcclxuICAgICAgICAgIHJpZ2h0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLFxyXG4gICAgICAgICAgcmFuZ2VMZW5ndGggPSBuYXRpdmVNYXgoYXJnc0xlbmd0aCAtIGhvbGRlcnNMZW5ndGgsIDApLFxyXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkocmFuZ2VMZW5ndGggKyByaWdodExlbmd0aCksXHJcbiAgICAgICAgICBpc1VuY3VycmllZCA9ICFpc0N1cnJpZWQ7XHJcblxyXG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCByYW5nZUxlbmd0aCkge1xyXG4gICAgICAgIHJlc3VsdFthcmdzSW5kZXhdID0gYXJnc1thcmdzSW5kZXhdO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBvZmZzZXQgPSBhcmdzSW5kZXg7XHJcbiAgICAgIHdoaWxlICgrK3JpZ2h0SW5kZXggPCByaWdodExlbmd0aCkge1xyXG4gICAgICAgIHJlc3VsdFtvZmZzZXQgKyByaWdodEluZGV4XSA9IHBhcnRpYWxzW3JpZ2h0SW5kZXhdO1xyXG4gICAgICB9XHJcbiAgICAgIHdoaWxlICgrK2hvbGRlcnNJbmRleCA8IGhvbGRlcnNMZW5ndGgpIHtcclxuICAgICAgICBpZiAoaXNVbmN1cnJpZWQgfHwgYXJnc0luZGV4IDwgYXJnc0xlbmd0aCkge1xyXG4gICAgICAgICAgcmVzdWx0W29mZnNldCArIGhvbGRlcnNbaG9sZGVyc0luZGV4XV0gPSBhcmdzW2FyZ3NJbmRleCsrXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGBzb3VyY2VgIHRvIGBhcnJheWAuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgZnJvbS5cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheT1bXV0gVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIHRvLlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNvcHlBcnJheShzb3VyY2UsIGFycmF5KSB7XHJcbiAgICAgIHZhciBpbmRleCA9IC0xLFxyXG4gICAgICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcclxuXHJcbiAgICAgIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xyXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xyXG4gICAgICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGFycmF5O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBjb3B5LlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XHJcbiAgICAgIHZhciBpc05ldyA9ICFvYmplY3Q7XHJcbiAgICAgIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xyXG5cclxuICAgICAgdmFyIGluZGV4ID0gLTEsXHJcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XHJcblxyXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xyXG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XHJcblxyXG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcclxuICAgICAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXHJcbiAgICAgICAgICA6IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIG5ld1ZhbHVlID0gc291cmNlW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc05ldykge1xyXG4gICAgICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBvYmplY3Q7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb3BpZXMgb3duIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNvcHlTeW1ib2xzKHNvdXJjZSwgb2JqZWN0KSB7XHJcbiAgICAgIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9scyhzb3VyY2UpLCBvYmplY3QpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29waWVzIG93biBhbmQgaW5oZXJpdGVkIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNvcHlTeW1ib2xzSW4oc291cmNlLCBvYmplY3QpIHtcclxuICAgICAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzSW4oc291cmNlKSwgb2JqZWN0KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmdyb3VwQnlgLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIGZ1bmN0aW9uIHRvIHNldCBhY2N1bXVsYXRvciB2YWx1ZXMuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaW5pdGlhbGl6ZXJdIFRoZSBhY2N1bXVsYXRvciBvYmplY3QgaW5pdGlhbGl6ZXIuXHJcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhZ2dyZWdhdG9yIGZ1bmN0aW9uLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVBZ2dyZWdhdG9yKHNldHRlciwgaW5pdGlhbGl6ZXIpIHtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XHJcbiAgICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlBZ2dyZWdhdG9yIDogYmFzZUFnZ3JlZ2F0b3IsXHJcbiAgICAgICAgICAgIGFjY3VtdWxhdG9yID0gaW5pdGlhbGl6ZXIgPyBpbml0aWFsaXplcigpIDoge307XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIHNldHRlciwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5hc3NpZ25gLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cclxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFzc2lnbmVyIGZ1bmN0aW9uLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xyXG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXHJcbiAgICAgICAgICAgIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoLFxyXG4gICAgICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoID4gMSA/IHNvdXJjZXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIGN1c3RvbWl6ZXIgPSAoYXNzaWduZXIubGVuZ3RoID4gMyAmJiB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nKVxyXG4gICAgICAgICAgPyAobGVuZ3RoLS0sIGN1c3RvbWl6ZXIpXHJcbiAgICAgICAgICA6IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xyXG4gICAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiBjdXN0b21pemVyO1xyXG4gICAgICAgICAgbGVuZ3RoID0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XHJcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcclxuICAgICAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcclxuICAgICAgICAgIGlmIChzb3VyY2UpIHtcclxuICAgICAgICAgICAgYXNzaWduZXIob2JqZWN0LCBzb3VyY2UsIGluZGV4LCBjdXN0b21pemVyKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgYGJhc2VFYWNoYCBvciBgYmFzZUVhY2hSaWdodGAgZnVuY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYSBjb2xsZWN0aW9uLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXHJcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVCYXNlRWFjaChlYWNoRnVuYywgZnJvbVJpZ2h0KSB7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xyXG4gICAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcclxuICAgICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XHJcbiAgICAgICAgICByZXR1cm4gZWFjaEZ1bmMoY29sbGVjdGlvbiwgaXRlcmF0ZWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGgsXHJcbiAgICAgICAgICAgIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTEsXHJcbiAgICAgICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KGNvbGxlY3Rpb24pO1xyXG5cclxuICAgICAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xyXG4gICAgICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIG1ldGhvZHMgbGlrZSBgXy5mb3JJbmAgYW5kIGBfLmZvck93bmAuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXHJcbiAgICAgICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KG9iamVjdCksXHJcbiAgICAgICAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSxcclxuICAgICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xyXG5cclxuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcclxuICAgICAgICAgIHZhciBrZXkgPSBwcm9wc1tmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XTtcclxuICAgICAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvYmplY3Q7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gaW52b2tlIGl0IHdpdGggdGhlIG9wdGlvbmFsIGB0aGlzYFxyXG4gICAgICogYmluZGluZyBvZiBgdGhpc0FyZ2AuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cclxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUJpbmQoZnVuYywgYml0bWFzaywgdGhpc0FyZykge1xyXG4gICAgICB2YXIgaXNCaW5kID0gYml0bWFzayAmIFdSQVBfQklORF9GTEFHLFxyXG4gICAgICAgICAgQ3RvciA9IGNyZWF0ZUN0b3IoZnVuYyk7XHJcblxyXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xyXG4gICAgICAgIHZhciBmbiA9ICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpID8gQ3RvciA6IGZ1bmM7XHJcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB3cmFwcGVyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8ubG93ZXJGaXJzdGAuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSBgU3RyaW5nYCBjYXNlIG1ldGhvZCB0byB1c2UuXHJcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXNlIGZ1bmN0aW9uLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVDYXNlRmlyc3QobWV0aG9kTmFtZSkge1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XHJcbiAgICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcclxuXHJcbiAgICAgICAgdmFyIHN0clN5bWJvbHMgPSBoYXNVbmljb2RlKHN0cmluZylcclxuICAgICAgICAgID8gc3RyaW5nVG9BcnJheShzdHJpbmcpXHJcbiAgICAgICAgICA6IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgdmFyIGNociA9IHN0clN5bWJvbHNcclxuICAgICAgICAgID8gc3RyU3ltYm9sc1swXVxyXG4gICAgICAgICAgOiBzdHJpbmcuY2hhckF0KDApO1xyXG5cclxuICAgICAgICB2YXIgdHJhaWxpbmcgPSBzdHJTeW1ib2xzXHJcbiAgICAgICAgICA/IGNhc3RTbGljZShzdHJTeW1ib2xzLCAxKS5qb2luKCcnKVxyXG4gICAgICAgICAgOiBzdHJpbmcuc2xpY2UoMSk7XHJcblxyXG4gICAgICAgIHJldHVybiBjaHJbbWV0aG9kTmFtZV0oKSArIHRyYWlsaW5nO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uY2FtZWxDYXNlYC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGNvbWJpbmUgZWFjaCB3b3JkLlxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG91bmRlciBmdW5jdGlvbi5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY3JlYXRlQ29tcG91bmRlcihjYWxsYmFjaykge1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIGFycmF5UmVkdWNlKHdvcmRzKGRlYnVycihzdHJpbmcpLnJlcGxhY2UocmVBcG9zLCAnJykpLCBjYWxsYmFjaywgJycpO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcHJvZHVjZXMgYW4gaW5zdGFuY2Ugb2YgYEN0b3JgIHJlZ2FyZGxlc3Mgb2ZcclxuICAgICAqIHdoZXRoZXIgaXQgd2FzIGludm9rZWQgYXMgcGFydCBvZiBhIGBuZXdgIGV4cHJlc3Npb24gb3IgYnkgYGNhbGxgIG9yIGBhcHBseWAuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IEN0b3IgVGhlIGNvbnN0cnVjdG9yIHRvIHdyYXAuXHJcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVDdG9yKEN0b3IpIHtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vIFVzZSBhIGBzd2l0Y2hgIHN0YXRlbWVudCB0byB3b3JrIHdpdGggY2xhc3MgY29uc3RydWN0b3JzLiBTZWVcclxuICAgICAgICAvLyBodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWZ1bmN0aW9uLW9iamVjdHMtY2FsbC10aGlzYXJndW1lbnQtYXJndW1lbnRzbGlzdFxyXG4gICAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXHJcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XHJcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xyXG4gICAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IEN0b3I7XHJcbiAgICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdKTtcclxuICAgICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0pO1xyXG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XHJcbiAgICAgICAgICBjYXNlIDQ6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcclxuICAgICAgICAgIGNhc2UgNTogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0pO1xyXG4gICAgICAgICAgY2FzZSA2OiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSwgYXJnc1s1XSk7XHJcbiAgICAgICAgICBjYXNlIDc6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdLCBhcmdzWzVdLCBhcmdzWzZdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHRoaXNCaW5kaW5nID0gYmFzZUNyZWF0ZShDdG9yLnByb3RvdHlwZSksXHJcbiAgICAgICAgICAgIHJlc3VsdCA9IEN0b3IuYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3MpO1xyXG5cclxuICAgICAgICAvLyBNaW1pYyB0aGUgY29uc3RydWN0b3IncyBgcmV0dXJuYCBiZWhhdmlvci5cclxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4MTMuMi4yIGZvciBtb3JlIGRldGFpbHMuXHJcbiAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiB0aGlzQmluZGluZztcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBlbmFibGUgY3VycnlpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFyaXR5IFRoZSBhcml0eSBvZiBgZnVuY2AuXHJcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVDdXJyeShmdW5jLCBiaXRtYXNrLCBhcml0eSkge1xyXG4gICAgICB2YXIgQ3RvciA9IGNyZWF0ZUN0b3IoZnVuYyk7XHJcblxyXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xyXG4gICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxyXG4gICAgICAgICAgICBhcmdzID0gQXJyYXkobGVuZ3RoKSxcclxuICAgICAgICAgICAgaW5kZXggPSBsZW5ndGgsXHJcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyID0gZ2V0SG9sZGVyKHdyYXBwZXIpO1xyXG5cclxuICAgICAgICB3aGlsZSAoaW5kZXgtLSkge1xyXG4gICAgICAgICAgYXJnc1tpbmRleF0gPSBhcmd1bWVudHNbaW5kZXhdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaG9sZGVycyA9IChsZW5ndGggPCAzICYmIGFyZ3NbMF0gIT09IHBsYWNlaG9sZGVyICYmIGFyZ3NbbGVuZ3RoIC0gMV0gIT09IHBsYWNlaG9sZGVyKVxyXG4gICAgICAgICAgPyBbXVxyXG4gICAgICAgICAgOiByZXBsYWNlSG9sZGVycyhhcmdzLCBwbGFjZWhvbGRlcik7XHJcblxyXG4gICAgICAgIGxlbmd0aCAtPSBob2xkZXJzLmxlbmd0aDtcclxuICAgICAgICBpZiAobGVuZ3RoIDwgYXJpdHkpIHtcclxuICAgICAgICAgIHJldHVybiBjcmVhdGVSZWN1cnJ5KFxyXG4gICAgICAgICAgICBmdW5jLCBiaXRtYXNrLCBjcmVhdGVIeWJyaWQsIHdyYXBwZXIucGxhY2Vob2xkZXIsIHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgYXJncywgaG9sZGVycywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFyaXR5IC0gbGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGZuID0gKHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikgPyBDdG9yIDogZnVuYztcclxuICAgICAgICByZXR1cm4gYXBwbHkoZm4sIHRoaXMsIGFyZ3MpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB3cmFwcGVyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGBfLmZpbmRgIG9yIGBfLmZpbmRMYXN0YCBmdW5jdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZmluZEluZGV4RnVuYyBUaGUgZnVuY3Rpb24gdG8gZmluZCB0aGUgY29sbGVjdGlvbiBpbmRleC5cclxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZpbmQgZnVuY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZpbmQoZmluZEluZGV4RnVuYykge1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcclxuICAgICAgICB2YXIgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XHJcbiAgICAgICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xyXG4gICAgICAgICAgdmFyIGl0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKTtcclxuICAgICAgICAgIGNvbGxlY3Rpb24gPSBrZXlzKGNvbGxlY3Rpb24pO1xyXG4gICAgICAgICAgcHJlZGljYXRlID0gZnVuY3Rpb24oa2V5KSB7IHJldHVybiBpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKTsgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGluZGV4ID0gZmluZEluZGV4RnVuYyhjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGZyb21JbmRleCk7XHJcbiAgICAgICAgcmV0dXJuIGluZGV4ID4gLTEgPyBpdGVyYWJsZVtpdGVyYXRlZSA/IGNvbGxlY3Rpb25baW5kZXhdIDogaW5kZXhdIDogdW5kZWZpbmVkO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGBfLmZsb3dgIG9yIGBfLmZsb3dSaWdodGAgZnVuY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZmxvdyBmdW5jdGlvbi5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY3JlYXRlRmxvdyhmcm9tUmlnaHQpIHtcclxuICAgICAgcmV0dXJuIGZsYXRSZXN0KGZ1bmN0aW9uKGZ1bmNzKSB7XHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IGZ1bmNzLmxlbmd0aCxcclxuICAgICAgICAgICAgaW5kZXggPSBsZW5ndGgsXHJcbiAgICAgICAgICAgIHByZXJlcSA9IExvZGFzaFdyYXBwZXIucHJvdG90eXBlLnRocnU7XHJcblxyXG4gICAgICAgIGlmIChmcm9tUmlnaHQpIHtcclxuICAgICAgICAgIGZ1bmNzLnJldmVyc2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKGluZGV4LS0pIHtcclxuICAgICAgICAgIHZhciBmdW5jID0gZnVuY3NbaW5kZXhdO1xyXG4gICAgICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKHByZXJlcSAmJiAhd3JhcHBlciAmJiBnZXRGdW5jTmFtZShmdW5jKSA9PSAnd3JhcHBlcicpIHtcclxuICAgICAgICAgICAgdmFyIHdyYXBwZXIgPSBuZXcgTG9kYXNoV3JhcHBlcihbXSwgdHJ1ZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluZGV4ID0gd3JhcHBlciA/IGluZGV4IDogbGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgICBmdW5jID0gZnVuY3NbaW5kZXhdO1xyXG5cclxuICAgICAgICAgIHZhciBmdW5jTmFtZSA9IGdldEZ1bmNOYW1lKGZ1bmMpLFxyXG4gICAgICAgICAgICAgIGRhdGEgPSBmdW5jTmFtZSA9PSAnd3JhcHBlcicgPyBnZXREYXRhKGZ1bmMpIDogdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAgIGlmIChkYXRhICYmIGlzTGF6aWFibGUoZGF0YVswXSkgJiZcclxuICAgICAgICAgICAgICAgIGRhdGFbMV0gPT0gKFdSQVBfQVJZX0ZMQUcgfCBXUkFQX0NVUlJZX0ZMQUcgfCBXUkFQX1BBUlRJQUxfRkxBRyB8IFdSQVBfUkVBUkdfRkxBRykgJiZcclxuICAgICAgICAgICAgICAgICFkYXRhWzRdLmxlbmd0aCAmJiBkYXRhWzldID09IDFcclxuICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgd3JhcHBlciA9IHdyYXBwZXJbZ2V0RnVuY05hbWUoZGF0YVswXSldLmFwcGx5KHdyYXBwZXIsIGRhdGFbM10pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgd3JhcHBlciA9IChmdW5jLmxlbmd0aCA9PSAxICYmIGlzTGF6aWFibGUoZnVuYykpXHJcbiAgICAgICAgICAgICAgPyB3cmFwcGVyW2Z1bmNOYW1lXSgpXHJcbiAgICAgICAgICAgICAgOiB3cmFwcGVyLnRocnUoZnVuYyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxyXG4gICAgICAgICAgICAgIHZhbHVlID0gYXJnc1swXTtcclxuXHJcbiAgICAgICAgICBpZiAod3JhcHBlciAmJiBhcmdzLmxlbmd0aCA9PSAxICYmIGlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB3cmFwcGVyLnBsYW50KHZhbHVlKS52YWx1ZSgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdmFyIGluZGV4ID0gMCxcclxuICAgICAgICAgICAgICByZXN1bHQgPSBsZW5ndGggPyBmdW5jc1tpbmRleF0uYXBwbHkodGhpcywgYXJncykgOiB2YWx1ZTtcclxuXHJcbiAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jc1tpbmRleF0uY2FsbCh0aGlzLCByZXN1bHQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9O1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBpbnZva2UgaXQgd2l0aCBvcHRpb25hbCBgdGhpc2BcclxuICAgICAqIGJpbmRpbmcgb2YgYHRoaXNBcmdgLCBwYXJ0aWFsIGFwcGxpY2F0aW9uLCBhbmQgY3VycnlpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSBmdW5jIFRoZSBmdW5jdGlvbiBvciBtZXRob2QgbmFtZSB0byB3cmFwLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cclxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZCB0b1xyXG4gICAgICogIHRoZSBuZXcgZnVuY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc10gVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc1JpZ2h0XSBUaGUgYXJndW1lbnRzIHRvIGFwcGVuZCB0byB0aG9zZSBwcm92aWRlZFxyXG4gICAgICogIHRvIHRoZSBuZXcgZnVuY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc1JpZ2h0XSBUaGUgYHBhcnRpYWxzUmlnaHRgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJnUG9zXSBUaGUgYXJndW1lbnQgcG9zaXRpb25zIG9mIHRoZSBuZXcgZnVuY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyeV0gVGhlIGFyaXR5IGNhcCBvZiBgZnVuY2AuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5XSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY3JlYXRlSHlicmlkKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzLCBwYXJ0aWFsc1JpZ2h0LCBob2xkZXJzUmlnaHQsIGFyZ1BvcywgYXJ5LCBhcml0eSkge1xyXG4gICAgICB2YXIgaXNBcnkgPSBiaXRtYXNrICYgV1JBUF9BUllfRkxBRyxcclxuICAgICAgICAgIGlzQmluZCA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRyxcclxuICAgICAgICAgIGlzQmluZEtleSA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfS0VZX0ZMQUcsXHJcbiAgICAgICAgICBpc0N1cnJpZWQgPSBiaXRtYXNrICYgKFdSQVBfQ1VSUllfRkxBRyB8IFdSQVBfQ1VSUllfUklHSFRfRkxBRyksXHJcbiAgICAgICAgICBpc0ZsaXAgPSBiaXRtYXNrICYgV1JBUF9GTElQX0ZMQUcsXHJcbiAgICAgICAgICBDdG9yID0gaXNCaW5kS2V5ID8gdW5kZWZpbmVkIDogY3JlYXRlQ3RvcihmdW5jKTtcclxuXHJcbiAgICAgIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXHJcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheShsZW5ndGgpLFxyXG4gICAgICAgICAgICBpbmRleCA9IGxlbmd0aDtcclxuXHJcbiAgICAgICAgd2hpbGUgKGluZGV4LS0pIHtcclxuICAgICAgICAgIGFyZ3NbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzQ3VycmllZCkge1xyXG4gICAgICAgICAgdmFyIHBsYWNlaG9sZGVyID0gZ2V0SG9sZGVyKHdyYXBwZXIpLFxyXG4gICAgICAgICAgICAgIGhvbGRlcnNDb3VudCA9IGNvdW50SG9sZGVycyhhcmdzLCBwbGFjZWhvbGRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwYXJ0aWFscykge1xyXG4gICAgICAgICAgYXJncyA9IGNvbXBvc2VBcmdzKGFyZ3MsIHBhcnRpYWxzLCBob2xkZXJzLCBpc0N1cnJpZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGFydGlhbHNSaWdodCkge1xyXG4gICAgICAgICAgYXJncyA9IGNvbXBvc2VBcmdzUmlnaHQoYXJncywgcGFydGlhbHNSaWdodCwgaG9sZGVyc1JpZ2h0LCBpc0N1cnJpZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZW5ndGggLT0gaG9sZGVyc0NvdW50O1xyXG4gICAgICAgIGlmIChpc0N1cnJpZWQgJiYgbGVuZ3RoIDwgYXJpdHkpIHtcclxuICAgICAgICAgIHZhciBuZXdIb2xkZXJzID0gcmVwbGFjZUhvbGRlcnMoYXJncywgcGxhY2Vob2xkZXIpO1xyXG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVJlY3VycnkoXHJcbiAgICAgICAgICAgIGZ1bmMsIGJpdG1hc2ssIGNyZWF0ZUh5YnJpZCwgd3JhcHBlci5wbGFjZWhvbGRlciwgdGhpc0FyZyxcclxuICAgICAgICAgICAgYXJncywgbmV3SG9sZGVycywgYXJnUG9zLCBhcnksIGFyaXR5IC0gbGVuZ3RoXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdGhpc0JpbmRpbmcgPSBpc0JpbmQgPyB0aGlzQXJnIDogdGhpcyxcclxuICAgICAgICAgICAgZm4gPSBpc0JpbmRLZXkgPyB0aGlzQmluZGluZ1tmdW5jXSA6IGZ1bmM7XHJcblxyXG4gICAgICAgIGxlbmd0aCA9IGFyZ3MubGVuZ3RoO1xyXG4gICAgICAgIGlmIChhcmdQb3MpIHtcclxuICAgICAgICAgIGFyZ3MgPSByZW9yZGVyKGFyZ3MsIGFyZ1Bvcyk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpc0ZsaXAgJiYgbGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgYXJncy5yZXZlcnNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0FyeSAmJiBhcnkgPCBsZW5ndGgpIHtcclxuICAgICAgICAgIGFyZ3MubGVuZ3RoID0gYXJ5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSB7XHJcbiAgICAgICAgICBmbiA9IEN0b3IgfHwgY3JlYXRlQ3Rvcihmbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzQmluZGluZywgYXJncyk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHdyYXBwZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5pbnZlcnRCeWAuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGFjY3VtdWxhdG9yIHZhbHVlcy5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHRvSXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgaXRlcmF0ZWVzLlxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgaW52ZXJ0ZXIgZnVuY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUludmVydGVyKHNldHRlciwgdG9JdGVyYXRlZSkge1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSkge1xyXG4gICAgICAgIHJldHVybiBiYXNlSW52ZXJ0ZXIob2JqZWN0LCBzZXR0ZXIsIHRvSXRlcmF0ZWUoaXRlcmF0ZWUpLCB7fSk7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyBhIG1hdGhlbWF0aWNhbCBvcGVyYXRpb24gb24gdHdvIHZhbHVlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3BlcmF0b3IgVGhlIGZ1bmN0aW9uIHRvIHBlcmZvcm0gdGhlIG9wZXJhdGlvbi5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgdXNlZCBmb3IgYHVuZGVmaW5lZGAgYXJndW1lbnRzLlxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWF0aGVtYXRpY2FsIG9wZXJhdGlvbiBmdW5jdGlvbi5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY3JlYXRlTWF0aE9wZXJhdGlvbihvcGVyYXRvciwgZGVmYXVsdFZhbHVlKSB7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcclxuICAgICAgICB2YXIgcmVzdWx0O1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIG90aGVyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG90aGVyICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gb3RoZXI7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IHR5cGVvZiBvdGhlciA9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IGJhc2VUb1N0cmluZyh2YWx1ZSk7XHJcbiAgICAgICAgICAgIG90aGVyID0gYmFzZVRvU3RyaW5nKG90aGVyKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gYmFzZVRvTnVtYmVyKHZhbHVlKTtcclxuICAgICAgICAgICAgb3RoZXIgPSBiYXNlVG9OdW1iZXIob3RoZXIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmVzdWx0ID0gb3BlcmF0b3IodmFsdWUsIG90aGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLm92ZXJgLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhcnJheUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBpdGVyYXRlZXMuXHJcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBvdmVyIGZ1bmN0aW9uLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVPdmVyKGFycmF5RnVuYykge1xyXG4gICAgICByZXR1cm4gZmxhdFJlc3QoZnVuY3Rpb24oaXRlcmF0ZWVzKSB7XHJcbiAgICAgICAgaXRlcmF0ZWVzID0gYXJyYXlNYXAoaXRlcmF0ZWVzLCBiYXNlVW5hcnkoZ2V0SXRlcmF0ZWUoKSkpO1xyXG4gICAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XHJcbiAgICAgICAgICB2YXIgdGhpc0FyZyA9IHRoaXM7XHJcbiAgICAgICAgICByZXR1cm4gYXJyYXlGdW5jKGl0ZXJhdGVlcywgZnVuY3Rpb24oaXRlcmF0ZWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFwcGx5KGl0ZXJhdGVlLCB0aGlzQXJnLCBhcmdzKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgdGhlIHBhZGRpbmcgZm9yIGBzdHJpbmdgIGJhc2VkIG9uIGBsZW5ndGhgLiBUaGUgYGNoYXJzYCBzdHJpbmdcclxuICAgICAqIGlzIHRydW5jYXRlZCBpZiB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgZXhjZWVkcyBgbGVuZ3RoYC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBUaGUgcGFkZGluZyBsZW5ndGguXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBwYWRkaW5nIGZvciBgc3RyaW5nYC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY3JlYXRlUGFkZGluZyhsZW5ndGgsIGNoYXJzKSB7XHJcbiAgICAgIGNoYXJzID0gY2hhcnMgPT09IHVuZGVmaW5lZCA/ICcgJyA6IGJhc2VUb1N0cmluZyhjaGFycyk7XHJcblxyXG4gICAgICB2YXIgY2hhcnNMZW5ndGggPSBjaGFycy5sZW5ndGg7XHJcbiAgICAgIGlmIChjaGFyc0xlbmd0aCA8IDIpIHtcclxuICAgICAgICByZXR1cm4gY2hhcnNMZW5ndGggPyBiYXNlUmVwZWF0KGNoYXJzLCBsZW5ndGgpIDogY2hhcnM7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VSZXBlYXQoY2hhcnMsIG5hdGl2ZUNlaWwobGVuZ3RoIC8gc3RyaW5nU2l6ZShjaGFycykpKTtcclxuICAgICAgcmV0dXJuIGhhc1VuaWNvZGUoY2hhcnMpXHJcbiAgICAgICAgPyBjYXN0U2xpY2Uoc3RyaW5nVG9BcnJheShyZXN1bHQpLCAwLCBsZW5ndGgpLmpvaW4oJycpXHJcbiAgICAgICAgOiByZXN1bHQuc2xpY2UoMCwgbGVuZ3RoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBpbnZva2UgaXQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmdcclxuICAgICAqIG9mIGB0aGlzQXJnYCBhbmQgYHBhcnRpYWxzYCBwcmVwZW5kZWQgdG8gdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXHJcbiAgICAgKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcnRpYWxzIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZCB0b1xyXG4gICAgICogIHRoZSBuZXcgZnVuY3Rpb24uXHJcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVQYXJ0aWFsKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzKSB7XHJcbiAgICAgIHZhciBpc0JpbmQgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0ZMQUcsXHJcbiAgICAgICAgICBDdG9yID0gY3JlYXRlQ3RvcihmdW5jKTtcclxuXHJcbiAgICAgIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XHJcbiAgICAgICAgdmFyIGFyZ3NJbmRleCA9IC0xLFxyXG4gICAgICAgICAgICBhcmdzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcclxuICAgICAgICAgICAgbGVmdEluZGV4ID0gLTEsXHJcbiAgICAgICAgICAgIGxlZnRMZW5ndGggPSBwYXJ0aWFscy5sZW5ndGgsXHJcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheShsZWZ0TGVuZ3RoICsgYXJnc0xlbmd0aCksXHJcbiAgICAgICAgICAgIGZuID0gKHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikgPyBDdG9yIDogZnVuYztcclxuXHJcbiAgICAgICAgd2hpbGUgKCsrbGVmdEluZGV4IDwgbGVmdExlbmd0aCkge1xyXG4gICAgICAgICAgYXJnc1tsZWZ0SW5kZXhdID0gcGFydGlhbHNbbGVmdEluZGV4XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKGFyZ3NMZW5ndGgtLSkge1xyXG4gICAgICAgICAgYXJnc1tsZWZ0SW5kZXgrK10gPSBhcmd1bWVudHNbKythcmdzSW5kZXhdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXBwbHkoZm4sIGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLCBhcmdzKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gd3JhcHBlcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBgXy5yYW5nZWAgb3IgYF8ucmFuZ2VSaWdodGAgZnVuY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmFuZ2UgZnVuY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJhbmdlKGZyb21SaWdodCkge1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24oc3RhcnQsIGVuZCwgc3RlcCkge1xyXG4gICAgICAgIGlmIChzdGVwICYmIHR5cGVvZiBzdGVwICE9ICdudW1iZXInICYmIGlzSXRlcmF0ZWVDYWxsKHN0YXJ0LCBlbmQsIHN0ZXApKSB7XHJcbiAgICAgICAgICBlbmQgPSBzdGVwID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBFbnN1cmUgdGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXHJcbiAgICAgICAgc3RhcnQgPSB0b0Zpbml0ZShzdGFydCk7XHJcbiAgICAgICAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICBlbmQgPSBzdGFydDtcclxuICAgICAgICAgIHN0YXJ0ID0gMDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZW5kID0gdG9GaW5pdGUoZW5kKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RlcCA9IHN0ZXAgPT09IHVuZGVmaW5lZCA/IChzdGFydCA8IGVuZCA/IDEgOiAtMSkgOiB0b0Zpbml0ZShzdGVwKTtcclxuICAgICAgICByZXR1cm4gYmFzZVJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXAsIGZyb21SaWdodCk7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyBhIHJlbGF0aW9uYWwgb3BlcmF0aW9uIG9uIHR3byB2YWx1ZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wZXJhdG9yIFRoZSBmdW5jdGlvbiB0byBwZXJmb3JtIHRoZSBvcGVyYXRpb24uXHJcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZWxhdGlvbmFsIG9wZXJhdGlvbiBmdW5jdGlvbi5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbihvcGVyYXRvcikge1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XHJcbiAgICAgICAgaWYgKCEodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnICYmIHR5cGVvZiBvdGhlciA9PSAnc3RyaW5nJykpIHtcclxuICAgICAgICAgIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xyXG4gICAgICAgICAgb3RoZXIgPSB0b051bWJlcihvdGhlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvcGVyYXRvcih2YWx1ZSwgb3RoZXIpO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGNvbnRpbnVlIGN1cnJ5aW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHdyYXBGdW5jIFRoZSBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIGBmdW5jYCB3cmFwcGVyLlxyXG4gICAgICogQHBhcmFtIHsqfSBwbGFjZWhvbGRlciBUaGUgcGxhY2Vob2xkZXIgdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQgdG9cclxuICAgICAqICB0aGUgbmV3IGZ1bmN0aW9uLlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNdIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJnUG9zXSBUaGUgYXJndW1lbnQgcG9zaXRpb25zIG9mIHRoZSBuZXcgZnVuY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyeV0gVGhlIGFyaXR5IGNhcCBvZiBgZnVuY2AuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5XSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY3JlYXRlUmVjdXJyeShmdW5jLCBiaXRtYXNrLCB3cmFwRnVuYywgcGxhY2Vob2xkZXIsIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzLCBhcmdQb3MsIGFyeSwgYXJpdHkpIHtcclxuICAgICAgdmFyIGlzQ3VycnkgPSBiaXRtYXNrICYgV1JBUF9DVVJSWV9GTEFHLFxyXG4gICAgICAgICAgbmV3SG9sZGVycyA9IGlzQ3VycnkgPyBob2xkZXJzIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgbmV3SG9sZGVyc1JpZ2h0ID0gaXNDdXJyeSA/IHVuZGVmaW5lZCA6IGhvbGRlcnMsXHJcbiAgICAgICAgICBuZXdQYXJ0aWFscyA9IGlzQ3VycnkgPyBwYXJ0aWFscyA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgIG5ld1BhcnRpYWxzUmlnaHQgPSBpc0N1cnJ5ID8gdW5kZWZpbmVkIDogcGFydGlhbHM7XHJcblxyXG4gICAgICBiaXRtYXNrIHw9IChpc0N1cnJ5ID8gV1JBUF9QQVJUSUFMX0ZMQUcgOiBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyk7XHJcbiAgICAgIGJpdG1hc2sgJj0gfihpc0N1cnJ5ID8gV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcgOiBXUkFQX1BBUlRJQUxfRkxBRyk7XHJcblxyXG4gICAgICBpZiAoIShiaXRtYXNrICYgV1JBUF9DVVJSWV9CT1VORF9GTEFHKSkge1xyXG4gICAgICAgIGJpdG1hc2sgJj0gfihXUkFQX0JJTkRfRkxBRyB8IFdSQVBfQklORF9LRVlfRkxBRyk7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIG5ld0RhdGEgPSBbXHJcbiAgICAgICAgZnVuYywgYml0bWFzaywgdGhpc0FyZywgbmV3UGFydGlhbHMsIG5ld0hvbGRlcnMsIG5ld1BhcnRpYWxzUmlnaHQsXHJcbiAgICAgICAgbmV3SG9sZGVyc1JpZ2h0LCBhcmdQb3MsIGFyeSwgYXJpdHlcclxuICAgICAgXTtcclxuXHJcbiAgICAgIHZhciByZXN1bHQgPSB3cmFwRnVuYy5hcHBseSh1bmRlZmluZWQsIG5ld0RhdGEpO1xyXG4gICAgICBpZiAoaXNMYXppYWJsZShmdW5jKSkge1xyXG4gICAgICAgIHNldERhdGEocmVzdWx0LCBuZXdEYXRhKTtcclxuICAgICAgfVxyXG4gICAgICByZXN1bHQucGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlcjtcclxuICAgICAgcmV0dXJuIHNldFdyYXBUb1N0cmluZyhyZXN1bHQsIGZ1bmMsIGJpdG1hc2spO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8ucm91bmRgLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBUaGUgbmFtZSBvZiB0aGUgYE1hdGhgIG1ldGhvZCB0byB1c2Ugd2hlbiByb3VuZGluZy5cclxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJvdW5kIGZ1bmN0aW9uLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVSb3VuZChtZXRob2ROYW1lKSB7XHJcbiAgICAgIHZhciBmdW5jID0gTWF0aFttZXRob2ROYW1lXTtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG51bWJlciwgcHJlY2lzaW9uKSB7XHJcbiAgICAgICAgbnVtYmVyID0gdG9OdW1iZXIobnVtYmVyKTtcclxuICAgICAgICBwcmVjaXNpb24gPSBwcmVjaXNpb24gPT0gbnVsbCA/IDAgOiBuYXRpdmVNaW4odG9JbnRlZ2VyKHByZWNpc2lvbiksIDI5Mik7XHJcbiAgICAgICAgaWYgKHByZWNpc2lvbiAmJiBuYXRpdmVJc0Zpbml0ZShudW1iZXIpKSB7XHJcbiAgICAgICAgICAvLyBTaGlmdCB3aXRoIGV4cG9uZW50aWFsIG5vdGF0aW9uIHRvIGF2b2lkIGZsb2F0aW5nLXBvaW50IGlzc3Vlcy5cclxuICAgICAgICAgIC8vIFNlZSBbTUROXShodHRwczovL21kbi5pby9yb3VuZCNFeGFtcGxlcykgZm9yIG1vcmUgZGV0YWlscy5cclxuICAgICAgICAgIHZhciBwYWlyID0gKHRvU3RyaW5nKG51bWJlcikgKyAnZScpLnNwbGl0KCdlJyksXHJcbiAgICAgICAgICAgICAgdmFsdWUgPSBmdW5jKHBhaXJbMF0gKyAnZScgKyAoK3BhaXJbMV0gKyBwcmVjaXNpb24pKTtcclxuXHJcbiAgICAgICAgICBwYWlyID0gKHRvU3RyaW5nKHZhbHVlKSArICdlJykuc3BsaXQoJ2UnKTtcclxuICAgICAgICAgIHJldHVybiArKHBhaXJbMF0gKyAnZScgKyAoK3BhaXJbMV0gLSBwcmVjaXNpb24pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZ1bmMobnVtYmVyKTtcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBzZXQgb2JqZWN0IG9mIGB2YWx1ZXNgLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhZGQgdG8gdGhlIHNldC5cclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBzZXQuXHJcbiAgICAgKi9cclxuICAgIHZhciBjcmVhdGVTZXQgPSAhKFNldCAmJiAoMSAvIHNldFRvQXJyYXkobmV3IFNldChbLC0wXSkpWzFdKSA9PSBJTkZJTklUWSkgPyBub29wIDogZnVuY3Rpb24odmFsdWVzKSB7XHJcbiAgICAgIHJldHVybiBuZXcgU2V0KHZhbHVlcyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGBfLnRvUGFpcnNgIG9yIGBfLnRvUGFpcnNJbmAgZnVuY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYSBnaXZlbiBvYmplY3QuXHJcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYWlycyBmdW5jdGlvbi5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY3JlYXRlVG9QYWlycyhrZXlzRnVuYykge1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XHJcbiAgICAgICAgdmFyIHRhZyA9IGdldFRhZyhvYmplY3QpO1xyXG4gICAgICAgIGlmICh0YWcgPT0gbWFwVGFnKSB7XHJcbiAgICAgICAgICByZXR1cm4gbWFwVG9BcnJheShvYmplY3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGFnID09IHNldFRhZykge1xyXG4gICAgICAgICAgcmV0dXJuIHNldFRvUGFpcnMob2JqZWN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJhc2VUb1BhaXJzKG9iamVjdCwga2V5c0Z1bmMob2JqZWN0KSk7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBlaXRoZXIgY3VycmllcyBvciBpbnZva2VzIGBmdW5jYCB3aXRoIG9wdGlvbmFsXHJcbiAgICAgKiBgdGhpc2AgYmluZGluZyBhbmQgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gZnVuYyBUaGUgZnVuY3Rpb24gb3IgbWV0aG9kIG5hbWUgdG8gd3JhcC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxyXG4gICAgICogICAgMSAtIGBfLmJpbmRgXHJcbiAgICAgKiAgICAyIC0gYF8uYmluZEtleWBcclxuICAgICAqICAgIDQgLSBgXy5jdXJyeWAgb3IgYF8uY3VycnlSaWdodGAgb2YgYSBib3VuZCBmdW5jdGlvblxyXG4gICAgICogICAgOCAtIGBfLmN1cnJ5YFxyXG4gICAgICogICAxNiAtIGBfLmN1cnJ5UmlnaHRgXHJcbiAgICAgKiAgIDMyIC0gYF8ucGFydGlhbGBcclxuICAgICAqICAgNjQgLSBgXy5wYXJ0aWFsUmlnaHRgXHJcbiAgICAgKiAgMTI4IC0gYF8ucmVhcmdgXHJcbiAgICAgKiAgMjU2IC0gYF8uYXJ5YFxyXG4gICAgICogIDUxMiAtIGBfLmZsaXBgXHJcbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNdIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJnUG9zXSBUaGUgYXJndW1lbnQgcG9zaXRpb25zIG9mIHRoZSBuZXcgZnVuY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyeV0gVGhlIGFyaXR5IGNhcCBvZiBgZnVuY2AuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5XSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY3JlYXRlV3JhcChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgYXJnUG9zLCBhcnksIGFyaXR5KSB7XHJcbiAgICAgIHZhciBpc0JpbmRLZXkgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0tFWV9GTEFHO1xyXG4gICAgICBpZiAoIWlzQmluZEtleSAmJiB0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBsZW5ndGggPSBwYXJ0aWFscyA/IHBhcnRpYWxzLmxlbmd0aCA6IDA7XHJcbiAgICAgIGlmICghbGVuZ3RoKSB7XHJcbiAgICAgICAgYml0bWFzayAmPSB+KFdSQVBfUEFSVElBTF9GTEFHIHwgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcpO1xyXG4gICAgICAgIHBhcnRpYWxzID0gaG9sZGVycyA9IHVuZGVmaW5lZDtcclxuICAgICAgfVxyXG4gICAgICBhcnkgPSBhcnkgPT09IHVuZGVmaW5lZCA/IGFyeSA6IG5hdGl2ZU1heCh0b0ludGVnZXIoYXJ5KSwgMCk7XHJcbiAgICAgIGFyaXR5ID0gYXJpdHkgPT09IHVuZGVmaW5lZCA/IGFyaXR5IDogdG9JbnRlZ2VyKGFyaXR5KTtcclxuICAgICAgbGVuZ3RoIC09IGhvbGRlcnMgPyBob2xkZXJzLmxlbmd0aCA6IDA7XHJcblxyXG4gICAgICBpZiAoYml0bWFzayAmIFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHKSB7XHJcbiAgICAgICAgdmFyIHBhcnRpYWxzUmlnaHQgPSBwYXJ0aWFscyxcclxuICAgICAgICAgICAgaG9sZGVyc1JpZ2h0ID0gaG9sZGVycztcclxuXHJcbiAgICAgICAgcGFydGlhbHMgPSBob2xkZXJzID0gdW5kZWZpbmVkO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBkYXRhID0gaXNCaW5kS2V5ID8gdW5kZWZpbmVkIDogZ2V0RGF0YShmdW5jKTtcclxuXHJcbiAgICAgIHZhciBuZXdEYXRhID0gW1xyXG4gICAgICAgIGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzLCBwYXJ0aWFsc1JpZ2h0LCBob2xkZXJzUmlnaHQsXHJcbiAgICAgICAgYXJnUG9zLCBhcnksIGFyaXR5XHJcbiAgICAgIF07XHJcblxyXG4gICAgICBpZiAoZGF0YSkge1xyXG4gICAgICAgIG1lcmdlRGF0YShuZXdEYXRhLCBkYXRhKTtcclxuICAgICAgfVxyXG4gICAgICBmdW5jID0gbmV3RGF0YVswXTtcclxuICAgICAgYml0bWFzayA9IG5ld0RhdGFbMV07XHJcbiAgICAgIHRoaXNBcmcgPSBuZXdEYXRhWzJdO1xyXG4gICAgICBwYXJ0aWFscyA9IG5ld0RhdGFbM107XHJcbiAgICAgIGhvbGRlcnMgPSBuZXdEYXRhWzRdO1xyXG4gICAgICBhcml0eSA9IG5ld0RhdGFbOV0gPSBuZXdEYXRhWzldID09PSB1bmRlZmluZWRcclxuICAgICAgICA/IChpc0JpbmRLZXkgPyAwIDogZnVuYy5sZW5ndGgpXHJcbiAgICAgICAgOiBuYXRpdmVNYXgobmV3RGF0YVs5XSAtIGxlbmd0aCwgMCk7XHJcblxyXG4gICAgICBpZiAoIWFyaXR5ICYmIGJpdG1hc2sgJiAoV1JBUF9DVVJSWV9GTEFHIHwgV1JBUF9DVVJSWV9SSUdIVF9GTEFHKSkge1xyXG4gICAgICAgIGJpdG1hc2sgJj0gfihXUkFQX0NVUlJZX0ZMQUcgfCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghYml0bWFzayB8fCBiaXRtYXNrID09IFdSQVBfQklORF9GTEFHKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZUJpbmQoZnVuYywgYml0bWFzaywgdGhpc0FyZyk7XHJcbiAgICAgIH0gZWxzZSBpZiAoYml0bWFzayA9PSBXUkFQX0NVUlJZX0ZMQUcgfHwgYml0bWFzayA9PSBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcpIHtcclxuICAgICAgICByZXN1bHQgPSBjcmVhdGVDdXJyeShmdW5jLCBiaXRtYXNrLCBhcml0eSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoKGJpdG1hc2sgPT0gV1JBUF9QQVJUSUFMX0ZMQUcgfHwgYml0bWFzayA9PSAoV1JBUF9CSU5EX0ZMQUcgfCBXUkFQX1BBUlRJQUxfRkxBRykpICYmICFob2xkZXJzLmxlbmd0aCkge1xyXG4gICAgICAgIHJlc3VsdCA9IGNyZWF0ZVBhcnRpYWwoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJlc3VsdCA9IGNyZWF0ZUh5YnJpZC5hcHBseSh1bmRlZmluZWQsIG5ld0RhdGEpO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBzZXR0ZXIgPSBkYXRhID8gYmFzZVNldERhdGEgOiBzZXREYXRhO1xyXG4gICAgICByZXR1cm4gc2V0V3JhcFRvU3RyaW5nKHNldHRlcihyZXN1bHQsIG5ld0RhdGEpLCBmdW5jLCBiaXRtYXNrKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVzZWQgYnkgYF8uZGVmYXVsdHNgIHRvIGN1c3RvbWl6ZSBpdHMgYF8uYXNzaWduSW5gIHVzZSB0byBhc3NpZ24gcHJvcGVydGllc1xyXG4gICAgICogb2Ygc291cmNlIG9iamVjdHMgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdCBmb3IgYWxsIGRlc3RpbmF0aW9uIHByb3BlcnRpZXNcclxuICAgICAqIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHsqfSBvYmpWYWx1ZSBUaGUgZGVzdGluYXRpb24gdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSBzb3VyY2UgdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHBhcmVudCBvYmplY3Qgb2YgYG9ialZhbHVlYC5cclxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB2YWx1ZSB0byBhc3NpZ24uXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGN1c3RvbURlZmF1bHRzQXNzaWduSW4ob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCkge1xyXG4gICAgICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCB8fFxyXG4gICAgICAgICAgKGVxKG9ialZhbHVlLCBvYmplY3RQcm90b1trZXldKSAmJiAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSB7XHJcbiAgICAgICAgcmV0dXJuIHNyY1ZhbHVlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBvYmpWYWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVzZWQgYnkgYF8uZGVmYXVsdHNEZWVwYCB0byBjdXN0b21pemUgaXRzIGBfLm1lcmdlYCB1c2UgdG8gbWVyZ2Ugc291cmNlXHJcbiAgICAgKiBvYmplY3RzIGludG8gZGVzdGluYXRpb24gb2JqZWN0cyB0aGF0IGFyZSBwYXNzZWQgdGhydS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHsqfSBvYmpWYWx1ZSBUaGUgZGVzdGluYXRpb24gdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSBzb3VyY2UgdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIG1lcmdlLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgcGFyZW50IG9iamVjdCBvZiBgb2JqVmFsdWVgLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgcGFyZW50IG9iamVjdCBvZiBgc3JjVmFsdWVgLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcclxuICAgICAqICBjb3VudGVycGFydHMuXHJcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdmFsdWUgdG8gYXNzaWduLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjdXN0b21EZWZhdWx0c01lcmdlKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spIHtcclxuICAgICAgaWYgKGlzT2JqZWN0KG9ialZhbHVlKSAmJiBpc09iamVjdChzcmNWYWx1ZSkpIHtcclxuICAgICAgICAvLyBSZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cclxuICAgICAgICBzdGFjay5zZXQoc3JjVmFsdWUsIG9ialZhbHVlKTtcclxuICAgICAgICBiYXNlTWVyZ2Uob2JqVmFsdWUsIHNyY1ZhbHVlLCB1bmRlZmluZWQsIGN1c3RvbURlZmF1bHRzTWVyZ2UsIHN0YWNrKTtcclxuICAgICAgICBzdGFja1snZGVsZXRlJ10oc3JjVmFsdWUpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBvYmpWYWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVzZWQgYnkgYF8ub21pdGAgdG8gY3VzdG9taXplIGl0cyBgXy5jbG9uZURlZXBgIHVzZSB0byBvbmx5IGNsb25lIHBsYWluXHJcbiAgICAgKiBvYmplY3RzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBpbnNwZWN0LlxyXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHVuY2xvbmVkIHZhbHVlIG9yIGB1bmRlZmluZWRgIHRvIGRlZmVyIGNsb25pbmcgdG8gYF8uY2xvbmVEZWVwYC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY3VzdG9tT21pdENsb25lKHZhbHVlKSB7XHJcbiAgICAgIHJldHVybiBpc1BsYWluT2JqZWN0KHZhbHVlKSA/IHVuZGVmaW5lZCA6IHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBhcnJheXMgd2l0aCBzdXBwb3J0IGZvclxyXG4gICAgICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFyZS5cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG90aGVyIFRoZSBvdGhlciBhcnJheSB0byBjb21wYXJlLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgYXJyYXlgIGFuZCBgb3RoZXJgIG9iamVjdHMuXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFycmF5cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBlcXVhbEFycmF5cyhhcnJheSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcclxuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcclxuICAgICAgICAgIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcclxuICAgICAgICAgIG90aExlbmd0aCA9IG90aGVyLmxlbmd0aDtcclxuXHJcbiAgICAgIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgLy8gQ2hlY2sgdGhhdCBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cclxuICAgICAgdmFyIGFyclN0YWNrZWQgPSBzdGFjay5nZXQoYXJyYXkpO1xyXG4gICAgICB2YXIgb3RoU3RhY2tlZCA9IHN0YWNrLmdldChvdGhlcik7XHJcbiAgICAgIGlmIChhcnJTdGFja2VkICYmIG90aFN0YWNrZWQpIHtcclxuICAgICAgICByZXR1cm4gYXJyU3RhY2tlZCA9PSBvdGhlciAmJiBvdGhTdGFja2VkID09IGFycmF5O1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBpbmRleCA9IC0xLFxyXG4gICAgICAgICAgcmVzdWx0ID0gdHJ1ZSxcclxuICAgICAgICAgIHNlZW4gPSAoYml0bWFzayAmIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xyXG5cclxuICAgICAgc3RhY2suc2V0KGFycmF5LCBvdGhlcik7XHJcbiAgICAgIHN0YWNrLnNldChvdGhlciwgYXJyYXkpO1xyXG5cclxuICAgICAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxyXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xyXG4gICAgICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcclxuICAgICAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XHJcblxyXG4gICAgICAgIGlmIChjdXN0b21pemVyKSB7XHJcbiAgICAgICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcclxuICAgICAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spXHJcbiAgICAgICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIGlmIChjb21wYXJlZCkge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXHJcbiAgICAgICAgaWYgKHNlZW4pIHtcclxuICAgICAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIGlmICghY2FjaGVIYXMoc2Vlbiwgb3RoSW5kZXgpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpKSB7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0pKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKCEoXHJcbiAgICAgICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XHJcbiAgICAgICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaylcclxuICAgICAgICAgICAgKSkge1xyXG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcclxuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgY29tcGFyaW5nIG9iamVjdHMgb2ZcclxuICAgICAqIHRoZSBzYW1lIGB0b1N0cmluZ1RhZ2AuXHJcbiAgICAgKlxyXG4gICAgICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjb21wYXJpbmcgdmFsdWVzIHdpdGggdGFncyBvZlxyXG4gICAgICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdHMgdG8gY29tcGFyZS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIHRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xyXG4gICAgICBzd2l0Y2ggKHRhZykge1xyXG4gICAgICAgIGNhc2UgZGF0YVZpZXdUYWc6XHJcbiAgICAgICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XHJcbiAgICAgICAgICAgICAgKG9iamVjdC5ieXRlT2Zmc2V0ICE9IG90aGVyLmJ5dGVPZmZzZXQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIG9iamVjdCA9IG9iamVjdC5idWZmZXI7XHJcbiAgICAgICAgICBvdGhlciA9IG90aGVyLmJ1ZmZlcjtcclxuXHJcbiAgICAgICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcclxuICAgICAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcclxuICAgICAgICAgICAgICAhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5KG9iamVjdCksIG5ldyBVaW50OEFycmF5KG90aGVyKSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICAgIGNhc2UgYm9vbFRhZzpcclxuICAgICAgICBjYXNlIGRhdGVUYWc6XHJcbiAgICAgICAgY2FzZSBudW1iZXJUYWc6XHJcbiAgICAgICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxyXG4gICAgICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cclxuICAgICAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xyXG5cclxuICAgICAgICBjYXNlIGVycm9yVGFnOlxyXG4gICAgICAgICAgcmV0dXJuIG9iamVjdC5uYW1lID09IG90aGVyLm5hbWUgJiYgb2JqZWN0Lm1lc3NhZ2UgPT0gb3RoZXIubWVzc2FnZTtcclxuXHJcbiAgICAgICAgY2FzZSByZWdleHBUYWc6XHJcbiAgICAgICAgY2FzZSBzdHJpbmdUYWc6XHJcbiAgICAgICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzLCBwcmltaXRpdmVzIGFuZCBvYmplY3RzLFxyXG4gICAgICAgICAgLy8gYXMgZXF1YWwuIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xyXG4gICAgICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cclxuICAgICAgICAgIHJldHVybiBvYmplY3QgPT0gKG90aGVyICsgJycpO1xyXG5cclxuICAgICAgICBjYXNlIG1hcFRhZzpcclxuICAgICAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcclxuXHJcbiAgICAgICAgY2FzZSBzZXRUYWc6XHJcbiAgICAgICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHO1xyXG4gICAgICAgICAgY29udmVydCB8fCAoY29udmVydCA9IHNldFRvQXJyYXkpO1xyXG5cclxuICAgICAgICAgIGlmIChvYmplY3Quc2l6ZSAhPSBvdGhlci5zaXplICYmICFpc1BhcnRpYWwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxyXG4gICAgICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcclxuICAgICAgICAgIGlmIChzdGFja2VkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYml0bWFzayB8PSBDT01QQVJFX1VOT1JERVJFRF9GTEFHO1xyXG5cclxuICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxyXG4gICAgICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xyXG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xyXG4gICAgICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XHJcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG5cclxuICAgICAgICBjYXNlIHN5bWJvbFRhZzpcclxuICAgICAgICAgIGlmIChzeW1ib2xWYWx1ZU9mKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzeW1ib2xWYWx1ZU9mLmNhbGwob2JqZWN0KSA9PSBzeW1ib2xWYWx1ZU9mLmNhbGwob3RoZXIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXHJcbiAgICAgKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xyXG4gICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxyXG4gICAgICAgICAgb2JqUHJvcHMgPSBnZXRBbGxLZXlzKG9iamVjdCksXHJcbiAgICAgICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXHJcbiAgICAgICAgICBvdGhQcm9wcyA9IGdldEFsbEtleXMob3RoZXIpLFxyXG4gICAgICAgICAgb3RoTGVuZ3RoID0gb3RoUHJvcHMubGVuZ3RoO1xyXG5cclxuICAgICAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XHJcbiAgICAgIHdoaWxlIChpbmRleC0tKSB7XHJcbiAgICAgICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcclxuICAgICAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICAvLyBDaGVjayB0aGF0IGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxyXG4gICAgICB2YXIgb2JqU3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xyXG4gICAgICB2YXIgb3RoU3RhY2tlZCA9IHN0YWNrLmdldChvdGhlcik7XHJcbiAgICAgIGlmIChvYmpTdGFja2VkICYmIG90aFN0YWNrZWQpIHtcclxuICAgICAgICByZXR1cm4gb2JqU3RhY2tlZCA9PSBvdGhlciAmJiBvdGhTdGFja2VkID09IG9iamVjdDtcclxuICAgICAgfVxyXG4gICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcclxuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xyXG4gICAgICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XHJcblxyXG4gICAgICB2YXIgc2tpcEN0b3IgPSBpc1BhcnRpYWw7XHJcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XHJcbiAgICAgICAga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xyXG4gICAgICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxyXG4gICAgICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2tleV07XHJcblxyXG4gICAgICAgIGlmIChjdXN0b21pemVyKSB7XHJcbiAgICAgICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcclxuICAgICAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBvYmpWYWx1ZSwga2V5LCBvdGhlciwgb2JqZWN0LCBzdGFjaylcclxuICAgICAgICAgICAgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5LCBvYmplY3QsIG90aGVyLCBzdGFjayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxyXG4gICAgICAgIGlmICghKGNvbXBhcmVkID09PSB1bmRlZmluZWRcclxuICAgICAgICAgICAgICA/IChvYmpWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKVxyXG4gICAgICAgICAgICAgIDogY29tcGFyZWRcclxuICAgICAgICAgICAgKSkge1xyXG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChyZXN1bHQgJiYgIXNraXBDdG9yKSB7XHJcbiAgICAgICAgdmFyIG9iakN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXHJcbiAgICAgICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgICAgICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXHJcbiAgICAgICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxyXG4gICAgICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcclxuICAgICAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXHJcbiAgICAgICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcclxuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcclxuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIGZsYXR0ZW5zIHRoZSByZXN0IGFycmF5LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZsYXRSZXN0KGZ1bmMpIHtcclxuICAgICAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHVuZGVmaW5lZCwgZmxhdHRlbiksIGZ1bmMgKyAnJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xyXG4gICAgICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcclxuICAgICAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cclxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldEFsbEtleXNJbihvYmplY3QpIHtcclxuICAgICAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0luLCBnZXRTeW1ib2xzSW4pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBtZXRhZGF0YSBmb3IgYGZ1bmNgLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBxdWVyeS5cclxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtZXRhZGF0YSBmb3IgYGZ1bmNgLlxyXG4gICAgICovXHJcbiAgICB2YXIgZ2V0RGF0YSA9ICFtZXRhTWFwID8gbm9vcCA6IGZ1bmN0aW9uKGZ1bmMpIHtcclxuICAgICAgcmV0dXJuIG1ldGFNYXAuZ2V0KGZ1bmMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIG5hbWUgb2YgYGZ1bmNgLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBxdWVyeS5cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGZ1bmN0aW9uIG5hbWUuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldEZ1bmNOYW1lKGZ1bmMpIHtcclxuICAgICAgdmFyIHJlc3VsdCA9IChmdW5jLm5hbWUgKyAnJyksXHJcbiAgICAgICAgICBhcnJheSA9IHJlYWxOYW1lc1tyZXN1bHRdLFxyXG4gICAgICAgICAgbGVuZ3RoID0gaGFzT3duUHJvcGVydHkuY2FsbChyZWFsTmFtZXMsIHJlc3VsdCkgPyBhcnJheS5sZW5ndGggOiAwO1xyXG5cclxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSBhcnJheVtsZW5ndGhdLFxyXG4gICAgICAgICAgICBvdGhlckZ1bmMgPSBkYXRhLmZ1bmM7XHJcbiAgICAgICAgaWYgKG90aGVyRnVuYyA9PSBudWxsIHx8IG90aGVyRnVuYyA9PSBmdW5jKSB7XHJcbiAgICAgICAgICByZXR1cm4gZGF0YS5uYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgYXJndW1lbnQgcGxhY2Vob2xkZXIgdmFsdWUgZm9yIGBmdW5jYC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW5zcGVjdC5cclxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwbGFjZWhvbGRlciB2YWx1ZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0SG9sZGVyKGZ1bmMpIHtcclxuICAgICAgdmFyIG9iamVjdCA9IGhhc093blByb3BlcnR5LmNhbGwobG9kYXNoLCAncGxhY2Vob2xkZXInKSA/IGxvZGFzaCA6IGZ1bmM7XHJcbiAgICAgIHJldHVybiBvYmplY3QucGxhY2Vob2xkZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBhcHByb3ByaWF0ZSBcIml0ZXJhdGVlXCIgZnVuY3Rpb24uIElmIGBfLml0ZXJhdGVlYCBpcyBjdXN0b21pemVkLFxyXG4gICAgICogdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSBjdXN0b20gbWV0aG9kLCBvdGhlcndpc2UgaXQgcmV0dXJucyBgYmFzZUl0ZXJhdGVlYC5cclxuICAgICAqIElmIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQsIHRoZSBjaG9zZW4gZnVuY3Rpb24gaXMgaW52b2tlZCB3aXRoIHRoZW0gYW5kXHJcbiAgICAgKiBpdHMgcmVzdWx0IGlzIHJldHVybmVkLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0geyp9IFt2YWx1ZV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYW4gaXRlcmF0ZWUuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5XSBUaGUgYXJpdHkgb2YgdGhlIGNyZWF0ZWQgaXRlcmF0ZWUuXHJcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNob3NlbiBmdW5jdGlvbiBvciBpdHMgcmVzdWx0LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRJdGVyYXRlZSgpIHtcclxuICAgICAgdmFyIHJlc3VsdCA9IGxvZGFzaC5pdGVyYXRlZSB8fCBpdGVyYXRlZTtcclxuICAgICAgcmVzdWx0ID0gcmVzdWx0ID09PSBpdGVyYXRlZSA/IGJhc2VJdGVyYXRlZSA6IHJlc3VsdDtcclxuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyByZXN1bHQoYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0pIDogcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXHJcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcclxuICAgICAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XHJcbiAgICAgIHJldHVybiBpc0tleWFibGUoa2V5KVxyXG4gICAgICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXHJcbiAgICAgICAgOiBkYXRhLm1hcDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIG9mIGBvYmplY3RgLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG1hdGNoIGRhdGEgb2YgYG9iamVjdGAuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcclxuICAgICAgdmFyIHJlc3VsdCA9IGtleXMob2JqZWN0KSxcclxuICAgICAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XHJcblxyXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcclxuICAgICAgICB2YXIga2V5ID0gcmVzdWx0W2xlbmd0aF0sXHJcbiAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XHJcblxyXG4gICAgICAgIHJlc3VsdFtsZW5ndGhdID0gW2tleSwgdmFsdWUsIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSldO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cclxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XHJcbiAgICAgIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcclxuICAgICAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xyXG4gICAgICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXHJcbiAgICAgICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XHJcblxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xyXG4gICAgICB9IGNhdGNoIChlKSB7fVxyXG5cclxuICAgICAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xyXG4gICAgICBpZiAodW5tYXNrZWQpIHtcclxuICAgICAgICBpZiAoaXNPd24pIHtcclxuICAgICAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cclxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cclxuICAgICAqL1xyXG4gICAgdmFyIGdldFN5bWJvbHMgPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xyXG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICAgIH1cclxuICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XHJcbiAgICAgIHJldHVybiBhcnJheUZpbHRlcihuYXRpdmVHZXRTeW1ib2xzKG9iamVjdCksIGZ1bmN0aW9uKHN5bWJvbCkge1xyXG4gICAgICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKTtcclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXHJcbiAgICAgKi9cclxuICAgIHZhciBnZXRTeW1ib2xzSW4gPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xyXG4gICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgIHdoaWxlIChvYmplY3QpIHtcclxuICAgICAgICBhcnJheVB1c2gocmVzdWx0LCBnZXRTeW1ib2xzKG9iamVjdCkpO1xyXG4gICAgICAgIG9iamVjdCA9IGdldFByb3RvdHlwZShvYmplY3QpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXHJcbiAgICAgKi9cclxuICAgIHZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xyXG5cclxuICAgIC8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzIDwgNi5cclxuICAgIGlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcclxuICAgICAgICAoTWFwICYmIGdldFRhZyhuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XHJcbiAgICAgICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxyXG4gICAgICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcclxuICAgICAgICAoV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXApICE9IHdlYWtNYXBUYWcpKSB7XHJcbiAgICAgIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IGJhc2VHZXRUYWcodmFsdWUpLFxyXG4gICAgICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogJyc7XHJcblxyXG4gICAgICAgIGlmIChjdG9yU3RyaW5nKSB7XHJcbiAgICAgICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcclxuICAgICAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcclxuICAgICAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xyXG4gICAgICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcclxuICAgICAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xyXG4gICAgICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHZpZXcsIGFwcGx5aW5nIGFueSBgdHJhbnNmb3Jtc2AgdG8gdGhlIGBzdGFydGAgYW5kIGBlbmRgIHBvc2l0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBvZiB0aGUgdmlldy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgdmlldy5cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHRyYW5zZm9ybXMgVGhlIHRyYW5zZm9ybWF0aW9ucyB0byBhcHBseSB0byB0aGUgdmlldy5cclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGBzdGFydGAgYW5kIGBlbmRgXHJcbiAgICAgKiAgcG9zaXRpb25zIG9mIHRoZSB2aWV3LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRWaWV3KHN0YXJ0LCBlbmQsIHRyYW5zZm9ybXMpIHtcclxuICAgICAgdmFyIGluZGV4ID0gLTEsXHJcbiAgICAgICAgICBsZW5ndGggPSB0cmFuc2Zvcm1zLmxlbmd0aDtcclxuXHJcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSB0cmFuc2Zvcm1zW2luZGV4XSxcclxuICAgICAgICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcclxuXHJcbiAgICAgICAgc3dpdGNoIChkYXRhLnR5cGUpIHtcclxuICAgICAgICAgIGNhc2UgJ2Ryb3AnOiAgICAgIHN0YXJ0ICs9IHNpemU7IGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAnZHJvcFJpZ2h0JzogZW5kIC09IHNpemU7IGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAndGFrZSc6ICAgICAgZW5kID0gbmF0aXZlTWluKGVuZCwgc3RhcnQgKyBzaXplKTsgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICd0YWtlUmlnaHQnOiBzdGFydCA9IG5hdGl2ZU1heChzdGFydCwgZW5kIC0gc2l6ZSk7IGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4geyAnc3RhcnQnOiBzdGFydCwgJ2VuZCc6IGVuZCB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRXh0cmFjdHMgd3JhcHBlciBkZXRhaWxzIGZyb20gdGhlIGBzb3VyY2VgIGJvZHkgY29tbWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSBUaGUgc291cmNlIHRvIGluc3BlY3QuXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdyYXBwZXIgZGV0YWlscy5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0V3JhcERldGFpbHMoc291cmNlKSB7XHJcbiAgICAgIHZhciBtYXRjaCA9IHNvdXJjZS5tYXRjaChyZVdyYXBEZXRhaWxzKTtcclxuICAgICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0uc3BsaXQocmVTcGxpdERldGFpbHMpIDogW107XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgYHBhdGhgIGV4aXN0cyBvbiBgb2JqZWN0YC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxyXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYXNGdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjayBwcm9wZXJ0aWVzLlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaGFzUGF0aChvYmplY3QsIHBhdGgsIGhhc0Z1bmMpIHtcclxuICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XHJcblxyXG4gICAgICB2YXIgaW5kZXggPSAtMSxcclxuICAgICAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxyXG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XHJcblxyXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xyXG4gICAgICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XHJcbiAgICAgICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHJlc3VsdCB8fCArK2luZGV4ICE9IGxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgIH1cclxuICAgICAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogb2JqZWN0Lmxlbmd0aDtcclxuICAgICAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiZcclxuICAgICAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6ZXMgYW4gYXJyYXkgY2xvbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjbG9uZS5cclxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGluaXRDbG9uZUFycmF5KGFycmF5KSB7XHJcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXHJcbiAgICAgICAgICByZXN1bHQgPSBuZXcgYXJyYXkuY29uc3RydWN0b3IobGVuZ3RoKTtcclxuXHJcbiAgICAgIC8vIEFkZCBwcm9wZXJ0aWVzIGFzc2lnbmVkIGJ5IGBSZWdFeHAjZXhlY2AuXHJcbiAgICAgIGlmIChsZW5ndGggJiYgdHlwZW9mIGFycmF5WzBdID09ICdzdHJpbmcnICYmIGhhc093blByb3BlcnR5LmNhbGwoYXJyYXksICdpbmRleCcpKSB7XHJcbiAgICAgICAgcmVzdWx0LmluZGV4ID0gYXJyYXkuaW5kZXg7XHJcbiAgICAgICAgcmVzdWx0LmlucHV0ID0gYXJyYXkuaW5wdXQ7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxyXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGluaXRDbG9uZU9iamVjdChvYmplY3QpIHtcclxuICAgICAgcmV0dXJuICh0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgIWlzUHJvdG90eXBlKG9iamVjdCkpXHJcbiAgICAgICAgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKVxyXG4gICAgICAgIDoge307XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUgYmFzZWQgb24gaXRzIGB0b1N0cmluZ1RhZ2AuXHJcbiAgICAgKlxyXG4gICAgICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjbG9uaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcclxuICAgICAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTWFwYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBgU2V0YCwgb3IgYFN0cmluZ2AuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdCB0byBjbG9uZS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaW5pdENsb25lQnlUYWcob2JqZWN0LCB0YWcsIGlzRGVlcCkge1xyXG4gICAgICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcclxuICAgICAgc3dpdGNoICh0YWcpIHtcclxuICAgICAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxyXG4gICAgICAgICAgcmV0dXJuIGNsb25lQXJyYXlCdWZmZXIob2JqZWN0KTtcclxuXHJcbiAgICAgICAgY2FzZSBib29sVGFnOlxyXG4gICAgICAgIGNhc2UgZGF0ZVRhZzpcclxuICAgICAgICAgIHJldHVybiBuZXcgQ3Rvcigrb2JqZWN0KTtcclxuXHJcbiAgICAgICAgY2FzZSBkYXRhVmlld1RhZzpcclxuICAgICAgICAgIHJldHVybiBjbG9uZURhdGFWaWV3KG9iamVjdCwgaXNEZWVwKTtcclxuXHJcbiAgICAgICAgY2FzZSBmbG9hdDMyVGFnOiBjYXNlIGZsb2F0NjRUYWc6XHJcbiAgICAgICAgY2FzZSBpbnQ4VGFnOiBjYXNlIGludDE2VGFnOiBjYXNlIGludDMyVGFnOlxyXG4gICAgICAgIGNhc2UgdWludDhUYWc6IGNhc2UgdWludDhDbGFtcGVkVGFnOiBjYXNlIHVpbnQxNlRhZzogY2FzZSB1aW50MzJUYWc6XHJcbiAgICAgICAgICByZXR1cm4gY2xvbmVUeXBlZEFycmF5KG9iamVjdCwgaXNEZWVwKTtcclxuXHJcbiAgICAgICAgY2FzZSBtYXBUYWc6XHJcbiAgICAgICAgICByZXR1cm4gbmV3IEN0b3I7XHJcblxyXG4gICAgICAgIGNhc2UgbnVtYmVyVGFnOlxyXG4gICAgICAgIGNhc2Ugc3RyaW5nVGFnOlxyXG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yKG9iamVjdCk7XHJcblxyXG4gICAgICAgIGNhc2UgcmVnZXhwVGFnOlxyXG4gICAgICAgICAgcmV0dXJuIGNsb25lUmVnRXhwKG9iamVjdCk7XHJcblxyXG4gICAgICAgIGNhc2Ugc2V0VGFnOlxyXG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yO1xyXG5cclxuICAgICAgICBjYXNlIHN5bWJvbFRhZzpcclxuICAgICAgICAgIHJldHVybiBjbG9uZVN5bWJvbChvYmplY3QpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnNlcnRzIHdyYXBwZXIgYGRldGFpbHNgIGluIGEgY29tbWVudCBhdCB0aGUgdG9wIG9mIHRoZSBgc291cmNlYCBib2R5LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIFRoZSBzb3VyY2UgdG8gbW9kaWZ5LlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBkZXRhaWxzIFRoZSBkZXRhaWxzIHRvIGluc2VydC5cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIG1vZGlmaWVkIHNvdXJjZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaW5zZXJ0V3JhcERldGFpbHMoc291cmNlLCBkZXRhaWxzKSB7XHJcbiAgICAgIHZhciBsZW5ndGggPSBkZXRhaWxzLmxlbmd0aDtcclxuICAgICAgaWYgKCFsZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gc291cmNlO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBsYXN0SW5kZXggPSBsZW5ndGggLSAxO1xyXG4gICAgICBkZXRhaWxzW2xhc3RJbmRleF0gPSAobGVuZ3RoID4gMSA/ICcmICcgOiAnJykgKyBkZXRhaWxzW2xhc3RJbmRleF07XHJcbiAgICAgIGRldGFpbHMgPSBkZXRhaWxzLmpvaW4obGVuZ3RoID4gMiA/ICcsICcgOiAnICcpO1xyXG4gICAgICByZXR1cm4gc291cmNlLnJlcGxhY2UocmVXcmFwQ29tbWVudCwgJ3tcXG4vKiBbd3JhcHBlZCB3aXRoICcgKyBkZXRhaWxzICsgJ10gKi9cXG4nKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZmxhdHRlbmFibGUgYGFyZ3VtZW50c2Agb2JqZWN0IG9yIGFycmF5LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZsYXR0ZW5hYmxlLCBlbHNlIGBmYWxzZWAuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlzRmxhdHRlbmFibGUodmFsdWUpIHtcclxuICAgICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSB8fFxyXG4gICAgICAgICEhKHNwcmVhZGFibGVTeW1ib2wgJiYgdmFsdWUgJiYgdmFsdWVbc3ByZWFkYWJsZVN5bWJvbF0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XHJcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xyXG4gICAgICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XHJcblxyXG4gICAgICByZXR1cm4gISFsZW5ndGggJiZcclxuICAgICAgICAodHlwZSA9PSAnbnVtYmVyJyB8fFxyXG4gICAgICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxyXG4gICAgICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXHJcbiAgICAgKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxyXG4gICAgICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLFxyXG4gICAgICogIGVsc2UgYGZhbHNlYC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHtcclxuICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xyXG4gICAgICBpZiAodHlwZSA9PSAnbnVtYmVyJ1xyXG4gICAgICAgICAgICA/IChpc0FycmF5TGlrZShvYmplY3QpICYmIGlzSW5kZXgoaW5kZXgsIG9iamVjdC5sZW5ndGgpKVxyXG4gICAgICAgICAgICA6ICh0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdClcclxuICAgICAgICAgICkge1xyXG4gICAgICAgIHJldHVybiBlcShvYmplY3RbaW5kZXhdLCB2YWx1ZSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lIGFuZCBub3QgYSBwcm9wZXJ0eSBwYXRoLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUsIGVsc2UgYGZhbHNlYC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXNLZXkodmFsdWUsIG9iamVjdCkge1xyXG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XHJcbiAgICAgIGlmICh0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicgfHxcclxuICAgICAgICAgIHZhbHVlID09IG51bGwgfHwgaXNTeW1ib2wodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKSB8fFxyXG4gICAgICAgIChvYmplY3QgIT0gbnVsbCAmJiB2YWx1ZSBpbiBPYmplY3Qob2JqZWN0KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xyXG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcclxuICAgICAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcclxuICAgICAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXHJcbiAgICAgICAgOiAodmFsdWUgPT09IG51bGwpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgYSBsYXp5IGNvdW50ZXJwYXJ0LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaGFzIGEgbGF6eSBjb3VudGVycGFydCxcclxuICAgICAqICBlbHNlIGBmYWxzZWAuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlzTGF6aWFibGUoZnVuYykge1xyXG4gICAgICB2YXIgZnVuY05hbWUgPSBnZXRGdW5jTmFtZShmdW5jKSxcclxuICAgICAgICAgIG90aGVyID0gbG9kYXNoW2Z1bmNOYW1lXTtcclxuXHJcbiAgICAgIGlmICh0eXBlb2Ygb3RoZXIgIT0gJ2Z1bmN0aW9uJyB8fCAhKGZ1bmNOYW1lIGluIExhenlXcmFwcGVyLnByb3RvdHlwZSkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGZ1bmMgPT09IG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGRhdGEgPSBnZXREYXRhKG90aGVyKTtcclxuICAgICAgcmV0dXJuICEhZGF0YSAmJiBmdW5jID09PSBkYXRhWzBdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xyXG4gICAgICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIGBmdW5jYCBpcyBjYXBhYmxlIG9mIGJlaW5nIG1hc2tlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2thYmxlLCBlbHNlIGBmYWxzZWAuXHJcbiAgICAgKi9cclxuICAgIHZhciBpc01hc2thYmxlID0gY29yZUpzRGF0YSA/IGlzRnVuY3Rpb24gOiBzdHViRmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XHJcbiAgICAgIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXHJcbiAgICAgICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcclxuXHJcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlmIHN1aXRhYmxlIGZvciBzdHJpY3RcclxuICAgICAqICBlcXVhbGl0eSBjb21wYXJpc29ucywgZWxzZSBgZmFsc2VgLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpIHtcclxuICAgICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSAmJiAhaXNPYmplY3QodmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBtYXRjaGVzUHJvcGVydHlgIGZvciBzb3VyY2UgdmFsdWVzIHN1aXRhYmxlXHJcbiAgICAgKiBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cclxuICAgICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUoa2V5LCBzcmNWYWx1ZSkge1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XHJcbiAgICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvYmplY3Rba2V5XSA9PT0gc3JjVmFsdWUgJiZcclxuICAgICAgICAgIChzcmNWYWx1ZSAhPT0gdW5kZWZpbmVkIHx8IChrZXkgaW4gT2JqZWN0KG9iamVjdCkpKTtcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tZW1vaXplYCB3aGljaCBjbGVhcnMgdGhlIG1lbW9pemVkIGZ1bmN0aW9uJ3NcclxuICAgICAqIGNhY2hlIHdoZW4gaXQgZXhjZWVkcyBgTUFYX01FTU9JWkVfU0laRWAuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cclxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBtZW1vaXplQ2FwcGVkKGZ1bmMpIHtcclxuICAgICAgdmFyIHJlc3VsdCA9IG1lbW9pemUoZnVuYywgZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgICAgaWYgKGNhY2hlLnNpemUgPT09IE1BWF9NRU1PSVpFX1NJWkUpIHtcclxuICAgICAgICAgIGNhY2hlLmNsZWFyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBrZXk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdmFyIGNhY2hlID0gcmVzdWx0LmNhY2hlO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWVyZ2VzIHRoZSBmdW5jdGlvbiBtZXRhZGF0YSBvZiBgc291cmNlYCBpbnRvIGBkYXRhYC5cclxuICAgICAqXHJcbiAgICAgKiBNZXJnaW5nIG1ldGFkYXRhIHJlZHVjZXMgdGhlIG51bWJlciBvZiB3cmFwcGVycyB1c2VkIHRvIGludm9rZSBhIGZ1bmN0aW9uLlxyXG4gICAgICogVGhpcyBpcyBwb3NzaWJsZSBiZWNhdXNlIG1ldGhvZHMgbGlrZSBgXy5iaW5kYCwgYF8uY3VycnlgLCBhbmQgYF8ucGFydGlhbGBcclxuICAgICAqIG1heSBiZSBhcHBsaWVkIHJlZ2FyZGxlc3Mgb2YgZXhlY3V0aW9uIG9yZGVyLiBNZXRob2RzIGxpa2UgYF8uYXJ5YCBhbmRcclxuICAgICAqIGBfLnJlYXJnYCBtb2RpZnkgZnVuY3Rpb24gYXJndW1lbnRzLCBtYWtpbmcgdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgYXJlXHJcbiAgICAgKiBleGVjdXRlZCBpbXBvcnRhbnQsIHByZXZlbnRpbmcgdGhlIG1lcmdpbmcgb2YgbWV0YWRhdGEuIEhvd2V2ZXIsIHdlIG1ha2VcclxuICAgICAqIGFuIGV4Y2VwdGlvbiBmb3IgYSBzYWZlIGNvbWJpbmVkIGNhc2Ugd2hlcmUgY3VycmllZCBmdW5jdGlvbnMgaGF2ZSBgXy5hcnlgXHJcbiAgICAgKiBhbmQgb3IgYF8ucmVhcmdgIGFwcGxpZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgVGhlIGRlc3RpbmF0aW9uIG1ldGFkYXRhLlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBzb3VyY2UgbWV0YWRhdGEuXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGRhdGFgLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBtZXJnZURhdGEoZGF0YSwgc291cmNlKSB7XHJcbiAgICAgIHZhciBiaXRtYXNrID0gZGF0YVsxXSxcclxuICAgICAgICAgIHNyY0JpdG1hc2sgPSBzb3VyY2VbMV0sXHJcbiAgICAgICAgICBuZXdCaXRtYXNrID0gYml0bWFzayB8IHNyY0JpdG1hc2ssXHJcbiAgICAgICAgICBpc0NvbW1vbiA9IG5ld0JpdG1hc2sgPCAoV1JBUF9CSU5EX0ZMQUcgfCBXUkFQX0JJTkRfS0VZX0ZMQUcgfCBXUkFQX0FSWV9GTEFHKTtcclxuXHJcbiAgICAgIHZhciBpc0NvbWJvID1cclxuICAgICAgICAoKHNyY0JpdG1hc2sgPT0gV1JBUF9BUllfRkxBRykgJiYgKGJpdG1hc2sgPT0gV1JBUF9DVVJSWV9GTEFHKSkgfHxcclxuICAgICAgICAoKHNyY0JpdG1hc2sgPT0gV1JBUF9BUllfRkxBRykgJiYgKGJpdG1hc2sgPT0gV1JBUF9SRUFSR19GTEFHKSAmJiAoZGF0YVs3XS5sZW5ndGggPD0gc291cmNlWzhdKSkgfHxcclxuICAgICAgICAoKHNyY0JpdG1hc2sgPT0gKFdSQVBfQVJZX0ZMQUcgfCBXUkFQX1JFQVJHX0ZMQUcpKSAmJiAoc291cmNlWzddLmxlbmd0aCA8PSBzb3VyY2VbOF0pICYmIChiaXRtYXNrID09IFdSQVBfQ1VSUllfRkxBRykpO1xyXG5cclxuICAgICAgLy8gRXhpdCBlYXJseSBpZiBtZXRhZGF0YSBjYW4ndCBiZSBtZXJnZWQuXHJcbiAgICAgIGlmICghKGlzQ29tbW9uIHx8IGlzQ29tYm8pKSB7XHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgIH1cclxuICAgICAgLy8gVXNlIHNvdXJjZSBgdGhpc0FyZ2AgaWYgYXZhaWxhYmxlLlxyXG4gICAgICBpZiAoc3JjQml0bWFzayAmIFdSQVBfQklORF9GTEFHKSB7XHJcbiAgICAgICAgZGF0YVsyXSA9IHNvdXJjZVsyXTtcclxuICAgICAgICAvLyBTZXQgd2hlbiBjdXJyeWluZyBhIGJvdW5kIGZ1bmN0aW9uLlxyXG4gICAgICAgIG5ld0JpdG1hc2sgfD0gYml0bWFzayAmIFdSQVBfQklORF9GTEFHID8gMCA6IFdSQVBfQ1VSUllfQk9VTkRfRkxBRztcclxuICAgICAgfVxyXG4gICAgICAvLyBDb21wb3NlIHBhcnRpYWwgYXJndW1lbnRzLlxyXG4gICAgICB2YXIgdmFsdWUgPSBzb3VyY2VbM107XHJcbiAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgIHZhciBwYXJ0aWFscyA9IGRhdGFbM107XHJcbiAgICAgICAgZGF0YVszXSA9IHBhcnRpYWxzID8gY29tcG9zZUFyZ3MocGFydGlhbHMsIHZhbHVlLCBzb3VyY2VbNF0pIDogdmFsdWU7XHJcbiAgICAgICAgZGF0YVs0XSA9IHBhcnRpYWxzID8gcmVwbGFjZUhvbGRlcnMoZGF0YVszXSwgUExBQ0VIT0xERVIpIDogc291cmNlWzRdO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIENvbXBvc2UgcGFydGlhbCByaWdodCBhcmd1bWVudHMuXHJcbiAgICAgIHZhbHVlID0gc291cmNlWzVdO1xyXG4gICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICBwYXJ0aWFscyA9IGRhdGFbNV07XHJcbiAgICAgICAgZGF0YVs1XSA9IHBhcnRpYWxzID8gY29tcG9zZUFyZ3NSaWdodChwYXJ0aWFscywgdmFsdWUsIHNvdXJjZVs2XSkgOiB2YWx1ZTtcclxuICAgICAgICBkYXRhWzZdID0gcGFydGlhbHMgPyByZXBsYWNlSG9sZGVycyhkYXRhWzVdLCBQTEFDRUhPTERFUikgOiBzb3VyY2VbNl07XHJcbiAgICAgIH1cclxuICAgICAgLy8gVXNlIHNvdXJjZSBgYXJnUG9zYCBpZiBhdmFpbGFibGUuXHJcbiAgICAgIHZhbHVlID0gc291cmNlWzddO1xyXG4gICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICBkYXRhWzddID0gdmFsdWU7XHJcbiAgICAgIH1cclxuICAgICAgLy8gVXNlIHNvdXJjZSBgYXJ5YCBpZiBpdCdzIHNtYWxsZXIuXHJcbiAgICAgIGlmIChzcmNCaXRtYXNrICYgV1JBUF9BUllfRkxBRykge1xyXG4gICAgICAgIGRhdGFbOF0gPSBkYXRhWzhdID09IG51bGwgPyBzb3VyY2VbOF0gOiBuYXRpdmVNaW4oZGF0YVs4XSwgc291cmNlWzhdKTtcclxuICAgICAgfVxyXG4gICAgICAvLyBVc2Ugc291cmNlIGBhcml0eWAgaWYgb25lIGlzIG5vdCBwcm92aWRlZC5cclxuICAgICAgaWYgKGRhdGFbOV0gPT0gbnVsbCkge1xyXG4gICAgICAgIGRhdGFbOV0gPSBzb3VyY2VbOV07XHJcbiAgICAgIH1cclxuICAgICAgLy8gVXNlIHNvdXJjZSBgZnVuY2AgYW5kIG1lcmdlIGJpdG1hc2tzLlxyXG4gICAgICBkYXRhWzBdID0gc291cmNlWzBdO1xyXG4gICAgICBkYXRhWzFdID0gbmV3Qml0bWFzaztcclxuXHJcbiAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlXHJcbiAgICAgKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXHJcbiAgICAgKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XHJcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgICAgaWYgKG9iamVjdCAhPSBudWxsKSB7XHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XHJcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xyXG4gICAgICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCB0cmFuc2Zvcm1zIHRoZSByZXN0IGFycmF5LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSByZXN0IGFycmF5IHRyYW5zZm9ybS5cclxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBvdmVyUmVzdChmdW5jLCBzdGFydCwgdHJhbnNmb3JtKSB7XHJcbiAgICAgIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6IHN0YXJ0LCAwKTtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxyXG4gICAgICAgICAgICBpbmRleCA9IC0xLFxyXG4gICAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXHJcbiAgICAgICAgICAgIGFycmF5ID0gQXJyYXkobGVuZ3RoKTtcclxuXHJcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcclxuICAgICAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluZGV4ID0gLTE7XHJcbiAgICAgICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XHJcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xyXG4gICAgICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvdGhlckFyZ3Nbc3RhcnRdID0gdHJhbnNmb3JtKGFycmF5KTtcclxuICAgICAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHBhcmVudCB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggVGhlIHBhdGggdG8gZ2V0IHRoZSBwYXJlbnQgdmFsdWUgb2YuXHJcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcGFyZW50IHZhbHVlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBwYXJlbnQob2JqZWN0LCBwYXRoKSB7XHJcbiAgICAgIHJldHVybiBwYXRoLmxlbmd0aCA8IDIgPyBvYmplY3QgOiBiYXNlR2V0KG9iamVjdCwgYmFzZVNsaWNlKHBhdGgsIDAsIC0xKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW9yZGVyIGBhcnJheWAgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgaW5kZXhlcyB3aGVyZSB0aGUgZWxlbWVudCBhdFxyXG4gICAgICogdGhlIGZpcnN0IGluZGV4IGlzIGFzc2lnbmVkIGFzIHRoZSBmaXJzdCBlbGVtZW50LCB0aGUgZWxlbWVudCBhdFxyXG4gICAgICogdGhlIHNlY29uZCBpbmRleCBpcyBhc3NpZ25lZCBhcyB0aGUgc2Vjb25kIGVsZW1lbnQsIGFuZCBzbyBvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHJlb3JkZXIuXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBpbmRleGVzIFRoZSBhcnJhbmdlZCBhcnJheSBpbmRleGVzLlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHJlb3JkZXIoYXJyYXksIGluZGV4ZXMpIHtcclxuICAgICAgdmFyIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcclxuICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1pbihpbmRleGVzLmxlbmd0aCwgYXJyTGVuZ3RoKSxcclxuICAgICAgICAgIG9sZEFycmF5ID0gY29weUFycmF5KGFycmF5KTtcclxuXHJcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xyXG4gICAgICAgIHZhciBpbmRleCA9IGluZGV4ZXNbbGVuZ3RoXTtcclxuICAgICAgICBhcnJheVtsZW5ndGhdID0gaXNJbmRleChpbmRleCwgYXJyTGVuZ3RoKSA/IG9sZEFycmF5W2luZGV4XSA6IHVuZGVmaW5lZDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gYXJyYXk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCwgdW5sZXNzIGBrZXlgIGlzIFwiX19wcm90b19fXCIgb3IgXCJjb25zdHJ1Y3RvclwiLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cclxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gc2FmZUdldChvYmplY3QsIGtleSkge1xyXG4gICAgICBpZiAoa2V5ID09PSAnY29uc3RydWN0b3InICYmIHR5cGVvZiBvYmplY3Rba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGtleSA9PSAnX19wcm90b19fJykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG9iamVjdFtrZXldO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBtZXRhZGF0YSBmb3IgYGZ1bmNgLlxyXG4gICAgICpcclxuICAgICAqICoqTm90ZToqKiBJZiB0aGlzIGZ1bmN0aW9uIGJlY29tZXMgaG90LCBpLmUuIGlzIGludm9rZWQgYSBsb3QgaW4gYSBzaG9ydFxyXG4gICAgICogcGVyaW9kIG9mIHRpbWUsIGl0IHdpbGwgdHJpcCBpdHMgYnJlYWtlciBhbmQgdHJhbnNpdGlvbiB0byBhbiBpZGVudGl0eVxyXG4gICAgICogZnVuY3Rpb24gdG8gYXZvaWQgZ2FyYmFnZSBjb2xsZWN0aW9uIHBhdXNlcyBpbiBWOC4gU2VlXHJcbiAgICAgKiBbVjggaXNzdWUgMjA3MF0oaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjA3MClcclxuICAgICAqIGZvciBtb3JlIGRldGFpbHMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFzc29jaWF0ZSBtZXRhZGF0YSB3aXRoLlxyXG4gICAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXRhZGF0YS5cclxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXHJcbiAgICAgKi9cclxuICAgIHZhciBzZXREYXRhID0gc2hvcnRPdXQoYmFzZVNldERhdGEpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBzaW1wbGUgd3JhcHBlciBhcm91bmQgdGhlIGdsb2JhbCBbYHNldFRpbWVvdXRgXShodHRwczovL21kbi5pby9zZXRUaW1lb3V0KS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVsYXkuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2FpdCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSBpbnZvY2F0aW9uLlxyXG4gICAgICogQHJldHVybnMge251bWJlcnxPYmplY3R9IFJldHVybnMgdGhlIHRpbWVyIGlkIG9yIHRpbWVvdXQgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICB2YXIgc2V0VGltZW91dCA9IGN0eFNldFRpbWVvdXQgfHwgZnVuY3Rpb24oZnVuYywgd2FpdCkge1xyXG4gICAgICByZXR1cm4gcm9vdC5zZXRUaW1lb3V0KGZ1bmMsIHdhaXQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGBmdW5jYCB0byByZXR1cm4gYHN0cmluZ2AuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXHJcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxyXG4gICAgICovXHJcbiAgICB2YXIgc2V0VG9TdHJpbmcgPSBzaG9ydE91dChiYXNlU2V0VG9TdHJpbmcpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYHdyYXBwZXJgIHRvIG1pbWljIHRoZSBzb3VyY2Ugb2YgYHJlZmVyZW5jZWBcclxuICAgICAqIHdpdGggd3JhcHBlciBkZXRhaWxzIGluIGEgY29tbWVudCBhdCB0aGUgdG9wIG9mIHRoZSBzb3VyY2UgYm9keS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gd3JhcHBlciBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVmZXJlbmNlIFRoZSByZWZlcmVuY2UgZnVuY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGB3cmFwcGVyYC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gc2V0V3JhcFRvU3RyaW5nKHdyYXBwZXIsIHJlZmVyZW5jZSwgYml0bWFzaykge1xyXG4gICAgICB2YXIgc291cmNlID0gKHJlZmVyZW5jZSArICcnKTtcclxuICAgICAgcmV0dXJuIHNldFRvU3RyaW5nKHdyYXBwZXIsIGluc2VydFdyYXBEZXRhaWxzKHNvdXJjZSwgdXBkYXRlV3JhcERldGFpbHMoZ2V0V3JhcERldGFpbHMoc291cmNlKSwgYml0bWFzaykpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0J2xsIHNob3J0IG91dCBhbmQgaW52b2tlIGBpZGVudGl0eWAgaW5zdGVhZFxyXG4gICAgICogb2YgYGZ1bmNgIHdoZW4gaXQncyBjYWxsZWQgYEhPVF9DT1VOVGAgb3IgbW9yZSB0aW1lcyBpbiBgSE9UX1NQQU5gXHJcbiAgICAgKiBtaWxsaXNlY29uZHMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc2hvcnRhYmxlIGZ1bmN0aW9uLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBzaG9ydE91dChmdW5jKSB7XHJcbiAgICAgIHZhciBjb3VudCA9IDAsXHJcbiAgICAgICAgICBsYXN0Q2FsbGVkID0gMDtcclxuXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgc3RhbXAgPSBuYXRpdmVOb3coKSxcclxuICAgICAgICAgICAgcmVtYWluaW5nID0gSE9UX1NQQU4gLSAoc3RhbXAgLSBsYXN0Q2FsbGVkKTtcclxuXHJcbiAgICAgICAgbGFzdENhbGxlZCA9IHN0YW1wO1xyXG4gICAgICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XHJcbiAgICAgICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY291bnQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc2h1ZmZsZWAgd2hpY2ggbXV0YXRlcyBhbmQgc2V0cyB0aGUgc2l6ZSBvZiBgYXJyYXlgLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2h1ZmZsZS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc2l6ZT1hcnJheS5sZW5ndGhdIFRoZSBzaXplIG9mIGBhcnJheWAuXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gc2h1ZmZsZVNlbGYoYXJyYXksIHNpemUpIHtcclxuICAgICAgdmFyIGluZGV4ID0gLTEsXHJcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXHJcbiAgICAgICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxO1xyXG5cclxuICAgICAgc2l6ZSA9IHNpemUgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHNpemU7XHJcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgc2l6ZSkge1xyXG4gICAgICAgIHZhciByYW5kID0gYmFzZVJhbmRvbShpbmRleCwgbGFzdEluZGV4KSxcclxuICAgICAgICAgICAgdmFsdWUgPSBhcnJheVtyYW5kXTtcclxuXHJcbiAgICAgICAgYXJyYXlbcmFuZF0gPSBhcnJheVtpbmRleF07XHJcbiAgICAgICAgYXJyYXlbaW5kZXhdID0gdmFsdWU7XHJcbiAgICAgIH1cclxuICAgICAgYXJyYXkubGVuZ3RoID0gc2l6ZTtcclxuICAgICAgcmV0dXJuIGFycmF5O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cclxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cclxuICAgICAqL1xyXG4gICAgdmFyIHN0cmluZ1RvUGF0aCA9IG1lbW9pemVDYXBwZWQoZnVuY3Rpb24oc3RyaW5nKSB7XHJcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgICAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KDApID09PSA0NiAvKiAuICovKSB7XHJcbiAgICAgICAgcmVzdWx0LnB1c2goJycpO1xyXG4gICAgICB9XHJcbiAgICAgIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcclxuICAgICAgICByZXN1bHQucHVzaChxdW90ZSA/IHN1YlN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwgJyQxJykgOiAobnVtYmVyIHx8IG1hdGNoKSk7XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIGtleSBpZiBpdCdzIG5vdCBhIHN0cmluZyBvciBzeW1ib2wuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHN5bWJvbH0gUmV0dXJucyB0aGUga2V5LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0b0tleSh2YWx1ZSkge1xyXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xyXG4gICAgICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcclxuICAgICAgaWYgKGZ1bmMgIT0gbnVsbCkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge31cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB3cmFwcGVyIGBkZXRhaWxzYCBiYXNlZCBvbiBgYml0bWFza2AgZmxhZ3MuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gZGV0YWlscyBUaGUgZGV0YWlscyB0byBtb2RpZnkuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBkZXRhaWxzYC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdXBkYXRlV3JhcERldGFpbHMoZGV0YWlscywgYml0bWFzaykge1xyXG4gICAgICBhcnJheUVhY2god3JhcEZsYWdzLCBmdW5jdGlvbihwYWlyKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gJ18uJyArIHBhaXJbMF07XHJcbiAgICAgICAgaWYgKChiaXRtYXNrICYgcGFpclsxXSkgJiYgIWFycmF5SW5jbHVkZXMoZGV0YWlscywgdmFsdWUpKSB7XHJcbiAgICAgICAgICBkZXRhaWxzLnB1c2godmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiBkZXRhaWxzLnNvcnQoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgd3JhcHBlcmAuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB3cmFwcGVyIFRoZSB3cmFwcGVyIHRvIGNsb25lLlxyXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHdyYXBwZXIuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHdyYXBwZXJDbG9uZSh3cmFwcGVyKSB7XHJcbiAgICAgIGlmICh3cmFwcGVyIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHtcclxuICAgICAgICByZXR1cm4gd3JhcHBlci5jbG9uZSgpO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgTG9kYXNoV3JhcHBlcih3cmFwcGVyLl9fd3JhcHBlZF9fLCB3cmFwcGVyLl9fY2hhaW5fXyk7XHJcbiAgICAgIHJlc3VsdC5fX2FjdGlvbnNfXyA9IGNvcHlBcnJheSh3cmFwcGVyLl9fYWN0aW9uc19fKTtcclxuICAgICAgcmVzdWx0Ll9faW5kZXhfXyAgPSB3cmFwcGVyLl9faW5kZXhfXztcclxuICAgICAgcmVzdWx0Ll9fdmFsdWVzX18gPSB3cmFwcGVyLl9fdmFsdWVzX187XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cyBzcGxpdCBpbnRvIGdyb3VwcyB0aGUgbGVuZ3RoIG9mIGBzaXplYC5cclxuICAgICAqIElmIGBhcnJheWAgY2FuJ3QgYmUgc3BsaXQgZXZlbmx5LCB0aGUgZmluYWwgY2h1bmsgd2lsbCBiZSB0aGUgcmVtYWluaW5nXHJcbiAgICAgKiBlbGVtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDMuMC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBwcm9jZXNzLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzaXplPTFdIFRoZSBsZW5ndGggb2YgZWFjaCBjaHVua1xyXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cclxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNodW5rcy5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogXy5jaHVuayhbJ2EnLCAnYicsICdjJywgJ2QnXSwgMik7XHJcbiAgICAgKiAvLyA9PiBbWydhJywgJ2InXSwgWydjJywgJ2QnXV1cclxuICAgICAqXHJcbiAgICAgKiBfLmNodW5rKFsnYScsICdiJywgJ2MnLCAnZCddLCAzKTtcclxuICAgICAqIC8vID0+IFtbJ2EnLCAnYicsICdjJ10sIFsnZCddXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjaHVuayhhcnJheSwgc2l6ZSwgZ3VhcmQpIHtcclxuICAgICAgaWYgKChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBzaXplLCBndWFyZCkgOiBzaXplID09PSB1bmRlZmluZWQpKSB7XHJcbiAgICAgICAgc2l6ZSA9IDE7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc2l6ZSA9IG5hdGl2ZU1heCh0b0ludGVnZXIoc2l6ZSksIDApO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcclxuICAgICAgaWYgKCFsZW5ndGggfHwgc2l6ZSA8IDEpIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGluZGV4ID0gMCxcclxuICAgICAgICAgIHJlc0luZGV4ID0gMCxcclxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KG5hdGl2ZUNlaWwobGVuZ3RoIC8gc2l6ZSkpO1xyXG5cclxuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gYmFzZVNsaWNlKGFycmF5LCBpbmRleCwgKGluZGV4ICs9IHNpemUpKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSB3aXRoIGFsbCBmYWxzZXkgdmFsdWVzIHJlbW92ZWQuIFRoZSB2YWx1ZXMgYGZhbHNlYCwgYG51bGxgLFxyXG4gICAgICogYDBgLCBgXCJcImAsIGB1bmRlZmluZWRgLCBhbmQgYE5hTmAgYXJlIGZhbHNleS5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDAuMS4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYWN0LlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLmNvbXBhY3QoWzAsIDEsIGZhbHNlLCAyLCAnJywgM10pO1xyXG4gICAgICogLy8gPT4gWzEsIDIsIDNdXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNvbXBhY3QoYXJyYXkpIHtcclxuICAgICAgdmFyIGluZGV4ID0gLTEsXHJcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcclxuICAgICAgICAgIHJlc0luZGV4ID0gMCxcclxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xyXG5cclxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XHJcbiAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgYXJyYXkgY29uY2F0ZW5hdGluZyBgYXJyYXlgIHdpdGggYW55IGFkZGl0aW9uYWwgYXJyYXlzXHJcbiAgICAgKiBhbmQvb3IgdmFsdWVzLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgNC4wLjBcclxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbmNhdGVuYXRlLlxyXG4gICAgICogQHBhcmFtIHsuLi4qfSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNvbmNhdGVuYXRlLlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgY29uY2F0ZW5hdGVkIGFycmF5LlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiB2YXIgYXJyYXkgPSBbMV07XHJcbiAgICAgKiB2YXIgb3RoZXIgPSBfLmNvbmNhdChhcnJheSwgMiwgWzNdLCBbWzRdXSk7XHJcbiAgICAgKlxyXG4gICAgICogY29uc29sZS5sb2cob3RoZXIpO1xyXG4gICAgICogLy8gPT4gWzEsIDIsIDMsIFs0XV1cclxuICAgICAqXHJcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XHJcbiAgICAgKiAvLyA9PiBbMV1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY29uY2F0KCkge1xyXG4gICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcclxuICAgICAgaWYgKCFsZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGFyZ3MgPSBBcnJheShsZW5ndGggLSAxKSxcclxuICAgICAgICAgIGFycmF5ID0gYXJndW1lbnRzWzBdLFxyXG4gICAgICAgICAgaW5kZXggPSBsZW5ndGg7XHJcblxyXG4gICAgICB3aGlsZSAoaW5kZXgtLSkge1xyXG4gICAgICAgIGFyZ3NbaW5kZXggLSAxXSA9IGFyZ3VtZW50c1tpbmRleF07XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGFycmF5UHVzaChpc0FycmF5KGFycmF5KSA/IGNvcHlBcnJheShhcnJheSkgOiBbYXJyYXldLCBiYXNlRmxhdHRlbihhcmdzLCAxKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGBhcnJheWAgdmFsdWVzIG5vdCBpbmNsdWRlZCBpbiB0aGUgb3RoZXIgZ2l2ZW4gYXJyYXlzXHJcbiAgICAgKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxyXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmVcclxuICAgICAqIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LlxyXG4gICAgICpcclxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucHVsbEFsbGAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAwLjEuMFxyXG4gICAgICogQGNhdGVnb3J5IEFycmF5XHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cclxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cclxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cclxuICAgICAqIEBzZWUgXy53aXRob3V0LCBfLnhvclxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLmRpZmZlcmVuY2UoWzIsIDFdLCBbMiwgM10pO1xyXG4gICAgICogLy8gPT4gWzFdXHJcbiAgICAgKi9cclxuICAgIHZhciBkaWZmZXJlbmNlID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXksIHZhbHVlcykge1xyXG4gICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QoYXJyYXkpXHJcbiAgICAgICAgPyBiYXNlRGlmZmVyZW5jZShhcnJheSwgYmFzZUZsYXR0ZW4odmFsdWVzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSkpXHJcbiAgICAgICAgOiBbXTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5kaWZmZXJlbmNlYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2hcclxuICAgICAqIGlzIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIGFuZCBgdmFsdWVzYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uXHJcbiAgICAgKiBieSB3aGljaCB0aGV5J3JlIGNvbXBhcmVkLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmVcclxuICAgICAqIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDpcclxuICAgICAqICh2YWx1ZSkuXHJcbiAgICAgKlxyXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5wdWxsQWxsQnlgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgNC4wLjBcclxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXHJcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8uZGlmZmVyZW5jZUJ5KFsyLjEsIDEuMl0sIFsyLjMsIDMuNF0sIE1hdGguZmxvb3IpO1xyXG4gICAgICogLy8gPT4gWzEuMl1cclxuICAgICAqXHJcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cclxuICAgICAqIF8uZGlmZmVyZW5jZUJ5KFt7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgW3sgJ3gnOiAxIH1dLCAneCcpO1xyXG4gICAgICogLy8gPT4gW3sgJ3gnOiAyIH1dXHJcbiAgICAgKi9cclxuICAgIHZhciBkaWZmZXJlbmNlQnkgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheSwgdmFsdWVzKSB7XHJcbiAgICAgIHZhciBpdGVyYXRlZSA9IGxhc3QodmFsdWVzKTtcclxuICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGl0ZXJhdGVlKSkge1xyXG4gICAgICAgIGl0ZXJhdGVlID0gdW5kZWZpbmVkO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdChhcnJheSlcclxuICAgICAgICA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCBiYXNlRmxhdHRlbih2YWx1ZXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKVxyXG4gICAgICAgIDogW107XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZGlmZmVyZW5jZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY29tcGFyYXRvcmBcclxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlgIHRvIGB2YWx1ZXNgLiBUaGUgb3JkZXIgYW5kXHJcbiAgICAgKiByZWZlcmVuY2VzIG9mIHJlc3VsdCB2YWx1ZXMgYXJlIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LiBUaGUgY29tcGFyYXRvclxyXG4gICAgICogaXMgaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXHJcbiAgICAgKlxyXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5wdWxsQWxsV2l0aGAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSA0LjAuMFxyXG4gICAgICogQGNhdGVnb3J5IEFycmF5XHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cclxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfV07XHJcbiAgICAgKlxyXG4gICAgICogXy5kaWZmZXJlbmNlV2l0aChvYmplY3RzLCBbeyAneCc6IDEsICd5JzogMiB9XSwgXy5pc0VxdWFsKTtcclxuICAgICAqIC8vID0+IFt7ICd4JzogMiwgJ3knOiAxIH1dXHJcbiAgICAgKi9cclxuICAgIHZhciBkaWZmZXJlbmNlV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMpIHtcclxuICAgICAgdmFyIGNvbXBhcmF0b3IgPSBsYXN0KHZhbHVlcyk7XHJcbiAgICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChjb21wYXJhdG9yKSkge1xyXG4gICAgICAgIGNvbXBhcmF0b3IgPSB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KGFycmF5KVxyXG4gICAgICAgID8gYmFzZURpZmZlcmVuY2UoYXJyYXksIGJhc2VGbGF0dGVuKHZhbHVlcywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpLCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpXHJcbiAgICAgICAgOiBbXTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBgbmAgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBiZWdpbm5pbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAwLjUuMFxyXG4gICAgICogQGNhdGVnb3J5IEFycmF5XHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBkcm9wLlxyXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cclxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSk7XHJcbiAgICAgKiAvLyA9PiBbMiwgM11cclxuICAgICAqXHJcbiAgICAgKiBfLmRyb3AoWzEsIDIsIDNdLCAyKTtcclxuICAgICAqIC8vID0+IFszXVxyXG4gICAgICpcclxuICAgICAqIF8uZHJvcChbMSwgMiwgM10sIDUpO1xyXG4gICAgICogLy8gPT4gW11cclxuICAgICAqXHJcbiAgICAgKiBfLmRyb3AoWzEsIDIsIDNdLCAwKTtcclxuICAgICAqIC8vID0+IFsxLCAyLCAzXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBkcm9wKGFycmF5LCBuLCBndWFyZCkge1xyXG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XHJcbiAgICAgIGlmICghbGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICB9XHJcbiAgICAgIG4gPSAoZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkKSA/IDEgOiB0b0ludGVnZXIobik7XHJcbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIG4gPCAwID8gMCA6IG4sIGxlbmd0aCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGBuYCBlbGVtZW50cyBkcm9wcGVkIGZyb20gdGhlIGVuZC5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDMuMC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGRyb3AuXHJcbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLmRyb3BSaWdodChbMSwgMiwgM10pO1xyXG4gICAgICogLy8gPT4gWzEsIDJdXHJcbiAgICAgKlxyXG4gICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdLCAyKTtcclxuICAgICAqIC8vID0+IFsxXVxyXG4gICAgICpcclxuICAgICAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSwgNSk7XHJcbiAgICAgKiAvLyA9PiBbXVxyXG4gICAgICpcclxuICAgICAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSwgMCk7XHJcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZHJvcFJpZ2h0KGFycmF5LCBuLCBndWFyZCkge1xyXG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XHJcbiAgICAgIGlmICghbGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICB9XHJcbiAgICAgIG4gPSAoZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkKSA/IDEgOiB0b0ludGVnZXIobik7XHJcbiAgICAgIG4gPSBsZW5ndGggLSBuO1xyXG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCAwLCBuIDwgMCA/IDAgOiBuKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIGV4Y2x1ZGluZyBlbGVtZW50cyBkcm9wcGVkIGZyb20gdGhlIGVuZC5cclxuICAgICAqIEVsZW1lbnRzIGFyZSBkcm9wcGVkIHVudGlsIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzXHJcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAzLjAuMFxyXG4gICAgICogQGNhdGVnb3J5IEFycmF5XHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIHZhciB1c2VycyA9IFtcclxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IHRydWUgfSxcclxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXHJcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9XHJcbiAgICAgKiBdO1xyXG4gICAgICpcclxuICAgICAqIF8uZHJvcFJpZ2h0V2hpbGUodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XHJcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXHJcbiAgICAgKlxyXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cclxuICAgICAqIF8uZHJvcFJpZ2h0V2hpbGUodXNlcnMsIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9KTtcclxuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5JywgJ2ZyZWQnXVxyXG4gICAgICpcclxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cclxuICAgICAqIF8uZHJvcFJpZ2h0V2hpbGUodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcclxuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cclxuICAgICAqXHJcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cclxuICAgICAqIF8uZHJvcFJpZ2h0V2hpbGUodXNlcnMsICdhY3RpdmUnKTtcclxuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5JywgJ2ZyZWQnLCAncGViYmxlcyddXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGRyb3BSaWdodFdoaWxlKGFycmF5LCBwcmVkaWNhdGUpIHtcclxuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXHJcbiAgICAgICAgPyBiYXNlV2hpbGUoYXJyYXksIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIHRydWUsIHRydWUpXHJcbiAgICAgICAgOiBbXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIGV4Y2x1ZGluZyBlbGVtZW50cyBkcm9wcGVkIGZyb20gdGhlIGJlZ2lubmluZy5cclxuICAgICAqIEVsZW1lbnRzIGFyZSBkcm9wcGVkIHVudGlsIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzXHJcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAzLjAuMFxyXG4gICAgICogQGNhdGVnb3J5IEFycmF5XHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIHZhciB1c2VycyA9IFtcclxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IGZhbHNlIH0sXHJcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxyXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogdHJ1ZSB9XHJcbiAgICAgKiBdO1xyXG4gICAgICpcclxuICAgICAqIF8uZHJvcFdoaWxlKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xyXG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydwZWJibGVzJ11cclxuICAgICAqXHJcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxyXG4gICAgICogXy5kcm9wV2hpbGUodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xyXG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJywgJ3BlYmJsZXMnXVxyXG4gICAgICpcclxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cclxuICAgICAqIF8uZHJvcFdoaWxlKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XHJcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ3BlYmJsZXMnXVxyXG4gICAgICpcclxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxyXG4gICAgICogXy5kcm9wV2hpbGUodXNlcnMsICdhY3RpdmUnKTtcclxuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5JywgJ2ZyZWQnLCAncGViYmxlcyddXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGRyb3BXaGlsZShhcnJheSwgcHJlZGljYXRlKSB7XHJcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxyXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCB0cnVlKVxyXG4gICAgICAgIDogW107XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaWxscyBlbGVtZW50cyBvZiBgYXJyYXlgIHdpdGggYHZhbHVlYCBmcm9tIGBzdGFydGAgdXAgdG8sIGJ1dCBub3RcclxuICAgICAqIGluY2x1ZGluZywgYGVuZGAuXHJcbiAgICAgKlxyXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDMuMi4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmaWxsLlxyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZmlsbCBgYXJyYXlgIHdpdGguXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cclxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgM107XHJcbiAgICAgKlxyXG4gICAgICogXy5maWxsKGFycmF5LCAnYScpO1xyXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xyXG4gICAgICogLy8gPT4gWydhJywgJ2EnLCAnYSddXHJcbiAgICAgKlxyXG4gICAgICogXy5maWxsKEFycmF5KDMpLCAyKTtcclxuICAgICAqIC8vID0+IFsyLCAyLCAyXVxyXG4gICAgICpcclxuICAgICAqIF8uZmlsbChbNCwgNiwgOCwgMTBdLCAnKicsIDEsIDMpO1xyXG4gICAgICogLy8gPT4gWzQsICcqJywgJyonLCAxMF1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZmlsbChhcnJheSwgdmFsdWUsIHN0YXJ0LCBlbmQpIHtcclxuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xyXG4gICAgICBpZiAoIWxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoc3RhcnQgJiYgdHlwZW9mIHN0YXJ0ICE9ICdudW1iZXInICYmIGlzSXRlcmF0ZWVDYWxsKGFycmF5LCB2YWx1ZSwgc3RhcnQpKSB7XHJcbiAgICAgICAgc3RhcnQgPSAwO1xyXG4gICAgICAgIGVuZCA9IGxlbmd0aDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gYmFzZUZpbGwoYXJyYXksIHZhbHVlLCBzdGFydCwgZW5kKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0XHJcbiAgICAgKiBlbGVtZW50IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDEuMS4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYC0xYC5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogdmFyIHVzZXJzID0gW1xyXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcclxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXHJcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiB0cnVlIH1cclxuICAgICAqIF07XHJcbiAgICAgKlxyXG4gICAgICogXy5maW5kSW5kZXgodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8udXNlciA9PSAnYmFybmV5JzsgfSk7XHJcbiAgICAgKiAvLyA9PiAwXHJcbiAgICAgKlxyXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cclxuICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCB7ICd1c2VyJzogJ2ZyZWQnLCAnYWN0aXZlJzogZmFsc2UgfSk7XHJcbiAgICAgKiAvLyA9PiAxXHJcbiAgICAgKlxyXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxyXG4gICAgICogXy5maW5kSW5kZXgodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcclxuICAgICAqIC8vID0+IDBcclxuICAgICAqXHJcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cclxuICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCAnYWN0aXZlJyk7XHJcbiAgICAgKiAvLyA9PiAyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcclxuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xyXG4gICAgICBpZiAoIWxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgaW5kZXggPSBmcm9tSW5kZXggPT0gbnVsbCA/IDAgOiB0b0ludGVnZXIoZnJvbUluZGV4KTtcclxuICAgICAgaWYgKGluZGV4IDwgMCkge1xyXG4gICAgICAgIGluZGV4ID0gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gYmFzZUZpbmRJbmRleChhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgaW5kZXgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kSW5kZXhgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHNcclxuICAgICAqIG9mIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAyLjAuMFxyXG4gICAgICogQGNhdGVnb3J5IEFycmF5XHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PWFycmF5Lmxlbmd0aC0xXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiB2YXIgdXNlcnMgPSBbXHJcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiB0cnVlIH0sXHJcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxyXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfVxyXG4gICAgICogXTtcclxuICAgICAqXHJcbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8udXNlciA9PSAncGViYmxlcyc7IH0pO1xyXG4gICAgICogLy8gPT4gMlxyXG4gICAgICpcclxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXHJcbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IHRydWUgfSk7XHJcbiAgICAgKiAvLyA9PiAwXHJcbiAgICAgKlxyXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxyXG4gICAgICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XHJcbiAgICAgKiAvLyA9PiAyXHJcbiAgICAgKlxyXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXHJcbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgodXNlcnMsICdhY3RpdmUnKTtcclxuICAgICAqIC8vID0+IDBcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZmluZExhc3RJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcclxuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xyXG4gICAgICBpZiAoIWxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgaW5kZXggPSBsZW5ndGggLSAxO1xyXG4gICAgICBpZiAoZnJvbUluZGV4ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBpbmRleCA9IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xyXG4gICAgICAgIGluZGV4ID0gZnJvbUluZGV4IDwgMFxyXG4gICAgICAgICAgPyBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApXHJcbiAgICAgICAgICA6IG5hdGl2ZU1pbihpbmRleCwgbGVuZ3RoIC0gMSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGJhc2VGaW5kSW5kZXgoYXJyYXksIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGluZGV4LCB0cnVlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZsYXR0ZW5zIGBhcnJheWAgYSBzaW5nbGUgbGV2ZWwgZGVlcC5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDAuMS4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLmZsYXR0ZW4oWzEsIFsyLCBbMywgWzRdXSwgNV1dKTtcclxuICAgICAqIC8vID0+IFsxLCAyLCBbMywgWzRdXSwgNV1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZmxhdHRlbihhcnJheSkge1xyXG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XHJcbiAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlRmxhdHRlbihhcnJheSwgMSkgOiBbXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlY3Vyc2l2ZWx5IGZsYXR0ZW5zIGBhcnJheWAuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAzLjAuMFxyXG4gICAgICogQGNhdGVnb3J5IEFycmF5XHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cclxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogXy5mbGF0dGVuRGVlcChbMSwgWzIsIFszLCBbNF1dLCA1XV0pO1xyXG4gICAgICogLy8gPT4gWzEsIDIsIDMsIDQsIDVdXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZsYXR0ZW5EZWVwKGFycmF5KSB7XHJcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcclxuICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VGbGF0dGVuKGFycmF5LCBJTkZJTklUWSkgOiBbXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlY3Vyc2l2ZWx5IGZsYXR0ZW4gYGFycmF5YCB1cCB0byBgZGVwdGhgIHRpbWVzLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgNC40LjBcclxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RlcHRoPTFdIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cclxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogdmFyIGFycmF5ID0gWzEsIFsyLCBbMywgWzRdXSwgNV1dO1xyXG4gICAgICpcclxuICAgICAqIF8uZmxhdHRlbkRlcHRoKGFycmF5LCAxKTtcclxuICAgICAqIC8vID0+IFsxLCAyLCBbMywgWzRdXSwgNV1cclxuICAgICAqXHJcbiAgICAgKiBfLmZsYXR0ZW5EZXB0aChhcnJheSwgMik7XHJcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgWzRdLCA1XVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBmbGF0dGVuRGVwdGgoYXJyYXksIGRlcHRoKSB7XHJcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcclxuICAgICAgaWYgKCFsZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICAgIH1cclxuICAgICAgZGVwdGggPSBkZXB0aCA9PT0gdW5kZWZpbmVkID8gMSA6IHRvSW50ZWdlcihkZXB0aCk7XHJcbiAgICAgIHJldHVybiBiYXNlRmxhdHRlbihhcnJheSwgZGVwdGgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGludmVyc2Ugb2YgYF8udG9QYWlyc2A7IHRoaXMgbWV0aG9kIHJldHVybnMgYW4gb2JqZWN0IGNvbXBvc2VkXHJcbiAgICAgKiBmcm9tIGtleS12YWx1ZSBgcGFpcnNgLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgNC4wLjBcclxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFpcnMgVGhlIGtleS12YWx1ZSBwYWlycy5cclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8uZnJvbVBhaXJzKFtbJ2EnLCAxXSwgWydiJywgMl1dKTtcclxuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBmcm9tUGFpcnMocGFpcnMpIHtcclxuICAgICAgdmFyIGluZGV4ID0gLTEsXHJcbiAgICAgICAgICBsZW5ndGggPSBwYWlycyA9PSBudWxsID8gMCA6IHBhaXJzLmxlbmd0aCxcclxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xyXG5cclxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcclxuICAgICAgICB2YXIgcGFpciA9IHBhaXJzW2luZGV4XTtcclxuICAgICAgICByZXN1bHRbcGFpclswXV0gPSBwYWlyWzFdO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAwLjEuMFxyXG4gICAgICogQGFsaWFzIGZpcnN0XHJcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cclxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8uaGVhZChbMSwgMiwgM10pO1xyXG4gICAgICogLy8gPT4gMVxyXG4gICAgICpcclxuICAgICAqIF8uaGVhZChbXSk7XHJcbiAgICAgKiAvLyA9PiB1bmRlZmluZWRcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaGVhZChhcnJheSkge1xyXG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBhcnJheVswXSA6IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGB2YWx1ZWAgaXMgZm91bmQgaW4gYGFycmF5YFxyXG4gICAgICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcclxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gSWYgYGZyb21JbmRleGAgaXMgbmVnYXRpdmUsIGl0J3MgdXNlZCBhcyB0aGVcclxuICAgICAqIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgYGFycmF5YC5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDAuMS4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8uaW5kZXhPZihbMSwgMiwgMSwgMl0sIDIpO1xyXG4gICAgICogLy8gPT4gMVxyXG4gICAgICpcclxuICAgICAqIC8vIFNlYXJjaCBmcm9tIHRoZSBgZnJvbUluZGV4YC5cclxuICAgICAqIF8uaW5kZXhPZihbMSwgMiwgMSwgMl0sIDIsIDIpO1xyXG4gICAgICogLy8gPT4gM1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XHJcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcclxuICAgICAgaWYgKCFsZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGluZGV4ID0gZnJvbUluZGV4ID09IG51bGwgPyAwIDogdG9JbnRlZ2VyKGZyb21JbmRleCk7XHJcbiAgICAgIGlmIChpbmRleCA8IDApIHtcclxuICAgICAgICBpbmRleCA9IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgaW5kZXgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhbGwgYnV0IHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDAuMS4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cclxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogXy5pbml0aWFsKFsxLCAyLCAzXSk7XHJcbiAgICAgKiAvLyA9PiBbMSwgMl1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaW5pdGlhbChhcnJheSkge1xyXG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XHJcbiAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlU2xpY2UoYXJyYXksIDAsIC0xKSA6IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzIHRoYXQgYXJlIGluY2x1ZGVkIGluIGFsbCBnaXZlbiBhcnJheXNcclxuICAgICAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXHJcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIFRoZSBvcmRlciBhbmQgcmVmZXJlbmNlcyBvZiByZXN1bHQgdmFsdWVzIGFyZVxyXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAwLjEuMFxyXG4gICAgICogQGNhdGVnb3J5IEFycmF5XHJcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBpbnRlcnNlY3RpbmcgdmFsdWVzLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLmludGVyc2VjdGlvbihbMiwgMV0sIFsyLCAzXSk7XHJcbiAgICAgKiAvLyA9PiBbMl1cclxuICAgICAqL1xyXG4gICAgdmFyIGludGVyc2VjdGlvbiA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xyXG4gICAgICB2YXIgbWFwcGVkID0gYXJyYXlNYXAoYXJyYXlzLCBjYXN0QXJyYXlMaWtlT2JqZWN0KTtcclxuICAgICAgcmV0dXJuIChtYXBwZWQubGVuZ3RoICYmIG1hcHBlZFswXSA9PT0gYXJyYXlzWzBdKVxyXG4gICAgICAgID8gYmFzZUludGVyc2VjdGlvbihtYXBwZWQpXHJcbiAgICAgICAgOiBbXTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pbnRlcnNlY3Rpb25gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYFxyXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IG9mIGVhY2ggYGFycmF5c2AgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvblxyXG4gICAgICogYnkgd2hpY2ggdGhleSdyZSBjb21wYXJlZC4gVGhlIG9yZGVyIGFuZCByZWZlcmVuY2VzIG9mIHJlc3VsdCB2YWx1ZXMgYXJlXHJcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6XHJcbiAgICAgKiAodmFsdWUpLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgNC4wLjBcclxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxyXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgaW50ZXJzZWN0aW5nIHZhbHVlcy5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogXy5pbnRlcnNlY3Rpb25CeShbMi4xLCAxLjJdLCBbMi4zLCAzLjRdLCBNYXRoLmZsb29yKTtcclxuICAgICAqIC8vID0+IFsyLjFdXHJcbiAgICAgKlxyXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXHJcbiAgICAgKiBfLmludGVyc2VjdGlvbkJ5KFt7ICd4JzogMSB9XSwgW3sgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xyXG4gICAgICogLy8gPT4gW3sgJ3gnOiAxIH1dXHJcbiAgICAgKi9cclxuICAgIHZhciBpbnRlcnNlY3Rpb25CeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xyXG4gICAgICB2YXIgaXRlcmF0ZWUgPSBsYXN0KGFycmF5cyksXHJcbiAgICAgICAgICBtYXBwZWQgPSBhcnJheU1hcChhcnJheXMsIGNhc3RBcnJheUxpa2VPYmplY3QpO1xyXG5cclxuICAgICAgaWYgKGl0ZXJhdGVlID09PSBsYXN0KG1hcHBlZCkpIHtcclxuICAgICAgICBpdGVyYXRlZSA9IHVuZGVmaW5lZDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBtYXBwZWQucG9wKCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIChtYXBwZWQubGVuZ3RoICYmIG1hcHBlZFswXSA9PT0gYXJyYXlzWzBdKVxyXG4gICAgICAgID8gYmFzZUludGVyc2VjdGlvbihtYXBwZWQsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSlcclxuICAgICAgICA6IFtdO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmludGVyc2VjdGlvbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY29tcGFyYXRvcmBcclxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlzYC4gVGhlIG9yZGVyIGFuZCByZWZlcmVuY2VzXHJcbiAgICAgKiBvZiByZXN1bHQgdmFsdWVzIGFyZSBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS4gVGhlIGNvbXBhcmF0b3IgaXNcclxuICAgICAqIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgNC4wLjBcclxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxyXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBpbnRlcnNlY3RpbmcgdmFsdWVzLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfV07XHJcbiAgICAgKiB2YXIgb3RoZXJzID0gW3sgJ3gnOiAxLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMiB9XTtcclxuICAgICAqXHJcbiAgICAgKiBfLmludGVyc2VjdGlvbldpdGgob2JqZWN0cywgb3RoZXJzLCBfLmlzRXF1YWwpO1xyXG4gICAgICogLy8gPT4gW3sgJ3gnOiAxLCAneSc6IDIgfV1cclxuICAgICAqL1xyXG4gICAgdmFyIGludGVyc2VjdGlvbldpdGggPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcclxuICAgICAgdmFyIGNvbXBhcmF0b3IgPSBsYXN0KGFycmF5cyksXHJcbiAgICAgICAgICBtYXBwZWQgPSBhcnJheU1hcChhcnJheXMsIGNhc3RBcnJheUxpa2VPYmplY3QpO1xyXG5cclxuICAgICAgY29tcGFyYXRvciA9IHR5cGVvZiBjb21wYXJhdG9yID09ICdmdW5jdGlvbicgPyBjb21wYXJhdG9yIDogdW5kZWZpbmVkO1xyXG4gICAgICBpZiAoY29tcGFyYXRvcikge1xyXG4gICAgICAgIG1hcHBlZC5wb3AoKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gKG1hcHBlZC5sZW5ndGggJiYgbWFwcGVkWzBdID09PSBhcnJheXNbMF0pXHJcbiAgICAgICAgPyBiYXNlSW50ZXJzZWN0aW9uKG1hcHBlZCwgdW5kZWZpbmVkLCBjb21wYXJhdG9yKVxyXG4gICAgICAgIDogW107XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIGFsbCBlbGVtZW50cyBpbiBgYXJyYXlgIGludG8gYSBzdHJpbmcgc2VwYXJhdGVkIGJ5IGBzZXBhcmF0b3JgLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgNC4wLjBcclxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbnZlcnQuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3NlcGFyYXRvcj0nLCddIFRoZSBlbGVtZW50IHNlcGFyYXRvci5cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGpvaW5lZCBzdHJpbmcuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8uam9pbihbJ2EnLCAnYicsICdjJ10sICd+Jyk7XHJcbiAgICAgKiAvLyA9PiAnYX5ifmMnXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGpvaW4oYXJyYXksIHNlcGFyYXRvcikge1xyXG4gICAgICByZXR1cm4gYXJyYXkgPT0gbnVsbCA/ICcnIDogbmF0aXZlSm9pbi5jYWxsKGFycmF5LCBzZXBhcmF0b3IpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAwLjEuMFxyXG4gICAgICogQGNhdGVnb3J5IEFycmF5XHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXHJcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8ubGFzdChbMSwgMiwgM10pO1xyXG4gICAgICogLy8gPT4gM1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBsYXN0KGFycmF5KSB7XHJcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcclxuICAgICAgcmV0dXJuIGxlbmd0aCA/IGFycmF5W2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pbmRleE9mYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXHJcbiAgICAgKiBgYXJyYXlgIGZyb20gcmlnaHQgdG8gbGVmdC5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDAuMS4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PWFycmF5Lmxlbmd0aC0xXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLmxhc3RJbmRleE9mKFsxLCAyLCAxLCAyXSwgMik7XHJcbiAgICAgKiAvLyA9PiAzXHJcbiAgICAgKlxyXG4gICAgICogLy8gU2VhcmNoIGZyb20gdGhlIGBmcm9tSW5kZXhgLlxyXG4gICAgICogXy5sYXN0SW5kZXhPZihbMSwgMiwgMSwgMl0sIDIsIDIpO1xyXG4gICAgICogLy8gPT4gMVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBsYXN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xyXG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XHJcbiAgICAgIGlmICghbGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBpbmRleCA9IGxlbmd0aDtcclxuICAgICAgaWYgKGZyb21JbmRleCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgaW5kZXggPSB0b0ludGVnZXIoZnJvbUluZGV4KTtcclxuICAgICAgICBpbmRleCA9IGluZGV4IDwgMCA/IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMCkgOiBuYXRpdmVNaW4oaW5kZXgsIGxlbmd0aCAtIDEpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWVcclxuICAgICAgICA/IHN0cmljdExhc3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgaW5kZXgpXHJcbiAgICAgICAgOiBiYXNlRmluZEluZGV4KGFycmF5LCBiYXNlSXNOYU4sIGluZGV4LCB0cnVlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGVsZW1lbnQgYXQgaW5kZXggYG5gIG9mIGBhcnJheWAuIElmIGBuYCBpcyBuZWdhdGl2ZSwgdGhlIG50aFxyXG4gICAgICogZWxlbWVudCBmcm9tIHRoZSBlbmQgaXMgcmV0dXJuZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSA0LjExLjBcclxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTBdIFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCB0byByZXR1cm4uXHJcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbnRoIGVsZW1lbnQgb2YgYGFycmF5YC5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogdmFyIGFycmF5ID0gWydhJywgJ2InLCAnYycsICdkJ107XHJcbiAgICAgKlxyXG4gICAgICogXy5udGgoYXJyYXksIDEpO1xyXG4gICAgICogLy8gPT4gJ2InXHJcbiAgICAgKlxyXG4gICAgICogXy5udGgoYXJyYXksIC0yKTtcclxuICAgICAqIC8vID0+ICdjJztcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gbnRoKGFycmF5LCBuKSB7XHJcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSA/IGJhc2VOdGgoYXJyYXksIHRvSW50ZWdlcihuKSkgOiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGFsbCBnaXZlbiB2YWx1ZXMgZnJvbSBgYXJyYXlgIHVzaW5nXHJcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxyXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxyXG4gICAgICpcclxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ud2l0aG91dGAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC4gVXNlIGBfLnJlbW92ZWBcclxuICAgICAqIHRvIHJlbW92ZSBlbGVtZW50cyBmcm9tIGFuIGFycmF5IGJ5IHByZWRpY2F0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDIuMC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXHJcbiAgICAgKiBAcGFyYW0gey4uLip9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIHZhciBhcnJheSA9IFsnYScsICdiJywgJ2MnLCAnYScsICdiJywgJ2MnXTtcclxuICAgICAqXHJcbiAgICAgKiBfLnB1bGwoYXJyYXksICdhJywgJ2MnKTtcclxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcclxuICAgICAqIC8vID0+IFsnYicsICdiJ11cclxuICAgICAqL1xyXG4gICAgdmFyIHB1bGwgPSBiYXNlUmVzdChwdWxsQWxsKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucHVsbGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhbiBhcnJheSBvZiB2YWx1ZXMgdG8gcmVtb3ZlLlxyXG4gICAgICpcclxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uZGlmZmVyZW5jZWAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDQuMC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byByZW1vdmUuXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogdmFyIGFycmF5ID0gWydhJywgJ2InLCAnYycsICdhJywgJ2InLCAnYyddO1xyXG4gICAgICpcclxuICAgICAqIF8ucHVsbEFsbChhcnJheSwgWydhJywgJ2MnXSk7XHJcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XHJcbiAgICAgKiAvLyA9PiBbJ2InLCAnYiddXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHB1bGxBbGwoYXJyYXksIHZhbHVlcykge1xyXG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCAmJiB2YWx1ZXMgJiYgdmFsdWVzLmxlbmd0aClcclxuICAgICAgICA/IGJhc2VQdWxsQWxsKGFycmF5LCB2YWx1ZXMpXHJcbiAgICAgICAgOiBhcnJheTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucHVsbEFsbGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXHJcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCBhbmQgYHZhbHVlc2AgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvblxyXG4gICAgICogYnkgd2hpY2ggdGhleSdyZSBjb21wYXJlZC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXHJcbiAgICAgKlxyXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5kaWZmZXJlbmNlQnlgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSA0LjAuMFxyXG4gICAgICogQGNhdGVnb3J5IEFycmF5XHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIHZhciBhcnJheSA9IFt7ICd4JzogMSB9LCB7ICd4JzogMiB9LCB7ICd4JzogMyB9LCB7ICd4JzogMSB9XTtcclxuICAgICAqXHJcbiAgICAgKiBfLnB1bGxBbGxCeShhcnJheSwgW3sgJ3gnOiAxIH0sIHsgJ3gnOiAzIH1dLCAneCcpO1xyXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xyXG4gICAgICogLy8gPT4gW3sgJ3gnOiAyIH1dXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHB1bGxBbGxCeShhcnJheSwgdmFsdWVzLCBpdGVyYXRlZSkge1xyXG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCAmJiB2YWx1ZXMgJiYgdmFsdWVzLmxlbmd0aClcclxuICAgICAgICA/IGJhc2VQdWxsQWxsKGFycmF5LCB2YWx1ZXMsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSlcclxuICAgICAgICA6IGFycmF5O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5wdWxsQWxsYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYCB3aGljaFxyXG4gICAgICogaXMgaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheWAgdG8gYHZhbHVlc2AuIFRoZSBjb21wYXJhdG9yIGlzXHJcbiAgICAgKiBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cclxuICAgICAqXHJcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLmRpZmZlcmVuY2VXaXRoYCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgNC42LjBcclxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIHZhciBhcnJheSA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAzLCAneSc6IDQgfSwgeyAneCc6IDUsICd5JzogNiB9XTtcclxuICAgICAqXHJcbiAgICAgKiBfLnB1bGxBbGxXaXRoKGFycmF5LCBbeyAneCc6IDMsICd5JzogNCB9XSwgXy5pc0VxdWFsKTtcclxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcclxuICAgICAqIC8vID0+IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiA1LCAneSc6IDYgfV1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcHVsbEFsbFdpdGgoYXJyYXksIHZhbHVlcywgY29tcGFyYXRvcikge1xyXG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCAmJiB2YWx1ZXMgJiYgdmFsdWVzLmxlbmd0aClcclxuICAgICAgICA/IGJhc2VQdWxsQWxsKGFycmF5LCB2YWx1ZXMsIHVuZGVmaW5lZCwgY29tcGFyYXRvcilcclxuICAgICAgICA6IGFycmF5O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBlbGVtZW50cyBmcm9tIGBhcnJheWAgY29ycmVzcG9uZGluZyB0byBgaW5kZXhlc2AgYW5kIHJldHVybnMgYW5cclxuICAgICAqIGFycmF5IG9mIHJlbW92ZWQgZWxlbWVudHMuXHJcbiAgICAgKlxyXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5hdGAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDMuMC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXHJcbiAgICAgKiBAcGFyYW0gey4uLihudW1iZXJ8bnVtYmVyW10pfSBbaW5kZXhlc10gVGhlIGluZGV4ZXMgb2YgZWxlbWVudHMgdG8gcmVtb3ZlLlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogdmFyIGFycmF5ID0gWydhJywgJ2InLCAnYycsICdkJ107XHJcbiAgICAgKiB2YXIgcHVsbGVkID0gXy5wdWxsQXQoYXJyYXksIFsxLCAzXSk7XHJcbiAgICAgKlxyXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xyXG4gICAgICogLy8gPT4gWydhJywgJ2MnXVxyXG4gICAgICpcclxuICAgICAqIGNvbnNvbGUubG9nKHB1bGxlZCk7XHJcbiAgICAgKiAvLyA9PiBbJ2InLCAnZCddXHJcbiAgICAgKi9cclxuICAgIHZhciBwdWxsQXQgPSBmbGF0UmVzdChmdW5jdGlvbihhcnJheSwgaW5kZXhlcykge1xyXG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXHJcbiAgICAgICAgICByZXN1bHQgPSBiYXNlQXQoYXJyYXksIGluZGV4ZXMpO1xyXG5cclxuICAgICAgYmFzZVB1bGxBdChhcnJheSwgYXJyYXlNYXAoaW5kZXhlcywgZnVuY3Rpb24oaW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gaXNJbmRleChpbmRleCwgbGVuZ3RoKSA/ICtpbmRleCA6IGluZGV4O1xyXG4gICAgICB9KS5zb3J0KGNvbXBhcmVBc2NlbmRpbmcpKTtcclxuXHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYWxsIGVsZW1lbnRzIGZyb20gYGFycmF5YCB0aGF0IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvclxyXG4gICAgICogYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHJlbW92ZWQgZWxlbWVudHMuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZFxyXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cclxuICAgICAqXHJcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLmZpbHRlcmAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC4gVXNlIGBfLnB1bGxgXHJcbiAgICAgKiB0byBwdWxsIGVsZW1lbnRzIGZyb20gYW4gYXJyYXkgYnkgdmFsdWUuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAyLjAuMFxyXG4gICAgICogQGNhdGVnb3J5IEFycmF5XHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDMsIDRdO1xyXG4gICAgICogdmFyIGV2ZW5zID0gXy5yZW1vdmUoYXJyYXksIGZ1bmN0aW9uKG4pIHtcclxuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDA7XHJcbiAgICAgKiB9KTtcclxuICAgICAqXHJcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XHJcbiAgICAgKiAvLyA9PiBbMSwgM11cclxuICAgICAqXHJcbiAgICAgKiBjb25zb2xlLmxvZyhldmVucyk7XHJcbiAgICAgKiAvLyA9PiBbMiwgNF1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcmVtb3ZlKGFycmF5LCBwcmVkaWNhdGUpIHtcclxuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgICBpZiAoIShhcnJheSAmJiBhcnJheS5sZW5ndGgpKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfVxyXG4gICAgICB2YXIgaW5kZXggPSAtMSxcclxuICAgICAgICAgIGluZGV4ZXMgPSBbXSxcclxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcclxuXHJcbiAgICAgIHByZWRpY2F0ZSA9IGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyk7XHJcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xyXG4gICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcclxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcclxuICAgICAgICAgIGluZGV4ZXMucHVzaChpbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGJhc2VQdWxsQXQoYXJyYXksIGluZGV4ZXMpO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV2ZXJzZXMgYGFycmF5YCBzbyB0aGF0IHRoZSBmaXJzdCBlbGVtZW50IGJlY29tZXMgdGhlIGxhc3QsIHRoZSBzZWNvbmRcclxuICAgICAqIGVsZW1lbnQgYmVjb21lcyB0aGUgc2Vjb25kIHRvIGxhc3QsIGFuZCBzbyBvbi5cclxuICAgICAqXHJcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgIGFuZCBpcyBiYXNlZCBvblxyXG4gICAgICogW2BBcnJheSNyZXZlcnNlYF0oaHR0cHM6Ly9tZG4uaW8vQXJyYXkvcmV2ZXJzZSkuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSA0LjAuMFxyXG4gICAgICogQGNhdGVnb3J5IEFycmF5XHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzXTtcclxuICAgICAqXHJcbiAgICAgKiBfLnJldmVyc2UoYXJyYXkpO1xyXG4gICAgICogLy8gPT4gWzMsIDIsIDFdXHJcbiAgICAgKlxyXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xyXG4gICAgICogLy8gPT4gWzMsIDIsIDFdXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHJldmVyc2UoYXJyYXkpIHtcclxuICAgICAgcmV0dXJuIGFycmF5ID09IG51bGwgPyBhcnJheSA6IG5hdGl2ZVJldmVyc2UuY2FsbChhcnJheSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCBmcm9tIGBzdGFydGAgdXAgdG8sIGJ1dCBub3QgaW5jbHVkaW5nLCBgZW5kYC5cclxuICAgICAqXHJcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgdXNlZCBpbnN0ZWFkIG9mXHJcbiAgICAgKiBbYEFycmF5I3NsaWNlYF0oaHR0cHM6Ly9tZG4uaW8vQXJyYXkvc2xpY2UpIHRvIGVuc3VyZSBkZW5zZSBhcnJheXMgYXJlXHJcbiAgICAgKiByZXR1cm5lZC5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDMuMC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzbGljZS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBzbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xyXG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XHJcbiAgICAgIGlmICghbGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChlbmQgJiYgdHlwZW9mIGVuZCAhPSAnbnVtYmVyJyAmJiBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgc3RhcnQsIGVuZCkpIHtcclxuICAgICAgICBzdGFydCA9IDA7XHJcbiAgICAgICAgZW5kID0gbGVuZ3RoO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHN0YXJ0ID0gc3RhcnQgPT0gbnVsbCA/IDAgOiB0b0ludGVnZXIoc3RhcnQpO1xyXG4gICAgICAgIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9JbnRlZ2VyKGVuZCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VzIGEgYmluYXJ5IHNlYXJjaCB0byBkZXRlcm1pbmUgdGhlIGxvd2VzdCBpbmRleCBhdCB3aGljaCBgdmFsdWVgXHJcbiAgICAgKiBzaG91bGQgYmUgaW5zZXJ0ZWQgaW50byBgYXJyYXlgIGluIG9yZGVyIHRvIG1haW50YWluIGl0cyBzb3J0IG9yZGVyLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgMC4xLjBcclxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxyXG4gICAgICogIGludG8gYGFycmF5YC5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogXy5zb3J0ZWRJbmRleChbMzAsIDUwXSwgNDApO1xyXG4gICAgICogLy8gPT4gMVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBzb3J0ZWRJbmRleChhcnJheSwgdmFsdWUpIHtcclxuICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0ZWRJbmRleGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgXHJcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIGZvciBgdmFsdWVgIGFuZCBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCB0byBjb21wdXRlIHRoZWlyXHJcbiAgICAgKiBzb3J0IHJhbmtpbmcuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgNC4wLjBcclxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxyXG4gICAgICogIGludG8gYGFycmF5YC5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDQgfSwgeyAneCc6IDUgfV07XHJcbiAgICAgKlxyXG4gICAgICogXy5zb3J0ZWRJbmRleEJ5KG9iamVjdHMsIHsgJ3gnOiA0IH0sIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ueDsgfSk7XHJcbiAgICAgKiAvLyA9PiAwXHJcbiAgICAgKlxyXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXHJcbiAgICAgKiBfLnNvcnRlZEluZGV4Qnkob2JqZWN0cywgeyAneCc6IDQgfSwgJ3gnKTtcclxuICAgICAqIC8vID0+IDBcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gc29ydGVkSW5kZXhCeShhcnJheSwgdmFsdWUsIGl0ZXJhdGVlKSB7XHJcbiAgICAgIHJldHVybiBiYXNlU29ydGVkSW5kZXhCeShhcnJheSwgdmFsdWUsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmluZGV4T2ZgIGV4Y2VwdCB0aGF0IGl0IHBlcmZvcm1zIGEgYmluYXJ5XHJcbiAgICAgKiBzZWFyY2ggb24gYSBzb3J0ZWQgYGFycmF5YC5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDQuMC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8uc29ydGVkSW5kZXhPZihbNCwgNSwgNSwgNSwgNl0sIDUpO1xyXG4gICAgICogLy8gPT4gMVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBzb3J0ZWRJbmRleE9mKGFycmF5LCB2YWx1ZSkge1xyXG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XHJcbiAgICAgIGlmIChsZW5ndGgpIHtcclxuICAgICAgICB2YXIgaW5kZXggPSBiYXNlU29ydGVkSW5kZXgoYXJyYXksIHZhbHVlKTtcclxuICAgICAgICBpZiAoaW5kZXggPCBsZW5ndGggJiYgZXEoYXJyYXlbaW5kZXhdLCB2YWx1ZSkpIHtcclxuICAgICAgICAgIHJldHVybiBpbmRleDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0ZWRJbmRleGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgaGlnaGVzdFxyXG4gICAgICogaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWQgaW50byBgYXJyYXlgIGluIG9yZGVyIHRvXHJcbiAgICAgKiBtYWludGFpbiBpdHMgc29ydCBvcmRlci5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDMuMC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcclxuICAgICAqICBpbnRvIGBhcnJheWAuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8uc29ydGVkTGFzdEluZGV4KFs0LCA1LCA1LCA1LCA2XSwgNSk7XHJcbiAgICAgKiAvLyA9PiA0XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHNvcnRlZExhc3RJbmRleChhcnJheSwgdmFsdWUpIHtcclxuICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUsIHRydWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0ZWRMYXN0SW5kZXhgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYFxyXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCBmb3IgYHZhbHVlYCBhbmQgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgdG8gY29tcHV0ZSB0aGVpclxyXG4gICAgICogc29ydCByYW5raW5nLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDQuMC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcclxuICAgICAqICBpbnRvIGBhcnJheWAuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiA0IH0sIHsgJ3gnOiA1IH1dO1xyXG4gICAgICpcclxuICAgICAqIF8uc29ydGVkTGFzdEluZGV4Qnkob2JqZWN0cywgeyAneCc6IDQgfSwgZnVuY3Rpb24obykgeyByZXR1cm4gby54OyB9KTtcclxuICAgICAqIC8vID0+IDFcclxuICAgICAqXHJcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cclxuICAgICAqIF8uc29ydGVkTGFzdEluZGV4Qnkob2JqZWN0cywgeyAneCc6IDQgfSwgJ3gnKTtcclxuICAgICAqIC8vID0+IDFcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gc29ydGVkTGFzdEluZGV4QnkoYXJyYXksIHZhbHVlLCBpdGVyYXRlZSkge1xyXG4gICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMiksIHRydWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5sYXN0SW5kZXhPZmAgZXhjZXB0IHRoYXQgaXQgcGVyZm9ybXMgYSBiaW5hcnlcclxuICAgICAqIHNlYXJjaCBvbiBhIHNvcnRlZCBgYXJyYXlgLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgNC4wLjBcclxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogXy5zb3J0ZWRMYXN0SW5kZXhPZihbNCwgNSwgNSwgNSwgNl0sIDUpO1xyXG4gICAgICogLy8gPT4gM1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBzb3J0ZWRMYXN0SW5kZXhPZihhcnJheSwgdmFsdWUpIHtcclxuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xyXG4gICAgICBpZiAobGVuZ3RoKSB7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gYmFzZVNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSwgdHJ1ZSkgLSAxO1xyXG4gICAgICAgIGlmIChlcShhcnJheVtpbmRleF0sIHZhbHVlKSkge1xyXG4gICAgICAgICAgcmV0dXJuIGluZGV4O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaXFgIGV4Y2VwdCB0aGF0IGl0J3MgZGVzaWduZWQgYW5kIG9wdGltaXplZFxyXG4gICAgICogZm9yIHNvcnRlZCBhcnJheXMuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSA0LjAuMFxyXG4gICAgICogQGNhdGVnb3J5IEFycmF5XHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cclxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLnNvcnRlZFVuaXEoWzEsIDEsIDJdKTtcclxuICAgICAqIC8vID0+IFsxLCAyXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBzb3J0ZWRVbmlxKGFycmF5KSB7XHJcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxyXG4gICAgICAgID8gYmFzZVNvcnRlZFVuaXEoYXJyYXkpXHJcbiAgICAgICAgOiBbXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pcUJ5YCBleGNlcHQgdGhhdCBpdCdzIGRlc2lnbmVkIGFuZCBvcHRpbWl6ZWRcclxuICAgICAqIGZvciBzb3J0ZWQgYXJyYXlzLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgNC4wLjBcclxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8uc29ydGVkVW5pcUJ5KFsxLjEsIDEuMiwgMi4zLCAyLjRdLCBNYXRoLmZsb29yKTtcclxuICAgICAqIC8vID0+IFsxLjEsIDIuM11cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gc29ydGVkVW5pcUJ5KGFycmF5LCBpdGVyYXRlZSkge1xyXG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcclxuICAgICAgICA/IGJhc2VTb3J0ZWRVbmlxKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpXHJcbiAgICAgICAgOiBbXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYWxsIGJ1dCB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgNC4wLjBcclxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLnRhaWwoWzEsIDIsIDNdKTtcclxuICAgICAqIC8vID0+IFsyLCAzXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0YWlsKGFycmF5KSB7XHJcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcclxuICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VTbGljZShhcnJheSwgMSwgbGVuZ3RoKSA6IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBgbmAgZWxlbWVudHMgdGFrZW4gZnJvbSB0aGUgYmVnaW5uaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgMC4xLjBcclxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gdGFrZS5cclxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8udGFrZShbMSwgMiwgM10pO1xyXG4gICAgICogLy8gPT4gWzFdXHJcbiAgICAgKlxyXG4gICAgICogXy50YWtlKFsxLCAyLCAzXSwgMik7XHJcbiAgICAgKiAvLyA9PiBbMSwgMl1cclxuICAgICAqXHJcbiAgICAgKiBfLnRha2UoWzEsIDIsIDNdLCA1KTtcclxuICAgICAqIC8vID0+IFsxLCAyLCAzXVxyXG4gICAgICpcclxuICAgICAqIF8udGFrZShbMSwgMiwgM10sIDApO1xyXG4gICAgICogLy8gPT4gW11cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdGFrZShhcnJheSwgbiwgZ3VhcmQpIHtcclxuICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgICAgfVxyXG4gICAgICBuID0gKGd1YXJkIHx8IG4gPT09IHVuZGVmaW5lZCkgPyAxIDogdG9JbnRlZ2VyKG4pO1xyXG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCAwLCBuIDwgMCA/IDAgOiBuKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGVuZC5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDMuMC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHRha2UuXHJcbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLnRha2VSaWdodChbMSwgMiwgM10pO1xyXG4gICAgICogLy8gPT4gWzNdXHJcbiAgICAgKlxyXG4gICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdLCAyKTtcclxuICAgICAqIC8vID0+IFsyLCAzXVxyXG4gICAgICpcclxuICAgICAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSwgNSk7XHJcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cclxuICAgICAqXHJcbiAgICAgKiBfLnRha2VSaWdodChbMSwgMiwgM10sIDApO1xyXG4gICAgICogLy8gPT4gW11cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdGFrZVJpZ2h0KGFycmF5LCBuLCBndWFyZCkge1xyXG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XHJcbiAgICAgIGlmICghbGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICB9XHJcbiAgICAgIG4gPSAoZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkKSA/IDEgOiB0b0ludGVnZXIobik7XHJcbiAgICAgIG4gPSBsZW5ndGggLSBuO1xyXG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCBuIDwgMCA/IDAgOiBuLCBsZW5ndGgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBlbGVtZW50cyB0YWtlbiBmcm9tIHRoZSBlbmQuIEVsZW1lbnRzIGFyZVxyXG4gICAgICogdGFrZW4gdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoXHJcbiAgICAgKiB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDMuMC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cclxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogdmFyIHVzZXJzID0gW1xyXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogdHJ1ZSB9LFxyXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcclxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH1cclxuICAgICAqIF07XHJcbiAgICAgKlxyXG4gICAgICogXy50YWtlUmlnaHRXaGlsZSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcclxuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCcsICdwZWJibGVzJ11cclxuICAgICAqXHJcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxyXG4gICAgICogXy50YWtlUmlnaHRXaGlsZSh1c2VycywgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xyXG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydwZWJibGVzJ11cclxuICAgICAqXHJcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXHJcbiAgICAgKiBfLnRha2VSaWdodFdoaWxlKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XHJcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnLCAncGViYmxlcyddXHJcbiAgICAgKlxyXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXHJcbiAgICAgKiBfLnRha2VSaWdodFdoaWxlKHVzZXJzLCAnYWN0aXZlJyk7XHJcbiAgICAgKiAvLyA9PiBbXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0YWtlUmlnaHRXaGlsZShhcnJheSwgcHJlZGljYXRlKSB7XHJcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxyXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBmYWxzZSwgdHJ1ZSlcclxuICAgICAgICA6IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBlbGVtZW50cyB0YWtlbiBmcm9tIHRoZSBiZWdpbm5pbmcuIEVsZW1lbnRzXHJcbiAgICAgKiBhcmUgdGFrZW4gdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoXHJcbiAgICAgKiB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDMuMC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cclxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogdmFyIHVzZXJzID0gW1xyXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcclxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXHJcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiB0cnVlIH1cclxuICAgICAqIF07XHJcbiAgICAgKlxyXG4gICAgICogXy50YWtlV2hpbGUodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XHJcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leScsICdmcmVkJ11cclxuICAgICAqXHJcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxyXG4gICAgICogXy50YWtlV2hpbGUodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xyXG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxyXG4gICAgICpcclxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cclxuICAgICAqIF8udGFrZVdoaWxlKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XHJcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leScsICdmcmVkJ11cclxuICAgICAqXHJcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cclxuICAgICAqIF8udGFrZVdoaWxlKHVzZXJzLCAnYWN0aXZlJyk7XHJcbiAgICAgKiAvLyA9PiBbXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0YWtlV2hpbGUoYXJyYXksIHByZWRpY2F0ZSkge1xyXG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcclxuICAgICAgICA/IGJhc2VXaGlsZShhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSlcclxuICAgICAgICA6IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzLCBpbiBvcmRlciwgZnJvbSBhbGwgZ2l2ZW4gYXJyYXlzIHVzaW5nXHJcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxyXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgMC4xLjBcclxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxyXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tYmluZWQgdmFsdWVzLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLnVuaW9uKFsyXSwgWzEsIDJdKTtcclxuICAgICAqIC8vID0+IFsyLCAxXVxyXG4gICAgICovXHJcbiAgICB2YXIgdW5pb24gPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcclxuICAgICAgcmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKGFycmF5cywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlvbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXHJcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgb2YgZWFjaCBgYXJyYXlzYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5XHJcbiAgICAgKiB3aGljaCB1bmlxdWVuZXNzIGlzIGNvbXB1dGVkLiBSZXN1bHQgdmFsdWVzIGFyZSBjaG9zZW4gZnJvbSB0aGUgZmlyc3RcclxuICAgICAqIGFycmF5IGluIHdoaWNoIHRoZSB2YWx1ZSBvY2N1cnMuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OlxyXG4gICAgICogKHZhbHVlKS5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDQuMC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcclxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cclxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbWJpbmVkIHZhbHVlcy5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogXy51bmlvbkJ5KFsyLjFdLCBbMS4yLCAyLjNdLCBNYXRoLmZsb29yKTtcclxuICAgICAqIC8vID0+IFsyLjEsIDEuMl1cclxuICAgICAqXHJcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cclxuICAgICAqIF8udW5pb25CeShbeyAneCc6IDEgfV0sIFt7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgJ3gnKTtcclxuICAgICAqIC8vID0+IFt7ICd4JzogMSB9LCB7ICd4JzogMiB9XVxyXG4gICAgICovXHJcbiAgICB2YXIgdW5pb25CeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xyXG4gICAgICB2YXIgaXRlcmF0ZWUgPSBsYXN0KGFycmF5cyk7XHJcbiAgICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChpdGVyYXRlZSkpIHtcclxuICAgICAgICBpdGVyYXRlZSA9IHVuZGVmaW5lZDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4oYXJyYXlzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pb25gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgIHdoaWNoXHJcbiAgICAgKiBpcyBpbnZva2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYGFycmF5c2AuIFJlc3VsdCB2YWx1ZXMgYXJlIGNob3NlbiBmcm9tXHJcbiAgICAgKiB0aGUgZmlyc3QgYXJyYXkgaW4gd2hpY2ggdGhlIHZhbHVlIG9jY3Vycy4gVGhlIGNvbXBhcmF0b3IgaXMgaW52b2tlZFxyXG4gICAgICogd2l0aCB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgNC4wLjBcclxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxyXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21iaW5lZCB2YWx1ZXMuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9XTtcclxuICAgICAqIHZhciBvdGhlcnMgPSBbeyAneCc6IDEsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAyIH1dO1xyXG4gICAgICpcclxuICAgICAqIF8udW5pb25XaXRoKG9iamVjdHMsIG90aGVycywgXy5pc0VxdWFsKTtcclxuICAgICAqIC8vID0+IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMSB9XVxyXG4gICAgICovXHJcbiAgICB2YXIgdW5pb25XaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XHJcbiAgICAgIHZhciBjb21wYXJhdG9yID0gbGFzdChhcnJheXMpO1xyXG4gICAgICBjb21wYXJhdG9yID0gdHlwZW9mIGNvbXBhcmF0b3IgPT0gJ2Z1bmN0aW9uJyA/IGNvbXBhcmF0b3IgOiB1bmRlZmluZWQ7XHJcbiAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcnJheXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSwgdW5kZWZpbmVkLCBjb21wYXJhdG9yKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGR1cGxpY2F0ZS1mcmVlIHZlcnNpb24gb2YgYW4gYXJyYXksIHVzaW5nXHJcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxyXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpbiB3aGljaCBvbmx5IHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGVhY2ggZWxlbWVudFxyXG4gICAgICogaXMga2VwdC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXIgdGhleSBvY2N1clxyXG4gICAgICogaW4gdGhlIGFycmF5LlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgMC4xLjBcclxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogXy51bmlxKFsyLCAxLCAyXSk7XHJcbiAgICAgKiAvLyA9PiBbMiwgMV1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdW5pcShhcnJheSkge1xyXG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBiYXNlVW5pcShhcnJheSkgOiBbXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pcWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXHJcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoXHJcbiAgICAgKiB1bmlxdWVuZXNzIGlzIGNvbXB1dGVkLiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZVxyXG4gICAgICogb3JkZXIgdGhleSBvY2N1ciBpbiB0aGUgYXJyYXkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OlxyXG4gICAgICogKHZhbHVlKS5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDQuMC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8udW5pcUJ5KFsyLjEsIDEuMiwgMi4zXSwgTWF0aC5mbG9vcik7XHJcbiAgICAgKiAvLyA9PiBbMi4xLCAxLjJdXHJcbiAgICAgKlxyXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXHJcbiAgICAgKiBfLnVuaXFCeShbeyAneCc6IDEgfSwgeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XHJcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEgfSwgeyAneCc6IDIgfV1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdW5pcUJ5KGFycmF5LCBpdGVyYXRlZSkge1xyXG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBiYXNlVW5pcShhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKSA6IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlxYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYCB3aGljaFxyXG4gICAgICogaXMgaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheWAuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzXHJcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBvcmRlciB0aGV5IG9jY3VyIGluIHRoZSBhcnJheS5UaGUgY29tcGFyYXRvciBpcyBpbnZva2VkXHJcbiAgICAgKiB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSA0LjAuMFxyXG4gICAgICogQGNhdGVnb3J5IEFycmF5XHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAyIH1dO1xyXG4gICAgICpcclxuICAgICAqIF8udW5pcVdpdGgob2JqZWN0cywgXy5pc0VxdWFsKTtcclxuICAgICAqIC8vID0+IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfV1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdW5pcVdpdGgoYXJyYXksIGNvbXBhcmF0b3IpIHtcclxuICAgICAgY29tcGFyYXRvciA9IHR5cGVvZiBjb21wYXJhdG9yID09ICdmdW5jdGlvbicgPyBjb21wYXJhdG9yIDogdW5kZWZpbmVkO1xyXG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBiYXNlVW5pcShhcnJheSwgdW5kZWZpbmVkLCBjb21wYXJhdG9yKSA6IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy56aXBgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYW4gYXJyYXkgb2YgZ3JvdXBlZFxyXG4gICAgICogZWxlbWVudHMgYW5kIGNyZWF0ZXMgYW4gYXJyYXkgcmVncm91cGluZyB0aGUgZWxlbWVudHMgdG8gdGhlaXIgcHJlLXppcFxyXG4gICAgICogY29uZmlndXJhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDEuMi4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzIHRvIHByb2Nlc3MuXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiByZWdyb3VwZWQgZWxlbWVudHMuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIHZhciB6aXBwZWQgPSBfLnppcChbJ2EnLCAnYiddLCBbMSwgMl0sIFt0cnVlLCBmYWxzZV0pO1xyXG4gICAgICogLy8gPT4gW1snYScsIDEsIHRydWVdLCBbJ2InLCAyLCBmYWxzZV1dXHJcbiAgICAgKlxyXG4gICAgICogXy51bnppcCh6aXBwZWQpO1xyXG4gICAgICogLy8gPT4gW1snYScsICdiJ10sIFsxLCAyXSwgW3RydWUsIGZhbHNlXV1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdW56aXAoYXJyYXkpIHtcclxuICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgbGVuZ3RoID0gMDtcclxuICAgICAgYXJyYXkgPSBhcnJheUZpbHRlcihhcnJheSwgZnVuY3Rpb24oZ3JvdXApIHtcclxuICAgICAgICBpZiAoaXNBcnJheUxpa2VPYmplY3QoZ3JvdXApKSB7XHJcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoZ3JvdXAubGVuZ3RoLCBsZW5ndGgpO1xyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIGJhc2VUaW1lcyhsZW5ndGgsIGZ1bmN0aW9uKGluZGV4KSB7XHJcbiAgICAgICAgcmV0dXJuIGFycmF5TWFwKGFycmF5LCBiYXNlUHJvcGVydHkoaW5kZXgpKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuemlwYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgdG8gc3BlY2lmeVxyXG4gICAgICogaG93IHJlZ3JvdXBlZCB2YWx1ZXMgc2hvdWxkIGJlIGNvbWJpbmVkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRoZVxyXG4gICAgICogZWxlbWVudHMgb2YgZWFjaCBncm91cDogKC4uLmdyb3VwKS5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDMuOC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzIHRvIHByb2Nlc3MuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIHRvIGNvbWJpbmVcclxuICAgICAqICByZWdyb3VwZWQgdmFsdWVzLlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVncm91cGVkIGVsZW1lbnRzLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiB2YXIgemlwcGVkID0gXy56aXAoWzEsIDJdLCBbMTAsIDIwXSwgWzEwMCwgMjAwXSk7XHJcbiAgICAgKiAvLyA9PiBbWzEsIDEwLCAxMDBdLCBbMiwgMjAsIDIwMF1dXHJcbiAgICAgKlxyXG4gICAgICogXy51bnppcFdpdGgoemlwcGVkLCBfLmFkZCk7XHJcbiAgICAgKiAvLyA9PiBbMywgMzAsIDMwMF1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdW56aXBXaXRoKGFycmF5LCBpdGVyYXRlZSkge1xyXG4gICAgICBpZiAoIShhcnJheSAmJiBhcnJheS5sZW5ndGgpKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciByZXN1bHQgPSB1bnppcChhcnJheSk7XHJcbiAgICAgIGlmIChpdGVyYXRlZSA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gYXJyYXlNYXAocmVzdWx0LCBmdW5jdGlvbihncm91cCkge1xyXG4gICAgICAgIHJldHVybiBhcHBseShpdGVyYXRlZSwgdW5kZWZpbmVkLCBncm91cCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBleGNsdWRpbmcgYWxsIGdpdmVuIHZhbHVlcyB1c2luZ1xyXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcclxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cclxuICAgICAqXHJcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLnB1bGxgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgMC4xLjBcclxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXHJcbiAgICAgKiBAcGFyYW0gey4uLip9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cclxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cclxuICAgICAqIEBzZWUgXy5kaWZmZXJlbmNlLCBfLnhvclxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLndpdGhvdXQoWzIsIDEsIDIsIDNdLCAxLCAyKTtcclxuICAgICAqIC8vID0+IFszXVxyXG4gICAgICovXHJcbiAgICB2YXIgd2l0aG91dCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMpIHtcclxuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KGFycmF5KVxyXG4gICAgICAgID8gYmFzZURpZmZlcmVuY2UoYXJyYXksIHZhbHVlcylcclxuICAgICAgICA6IFtdO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMgdGhhdCBpcyB0aGVcclxuICAgICAqIFtzeW1tZXRyaWMgZGlmZmVyZW5jZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3ltbWV0cmljX2RpZmZlcmVuY2UpXHJcbiAgICAgKiBvZiB0aGUgZ2l2ZW4gYXJyYXlzLiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBvcmRlclxyXG4gICAgICogdGhleSBvY2N1ciBpbiB0aGUgYXJyYXlzLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgMi40LjBcclxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxyXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxyXG4gICAgICogQHNlZSBfLmRpZmZlcmVuY2UsIF8ud2l0aG91dFxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLnhvcihbMiwgMV0sIFsyLCAzXSk7XHJcbiAgICAgKiAvLyA9PiBbMSwgM11cclxuICAgICAqL1xyXG4gICAgdmFyIHhvciA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xyXG4gICAgICByZXR1cm4gYmFzZVhvcihhcnJheUZpbHRlcihhcnJheXMsIGlzQXJyYXlMaWtlT2JqZWN0KSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ueG9yYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcclxuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBvZiBlYWNoIGBhcnJheXNgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnlcclxuICAgICAqIHdoaWNoIGJ5IHdoaWNoIHRoZXkncmUgY29tcGFyZWQuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzIGRldGVybWluZWRcclxuICAgICAqIGJ5IHRoZSBvcmRlciB0aGV5IG9jY3VyIGluIHRoZSBhcnJheXMuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lXHJcbiAgICAgKiBhcmd1bWVudDogKHZhbHVlKS5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDQuMC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcclxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cclxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogXy54b3JCeShbMi4xLCAxLjJdLCBbMi4zLCAzLjRdLCBNYXRoLmZsb29yKTtcclxuICAgICAqIC8vID0+IFsxLjIsIDMuNF1cclxuICAgICAqXHJcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cclxuICAgICAqIF8ueG9yQnkoW3sgJ3gnOiAxIH1dLCBbeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XHJcbiAgICAgKiAvLyA9PiBbeyAneCc6IDIgfV1cclxuICAgICAqL1xyXG4gICAgdmFyIHhvckJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XHJcbiAgICAgIHZhciBpdGVyYXRlZSA9IGxhc3QoYXJyYXlzKTtcclxuICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGl0ZXJhdGVlKSkge1xyXG4gICAgICAgIGl0ZXJhdGVlID0gdW5kZWZpbmVkO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBiYXNlWG9yKGFycmF5RmlsdGVyKGFycmF5cywgaXNBcnJheUxpa2VPYmplY3QpLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnhvcmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY29tcGFyYXRvcmAgd2hpY2ggaXNcclxuICAgICAqIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlzYC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXNcclxuICAgICAqIGRldGVybWluZWQgYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXIgaW4gdGhlIGFycmF5cy4gVGhlIGNvbXBhcmF0b3IgaXMgaW52b2tlZFxyXG4gICAgICogd2l0aCB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgNC4wLjBcclxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxyXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9XTtcclxuICAgICAqIHZhciBvdGhlcnMgPSBbeyAneCc6IDEsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAyIH1dO1xyXG4gICAgICpcclxuICAgICAqIF8ueG9yV2l0aChvYmplY3RzLCBvdGhlcnMsIF8uaXNFcXVhbCk7XHJcbiAgICAgKiAvLyA9PiBbeyAneCc6IDIsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAxIH1dXHJcbiAgICAgKi9cclxuICAgIHZhciB4b3JXaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XHJcbiAgICAgIHZhciBjb21wYXJhdG9yID0gbGFzdChhcnJheXMpO1xyXG4gICAgICBjb21wYXJhdG9yID0gdHlwZW9mIGNvbXBhcmF0b3IgPT0gJ2Z1bmN0aW9uJyA/IGNvbXBhcmF0b3IgOiB1bmRlZmluZWQ7XHJcbiAgICAgIHJldHVybiBiYXNlWG9yKGFycmF5RmlsdGVyKGFycmF5cywgaXNBcnJheUxpa2VPYmplY3QpLCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMsIHRoZSBmaXJzdCBvZiB3aGljaCBjb250YWlucyB0aGVcclxuICAgICAqIGZpcnN0IGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBhcnJheXMsIHRoZSBzZWNvbmQgb2Ygd2hpY2ggY29udGFpbnMgdGhlXHJcbiAgICAgKiBzZWNvbmQgZWxlbWVudHMgb2YgdGhlIGdpdmVuIGFycmF5cywgYW5kIHNvIG9uLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgMC4xLjBcclxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxyXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBwcm9jZXNzLlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cy5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogXy56aXAoWydhJywgJ2InXSwgWzEsIDJdLCBbdHJ1ZSwgZmFsc2VdKTtcclxuICAgICAqIC8vID0+IFtbJ2EnLCAxLCB0cnVlXSwgWydiJywgMiwgZmFsc2VdXVxyXG4gICAgICovXHJcbiAgICB2YXIgemlwID0gYmFzZVJlc3QodW56aXApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mcm9tUGFpcnNgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgdHdvIGFycmF5cyxcclxuICAgICAqIG9uZSBvZiBwcm9wZXJ0eSBpZGVudGlmaWVycyBhbmQgb25lIG9mIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgMC40LjBcclxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BzPVtdXSBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMuXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzPVtdXSBUaGUgcHJvcGVydHkgdmFsdWVzLlxyXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogXy56aXBPYmplY3QoWydhJywgJ2InXSwgWzEsIDJdKTtcclxuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB6aXBPYmplY3QocHJvcHMsIHZhbHVlcykge1xyXG4gICAgICByZXR1cm4gYmFzZVppcE9iamVjdChwcm9wcyB8fCBbXSwgdmFsdWVzIHx8IFtdLCBhc3NpZ25WYWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnppcE9iamVjdGAgZXhjZXB0IHRoYXQgaXQgc3VwcG9ydHMgcHJvcGVydHkgcGF0aHMuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSA0LjEuMFxyXG4gICAgICogQGNhdGVnb3J5IEFycmF5XHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcHM9W11dIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycy5cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXM9W11dIFRoZSBwcm9wZXJ0eSB2YWx1ZXMuXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLnppcE9iamVjdERlZXAoWydhLmJbMF0uYycsICdhLmJbMV0uZCddLCBbMSwgMl0pO1xyXG4gICAgICogLy8gPT4geyAnYSc6IHsgJ2InOiBbeyAnYyc6IDEgfSwgeyAnZCc6IDIgfV0gfSB9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHppcE9iamVjdERlZXAocHJvcHMsIHZhbHVlcykge1xyXG4gICAgICByZXR1cm4gYmFzZVppcE9iamVjdChwcm9wcyB8fCBbXSwgdmFsdWVzIHx8IFtdLCBiYXNlU2V0KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uemlwYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgdG8gc3BlY2lmeVxyXG4gICAgICogaG93IGdyb3VwZWQgdmFsdWVzIHNob3VsZCBiZSBjb21iaW5lZC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aGVcclxuICAgICAqIGVsZW1lbnRzIG9mIGVhY2ggZ3JvdXA6ICguLi5ncm91cCkuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAzLjguMFxyXG4gICAgICogQGNhdGVnb3J5IEFycmF5XHJcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIHByb2Nlc3MuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIHRvIGNvbWJpbmVcclxuICAgICAqICBncm91cGVkIHZhbHVlcy5cclxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8uemlwV2l0aChbMSwgMl0sIFsxMCwgMjBdLCBbMTAwLCAyMDBdLCBmdW5jdGlvbihhLCBiLCBjKSB7XHJcbiAgICAgKiAgIHJldHVybiBhICsgYiArIGM7XHJcbiAgICAgKiB9KTtcclxuICAgICAqIC8vID0+IFsxMTEsIDIyMl1cclxuICAgICAqL1xyXG4gICAgdmFyIHppcFdpdGggPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcclxuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5cy5sZW5ndGgsXHJcbiAgICAgICAgICBpdGVyYXRlZSA9IGxlbmd0aCA+IDEgPyBhcnJheXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XHJcblxyXG4gICAgICBpdGVyYXRlZSA9IHR5cGVvZiBpdGVyYXRlZSA9PSAnZnVuY3Rpb24nID8gKGFycmF5cy5wb3AoKSwgaXRlcmF0ZWUpIDogdW5kZWZpbmVkO1xyXG4gICAgICByZXR1cm4gdW56aXBXaXRoKGFycmF5cywgaXRlcmF0ZWUpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UgdGhhdCB3cmFwcyBgdmFsdWVgIHdpdGggZXhwbGljaXQgbWV0aG9kXHJcbiAgICAgKiBjaGFpbiBzZXF1ZW5jZXMgZW5hYmxlZC4gVGhlIHJlc3VsdCBvZiBzdWNoIHNlcXVlbmNlcyBtdXN0IGJlIHVud3JhcHBlZFxyXG4gICAgICogd2l0aCBgXyN2YWx1ZWAuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAxLjMuMFxyXG4gICAgICogQGNhdGVnb3J5IFNlcVxyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiB2YXIgdXNlcnMgPSBbXHJcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhZ2UnOiAzNiB9LFxyXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAgfSxcclxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEgfVxyXG4gICAgICogXTtcclxuICAgICAqXHJcbiAgICAgKiB2YXIgeW91bmdlc3QgPSBfXHJcbiAgICAgKiAgIC5jaGFpbih1c2VycylcclxuICAgICAqICAgLnNvcnRCeSgnYWdlJylcclxuICAgICAqICAgLm1hcChmdW5jdGlvbihvKSB7XHJcbiAgICAgKiAgICAgcmV0dXJuIG8udXNlciArICcgaXMgJyArIG8uYWdlO1xyXG4gICAgICogICB9KVxyXG4gICAgICogICAuaGVhZCgpXHJcbiAgICAgKiAgIC52YWx1ZSgpO1xyXG4gICAgICogLy8gPT4gJ3BlYmJsZXMgaXMgMSdcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY2hhaW4odmFsdWUpIHtcclxuICAgICAgdmFyIHJlc3VsdCA9IGxvZGFzaCh2YWx1ZSk7XHJcbiAgICAgIHJlc3VsdC5fX2NoYWluX18gPSB0cnVlO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgaW52b2tlcyBgaW50ZXJjZXB0b3JgIGFuZCByZXR1cm5zIGB2YWx1ZWAuIFRoZSBpbnRlcmNlcHRvclxyXG4gICAgICogaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS4gVGhlIHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG9cclxuICAgICAqIFwidGFwIGludG9cIiBhIG1ldGhvZCBjaGFpbiBzZXF1ZW5jZSBpbiBvcmRlciB0byBtb2RpZnkgaW50ZXJtZWRpYXRlIHJlc3VsdHMuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAwLjEuMFxyXG4gICAgICogQGNhdGVnb3J5IFNlcVxyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvdmlkZSB0byBgaW50ZXJjZXB0b3JgLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaW50ZXJjZXB0b3IgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cclxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8oWzEsIDIsIDNdKVxyXG4gICAgICogIC50YXAoZnVuY3Rpb24oYXJyYXkpIHtcclxuICAgICAqICAgIC8vIE11dGF0ZSBpbnB1dCBhcnJheS5cclxuICAgICAqICAgIGFycmF5LnBvcCgpO1xyXG4gICAgICogIH0pXHJcbiAgICAgKiAgLnJldmVyc2UoKVxyXG4gICAgICogIC52YWx1ZSgpO1xyXG4gICAgICogLy8gPT4gWzIsIDFdXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHRhcCh2YWx1ZSwgaW50ZXJjZXB0b3IpIHtcclxuICAgICAgaW50ZXJjZXB0b3IodmFsdWUpO1xyXG4gICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnRhcGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgcmVzdWx0IG9mIGBpbnRlcmNlcHRvcmAuXHJcbiAgICAgKiBUaGUgcHVycG9zZSBvZiB0aGlzIG1ldGhvZCBpcyB0byBcInBhc3MgdGhydVwiIHZhbHVlcyByZXBsYWNpbmcgaW50ZXJtZWRpYXRlXHJcbiAgICAgKiByZXN1bHRzIGluIGEgbWV0aG9kIGNoYWluIHNlcXVlbmNlLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgMy4wLjBcclxuICAgICAqIEBjYXRlZ29yeSBTZXFcclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb3ZpZGUgdG8gYGludGVyY2VwdG9yYC5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGludGVyY2VwdG9yIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXHJcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBpbnRlcmNlcHRvcmAuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8oJyAgYWJjICAnKVxyXG4gICAgICogIC5jaGFpbigpXHJcbiAgICAgKiAgLnRyaW0oKVxyXG4gICAgICogIC50aHJ1KGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgKiAgICByZXR1cm4gW3ZhbHVlXTtcclxuICAgICAqICB9KVxyXG4gICAgICogIC52YWx1ZSgpO1xyXG4gICAgICogLy8gPT4gWydhYmMnXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0aHJ1KHZhbHVlLCBpbnRlcmNlcHRvcikge1xyXG4gICAgICByZXR1cm4gaW50ZXJjZXB0b3IodmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgdGhlIHdyYXBwZXIgdmVyc2lvbiBvZiBgXy5hdGAuXHJcbiAgICAgKlxyXG4gICAgICogQG5hbWUgYXRcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgMS4wLjBcclxuICAgICAqIEBjYXRlZ29yeSBTZXFcclxuICAgICAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfSwgNF0gfTtcclxuICAgICAqXHJcbiAgICAgKiBfKG9iamVjdCkuYXQoWydhWzBdLmIuYycsICdhWzFdJ10pLnZhbHVlKCk7XHJcbiAgICAgKiAvLyA9PiBbMywgNF1cclxuICAgICAqL1xyXG4gICAgdmFyIHdyYXBwZXJBdCA9IGZsYXRSZXN0KGZ1bmN0aW9uKHBhdGhzKSB7XHJcbiAgICAgIHZhciBsZW5ndGggPSBwYXRocy5sZW5ndGgsXHJcbiAgICAgICAgICBzdGFydCA9IGxlbmd0aCA/IHBhdGhzWzBdIDogMCxcclxuICAgICAgICAgIHZhbHVlID0gdGhpcy5fX3dyYXBwZWRfXyxcclxuICAgICAgICAgIGludGVyY2VwdG9yID0gZnVuY3Rpb24ob2JqZWN0KSB7IHJldHVybiBiYXNlQXQob2JqZWN0LCBwYXRocyk7IH07XHJcblxyXG4gICAgICBpZiAobGVuZ3RoID4gMSB8fCB0aGlzLl9fYWN0aW9uc19fLmxlbmd0aCB8fFxyXG4gICAgICAgICAgISh2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSB8fCAhaXNJbmRleChzdGFydCkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50aHJ1KGludGVyY2VwdG9yKTtcclxuICAgICAgfVxyXG4gICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKHN0YXJ0LCArc3RhcnQgKyAobGVuZ3RoID8gMSA6IDApKTtcclxuICAgICAgdmFsdWUuX19hY3Rpb25zX18ucHVzaCh7XHJcbiAgICAgICAgJ2Z1bmMnOiB0aHJ1LFxyXG4gICAgICAgICdhcmdzJzogW2ludGVyY2VwdG9yXSxcclxuICAgICAgICAndGhpc0FyZyc6IHVuZGVmaW5lZFxyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHZhbHVlLCB0aGlzLl9fY2hhaW5fXykudGhydShmdW5jdGlvbihhcnJheSkge1xyXG4gICAgICAgIGlmIChsZW5ndGggJiYgIWFycmF5Lmxlbmd0aCkge1xyXG4gICAgICAgICAgYXJyYXkucHVzaCh1bmRlZmluZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXJyYXk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZSB3aXRoIGV4cGxpY2l0IG1ldGhvZCBjaGFpbiBzZXF1ZW5jZXMgZW5hYmxlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbmFtZSBjaGFpblxyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAwLjEuMFxyXG4gICAgICogQGNhdGVnb3J5IFNlcVxyXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIHZhciB1c2VycyA9IFtcclxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcclxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAgfVxyXG4gICAgICogXTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBBIHNlcXVlbmNlIHdpdGhvdXQgZXhwbGljaXQgY2hhaW5pbmcuXHJcbiAgICAgKiBfKHVzZXJzKS5oZWFkKCk7XHJcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XHJcbiAgICAgKlxyXG4gICAgICogLy8gQSBzZXF1ZW5jZSB3aXRoIGV4cGxpY2l0IGNoYWluaW5nLlxyXG4gICAgICogXyh1c2VycylcclxuICAgICAqICAgLmNoYWluKClcclxuICAgICAqICAgLmhlYWQoKVxyXG4gICAgICogICAucGljaygndXNlcicpXHJcbiAgICAgKiAgIC52YWx1ZSgpO1xyXG4gICAgICogLy8gPT4geyAndXNlcic6ICdiYXJuZXknIH1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gd3JhcHBlckNoYWluKCkge1xyXG4gICAgICByZXR1cm4gY2hhaW4odGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFeGVjdXRlcyB0aGUgY2hhaW4gc2VxdWVuY2UgYW5kIHJldHVybnMgdGhlIHdyYXBwZWQgcmVzdWx0LlxyXG4gICAgICpcclxuICAgICAqIEBuYW1lIGNvbW1pdFxyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAzLjIuMFxyXG4gICAgICogQGNhdGVnb3J5IFNlcVxyXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyXTtcclxuICAgICAqIHZhciB3cmFwcGVkID0gXyhhcnJheSkucHVzaCgzKTtcclxuICAgICAqXHJcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XHJcbiAgICAgKiAvLyA9PiBbMSwgMl1cclxuICAgICAqXHJcbiAgICAgKiB3cmFwcGVkID0gd3JhcHBlZC5jb21taXQoKTtcclxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcclxuICAgICAqIC8vID0+IFsxLCAyLCAzXVxyXG4gICAgICpcclxuICAgICAqIHdyYXBwZWQubGFzdCgpO1xyXG4gICAgICogLy8gPT4gM1xyXG4gICAgICpcclxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcclxuICAgICAqIC8vID0+IFsxLCAyLCAzXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB3cmFwcGVyQ29tbWl0KCkge1xyXG4gICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIodGhpcy52YWx1ZSgpLCB0aGlzLl9fY2hhaW5fXyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBuZXh0IHZhbHVlIG9uIGEgd3JhcHBlZCBvYmplY3QgZm9sbG93aW5nIHRoZVxyXG4gICAgICogW2l0ZXJhdG9yIHByb3RvY29sXShodHRwczovL21kbi5pby9pdGVyYXRpb25fcHJvdG9jb2xzI2l0ZXJhdG9yKS5cclxuICAgICAqXHJcbiAgICAgKiBAbmFtZSBuZXh0XHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDQuMC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXh0IGl0ZXJhdG9yIHZhbHVlLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oWzEsIDJdKTtcclxuICAgICAqXHJcbiAgICAgKiB3cmFwcGVkLm5leHQoKTtcclxuICAgICAqIC8vID0+IHsgJ2RvbmUnOiBmYWxzZSwgJ3ZhbHVlJzogMSB9XHJcbiAgICAgKlxyXG4gICAgICogd3JhcHBlZC5uZXh0KCk7XHJcbiAgICAgKiAvLyA9PiB7ICdkb25lJzogZmFsc2UsICd2YWx1ZSc6IDIgfVxyXG4gICAgICpcclxuICAgICAqIHdyYXBwZWQubmV4dCgpO1xyXG4gICAgICogLy8gPT4geyAnZG9uZSc6IHRydWUsICd2YWx1ZSc6IHVuZGVmaW5lZCB9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHdyYXBwZXJOZXh0KCkge1xyXG4gICAgICBpZiAodGhpcy5fX3ZhbHVlc19fID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB0aGlzLl9fdmFsdWVzX18gPSB0b0FycmF5KHRoaXMudmFsdWUoKSk7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGRvbmUgPSB0aGlzLl9faW5kZXhfXyA+PSB0aGlzLl9fdmFsdWVzX18ubGVuZ3RoLFxyXG4gICAgICAgICAgdmFsdWUgPSBkb25lID8gdW5kZWZpbmVkIDogdGhpcy5fX3ZhbHVlc19fW3RoaXMuX19pbmRleF9fKytdO1xyXG5cclxuICAgICAgcmV0dXJuIHsgJ2RvbmUnOiBkb25lLCAndmFsdWUnOiB2YWx1ZSB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRW5hYmxlcyB0aGUgd3JhcHBlciB0byBiZSBpdGVyYWJsZS5cclxuICAgICAqXHJcbiAgICAgKiBAbmFtZSBTeW1ib2wuaXRlcmF0b3JcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgNC4wLjBcclxuICAgICAqIEBjYXRlZ29yeSBTZXFcclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHdyYXBwZXIgb2JqZWN0LlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oWzEsIDJdKTtcclxuICAgICAqXHJcbiAgICAgKiB3cmFwcGVkW1N5bWJvbC5pdGVyYXRvcl0oKSA9PT0gd3JhcHBlZDtcclxuICAgICAqIC8vID0+IHRydWVcclxuICAgICAqXHJcbiAgICAgKiBBcnJheS5mcm9tKHdyYXBwZWQpO1xyXG4gICAgICogLy8gPT4gWzEsIDJdXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHdyYXBwZXJUb0l0ZXJhdG9yKCkge1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgY2hhaW4gc2VxdWVuY2UgcGxhbnRpbmcgYHZhbHVlYCBhcyB0aGUgd3JhcHBlZCB2YWx1ZS5cclxuICAgICAqXHJcbiAgICAgKiBAbmFtZSBwbGFudFxyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAzLjIuMFxyXG4gICAgICogQGNhdGVnb3J5IFNlcVxyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcGxhbnQuXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcclxuICAgICAqICAgcmV0dXJuIG4gKiBuO1xyXG4gICAgICogfVxyXG4gICAgICpcclxuICAgICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMl0pLm1hcChzcXVhcmUpO1xyXG4gICAgICogdmFyIG90aGVyID0gd3JhcHBlZC5wbGFudChbMywgNF0pO1xyXG4gICAgICpcclxuICAgICAqIG90aGVyLnZhbHVlKCk7XHJcbiAgICAgKiAvLyA9PiBbOSwgMTZdXHJcbiAgICAgKlxyXG4gICAgICogd3JhcHBlZC52YWx1ZSgpO1xyXG4gICAgICogLy8gPT4gWzEsIDRdXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHdyYXBwZXJQbGFudCh2YWx1ZSkge1xyXG4gICAgICB2YXIgcmVzdWx0LFxyXG4gICAgICAgICAgcGFyZW50ID0gdGhpcztcclxuXHJcbiAgICAgIHdoaWxlIChwYXJlbnQgaW5zdGFuY2VvZiBiYXNlTG9kYXNoKSB7XHJcbiAgICAgICAgdmFyIGNsb25lID0gd3JhcHBlckNsb25lKHBhcmVudCk7XHJcbiAgICAgICAgY2xvbmUuX19pbmRleF9fID0gMDtcclxuICAgICAgICBjbG9uZS5fX3ZhbHVlc19fID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgICAgIHByZXZpb3VzLl9fd3JhcHBlZF9fID0gY2xvbmU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJlc3VsdCA9IGNsb25lO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcHJldmlvdXMgPSBjbG9uZTtcclxuICAgICAgICBwYXJlbnQgPSBwYXJlbnQuX193cmFwcGVkX187XHJcbiAgICAgIH1cclxuICAgICAgcHJldmlvdXMuX193cmFwcGVkX18gPSB2YWx1ZTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHRoZSB3cmFwcGVyIHZlcnNpb24gb2YgYF8ucmV2ZXJzZWAuXHJcbiAgICAgKlxyXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgdGhlIHdyYXBwZWQgYXJyYXkuXHJcbiAgICAgKlxyXG4gICAgICogQG5hbWUgcmV2ZXJzZVxyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAwLjEuMFxyXG4gICAgICogQGNhdGVnb3J5IFNlcVxyXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzXTtcclxuICAgICAqXHJcbiAgICAgKiBfKGFycmF5KS5yZXZlcnNlKCkudmFsdWUoKVxyXG4gICAgICogLy8gPT4gWzMsIDIsIDFdXHJcbiAgICAgKlxyXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xyXG4gICAgICogLy8gPT4gWzMsIDIsIDFdXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHdyYXBwZXJSZXZlcnNlKCkge1xyXG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLl9fd3JhcHBlZF9fO1xyXG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikge1xyXG4gICAgICAgIHZhciB3cmFwcGVkID0gdmFsdWU7XHJcbiAgICAgICAgaWYgKHRoaXMuX19hY3Rpb25zX18ubGVuZ3RoKSB7XHJcbiAgICAgICAgICB3cmFwcGVkID0gbmV3IExhenlXcmFwcGVyKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3cmFwcGVkID0gd3JhcHBlZC5yZXZlcnNlKCk7XHJcbiAgICAgICAgd3JhcHBlZC5fX2FjdGlvbnNfXy5wdXNoKHtcclxuICAgICAgICAgICdmdW5jJzogdGhydSxcclxuICAgICAgICAgICdhcmdzJzogW3JldmVyc2VdLFxyXG4gICAgICAgICAgJ3RoaXNBcmcnOiB1bmRlZmluZWRcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIod3JhcHBlZCwgdGhpcy5fX2NoYWluX18pO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLnRocnUocmV2ZXJzZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFeGVjdXRlcyB0aGUgY2hhaW4gc2VxdWVuY2UgdG8gcmVzb2x2ZSB0aGUgdW53cmFwcGVkIHZhbHVlLlxyXG4gICAgICpcclxuICAgICAqIEBuYW1lIHZhbHVlXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDAuMS4wXHJcbiAgICAgKiBAYWxpYXMgdG9KU09OLCB2YWx1ZU9mXHJcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXHJcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdW53cmFwcGVkIHZhbHVlLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfKFsxLCAyLCAzXSkudmFsdWUoKTtcclxuICAgICAqIC8vID0+IFsxLCAyLCAzXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB3cmFwcGVyVmFsdWUoKSB7XHJcbiAgICAgIHJldHVybiBiYXNlV3JhcHBlclZhbHVlKHRoaXMuX193cmFwcGVkX18sIHRoaXMuX19hY3Rpb25zX18pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xyXG4gICAgICogZWFjaCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCB0aHJ1IGBpdGVyYXRlZWAuIFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIG9mXHJcbiAgICAgKiBlYWNoIGtleSBpcyB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoZSBrZXkgd2FzIHJldHVybmVkIGJ5IGBpdGVyYXRlZWAuIFRoZVxyXG4gICAgICogaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDAuNS4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxyXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8uY291bnRCeShbNi4xLCA0LjIsIDYuM10sIE1hdGguZmxvb3IpO1xyXG4gICAgICogLy8gPT4geyAnNCc6IDEsICc2JzogMiB9XHJcbiAgICAgKlxyXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXHJcbiAgICAgKiBfLmNvdW50QnkoWydvbmUnLCAndHdvJywgJ3RocmVlJ10sICdsZW5ndGgnKTtcclxuICAgICAqIC8vID0+IHsgJzMnOiAyLCAnNSc6IDEgfVxyXG4gICAgICovXHJcbiAgICB2YXIgY291bnRCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XHJcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwga2V5KSkge1xyXG4gICAgICAgICsrcmVzdWx0W2tleV07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCAxKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yICoqYWxsKiogZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLlxyXG4gICAgICogSXRlcmF0aW9uIGlzIHN0b3BwZWQgb25jZSBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpc1xyXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxyXG4gICAgICpcclxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCByZXR1cm5zIGB0cnVlYCBmb3JcclxuICAgICAqIFtlbXB0eSBjb2xsZWN0aW9uc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRW1wdHlfc2V0KSBiZWNhdXNlXHJcbiAgICAgKiBbZXZlcnl0aGluZyBpcyB0cnVlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WYWN1b3VzX3RydXRoKSBvZlxyXG4gICAgICogZWxlbWVudHMgb2YgZW1wdHkgY29sbGVjdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAwLjEuMFxyXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cclxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cclxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3MgdGhlIHByZWRpY2F0ZSBjaGVjayxcclxuICAgICAqICBlbHNlIGBmYWxzZWAuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8uZXZlcnkoW3RydWUsIDEsIG51bGwsICd5ZXMnXSwgQm9vbGVhbik7XHJcbiAgICAgKiAvLyA9PiBmYWxzZVxyXG4gICAgICpcclxuICAgICAqIHZhciB1c2VycyA9IFtcclxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSB9LFxyXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH1cclxuICAgICAqIF07XHJcbiAgICAgKlxyXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cclxuICAgICAqIF8uZXZlcnkodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xyXG4gICAgICogLy8gPT4gZmFsc2VcclxuICAgICAqXHJcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXHJcbiAgICAgKiBfLmV2ZXJ5KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XHJcbiAgICAgKiAvLyA9PiB0cnVlXHJcbiAgICAgKlxyXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXHJcbiAgICAgKiBfLmV2ZXJ5KHVzZXJzLCAnYWN0aXZlJyk7XHJcbiAgICAgKiAvLyA9PiBmYWxzZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBldmVyeShjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGd1YXJkKSB7XHJcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RXZlcnkgOiBiYXNlRXZlcnk7XHJcbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGd1YXJkKSkge1xyXG4gICAgICAgIHByZWRpY2F0ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgYWxsIGVsZW1lbnRzXHJcbiAgICAgKiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHRocmVlXHJcbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cclxuICAgICAqXHJcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLnJlbW92ZWAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAwLjEuMFxyXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cclxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cclxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxyXG4gICAgICogQHNlZSBfLnJlamVjdFxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiB2YXIgdXNlcnMgPSBbXHJcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxyXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH1cclxuICAgICAqIF07XHJcbiAgICAgKlxyXG4gICAgICogXy5maWx0ZXIodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XHJcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxyXG4gICAgICpcclxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXHJcbiAgICAgKiBfLmZpbHRlcih1c2VycywgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0pO1xyXG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxyXG4gICAgICpcclxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cclxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XHJcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxyXG4gICAgICpcclxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxyXG4gICAgICogXy5maWx0ZXIodXNlcnMsICdhY3RpdmUnKTtcclxuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cclxuICAgICAqXHJcbiAgICAgKiAvLyBDb21iaW5pbmcgc2V2ZXJhbCBwcmVkaWNhdGVzIHVzaW5nIGBfLm92ZXJFdmVyeWAgb3IgYF8ub3ZlclNvbWVgLlxyXG4gICAgICogXy5maWx0ZXIodXNlcnMsIF8ub3ZlclNvbWUoW3sgJ2FnZSc6IDM2IH0sIFsnYWdlJywgNDBdXSkpO1xyXG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJywgJ2Jhcm5leSddXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZpbHRlcihjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcclxuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlGaWx0ZXIgOiBiYXNlRmlsdGVyO1xyXG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLCByZXR1cm5pbmcgdGhlIGZpcnN0IGVsZW1lbnRcclxuICAgICAqIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhyZWVcclxuICAgICAqIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgMC4xLjBcclxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxyXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hdGNoZWQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogdmFyIHVzZXJzID0gW1xyXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXHJcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0sXHJcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IHRydWUgfVxyXG4gICAgICogXTtcclxuICAgICAqXHJcbiAgICAgKiBfLmZpbmQodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWdlIDwgNDA7IH0pO1xyXG4gICAgICogLy8gPT4gb2JqZWN0IGZvciAnYmFybmV5J1xyXG4gICAgICpcclxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXHJcbiAgICAgKiBfLmZpbmQodXNlcnMsIHsgJ2FnZSc6IDEsICdhY3RpdmUnOiB0cnVlIH0pO1xyXG4gICAgICogLy8gPT4gb2JqZWN0IGZvciAncGViYmxlcydcclxuICAgICAqXHJcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXHJcbiAgICAgKiBfLmZpbmQodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcclxuICAgICAqIC8vID0+IG9iamVjdCBmb3IgJ2ZyZWQnXHJcbiAgICAgKlxyXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXHJcbiAgICAgKiBfLmZpbmQodXNlcnMsICdhY3RpdmUnKTtcclxuICAgICAqIC8vID0+IG9iamVjdCBmb3IgJ2Jhcm5leSdcclxuICAgICAqL1xyXG4gICAgdmFyIGZpbmQgPSBjcmVhdGVGaW5kKGZpbmRJbmRleCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcclxuICAgICAqIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAyLjAuMFxyXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cclxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD1jb2xsZWN0aW9uLmxlbmd0aC0xXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXHJcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF0Y2hlZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLmZpbmRMYXN0KFsxLCAyLCAzLCA0XSwgZnVuY3Rpb24obikge1xyXG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMTtcclxuICAgICAqIH0pO1xyXG4gICAgICogLy8gPT4gM1xyXG4gICAgICovXHJcbiAgICB2YXIgZmluZExhc3QgPSBjcmVhdGVGaW5kKGZpbmRMYXN0SW5kZXgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGZsYXR0ZW5lZCBhcnJheSBvZiB2YWx1ZXMgYnkgcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gXHJcbiAgICAgKiB0aHJ1IGBpdGVyYXRlZWAgYW5kIGZsYXR0ZW5pbmcgdGhlIG1hcHBlZCByZXN1bHRzLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZFxyXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDQuMC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxyXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIGZ1bmN0aW9uIGR1cGxpY2F0ZShuKSB7XHJcbiAgICAgKiAgIHJldHVybiBbbiwgbl07XHJcbiAgICAgKiB9XHJcbiAgICAgKlxyXG4gICAgICogXy5mbGF0TWFwKFsxLCAyXSwgZHVwbGljYXRlKTtcclxuICAgICAqIC8vID0+IFsxLCAxLCAyLCAyXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBmbGF0TWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XHJcbiAgICAgIHJldHVybiBiYXNlRmxhdHRlbihtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpLCAxKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmxhdE1hcGAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgZmxhdHRlbnMgdGhlXHJcbiAgICAgKiBtYXBwZWQgcmVzdWx0cy5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDQuNy4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxyXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIGZ1bmN0aW9uIGR1cGxpY2F0ZShuKSB7XHJcbiAgICAgKiAgIHJldHVybiBbW1tuLCBuXV1dO1xyXG4gICAgICogfVxyXG4gICAgICpcclxuICAgICAqIF8uZmxhdE1hcERlZXAoWzEsIDJdLCBkdXBsaWNhdGUpO1xyXG4gICAgICogLy8gPT4gWzEsIDEsIDIsIDJdXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZsYXRNYXBEZWVwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XHJcbiAgICAgIHJldHVybiBiYXNlRmxhdHRlbihtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpLCBJTkZJTklUWSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZsYXRNYXBgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGZsYXR0ZW5zIHRoZVxyXG4gICAgICogbWFwcGVkIHJlc3VsdHMgdXAgdG8gYGRlcHRoYCB0aW1lcy5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDQuNy4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxyXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RlcHRoPTFdIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cclxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogZnVuY3Rpb24gZHVwbGljYXRlKG4pIHtcclxuICAgICAqICAgcmV0dXJuIFtbW24sIG5dXV07XHJcbiAgICAgKiB9XHJcbiAgICAgKlxyXG4gICAgICogXy5mbGF0TWFwRGVwdGgoWzEsIDJdLCBkdXBsaWNhdGUsIDIpO1xyXG4gICAgICogLy8gPT4gW1sxLCAxXSwgWzIsIDJdXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBmbGF0TWFwRGVwdGgoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGRlcHRoKSB7XHJcbiAgICAgIGRlcHRoID0gZGVwdGggPT09IHVuZGVmaW5lZCA/IDEgOiB0b0ludGVnZXIoZGVwdGgpO1xyXG4gICAgICByZXR1cm4gYmFzZUZsYXR0ZW4obWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSwgZGVwdGgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBlbGVtZW50LlxyXG4gICAgICogVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cclxuICAgICAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cclxuICAgICAqXHJcbiAgICAgKiAqKk5vdGU6KiogQXMgd2l0aCBvdGhlciBcIkNvbGxlY3Rpb25zXCIgbWV0aG9kcywgb2JqZWN0cyB3aXRoIGEgXCJsZW5ndGhcIlxyXG4gICAgICogcHJvcGVydHkgYXJlIGl0ZXJhdGVkIGxpa2UgYXJyYXlzLiBUbyBhdm9pZCB0aGlzIGJlaGF2aW9yIHVzZSBgXy5mb3JJbmBcclxuICAgICAqIG9yIGBfLmZvck93bmAgZm9yIG9iamVjdCBpdGVyYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAwLjEuMFxyXG4gICAgICogQGFsaWFzIGVhY2hcclxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cclxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxyXG4gICAgICogQHNlZSBfLmZvckVhY2hSaWdodFxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLmZvckVhY2goWzEsIDJdLCBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICogICBjb25zb2xlLmxvZyh2YWx1ZSk7XHJcbiAgICAgKiB9KTtcclxuICAgICAqIC8vID0+IExvZ3MgYDFgIHRoZW4gYDJgLlxyXG4gICAgICpcclxuICAgICAqIF8uZm9yRWFjaCh7ICdhJzogMSwgJ2InOiAyIH0sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcclxuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcclxuICAgICAqIH0pO1xyXG4gICAgICogLy8gPT4gTG9ncyAnYScgdGhlbiAnYicgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCkuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZvckVhY2goY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcclxuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlFYWNoIDogYmFzZUVhY2g7XHJcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvckVhY2hgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcclxuICAgICAqIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAyLjAuMFxyXG4gICAgICogQGFsaWFzIGVhY2hSaWdodFxyXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cclxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxyXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXHJcbiAgICAgKiBAc2VlIF8uZm9yRWFjaFxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLmZvckVhY2hSaWdodChbMSwgMl0sIGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgKiAgIGNvbnNvbGUubG9nKHZhbHVlKTtcclxuICAgICAqIH0pO1xyXG4gICAgICogLy8gPT4gTG9ncyBgMmAgdGhlbiBgMWAuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZvckVhY2hSaWdodChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xyXG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUVhY2hSaWdodCA6IGJhc2VFYWNoUmlnaHQ7XHJcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmdcclxuICAgICAqIGVhY2ggZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLiBUaGUgb3JkZXIgb2YgZ3JvdXBlZCB2YWx1ZXNcclxuICAgICAqIGlzIGRldGVybWluZWQgYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXIgaW4gYGNvbGxlY3Rpb25gLiBUaGUgY29ycmVzcG9uZGluZ1xyXG4gICAgICogdmFsdWUgb2YgZWFjaCBrZXkgaXMgYW4gYXJyYXkgb2YgZWxlbWVudHMgcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgdGhlXHJcbiAgICAgKiBrZXkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgMC4xLjBcclxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxyXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogXy5ncm91cEJ5KFs2LjEsIDQuMiwgNi4zXSwgTWF0aC5mbG9vcik7XHJcbiAgICAgKiAvLyA9PiB7ICc0JzogWzQuMl0sICc2JzogWzYuMSwgNi4zXSB9XHJcbiAgICAgKlxyXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXHJcbiAgICAgKiBfLmdyb3VwQnkoWydvbmUnLCAndHdvJywgJ3RocmVlJ10sICdsZW5ndGgnKTtcclxuICAgICAqIC8vID0+IHsgJzMnOiBbJ29uZScsICd0d28nXSwgJzUnOiBbJ3RocmVlJ10gfVxyXG4gICAgICovXHJcbiAgICB2YXIgZ3JvdXBCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XHJcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwga2V5KSkge1xyXG4gICAgICAgIHJlc3VsdFtrZXldLnB1c2godmFsdWUpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgW3ZhbHVlXSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gYGNvbGxlY3Rpb25gLiBJZiBgY29sbGVjdGlvbmAgaXMgYSBzdHJpbmcsIGl0J3NcclxuICAgICAqIGNoZWNrZWQgZm9yIGEgc3Vic3RyaW5nIG9mIGB2YWx1ZWAsIG90aGVyd2lzZVxyXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcclxuICAgICAqIGlzIHVzZWQgZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBJZiBgZnJvbUluZGV4YCBpcyBuZWdhdGl2ZSwgaXQncyB1c2VkIGFzXHJcbiAgICAgKiB0aGUgb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiBgY29sbGVjdGlvbmAuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAwLjEuMFxyXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cclxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cclxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLnJlZHVjZWAuXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLmluY2x1ZGVzKFsxLCAyLCAzXSwgMSk7XHJcbiAgICAgKiAvLyA9PiB0cnVlXHJcbiAgICAgKlxyXG4gICAgICogXy5pbmNsdWRlcyhbMSwgMiwgM10sIDEsIDIpO1xyXG4gICAgICogLy8gPT4gZmFsc2VcclxuICAgICAqXHJcbiAgICAgKiBfLmluY2x1ZGVzKHsgJ2EnOiAxLCAnYic6IDIgfSwgMSk7XHJcbiAgICAgKiAvLyA9PiB0cnVlXHJcbiAgICAgKlxyXG4gICAgICogXy5pbmNsdWRlcygnYWJjZCcsICdiYycpO1xyXG4gICAgICogLy8gPT4gdHJ1ZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpbmNsdWRlcyhjb2xsZWN0aW9uLCB2YWx1ZSwgZnJvbUluZGV4LCBndWFyZCkge1xyXG4gICAgICBjb2xsZWN0aW9uID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBjb2xsZWN0aW9uIDogdmFsdWVzKGNvbGxlY3Rpb24pO1xyXG4gICAgICBmcm9tSW5kZXggPSAoZnJvbUluZGV4ICYmICFndWFyZCkgPyB0b0ludGVnZXIoZnJvbUluZGV4KSA6IDA7XHJcblxyXG4gICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XHJcbiAgICAgIGlmIChmcm9tSW5kZXggPCAwKSB7XHJcbiAgICAgICAgZnJvbUluZGV4ID0gbmF0aXZlTWF4KGxlbmd0aCArIGZyb21JbmRleCwgMCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGlzU3RyaW5nKGNvbGxlY3Rpb24pXHJcbiAgICAgICAgPyAoZnJvbUluZGV4IDw9IGxlbmd0aCAmJiBjb2xsZWN0aW9uLmluZGV4T2YodmFsdWUsIGZyb21JbmRleCkgPiAtMSlcclxuICAgICAgICA6ICghIWxlbmd0aCAmJiBiYXNlSW5kZXhPZihjb2xsZWN0aW9uLCB2YWx1ZSwgZnJvbUluZGV4KSA+IC0xKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEludm9rZXMgdGhlIG1ldGhvZCBhdCBgcGF0aGAgb2YgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nXHJcbiAgICAgKiBhbiBhcnJheSBvZiB0aGUgcmVzdWx0cyBvZiBlYWNoIGludm9rZWQgbWV0aG9kLiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHNcclxuICAgICAqIGFyZSBwcm92aWRlZCB0byBlYWNoIGludm9rZWQgbWV0aG9kLiBJZiBgcGF0aGAgaXMgYSBmdW5jdGlvbiwgaXQncyBpbnZva2VkXHJcbiAgICAgKiBmb3IsIGFuZCBgdGhpc2AgYm91bmQgdG8sIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSA0LjAuMFxyXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cclxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cclxuICAgICAqIEBwYXJhbSB7QXJyYXl8RnVuY3Rpb258c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlIG9yXHJcbiAgICAgKiAgdGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cclxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGVhY2ggbWV0aG9kIHdpdGguXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8uaW52b2tlTWFwKFtbNSwgMSwgN10sIFszLCAyLCAxXV0sICdzb3J0Jyk7XHJcbiAgICAgKiAvLyA9PiBbWzEsIDUsIDddLCBbMSwgMiwgM11dXHJcbiAgICAgKlxyXG4gICAgICogXy5pbnZva2VNYXAoWzEyMywgNDU2XSwgU3RyaW5nLnByb3RvdHlwZS5zcGxpdCwgJycpO1xyXG4gICAgICogLy8gPT4gW1snMScsICcyJywgJzMnXSwgWyc0JywgJzUnLCAnNiddXVxyXG4gICAgICovXHJcbiAgICB2YXIgaW52b2tlTWFwID0gYmFzZVJlc3QoZnVuY3Rpb24oY29sbGVjdGlvbiwgcGF0aCwgYXJncykge1xyXG4gICAgICB2YXIgaW5kZXggPSAtMSxcclxuICAgICAgICAgIGlzRnVuYyA9IHR5cGVvZiBwYXRoID09ICdmdW5jdGlvbicsXHJcbiAgICAgICAgICByZXN1bHQgPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IEFycmF5KGNvbGxlY3Rpb24ubGVuZ3RoKSA6IFtdO1xyXG5cclxuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICByZXN1bHRbKytpbmRleF0gPSBpc0Z1bmMgPyBhcHBseShwYXRoLCB2YWx1ZSwgYXJncykgOiBiYXNlSW52b2tlKHZhbHVlLCBwYXRoLCBhcmdzKTtcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xyXG4gICAgICogZWFjaCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCB0aHJ1IGBpdGVyYXRlZWAuIFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIG9mXHJcbiAgICAgKiBlYWNoIGtleSBpcyB0aGUgbGFzdCBlbGVtZW50IHJlc3BvbnNpYmxlIGZvciBnZW5lcmF0aW5nIHRoZSBrZXkuIFRoZVxyXG4gICAgICogaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDQuMC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxyXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIHZhciBhcnJheSA9IFtcclxuICAgICAqICAgeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sXHJcbiAgICAgKiAgIHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH1cclxuICAgICAqIF07XHJcbiAgICAgKlxyXG4gICAgICogXy5rZXlCeShhcnJheSwgZnVuY3Rpb24obykge1xyXG4gICAgICogICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShvLmNvZGUpO1xyXG4gICAgICogfSk7XHJcbiAgICAgKiAvLyA9PiB7ICdhJzogeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sICdkJzogeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfSB9XHJcbiAgICAgKlxyXG4gICAgICogXy5rZXlCeShhcnJheSwgJ2RpcicpO1xyXG4gICAgICogLy8gPT4geyAnbGVmdCc6IHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LCAncmlnaHQnOiB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9IH1cclxuICAgICAqL1xyXG4gICAgdmFyIGtleUJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcclxuICAgICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCB2YWx1ZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdmFsdWVzIGJ5IHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCB0aHJ1XHJcbiAgICAgKiBgaXRlcmF0ZWVgLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcclxuICAgICAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cclxuICAgICAqXHJcbiAgICAgKiBNYW55IGxvZGFzaCBtZXRob2RzIGFyZSBndWFyZGVkIHRvIHdvcmsgYXMgaXRlcmF0ZWVzIGZvciBtZXRob2RzIGxpa2VcclxuICAgICAqIGBfLmV2ZXJ5YCwgYF8uZmlsdGVyYCwgYF8ubWFwYCwgYF8ubWFwVmFsdWVzYCwgYF8ucmVqZWN0YCwgYW5kIGBfLnNvbWVgLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBndWFyZGVkIG1ldGhvZHMgYXJlOlxyXG4gICAgICogYGFyeWAsIGBjaHVua2AsIGBjdXJyeWAsIGBjdXJyeVJpZ2h0YCwgYGRyb3BgLCBgZHJvcFJpZ2h0YCwgYGV2ZXJ5YCxcclxuICAgICAqIGBmaWxsYCwgYGludmVydGAsIGBwYXJzZUludGAsIGByYW5kb21gLCBgcmFuZ2VgLCBgcmFuZ2VSaWdodGAsIGByZXBlYXRgLFxyXG4gICAgICogYHNhbXBsZVNpemVgLCBgc2xpY2VgLCBgc29tZWAsIGBzb3J0QnlgLCBgc3BsaXRgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLFxyXG4gICAgICogYHRlbXBsYXRlYCwgYHRyaW1gLCBgdHJpbUVuZGAsIGB0cmltU3RhcnRgLCBhbmQgYHdvcmRzYFxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgMC4xLjBcclxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cclxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcclxuICAgICAqICAgcmV0dXJuIG4gKiBuO1xyXG4gICAgICogfVxyXG4gICAgICpcclxuICAgICAqIF8ubWFwKFs0LCA4XSwgc3F1YXJlKTtcclxuICAgICAqIC8vID0+IFsxNiwgNjRdXHJcbiAgICAgKlxyXG4gICAgICogXy5tYXAoeyAnYSc6IDQsICdiJzogOCB9LCBzcXVhcmUpO1xyXG4gICAgICogLy8gPT4gWzE2LCA2NF0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcclxuICAgICAqXHJcbiAgICAgKiB2YXIgdXNlcnMgPSBbXHJcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JyB9LFxyXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnIH1cclxuICAgICAqIF07XHJcbiAgICAgKlxyXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXHJcbiAgICAgKiBfLm1hcCh1c2VycywgJ3VzZXInKTtcclxuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcclxuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlNYXAgOiBiYXNlTWFwO1xyXG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMykpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0QnlgIGV4Y2VwdCB0aGF0IGl0IGFsbG93cyBzcGVjaWZ5aW5nIHRoZSBzb3J0XHJcbiAgICAgKiBvcmRlcnMgb2YgdGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LiBJZiBgb3JkZXJzYCBpcyB1bnNwZWNpZmllZCwgYWxsIHZhbHVlc1xyXG4gICAgICogYXJlIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIuIE90aGVyd2lzZSwgc3BlY2lmeSBhbiBvcmRlciBvZiBcImRlc2NcIiBmb3JcclxuICAgICAqIGRlc2NlbmRpbmcgb3IgXCJhc2NcIiBmb3IgYXNjZW5kaW5nIHNvcnQgb3JkZXIgb2YgY29ycmVzcG9uZGluZyB2YWx1ZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSA0LjAuMFxyXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cclxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cclxuICAgICAqIEBwYXJhbSB7QXJyYXlbXXxGdW5jdGlvbltdfE9iamVjdFtdfHN0cmluZ1tdfSBbaXRlcmF0ZWVzPVtfLmlkZW50aXR5XV1cclxuICAgICAqICBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBbb3JkZXJzXSBUaGUgc29ydCBvcmRlcnMgb2YgYGl0ZXJhdGVlc2AuXHJcbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5yZWR1Y2VgLlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiB2YXIgdXNlcnMgPSBbXHJcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQ4IH0sXHJcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM0IH0sXHJcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH0sXHJcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH1cclxuICAgICAqIF07XHJcbiAgICAgKlxyXG4gICAgICogLy8gU29ydCBieSBgdXNlcmAgaW4gYXNjZW5kaW5nIG9yZGVyIGFuZCBieSBgYWdlYCBpbiBkZXNjZW5kaW5nIG9yZGVyLlxyXG4gICAgICogXy5vcmRlckJ5KHVzZXJzLCBbJ3VzZXInLCAnYWdlJ10sIFsnYXNjJywgJ2Rlc2MnXSk7XHJcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAzNl0sIFsnYmFybmV5JywgMzRdLCBbJ2ZyZWQnLCA0OF0sIFsnZnJlZCcsIDQwXV1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gb3JkZXJCeShjb2xsZWN0aW9uLCBpdGVyYXRlZXMsIG9yZGVycywgZ3VhcmQpIHtcclxuICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIWlzQXJyYXkoaXRlcmF0ZWVzKSkge1xyXG4gICAgICAgIGl0ZXJhdGVlcyA9IGl0ZXJhdGVlcyA9PSBudWxsID8gW10gOiBbaXRlcmF0ZWVzXTtcclxuICAgICAgfVxyXG4gICAgICBvcmRlcnMgPSBndWFyZCA/IHVuZGVmaW5lZCA6IG9yZGVycztcclxuICAgICAgaWYgKCFpc0FycmF5KG9yZGVycykpIHtcclxuICAgICAgICBvcmRlcnMgPSBvcmRlcnMgPT0gbnVsbCA/IFtdIDogW29yZGVyc107XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMgc3BsaXQgaW50byB0d28gZ3JvdXBzLCB0aGUgZmlyc3Qgb2Ygd2hpY2hcclxuICAgICAqIGNvbnRhaW5zIGVsZW1lbnRzIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciwgdGhlIHNlY29uZCBvZiB3aGljaFxyXG4gICAgICogY29udGFpbnMgZWxlbWVudHMgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkgZm9yLiBUaGUgcHJlZGljYXRlIGlzXHJcbiAgICAgKiBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgMy4wLjBcclxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIHZhciB1c2VycyA9IFtcclxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FnZSc6IDM2LCAnYWN0aXZlJzogZmFsc2UgfSxcclxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogdHJ1ZSB9LFxyXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSwgICdhY3RpdmUnOiBmYWxzZSB9XHJcbiAgICAgKiBdO1xyXG4gICAgICpcclxuICAgICAqIF8ucGFydGl0aW9uKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFjdGl2ZTsgfSk7XHJcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydmcmVkJ10sIFsnYmFybmV5JywgJ3BlYmJsZXMnXV1cclxuICAgICAqXHJcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxyXG4gICAgICogXy5wYXJ0aXRpb24odXNlcnMsIHsgJ2FnZSc6IDEsICdhY3RpdmUnOiBmYWxzZSB9KTtcclxuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ3BlYmJsZXMnXSwgWydiYXJuZXknLCAnZnJlZCddXVxyXG4gICAgICpcclxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cclxuICAgICAqIF8ucGFydGl0aW9uKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XHJcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAncGViYmxlcyddLCBbJ2ZyZWQnXV1cclxuICAgICAqXHJcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cclxuICAgICAqIF8ucGFydGl0aW9uKHVzZXJzLCAnYWN0aXZlJyk7XHJcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydmcmVkJ10sIFsnYmFybmV5JywgJ3BlYmJsZXMnXV1cclxuICAgICAqL1xyXG4gICAgdmFyIHBhcnRpdGlvbiA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XHJcbiAgICAgIHJlc3VsdFtrZXkgPyAwIDogMV0ucHVzaCh2YWx1ZSk7XHJcbiAgICB9LCBmdW5jdGlvbigpIHsgcmV0dXJuIFtbXSwgW11dOyB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZHVjZXMgYGNvbGxlY3Rpb25gIHRvIGEgdmFsdWUgd2hpY2ggaXMgdGhlIGFjY3VtdWxhdGVkIHJlc3VsdCBvZiBydW5uaW5nXHJcbiAgICAgKiBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gIHRocnUgYGl0ZXJhdGVlYCwgd2hlcmUgZWFjaCBzdWNjZXNzaXZlXHJcbiAgICAgKiBpbnZvY2F0aW9uIGlzIHN1cHBsaWVkIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzLiBJZiBgYWNjdW11bGF0b3JgXHJcbiAgICAgKiBpcyBub3QgZ2l2ZW4sIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCBpcyB1c2VkIGFzIHRoZSBpbml0aWFsXHJcbiAgICAgKiB2YWx1ZS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czpcclxuICAgICAqIChhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXHJcbiAgICAgKlxyXG4gICAgICogTWFueSBsb2Rhc2ggbWV0aG9kcyBhcmUgZ3VhcmRlZCB0byB3b3JrIGFzIGl0ZXJhdGVlcyBmb3IgbWV0aG9kcyBsaWtlXHJcbiAgICAgKiBgXy5yZWR1Y2VgLCBgXy5yZWR1Y2VSaWdodGAsIGFuZCBgXy50cmFuc2Zvcm1gLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBndWFyZGVkIG1ldGhvZHMgYXJlOlxyXG4gICAgICogYGFzc2lnbmAsIGBkZWZhdWx0c2AsIGBkZWZhdWx0c0RlZXBgLCBgaW5jbHVkZXNgLCBgbWVyZ2VgLCBgb3JkZXJCeWAsXHJcbiAgICAgKiBhbmQgYHNvcnRCeWBcclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDAuMS4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxyXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXHJcbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXHJcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXHJcbiAgICAgKiBAc2VlIF8ucmVkdWNlUmlnaHRcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogXy5yZWR1Y2UoWzEsIDJdLCBmdW5jdGlvbihzdW0sIG4pIHtcclxuICAgICAqICAgcmV0dXJuIHN1bSArIG47XHJcbiAgICAgKiB9LCAwKTtcclxuICAgICAqIC8vID0+IDNcclxuICAgICAqXHJcbiAgICAgKiBfLnJlZHVjZSh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfSwgZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XHJcbiAgICAgKiAgIChyZXN1bHRbdmFsdWVdIHx8IChyZXN1bHRbdmFsdWVdID0gW10pKS5wdXNoKGtleSk7XHJcbiAgICAgKiAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgKiB9LCB7fSk7XHJcbiAgICAgKiAvLyA9PiB7ICcxJzogWydhJywgJ2MnXSwgJzInOiBbJ2InXSB9IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHJlZHVjZShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcclxuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlSZWR1Y2UgOiBiYXNlUmVkdWNlLFxyXG4gICAgICAgICAgaW5pdEFjY3VtID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XHJcblxyXG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgNCksIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0sIGJhc2VFYWNoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucmVkdWNlYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXHJcbiAgICAgKiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgMC4xLjBcclxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cclxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cclxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cclxuICAgICAqIEBzZWUgXy5yZWR1Y2VcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogdmFyIGFycmF5ID0gW1swLCAxXSwgWzIsIDNdLCBbNCwgNV1dO1xyXG4gICAgICpcclxuICAgICAqIF8ucmVkdWNlUmlnaHQoYXJyYXksIGZ1bmN0aW9uKGZsYXR0ZW5lZCwgb3RoZXIpIHtcclxuICAgICAqICAgcmV0dXJuIGZsYXR0ZW5lZC5jb25jYXQob3RoZXIpO1xyXG4gICAgICogfSwgW10pO1xyXG4gICAgICogLy8gPT4gWzQsIDUsIDIsIDMsIDAsIDFdXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xyXG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVJlZHVjZVJpZ2h0IDogYmFzZVJlZHVjZSxcclxuICAgICAgICAgIGluaXRBY2N1bSA9IGFyZ3VtZW50cy5sZW5ndGggPCAzO1xyXG5cclxuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDQpLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtLCBiYXNlRWFjaFJpZ2h0KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5maWx0ZXJgOyB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmBcclxuICAgICAqIHRoYXQgYHByZWRpY2F0ZWAgZG9lcyAqKm5vdCoqIHJldHVybiB0cnV0aHkgZm9yLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgMC4xLjBcclxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cclxuICAgICAqIEBzZWUgXy5maWx0ZXJcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogdmFyIHVzZXJzID0gW1xyXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlIH0sXHJcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogdHJ1ZSB9XHJcbiAgICAgKiBdO1xyXG4gICAgICpcclxuICAgICAqIF8ucmVqZWN0KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xyXG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cclxuICAgICAqXHJcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxyXG4gICAgICogXy5yZWplY3QodXNlcnMsIHsgJ2FnZSc6IDQwLCAnYWN0aXZlJzogdHJ1ZSB9KTtcclxuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cclxuICAgICAqXHJcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXHJcbiAgICAgKiBfLnJlamVjdCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xyXG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cclxuICAgICAqXHJcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cclxuICAgICAqIF8ucmVqZWN0KHVzZXJzLCAnYWN0aXZlJyk7XHJcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHJlamVjdChjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcclxuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlGaWx0ZXIgOiBiYXNlRmlsdGVyO1xyXG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBuZWdhdGUoZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhIHJhbmRvbSBlbGVtZW50IGZyb20gYGNvbGxlY3Rpb25gLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgMi4wLjBcclxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzYW1wbGUuXHJcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmFuZG9tIGVsZW1lbnQuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8uc2FtcGxlKFsxLCAyLCAzLCA0XSk7XHJcbiAgICAgKiAvLyA9PiAyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHNhbXBsZShjb2xsZWN0aW9uKSB7XHJcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5U2FtcGxlIDogYmFzZVNhbXBsZTtcclxuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGBuYCByYW5kb20gZWxlbWVudHMgYXQgdW5pcXVlIGtleXMgZnJvbSBgY29sbGVjdGlvbmAgdXAgdG8gdGhlXHJcbiAgICAgKiBzaXplIG9mIGBjb2xsZWN0aW9uYC5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDQuMC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxyXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2FtcGxlLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gc2FtcGxlLlxyXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cclxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZG9tIGVsZW1lbnRzLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLnNhbXBsZVNpemUoWzEsIDIsIDNdLCAyKTtcclxuICAgICAqIC8vID0+IFszLCAxXVxyXG4gICAgICpcclxuICAgICAqIF8uc2FtcGxlU2l6ZShbMSwgMiwgM10sIDQpO1xyXG4gICAgICogLy8gPT4gWzIsIDMsIDFdXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHNhbXBsZVNpemUoY29sbGVjdGlvbiwgbiwgZ3VhcmQpIHtcclxuICAgICAgaWYgKChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIG4sIGd1YXJkKSA6IG4gPT09IHVuZGVmaW5lZCkpIHtcclxuICAgICAgICBuID0gMTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBuID0gdG9JbnRlZ2VyKG4pO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5U2FtcGxlU2l6ZSA6IGJhc2VTYW1wbGVTaXplO1xyXG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBuKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygc2h1ZmZsZWQgdmFsdWVzLCB1c2luZyBhIHZlcnNpb24gb2YgdGhlXHJcbiAgICAgKiBbRmlzaGVyLVlhdGVzIHNodWZmbGVdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlci1ZYXRlc19zaHVmZmxlKS5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDAuMS4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxyXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2h1ZmZsZS5cclxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNodWZmbGVkIGFycmF5LlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLnNodWZmbGUoWzEsIDIsIDMsIDRdKTtcclxuICAgICAqIC8vID0+IFs0LCAxLCAzLCAyXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBzaHVmZmxlKGNvbGxlY3Rpb24pIHtcclxuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTaHVmZmxlIDogYmFzZVNodWZmbGU7XHJcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgc2l6ZSBvZiBgY29sbGVjdGlvbmAgYnkgcmV0dXJuaW5nIGl0cyBsZW5ndGggZm9yIGFycmF5LWxpa2VcclxuICAgICAqIHZhbHVlcyBvciB0aGUgbnVtYmVyIG9mIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIGZvciBvYmplY3RzLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgMC4xLjBcclxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbGxlY3Rpb24gc2l6ZS5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogXy5zaXplKFsxLCAyLCAzXSk7XHJcbiAgICAgKiAvLyA9PiAzXHJcbiAgICAgKlxyXG4gICAgICogXy5zaXplKHsgJ2EnOiAxLCAnYic6IDIgfSk7XHJcbiAgICAgKiAvLyA9PiAyXHJcbiAgICAgKlxyXG4gICAgICogXy5zaXplKCdwZWJibGVzJyk7XHJcbiAgICAgKiAvLyA9PiA3XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHNpemUoY29sbGVjdGlvbikge1xyXG4gICAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzU3RyaW5nKGNvbGxlY3Rpb24pID8gc3RyaW5nU2l6ZShjb2xsZWN0aW9uKSA6IGNvbGxlY3Rpb24ubGVuZ3RoO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciB0YWcgPSBnZXRUYWcoY29sbGVjdGlvbik7XHJcbiAgICAgIGlmICh0YWcgPT0gbWFwVGFnIHx8IHRhZyA9PSBzZXRUYWcpIHtcclxuICAgICAgICByZXR1cm4gY29sbGVjdGlvbi5zaXplO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBiYXNlS2V5cyhjb2xsZWN0aW9uKS5sZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yICoqYW55KiogZWxlbWVudCBvZiBgY29sbGVjdGlvbmAuXHJcbiAgICAgKiBJdGVyYXRpb24gaXMgc3RvcHBlZCBvbmNlIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5LiBUaGUgcHJlZGljYXRlIGlzXHJcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAwLjEuMFxyXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cclxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cclxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXHJcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLnNvbWUoW251bGwsIDAsICd5ZXMnLCBmYWxzZV0sIEJvb2xlYW4pO1xyXG4gICAgICogLy8gPT4gdHJ1ZVxyXG4gICAgICpcclxuICAgICAqIHZhciB1c2VycyA9IFtcclxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogdHJ1ZSB9LFxyXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhY3RpdmUnOiBmYWxzZSB9XHJcbiAgICAgKiBdO1xyXG4gICAgICpcclxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXHJcbiAgICAgKiBfLnNvbWUodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xyXG4gICAgICogLy8gPT4gZmFsc2VcclxuICAgICAqXHJcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXHJcbiAgICAgKiBfLnNvbWUodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcclxuICAgICAqIC8vID0+IHRydWVcclxuICAgICAqXHJcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cclxuICAgICAqIF8uc29tZSh1c2VycywgJ2FjdGl2ZScpO1xyXG4gICAgICogLy8gPT4gdHJ1ZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBzb21lKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZ3VhcmQpIHtcclxuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTb21lIDogYmFzZVNvbWU7XHJcbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGd1YXJkKSkge1xyXG4gICAgICAgIHByZWRpY2F0ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMsIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIgYnkgdGhlIHJlc3VsdHMgb2ZcclxuICAgICAqIHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGEgY29sbGVjdGlvbiB0aHJ1IGVhY2ggaXRlcmF0ZWUuIFRoaXMgbWV0aG9kXHJcbiAgICAgKiBwZXJmb3JtcyBhIHN0YWJsZSBzb3J0LCB0aGF0IGlzLCBpdCBwcmVzZXJ2ZXMgdGhlIG9yaWdpbmFsIHNvcnQgb3JkZXIgb2ZcclxuICAgICAqIGVxdWFsIGVsZW1lbnRzLiBUaGUgaXRlcmF0ZWVzIGFyZSBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgMC4xLjBcclxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXHJcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW2l0ZXJhdGVlcz1bXy5pZGVudGl0eV1dXHJcbiAgICAgKiAgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiB2YXIgdXNlcnMgPSBbXHJcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQ4IH0sXHJcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXHJcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDMwIH0sXHJcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM0IH1cclxuICAgICAqIF07XHJcbiAgICAgKlxyXG4gICAgICogXy5zb3J0QnkodXNlcnMsIFtmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXI7IH1dKTtcclxuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsIDM2XSwgWydiYXJuZXknLCAzNF0sIFsnZnJlZCcsIDQ4XSwgWydmcmVkJywgMzBdXVxyXG4gICAgICpcclxuICAgICAqIF8uc29ydEJ5KHVzZXJzLCBbJ3VzZXInLCAnYWdlJ10pO1xyXG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgMzRdLCBbJ2Jhcm5leScsIDM2XSwgWydmcmVkJywgMzBdLCBbJ2ZyZWQnLCA0OF1dXHJcbiAgICAgKi9cclxuICAgIHZhciBzb3J0QnkgPSBiYXNlUmVzdChmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZXMpIHtcclxuICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgbGVuZ3RoID0gaXRlcmF0ZWVzLmxlbmd0aDtcclxuICAgICAgaWYgKGxlbmd0aCA+IDEgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgaXRlcmF0ZWVzWzBdLCBpdGVyYXRlZXNbMV0pKSB7XHJcbiAgICAgICAgaXRlcmF0ZWVzID0gW107XHJcbiAgICAgIH0gZWxzZSBpZiAobGVuZ3RoID4gMiAmJiBpc0l0ZXJhdGVlQ2FsbChpdGVyYXRlZXNbMF0sIGl0ZXJhdGVlc1sxXSwgaXRlcmF0ZWVzWzJdKSkge1xyXG4gICAgICAgIGl0ZXJhdGVlcyA9IFtpdGVyYXRlZXNbMF1dO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLCBiYXNlRmxhdHRlbihpdGVyYXRlZXMsIDEpLCBbXSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSB0aW1lc3RhbXAgb2YgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIGVsYXBzZWQgc2luY2VcclxuICAgICAqIHRoZSBVbml4IGVwb2NoICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgMi40LjBcclxuICAgICAqIEBjYXRlZ29yeSBEYXRlXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lc3RhbXAuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8uZGVmZXIoZnVuY3Rpb24oc3RhbXApIHtcclxuICAgICAqICAgY29uc29sZS5sb2coXy5ub3coKSAtIHN0YW1wKTtcclxuICAgICAqIH0sIF8ubm93KCkpO1xyXG4gICAgICogLy8gPT4gTG9ncyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpdCB0b29rIGZvciB0aGUgZGVmZXJyZWQgaW52b2NhdGlvbi5cclxuICAgICAqL1xyXG4gICAgdmFyIG5vdyA9IGN0eE5vdyB8fCBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIHJvb3QuRGF0ZS5ub3coKTtcclxuICAgIH07XHJcblxyXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLmJlZm9yZWA7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXNcclxuICAgICAqIGBmdW5jYCBvbmNlIGl0J3MgY2FsbGVkIGBuYCBvciBtb3JlIHRpbWVzLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgMC4xLjBcclxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBjYWxscyBiZWZvcmUgYGZ1bmNgIGlzIGludm9rZWQuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cclxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIHZhciBzYXZlcyA9IFsncHJvZmlsZScsICdzZXR0aW5ncyddO1xyXG4gICAgICpcclxuICAgICAqIHZhciBkb25lID0gXy5hZnRlcihzYXZlcy5sZW5ndGgsIGZ1bmN0aW9uKCkge1xyXG4gICAgICogICBjb25zb2xlLmxvZygnZG9uZSBzYXZpbmchJyk7XHJcbiAgICAgKiB9KTtcclxuICAgICAqXHJcbiAgICAgKiBfLmZvckVhY2goc2F2ZXMsIGZ1bmN0aW9uKHR5cGUpIHtcclxuICAgICAqICAgYXN5bmNTYXZlKHsgJ3R5cGUnOiB0eXBlLCAnY29tcGxldGUnOiBkb25lIH0pO1xyXG4gICAgICogfSk7XHJcbiAgICAgKiAvLyA9PiBMb2dzICdkb25lIHNhdmluZyEnIGFmdGVyIHRoZSB0d28gYXN5bmMgc2F2ZXMgaGF2ZSBjb21wbGV0ZWQuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGFmdGVyKG4sIGZ1bmMpIHtcclxuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XHJcbiAgICAgIH1cclxuICAgICAgbiA9IHRvSW50ZWdlcihuKTtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICgtLW4gPCAxKSB7XHJcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgLCB3aXRoIHVwIHRvIGBuYCBhcmd1bWVudHMsXHJcbiAgICAgKiBpZ25vcmluZyBhbnkgYWRkaXRpb25hbCBhcmd1bWVudHMuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAzLjAuMFxyXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj1mdW5jLmxlbmd0aF0gVGhlIGFyaXR5IGNhcC5cclxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXHJcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8ubWFwKFsnNicsICc4JywgJzEwJ10sIF8uYXJ5KHBhcnNlSW50LCAxKSk7XHJcbiAgICAgKiAvLyA9PiBbNiwgOCwgMTBdXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGFyeShmdW5jLCBuLCBndWFyZCkge1xyXG4gICAgICBuID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBuO1xyXG4gICAgICBuID0gKGZ1bmMgJiYgbiA9PSBudWxsKSA/IGZ1bmMubGVuZ3RoIDogbjtcclxuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9BUllfRkxBRywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBuKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgLCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzXHJcbiAgICAgKiBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbiwgd2hpbGUgaXQncyBjYWxsZWQgbGVzcyB0aGFuIGBuYCB0aW1lcy4gU3Vic2VxdWVudFxyXG4gICAgICogY2FsbHMgdG8gdGhlIGNyZWF0ZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGludm9jYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAzLjAuMFxyXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGNhbGxzIGF0IHdoaWNoIGBmdW5jYCBpcyBubyBsb25nZXIgaW52b2tlZC5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVzdHJpY3RlZCBmdW5jdGlvbi5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uYmVmb3JlKDUsIGFkZENvbnRhY3RUb0xpc3QpKTtcclxuICAgICAqIC8vID0+IEFsbG93cyBhZGRpbmcgdXAgdG8gNCBjb250YWN0cyB0byB0aGUgbGlzdC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYmVmb3JlKG4sIGZ1bmMpIHtcclxuICAgICAgdmFyIHJlc3VsdDtcclxuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XHJcbiAgICAgIH1cclxuICAgICAgbiA9IHRvSW50ZWdlcihuKTtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICgtLW4gPiAwKSB7XHJcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuIDw9IDEpIHtcclxuICAgICAgICAgIGZ1bmMgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2BcclxuICAgICAqIGFuZCBgcGFydGlhbHNgIHByZXBlbmRlZCB0byB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBgXy5iaW5kLnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWMgYnVpbGRzLFxyXG4gICAgICogbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgbmF0aXZlIGBGdW5jdGlvbiNiaW5kYCwgdGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCJcclxuICAgICAqIHByb3BlcnR5IG9mIGJvdW5kIGZ1bmN0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDAuMS4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGJpbmQuXHJcbiAgICAgKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cclxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYm91bmQgZnVuY3Rpb24uXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIGZ1bmN0aW9uIGdyZWV0KGdyZWV0aW5nLCBwdW5jdHVhdGlvbikge1xyXG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyB0aGlzLnVzZXIgKyBwdW5jdHVhdGlvbjtcclxuICAgICAqIH1cclxuICAgICAqXHJcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJyB9O1xyXG4gICAgICpcclxuICAgICAqIHZhciBib3VuZCA9IF8uYmluZChncmVldCwgb2JqZWN0LCAnaGknKTtcclxuICAgICAqIGJvdW5kKCchJyk7XHJcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCEnXHJcbiAgICAgKlxyXG4gICAgICogLy8gQm91bmQgd2l0aCBwbGFjZWhvbGRlcnMuXHJcbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmQoZ3JlZXQsIG9iamVjdCwgXywgJyEnKTtcclxuICAgICAqIGJvdW5kKCdoaScpO1xyXG4gICAgICogLy8gPT4gJ2hpIGZyZWQhJ1xyXG4gICAgICovXHJcbiAgICB2YXIgYmluZCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIHRoaXNBcmcsIHBhcnRpYWxzKSB7XHJcbiAgICAgIHZhciBiaXRtYXNrID0gV1JBUF9CSU5EX0ZMQUc7XHJcbiAgICAgIGlmIChwYXJ0aWFscy5sZW5ndGgpIHtcclxuICAgICAgICB2YXIgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBnZXRIb2xkZXIoYmluZCkpO1xyXG4gICAgICAgIGJpdG1hc2sgfD0gV1JBUF9QQVJUSUFMX0ZMQUc7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSBtZXRob2QgYXQgYG9iamVjdFtrZXldYCB3aXRoIGBwYXJ0aWFsc2BcclxuICAgICAqIHByZXBlbmRlZCB0byB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgbWV0aG9kIGRpZmZlcnMgZnJvbSBgXy5iaW5kYCBieSBhbGxvd2luZyBib3VuZCBmdW5jdGlvbnMgdG8gcmVmZXJlbmNlXHJcbiAgICAgKiBtZXRob2RzIHRoYXQgbWF5IGJlIHJlZGVmaW5lZCBvciBkb24ndCB5ZXQgZXhpc3QuIFNlZVxyXG4gICAgICogW1BldGVyIE1pY2hhdXgncyBhcnRpY2xlXShodHRwOi8vcGV0ZXIubWljaGF1eC5jYS9hcnRpY2xlcy9sYXp5LWZ1bmN0aW9uLWRlZmluaXRpb24tcGF0dGVybilcclxuICAgICAqIGZvciBtb3JlIGRldGFpbHMuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGBfLmJpbmRLZXkucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xyXG4gICAgICogYnVpbGRzLCBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAwLjEwLjBcclxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGludm9rZSB0aGUgbWV0aG9kIG9uLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QuXHJcbiAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cclxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiB2YXIgb2JqZWN0ID0ge1xyXG4gICAgICogICAndXNlcic6ICdmcmVkJyxcclxuICAgICAqICAgJ2dyZWV0JzogZnVuY3Rpb24oZ3JlZXRpbmcsIHB1bmN0dWF0aW9uKSB7XHJcbiAgICAgKiAgICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgdGhpcy51c2VyICsgcHVuY3R1YXRpb247XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH07XHJcbiAgICAgKlxyXG4gICAgICogdmFyIGJvdW5kID0gXy5iaW5kS2V5KG9iamVjdCwgJ2dyZWV0JywgJ2hpJyk7XHJcbiAgICAgKiBib3VuZCgnIScpO1xyXG4gICAgICogLy8gPT4gJ2hpIGZyZWQhJ1xyXG4gICAgICpcclxuICAgICAqIG9iamVjdC5ncmVldCA9IGZ1bmN0aW9uKGdyZWV0aW5nLCBwdW5jdHVhdGlvbikge1xyXG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAneWEgJyArIHRoaXMudXNlciArIHB1bmN0dWF0aW9uO1xyXG4gICAgICogfTtcclxuICAgICAqXHJcbiAgICAgKiBib3VuZCgnIScpO1xyXG4gICAgICogLy8gPT4gJ2hpeWEgZnJlZCEnXHJcbiAgICAgKlxyXG4gICAgICogLy8gQm91bmQgd2l0aCBwbGFjZWhvbGRlcnMuXHJcbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmRLZXkob2JqZWN0LCAnZ3JlZXQnLCBfLCAnIScpO1xyXG4gICAgICogYm91bmQoJ2hpJyk7XHJcbiAgICAgKiAvLyA9PiAnaGl5YSBmcmVkISdcclxuICAgICAqL1xyXG4gICAgdmFyIGJpbmRLZXkgPSBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIGtleSwgcGFydGlhbHMpIHtcclxuICAgICAgdmFyIGJpdG1hc2sgPSBXUkFQX0JJTkRfRkxBRyB8IFdSQVBfQklORF9LRVlfRkxBRztcclxuICAgICAgaWYgKHBhcnRpYWxzLmxlbmd0aCkge1xyXG4gICAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGdldEhvbGRlcihiaW5kS2V5KSk7XHJcbiAgICAgICAgYml0bWFzayB8PSBXUkFQX1BBUlRJQUxfRkxBRztcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChrZXksIGJpdG1hc2ssIG9iamVjdCwgcGFydGlhbHMsIGhvbGRlcnMpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIGFyZ3VtZW50cyBvZiBgZnVuY2AgYW5kIGVpdGhlciBpbnZva2VzXHJcbiAgICAgKiBgZnVuY2AgcmV0dXJuaW5nIGl0cyByZXN1bHQsIGlmIGF0IGxlYXN0IGBhcml0eWAgbnVtYmVyIG9mIGFyZ3VtZW50cyBoYXZlXHJcbiAgICAgKiBiZWVuIHByb3ZpZGVkLCBvciByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHRoZSByZW1haW5pbmcgYGZ1bmNgXHJcbiAgICAgKiBhcmd1bWVudHMsIGFuZCBzbyBvbi4gVGhlIGFyaXR5IG9mIGBmdW5jYCBtYXkgYmUgc3BlY2lmaWVkIGlmIGBmdW5jLmxlbmd0aGBcclxuICAgICAqIGlzIG5vdCBzdWZmaWNpZW50LlxyXG4gICAgICpcclxuICAgICAqIFRoZSBgXy5jdXJyeS5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljIGJ1aWxkcyxcclxuICAgICAqIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHByb3ZpZGVkIGFyZ3VtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgY3VycmllZCBmdW5jdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAyLjAuMFxyXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHk9ZnVuYy5sZW5ndGhdIFRoZSBhcml0eSBvZiBgZnVuY2AuXHJcbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY3VycmllZCBmdW5jdGlvbi5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogdmFyIGFiYyA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcclxuICAgICAqICAgcmV0dXJuIFthLCBiLCBjXTtcclxuICAgICAqIH07XHJcbiAgICAgKlxyXG4gICAgICogdmFyIGN1cnJpZWQgPSBfLmN1cnJ5KGFiYyk7XHJcbiAgICAgKlxyXG4gICAgICogY3VycmllZCgxKSgyKSgzKTtcclxuICAgICAqIC8vID0+IFsxLCAyLCAzXVxyXG4gICAgICpcclxuICAgICAqIGN1cnJpZWQoMSwgMikoMyk7XHJcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cclxuICAgICAqXHJcbiAgICAgKiBjdXJyaWVkKDEsIDIsIDMpO1xyXG4gICAgICogLy8gPT4gWzEsIDIsIDNdXHJcbiAgICAgKlxyXG4gICAgICogLy8gQ3VycmllZCB3aXRoIHBsYWNlaG9sZGVycy5cclxuICAgICAqIGN1cnJpZWQoMSkoXywgMykoMik7XHJcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY3VycnkoZnVuYywgYXJpdHksIGd1YXJkKSB7XHJcbiAgICAgIGFyaXR5ID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBhcml0eTtcclxuICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9DVVJSWV9GTEFHLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYXJpdHkpO1xyXG4gICAgICByZXN1bHQucGxhY2Vob2xkZXIgPSBjdXJyeS5wbGFjZWhvbGRlcjtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uY3VycnlgIGV4Y2VwdCB0aGF0IGFyZ3VtZW50cyBhcmUgYXBwbGllZCB0byBgZnVuY2BcclxuICAgICAqIGluIHRoZSBtYW5uZXIgb2YgYF8ucGFydGlhbFJpZ2h0YCBpbnN0ZWFkIG9mIGBfLnBhcnRpYWxgLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBgXy5jdXJyeVJpZ2h0LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcclxuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcHJvdmlkZWQgYXJndW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBjdXJyaWVkIGZ1bmN0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDMuMC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eT1mdW5jLmxlbmd0aF0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cclxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXHJcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjdXJyaWVkIGZ1bmN0aW9uLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiB2YXIgYWJjID0gZnVuY3Rpb24oYSwgYiwgYykge1xyXG4gICAgICogICByZXR1cm4gW2EsIGIsIGNdO1xyXG4gICAgICogfTtcclxuICAgICAqXHJcbiAgICAgKiB2YXIgY3VycmllZCA9IF8uY3VycnlSaWdodChhYmMpO1xyXG4gICAgICpcclxuICAgICAqIGN1cnJpZWQoMykoMikoMSk7XHJcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cclxuICAgICAqXHJcbiAgICAgKiBjdXJyaWVkKDIsIDMpKDEpO1xyXG4gICAgICogLy8gPT4gWzEsIDIsIDNdXHJcbiAgICAgKlxyXG4gICAgICogY3VycmllZCgxLCAyLCAzKTtcclxuICAgICAqIC8vID0+IFsxLCAyLCAzXVxyXG4gICAgICpcclxuICAgICAqIC8vIEN1cnJpZWQgd2l0aCBwbGFjZWhvbGRlcnMuXHJcbiAgICAgKiBjdXJyaWVkKDMpKDEsIF8pKDIpO1xyXG4gICAgICogLy8gPT4gWzEsIDIsIDNdXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGN1cnJ5UmlnaHQoZnVuYywgYXJpdHksIGd1YXJkKSB7XHJcbiAgICAgIGFyaXR5ID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBhcml0eTtcclxuICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9DVVJSWV9SSUdIVF9GTEFHLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYXJpdHkpO1xyXG4gICAgICByZXN1bHQucGxhY2Vob2xkZXIgPSBjdXJyeVJpZ2h0LnBsYWNlaG9sZGVyO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGRlYm91bmNlZCBmdW5jdGlvbiB0aGF0IGRlbGF5cyBpbnZva2luZyBgZnVuY2AgdW50aWwgYWZ0ZXIgYHdhaXRgXHJcbiAgICAgKiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3YXNcclxuICAgICAqIGludm9rZWQuIFRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgIG1ldGhvZCB0byBjYW5jZWxcclxuICAgICAqIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLlxyXG4gICAgICogUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlXHJcbiAgICAgKiBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkXHJcbiAgICAgKiB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50XHJcbiAgICAgKiBjYWxscyB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYFxyXG4gICAgICogaW52b2NhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXHJcbiAgICAgKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIGRlYm91bmNlZCBmdW5jdGlvblxyXG4gICAgICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxyXG4gICAgICpcclxuICAgICAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxyXG4gICAgICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxyXG4gICAgICpcclxuICAgICAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxyXG4gICAgICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy5kZWJvdW5jZWAgYW5kIGBfLnRocm90dGxlYC5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDAuMS4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9ZmFsc2VdXHJcbiAgICAgKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFdhaXRdXHJcbiAgICAgKiAgVGhlIG1heGltdW0gdGltZSBgZnVuY2AgaXMgYWxsb3dlZCB0byBiZSBkZWxheWVkIGJlZm9yZSBpdCdzIGludm9rZWQuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXHJcbiAgICAgKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cclxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGRlYm91bmNlZCBmdW5jdGlvbi5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogLy8gQXZvaWQgY29zdGx5IGNhbGN1bGF0aW9ucyB3aGlsZSB0aGUgd2luZG93IHNpemUgaXMgaW4gZmx1eC5cclxuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKSk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gSW52b2tlIGBzZW5kTWFpbGAgd2hlbiBjbGlja2VkLCBkZWJvdW5jaW5nIHN1YnNlcXVlbnQgY2FsbHMuXHJcbiAgICAgKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XHJcbiAgICAgKiAgICdsZWFkaW5nJzogdHJ1ZSxcclxuICAgICAqICAgJ3RyYWlsaW5nJzogZmFsc2VcclxuICAgICAqIH0pKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBFbnN1cmUgYGJhdGNoTG9nYCBpcyBpbnZva2VkIG9uY2UgYWZ0ZXIgMSBzZWNvbmQgb2YgZGVib3VuY2VkIGNhbGxzLlxyXG4gICAgICogdmFyIGRlYm91bmNlZCA9IF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwgeyAnbWF4V2FpdCc6IDEwMDAgfSk7XHJcbiAgICAgKiB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvc3RyZWFtJyk7XHJcbiAgICAgKiBqUXVlcnkoc291cmNlKS5vbignbWVzc2FnZScsIGRlYm91bmNlZCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyBkZWJvdW5jZWQgaW52b2NhdGlvbi5cclxuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIGRlYm91bmNlZC5jYW5jZWwpO1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XHJcbiAgICAgIHZhciBsYXN0QXJncyxcclxuICAgICAgICAgIGxhc3RUaGlzLFxyXG4gICAgICAgICAgbWF4V2FpdCxcclxuICAgICAgICAgIHJlc3VsdCxcclxuICAgICAgICAgIHRpbWVySWQsXHJcbiAgICAgICAgICBsYXN0Q2FsbFRpbWUsXHJcbiAgICAgICAgICBsYXN0SW52b2tlVGltZSA9IDAsXHJcbiAgICAgICAgICBsZWFkaW5nID0gZmFsc2UsXHJcbiAgICAgICAgICBtYXhpbmcgPSBmYWxzZSxcclxuICAgICAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xyXG4gICAgICB9XHJcbiAgICAgIHdhaXQgPSB0b051bWJlcih3YWl0KSB8fCAwO1xyXG4gICAgICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcclxuICAgICAgICBsZWFkaW5nID0gISFvcHRpb25zLmxlYWRpbmc7XHJcbiAgICAgICAgbWF4aW5nID0gJ21heFdhaXQnIGluIG9wdGlvbnM7XHJcbiAgICAgICAgbWF4V2FpdCA9IG1heGluZyA/IG5hdGl2ZU1heCh0b051bWJlcihvcHRpb25zLm1heFdhaXQpIHx8IDAsIHdhaXQpIDogbWF4V2FpdDtcclxuICAgICAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBpbnZva2VGdW5jKHRpbWUpIHtcclxuICAgICAgICB2YXIgYXJncyA9IGxhc3RBcmdzLFxyXG4gICAgICAgICAgICB0aGlzQXJnID0gbGFzdFRoaXM7XHJcblxyXG4gICAgICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xyXG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gbGVhZGluZ0VkZ2UodGltZSkge1xyXG4gICAgICAgIC8vIFJlc2V0IGFueSBgbWF4V2FpdGAgdGltZXIuXHJcbiAgICAgICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xyXG4gICAgICAgIC8vIFN0YXJ0IHRoZSB0aW1lciBmb3IgdGhlIHRyYWlsaW5nIGVkZ2UuXHJcbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcclxuICAgICAgICAvLyBJbnZva2UgdGhlIGxlYWRpbmcgZWRnZS5cclxuICAgICAgICByZXR1cm4gbGVhZGluZyA/IGludm9rZUZ1bmModGltZSkgOiByZXN1bHQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIHJlbWFpbmluZ1dhaXQodGltZSkge1xyXG4gICAgICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXHJcbiAgICAgICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWUsXHJcbiAgICAgICAgICAgIHRpbWVXYWl0aW5nID0gd2FpdCAtIHRpbWVTaW5jZUxhc3RDYWxsO1xyXG5cclxuICAgICAgICByZXR1cm4gbWF4aW5nXHJcbiAgICAgICAgICA/IG5hdGl2ZU1pbih0aW1lV2FpdGluZywgbWF4V2FpdCAtIHRpbWVTaW5jZUxhc3RJbnZva2UpXHJcbiAgICAgICAgICA6IHRpbWVXYWl0aW5nO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBzaG91bGRJbnZva2UodGltZSkge1xyXG4gICAgICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXHJcbiAgICAgICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsLCBhY3Rpdml0eSBoYXMgc3RvcHBlZCBhbmQgd2UncmUgYXQgdGhlXHJcbiAgICAgICAgLy8gdHJhaWxpbmcgZWRnZSwgdGhlIHN5c3RlbSB0aW1lIGhhcyBnb25lIGJhY2t3YXJkcyBhbmQgd2UncmUgdHJlYXRpbmdcclxuICAgICAgICAvLyBpdCBhcyB0aGUgdHJhaWxpbmcgZWRnZSwgb3Igd2UndmUgaGl0IHRoZSBgbWF4V2FpdGAgbGltaXQuXHJcbiAgICAgICAgcmV0dXJuIChsYXN0Q2FsbFRpbWUgPT09IHVuZGVmaW5lZCB8fCAodGltZVNpbmNlTGFzdENhbGwgPj0gd2FpdCkgfHxcclxuICAgICAgICAgICh0aW1lU2luY2VMYXN0Q2FsbCA8IDApIHx8IChtYXhpbmcgJiYgdGltZVNpbmNlTGFzdEludm9rZSA+PSBtYXhXYWl0KSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIHRpbWVyRXhwaXJlZCgpIHtcclxuICAgICAgICB2YXIgdGltZSA9IG5vdygpO1xyXG4gICAgICAgIGlmIChzaG91bGRJbnZva2UodGltZSkpIHtcclxuICAgICAgICAgIHJldHVybiB0cmFpbGluZ0VkZ2UodGltZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJlc3RhcnQgdGhlIHRpbWVyLlxyXG4gICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgcmVtYWluaW5nV2FpdCh0aW1lKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XHJcbiAgICAgICAgdGltZXJJZCA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgLy8gT25seSBpbnZva2UgaWYgd2UgaGF2ZSBgbGFzdEFyZ3NgIHdoaWNoIG1lYW5zIGBmdW5jYCBoYXMgYmVlblxyXG4gICAgICAgIC8vIGRlYm91bmNlZCBhdCBsZWFzdCBvbmNlLlxyXG4gICAgICAgIGlmICh0cmFpbGluZyAmJiBsYXN0QXJncykge1xyXG4gICAgICAgICAgcmV0dXJuIGludm9rZUZ1bmModGltZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gY2FuY2VsKCkge1xyXG4gICAgICAgIGlmICh0aW1lcklkICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGFzdEludm9rZVRpbWUgPSAwO1xyXG4gICAgICAgIGxhc3RBcmdzID0gbGFzdENhbGxUaW1lID0gbGFzdFRoaXMgPSB0aW1lcklkID0gdW5kZWZpbmVkO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBmbHVzaCgpIHtcclxuICAgICAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gZGVib3VuY2VkKCkge1xyXG4gICAgICAgIHZhciB0aW1lID0gbm93KCksXHJcbiAgICAgICAgICAgIGlzSW52b2tpbmcgPSBzaG91bGRJbnZva2UodGltZSk7XHJcblxyXG4gICAgICAgIGxhc3RBcmdzID0gYXJndW1lbnRzO1xyXG4gICAgICAgIGxhc3RUaGlzID0gdGhpcztcclxuICAgICAgICBsYXN0Q2FsbFRpbWUgPSB0aW1lO1xyXG5cclxuICAgICAgICBpZiAoaXNJbnZva2luZykge1xyXG4gICAgICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChtYXhpbmcpIHtcclxuICAgICAgICAgICAgLy8gSGFuZGxlIGludm9jYXRpb25zIGluIGEgdGlnaHQgbG9vcC5cclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xyXG4gICAgICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xyXG4gICAgICAgICAgICByZXR1cm4gaW52b2tlRnVuYyhsYXN0Q2FsbFRpbWUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICB9XHJcbiAgICAgIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XHJcbiAgICAgIGRlYm91bmNlZC5mbHVzaCA9IGZsdXNoO1xyXG4gICAgICByZXR1cm4gZGVib3VuY2VkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmZXJzIGludm9raW5nIHRoZSBgZnVuY2AgdW50aWwgdGhlIGN1cnJlbnQgY2FsbCBzdGFjayBoYXMgY2xlYXJlZC4gQW55XHJcbiAgICAgKiBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQncyBpbnZva2VkLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgMC4xLjBcclxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVmZXIuXHJcbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVyIGlkLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLmRlZmVyKGZ1bmN0aW9uKHRleHQpIHtcclxuICAgICAqICAgY29uc29sZS5sb2codGV4dCk7XHJcbiAgICAgKiB9LCAnZGVmZXJyZWQnKTtcclxuICAgICAqIC8vID0+IExvZ3MgJ2RlZmVycmVkJyBhZnRlciBvbmUgbWlsbGlzZWNvbmQuXHJcbiAgICAgKi9cclxuICAgIHZhciBkZWZlciA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIGFyZ3MpIHtcclxuICAgICAgcmV0dXJuIGJhc2VEZWxheShmdW5jLCAxLCBhcmdzKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW52b2tlcyBgZnVuY2AgYWZ0ZXIgYHdhaXRgIG1pbGxpc2Vjb25kcy4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZVxyXG4gICAgICogcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQncyBpbnZva2VkLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgMC4xLjBcclxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVsYXkuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2FpdCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSBpbnZvY2F0aW9uLlxyXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lciBpZC5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogXy5kZWxheShmdW5jdGlvbih0ZXh0KSB7XHJcbiAgICAgKiAgIGNvbnNvbGUubG9nKHRleHQpO1xyXG4gICAgICogfSwgMTAwMCwgJ2xhdGVyJyk7XHJcbiAgICAgKiAvLyA9PiBMb2dzICdsYXRlcicgYWZ0ZXIgb25lIHNlY29uZC5cclxuICAgICAqL1xyXG4gICAgdmFyIGRlbGF5ID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgd2FpdCwgYXJncykge1xyXG4gICAgICByZXR1cm4gYmFzZURlbGF5KGZ1bmMsIHRvTnVtYmVyKHdhaXQpIHx8IDAsIGFyZ3MpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGFyZ3VtZW50cyByZXZlcnNlZC5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDQuMC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGZsaXAgYXJndW1lbnRzIGZvci5cclxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZsaXBwZWQgZnVuY3Rpb24uXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIHZhciBmbGlwcGVkID0gXy5mbGlwKGZ1bmN0aW9uKCkge1xyXG4gICAgICogICByZXR1cm4gXy50b0FycmF5KGFyZ3VtZW50cyk7XHJcbiAgICAgKiB9KTtcclxuICAgICAqXHJcbiAgICAgKiBmbGlwcGVkKCdhJywgJ2InLCAnYycsICdkJyk7XHJcbiAgICAgKiAvLyA9PiBbJ2QnLCAnYycsICdiJywgJ2EnXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBmbGlwKGZ1bmMpIHtcclxuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9GTElQX0ZMQUcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcclxuICAgICAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcclxuICAgICAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxyXG4gICAgICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcclxuICAgICAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxyXG4gICAgICpcclxuICAgICAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcclxuICAgICAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxyXG4gICAgICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcclxuICAgICAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXHJcbiAgICAgKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBjbGVhcmAsIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDAuMS4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cclxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xyXG4gICAgICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xyXG4gICAgICpcclxuICAgICAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xyXG4gICAgICogdmFsdWVzKG9iamVjdCk7XHJcbiAgICAgKiAvLyA9PiBbMSwgMl1cclxuICAgICAqXHJcbiAgICAgKiB2YWx1ZXMob3RoZXIpO1xyXG4gICAgICogLy8gPT4gWzMsIDRdXHJcbiAgICAgKlxyXG4gICAgICogb2JqZWN0LmEgPSAyO1xyXG4gICAgICogdmFsdWVzKG9iamVjdCk7XHJcbiAgICAgKiAvLyA9PiBbMSwgMl1cclxuICAgICAqXHJcbiAgICAgKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cclxuICAgICAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcclxuICAgICAqIHZhbHVlcyhvYmplY3QpO1xyXG4gICAgICogLy8gPT4gWydhJywgJ2InXVxyXG4gICAgICpcclxuICAgICAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXHJcbiAgICAgKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XHJcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAhPSBudWxsICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcclxuICAgICAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXHJcbiAgICAgICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XHJcblxyXG4gICAgICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xyXG4gICAgICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgICAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCkgfHwgY2FjaGU7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfTtcclxuICAgICAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwQ2FjaGUpO1xyXG4gICAgICByZXR1cm4gbWVtb2l6ZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRXhwb3NlIGBNYXBDYWNoZWAuXHJcbiAgICBtZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBuZWdhdGVzIHRoZSByZXN1bHQgb2YgdGhlIHByZWRpY2F0ZSBgZnVuY2AuIFRoZVxyXG4gICAgICogYGZ1bmNgIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHMgb2YgdGhlXHJcbiAgICAgKiBjcmVhdGVkIGZ1bmN0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgMy4wLjBcclxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBwcmVkaWNhdGUgdG8gbmVnYXRlLlxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbmVnYXRlZCBmdW5jdGlvbi5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogZnVuY3Rpb24gaXNFdmVuKG4pIHtcclxuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDA7XHJcbiAgICAgKiB9XHJcbiAgICAgKlxyXG4gICAgICogXy5maWx0ZXIoWzEsIDIsIDMsIDQsIDUsIDZdLCBfLm5lZ2F0ZShpc0V2ZW4pKTtcclxuICAgICAqIC8vID0+IFsxLCAzLCA1XVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBuZWdhdGUocHJlZGljYXRlKSB7XHJcbiAgICAgIGlmICh0eXBlb2YgcHJlZGljYXRlICE9ICdmdW5jdGlvbicpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xyXG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcclxuICAgICAgICAgIGNhc2UgMDogcmV0dXJuICFwcmVkaWNhdGUuY2FsbCh0aGlzKTtcclxuICAgICAgICAgIGNhc2UgMTogcmV0dXJuICFwcmVkaWNhdGUuY2FsbCh0aGlzLCBhcmdzWzBdKTtcclxuICAgICAgICAgIGNhc2UgMjogcmV0dXJuICFwcmVkaWNhdGUuY2FsbCh0aGlzLCBhcmdzWzBdLCBhcmdzWzFdKTtcclxuICAgICAgICAgIGNhc2UgMzogcmV0dXJuICFwcmVkaWNhdGUuY2FsbCh0aGlzLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICFwcmVkaWNhdGUuYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpcyByZXN0cmljdGVkIHRvIGludm9raW5nIGBmdW5jYCBvbmNlLiBSZXBlYXQgY2FsbHNcclxuICAgICAqIHRvIHRoZSBmdW5jdGlvbiByZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBpbnZvY2F0aW9uLiBUaGUgYGZ1bmNgIGlzXHJcbiAgICAgKiBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHMgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAwLjEuMFxyXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cclxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIHZhciBpbml0aWFsaXplID0gXy5vbmNlKGNyZWF0ZUFwcGxpY2F0aW9uKTtcclxuICAgICAqIGluaXRpYWxpemUoKTtcclxuICAgICAqIGluaXRpYWxpemUoKTtcclxuICAgICAqIC8vID0+IGBjcmVhdGVBcHBsaWNhdGlvbmAgaXMgaW52b2tlZCBvbmNlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG9uY2UoZnVuYykge1xyXG4gICAgICByZXR1cm4gYmVmb3JlKDIsIGZ1bmMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnRzIHRyYW5zZm9ybWVkLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBzaW5jZSA0LjAuMFxyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cclxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbdHJhbnNmb3Jtcz1bXy5pZGVudGl0eV1dXHJcbiAgICAgKiAgVGhlIGFyZ3VtZW50IHRyYW5zZm9ybXMuXHJcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogZnVuY3Rpb24gZG91YmxlZChuKSB7XHJcbiAgICAgKiAgIHJldHVybiBuICogMjtcclxuICAgICAqIH1cclxuICAgICAqXHJcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xyXG4gICAgICogICByZXR1cm4gbiAqIG47XHJcbiAgICAgKiB9XHJcbiAgICAgKlxyXG4gICAgICogdmFyIGZ1bmMgPSBfLm92ZXJBcmdzKGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgICAqICAgcmV0dXJuIFt4LCB5XTtcclxuICAgICAqIH0sIFtzcXVhcmUsIGRvdWJsZWRdKTtcclxuICAgICAqXHJcbiAgICAgKiBmdW5jKDksIDMpO1xyXG4gICAgICogLy8gPT4gWzgxLCA2XVxyXG4gICAgICpcclxuICAgICAqIGZ1bmMoMTAsIDUpO1xyXG4gICAgICogLy8gPT4gWzEwMCwgMTBdXHJcbiAgICAgKi9cclxuICAgIHZhciBvdmVyQXJncyA9IGNhc3RSZXN0KGZ1bmN0aW9uKGZ1bmMsIHRyYW5zZm9ybXMpIHtcclxuICAgICAgdHJhbnNmb3JtcyA9ICh0cmFuc2Zvcm1zLmxlbmd0aCA9PSAxICYmIGlzQXJyYXkodHJhbnNmb3Jtc1swXSkpXHJcbiAgICAgICAgPyBhcnJheU1hcCh0cmFuc2Zvcm1zWzBdLCBiYXNlVW5hcnkoZ2V0SXRlcmF0ZWUoKSkpXHJcbiAgICAgICAgOiBhcnJheU1hcChiYXNlRmxhdHRlbih0cmFuc2Zvcm1zLCAxKSwgYmFzZVVuYXJ5KGdldEl0ZXJhdGVlKCkpKTtcclxuXHJcbiAgICAgIHZhciBmdW5jc0xlbmd0aCA9IHRyYW5zZm9ybXMubGVuZ3RoO1xyXG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xyXG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxyXG4gICAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNaW4oYXJncy5sZW5ndGgsIGZ1bmNzTGVuZ3RoKTtcclxuXHJcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcclxuICAgICAgICAgIGFyZ3NbaW5kZXhdID0gdHJhbnNmb3Jtc1tpbmRleF0uY2FsbCh0aGlzLCBhcmdzW2luZGV4XSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBhcmdzKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggYHBhcnRpYWxzYCBwcmVwZW5kZWQgdG8gdGhlXHJcbiAgICAgKiBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYmluZGAgZXhjZXB0IGl0IGRvZXMgKipub3QqKlxyXG4gICAgICogYWx0ZXIgdGhlIGB0aGlzYCBiaW5kaW5nLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBgXy5wYXJ0aWFsLnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcclxuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBwYXJ0aWFsbHlcclxuICAgICAqIGFwcGxpZWQgZnVuY3Rpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgMC4yLjBcclxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5IGFyZ3VtZW50cyB0by5cclxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFydGlhbGx5IGFwcGxpZWQgZnVuY3Rpb24uXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIGZ1bmN0aW9uIGdyZWV0KGdyZWV0aW5nLCBuYW1lKSB7XHJcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICcgJyArIG5hbWU7XHJcbiAgICAgKiB9XHJcbiAgICAgKlxyXG4gICAgICogdmFyIHNheUhlbGxvVG8gPSBfLnBhcnRpYWwoZ3JlZXQsICdoZWxsbycpO1xyXG4gICAgICogc2F5SGVsbG9UbygnZnJlZCcpO1xyXG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQnXHJcbiAgICAgKlxyXG4gICAgICogLy8gUGFydGlhbGx5IGFwcGxpZWQgd2l0aCBwbGFjZWhvbGRlcnMuXHJcbiAgICAgKiB2YXIgZ3JlZXRGcmVkID0gXy5wYXJ0aWFsKGdyZWV0LCBfLCAnZnJlZCcpO1xyXG4gICAgICogZ3JlZXRGcmVkKCdoaScpO1xyXG4gICAgICogLy8gPT4gJ2hpIGZyZWQnXHJcbiAgICAgKi9cclxuICAgIHZhciBwYXJ0aWFsID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgcGFydGlhbHMpIHtcclxuICAgICAgdmFyIGhvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhwYXJ0aWFscywgZ2V0SG9sZGVyKHBhcnRpYWwpKTtcclxuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9QQVJUSUFMX0ZMQUcsIHVuZGVmaW5lZCwgcGFydGlhbHMsIGhvbGRlcnMpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnBhcnRpYWxgIGV4Y2VwdCB0aGF0IHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50c1xyXG4gICAgICogYXJlIGFwcGVuZGVkIHRvIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGBfLnBhcnRpYWxSaWdodC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljXHJcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgcGFydGlhbGx5XHJcbiAgICAgKiBhcHBsaWVkIGZ1bmN0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDEuMC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHBhcnRpYWxseSBhcHBseSBhcmd1bWVudHMgdG8uXHJcbiAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cclxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhcnRpYWxseSBhcHBsaWVkIGZ1bmN0aW9uLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBmdW5jdGlvbiBncmVldChncmVldGluZywgbmFtZSkge1xyXG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyBuYW1lO1xyXG4gICAgICogfVxyXG4gICAgICpcclxuICAgICAqIHZhciBncmVldEZyZWQgPSBfLnBhcnRpYWxSaWdodChncmVldCwgJ2ZyZWQnKTtcclxuICAgICAqIGdyZWV0RnJlZCgnaGknKTtcclxuICAgICAqIC8vID0+ICdoaSBmcmVkJ1xyXG4gICAgICpcclxuICAgICAqIC8vIFBhcnRpYWxseSBhcHBsaWVkIHdpdGggcGxhY2Vob2xkZXJzLlxyXG4gICAgICogdmFyIHNheUhlbGxvVG8gPSBfLnBhcnRpYWxSaWdodChncmVldCwgJ2hlbGxvJywgXyk7XHJcbiAgICAgKiBzYXlIZWxsb1RvKCdmcmVkJyk7XHJcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCdcclxuICAgICAqL1xyXG4gICAgdmFyIHBhcnRpYWxSaWdodCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIHBhcnRpYWxzKSB7XHJcbiAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGdldEhvbGRlcihwYXJ0aWFsUmlnaHQpKTtcclxuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcsIHVuZGVmaW5lZCwgcGFydGlhbHMsIGhvbGRlcnMpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGFyZ3VtZW50cyBhcnJhbmdlZCBhY2NvcmRpbmdcclxuICAgICAqIHRvIHRoZSBzcGVjaWZpZWQgYGluZGV4ZXNgIHdoZXJlIHRoZSBhcmd1bWVudCB2YWx1ZSBhdCB0aGUgZmlyc3QgaW5kZXggaXNcclxuICAgICAqIHByb3ZpZGVkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCwgdGhlIGFyZ3VtZW50IHZhbHVlIGF0IHRoZSBzZWNvbmQgaW5kZXggaXNcclxuICAgICAqIHByb3ZpZGVkIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQsIGFuZCBzbyBvbi5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDMuMC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlYXJyYW5nZSBhcmd1bWVudHMgZm9yLlxyXG4gICAgICogQHBhcmFtIHsuLi4obnVtYmVyfG51bWJlcltdKX0gaW5kZXhlcyBUaGUgYXJyYW5nZWQgYXJndW1lbnQgaW5kZXhlcy5cclxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiB2YXIgcmVhcmdlZCA9IF8ucmVhcmcoZnVuY3Rpb24oYSwgYiwgYykge1xyXG4gICAgICogICByZXR1cm4gW2EsIGIsIGNdO1xyXG4gICAgICogfSwgWzIsIDAsIDFdKTtcclxuICAgICAqXHJcbiAgICAgKiByZWFyZ2VkKCdiJywgJ2MnLCAnYScpXHJcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ11cclxuICAgICAqL1xyXG4gICAgdmFyIHJlYXJnID0gZmxhdFJlc3QoZnVuY3Rpb24oZnVuYywgaW5kZXhlcykge1xyXG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBXUkFQX1JFQVJHX0ZMQUcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGluZGV4ZXMpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGVcclxuICAgICAqIGNyZWF0ZWQgZnVuY3Rpb24gYW5kIGFyZ3VtZW50cyBmcm9tIGBzdGFydGAgYW5kIGJleW9uZCBwcm92aWRlZCBhc1xyXG4gICAgICogYW4gYXJyYXkuXHJcbiAgICAgKlxyXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uIHRoZVxyXG4gICAgICogW3Jlc3QgcGFyYW1ldGVyXShodHRwczovL21kbi5pby9yZXN0X3BhcmFtZXRlcnMpLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgNC4wLjBcclxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cclxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiB2YXIgc2F5ID0gXy5yZXN0KGZ1bmN0aW9uKHdoYXQsIG5hbWVzKSB7XHJcbiAgICAgKiAgIHJldHVybiB3aGF0ICsgJyAnICsgXy5pbml0aWFsKG5hbWVzKS5qb2luKCcsICcpICtcclxuICAgICAqICAgICAoXy5zaXplKG5hbWVzKSA+IDEgPyAnLCAmICcgOiAnJykgKyBfLmxhc3QobmFtZXMpO1xyXG4gICAgICogfSk7XHJcbiAgICAgKlxyXG4gICAgICogc2F5KCdoZWxsbycsICdmcmVkJywgJ2Jhcm5leScsICdwZWJibGVzJyk7XHJcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHJlc3QoZnVuYywgc3RhcnQpIHtcclxuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XHJcbiAgICAgIH1cclxuICAgICAgc3RhcnQgPSBzdGFydCA9PT0gdW5kZWZpbmVkID8gc3RhcnQgOiB0b0ludGVnZXIoc3RhcnQpO1xyXG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuYywgc3RhcnQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlXHJcbiAgICAgKiBjcmVhdGUgZnVuY3Rpb24gYW5kIGFuIGFycmF5IG9mIGFyZ3VtZW50cyBtdWNoIGxpa2VcclxuICAgICAqIFtgRnVuY3Rpb24jYXBwbHlgXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5KS5cclxuICAgICAqXHJcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb24gdGhlXHJcbiAgICAgKiBbc3ByZWFkIG9wZXJhdG9yXShodHRwczovL21kbi5pby9zcHJlYWRfb3BlcmF0b3IpLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgMy4yLjBcclxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gc3ByZWFkIGFyZ3VtZW50cyBvdmVyLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHNwcmVhZC5cclxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiB2YXIgc2F5ID0gXy5zcHJlYWQoZnVuY3Rpb24od2hvLCB3aGF0KSB7XHJcbiAgICAgKiAgIHJldHVybiB3aG8gKyAnIHNheXMgJyArIHdoYXQ7XHJcbiAgICAgKiB9KTtcclxuICAgICAqXHJcbiAgICAgKiBzYXkoWydmcmVkJywgJ2hlbGxvJ10pO1xyXG4gICAgICogLy8gPT4gJ2ZyZWQgc2F5cyBoZWxsbydcclxuICAgICAqXHJcbiAgICAgKiB2YXIgbnVtYmVycyA9IFByb21pc2UuYWxsKFtcclxuICAgICAqICAgUHJvbWlzZS5yZXNvbHZlKDQwKSxcclxuICAgICAqICAgUHJvbWlzZS5yZXNvbHZlKDM2KVxyXG4gICAgICogXSk7XHJcbiAgICAgKlxyXG4gICAgICogbnVtYmVycy50aGVuKF8uc3ByZWFkKGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgICAqICAgcmV0dXJuIHggKyB5O1xyXG4gICAgICogfSkpO1xyXG4gICAgICogLy8gPT4gYSBQcm9taXNlIG9mIDc2XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHNwcmVhZChmdW5jLCBzdGFydCkge1xyXG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcclxuICAgICAgfVxyXG4gICAgICBzdGFydCA9IHN0YXJ0ID09IG51bGwgPyAwIDogbmF0aXZlTWF4KHRvSW50ZWdlcihzdGFydCksIDApO1xyXG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xyXG4gICAgICAgIHZhciBhcnJheSA9IGFyZ3Nbc3RhcnRdLFxyXG4gICAgICAgICAgICBvdGhlckFyZ3MgPSBjYXN0U2xpY2UoYXJncywgMCwgc3RhcnQpO1xyXG5cclxuICAgICAgICBpZiAoYXJyYXkpIHtcclxuICAgICAgICAgIGFycmF5UHVzaChvdGhlckFyZ3MsIGFycmF5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIHRocm90dGxlZCBmdW5jdGlvbiB0aGF0IG9ubHkgaW52b2tlcyBgZnVuY2AgYXQgbW9zdCBvbmNlIHBlclxyXG4gICAgICogZXZlcnkgYHdhaXRgIG1pbGxpc2Vjb25kcy4gVGhlIHRocm90dGxlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGBcclxuICAgICAqIG1ldGhvZCB0byBjYW5jZWwgZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG9cclxuICAgICAqIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYFxyXG4gICAgICogc2hvdWxkIGJlIGludm9rZWQgb24gdGhlIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YFxyXG4gICAgICogdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZVxyXG4gICAgICogdGhyb3R0bGVkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50IGNhbGxzIHRvIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gcmV0dXJuIHRoZVxyXG4gICAgICogcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBpbnZvY2F0aW9uLlxyXG4gICAgICpcclxuICAgICAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcclxuICAgICAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uXHJcbiAgICAgKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXHJcbiAgICAgKlxyXG4gICAgICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXHJcbiAgICAgKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXHJcbiAgICAgKlxyXG4gICAgICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXHJcbiAgICAgKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLnRocm90dGxlYCBhbmQgYF8uZGVib3VuY2VgLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgMC4xLjBcclxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gdGhyb3R0bGUuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhyb3R0bGUgaW52b2NhdGlvbnMgdG8uXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz10cnVlXVxyXG4gICAgICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cclxuICAgICAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgdGhyb3R0bGVkIGZ1bmN0aW9uLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiAvLyBBdm9pZCBleGNlc3NpdmVseSB1cGRhdGluZyB0aGUgcG9zaXRpb24gd2hpbGUgc2Nyb2xsaW5nLlxyXG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3Njcm9sbCcsIF8udGhyb3R0bGUodXBkYXRlUG9zaXRpb24sIDEwMCkpO1xyXG4gICAgICpcclxuICAgICAqIC8vIEludm9rZSBgcmVuZXdUb2tlbmAgd2hlbiB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQsIGJ1dCBub3QgbW9yZSB0aGFuIG9uY2UgZXZlcnkgNSBtaW51dGVzLlxyXG4gICAgICogdmFyIHRocm90dGxlZCA9IF8udGhyb3R0bGUocmVuZXdUb2tlbiwgMzAwMDAwLCB7ICd0cmFpbGluZyc6IGZhbHNlIH0pO1xyXG4gICAgICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIHRocm90dGxlZCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyB0aHJvdHRsZWQgaW52b2NhdGlvbi5cclxuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIHRocm90dGxlZC5jYW5jZWwpO1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0aHJvdHRsZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XHJcbiAgICAgIHZhciBsZWFkaW5nID0gdHJ1ZSxcclxuICAgICAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpc09iamVjdChvcHRpb25zKSkge1xyXG4gICAgICAgIGxlYWRpbmcgPSAnbGVhZGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy5sZWFkaW5nIDogbGVhZGluZztcclxuICAgICAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBkZWJvdW5jZShmdW5jLCB3YWl0LCB7XHJcbiAgICAgICAgJ2xlYWRpbmcnOiBsZWFkaW5nLFxyXG4gICAgICAgICdtYXhXYWl0Jzogd2FpdCxcclxuICAgICAgICAndHJhaWxpbmcnOiB0cmFpbGluZ1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgdXAgdG8gb25lIGFyZ3VtZW50LCBpZ25vcmluZyBhbnlcclxuICAgICAqIGFkZGl0aW9uYWwgYXJndW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgNC4wLjBcclxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXHJcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8ubWFwKFsnNicsICc4JywgJzEwJ10sIF8udW5hcnkocGFyc2VJbnQpKTtcclxuICAgICAqIC8vID0+IFs2LCA4LCAxMF1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdW5hcnkoZnVuYykge1xyXG4gICAgICByZXR1cm4gYXJ5KGZ1bmMsIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcHJvdmlkZXMgYHZhbHVlYCB0byBgd3JhcHBlcmAgYXMgaXRzIGZpcnN0XHJcbiAgICAgKiBhcmd1bWVudC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBmdW5jdGlvbiBhcmUgYXBwZW5kZWRcclxuICAgICAqIHRvIHRob3NlIHByb3ZpZGVkIHRvIHRoZSBgd3JhcHBlcmAuIFRoZSB3cmFwcGVyIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgXHJcbiAgICAgKiBiaW5kaW5nIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgMC4xLjBcclxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFt3cmFwcGVyPWlkZW50aXR5XSBUaGUgd3JhcHBlciBmdW5jdGlvbi5cclxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiB2YXIgcCA9IF8ud3JhcChfLmVzY2FwZSwgZnVuY3Rpb24oZnVuYywgdGV4dCkge1xyXG4gICAgICogICByZXR1cm4gJzxwPicgKyBmdW5jKHRleHQpICsgJzwvcD4nO1xyXG4gICAgICogfSk7XHJcbiAgICAgKlxyXG4gICAgICogcCgnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcclxuICAgICAqIC8vID0+ICc8cD5mcmVkLCBiYXJuZXksICZhbXA7IHBlYmJsZXM8L3A+J1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB3cmFwKHZhbHVlLCB3cmFwcGVyKSB7XHJcbiAgICAgIHJldHVybiBwYXJ0aWFsKGNhc3RGdW5jdGlvbih3cmFwcGVyKSwgdmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhc3RzIGB2YWx1ZWAgYXMgYW4gYXJyYXkgaWYgaXQncyBub3Qgb25lLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgNC40LjBcclxuICAgICAqIEBjYXRlZ29yeSBMYW5nXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IGFycmF5LlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLmNhc3RBcnJheSgxKTtcclxuICAgICAqIC8vID0+IFsxXVxyXG4gICAgICpcclxuICAgICAqIF8uY2FzdEFycmF5KHsgJ2EnOiAxIH0pO1xyXG4gICAgICogLy8gPT4gW3sgJ2EnOiAxIH1dXHJcbiAgICAgKlxyXG4gICAgICogXy5jYXN0QXJyYXkoJ2FiYycpO1xyXG4gICAgICogLy8gPT4gWydhYmMnXVxyXG4gICAgICpcclxuICAgICAqIF8uY2FzdEFycmF5KG51bGwpO1xyXG4gICAgICogLy8gPT4gW251bGxdXHJcbiAgICAgKlxyXG4gICAgICogXy5jYXN0QXJyYXkodW5kZWZpbmVkKTtcclxuICAgICAqIC8vID0+IFt1bmRlZmluZWRdXHJcbiAgICAgKlxyXG4gICAgICogXy5jYXN0QXJyYXkoKTtcclxuICAgICAqIC8vID0+IFtdXHJcbiAgICAgKlxyXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDNdO1xyXG4gICAgICogY29uc29sZS5sb2coXy5jYXN0QXJyYXkoYXJyYXkpID09PSBhcnJheSk7XHJcbiAgICAgKiAvLyA9PiB0cnVlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNhc3RBcnJheSgpIHtcclxuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciB2YWx1ZSA9IGFyZ3VtZW50c1swXTtcclxuICAgICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIHNoYWxsb3cgY2xvbmUgb2YgYHZhbHVlYC5cclxuICAgICAqXHJcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvbiB0aGVcclxuICAgICAqIFtzdHJ1Y3R1cmVkIGNsb25lIGFsZ29yaXRobV0oaHR0cHM6Ly9tZG4uaW8vU3RydWN0dXJlZF9jbG9uZV9hbGdvcml0aG0pXHJcbiAgICAgKiBhbmQgc3VwcG9ydHMgY2xvbmluZyBhcnJheXMsIGFycmF5IGJ1ZmZlcnMsIGJvb2xlYW5zLCBkYXRlIG9iamVjdHMsIG1hcHMsXHJcbiAgICAgKiBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLCBzZXRzLCBzdHJpbmdzLCBzeW1ib2xzLCBhbmQgdHlwZWRcclxuICAgICAqIGFycmF5cy4gVGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYGFyZ3VtZW50c2Agb2JqZWN0cyBhcmUgY2xvbmVkXHJcbiAgICAgKiBhcyBwbGFpbiBvYmplY3RzLiBBbiBlbXB0eSBvYmplY3QgaXMgcmV0dXJuZWQgZm9yIHVuY2xvbmVhYmxlIHZhbHVlcyBzdWNoXHJcbiAgICAgKiBhcyBlcnJvciBvYmplY3RzLCBmdW5jdGlvbnMsIERPTSBub2RlcywgYW5kIFdlYWtNYXBzLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgMC4xLjBcclxuICAgICAqIEBjYXRlZ29yeSBMYW5nXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cclxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXHJcbiAgICAgKiBAc2VlIF8uY2xvbmVEZWVwXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ2EnOiAxIH0sIHsgJ2InOiAyIH1dO1xyXG4gICAgICpcclxuICAgICAqIHZhciBzaGFsbG93ID0gXy5jbG9uZShvYmplY3RzKTtcclxuICAgICAqIGNvbnNvbGUubG9nKHNoYWxsb3dbMF0gPT09IG9iamVjdHNbMF0pO1xyXG4gICAgICogLy8gPT4gdHJ1ZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjbG9uZSh2YWx1ZSkge1xyXG4gICAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9TWU1CT0xTX0ZMQUcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jbG9uZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2hcclxuICAgICAqIGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgY2xvbmVkIHZhbHVlLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCxcclxuICAgICAqIGNsb25pbmcgaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZCB3aXRoXHJcbiAgICAgKiB1cCB0byBmb3VyIGFyZ3VtZW50czsgKHZhbHVlIFssIGluZGV4fGtleSwgb2JqZWN0LCBzdGFja10pLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgNC4wLjBcclxuICAgICAqIEBjYXRlZ29yeSBMYW5nXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXHJcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxyXG4gICAgICogQHNlZSBfLmNsb25lRGVlcFdpdGhcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcih2YWx1ZSkge1xyXG4gICAgICogICBpZiAoXy5pc0VsZW1lbnQodmFsdWUpKSB7XHJcbiAgICAgKiAgICAgcmV0dXJuIHZhbHVlLmNsb25lTm9kZShmYWxzZSk7XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqXHJcbiAgICAgKiB2YXIgZWwgPSBfLmNsb25lV2l0aChkb2N1bWVudC5ib2R5LCBjdXN0b21pemVyKTtcclxuICAgICAqXHJcbiAgICAgKiBjb25zb2xlLmxvZyhlbCA9PT0gZG9jdW1lbnQuYm9keSk7XHJcbiAgICAgKiAvLyA9PiBmYWxzZVxyXG4gICAgICogY29uc29sZS5sb2coZWwubm9kZU5hbWUpO1xyXG4gICAgICogLy8gPT4gJ0JPRFknXHJcbiAgICAgKiBjb25zb2xlLmxvZyhlbC5jaGlsZE5vZGVzLmxlbmd0aCk7XHJcbiAgICAgKiAvLyA9PiAwXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNsb25lV2l0aCh2YWx1ZSwgY3VzdG9taXplcikge1xyXG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XHJcbiAgICAgIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIENMT05FX1NZTUJPTFNfRkxBRywgY3VzdG9taXplcik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmNsb25lYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBjbG9uZXMgYHZhbHVlYC5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDEuMC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmVjdXJzaXZlbHkgY2xvbmUuXHJcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZGVlcCBjbG9uZWQgdmFsdWUuXHJcbiAgICAgKiBAc2VlIF8uY2xvbmVcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnYSc6IDEgfSwgeyAnYic6IDIgfV07XHJcbiAgICAgKlxyXG4gICAgICogdmFyIGRlZXAgPSBfLmNsb25lRGVlcChvYmplY3RzKTtcclxuICAgICAqIGNvbnNvbGUubG9nKGRlZXBbMF0gPT09IG9iamVjdHNbMF0pO1xyXG4gICAgICogLy8gPT4gZmFsc2VcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY2xvbmVEZWVwKHZhbHVlKSB7XHJcbiAgICAgIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIENMT05FX0RFRVBfRkxBRyB8IENMT05FX1NZTUJPTFNfRkxBRyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmNsb25lV2l0aGAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgY2xvbmVzIGB2YWx1ZWAuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSA0LjAuMFxyXG4gICAgICogQGNhdGVnb3J5IExhbmdcclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJlY3Vyc2l2ZWx5IGNsb25lLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZy5cclxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBkZWVwIGNsb25lZCB2YWx1ZS5cclxuICAgICAqIEBzZWUgXy5jbG9uZVdpdGhcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcih2YWx1ZSkge1xyXG4gICAgICogICBpZiAoXy5pc0VsZW1lbnQodmFsdWUpKSB7XHJcbiAgICAgKiAgICAgcmV0dXJuIHZhbHVlLmNsb25lTm9kZSh0cnVlKTtcclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICpcclxuICAgICAqIHZhciBlbCA9IF8uY2xvbmVEZWVwV2l0aChkb2N1bWVudC5ib2R5LCBjdXN0b21pemVyKTtcclxuICAgICAqXHJcbiAgICAgKiBjb25zb2xlLmxvZyhlbCA9PT0gZG9jdW1lbnQuYm9keSk7XHJcbiAgICAgKiAvLyA9PiBmYWxzZVxyXG4gICAgICogY29uc29sZS5sb2coZWwubm9kZU5hbWUpO1xyXG4gICAgICogLy8gPT4gJ0JPRFknXHJcbiAgICAgKiBjb25zb2xlLmxvZyhlbC5jaGlsZE5vZGVzLmxlbmd0aCk7XHJcbiAgICAgKiAvLyA9PiAyMFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjbG9uZURlZXBXaXRoKHZhbHVlLCBjdXN0b21pemVyKSB7XHJcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcclxuICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfREVFUF9GTEFHIHwgQ0xPTkVfU1lNQk9MU19GTEFHLCBjdXN0b21pemVyKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpZiBgb2JqZWN0YCBjb25mb3JtcyB0byBgc291cmNlYCBieSBpbnZva2luZyB0aGUgcHJlZGljYXRlXHJcbiAgICAgKiBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgdmFsdWVzIG9mIGBvYmplY3RgLlxyXG4gICAgICpcclxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBlcXVpdmFsZW50IHRvIGBfLmNvbmZvcm1zYCB3aGVuIGBzb3VyY2VgIGlzXHJcbiAgICAgKiBwYXJ0aWFsbHkgYXBwbGllZC5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDQuMTQuMFxyXG4gICAgICogQGNhdGVnb3J5IExhbmdcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHByZWRpY2F0ZXMgdG8gY29uZm9ybSB0by5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBjb25mb3JtcywgZWxzZSBgZmFsc2VgLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xyXG4gICAgICpcclxuICAgICAqIF8uY29uZm9ybXNUbyhvYmplY3QsIHsgJ2InOiBmdW5jdGlvbihuKSB7IHJldHVybiBuID4gMTsgfSB9KTtcclxuICAgICAqIC8vID0+IHRydWVcclxuICAgICAqXHJcbiAgICAgKiBfLmNvbmZvcm1zVG8ob2JqZWN0LCB7ICdiJzogZnVuY3Rpb24obikgeyByZXR1cm4gbiA+IDI7IH0gfSk7XHJcbiAgICAgKiAvLyA9PiBmYWxzZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjb25mb3Jtc1RvKG9iamVjdCwgc291cmNlKSB7XHJcbiAgICAgIHJldHVybiBzb3VyY2UgPT0gbnVsbCB8fCBiYXNlQ29uZm9ybXNUbyhvYmplY3QsIHNvdXJjZSwga2V5cyhzb3VyY2UpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBlcmZvcm1zIGFcclxuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXHJcbiAgICAgKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDQuMC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cclxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcclxuICAgICAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XHJcbiAgICAgKlxyXG4gICAgICogXy5lcShvYmplY3QsIG9iamVjdCk7XHJcbiAgICAgKiAvLyA9PiB0cnVlXHJcbiAgICAgKlxyXG4gICAgICogXy5lcShvYmplY3QsIG90aGVyKTtcclxuICAgICAqIC8vID0+IGZhbHNlXHJcbiAgICAgKlxyXG4gICAgICogXy5lcSgnYScsICdhJyk7XHJcbiAgICAgKiAvLyA9PiB0cnVlXHJcbiAgICAgKlxyXG4gICAgICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcclxuICAgICAqIC8vID0+IGZhbHNlXHJcbiAgICAgKlxyXG4gICAgICogXy5lcShOYU4sIE5hTik7XHJcbiAgICAgKiAvLyA9PiB0cnVlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xyXG4gICAgICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBgb3RoZXJgLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgMy45LjBcclxuICAgICAqIEBjYXRlZ29yeSBMYW5nXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxyXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBgb3RoZXJgLFxyXG4gICAgICogIGVsc2UgYGZhbHNlYC5cclxuICAgICAqIEBzZWUgXy5sdFxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLmd0KDMsIDEpO1xyXG4gICAgICogLy8gPT4gdHJ1ZVxyXG4gICAgICpcclxuICAgICAqIF8uZ3QoMywgMyk7XHJcbiAgICAgKiAvLyA9PiBmYWxzZVxyXG4gICAgICpcclxuICAgICAqIF8uZ3QoMSwgMyk7XHJcbiAgICAgKiAvLyA9PiBmYWxzZVxyXG4gICAgICovXHJcbiAgICB2YXIgZ3QgPSBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKGJhc2VHdCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYG90aGVyYC5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDMuOS4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cclxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG9cclxuICAgICAqICBgb3RoZXJgLCBlbHNlIGBmYWxzZWAuXHJcbiAgICAgKiBAc2VlIF8ubHRlXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8uZ3RlKDMsIDEpO1xyXG4gICAgICogLy8gPT4gdHJ1ZVxyXG4gICAgICpcclxuICAgICAqIF8uZ3RlKDMsIDMpO1xyXG4gICAgICogLy8gPT4gdHJ1ZVxyXG4gICAgICpcclxuICAgICAqIF8uZ3RlKDEsIDMpO1xyXG4gICAgICogLy8gPT4gZmFsc2VcclxuICAgICAqL1xyXG4gICAgdmFyIGd0ZSA9IGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24oZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XHJcbiAgICAgIHJldHVybiB2YWx1ZSA+PSBvdGhlcjtcclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDAuMS4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXHJcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xyXG4gICAgICogLy8gPT4gdHJ1ZVxyXG4gICAgICpcclxuICAgICAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcclxuICAgICAqIC8vID0+IGZhbHNlXHJcbiAgICAgKi9cclxuICAgIHZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxyXG4gICAgICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDAuMS4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcclxuICAgICAqIC8vID0+IHRydWVcclxuICAgICAqXHJcbiAgICAgKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XHJcbiAgICAgKiAvLyA9PiBmYWxzZVxyXG4gICAgICpcclxuICAgICAqIF8uaXNBcnJheSgnYWJjJyk7XHJcbiAgICAgKiAvLyA9PiBmYWxzZVxyXG4gICAgICpcclxuICAgICAqIF8uaXNBcnJheShfLm5vb3ApO1xyXG4gICAgICogLy8gPT4gZmFsc2VcclxuICAgICAqL1xyXG4gICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlCdWZmZXJgIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDQuMy4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogXy5pc0FycmF5QnVmZmVyKG5ldyBBcnJheUJ1ZmZlcigyKSk7XHJcbiAgICAgKiAvLyA9PiB0cnVlXHJcbiAgICAgKlxyXG4gICAgICogXy5pc0FycmF5QnVmZmVyKG5ldyBBcnJheSgyKSk7XHJcbiAgICAgKiAvLyA9PiBmYWxzZVxyXG4gICAgICovXHJcbiAgICB2YXIgaXNBcnJheUJ1ZmZlciA9IG5vZGVJc0FycmF5QnVmZmVyID8gYmFzZVVuYXJ5KG5vZGVJc0FycmF5QnVmZmVyKSA6IGJhc2VJc0FycmF5QnVmZmVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xyXG4gICAgICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxyXG4gICAgICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDQuMC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcclxuICAgICAqIC8vID0+IHRydWVcclxuICAgICAqXHJcbiAgICAgKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xyXG4gICAgICogLy8gPT4gdHJ1ZVxyXG4gICAgICpcclxuICAgICAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xyXG4gICAgICogLy8gPT4gdHJ1ZVxyXG4gICAgICpcclxuICAgICAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcclxuICAgICAqIC8vID0+IGZhbHNlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XHJcbiAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0FycmF5TGlrZWAgZXhjZXB0IHRoYXQgaXQgYWxzbyBjaGVja3MgaWYgYHZhbHVlYFxyXG4gICAgICogaXMgYW4gb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgNC4wLjBcclxuICAgICAqIEBjYXRlZ29yeSBMYW5nXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0LFxyXG4gICAgICogIGVsc2UgYGZhbHNlYC5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogXy5pc0FycmF5TGlrZU9iamVjdChbMSwgMiwgM10pO1xyXG4gICAgICogLy8gPT4gdHJ1ZVxyXG4gICAgICpcclxuICAgICAqIF8uaXNBcnJheUxpa2VPYmplY3QoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XHJcbiAgICAgKiAvLyA9PiB0cnVlXHJcbiAgICAgKlxyXG4gICAgICogXy5pc0FycmF5TGlrZU9iamVjdCgnYWJjJyk7XHJcbiAgICAgKiAvLyA9PiBmYWxzZVxyXG4gICAgICpcclxuICAgICAqIF8uaXNBcnJheUxpa2VPYmplY3QoXy5ub29wKTtcclxuICAgICAqIC8vID0+IGZhbHNlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XHJcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBib29sZWFuIHByaW1pdGl2ZSBvciBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAwLjEuMFxyXG4gICAgICogQGNhdGVnb3J5IExhbmdcclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBib29sZWFuLCBlbHNlIGBmYWxzZWAuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8uaXNCb29sZWFuKGZhbHNlKTtcclxuICAgICAqIC8vID0+IHRydWVcclxuICAgICAqXHJcbiAgICAgKiBfLmlzQm9vbGVhbihudWxsKTtcclxuICAgICAqIC8vID0+IGZhbHNlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xyXG4gICAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlIHx8XHJcbiAgICAgICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYm9vbFRhZyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDQuMy4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xyXG4gICAgICogLy8gPT4gdHJ1ZVxyXG4gICAgICpcclxuICAgICAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xyXG4gICAgICogLy8gPT4gZmFsc2VcclxuICAgICAqL1xyXG4gICAgdmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBEYXRlYCBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAwLjEuMFxyXG4gICAgICogQGNhdGVnb3J5IExhbmdcclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBkYXRlIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLmlzRGF0ZShuZXcgRGF0ZSk7XHJcbiAgICAgKiAvLyA9PiB0cnVlXHJcbiAgICAgKlxyXG4gICAgICogXy5pc0RhdGUoJ01vbiBBcHJpbCAyMyAyMDEyJyk7XHJcbiAgICAgKiAvLyA9PiBmYWxzZVxyXG4gICAgICovXHJcbiAgICB2YXIgaXNEYXRlID0gbm9kZUlzRGF0ZSA/IGJhc2VVbmFyeShub2RlSXNEYXRlKSA6IGJhc2VJc0RhdGU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBET00gZWxlbWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDAuMS4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIERPTSBlbGVtZW50LCBlbHNlIGBmYWxzZWAuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8uaXNFbGVtZW50KGRvY3VtZW50LmJvZHkpO1xyXG4gICAgICogLy8gPT4gdHJ1ZVxyXG4gICAgICpcclxuICAgICAqIF8uaXNFbGVtZW50KCc8Ym9keT4nKTtcclxuICAgICAqIC8vID0+IGZhbHNlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlzRWxlbWVudCh2YWx1ZSkge1xyXG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiB2YWx1ZS5ub2RlVHlwZSA9PT0gMSAmJiAhaXNQbGFpbk9iamVjdCh2YWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBlbXB0eSBvYmplY3QsIGNvbGxlY3Rpb24sIG1hcCwgb3Igc2V0LlxyXG4gICAgICpcclxuICAgICAqIE9iamVjdHMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIG5vIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZFxyXG4gICAgICogcHJvcGVydGllcy5cclxuICAgICAqXHJcbiAgICAgKiBBcnJheS1saWtlIHZhbHVlcyBzdWNoIGFzIGBhcmd1bWVudHNgIG9iamVjdHMsIGFycmF5cywgYnVmZmVycywgc3RyaW5ncywgb3JcclxuICAgICAqIGpRdWVyeS1saWtlIGNvbGxlY3Rpb25zIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBhIGBsZW5ndGhgIG9mIGAwYC5cclxuICAgICAqIFNpbWlsYXJseSwgbWFwcyBhbmQgc2V0cyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgYSBgc2l6ZWAgb2YgYDBgLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgMC4xLjBcclxuICAgICAqIEBjYXRlZ29yeSBMYW5nXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGVtcHR5LCBlbHNlIGBmYWxzZWAuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8uaXNFbXB0eShudWxsKTtcclxuICAgICAqIC8vID0+IHRydWVcclxuICAgICAqXHJcbiAgICAgKiBfLmlzRW1wdHkodHJ1ZSk7XHJcbiAgICAgKiAvLyA9PiB0cnVlXHJcbiAgICAgKlxyXG4gICAgICogXy5pc0VtcHR5KDEpO1xyXG4gICAgICogLy8gPT4gdHJ1ZVxyXG4gICAgICpcclxuICAgICAqIF8uaXNFbXB0eShbMSwgMiwgM10pO1xyXG4gICAgICogLy8gPT4gZmFsc2VcclxuICAgICAqXHJcbiAgICAgKiBfLmlzRW1wdHkoeyAnYSc6IDEgfSk7XHJcbiAgICAgKiAvLyA9PiBmYWxzZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XHJcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSAmJlxyXG4gICAgICAgICAgKGlzQXJyYXkodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUuc3BsaWNlID09ICdmdW5jdGlvbicgfHxcclxuICAgICAgICAgICAgaXNCdWZmZXIodmFsdWUpIHx8IGlzVHlwZWRBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpKSkge1xyXG4gICAgICAgIHJldHVybiAhdmFsdWUubGVuZ3RoO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpO1xyXG4gICAgICBpZiAodGFnID09IG1hcFRhZyB8fCB0YWcgPT0gc2V0VGFnKSB7XHJcbiAgICAgICAgcmV0dXJuICF2YWx1ZS5zaXplO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpc1Byb3RvdHlwZSh2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gIWJhc2VLZXlzKHZhbHVlKS5sZW5ndGg7XHJcbiAgICAgIH1cclxuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpIHtcclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlXHJcbiAgICAgKiBlcXVpdmFsZW50LlxyXG4gICAgICpcclxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBjb21wYXJpbmcgYXJyYXlzLCBhcnJheSBidWZmZXJzLCBib29sZWFucyxcclxuICAgICAqIGRhdGUgb2JqZWN0cywgZXJyb3Igb2JqZWN0cywgbWFwcywgbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcyxcclxuICAgICAqIHNldHMsIHN0cmluZ3MsIHN5bWJvbHMsIGFuZCB0eXBlZCBhcnJheXMuIGBPYmplY3RgIG9iamVjdHMgYXJlIGNvbXBhcmVkXHJcbiAgICAgKiBieSB0aGVpciBvd24sIG5vdCBpbmhlcml0ZWQsIGVudW1lcmFibGUgcHJvcGVydGllcy4gRnVuY3Rpb25zIGFuZCBET01cclxuICAgICAqIG5vZGVzIGFyZSBjb21wYXJlZCBieSBzdHJpY3QgZXF1YWxpdHksIGkuZS4gYD09PWAuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAwLjEuMFxyXG4gICAgICogQGNhdGVnb3J5IExhbmdcclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXHJcbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XHJcbiAgICAgKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xyXG4gICAgICpcclxuICAgICAqIF8uaXNFcXVhbChvYmplY3QsIG90aGVyKTtcclxuICAgICAqIC8vID0+IHRydWVcclxuICAgICAqXHJcbiAgICAgKiBvYmplY3QgPT09IG90aGVyO1xyXG4gICAgICogLy8gPT4gZmFsc2VcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXNFcXVhbCh2YWx1ZSwgb3RoZXIpIHtcclxuICAgICAgcmV0dXJuIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlcik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzRXF1YWxgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoXHJcbiAgICAgKiBpcyBpbnZva2VkIHRvIGNvbXBhcmUgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCwgY29tcGFyaXNvbnNcclxuICAgICAqIGFyZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGggdXAgdG9cclxuICAgICAqIHNpeCBhcmd1bWVudHM6IChvYmpWYWx1ZSwgb3RoVmFsdWUgWywgaW5kZXh8a2V5LCBvYmplY3QsIG90aGVyLCBzdGFja10pLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgNC4wLjBcclxuICAgICAqIEBjYXRlZ29yeSBMYW5nXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxyXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogZnVuY3Rpb24gaXNHcmVldGluZyh2YWx1ZSkge1xyXG4gICAgICogICByZXR1cm4gL15oKD86aXxlbGxvKSQvLnRlc3QodmFsdWUpO1xyXG4gICAgICogfVxyXG4gICAgICpcclxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlKSB7XHJcbiAgICAgKiAgIGlmIChpc0dyZWV0aW5nKG9ialZhbHVlKSAmJiBpc0dyZWV0aW5nKG90aFZhbHVlKSkge1xyXG4gICAgICogICAgIHJldHVybiB0cnVlO1xyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKlxyXG4gICAgICogdmFyIGFycmF5ID0gWydoZWxsbycsICdnb29kYnllJ107XHJcbiAgICAgKiB2YXIgb3RoZXIgPSBbJ2hpJywgJ2dvb2RieWUnXTtcclxuICAgICAqXHJcbiAgICAgKiBfLmlzRXF1YWxXaXRoKGFycmF5LCBvdGhlciwgY3VzdG9taXplcik7XHJcbiAgICAgKiAvLyA9PiB0cnVlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlzRXF1YWxXaXRoKHZhbHVlLCBvdGhlciwgY3VzdG9taXplcikge1xyXG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XHJcbiAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyID8gY3VzdG9taXplcih2YWx1ZSwgb3RoZXIpIDogdW5kZWZpbmVkO1xyXG4gICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIHVuZGVmaW5lZCwgY3VzdG9taXplcikgOiAhIXJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGBFcnJvcmAsIGBFdmFsRXJyb3JgLCBgUmFuZ2VFcnJvcmAsIGBSZWZlcmVuY2VFcnJvcmAsXHJcbiAgICAgKiBgU3ludGF4RXJyb3JgLCBgVHlwZUVycm9yYCwgb3IgYFVSSUVycm9yYCBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAzLjAuMFxyXG4gICAgICogQGNhdGVnb3J5IExhbmdcclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gZXJyb3Igb2JqZWN0LCBlbHNlIGBmYWxzZWAuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8uaXNFcnJvcihuZXcgRXJyb3IpO1xyXG4gICAgICogLy8gPT4gdHJ1ZVxyXG4gICAgICpcclxuICAgICAqIF8uaXNFcnJvcihFcnJvcik7XHJcbiAgICAgKiAvLyA9PiBmYWxzZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc0Vycm9yKHZhbHVlKSB7XHJcbiAgICAgIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XHJcbiAgICAgIHJldHVybiB0YWcgPT0gZXJyb3JUYWcgfHwgdGFnID09IGRvbUV4Y1RhZyB8fFxyXG4gICAgICAgICh0eXBlb2YgdmFsdWUubWVzc2FnZSA9PSAnc3RyaW5nJyAmJiB0eXBlb2YgdmFsdWUubmFtZSA9PSAnc3RyaW5nJyAmJiAhaXNQbGFpbk9iamVjdCh2YWx1ZSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmaW5pdGUgcHJpbWl0aXZlIG51bWJlci5cclxuICAgICAqXHJcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cclxuICAgICAqIFtgTnVtYmVyLmlzRmluaXRlYF0oaHR0cHM6Ly9tZG4uaW8vTnVtYmVyL2lzRmluaXRlKS5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDAuMS4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZpbml0ZSBudW1iZXIsIGVsc2UgYGZhbHNlYC5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogXy5pc0Zpbml0ZSgzKTtcclxuICAgICAqIC8vID0+IHRydWVcclxuICAgICAqXHJcbiAgICAgKiBfLmlzRmluaXRlKE51bWJlci5NSU5fVkFMVUUpO1xyXG4gICAgICogLy8gPT4gdHJ1ZVxyXG4gICAgICpcclxuICAgICAqIF8uaXNGaW5pdGUoSW5maW5pdHkpO1xyXG4gICAgICogLy8gPT4gZmFsc2VcclxuICAgICAqXHJcbiAgICAgKiBfLmlzRmluaXRlKCczJyk7XHJcbiAgICAgKiAvLyA9PiBmYWxzZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc0Zpbml0ZSh2YWx1ZSkge1xyXG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIG5hdGl2ZUlzRmluaXRlKHZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDAuMS4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8uaXNGdW5jdGlvbihfKTtcclxuICAgICAqIC8vID0+IHRydWVcclxuICAgICAqXHJcbiAgICAgKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xyXG4gICAgICogLy8gPT4gZmFsc2VcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcclxuICAgICAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXHJcbiAgICAgIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcclxuICAgICAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGludGVnZXIuXHJcbiAgICAgKlxyXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXHJcbiAgICAgKiBbYE51bWJlci5pc0ludGVnZXJgXShodHRwczovL21kbi5pby9OdW1iZXIvaXNJbnRlZ2VyKS5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDQuMC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBpbnRlZ2VyLCBlbHNlIGBmYWxzZWAuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8uaXNJbnRlZ2VyKDMpO1xyXG4gICAgICogLy8gPT4gdHJ1ZVxyXG4gICAgICpcclxuICAgICAqIF8uaXNJbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xyXG4gICAgICogLy8gPT4gZmFsc2VcclxuICAgICAqXHJcbiAgICAgKiBfLmlzSW50ZWdlcihJbmZpbml0eSk7XHJcbiAgICAgKiAvLyA9PiBmYWxzZVxyXG4gICAgICpcclxuICAgICAqIF8uaXNJbnRlZ2VyKCczJyk7XHJcbiAgICAgKiAvLyA9PiBmYWxzZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc0ludGVnZXIodmFsdWUpIHtcclxuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA9PSB0b0ludGVnZXIodmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cclxuICAgICAqXHJcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxyXG4gICAgICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDQuMC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLmlzTGVuZ3RoKDMpO1xyXG4gICAgICogLy8gPT4gdHJ1ZVxyXG4gICAgICpcclxuICAgICAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XHJcbiAgICAgKiAvLyA9PiBmYWxzZVxyXG4gICAgICpcclxuICAgICAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xyXG4gICAgICogLy8gPT4gZmFsc2VcclxuICAgICAqXHJcbiAgICAgKiBfLmlzTGVuZ3RoKCczJyk7XHJcbiAgICAgKiAvLyA9PiBmYWxzZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xyXG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXHJcbiAgICAgICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXHJcbiAgICAgKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXHJcbiAgICAgKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAwLjEuMFxyXG4gICAgICogQGNhdGVnb3J5IExhbmdcclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8uaXNPYmplY3Qoe30pO1xyXG4gICAgICogLy8gPT4gdHJ1ZVxyXG4gICAgICpcclxuICAgICAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcclxuICAgICAqIC8vID0+IHRydWVcclxuICAgICAqXHJcbiAgICAgKiBfLmlzT2JqZWN0KF8ubm9vcCk7XHJcbiAgICAgKiAvLyA9PiB0cnVlXHJcbiAgICAgKlxyXG4gICAgICogXy5pc09iamVjdChudWxsKTtcclxuICAgICAqIC8vID0+IGZhbHNlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XHJcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xyXG4gICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXHJcbiAgICAgKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSA0LjAuMFxyXG4gICAgICogQGNhdGVnb3J5IExhbmdcclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogXy5pc09iamVjdExpa2Uoe30pO1xyXG4gICAgICogLy8gPT4gdHJ1ZVxyXG4gICAgICpcclxuICAgICAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XHJcbiAgICAgKiAvLyA9PiB0cnVlXHJcbiAgICAgKlxyXG4gICAgICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcclxuICAgICAqIC8vID0+IGZhbHNlXHJcbiAgICAgKlxyXG4gICAgICogXy5pc09iamVjdExpa2UobnVsbCk7XHJcbiAgICAgKiAvLyA9PiBmYWxzZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcclxuICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBNYXBgIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDQuMy4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG1hcCwgZWxzZSBgZmFsc2VgLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLmlzTWFwKG5ldyBNYXApO1xyXG4gICAgICogLy8gPT4gdHJ1ZVxyXG4gICAgICpcclxuICAgICAqIF8uaXNNYXAobmV3IFdlYWtNYXApO1xyXG4gICAgICogLy8gPT4gZmFsc2VcclxuICAgICAqL1xyXG4gICAgdmFyIGlzTWFwID0gbm9kZUlzTWFwID8gYmFzZVVuYXJ5KG5vZGVJc01hcCkgOiBiYXNlSXNNYXA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQZXJmb3JtcyBhIHBhcnRpYWwgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gYG9iamVjdGAgYW5kIGBzb3VyY2VgIHRvXHJcbiAgICAgKiBkZXRlcm1pbmUgaWYgYG9iamVjdGAgY29udGFpbnMgZXF1aXZhbGVudCBwcm9wZXJ0eSB2YWx1ZXMuXHJcbiAgICAgKlxyXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGVxdWl2YWxlbnQgdG8gYF8ubWF0Y2hlc2Agd2hlbiBgc291cmNlYCBpc1xyXG4gICAgICogcGFydGlhbGx5IGFwcGxpZWQuXHJcbiAgICAgKlxyXG4gICAgICogUGFydGlhbCBjb21wYXJpc29ucyB3aWxsIG1hdGNoIGVtcHR5IGFycmF5IGFuZCBlbXB0eSBvYmplY3QgYHNvdXJjZWBcclxuICAgICAqIHZhbHVlcyBhZ2FpbnN0IGFueSBhcnJheSBvciBvYmplY3QgdmFsdWUsIHJlc3BlY3RpdmVseS4gU2VlIGBfLmlzRXF1YWxgXHJcbiAgICAgKiBmb3IgYSBsaXN0IG9mIHN1cHBvcnRlZCB2YWx1ZSBjb21wYXJpc29ucy5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDMuMC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcclxuICAgICAqXHJcbiAgICAgKiBfLmlzTWF0Y2gob2JqZWN0LCB7ICdiJzogMiB9KTtcclxuICAgICAqIC8vID0+IHRydWVcclxuICAgICAqXHJcbiAgICAgKiBfLmlzTWF0Y2gob2JqZWN0LCB7ICdiJzogMSB9KTtcclxuICAgICAqIC8vID0+IGZhbHNlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlzTWF0Y2gob2JqZWN0LCBzb3VyY2UpIHtcclxuICAgICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBnZXRNYXRjaERhdGEoc291cmNlKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzTWF0Y2hgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoXHJcbiAgICAgKiBpcyBpbnZva2VkIHRvIGNvbXBhcmUgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCwgY29tcGFyaXNvbnNcclxuICAgICAqIGFyZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGggZml2ZVxyXG4gICAgICogYXJndW1lbnRzOiAob2JqVmFsdWUsIHNyY1ZhbHVlLCBpbmRleHxrZXksIG9iamVjdCwgc291cmNlKS5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDQuMC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBmdW5jdGlvbiBpc0dyZWV0aW5nKHZhbHVlKSB7XHJcbiAgICAgKiAgIHJldHVybiAvXmgoPzppfGVsbG8pJC8udGVzdCh2YWx1ZSk7XHJcbiAgICAgKiB9XHJcbiAgICAgKlxyXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcclxuICAgICAqICAgaWYgKGlzR3JlZXRpbmcob2JqVmFsdWUpICYmIGlzR3JlZXRpbmcoc3JjVmFsdWUpKSB7XHJcbiAgICAgKiAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqXHJcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnZ3JlZXRpbmcnOiAnaGVsbG8nIH07XHJcbiAgICAgKiB2YXIgc291cmNlID0geyAnZ3JlZXRpbmcnOiAnaGknIH07XHJcbiAgICAgKlxyXG4gICAgICogXy5pc01hdGNoV2l0aChvYmplY3QsIHNvdXJjZSwgY3VzdG9taXplcik7XHJcbiAgICAgKiAvLyA9PiB0cnVlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlzTWF0Y2hXaXRoKG9iamVjdCwgc291cmNlLCBjdXN0b21pemVyKSB7XHJcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcclxuICAgICAgcmV0dXJuIGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBnZXRNYXRjaERhdGEoc291cmNlKSwgY3VzdG9taXplcik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgTmFOYC5cclxuICAgICAqXHJcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cclxuICAgICAqIFtgTnVtYmVyLmlzTmFOYF0oaHR0cHM6Ly9tZG4uaW8vTnVtYmVyL2lzTmFOKSBhbmQgaXMgbm90IHRoZSBzYW1lIGFzXHJcbiAgICAgKiBnbG9iYWwgW2Bpc05hTmBdKGh0dHBzOi8vbWRuLmlvL2lzTmFOKSB3aGljaCByZXR1cm5zIGB0cnVlYCBmb3JcclxuICAgICAqIGB1bmRlZmluZWRgIGFuZCBvdGhlciBub24tbnVtYmVyIHZhbHVlcy5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDAuMS4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLmlzTmFOKE5hTik7XHJcbiAgICAgKiAvLyA9PiB0cnVlXHJcbiAgICAgKlxyXG4gICAgICogXy5pc05hTihuZXcgTnVtYmVyKE5hTikpO1xyXG4gICAgICogLy8gPT4gdHJ1ZVxyXG4gICAgICpcclxuICAgICAqIGlzTmFOKHVuZGVmaW5lZCk7XHJcbiAgICAgKiAvLyA9PiB0cnVlXHJcbiAgICAgKlxyXG4gICAgICogXy5pc05hTih1bmRlZmluZWQpO1xyXG4gICAgICogLy8gPT4gZmFsc2VcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXNOYU4odmFsdWUpIHtcclxuICAgICAgLy8gQW4gYE5hTmAgcHJpbWl0aXZlIGlzIHRoZSBvbmx5IHZhbHVlIHRoYXQgaXMgbm90IGVxdWFsIHRvIGl0c2VsZi5cclxuICAgICAgLy8gUGVyZm9ybSB0aGUgYHRvU3RyaW5nVGFnYCBjaGVjayBmaXJzdCB0byBhdm9pZCBlcnJvcnMgd2l0aCBzb21lXHJcbiAgICAgIC8vIEFjdGl2ZVggb2JqZWN0cyBpbiBJRS5cclxuICAgICAgcmV0dXJuIGlzTnVtYmVyKHZhbHVlKSAmJiB2YWx1ZSAhPSArdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByaXN0aW5lIG5hdGl2ZSBmdW5jdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgY2FuJ3QgcmVsaWFibHkgZGV0ZWN0IG5hdGl2ZSBmdW5jdGlvbnMgaW4gdGhlIHByZXNlbmNlXHJcbiAgICAgKiBvZiB0aGUgY29yZS1qcyBwYWNrYWdlIGJlY2F1c2UgY29yZS1qcyBjaXJjdW12ZW50cyB0aGlzIGtpbmQgb2YgZGV0ZWN0aW9uLlxyXG4gICAgICogRGVzcGl0ZSBtdWx0aXBsZSByZXF1ZXN0cywgdGhlIGNvcmUtanMgbWFpbnRhaW5lciBoYXMgbWFkZSBpdCBjbGVhcjogYW55XHJcbiAgICAgKiBhdHRlbXB0IHRvIGZpeCB0aGUgZGV0ZWN0aW9uIHdpbGwgYmUgb2JzdHJ1Y3RlZC4gQXMgYSByZXN1bHQsIHdlJ3JlIGxlZnRcclxuICAgICAqIHdpdGggbGl0dGxlIGNob2ljZSBidXQgdG8gdGhyb3cgYW4gZXJyb3IuIFVuZm9ydHVuYXRlbHksIHRoaXMgYWxzbyBhZmZlY3RzXHJcbiAgICAgKiBwYWNrYWdlcywgbGlrZSBbYmFiZWwtcG9seWZpbGxdKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2JhYmVsLXBvbHlmaWxsKSxcclxuICAgICAqIHdoaWNoIHJlbHkgb24gY29yZS1qcy5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDMuMC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcclxuICAgICAqICBlbHNlIGBmYWxzZWAuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8uaXNOYXRpdmUoQXJyYXkucHJvdG90eXBlLnB1c2gpO1xyXG4gICAgICogLy8gPT4gdHJ1ZVxyXG4gICAgICpcclxuICAgICAqIF8uaXNOYXRpdmUoXyk7XHJcbiAgICAgKiAvLyA9PiBmYWxzZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc05hdGl2ZSh2YWx1ZSkge1xyXG4gICAgICBpZiAoaXNNYXNrYWJsZSh2YWx1ZSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoQ09SRV9FUlJPUl9URVhUKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBudWxsYC5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDAuMS4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgbnVsbGAsIGVsc2UgYGZhbHNlYC5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogXy5pc051bGwobnVsbCk7XHJcbiAgICAgKiAvLyA9PiB0cnVlXHJcbiAgICAgKlxyXG4gICAgICogXy5pc051bGwodm9pZCAwKTtcclxuICAgICAqIC8vID0+IGZhbHNlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlzTnVsbCh2YWx1ZSkge1xyXG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSA0LjAuMFxyXG4gICAgICogQGNhdGVnb3J5IExhbmdcclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgbnVsbGlzaCwgZWxzZSBgZmFsc2VgLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLmlzTmlsKG51bGwpO1xyXG4gICAgICogLy8gPT4gdHJ1ZVxyXG4gICAgICpcclxuICAgICAqIF8uaXNOaWwodm9pZCAwKTtcclxuICAgICAqIC8vID0+IHRydWVcclxuICAgICAqXHJcbiAgICAgKiBfLmlzTmlsKE5hTik7XHJcbiAgICAgKiAvLyA9PiBmYWxzZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc05pbCh2YWx1ZSkge1xyXG4gICAgICByZXR1cm4gdmFsdWUgPT0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgTnVtYmVyYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqICoqTm90ZToqKiBUbyBleGNsdWRlIGBJbmZpbml0eWAsIGAtSW5maW5pdHlgLCBhbmQgYE5hTmAsIHdoaWNoIGFyZVxyXG4gICAgICogY2xhc3NpZmllZCBhcyBudW1iZXJzLCB1c2UgdGhlIGBfLmlzRmluaXRlYCBtZXRob2QuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAwLjEuMFxyXG4gICAgICogQGNhdGVnb3J5IExhbmdcclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBudW1iZXIsIGVsc2UgYGZhbHNlYC5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogXy5pc051bWJlcigzKTtcclxuICAgICAqIC8vID0+IHRydWVcclxuICAgICAqXHJcbiAgICAgKiBfLmlzTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xyXG4gICAgICogLy8gPT4gdHJ1ZVxyXG4gICAgICpcclxuICAgICAqIF8uaXNOdW1iZXIoSW5maW5pdHkpO1xyXG4gICAgICogLy8gPT4gdHJ1ZVxyXG4gICAgICpcclxuICAgICAqIF8uaXNOdW1iZXIoJzMnKTtcclxuICAgICAqIC8vID0+IGZhbHNlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XHJcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHxcclxuICAgICAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBudW1iZXJUYWcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxyXG4gICAgICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgMC44LjBcclxuICAgICAqIEBjYXRlZ29yeSBMYW5nXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcclxuICAgICAqICAgdGhpcy5hID0gMTtcclxuICAgICAqIH1cclxuICAgICAqXHJcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7XHJcbiAgICAgKiAvLyA9PiBmYWxzZVxyXG4gICAgICpcclxuICAgICAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xyXG4gICAgICogLy8gPT4gZmFsc2VcclxuICAgICAqXHJcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcclxuICAgICAqIC8vID0+IHRydWVcclxuICAgICAqXHJcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7XHJcbiAgICAgKiAvLyA9PiB0cnVlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcclxuICAgICAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8IGJhc2VHZXRUYWcodmFsdWUpICE9IG9iamVjdFRhZykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUodmFsdWUpO1xyXG4gICAgICBpZiAocHJvdG8gPT09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgQ3RvciA9IGhhc093blByb3BlcnR5LmNhbGwocHJvdG8sICdjb25zdHJ1Y3RvcicpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xyXG4gICAgICByZXR1cm4gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJlxyXG4gICAgICAgIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFJlZ0V4cGAgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgMC4xLjBcclxuICAgICAqIEBjYXRlZ29yeSBMYW5nXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcmVnZXhwLCBlbHNlIGBmYWxzZWAuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8uaXNSZWdFeHAoL2FiYy8pO1xyXG4gICAgICogLy8gPT4gdHJ1ZVxyXG4gICAgICpcclxuICAgICAqIF8uaXNSZWdFeHAoJy9hYmMvJyk7XHJcbiAgICAgKiAvLyA9PiBmYWxzZVxyXG4gICAgICovXHJcbiAgICB2YXIgaXNSZWdFeHAgPSBub2RlSXNSZWdFeHAgPyBiYXNlVW5hcnkobm9kZUlzUmVnRXhwKSA6IGJhc2VJc1JlZ0V4cDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgc2FmZSBpbnRlZ2VyLiBBbiBpbnRlZ2VyIGlzIHNhZmUgaWYgaXQncyBhbiBJRUVFLTc1NFxyXG4gICAgICogZG91YmxlIHByZWNpc2lvbiBudW1iZXIgd2hpY2ggaXNuJ3QgdGhlIHJlc3VsdCBvZiBhIHJvdW5kZWQgdW5zYWZlIGludGVnZXIuXHJcbiAgICAgKlxyXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXHJcbiAgICAgKiBbYE51bWJlci5pc1NhZmVJbnRlZ2VyYF0oaHR0cHM6Ly9tZG4uaW8vTnVtYmVyL2lzU2FmZUludGVnZXIpLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgNC4wLjBcclxuICAgICAqIEBjYXRlZ29yeSBMYW5nXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc2FmZSBpbnRlZ2VyLCBlbHNlIGBmYWxzZWAuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8uaXNTYWZlSW50ZWdlcigzKTtcclxuICAgICAqIC8vID0+IHRydWVcclxuICAgICAqXHJcbiAgICAgKiBfLmlzU2FmZUludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XHJcbiAgICAgKiAvLyA9PiBmYWxzZVxyXG4gICAgICpcclxuICAgICAqIF8uaXNTYWZlSW50ZWdlcihJbmZpbml0eSk7XHJcbiAgICAgKiAvLyA9PiBmYWxzZVxyXG4gICAgICpcclxuICAgICAqIF8uaXNTYWZlSW50ZWdlcignMycpO1xyXG4gICAgICogLy8gPT4gZmFsc2VcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXNTYWZlSW50ZWdlcih2YWx1ZSkge1xyXG4gICAgICByZXR1cm4gaXNJbnRlZ2VyKHZhbHVlKSAmJiB2YWx1ZSA+PSAtTUFYX1NBRkVfSU5URUdFUiAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTZXRgIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDQuMy4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNldCwgZWxzZSBgZmFsc2VgLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLmlzU2V0KG5ldyBTZXQpO1xyXG4gICAgICogLy8gPT4gdHJ1ZVxyXG4gICAgICpcclxuICAgICAqIF8uaXNTZXQobmV3IFdlYWtTZXQpO1xyXG4gICAgICogLy8gPT4gZmFsc2VcclxuICAgICAqL1xyXG4gICAgdmFyIGlzU2V0ID0gbm9kZUlzU2V0ID8gYmFzZVVuYXJ5KG5vZGVJc1NldCkgOiBiYXNlSXNTZXQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN0cmluZ2AgcHJpbWl0aXZlIG9yIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAc2luY2UgMC4xLjBcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN0cmluZywgZWxzZSBgZmFsc2VgLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLmlzU3RyaW5nKCdhYmMnKTtcclxuICAgICAqIC8vID0+IHRydWVcclxuICAgICAqXHJcbiAgICAgKiBfLmlzU3RyaW5nKDEpO1xyXG4gICAgICogLy8gPT4gZmFsc2VcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcclxuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fFxyXG4gICAgICAgICghaXNBcnJheSh2YWx1ZSkgJiYgaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzdHJpbmdUYWcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSA0LjAuMFxyXG4gICAgICogQGNhdGVnb3J5IExhbmdcclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xyXG4gICAgICogLy8gPT4gdHJ1ZVxyXG4gICAgICpcclxuICAgICAqIF8uaXNTeW1ib2woJ2FiYycpO1xyXG4gICAgICogLy8gPT4gZmFsc2VcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcclxuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxyXG4gICAgICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAzLjAuMFxyXG4gICAgICogQGNhdGVnb3J5IExhbmdcclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XHJcbiAgICAgKiAvLyA9PiB0cnVlXHJcbiAgICAgKlxyXG4gICAgICogXy5pc1R5cGVkQXJyYXkoW10pO1xyXG4gICAgICogLy8gPT4gZmFsc2VcclxuICAgICAqL1xyXG4gICAgdmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHNpbmNlIDAuMS4wXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQGNhdGVnb3J5IExhbmdcclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAsIGVsc2UgYGZhbHNlYC5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogXy5pc1VuZGVmaW5lZCh2b2lkIDApO1xyXG4gICAgICogLy8gPT4gdHJ1ZVxyXG4gICAgICpcclxuICAgICAqIF8uaXNVbmRlZmluZWQobnVsbCk7XHJcbiAgICAgKiAvLyA9PiBmYWxzZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkge1xyXG4gICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgV2Vha01hcGAgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgNC4zLjBcclxuICAgICAqIEBjYXRlZ29yeSBMYW5nXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgd2VhayBtYXAsIGVsc2UgYGZhbHNlYC5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogXy5pc1dlYWtNYXAobmV3IFdlYWtNYXApO1xyXG4gICAgICogLy8gPT4gdHJ1ZVxyXG4gICAgICpcclxuICAgICAqIF8uaXNXZWFrTWFwKG5ldyBNYXApO1xyXG4gICAgICogLy8gPT4gZmFsc2VcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXNXZWFrTWFwKHZhbHVlKSB7XHJcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gd2Vha01hcFRhZztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgV2Vha1NldGAgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgNC4zLjBcclxuICAgICAqIEBjYXRlZ29yeSBMYW5nXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgd2VhayBzZXQsIGVsc2UgYGZhbHNlYC5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogXy5pc1dlYWtTZXQobmV3IFdlYWtTZXQpO1xyXG4gICAgICogLy8gPT4gdHJ1ZVxyXG4gICAgICpcclxuICAgICAqIF8uaXNXZWFrU2V0KG5ldyBTZXQpO1xyXG4gICAgICogLy8gPT4gZmFsc2VcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXNXZWFrU2V0KHZhbHVlKSB7XHJcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHdlYWtTZXRUYWc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gYG90aGVyYC5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDMuOS4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cclxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gYG90aGVyYCxcclxuICAgICAqICBlbHNlIGBmYWxzZWAuXHJcbiAgICAgKiBAc2VlIF8uZ3RcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogXy5sdCgxLCAzKTtcclxuICAgICAqIC8vID0+IHRydWVcclxuICAgICAqXHJcbiAgICAgKiBfLmx0KDMsIDMpO1xyXG4gICAgICogLy8gPT4gZmFsc2VcclxuICAgICAqXHJcbiAgICAgKiBfLmx0KDMsIDEpO1xyXG4gICAgICogLy8gPT4gZmFsc2VcclxuICAgICAqL1xyXG4gICAgdmFyIGx0ID0gY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbihiYXNlTHQpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBvdGhlcmAuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAzLjkuMFxyXG4gICAgICogQGNhdGVnb3J5IExhbmdcclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXHJcbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvXHJcbiAgICAgKiAgYG90aGVyYCwgZWxzZSBgZmFsc2VgLlxyXG4gICAgICogQHNlZSBfLmd0ZVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLmx0ZSgxLCAzKTtcclxuICAgICAqIC8vID0+IHRydWVcclxuICAgICAqXHJcbiAgICAgKiBfLmx0ZSgzLCAzKTtcclxuICAgICAqIC8vID0+IHRydWVcclxuICAgICAqXHJcbiAgICAgKiBfLmx0ZSgzLCAxKTtcclxuICAgICAqIC8vID0+IGZhbHNlXHJcbiAgICAgKi9cclxuICAgIHZhciBsdGUgPSBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xyXG4gICAgICByZXR1cm4gdmFsdWUgPD0gb3RoZXI7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gYXJyYXkuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHNpbmNlIDAuMS4wXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQGNhdGVnb3J5IExhbmdcclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogXy50b0FycmF5KHsgJ2EnOiAxLCAnYic6IDIgfSk7XHJcbiAgICAgKiAvLyA9PiBbMSwgMl1cclxuICAgICAqXHJcbiAgICAgKiBfLnRvQXJyYXkoJ2FiYycpO1xyXG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddXHJcbiAgICAgKlxyXG4gICAgICogXy50b0FycmF5KDEpO1xyXG4gICAgICogLy8gPT4gW11cclxuICAgICAqXHJcbiAgICAgKiBfLnRvQXJyYXkobnVsbCk7XHJcbiAgICAgKiAvLyA9PiBbXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0b0FycmF5KHZhbHVlKSB7XHJcbiAgICAgIGlmICghdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiBpc1N0cmluZyh2YWx1ZSkgPyBzdHJpbmdUb0FycmF5KHZhbHVlKSA6IGNvcHlBcnJheSh2YWx1ZSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHN5bUl0ZXJhdG9yICYmIHZhbHVlW3N5bUl0ZXJhdG9yXSkge1xyXG4gICAgICAgIHJldHVybiBpdGVyYXRvclRvQXJyYXkodmFsdWVbc3ltSXRlcmF0b3JdKCkpO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpLFxyXG4gICAgICAgICAgZnVuYyA9IHRhZyA9PSBtYXBUYWcgPyBtYXBUb0FycmF5IDogKHRhZyA9PSBzZXRUYWcgPyBzZXRUb0FycmF5IDogdmFsdWVzKTtcclxuXHJcbiAgICAgIHJldHVybiBmdW5jKHZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBmaW5pdGUgbnVtYmVyLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgNC4xMi4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBudW1iZXIuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8udG9GaW5pdGUoMy4yKTtcclxuICAgICAqIC8vID0+IDMuMlxyXG4gICAgICpcclxuICAgICAqIF8udG9GaW5pdGUoTnVtYmVyLk1JTl9WQUxVRSk7XHJcbiAgICAgKiAvLyA9PiA1ZS0zMjRcclxuICAgICAqXHJcbiAgICAgKiBfLnRvRmluaXRlKEluZmluaXR5KTtcclxuICAgICAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XHJcbiAgICAgKlxyXG4gICAgICogXy50b0Zpbml0ZSgnMy4yJyk7XHJcbiAgICAgKiAvLyA9PiAzLjJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdG9GaW5pdGUodmFsdWUpIHtcclxuICAgICAgaWYgKCF2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogMDtcclxuICAgICAgfVxyXG4gICAgICB2YWx1ZSA9IHRvTnVtYmVyKHZhbHVlKTtcclxuICAgICAgaWYgKHZhbHVlID09PSBJTkZJTklUWSB8fCB2YWx1ZSA9PT0gLUlORklOSVRZKSB7XHJcbiAgICAgICAgdmFyIHNpZ24gPSAodmFsdWUgPCAwID8gLTEgOiAxKTtcclxuICAgICAgICByZXR1cm4gc2lnbiAqIE1BWF9JTlRFR0VSO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgPyB2YWx1ZSA6IDA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIuXHJcbiAgICAgKlxyXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cclxuICAgICAqIFtgVG9JbnRlZ2VyYF0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvaW50ZWdlcikuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSA0LjAuMFxyXG4gICAgICogQGNhdGVnb3J5IExhbmdcclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogXy50b0ludGVnZXIoMy4yKTtcclxuICAgICAqIC8vID0+IDNcclxuICAgICAqXHJcbiAgICAgKiBfLnRvSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcclxuICAgICAqIC8vID0+IDBcclxuICAgICAqXHJcbiAgICAgKiBfLnRvSW50ZWdlcihJbmZpbml0eSk7XHJcbiAgICAgKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxyXG4gICAgICpcclxuICAgICAqIF8udG9JbnRlZ2VyKCczLjInKTtcclxuICAgICAqIC8vID0+IDNcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdG9JbnRlZ2VyKHZhbHVlKSB7XHJcbiAgICAgIHZhciByZXN1bHQgPSB0b0Zpbml0ZSh2YWx1ZSksXHJcbiAgICAgICAgICByZW1haW5kZXIgPSByZXN1bHQgJSAxO1xyXG5cclxuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gcmVzdWx0ID8gKHJlbWFpbmRlciA/IHJlc3VsdCAtIHJlbWFpbmRlciA6IHJlc3VsdCkgOiAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBpbnRlZ2VyIHN1aXRhYmxlIGZvciB1c2UgYXMgdGhlIGxlbmd0aCBvZiBhblxyXG4gICAgICogYXJyYXktbGlrZSBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXHJcbiAgICAgKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgNC4wLjBcclxuICAgICAqIEBjYXRlZ29yeSBMYW5nXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8udG9MZW5ndGgoMy4yKTtcclxuICAgICAqIC8vID0+IDNcclxuICAgICAqXHJcbiAgICAgKiBfLnRvTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xyXG4gICAgICogLy8gPT4gMFxyXG4gICAgICpcclxuICAgICAqIF8udG9MZW5ndGgoSW5maW5pdHkpO1xyXG4gICAgICogLy8gPT4gNDI5NDk2NzI5NVxyXG4gICAgICpcclxuICAgICAqIF8udG9MZW5ndGgoJzMuMicpO1xyXG4gICAgICogLy8gPT4gM1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0b0xlbmd0aCh2YWx1ZSkge1xyXG4gICAgICByZXR1cm4gdmFsdWUgPyBiYXNlQ2xhbXAodG9JbnRlZ2VyKHZhbHVlKSwgMCwgTUFYX0FSUkFZX0xFTkdUSCkgOiAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDQuMC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogXy50b051bWJlcigzLjIpO1xyXG4gICAgICogLy8gPT4gMy4yXHJcbiAgICAgKlxyXG4gICAgICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcclxuICAgICAqIC8vID0+IDVlLTMyNFxyXG4gICAgICpcclxuICAgICAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xyXG4gICAgICogLy8gPT4gSW5maW5pdHlcclxuICAgICAqXHJcbiAgICAgKiBfLnRvTnVtYmVyKCczLjInKTtcclxuICAgICAqIC8vID0+IDMuMlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xyXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gTkFOO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcclxuICAgICAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XHJcbiAgICAgICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcclxuICAgICAgfVxyXG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XHJcbiAgICAgIH1cclxuICAgICAgdmFsdWUgPSBiYXNlVHJpbSh2YWx1ZSk7XHJcbiAgICAgIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XHJcbiAgICAgIHJldHVybiAoaXNCaW5hcnkgfHwgcmVJc09jdGFsLnRlc3QodmFsdWUpKVxyXG4gICAgICAgID8gZnJlZVBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KVxyXG4gICAgICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHBsYWluIG9iamVjdCBmbGF0dGVuaW5nIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZ1xyXG4gICAgICoga2V5ZWQgcHJvcGVydGllcyBvZiBgdmFsdWVgIHRvIG93biBwcm9wZXJ0aWVzIG9mIHRoZSBwbGFpbiBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAzLjAuMFxyXG4gICAgICogQGNhdGVnb3J5IExhbmdcclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgcGxhaW4gb2JqZWN0LlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XHJcbiAgICAgKiAgIHRoaXMuYiA9IDI7XHJcbiAgICAgKiB9XHJcbiAgICAgKlxyXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcclxuICAgICAqXHJcbiAgICAgKiBfLmFzc2lnbih7ICdhJzogMSB9LCBuZXcgRm9vKTtcclxuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxyXG4gICAgICpcclxuICAgICAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIF8udG9QbGFpbk9iamVjdChuZXcgRm9vKSk7XHJcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0b1BsYWluT2JqZWN0KHZhbHVlKSB7XHJcbiAgICAgIHJldHVybiBjb3B5T2JqZWN0KHZhbHVlLCBrZXlzSW4odmFsdWUpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzYWZlIGludGVnZXIuIEEgc2FmZSBpbnRlZ2VyIGNhbiBiZSBjb21wYXJlZCBhbmRcclxuICAgICAqIHJlcHJlc2VudGVkIGNvcnJlY3RseS5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDQuMC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLnRvU2FmZUludGVnZXIoMy4yKTtcclxuICAgICAqIC8vID0+IDNcclxuICAgICAqXHJcbiAgICAgKiBfLnRvU2FmZUludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XHJcbiAgICAgKiAvLyA9PiAwXHJcbiAgICAgKlxyXG4gICAgICogXy50b1NhZmVJbnRlZ2VyKEluZmluaXR5KTtcclxuICAgICAqIC8vID0+IDkwMDcxOTkyNTQ3NDA5OTFcclxuICAgICAqXHJcbiAgICAgKiBfLnRvU2FmZUludGVnZXIoJzMuMicpO1xyXG4gICAgICogLy8gPT4gM1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0b1NhZmVJbnRlZ2VyKHZhbHVlKSB7XHJcbiAgICAgIHJldHVybiB2YWx1ZVxyXG4gICAgICAgID8gYmFzZUNsYW1wKHRvSW50ZWdlcih2YWx1ZSksIC1NQVhfU0FGRV9JTlRFR0VSLCBNQVhfU0FGRV9JTlRFR0VSKVxyXG4gICAgICAgIDogKHZhbHVlID09PSAwID8gdmFsdWUgOiAwKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXHJcbiAgICAgKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDQuMC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8udG9TdHJpbmcobnVsbCk7XHJcbiAgICAgKiAvLyA9PiAnJ1xyXG4gICAgICpcclxuICAgICAqIF8udG9TdHJpbmcoLTApO1xyXG4gICAgICogLy8gPT4gJy0wJ1xyXG4gICAgICpcclxuICAgICAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcclxuICAgICAqIC8vID0+ICcxLDIsMydcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcclxuICAgICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXNzaWducyBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0cyB0byB0aGVcclxuICAgICAqIGRlc3RpbmF0aW9uIG9iamVjdC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxyXG4gICAgICogU3Vic2VxdWVudCBzb3VyY2VzIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLlxyXG4gICAgICpcclxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgIGFuZCBpcyBsb29zZWx5IGJhc2VkIG9uXHJcbiAgICAgKiBbYE9iamVjdC5hc3NpZ25gXShodHRwczovL21kbi5pby9PYmplY3QvYXNzaWduKS5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDAuMTAuMFxyXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxyXG4gICAgICogQHNlZSBfLmFzc2lnbkluXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcclxuICAgICAqICAgdGhpcy5hID0gMTtcclxuICAgICAqIH1cclxuICAgICAqXHJcbiAgICAgKiBmdW5jdGlvbiBCYXIoKSB7XHJcbiAgICAgKiAgIHRoaXMuYyA9IDM7XHJcbiAgICAgKiB9XHJcbiAgICAgKlxyXG4gICAgICogRm9vLnByb3RvdHlwZS5iID0gMjtcclxuICAgICAqIEJhci5wcm90b3R5cGUuZCA9IDQ7XHJcbiAgICAgKlxyXG4gICAgICogXy5hc3NpZ24oeyAnYSc6IDAgfSwgbmV3IEZvbywgbmV3IEJhcik7XHJcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cclxuICAgICAqL1xyXG4gICAgdmFyIGFzc2lnbiA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlKSB7XHJcbiAgICAgIGlmIChpc1Byb3RvdHlwZShzb3VyY2UpIHx8IGlzQXJyYXlMaWtlKHNvdXJjZSkpIHtcclxuICAgICAgICBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XHJcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XHJcbiAgICAgICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgc291cmNlW2tleV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBvd24gYW5kXHJcbiAgICAgKiBpbmhlcml0ZWQgc291cmNlIHByb3BlcnRpZXMuXHJcbiAgICAgKlxyXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSA0LjAuMFxyXG4gICAgICogQGFsaWFzIGV4dGVuZFxyXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxyXG4gICAgICogQHNlZSBfLmFzc2lnblxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XHJcbiAgICAgKiAgIHRoaXMuYSA9IDE7XHJcbiAgICAgKiB9XHJcbiAgICAgKlxyXG4gICAgICogZnVuY3Rpb24gQmFyKCkge1xyXG4gICAgICogICB0aGlzLmMgPSAzO1xyXG4gICAgICogfVxyXG4gICAgICpcclxuICAgICAqIEZvby5wcm90b3R5cGUuYiA9IDI7XHJcbiAgICAgKiBCYXIucHJvdG90eXBlLmQgPSA0O1xyXG4gICAgICpcclxuICAgICAqIF8uYXNzaWduSW4oeyAnYSc6IDAgfSwgbmV3IEZvbywgbmV3IEJhcik7XHJcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMsICdkJzogNCB9XHJcbiAgICAgKi9cclxuICAgIHZhciBhc3NpZ25JbiA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlKSB7XHJcbiAgICAgIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0KTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25JbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmBcclxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgYXNzaWduZWQgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJuc1xyXG4gICAgICogYHVuZGVmaW5lZGAsIGFzc2lnbm1lbnQgaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmBcclxuICAgICAqIGlzIGludm9rZWQgd2l0aCBmaXZlIGFyZ3VtZW50czogKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSkuXHJcbiAgICAgKlxyXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSA0LjAuMFxyXG4gICAgICogQGFsaWFzIGV4dGVuZFdpdGhcclxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzb3VyY2VzIFRoZSBzb3VyY2Ugb2JqZWN0cy5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXHJcbiAgICAgKiBAc2VlIF8uYXNzaWduV2l0aFxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSkge1xyXG4gICAgICogICByZXR1cm4gXy5pc1VuZGVmaW5lZChvYmpWYWx1ZSkgPyBzcmNWYWx1ZSA6IG9ialZhbHVlO1xyXG4gICAgICogfVxyXG4gICAgICpcclxuICAgICAqIHZhciBkZWZhdWx0cyA9IF8ucGFydGlhbFJpZ2h0KF8uYXNzaWduSW5XaXRoLCBjdXN0b21pemVyKTtcclxuICAgICAqXHJcbiAgICAgKiBkZWZhdWx0cyh7ICdhJzogMSB9LCB7ICdiJzogMiB9LCB7ICdhJzogMyB9KTtcclxuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxyXG4gICAgICovXHJcbiAgICB2YXIgYXNzaWduSW5XaXRoID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKSB7XHJcbiAgICAgIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0LCBjdXN0b21pemVyKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgXHJcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIGFzc2lnbmVkIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnNcclxuICAgICAqIGB1bmRlZmluZWRgLCBhc3NpZ25tZW50IGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgXHJcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggZml2ZSBhcmd1bWVudHM6IChvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UpLlxyXG4gICAgICpcclxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgNC4wLjBcclxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzb3VyY2VzIFRoZSBzb3VyY2Ugb2JqZWN0cy5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXHJcbiAgICAgKiBAc2VlIF8uYXNzaWduSW5XaXRoXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlKSB7XHJcbiAgICAgKiAgIHJldHVybiBfLmlzVW5kZWZpbmVkKG9ialZhbHVlKSA/IHNyY1ZhbHVlIDogb2JqVmFsdWU7XHJcbiAgICAgKiB9XHJcbiAgICAgKlxyXG4gICAgICogdmFyIGRlZmF1bHRzID0gXy5wYXJ0aWFsUmlnaHQoXy5hc3NpZ25XaXRoLCBjdXN0b21pemVyKTtcclxuICAgICAqXHJcbiAgICAgKiBkZWZhdWx0cyh7ICdhJzogMSB9LCB7ICdiJzogMiB9LCB7ICdhJzogMyB9KTtcclxuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxyXG4gICAgICovXHJcbiAgICB2YXIgYXNzaWduV2l0aCA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xyXG4gICAgICBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QsIGN1c3RvbWl6ZXIpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIGBwYXRoc2Agb2YgYG9iamVjdGAuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAxLjAuMFxyXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cclxuICAgICAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHBpY2tlZCB2YWx1ZXMuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH0sIDRdIH07XHJcbiAgICAgKlxyXG4gICAgICogXy5hdChvYmplY3QsIFsnYVswXS5iLmMnLCAnYVsxXSddKTtcclxuICAgICAqIC8vID0+IFszLCA0XVxyXG4gICAgICovXHJcbiAgICB2YXIgYXQgPSBmbGF0UmVzdChiYXNlQXQpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIHRoZSBgcHJvdG90eXBlYCBvYmplY3QuIElmIGFcclxuICAgICAqIGBwcm9wZXJ0aWVzYCBvYmplY3QgaXMgZ2l2ZW4sIGl0cyBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllc1xyXG4gICAgICogYXJlIGFzc2lnbmVkIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDIuMy4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvdG90eXBlIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXSBUaGUgcHJvcGVydGllcyB0byBhc3NpZ24gdG8gdGhlIG9iamVjdC5cclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIGZ1bmN0aW9uIFNoYXBlKCkge1xyXG4gICAgICogICB0aGlzLnggPSAwO1xyXG4gICAgICogICB0aGlzLnkgPSAwO1xyXG4gICAgICogfVxyXG4gICAgICpcclxuICAgICAqIGZ1bmN0aW9uIENpcmNsZSgpIHtcclxuICAgICAqICAgU2hhcGUuY2FsbCh0aGlzKTtcclxuICAgICAqIH1cclxuICAgICAqXHJcbiAgICAgKiBDaXJjbGUucHJvdG90eXBlID0gXy5jcmVhdGUoU2hhcGUucHJvdG90eXBlLCB7XHJcbiAgICAgKiAgICdjb25zdHJ1Y3Rvcic6IENpcmNsZVxyXG4gICAgICogfSk7XHJcbiAgICAgKlxyXG4gICAgICogdmFyIGNpcmNsZSA9IG5ldyBDaXJjbGU7XHJcbiAgICAgKiBjaXJjbGUgaW5zdGFuY2VvZiBDaXJjbGU7XHJcbiAgICAgKiAvLyA9PiB0cnVlXHJcbiAgICAgKlxyXG4gICAgICogY2lyY2xlIGluc3RhbmNlb2YgU2hhcGU7XHJcbiAgICAgKiAvLyA9PiB0cnVlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZShwcm90b3R5cGUsIHByb3BlcnRpZXMpIHtcclxuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VDcmVhdGUocHJvdG90eXBlKTtcclxuICAgICAgcmV0dXJuIHByb3BlcnRpZXMgPT0gbnVsbCA/IHJlc3VsdCA6IGJhc2VBc3NpZ24ocmVzdWx0LCBwcm9wZXJ0aWVzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFzc2lnbnMgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2VcclxuICAgICAqIG9iamVjdHMgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdCBmb3IgYWxsIGRlc3RpbmF0aW9uIHByb3BlcnRpZXMgdGhhdFxyXG4gICAgICogcmVzb2x2ZSB0byBgdW5kZWZpbmVkYC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxyXG4gICAgICogT25jZSBhIHByb3BlcnR5IGlzIHNldCwgYWRkaXRpb25hbCB2YWx1ZXMgb2YgdGhlIHNhbWUgcHJvcGVydHkgYXJlIGlnbm9yZWQuXHJcbiAgICAgKlxyXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHNpbmNlIDAuMS4wXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxyXG4gICAgICogQHNlZSBfLmRlZmF1bHRzRGVlcFxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLmRlZmF1bHRzKHsgJ2EnOiAxIH0sIHsgJ2InOiAyIH0sIHsgJ2EnOiAzIH0pO1xyXG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XHJcbiAgICAgKi9cclxuICAgIHZhciBkZWZhdWx0cyA9IGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xyXG4gICAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcclxuXHJcbiAgICAgIHZhciBpbmRleCA9IC0xO1xyXG4gICAgICB2YXIgbGVuZ3RoID0gc291cmNlcy5sZW5ndGg7XHJcbiAgICAgIHZhciBndWFyZCA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzWzJdIDogdW5kZWZpbmVkO1xyXG5cclxuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xyXG4gICAgICAgIGxlbmd0aCA9IDE7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xyXG4gICAgICAgIHZhciBwcm9wcyA9IGtleXNJbihzb3VyY2UpO1xyXG4gICAgICAgIHZhciBwcm9wc0luZGV4ID0gLTE7XHJcbiAgICAgICAgdmFyIHByb3BzTGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xyXG5cclxuICAgICAgICB3aGlsZSAoKytwcm9wc0luZGV4IDwgcHJvcHNMZW5ndGgpIHtcclxuICAgICAgICAgIHZhciBrZXkgPSBwcm9wc1twcm9wc0luZGV4XTtcclxuICAgICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdFtrZXldO1xyXG5cclxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8XHJcbiAgICAgICAgICAgICAgKGVxKHZhbHVlLCBvYmplY3RQcm90b1trZXldKSAmJiAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSB7XHJcbiAgICAgICAgICAgIG9iamVjdFtrZXldID0gc291cmNlW2tleV07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gb2JqZWN0O1xyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmRlZmF1bHRzYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBhc3NpZ25zXHJcbiAgICAgKiBkZWZhdWx0IHByb3BlcnRpZXMuXHJcbiAgICAgKlxyXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAzLjEwLjBcclxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxyXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cclxuICAgICAqIEBzZWUgXy5kZWZhdWx0c1xyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLmRlZmF1bHRzRGVlcCh7ICdhJzogeyAnYic6IDIgfSB9LCB7ICdhJzogeyAnYic6IDEsICdjJzogMyB9IH0pO1xyXG4gICAgICogLy8gPT4geyAnYSc6IHsgJ2InOiAyLCAnYyc6IDMgfSB9XHJcbiAgICAgKi9cclxuICAgIHZhciBkZWZhdWx0c0RlZXAgPSBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XHJcbiAgICAgIGFyZ3MucHVzaCh1bmRlZmluZWQsIGN1c3RvbURlZmF1bHRzTWVyZ2UpO1xyXG4gICAgICByZXR1cm4gYXBwbHkobWVyZ2VXaXRoLCB1bmRlZmluZWQsIGFyZ3MpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGtleSBvZiB0aGUgZmlyc3RcclxuICAgICAqIGVsZW1lbnQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgMS4xLjBcclxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFJldHVybnMgdGhlIGtleSBvZiB0aGUgbWF0Y2hlZCBlbGVtZW50LFxyXG4gICAgICogIGVsc2UgYHVuZGVmaW5lZGAuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIHZhciB1c2VycyA9IHtcclxuICAgICAqICAgJ2Jhcm5leSc6ICB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcclxuICAgICAqICAgJ2ZyZWQnOiAgICB7ICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0sXHJcbiAgICAgKiAgICdwZWJibGVzJzogeyAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cclxuICAgICAqIH07XHJcbiAgICAgKlxyXG4gICAgICogXy5maW5kS2V5KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZSA8IDQwOyB9KTtcclxuICAgICAqIC8vID0+ICdiYXJuZXknIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXHJcbiAgICAgKlxyXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cclxuICAgICAqIF8uZmluZEtleSh1c2VycywgeyAnYWdlJzogMSwgJ2FjdGl2ZSc6IHRydWUgfSk7XHJcbiAgICAgKiAvLyA9PiAncGViYmxlcydcclxuICAgICAqXHJcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXHJcbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcclxuICAgICAqIC8vID0+ICdmcmVkJ1xyXG4gICAgICpcclxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxyXG4gICAgICogXy5maW5kS2V5KHVzZXJzLCAnYWN0aXZlJyk7XHJcbiAgICAgKiAvLyA9PiAnYmFybmV5J1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBmaW5kS2V5KG9iamVjdCwgcHJlZGljYXRlKSB7XHJcbiAgICAgIHJldHVybiBiYXNlRmluZEtleShvYmplY3QsIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGJhc2VGb3JPd24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kS2V5YCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXHJcbiAgICAgKiBhIGNvbGxlY3Rpb24gaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgMi4wLjBcclxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFJldHVybnMgdGhlIGtleSBvZiB0aGUgbWF0Y2hlZCBlbGVtZW50LFxyXG4gICAgICogIGVsc2UgYHVuZGVmaW5lZGAuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIHZhciB1c2VycyA9IHtcclxuICAgICAqICAgJ2Jhcm5leSc6ICB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcclxuICAgICAqICAgJ2ZyZWQnOiAgICB7ICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0sXHJcbiAgICAgKiAgICdwZWJibGVzJzogeyAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cclxuICAgICAqIH07XHJcbiAgICAgKlxyXG4gICAgICogXy5maW5kTGFzdEtleSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hZ2UgPCA0MDsgfSk7XHJcbiAgICAgKiAvLyA9PiByZXR1cm5zICdwZWJibGVzJyBhc3N1bWluZyBgXy5maW5kS2V5YCByZXR1cm5zICdiYXJuZXknXHJcbiAgICAgKlxyXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cclxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9KTtcclxuICAgICAqIC8vID0+ICdiYXJuZXknXHJcbiAgICAgKlxyXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxyXG4gICAgICogXy5maW5kTGFzdEtleSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xyXG4gICAgICogLy8gPT4gJ2ZyZWQnXHJcbiAgICAgKlxyXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXHJcbiAgICAgKiBfLmZpbmRMYXN0S2V5KHVzZXJzLCAnYWN0aXZlJyk7XHJcbiAgICAgKiAvLyA9PiAncGViYmxlcydcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZmluZExhc3RLZXkob2JqZWN0LCBwcmVkaWNhdGUpIHtcclxuICAgICAgcmV0dXJuIGJhc2VGaW5kS2V5KG9iamVjdCwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgYmFzZUZvck93blJpZ2h0KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEl0ZXJhdGVzIG92ZXIgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBhblxyXG4gICAgICogb2JqZWN0IGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkXHJcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBrZXksIG9iamVjdCkuIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdFxyXG4gICAgICogaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAwLjMuMFxyXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxyXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cclxuICAgICAqIEBzZWUgXy5mb3JJblJpZ2h0XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcclxuICAgICAqICAgdGhpcy5hID0gMTtcclxuICAgICAqICAgdGhpcy5iID0gMjtcclxuICAgICAqIH1cclxuICAgICAqXHJcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xyXG4gICAgICpcclxuICAgICAqIF8uZm9ySW4obmV3IEZvbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xyXG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xyXG4gICAgICogfSk7XHJcbiAgICAgKiAvLyA9PiBMb2dzICdhJywgJ2InLCB0aGVuICdjJyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZm9ySW4ob2JqZWN0LCBpdGVyYXRlZSkge1xyXG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGxcclxuICAgICAgICA/IG9iamVjdFxyXG4gICAgICAgIDogYmFzZUZvcihvYmplY3QsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSwga2V5c0luKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZm9ySW5gIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgcHJvcGVydGllcyBvZlxyXG4gICAgICogYG9iamVjdGAgaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgMi4wLjBcclxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXHJcbiAgICAgKiBAc2VlIF8uZm9ySW5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xyXG4gICAgICogICB0aGlzLmEgPSAxO1xyXG4gICAgICogICB0aGlzLmIgPSAyO1xyXG4gICAgICogfVxyXG4gICAgICpcclxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XHJcbiAgICAgKlxyXG4gICAgICogXy5mb3JJblJpZ2h0KG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcclxuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcclxuICAgICAqIH0pO1xyXG4gICAgICogLy8gPT4gTG9ncyAnYycsICdiJywgdGhlbiAnYScgYXNzdW1pbmcgYF8uZm9ySW5gIGxvZ3MgJ2EnLCAnYicsIHRoZW4gJ2MnLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBmb3JJblJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUpIHtcclxuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsXHJcbiAgICAgICAgPyBvYmplY3RcclxuICAgICAgICA6IGJhc2VGb3JSaWdodChvYmplY3QsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSwga2V5c0luKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEl0ZXJhdGVzIG92ZXIgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0IGFuZFxyXG4gICAgICogaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlXHJcbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwga2V5LCBvYmplY3QpLiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uXHJcbiAgICAgKiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgMC4zLjBcclxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXHJcbiAgICAgKiBAc2VlIF8uZm9yT3duUmlnaHRcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xyXG4gICAgICogICB0aGlzLmEgPSAxO1xyXG4gICAgICogICB0aGlzLmIgPSAyO1xyXG4gICAgICogfVxyXG4gICAgICpcclxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XHJcbiAgICAgKlxyXG4gICAgICogXy5mb3JPd24obmV3IEZvbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xyXG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xyXG4gICAgICogfSk7XHJcbiAgICAgKiAvLyA9PiBMb2dzICdhJyB0aGVuICdiJyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZm9yT3duKG9iamVjdCwgaXRlcmF0ZWUpIHtcclxuICAgICAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yT3duKG9iamVjdCwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZm9yT3duYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIHByb3BlcnRpZXMgb2ZcclxuICAgICAqIGBvYmplY3RgIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDIuMC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxyXG4gICAgICogQHNlZSBfLmZvck93blxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XHJcbiAgICAgKiAgIHRoaXMuYSA9IDE7XHJcbiAgICAgKiAgIHRoaXMuYiA9IDI7XHJcbiAgICAgKiB9XHJcbiAgICAgKlxyXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcclxuICAgICAqXHJcbiAgICAgKiBfLmZvck93blJpZ2h0KG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcclxuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcclxuICAgICAqIH0pO1xyXG4gICAgICogLy8gPT4gTG9ncyAnYicgdGhlbiAnYScgYXNzdW1pbmcgYF8uZm9yT3duYCBsb2dzICdhJyB0aGVuICdiJy5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZm9yT3duUmlnaHQob2JqZWN0LCBpdGVyYXRlZSkge1xyXG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3JPd25SaWdodChvYmplY3QsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGZ1bmN0aW9uIHByb3BlcnR5IG5hbWVzIGZyb20gb3duIGVudW1lcmFibGUgcHJvcGVydGllc1xyXG4gICAgICogb2YgYG9iamVjdGAuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHNpbmNlIDAuMS4wXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGZ1bmN0aW9uIG5hbWVzLlxyXG4gICAgICogQHNlZSBfLmZ1bmN0aW9uc0luXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcclxuICAgICAqICAgdGhpcy5hID0gXy5jb25zdGFudCgnYScpO1xyXG4gICAgICogICB0aGlzLmIgPSBfLmNvbnN0YW50KCdiJyk7XHJcbiAgICAgKiB9XHJcbiAgICAgKlxyXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gXy5jb25zdGFudCgnYycpO1xyXG4gICAgICpcclxuICAgICAqIF8uZnVuY3Rpb25zKG5ldyBGb28pO1xyXG4gICAgICogLy8gPT4gWydhJywgJ2InXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBmdW5jdGlvbnMob2JqZWN0KSB7XHJcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZUZ1bmN0aW9ucyhvYmplY3QsIGtleXMob2JqZWN0KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGZ1bmN0aW9uIHByb3BlcnR5IG5hbWVzIGZyb20gb3duIGFuZCBpbmhlcml0ZWRcclxuICAgICAqIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBgb2JqZWN0YC5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDQuMC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cclxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgZnVuY3Rpb24gbmFtZXMuXHJcbiAgICAgKiBAc2VlIF8uZnVuY3Rpb25zXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcclxuICAgICAqICAgdGhpcy5hID0gXy5jb25zdGFudCgnYScpO1xyXG4gICAgICogICB0aGlzLmIgPSBfLmNvbnN0YW50KCdiJyk7XHJcbiAgICAgKiB9XHJcbiAgICAgKlxyXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gXy5jb25zdGFudCgnYycpO1xyXG4gICAgICpcclxuICAgICAqIF8uZnVuY3Rpb25zSW4obmV3IEZvbyk7XHJcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ11cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25zSW4ob2JqZWN0KSB7XHJcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZUZ1bmN0aW9ucyhvYmplY3QsIGtleXNJbihvYmplY3QpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzXHJcbiAgICAgKiBgdW5kZWZpbmVkYCwgdGhlIGBkZWZhdWx0VmFsdWVgIGlzIHJldHVybmVkIGluIGl0cyBwbGFjZS5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDMuNy4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxyXG4gICAgICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cclxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcclxuICAgICAqXHJcbiAgICAgKiBfLmdldChvYmplY3QsICdhWzBdLmIuYycpO1xyXG4gICAgICogLy8gPT4gM1xyXG4gICAgICpcclxuICAgICAqIF8uZ2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xyXG4gICAgICogLy8gPT4gM1xyXG4gICAgICpcclxuICAgICAqIF8uZ2V0KG9iamVjdCwgJ2EuYi5jJywgJ2RlZmF1bHQnKTtcclxuICAgICAqIC8vID0+ICdkZWZhdWx0J1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcclxuICAgICAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHBhdGgpO1xyXG4gICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IHByb3BlcnR5IG9mIGBvYmplY3RgLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBzaW5jZSAwLjEuMFxyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cclxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiB7ICdiJzogMiB9IH07XHJcbiAgICAgKiB2YXIgb3RoZXIgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XHJcbiAgICAgKlxyXG4gICAgICogXy5oYXMob2JqZWN0LCAnYScpO1xyXG4gICAgICogLy8gPT4gdHJ1ZVxyXG4gICAgICpcclxuICAgICAqIF8uaGFzKG9iamVjdCwgJ2EuYicpO1xyXG4gICAgICogLy8gPT4gdHJ1ZVxyXG4gICAgICpcclxuICAgICAqIF8uaGFzKG9iamVjdCwgWydhJywgJ2InXSk7XHJcbiAgICAgKiAvLyA9PiB0cnVlXHJcbiAgICAgKlxyXG4gICAgICogXy5oYXMob3RoZXIsICdhJyk7XHJcbiAgICAgKiAvLyA9PiBmYWxzZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBoYXMob2JqZWN0LCBwYXRoKSB7XHJcbiAgICAgIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDQuMC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XHJcbiAgICAgKlxyXG4gICAgICogXy5oYXNJbihvYmplY3QsICdhJyk7XHJcbiAgICAgKiAvLyA9PiB0cnVlXHJcbiAgICAgKlxyXG4gICAgICogXy5oYXNJbihvYmplY3QsICdhLmInKTtcclxuICAgICAqIC8vID0+IHRydWVcclxuICAgICAqXHJcbiAgICAgKiBfLmhhc0luKG9iamVjdCwgWydhJywgJ2InXSk7XHJcbiAgICAgKiAvLyA9PiB0cnVlXHJcbiAgICAgKlxyXG4gICAgICogXy5oYXNJbihvYmplY3QsICdiJyk7XHJcbiAgICAgKiAvLyA9PiBmYWxzZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBoYXNJbihvYmplY3QsIHBhdGgpIHtcclxuICAgICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIGludmVydGVkIGtleXMgYW5kIHZhbHVlcyBvZiBgb2JqZWN0YC5cclxuICAgICAqIElmIGBvYmplY3RgIGNvbnRhaW5zIGR1cGxpY2F0ZSB2YWx1ZXMsIHN1YnNlcXVlbnQgdmFsdWVzIG92ZXJ3cml0ZVxyXG4gICAgICogcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgdmFsdWVzLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgMC43LjBcclxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnZlcnQuXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgaW52ZXJ0ZWQgb2JqZWN0LlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAxIH07XHJcbiAgICAgKlxyXG4gICAgICogXy5pbnZlcnQob2JqZWN0KTtcclxuICAgICAqIC8vID0+IHsgJzEnOiAnYycsICcyJzogJ2InIH1cclxuICAgICAqL1xyXG4gICAgdmFyIGludmVydCA9IGNyZWF0ZUludmVydGVyKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xyXG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJlxyXG4gICAgICAgICAgdHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9ICdmdW5jdGlvbicpIHtcclxuICAgICAgICB2YWx1ZSA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXN1bHRbdmFsdWVdID0ga2V5O1xyXG4gICAgfSwgY29uc3RhbnQoaWRlbnRpdHkpKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW52ZXJ0YCBleGNlcHQgdGhhdCB0aGUgaW52ZXJ0ZWQgb2JqZWN0IGlzIGdlbmVyYXRlZFxyXG4gICAgICogZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nIGVhY2ggZWxlbWVudCBvZiBgb2JqZWN0YCB0aHJ1IGBpdGVyYXRlZWAuIFRoZVxyXG4gICAgICogY29ycmVzcG9uZGluZyBpbnZlcnRlZCB2YWx1ZSBvZiBlYWNoIGludmVydGVkIGtleSBpcyBhbiBhcnJheSBvZiBrZXlzXHJcbiAgICAgKiByZXNwb25zaWJsZSBmb3IgZ2VuZXJhdGluZyB0aGUgaW52ZXJ0ZWQgdmFsdWUuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkXHJcbiAgICAgKiB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDQuMS4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW52ZXJ0LlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxyXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGludmVydGVkIG9iamVjdC5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9O1xyXG4gICAgICpcclxuICAgICAqIF8uaW52ZXJ0Qnkob2JqZWN0KTtcclxuICAgICAqIC8vID0+IHsgJzEnOiBbJ2EnLCAnYyddLCAnMic6IFsnYiddIH1cclxuICAgICAqXHJcbiAgICAgKiBfLmludmVydEJ5KG9iamVjdCwgZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAqICAgcmV0dXJuICdncm91cCcgKyB2YWx1ZTtcclxuICAgICAqIH0pO1xyXG4gICAgICogLy8gPT4geyAnZ3JvdXAxJzogWydhJywgJ2MnXSwgJ2dyb3VwMic6IFsnYiddIH1cclxuICAgICAqL1xyXG4gICAgdmFyIGludmVydEJ5ID0gY3JlYXRlSW52ZXJ0ZXIoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XHJcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmXHJcbiAgICAgICAgICB0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHZhbHVlID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwgdmFsdWUpKSB7XHJcbiAgICAgICAgcmVzdWx0W3ZhbHVlXS5wdXNoKGtleSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmVzdWx0W3ZhbHVlXSA9IFtrZXldO1xyXG4gICAgICB9XHJcbiAgICB9LCBnZXRJdGVyYXRlZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnZva2VzIHRoZSBtZXRob2QgYXQgYHBhdGhgIG9mIGBvYmplY3RgLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgNC4wLjBcclxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cclxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlLlxyXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxyXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiB0aGUgaW52b2tlZCBtZXRob2QuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogWzEsIDIsIDMsIDRdIH0gfV0gfTtcclxuICAgICAqXHJcbiAgICAgKiBfLmludm9rZShvYmplY3QsICdhWzBdLmIuYy5zbGljZScsIDEsIDMpO1xyXG4gICAgICogLy8gPT4gWzIsIDNdXHJcbiAgICAgKi9cclxuICAgIHZhciBpbnZva2UgPSBiYXNlUmVzdChiYXNlSW52b2tlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxyXG4gICAgICpcclxuICAgICAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXHJcbiAgICAgKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXHJcbiAgICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBzaW5jZSAwLjEuMFxyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cclxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcclxuICAgICAqICAgdGhpcy5hID0gMTtcclxuICAgICAqICAgdGhpcy5iID0gMjtcclxuICAgICAqIH1cclxuICAgICAqXHJcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xyXG4gICAgICpcclxuICAgICAqIF8ua2V5cyhuZXcgRm9vKTtcclxuICAgICAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcclxuICAgICAqXHJcbiAgICAgKiBfLmtleXMoJ2hpJyk7XHJcbiAgICAgKiAvLyA9PiBbJzAnLCAnMSddXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XHJcbiAgICAgIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXHJcbiAgICAgKlxyXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAzLjAuMFxyXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xyXG4gICAgICogICB0aGlzLmEgPSAxO1xyXG4gICAgICogICB0aGlzLmIgPSAyO1xyXG4gICAgICogfVxyXG4gICAgICpcclxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XHJcbiAgICAgKlxyXG4gICAgICogXy5rZXlzSW4obmV3IEZvbyk7XHJcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xyXG4gICAgICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0LCB0cnVlKSA6IGJhc2VLZXlzSW4ob2JqZWN0KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5tYXBWYWx1ZXNgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGFuIG9iamVjdCB3aXRoIHRoZVxyXG4gICAgICogc2FtZSB2YWx1ZXMgYXMgYG9iamVjdGAgYW5kIGtleXMgZ2VuZXJhdGVkIGJ5IHJ1bm5pbmcgZWFjaCBvd24gZW51bWVyYWJsZVxyXG4gICAgICogc3RyaW5nIGtleWVkIHByb3BlcnR5IG9mIGBvYmplY3RgIHRocnUgYGl0ZXJhdGVlYC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWRcclxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGtleSwgb2JqZWN0KS5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDMuOC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIG9iamVjdC5cclxuICAgICAqIEBzZWUgXy5tYXBWYWx1ZXNcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogXy5tYXBLZXlzKHsgJ2EnOiAxLCAnYic6IDIgfSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xyXG4gICAgICogICByZXR1cm4ga2V5ICsgdmFsdWU7XHJcbiAgICAgKiB9KTtcclxuICAgICAqIC8vID0+IHsgJ2ExJzogMSwgJ2IyJzogMiB9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG1hcEtleXMob2JqZWN0LCBpdGVyYXRlZSkge1xyXG4gICAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICAgIGl0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpO1xyXG5cclxuICAgICAgYmFzZUZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xyXG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGl0ZXJhdGVlKHZhbHVlLCBrZXksIG9iamVjdCksIHZhbHVlKTtcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIGtleXMgYXMgYG9iamVjdGAgYW5kIHZhbHVlcyBnZW5lcmF0ZWRcclxuICAgICAqIGJ5IHJ1bm5pbmcgZWFjaCBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAgdGhydVxyXG4gICAgICogYGl0ZXJhdGVlYC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XHJcbiAgICAgKiAodmFsdWUsIGtleSwgb2JqZWN0KS5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDIuNC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIG9iamVjdC5cclxuICAgICAqIEBzZWUgXy5tYXBLZXlzXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIHZhciB1c2VycyA9IHtcclxuICAgICAqICAgJ2ZyZWQnOiAgICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAgfSxcclxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSB9XHJcbiAgICAgKiB9O1xyXG4gICAgICpcclxuICAgICAqIF8ubWFwVmFsdWVzKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZTsgfSk7XHJcbiAgICAgKiAvLyA9PiB7ICdmcmVkJzogNDAsICdwZWJibGVzJzogMSB9IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXHJcbiAgICAgKlxyXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXHJcbiAgICAgKiBfLm1hcFZhbHVlcyh1c2VycywgJ2FnZScpO1xyXG4gICAgICogLy8gPT4geyAnZnJlZCc6IDQwLCAncGViYmxlcyc6IDEgfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBtYXBWYWx1ZXMob2JqZWN0LCBpdGVyYXRlZSkge1xyXG4gICAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICAgIGl0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpO1xyXG5cclxuICAgICAgYmFzZUZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xyXG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgaXRlcmF0ZWUodmFsdWUsIGtleSwgb2JqZWN0KSk7XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25gIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IG1lcmdlcyBvd24gYW5kXHJcbiAgICAgKiBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0cyBpbnRvIHRoZVxyXG4gICAgICogZGVzdGluYXRpb24gb2JqZWN0LiBTb3VyY2UgcHJvcGVydGllcyB0aGF0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAgYXJlXHJcbiAgICAgKiBza2lwcGVkIGlmIGEgZGVzdGluYXRpb24gdmFsdWUgZXhpc3RzLiBBcnJheSBhbmQgcGxhaW4gb2JqZWN0IHByb3BlcnRpZXNcclxuICAgICAqIGFyZSBtZXJnZWQgcmVjdXJzaXZlbHkuIE90aGVyIG9iamVjdHMgYW5kIHZhbHVlIHR5cGVzIGFyZSBvdmVycmlkZGVuIGJ5XHJcbiAgICAgKiBhc3NpZ25tZW50LiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuIFN1YnNlcXVlbnRcclxuICAgICAqIHNvdXJjZXMgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHNvdXJjZXMuXHJcbiAgICAgKlxyXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAwLjUuMFxyXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiB2YXIgb2JqZWN0ID0ge1xyXG4gICAgICogICAnYSc6IFt7ICdiJzogMiB9LCB7ICdkJzogNCB9XVxyXG4gICAgICogfTtcclxuICAgICAqXHJcbiAgICAgKiB2YXIgb3RoZXIgPSB7XHJcbiAgICAgKiAgICdhJzogW3sgJ2MnOiAzIH0sIHsgJ2UnOiA1IH1dXHJcbiAgICAgKiB9O1xyXG4gICAgICpcclxuICAgICAqIF8ubWVyZ2Uob2JqZWN0LCBvdGhlcik7XHJcbiAgICAgKiAvLyA9PiB7ICdhJzogW3sgJ2InOiAyLCAnYyc6IDMgfSwgeyAnZCc6IDQsICdlJzogNSB9XSB9XHJcbiAgICAgKi9cclxuICAgIHZhciBtZXJnZSA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCkge1xyXG4gICAgICBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5tZXJnZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2hcclxuICAgICAqIGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgbWVyZ2VkIHZhbHVlcyBvZiB0aGUgZGVzdGluYXRpb24gYW5kIHNvdXJjZVxyXG4gICAgICogcHJvcGVydGllcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGAsIG1lcmdpbmcgaXMgaGFuZGxlZCBieSB0aGVcclxuICAgICAqIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWQgd2l0aCBzaXggYXJndW1lbnRzOlxyXG4gICAgICogKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spLlxyXG4gICAgICpcclxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgNC4wLjBcclxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzb3VyY2VzIFRoZSBzb3VyY2Ugb2JqZWN0cy5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSkge1xyXG4gICAgICogICBpZiAoXy5pc0FycmF5KG9ialZhbHVlKSkge1xyXG4gICAgICogICAgIHJldHVybiBvYmpWYWx1ZS5jb25jYXQoc3JjVmFsdWUpO1xyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKlxyXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbMV0sICdiJzogWzJdIH07XHJcbiAgICAgKiB2YXIgb3RoZXIgPSB7ICdhJzogWzNdLCAnYic6IFs0XSB9O1xyXG4gICAgICpcclxuICAgICAqIF8ubWVyZ2VXaXRoKG9iamVjdCwgb3RoZXIsIGN1c3RvbWl6ZXIpO1xyXG4gICAgICogLy8gPT4geyAnYSc6IFsxLCAzXSwgJ2InOiBbMiwgNF0gfVxyXG4gICAgICovXHJcbiAgICB2YXIgbWVyZ2VXaXRoID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKSB7XHJcbiAgICAgIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ucGlja2A7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZVxyXG4gICAgICogb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBwYXRocyBvZiBgb2JqZWN0YCB0aGF0IGFyZSBub3Qgb21pdHRlZC5cclxuICAgICAqXHJcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgY29uc2lkZXJhYmx5IHNsb3dlciB0aGFuIGBfLnBpY2tgLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBzaW5jZSAwLjEuMFxyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBvbWl0LlxyXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XHJcbiAgICAgKlxyXG4gICAgICogXy5vbWl0KG9iamVjdCwgWydhJywgJ2MnXSk7XHJcbiAgICAgKiAvLyA9PiB7ICdiJzogJzInIH1cclxuICAgICAqL1xyXG4gICAgdmFyIG9taXQgPSBmbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIHBhdGhzKSB7XHJcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfVxyXG4gICAgICB2YXIgaXNEZWVwID0gZmFsc2U7XHJcbiAgICAgIHBhdGhzID0gYXJyYXlNYXAocGF0aHMsIGZ1bmN0aW9uKHBhdGgpIHtcclxuICAgICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcclxuICAgICAgICBpc0RlZXAgfHwgKGlzRGVlcCA9IHBhdGgubGVuZ3RoID4gMSk7XHJcbiAgICAgICAgcmV0dXJuIHBhdGg7XHJcbiAgICAgIH0pO1xyXG4gICAgICBjb3B5T2JqZWN0KG9iamVjdCwgZ2V0QWxsS2V5c0luKG9iamVjdCksIHJlc3VsdCk7XHJcbiAgICAgIGlmIChpc0RlZXApIHtcclxuICAgICAgICByZXN1bHQgPSBiYXNlQ2xvbmUocmVzdWx0LCBDTE9ORV9ERUVQX0ZMQUcgfCBDTE9ORV9GTEFUX0ZMQUcgfCBDTE9ORV9TWU1CT0xTX0ZMQUcsIGN1c3RvbU9taXRDbG9uZSk7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGxlbmd0aCA9IHBhdGhzLmxlbmd0aDtcclxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XHJcbiAgICAgICAgYmFzZVVuc2V0KHJlc3VsdCwgcGF0aHNbbGVuZ3RoXSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLnBpY2tCeWA7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mXHJcbiAgICAgKiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBgb2JqZWN0YCB0aGF0XHJcbiAgICAgKiBgcHJlZGljYXRlYCBkb2Vzbid0IHJldHVybiB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0d29cclxuICAgICAqIGFyZ3VtZW50czogKHZhbHVlLCBrZXkpLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgNC4wLjBcclxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBwcm9wZXJ0eS5cclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xyXG4gICAgICpcclxuICAgICAqIF8ub21pdEJ5KG9iamVjdCwgXy5pc051bWJlcik7XHJcbiAgICAgKiAvLyA9PiB7ICdiJzogJzInIH1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gb21pdEJ5KG9iamVjdCwgcHJlZGljYXRlKSB7XHJcbiAgICAgIHJldHVybiBwaWNrQnkob2JqZWN0LCBuZWdhdGUoZ2V0SXRlcmF0ZWUocHJlZGljYXRlKSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIHBpY2tlZCBgb2JqZWN0YCBwcm9wZXJ0aWVzLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBzaW5jZSAwLjEuMFxyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxyXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XHJcbiAgICAgKlxyXG4gICAgICogXy5waWNrKG9iamVjdCwgWydhJywgJ2MnXSk7XHJcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cclxuICAgICAqL1xyXG4gICAgdmFyIHBpY2sgPSBmbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIHBhdGhzKSB7XHJcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHt9IDogYmFzZVBpY2sob2JqZWN0LCBwYXRocyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBgb2JqZWN0YCBwcm9wZXJ0aWVzIGBwcmVkaWNhdGVgIHJldHVybnNcclxuICAgICAqIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM6ICh2YWx1ZSwga2V5KS5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDQuMC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgcHJvcGVydHkuXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcclxuICAgICAqXHJcbiAgICAgKiBfLnBpY2tCeShvYmplY3QsIF8uaXNOdW1iZXIpO1xyXG4gICAgICogLy8gPT4geyAnYSc6IDEsICdjJzogMyB9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHBpY2tCeShvYmplY3QsIHByZWRpY2F0ZSkge1xyXG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4ge307XHJcbiAgICAgIH1cclxuICAgICAgdmFyIHByb3BzID0gYXJyYXlNYXAoZ2V0QWxsS2V5c0luKG9iamVjdCksIGZ1bmN0aW9uKHByb3ApIHtcclxuICAgICAgICByZXR1cm4gW3Byb3BdO1xyXG4gICAgICB9KTtcclxuICAgICAgcHJlZGljYXRlID0gZ2V0SXRlcmF0ZWUocHJlZGljYXRlKTtcclxuICAgICAgcmV0dXJuIGJhc2VQaWNrQnkob2JqZWN0LCBwcm9wcywgZnVuY3Rpb24odmFsdWUsIHBhdGgpIHtcclxuICAgICAgICByZXR1cm4gcHJlZGljYXRlKHZhbHVlLCBwYXRoWzBdKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmdldGAgZXhjZXB0IHRoYXQgaWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzIGFcclxuICAgICAqIGZ1bmN0aW9uIGl0J3MgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBpdHMgcGFyZW50IG9iamVjdCBhbmRcclxuICAgICAqIGl0cyByZXN1bHQgaXMgcmV0dXJuZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHNpbmNlIDAuMS4wXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxyXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHJlc29sdmUuXHJcbiAgICAgKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxyXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYzEnOiAzLCAnYzInOiBfLmNvbnN0YW50KDQpIH0gfV0gfTtcclxuICAgICAqXHJcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdhWzBdLmIuYzEnKTtcclxuICAgICAqIC8vID0+IDNcclxuICAgICAqXHJcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdhWzBdLmIuYzInKTtcclxuICAgICAqIC8vID0+IDRcclxuICAgICAqXHJcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdhWzBdLmIuYzMnLCAnZGVmYXVsdCcpO1xyXG4gICAgICogLy8gPT4gJ2RlZmF1bHQnXHJcbiAgICAgKlxyXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnYVswXS5iLmMzJywgXy5jb25zdGFudCgnZGVmYXVsdCcpKTtcclxuICAgICAqIC8vID0+ICdkZWZhdWx0J1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiByZXN1bHQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcclxuICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XHJcblxyXG4gICAgICB2YXIgaW5kZXggPSAtMSxcclxuICAgICAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xyXG5cclxuICAgICAgLy8gRW5zdXJlIHRoZSBsb29wIGlzIGVudGVyZWQgd2hlbiBwYXRoIGlzIGVtcHR5LlxyXG4gICAgICBpZiAoIWxlbmd0aCkge1xyXG4gICAgICAgIGxlbmd0aCA9IDE7XHJcbiAgICAgICAgb2JqZWN0ID0gdW5kZWZpbmVkO1xyXG4gICAgICB9XHJcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3RbdG9LZXkocGF0aFtpbmRleF0pXTtcclxuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgaW5kZXggPSBsZW5ndGg7XHJcbiAgICAgICAgICB2YWx1ZSA9IGRlZmF1bHRWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgb2JqZWN0ID0gaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZS5jYWxsKG9iamVjdCkgOiB2YWx1ZTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gb2JqZWN0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiBhIHBvcnRpb24gb2YgYHBhdGhgIGRvZXNuJ3QgZXhpc3QsXHJcbiAgICAgKiBpdCdzIGNyZWF0ZWQuIEFycmF5cyBhcmUgY3JlYXRlZCBmb3IgbWlzc2luZyBpbmRleCBwcm9wZXJ0aWVzIHdoaWxlIG9iamVjdHNcclxuICAgICAqIGFyZSBjcmVhdGVkIGZvciBhbGwgb3RoZXIgbWlzc2luZyBwcm9wZXJ0aWVzLiBVc2UgYF8uc2V0V2l0aGAgdG8gY3VzdG9taXplXHJcbiAgICAgKiBgcGF0aGAgY3JlYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAzLjcuMFxyXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cclxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xyXG4gICAgICpcclxuICAgICAqIF8uc2V0KG9iamVjdCwgJ2FbMF0uYi5jJywgNCk7XHJcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QuYVswXS5iLmMpO1xyXG4gICAgICogLy8gPT4gNFxyXG4gICAgICpcclxuICAgICAqIF8uc2V0KG9iamVjdCwgWyd4JywgJzAnLCAneScsICd6J10sIDUpO1xyXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0LnhbMF0ueS56KTtcclxuICAgICAqIC8vID0+IDVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gc2V0KG9iamVjdCwgcGF0aCwgdmFsdWUpIHtcclxuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc2V0YCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaCBpc1xyXG4gICAgICogaW52b2tlZCB0byBwcm9kdWNlIHRoZSBvYmplY3RzIG9mIGBwYXRoYC4gIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgXHJcbiAgICAgKiBwYXRoIGNyZWF0aW9uIGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWRcclxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAobnNWYWx1ZSwga2V5LCBuc09iamVjdCkuXHJcbiAgICAgKlxyXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSA0LjAuMFxyXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cclxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiB2YXIgb2JqZWN0ID0ge307XHJcbiAgICAgKlxyXG4gICAgICogXy5zZXRXaXRoKG9iamVjdCwgJ1swXVsxXScsICdhJywgT2JqZWN0KTtcclxuICAgICAqIC8vID0+IHsgJzAnOiB7ICcxJzogJ2EnIH0gfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBzZXRXaXRoKG9iamVjdCwgcGF0aCwgdmFsdWUsIGN1c3RvbWl6ZXIpIHtcclxuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkO1xyXG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUsIGN1c3RvbWl6ZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQtdmFsdWUgcGFpcnMgZm9yIGBvYmplY3RgXHJcbiAgICAgKiB3aGljaCBjYW4gYmUgY29uc3VtZWQgYnkgYF8uZnJvbVBhaXJzYC4gSWYgYG9iamVjdGAgaXMgYSBtYXAgb3Igc2V0LCBpdHNcclxuICAgICAqIGVudHJpZXMgYXJlIHJldHVybmVkLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgNC4wLjBcclxuICAgICAqIEBhbGlhcyBlbnRyaWVzXHJcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xyXG4gICAgICogICB0aGlzLmEgPSAxO1xyXG4gICAgICogICB0aGlzLmIgPSAyO1xyXG4gICAgICogfVxyXG4gICAgICpcclxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XHJcbiAgICAgKlxyXG4gICAgICogXy50b1BhaXJzKG5ldyBGb28pO1xyXG4gICAgICogLy8gPT4gW1snYScsIDFdLCBbJ2InLCAyXV0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcclxuICAgICAqL1xyXG4gICAgdmFyIHRvUGFpcnMgPSBjcmVhdGVUb1BhaXJzKGtleXMpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZC12YWx1ZSBwYWlyc1xyXG4gICAgICogZm9yIGBvYmplY3RgIHdoaWNoIGNhbiBiZSBjb25zdW1lZCBieSBgXy5mcm9tUGFpcnNgLiBJZiBgb2JqZWN0YCBpcyBhIG1hcFxyXG4gICAgICogb3Igc2V0LCBpdHMgZW50cmllcyBhcmUgcmV0dXJuZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSA0LjAuMFxyXG4gICAgICogQGFsaWFzIGVudHJpZXNJblxyXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcclxuICAgICAqICAgdGhpcy5hID0gMTtcclxuICAgICAqICAgdGhpcy5iID0gMjtcclxuICAgICAqIH1cclxuICAgICAqXHJcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xyXG4gICAgICpcclxuICAgICAqIF8udG9QYWlyc0luKG5ldyBGb28pO1xyXG4gICAgICogLy8gPT4gW1snYScsIDFdLCBbJ2InLCAyXSwgWydjJywgM11dIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXHJcbiAgICAgKi9cclxuICAgIHZhciB0b1BhaXJzSW4gPSBjcmVhdGVUb1BhaXJzKGtleXNJbik7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhbHRlcm5hdGl2ZSB0byBgXy5yZWR1Y2VgOyB0aGlzIG1ldGhvZCB0cmFuc2Zvcm1zIGBvYmplY3RgIHRvIGEgbmV3XHJcbiAgICAgKiBgYWNjdW11bGF0b3JgIG9iamVjdCB3aGljaCBpcyB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgZWFjaCBvZiBpdHMgb3duXHJcbiAgICAgKiBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIHRocnUgYGl0ZXJhdGVlYCwgd2l0aCBlYWNoIGludm9jYXRpb25cclxuICAgICAqIHBvdGVudGlhbGx5IG11dGF0aW5nIHRoZSBgYWNjdW11bGF0b3JgIG9iamVjdC4gSWYgYGFjY3VtdWxhdG9yYCBpcyBub3RcclxuICAgICAqIHByb3ZpZGVkLCBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgc2FtZSBgW1tQcm90b3R5cGVdXWAgd2lsbCBiZSB1c2VkLiBUaGVcclxuICAgICAqIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czogKGFjY3VtdWxhdG9yLCB2YWx1ZSwga2V5LCBvYmplY3QpLlxyXG4gICAgICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgMS4zLjBcclxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cclxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgY3VzdG9tIGFjY3VtdWxhdG9yIHZhbHVlLlxyXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLnRyYW5zZm9ybShbMiwgMywgNF0sIGZ1bmN0aW9uKHJlc3VsdCwgbikge1xyXG4gICAgICogICByZXN1bHQucHVzaChuICo9IG4pO1xyXG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMDtcclxuICAgICAqIH0sIFtdKTtcclxuICAgICAqIC8vID0+IFs0LCA5XVxyXG4gICAgICpcclxuICAgICAqIF8udHJhbnNmb3JtKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9LCBmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcclxuICAgICAqICAgKHJlc3VsdFt2YWx1ZV0gfHwgKHJlc3VsdFt2YWx1ZV0gPSBbXSkpLnB1c2goa2V5KTtcclxuICAgICAqIH0sIHt9KTtcclxuICAgICAqIC8vID0+IHsgJzEnOiBbJ2EnLCAnYyddLCAnMic6IFsnYiddIH1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtKG9iamVjdCwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XHJcbiAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcclxuICAgICAgICAgIGlzQXJyTGlrZSA9IGlzQXJyIHx8IGlzQnVmZmVyKG9iamVjdCkgfHwgaXNUeXBlZEFycmF5KG9iamVjdCk7XHJcblxyXG4gICAgICBpdGVyYXRlZSA9IGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCA0KTtcclxuICAgICAgaWYgKGFjY3VtdWxhdG9yID09IG51bGwpIHtcclxuICAgICAgICB2YXIgQ3RvciA9IG9iamVjdCAmJiBvYmplY3QuY29uc3RydWN0b3I7XHJcbiAgICAgICAgaWYgKGlzQXJyTGlrZSkge1xyXG4gICAgICAgICAgYWNjdW11bGF0b3IgPSBpc0FyciA/IG5ldyBDdG9yIDogW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KG9iamVjdCkpIHtcclxuICAgICAgICAgIGFjY3VtdWxhdG9yID0gaXNGdW5jdGlvbihDdG9yKSA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpIDoge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgYWNjdW11bGF0b3IgPSB7fTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgKGlzQXJyTGlrZSA/IGFycmF5RWFjaCA6IGJhc2VGb3JPd24pKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBvYmplY3QpIHtcclxuICAgICAgICByZXR1cm4gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgb2JqZWN0KTtcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgdGhlIHByb3BlcnR5IGF0IGBwYXRoYCBvZiBgb2JqZWN0YC5cclxuICAgICAqXHJcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDQuMC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxyXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHVuc2V0LlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBwcm9wZXJ0eSBpcyBkZWxldGVkLCBlbHNlIGBmYWxzZWAuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogNyB9IH1dIH07XHJcbiAgICAgKiBfLnVuc2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XHJcbiAgICAgKiAvLyA9PiB0cnVlXHJcbiAgICAgKlxyXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0KTtcclxuICAgICAqIC8vID0+IHsgJ2EnOiBbeyAnYic6IHt9IH1dIH07XHJcbiAgICAgKlxyXG4gICAgICogXy51bnNldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcclxuICAgICAqIC8vID0+IHRydWVcclxuICAgICAqXHJcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QpO1xyXG4gICAgICogLy8gPT4geyAnYSc6IFt7ICdiJzoge30gfV0gfTtcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdW5zZXQob2JqZWN0LCBwYXRoKSB7XHJcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHRydWUgOiBiYXNlVW5zZXQob2JqZWN0LCBwYXRoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc2V0YCBleGNlcHQgdGhhdCBhY2NlcHRzIGB1cGRhdGVyYCB0byBwcm9kdWNlIHRoZVxyXG4gICAgICogdmFsdWUgdG8gc2V0LiBVc2UgYF8udXBkYXRlV2l0aGAgdG8gY3VzdG9taXplIGBwYXRoYCBjcmVhdGlvbi4gVGhlIGB1cGRhdGVyYFxyXG4gICAgICogaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cclxuICAgICAqXHJcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDQuNi4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxyXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZXIgVGhlIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdGhlIHVwZGF0ZWQgdmFsdWUuXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xyXG4gICAgICpcclxuICAgICAqIF8udXBkYXRlKG9iamVjdCwgJ2FbMF0uYi5jJywgZnVuY3Rpb24obikgeyByZXR1cm4gbiAqIG47IH0pO1xyXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0LmFbMF0uYi5jKTtcclxuICAgICAqIC8vID0+IDlcclxuICAgICAqXHJcbiAgICAgKiBfLnVwZGF0ZShvYmplY3QsICd4WzBdLnkueicsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gPyBuICsgMSA6IDA7IH0pO1xyXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0LnhbMF0ueS56KTtcclxuICAgICAqIC8vID0+IDBcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdXBkYXRlKG9iamVjdCwgcGF0aCwgdXBkYXRlcikge1xyXG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBiYXNlVXBkYXRlKG9iamVjdCwgcGF0aCwgY2FzdEZ1bmN0aW9uKHVwZGF0ZXIpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udXBkYXRlYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaCBpc1xyXG4gICAgICogaW52b2tlZCB0byBwcm9kdWNlIHRoZSBvYmplY3RzIG9mIGBwYXRoYC4gIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgXHJcbiAgICAgKiBwYXRoIGNyZWF0aW9uIGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWRcclxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAobnNWYWx1ZSwga2V5LCBuc09iamVjdCkuXHJcbiAgICAgKlxyXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSA0LjYuMFxyXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cclxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGVyIFRoZSBmdW5jdGlvbiB0byBwcm9kdWNlIHRoZSB1cGRhdGVkIHZhbHVlLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxyXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogdmFyIG9iamVjdCA9IHt9O1xyXG4gICAgICpcclxuICAgICAqIF8udXBkYXRlV2l0aChvYmplY3QsICdbMF1bMV0nLCBfLmNvbnN0YW50KCdhJyksIE9iamVjdCk7XHJcbiAgICAgKiAvLyA9PiB7ICcwJzogeyAnMSc6ICdhJyB9IH1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdXBkYXRlV2l0aChvYmplY3QsIHBhdGgsIHVwZGF0ZXIsIGN1c3RvbWl6ZXIpIHtcclxuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkO1xyXG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBiYXNlVXBkYXRlKG9iamVjdCwgcGF0aCwgY2FzdEZ1bmN0aW9uKHVwZGF0ZXIpLCBjdXN0b21pemVyKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0eSB2YWx1ZXMgb2YgYG9iamVjdGAuXHJcbiAgICAgKlxyXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHNpbmNlIDAuMS4wXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcclxuICAgICAqICAgdGhpcy5hID0gMTtcclxuICAgICAqICAgdGhpcy5iID0gMjtcclxuICAgICAqIH1cclxuICAgICAqXHJcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xyXG4gICAgICpcclxuICAgICAqIF8udmFsdWVzKG5ldyBGb28pO1xyXG4gICAgICogLy8gPT4gWzEsIDJdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXHJcbiAgICAgKlxyXG4gICAgICogXy52YWx1ZXMoJ2hpJyk7XHJcbiAgICAgKiAvLyA9PiBbJ2gnLCAnaSddXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHZhbHVlcyhvYmplY3QpIHtcclxuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlVmFsdWVzKG9iamVjdCwga2V5cyhvYmplY3QpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnR5XHJcbiAgICAgKiB2YWx1ZXMgb2YgYG9iamVjdGAuXHJcbiAgICAgKlxyXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAzLjAuMFxyXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcclxuICAgICAqICAgdGhpcy5hID0gMTtcclxuICAgICAqICAgdGhpcy5iID0gMjtcclxuICAgICAqIH1cclxuICAgICAqXHJcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xyXG4gICAgICpcclxuICAgICAqIF8udmFsdWVzSW4obmV3IEZvbyk7XHJcbiAgICAgKiAvLyA9PiBbMSwgMiwgM10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdmFsdWVzSW4ob2JqZWN0KSB7XHJcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZVZhbHVlcyhvYmplY3QsIGtleXNJbihvYmplY3QpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGFtcHMgYG51bWJlcmAgd2l0aGluIHRoZSBpbmNsdXNpdmUgYGxvd2VyYCBhbmQgYHVwcGVyYCBib3VuZHMuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSA0LjAuMFxyXG4gICAgICogQGNhdGVnb3J5IE51bWJlclxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIGNsYW1wLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsb3dlcl0gVGhlIGxvd2VyIGJvdW5kLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHVwcGVyIFRoZSB1cHBlciBib3VuZC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNsYW1wZWQgbnVtYmVyLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLmNsYW1wKC0xMCwgLTUsIDUpO1xyXG4gICAgICogLy8gPT4gLTVcclxuICAgICAqXHJcbiAgICAgKiBfLmNsYW1wKDEwLCAtNSwgNSk7XHJcbiAgICAgKiAvLyA9PiA1XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNsYW1wKG51bWJlciwgbG93ZXIsIHVwcGVyKSB7XHJcbiAgICAgIGlmICh1cHBlciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdXBwZXIgPSBsb3dlcjtcclxuICAgICAgICBsb3dlciA9IHVuZGVmaW5lZDtcclxuICAgICAgfVxyXG4gICAgICBpZiAodXBwZXIgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHVwcGVyID0gdG9OdW1iZXIodXBwZXIpO1xyXG4gICAgICAgIHVwcGVyID0gdXBwZXIgPT09IHVwcGVyID8gdXBwZXIgOiAwO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChsb3dlciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgbG93ZXIgPSB0b051bWJlcihsb3dlcik7XHJcbiAgICAgICAgbG93ZXIgPSBsb3dlciA9PT0gbG93ZXIgPyBsb3dlciA6IDA7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGJhc2VDbGFtcCh0b051bWJlcihudW1iZXIpLCBsb3dlciwgdXBwZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIGBuYCBpcyBiZXR3ZWVuIGBzdGFydGAgYW5kIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZywgYGVuZGAuIElmXHJcbiAgICAgKiBgZW5kYCBpcyBub3Qgc3BlY2lmaWVkLCBpdCdzIHNldCB0byBgc3RhcnRgIHdpdGggYHN0YXJ0YCB0aGVuIHNldCB0byBgMGAuXHJcbiAgICAgKiBJZiBgc3RhcnRgIGlzIGdyZWF0ZXIgdGhhbiBgZW5kYCB0aGUgcGFyYW1zIGFyZSBzd2FwcGVkIHRvIHN1cHBvcnRcclxuICAgICAqIG5lZ2F0aXZlIHJhbmdlcy5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDMuMy4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgTnVtYmVyXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gY2hlY2suXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBudW1iZXJgIGlzIGluIHRoZSByYW5nZSwgZWxzZSBgZmFsc2VgLlxyXG4gICAgICogQHNlZSBfLnJhbmdlLCBfLnJhbmdlUmlnaHRcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogXy5pblJhbmdlKDMsIDIsIDQpO1xyXG4gICAgICogLy8gPT4gdHJ1ZVxyXG4gICAgICpcclxuICAgICAqIF8uaW5SYW5nZSg0LCA4KTtcclxuICAgICAqIC8vID0+IHRydWVcclxuICAgICAqXHJcbiAgICAgKiBfLmluUmFuZ2UoNCwgMik7XHJcbiAgICAgKiAvLyA9PiBmYWxzZVxyXG4gICAgICpcclxuICAgICAqIF8uaW5SYW5nZSgyLCAyKTtcclxuICAgICAqIC8vID0+IGZhbHNlXHJcbiAgICAgKlxyXG4gICAgICogXy5pblJhbmdlKDEuMiwgMik7XHJcbiAgICAgKiAvLyA9PiB0cnVlXHJcbiAgICAgKlxyXG4gICAgICogXy5pblJhbmdlKDUuMiwgNCk7XHJcbiAgICAgKiAvLyA9PiBmYWxzZVxyXG4gICAgICpcclxuICAgICAqIF8uaW5SYW5nZSgtMywgLTIsIC02KTtcclxuICAgICAqIC8vID0+IHRydWVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaW5SYW5nZShudW1iZXIsIHN0YXJ0LCBlbmQpIHtcclxuICAgICAgc3RhcnQgPSB0b0Zpbml0ZShzdGFydCk7XHJcbiAgICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGVuZCA9IHN0YXJ0O1xyXG4gICAgICAgIHN0YXJ0ID0gMDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBlbmQgPSB0b0Zpbml0ZShlbmQpO1xyXG4gICAgICB9XHJcbiAgICAgIG51bWJlciA9IHRvTnVtYmVyKG51bWJlcik7XHJcbiAgICAgIHJldHVybiBiYXNlSW5SYW5nZShudW1iZXIsIHN0YXJ0LCBlbmQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJvZHVjZXMgYSByYW5kb20gbnVtYmVyIGJldHdlZW4gdGhlIGluY2x1c2l2ZSBgbG93ZXJgIGFuZCBgdXBwZXJgIGJvdW5kcy5cclxuICAgICAqIElmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHByb3ZpZGVkIGEgbnVtYmVyIGJldHdlZW4gYDBgIGFuZCB0aGUgZ2l2ZW4gbnVtYmVyXHJcbiAgICAgKiBpcyByZXR1cm5lZC4gSWYgYGZsb2F0aW5nYCBpcyBgdHJ1ZWAsIG9yIGVpdGhlciBgbG93ZXJgIG9yIGB1cHBlcmAgYXJlXHJcbiAgICAgKiBmbG9hdHMsIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGlzIHJldHVybmVkIGluc3RlYWQgb2YgYW4gaW50ZWdlci5cclxuICAgICAqXHJcbiAgICAgKiAqKk5vdGU6KiogSmF2YVNjcmlwdCBmb2xsb3dzIHRoZSBJRUVFLTc1NCBzdGFuZGFyZCBmb3IgcmVzb2x2aW5nXHJcbiAgICAgKiBmbG9hdGluZy1wb2ludCB2YWx1ZXMgd2hpY2ggY2FuIHByb2R1Y2UgdW5leHBlY3RlZCByZXN1bHRzLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgMC43LjBcclxuICAgICAqIEBjYXRlZ29yeSBOdW1iZXJcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbG93ZXI9MF0gVGhlIGxvd2VyIGJvdW5kLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt1cHBlcj0xXSBUaGUgdXBwZXIgYm91bmQuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmbG9hdGluZ10gU3BlY2lmeSByZXR1cm5pbmcgYSBmbG9hdGluZy1wb2ludCBudW1iZXIuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByYW5kb20gbnVtYmVyLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLnJhbmRvbSgwLCA1KTtcclxuICAgICAqIC8vID0+IGFuIGludGVnZXIgYmV0d2VlbiAwIGFuZCA1XHJcbiAgICAgKlxyXG4gICAgICogXy5yYW5kb20oNSk7XHJcbiAgICAgKiAvLyA9PiBhbHNvIGFuIGludGVnZXIgYmV0d2VlbiAwIGFuZCA1XHJcbiAgICAgKlxyXG4gICAgICogXy5yYW5kb20oNSwgdHJ1ZSk7XHJcbiAgICAgKiAvLyA9PiBhIGZsb2F0aW5nLXBvaW50IG51bWJlciBiZXR3ZWVuIDAgYW5kIDVcclxuICAgICAqXHJcbiAgICAgKiBfLnJhbmRvbSgxLjIsIDUuMik7XHJcbiAgICAgKiAvLyA9PiBhIGZsb2F0aW5nLXBvaW50IG51bWJlciBiZXR3ZWVuIDEuMiBhbmQgNS4yXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHJhbmRvbShsb3dlciwgdXBwZXIsIGZsb2F0aW5nKSB7XHJcbiAgICAgIGlmIChmbG9hdGluZyAmJiB0eXBlb2YgZmxvYXRpbmcgIT0gJ2Jvb2xlYW4nICYmIGlzSXRlcmF0ZWVDYWxsKGxvd2VyLCB1cHBlciwgZmxvYXRpbmcpKSB7XHJcbiAgICAgICAgdXBwZXIgPSBmbG9hdGluZyA9IHVuZGVmaW5lZDtcclxuICAgICAgfVxyXG4gICAgICBpZiAoZmxvYXRpbmcgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdXBwZXIgPT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgICBmbG9hdGluZyA9IHVwcGVyO1xyXG4gICAgICAgICAgdXBwZXIgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBsb3dlciA9PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAgIGZsb2F0aW5nID0gbG93ZXI7XHJcbiAgICAgICAgICBsb3dlciA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGxvd2VyID09PSB1bmRlZmluZWQgJiYgdXBwZXIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGxvd2VyID0gMDtcclxuICAgICAgICB1cHBlciA9IDE7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgbG93ZXIgPSB0b0Zpbml0ZShsb3dlcik7XHJcbiAgICAgICAgaWYgKHVwcGVyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIHVwcGVyID0gbG93ZXI7XHJcbiAgICAgICAgICBsb3dlciA9IDA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHVwcGVyID0gdG9GaW5pdGUodXBwZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAobG93ZXIgPiB1cHBlcikge1xyXG4gICAgICAgIHZhciB0ZW1wID0gbG93ZXI7XHJcbiAgICAgICAgbG93ZXIgPSB1cHBlcjtcclxuICAgICAgICB1cHBlciA9IHRlbXA7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGZsb2F0aW5nIHx8IGxvd2VyICUgMSB8fCB1cHBlciAlIDEpIHtcclxuICAgICAgICB2YXIgcmFuZCA9IG5hdGl2ZVJhbmRvbSgpO1xyXG4gICAgICAgIHJldHVybiBuYXRpdmVNaW4obG93ZXIgKyAocmFuZCAqICh1cHBlciAtIGxvd2VyICsgZnJlZVBhcnNlRmxvYXQoJzFlLScgKyAoKHJhbmQgKyAnJykubGVuZ3RoIC0gMSkpKSksIHVwcGVyKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gYmFzZVJhbmRvbShsb3dlciwgdXBwZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIFtjYW1lbCBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DYW1lbENhc2UpLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgMy4wLjBcclxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjYW1lbCBjYXNlZCBzdHJpbmcuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8uY2FtZWxDYXNlKCdGb28gQmFyJyk7XHJcbiAgICAgKiAvLyA9PiAnZm9vQmFyJ1xyXG4gICAgICpcclxuICAgICAqIF8uY2FtZWxDYXNlKCctLWZvby1iYXItLScpO1xyXG4gICAgICogLy8gPT4gJ2Zvb0JhcidcclxuICAgICAqXHJcbiAgICAgKiBfLmNhbWVsQ2FzZSgnX19GT09fQkFSX18nKTtcclxuICAgICAqIC8vID0+ICdmb29CYXInXHJcbiAgICAgKi9cclxuICAgIHZhciBjYW1lbENhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcclxuICAgICAgd29yZCA9IHdvcmQudG9Mb3dlckNhc2UoKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/IGNhcGl0YWxpemUod29yZCkgOiB3b3JkKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBgc3RyaW5nYCB0byB1cHBlciBjYXNlIGFuZCB0aGUgcmVtYWluaW5nXHJcbiAgICAgKiB0byBsb3dlciBjYXNlLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgMy4wLjBcclxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNhcGl0YWxpemUuXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjYXBpdGFsaXplZCBzdHJpbmcuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8uY2FwaXRhbGl6ZSgnRlJFRCcpO1xyXG4gICAgICogLy8gPT4gJ0ZyZWQnXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyaW5nKSB7XHJcbiAgICAgIHJldHVybiB1cHBlckZpcnN0KHRvU3RyaW5nKHN0cmluZykudG9Mb3dlckNhc2UoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWJ1cnJzIGBzdHJpbmdgIGJ5IGNvbnZlcnRpbmdcclxuICAgICAqIFtMYXRpbi0xIFN1cHBsZW1lbnRdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhdGluLTFfU3VwcGxlbWVudF8oVW5pY29kZV9ibG9jaykjQ2hhcmFjdGVyX3RhYmxlKVxyXG4gICAgICogYW5kIFtMYXRpbiBFeHRlbmRlZC1BXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYXRpbl9FeHRlbmRlZC1BKVxyXG4gICAgICogbGV0dGVycyB0byBiYXNpYyBMYXRpbiBsZXR0ZXJzIGFuZCByZW1vdmluZ1xyXG4gICAgICogW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzKS5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDMuMC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBkZWJ1cnIuXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBkZWJ1cnJlZCBzdHJpbmcuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8uZGVidXJyKCdkw6lqw6AgdnUnKTtcclxuICAgICAqIC8vID0+ICdkZWphIHZ1J1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBkZWJ1cnIoc3RyaW5nKSB7XHJcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XHJcbiAgICAgIHJldHVybiBzdHJpbmcgJiYgc3RyaW5nLnJlcGxhY2UocmVMYXRpbiwgZGVidXJyTGV0dGVyKS5yZXBsYWNlKHJlQ29tYm9NYXJrLCAnJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgYHN0cmluZ2AgZW5kcyB3aXRoIHRoZSBnaXZlbiB0YXJnZXQgc3RyaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgMy4wLjBcclxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3RhcmdldF0gVGhlIHN0cmluZyB0byBzZWFyY2ggZm9yLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwb3NpdGlvbj1zdHJpbmcubGVuZ3RoXSBUaGUgcG9zaXRpb24gdG8gc2VhcmNoIHVwIHRvLlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBzdHJpbmdgIGVuZHMgd2l0aCBgdGFyZ2V0YCxcclxuICAgICAqICBlbHNlIGBmYWxzZWAuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8uZW5kc1dpdGgoJ2FiYycsICdjJyk7XHJcbiAgICAgKiAvLyA9PiB0cnVlXHJcbiAgICAgKlxyXG4gICAgICogXy5lbmRzV2l0aCgnYWJjJywgJ2InKTtcclxuICAgICAqIC8vID0+IGZhbHNlXHJcbiAgICAgKlxyXG4gICAgICogXy5lbmRzV2l0aCgnYWJjJywgJ2InLCAyKTtcclxuICAgICAqIC8vID0+IHRydWVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZW5kc1dpdGgoc3RyaW5nLCB0YXJnZXQsIHBvc2l0aW9uKSB7XHJcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XHJcbiAgICAgIHRhcmdldCA9IGJhc2VUb1N0cmluZyh0YXJnZXQpO1xyXG5cclxuICAgICAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XHJcbiAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24gPT09IHVuZGVmaW5lZFxyXG4gICAgICAgID8gbGVuZ3RoXHJcbiAgICAgICAgOiBiYXNlQ2xhbXAodG9JbnRlZ2VyKHBvc2l0aW9uKSwgMCwgbGVuZ3RoKTtcclxuXHJcbiAgICAgIHZhciBlbmQgPSBwb3NpdGlvbjtcclxuICAgICAgcG9zaXRpb24gLT0gdGFyZ2V0Lmxlbmd0aDtcclxuICAgICAgcmV0dXJuIHBvc2l0aW9uID49IDAgJiYgc3RyaW5nLnNsaWNlKHBvc2l0aW9uLCBlbmQpID09IHRhcmdldDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoZSBjaGFyYWN0ZXJzIFwiJlwiLCBcIjxcIiwgXCI+XCIsICdcIicsIGFuZCBcIidcIiBpbiBgc3RyaW5nYCB0byB0aGVpclxyXG4gICAgICogY29ycmVzcG9uZGluZyBIVE1MIGVudGl0aWVzLlxyXG4gICAgICpcclxuICAgICAqICoqTm90ZToqKiBObyBvdGhlciBjaGFyYWN0ZXJzIGFyZSBlc2NhcGVkLiBUbyBlc2NhcGUgYWRkaXRpb25hbFxyXG4gICAgICogY2hhcmFjdGVycyB1c2UgYSB0aGlyZC1wYXJ0eSBsaWJyYXJ5IGxpa2UgW19oZV9dKGh0dHBzOi8vbXRocy5iZS9oZSkuXHJcbiAgICAgKlxyXG4gICAgICogVGhvdWdoIHRoZSBcIj5cIiBjaGFyYWN0ZXIgaXMgZXNjYXBlZCBmb3Igc3ltbWV0cnksIGNoYXJhY3RlcnMgbGlrZVxyXG4gICAgICogXCI+XCIgYW5kIFwiL1wiIGRvbid0IG5lZWQgZXNjYXBpbmcgaW4gSFRNTCBhbmQgaGF2ZSBubyBzcGVjaWFsIG1lYW5pbmdcclxuICAgICAqIHVubGVzcyB0aGV5J3JlIHBhcnQgb2YgYSB0YWcgb3IgdW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlLiBTZWVcclxuICAgICAqIFtNYXRoaWFzIEJ5bmVucydzIGFydGljbGVdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9hbWJpZ3VvdXMtYW1wZXJzYW5kcylcclxuICAgICAqICh1bmRlciBcInNlbWktcmVsYXRlZCBmdW4gZmFjdFwiKSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gICAgICpcclxuICAgICAqIFdoZW4gd29ya2luZyB3aXRoIEhUTUwgeW91IHNob3VsZCBhbHdheXNcclxuICAgICAqIFtxdW90ZSBhdHRyaWJ1dGUgdmFsdWVzXShodHRwOi8vd29ua28uY29tL3Bvc3QvaHRtbC1lc2NhcGluZykgdG8gcmVkdWNlXHJcbiAgICAgKiBYU1MgdmVjdG9ycy5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAc2luY2UgMC4xLjBcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBlc2NhcGUuXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIHN0cmluZy5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogXy5lc2NhcGUoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XHJcbiAgICAgKiAvLyA9PiAnZnJlZCwgYmFybmV5LCAmYW1wOyBwZWJibGVzJ1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBlc2NhcGUoc3RyaW5nKSB7XHJcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XHJcbiAgICAgIHJldHVybiAoc3RyaW5nICYmIHJlSGFzVW5lc2NhcGVkSHRtbC50ZXN0KHN0cmluZykpXHJcbiAgICAgICAgPyBzdHJpbmcucmVwbGFjZShyZVVuZXNjYXBlZEh0bWwsIGVzY2FwZUh0bWxDaGFyKVxyXG4gICAgICAgIDogc3RyaW5nO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRXNjYXBlcyB0aGUgYFJlZ0V4cGAgc3BlY2lhbCBjaGFyYWN0ZXJzIFwiXlwiLCBcIiRcIiwgXCJcXFwiLCBcIi5cIiwgXCIqXCIsIFwiK1wiLFxyXG4gICAgICogXCI/XCIsIFwiKFwiLCBcIilcIiwgXCJbXCIsIFwiXVwiLCBcIntcIiwgXCJ9XCIsIGFuZCBcInxcIiBpbiBgc3RyaW5nYC5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDMuMC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBlc2NhcGUuXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIHN0cmluZy5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogXy5lc2NhcGVSZWdFeHAoJ1tsb2Rhc2hdKGh0dHBzOi8vbG9kYXNoLmNvbS8pJyk7XHJcbiAgICAgKiAvLyA9PiAnXFxbbG9kYXNoXFxdXFwoaHR0cHM6Ly9sb2Rhc2hcXC5jb20vXFwpJ1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyaW5nKSB7XHJcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XHJcbiAgICAgIHJldHVybiAoc3RyaW5nICYmIHJlSGFzUmVnRXhwQ2hhci50ZXN0KHN0cmluZykpXHJcbiAgICAgICAgPyBzdHJpbmcucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxyXG4gICAgICAgIDogc3RyaW5nO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG9cclxuICAgICAqIFtrZWJhYiBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MZXR0ZXJfY2FzZSNTcGVjaWFsX2Nhc2Vfc3R5bGVzKS5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDMuMC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUga2ViYWIgY2FzZWQgc3RyaW5nLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLmtlYmFiQ2FzZSgnRm9vIEJhcicpO1xyXG4gICAgICogLy8gPT4gJ2Zvby1iYXInXHJcbiAgICAgKlxyXG4gICAgICogXy5rZWJhYkNhc2UoJ2Zvb0JhcicpO1xyXG4gICAgICogLy8gPT4gJ2Zvby1iYXInXHJcbiAgICAgKlxyXG4gICAgICogXy5rZWJhYkNhc2UoJ19fRk9PX0JBUl9fJyk7XHJcbiAgICAgKiAvLyA9PiAnZm9vLWJhcidcclxuICAgICAqL1xyXG4gICAgdmFyIGtlYmFiQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xyXG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJy0nIDogJycpICsgd29yZC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCwgYXMgc3BhY2Ugc2VwYXJhdGVkIHdvcmRzLCB0byBsb3dlciBjYXNlLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgNC4wLjBcclxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBsb3dlciBjYXNlZCBzdHJpbmcuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8ubG93ZXJDYXNlKCctLUZvby1CYXItLScpO1xyXG4gICAgICogLy8gPT4gJ2ZvbyBiYXInXHJcbiAgICAgKlxyXG4gICAgICogXy5sb3dlckNhc2UoJ2Zvb0JhcicpO1xyXG4gICAgICogLy8gPT4gJ2ZvbyBiYXInXHJcbiAgICAgKlxyXG4gICAgICogXy5sb3dlckNhc2UoJ19fRk9PX0JBUl9fJyk7XHJcbiAgICAgKiAvLyA9PiAnZm9vIGJhcidcclxuICAgICAqL1xyXG4gICAgdmFyIGxvd2VyQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xyXG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJyAnIDogJycpICsgd29yZC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGBzdHJpbmdgIHRvIGxvd2VyIGNhc2UuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSA0LjAuMFxyXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8ubG93ZXJGaXJzdCgnRnJlZCcpO1xyXG4gICAgICogLy8gPT4gJ2ZyZWQnXHJcbiAgICAgKlxyXG4gICAgICogXy5sb3dlckZpcnN0KCdGUkVEJyk7XHJcbiAgICAgKiAvLyA9PiAnZlJFRCdcclxuICAgICAqL1xyXG4gICAgdmFyIGxvd2VyRmlyc3QgPSBjcmVhdGVDYXNlRmlyc3QoJ3RvTG93ZXJDYXNlJyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQYWRzIGBzdHJpbmdgIG9uIHRoZSBsZWZ0IGFuZCByaWdodCBzaWRlcyBpZiBpdCdzIHNob3J0ZXIgdGhhbiBgbGVuZ3RoYC5cclxuICAgICAqIFBhZGRpbmcgY2hhcmFjdGVycyBhcmUgdHJ1bmNhdGVkIGlmIHRoZXkgY2FuJ3QgYmUgZXZlbmx5IGRpdmlkZWQgYnkgYGxlbmd0aGAuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAzLjAuMFxyXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcGFkLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9MF0gVGhlIHBhZGRpbmcgbGVuZ3RoLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz0nICddIFRoZSBzdHJpbmcgdXNlZCBhcyBwYWRkaW5nLlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGVkIHN0cmluZy5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogXy5wYWQoJ2FiYycsIDgpO1xyXG4gICAgICogLy8gPT4gJyAgYWJjICAgJ1xyXG4gICAgICpcclxuICAgICAqIF8ucGFkKCdhYmMnLCA4LCAnXy0nKTtcclxuICAgICAqIC8vID0+ICdfLWFiY18tXydcclxuICAgICAqXHJcbiAgICAgKiBfLnBhZCgnYWJjJywgMyk7XHJcbiAgICAgKiAvLyA9PiAnYWJjJ1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBwYWQoc3RyaW5nLCBsZW5ndGgsIGNoYXJzKSB7XHJcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XHJcbiAgICAgIGxlbmd0aCA9IHRvSW50ZWdlcihsZW5ndGgpO1xyXG5cclxuICAgICAgdmFyIHN0ckxlbmd0aCA9IGxlbmd0aCA/IHN0cmluZ1NpemUoc3RyaW5nKSA6IDA7XHJcbiAgICAgIGlmICghbGVuZ3RoIHx8IHN0ckxlbmd0aCA+PSBsZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gc3RyaW5nO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBtaWQgPSAobGVuZ3RoIC0gc3RyTGVuZ3RoKSAvIDI7XHJcbiAgICAgIHJldHVybiAoXHJcbiAgICAgICAgY3JlYXRlUGFkZGluZyhuYXRpdmVGbG9vcihtaWQpLCBjaGFycykgK1xyXG4gICAgICAgIHN0cmluZyArXHJcbiAgICAgICAgY3JlYXRlUGFkZGluZyhuYXRpdmVDZWlsKG1pZCksIGNoYXJzKVxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGFkcyBgc3RyaW5nYCBvbiB0aGUgcmlnaHQgc2lkZSBpZiBpdCdzIHNob3J0ZXIgdGhhbiBgbGVuZ3RoYC4gUGFkZGluZ1xyXG4gICAgICogY2hhcmFjdGVycyBhcmUgdHJ1bmNhdGVkIGlmIHRoZXkgZXhjZWVkIGBsZW5ndGhgLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgNC4wLjBcclxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHBhZC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTBdIFRoZSBwYWRkaW5nIGxlbmd0aC5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9JyAnXSBUaGUgc3RyaW5nIHVzZWQgYXMgcGFkZGluZy5cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHBhZGRlZCBzdHJpbmcuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8ucGFkRW5kKCdhYmMnLCA2KTtcclxuICAgICAqIC8vID0+ICdhYmMgICAnXHJcbiAgICAgKlxyXG4gICAgICogXy5wYWRFbmQoJ2FiYycsIDYsICdfLScpO1xyXG4gICAgICogLy8gPT4gJ2FiY18tXydcclxuICAgICAqXHJcbiAgICAgKiBfLnBhZEVuZCgnYWJjJywgMyk7XHJcbiAgICAgKiAvLyA9PiAnYWJjJ1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBwYWRFbmQoc3RyaW5nLCBsZW5ndGgsIGNoYXJzKSB7XHJcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XHJcbiAgICAgIGxlbmd0aCA9IHRvSW50ZWdlcihsZW5ndGgpO1xyXG5cclxuICAgICAgdmFyIHN0ckxlbmd0aCA9IGxlbmd0aCA/IHN0cmluZ1NpemUoc3RyaW5nKSA6IDA7XHJcbiAgICAgIHJldHVybiAobGVuZ3RoICYmIHN0ckxlbmd0aCA8IGxlbmd0aClcclxuICAgICAgICA/IChzdHJpbmcgKyBjcmVhdGVQYWRkaW5nKGxlbmd0aCAtIHN0ckxlbmd0aCwgY2hhcnMpKVxyXG4gICAgICAgIDogc3RyaW5nO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGFkcyBgc3RyaW5nYCBvbiB0aGUgbGVmdCBzaWRlIGlmIGl0J3Mgc2hvcnRlciB0aGFuIGBsZW5ndGhgLiBQYWRkaW5nXHJcbiAgICAgKiBjaGFyYWN0ZXJzIGFyZSB0cnVuY2F0ZWQgaWYgdGhleSBleGNlZWQgYGxlbmd0aGAuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSA0LjAuMFxyXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcGFkLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9MF0gVGhlIHBhZGRpbmcgbGVuZ3RoLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz0nICddIFRoZSBzdHJpbmcgdXNlZCBhcyBwYWRkaW5nLlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGVkIHN0cmluZy5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogXy5wYWRTdGFydCgnYWJjJywgNik7XHJcbiAgICAgKiAvLyA9PiAnICAgYWJjJ1xyXG4gICAgICpcclxuICAgICAqIF8ucGFkU3RhcnQoJ2FiYycsIDYsICdfLScpO1xyXG4gICAgICogLy8gPT4gJ18tX2FiYydcclxuICAgICAqXHJcbiAgICAgKiBfLnBhZFN0YXJ0KCdhYmMnLCAzKTtcclxuICAgICAqIC8vID0+ICdhYmMnXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHBhZFN0YXJ0KHN0cmluZywgbGVuZ3RoLCBjaGFycykge1xyXG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xyXG4gICAgICBsZW5ndGggPSB0b0ludGVnZXIobGVuZ3RoKTtcclxuXHJcbiAgICAgIHZhciBzdHJMZW5ndGggPSBsZW5ndGggPyBzdHJpbmdTaXplKHN0cmluZykgOiAwO1xyXG4gICAgICByZXR1cm4gKGxlbmd0aCAmJiBzdHJMZW5ndGggPCBsZW5ndGgpXHJcbiAgICAgICAgPyAoY3JlYXRlUGFkZGluZyhsZW5ndGggLSBzdHJMZW5ndGgsIGNoYXJzKSArIHN0cmluZylcclxuICAgICAgICA6IHN0cmluZztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGFuIGludGVnZXIgb2YgdGhlIHNwZWNpZmllZCByYWRpeC4gSWYgYHJhZGl4YCBpc1xyXG4gICAgICogYHVuZGVmaW5lZGAgb3IgYDBgLCBhIGByYWRpeGAgb2YgYDEwYCBpcyB1c2VkIHVubGVzcyBgdmFsdWVgIGlzIGFcclxuICAgICAqIGhleGFkZWNpbWFsLCBpbiB3aGljaCBjYXNlIGEgYHJhZGl4YCBvZiBgMTZgIGlzIHVzZWQuXHJcbiAgICAgKlxyXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGFsaWducyB3aXRoIHRoZVxyXG4gICAgICogW0VTNSBpbXBsZW1lbnRhdGlvbl0oaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMS4yLjIpIG9mIGBwYXJzZUludGAuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAxLjEuMFxyXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3JhZGl4PTEwXSBUaGUgcmFkaXggdG8gaW50ZXJwcmV0IGB2YWx1ZWAgYnkuXHJcbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8ucGFyc2VJbnQoJzA4Jyk7XHJcbiAgICAgKiAvLyA9PiA4XHJcbiAgICAgKlxyXG4gICAgICogXy5tYXAoWyc2JywgJzA4JywgJzEwJ10sIF8ucGFyc2VJbnQpO1xyXG4gICAgICogLy8gPT4gWzYsIDgsIDEwXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBwYXJzZUludChzdHJpbmcsIHJhZGl4LCBndWFyZCkge1xyXG4gICAgICBpZiAoZ3VhcmQgfHwgcmFkaXggPT0gbnVsbCkge1xyXG4gICAgICAgIHJhZGl4ID0gMDtcclxuICAgICAgfSBlbHNlIGlmIChyYWRpeCkge1xyXG4gICAgICAgIHJhZGl4ID0gK3JhZGl4O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBuYXRpdmVQYXJzZUludCh0b1N0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVUcmltU3RhcnQsICcnKSwgcmFkaXggfHwgMCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXBlYXRzIHRoZSBnaXZlbiBzdHJpbmcgYG5gIHRpbWVzLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgMy4wLjBcclxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHJlcGVhdC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJlcGVhdCB0aGUgc3RyaW5nLlxyXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJlcGVhdGVkIHN0cmluZy5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogXy5yZXBlYXQoJyonLCAzKTtcclxuICAgICAqIC8vID0+ICcqKionXHJcbiAgICAgKlxyXG4gICAgICogXy5yZXBlYXQoJ2FiYycsIDIpO1xyXG4gICAgICogLy8gPT4gJ2FiY2FiYydcclxuICAgICAqXHJcbiAgICAgKiBfLnJlcGVhdCgnYWJjJywgMCk7XHJcbiAgICAgKiAvLyA9PiAnJ1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiByZXBlYXQoc3RyaW5nLCBuLCBndWFyZCkge1xyXG4gICAgICBpZiAoKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwoc3RyaW5nLCBuLCBndWFyZCkgOiBuID09PSB1bmRlZmluZWQpKSB7XHJcbiAgICAgICAgbiA9IDE7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbiA9IHRvSW50ZWdlcihuKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gYmFzZVJlcGVhdCh0b1N0cmluZyhzdHJpbmcpLCBuKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlcGxhY2VzIG1hdGNoZXMgZm9yIGBwYXR0ZXJuYCBpbiBgc3RyaW5nYCB3aXRoIGByZXBsYWNlbWVudGAuXHJcbiAgICAgKlxyXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXHJcbiAgICAgKiBbYFN0cmluZyNyZXBsYWNlYF0oaHR0cHM6Ly9tZG4uaW8vU3RyaW5nL3JlcGxhY2UpLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgNC4wLjBcclxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIG1vZGlmeS5cclxuICAgICAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gcGF0dGVybiBUaGUgcGF0dGVybiB0byByZXBsYWNlLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IHJlcGxhY2VtZW50IFRoZSBtYXRjaCByZXBsYWNlbWVudC5cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIG1vZGlmaWVkIHN0cmluZy5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogXy5yZXBsYWNlKCdIaSBGcmVkJywgJ0ZyZWQnLCAnQmFybmV5Jyk7XHJcbiAgICAgKiAvLyA9PiAnSGkgQmFybmV5J1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiByZXBsYWNlKCkge1xyXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcclxuICAgICAgICAgIHN0cmluZyA9IHRvU3RyaW5nKGFyZ3NbMF0pO1xyXG5cclxuICAgICAgcmV0dXJuIGFyZ3MubGVuZ3RoIDwgMyA/IHN0cmluZyA6IHN0cmluZy5yZXBsYWNlKGFyZ3NbMV0sIGFyZ3NbMl0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG9cclxuICAgICAqIFtzbmFrZSBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TbmFrZV9jYXNlKS5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDMuMC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc25ha2UgY2FzZWQgc3RyaW5nLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLnNuYWtlQ2FzZSgnRm9vIEJhcicpO1xyXG4gICAgICogLy8gPT4gJ2Zvb19iYXInXHJcbiAgICAgKlxyXG4gICAgICogXy5zbmFrZUNhc2UoJ2Zvb0JhcicpO1xyXG4gICAgICogLy8gPT4gJ2Zvb19iYXInXHJcbiAgICAgKlxyXG4gICAgICogXy5zbmFrZUNhc2UoJy0tRk9PLUJBUi0tJyk7XHJcbiAgICAgKiAvLyA9PiAnZm9vX2JhcidcclxuICAgICAqL1xyXG4gICAgdmFyIHNuYWtlQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xyXG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJ18nIDogJycpICsgd29yZC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTcGxpdHMgYHN0cmluZ2AgYnkgYHNlcGFyYXRvcmAuXHJcbiAgICAgKlxyXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXHJcbiAgICAgKiBbYFN0cmluZyNzcGxpdGBdKGh0dHBzOi8vbWRuLmlvL1N0cmluZy9zcGxpdCkuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSA0LjAuMFxyXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gc3BsaXQuXHJcbiAgICAgKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IHNlcGFyYXRvciBUaGUgc2VwYXJhdG9yIHBhdHRlcm4gdG8gc3BsaXQgYnkuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBUaGUgbGVuZ3RoIHRvIHRydW5jYXRlIHJlc3VsdHMgdG8uXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHN0cmluZyBzZWdtZW50cy5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogXy5zcGxpdCgnYS1iLWMnLCAnLScsIDIpO1xyXG4gICAgICogLy8gPT4gWydhJywgJ2InXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBzcGxpdChzdHJpbmcsIHNlcGFyYXRvciwgbGltaXQpIHtcclxuICAgICAgaWYgKGxpbWl0ICYmIHR5cGVvZiBsaW1pdCAhPSAnbnVtYmVyJyAmJiBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIHNlcGFyYXRvciwgbGltaXQpKSB7XHJcbiAgICAgICAgc2VwYXJhdG9yID0gbGltaXQgPSB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuICAgICAgbGltaXQgPSBsaW1pdCA9PT0gdW5kZWZpbmVkID8gTUFYX0FSUkFZX0xFTkdUSCA6IGxpbWl0ID4+PiAwO1xyXG4gICAgICBpZiAoIWxpbWl0KSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICB9XHJcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XHJcbiAgICAgIGlmIChzdHJpbmcgJiYgKFxyXG4gICAgICAgICAgICB0eXBlb2Ygc2VwYXJhdG9yID09ICdzdHJpbmcnIHx8XHJcbiAgICAgICAgICAgIChzZXBhcmF0b3IgIT0gbnVsbCAmJiAhaXNSZWdFeHAoc2VwYXJhdG9yKSlcclxuICAgICAgICAgICkpIHtcclxuICAgICAgICBzZXBhcmF0b3IgPSBiYXNlVG9TdHJpbmcoc2VwYXJhdG9yKTtcclxuICAgICAgICBpZiAoIXNlcGFyYXRvciAmJiBoYXNVbmljb2RlKHN0cmluZykpIHtcclxuICAgICAgICAgIHJldHVybiBjYXN0U2xpY2Uoc3RyaW5nVG9BcnJheShzdHJpbmcpLCAwLCBsaW1pdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBzdHJpbmcuc3BsaXQoc2VwYXJhdG9yLCBsaW1pdCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0b1xyXG4gICAgICogW3N0YXJ0IGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xldHRlcl9jYXNlI1N0eWxpc3RpY19vcl9zcGVjaWFsaXNlZF91c2FnZSkuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAzLjEuMFxyXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0YXJ0IGNhc2VkIHN0cmluZy5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogXy5zdGFydENhc2UoJy0tZm9vLWJhci0tJyk7XHJcbiAgICAgKiAvLyA9PiAnRm9vIEJhcidcclxuICAgICAqXHJcbiAgICAgKiBfLnN0YXJ0Q2FzZSgnZm9vQmFyJyk7XHJcbiAgICAgKiAvLyA9PiAnRm9vIEJhcidcclxuICAgICAqXHJcbiAgICAgKiBfLnN0YXJ0Q2FzZSgnX19GT09fQkFSX18nKTtcclxuICAgICAqIC8vID0+ICdGT08gQkFSJ1xyXG4gICAgICovXHJcbiAgICB2YXIgc3RhcnRDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XHJcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnICcgOiAnJykgKyB1cHBlckZpcnN0KHdvcmQpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgYHN0cmluZ2Agc3RhcnRzIHdpdGggdGhlIGdpdmVuIHRhcmdldCBzdHJpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAzLjAuMFxyXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdGFyZ2V0XSBUaGUgc3RyaW5nIHRvIHNlYXJjaCBmb3IuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3Bvc2l0aW9uPTBdIFRoZSBwb3NpdGlvbiB0byBzZWFyY2ggZnJvbS5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgc3RyaW5nYCBzdGFydHMgd2l0aCBgdGFyZ2V0YCxcclxuICAgICAqICBlbHNlIGBmYWxzZWAuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8uc3RhcnRzV2l0aCgnYWJjJywgJ2EnKTtcclxuICAgICAqIC8vID0+IHRydWVcclxuICAgICAqXHJcbiAgICAgKiBfLnN0YXJ0c1dpdGgoJ2FiYycsICdiJyk7XHJcbiAgICAgKiAvLyA9PiBmYWxzZVxyXG4gICAgICpcclxuICAgICAqIF8uc3RhcnRzV2l0aCgnYWJjJywgJ2InLCAxKTtcclxuICAgICAqIC8vID0+IHRydWVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gc3RhcnRzV2l0aChzdHJpbmcsIHRhcmdldCwgcG9zaXRpb24pIHtcclxuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcclxuICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA9PSBudWxsXHJcbiAgICAgICAgPyAwXHJcbiAgICAgICAgOiBiYXNlQ2xhbXAodG9JbnRlZ2VyKHBvc2l0aW9uKSwgMCwgc3RyaW5nLmxlbmd0aCk7XHJcblxyXG4gICAgICB0YXJnZXQgPSBiYXNlVG9TdHJpbmcodGFyZ2V0KTtcclxuICAgICAgcmV0dXJuIHN0cmluZy5zbGljZShwb3NpdGlvbiwgcG9zaXRpb24gKyB0YXJnZXQubGVuZ3RoKSA9PSB0YXJnZXQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgY29tcGlsZWQgdGVtcGxhdGUgZnVuY3Rpb24gdGhhdCBjYW4gaW50ZXJwb2xhdGUgZGF0YSBwcm9wZXJ0aWVzXHJcbiAgICAgKiBpbiBcImludGVycG9sYXRlXCIgZGVsaW1pdGVycywgSFRNTC1lc2NhcGUgaW50ZXJwb2xhdGVkIGRhdGEgcHJvcGVydGllcyBpblxyXG4gICAgICogXCJlc2NhcGVcIiBkZWxpbWl0ZXJzLCBhbmQgZXhlY3V0ZSBKYXZhU2NyaXB0IGluIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXJzLiBEYXRhXHJcbiAgICAgKiBwcm9wZXJ0aWVzIG1heSBiZSBhY2Nlc3NlZCBhcyBmcmVlIHZhcmlhYmxlcyBpbiB0aGUgdGVtcGxhdGUuIElmIGEgc2V0dGluZ1xyXG4gICAgICogb2JqZWN0IGlzIGdpdmVuLCBpdCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgYF8udGVtcGxhdGVTZXR0aW5nc2AgdmFsdWVzLlxyXG4gICAgICpcclxuICAgICAqICoqTm90ZToqKiBJbiB0aGUgZGV2ZWxvcG1lbnQgYnVpbGQgYF8udGVtcGxhdGVgIHV0aWxpemVzXHJcbiAgICAgKiBbc291cmNlVVJMc10oaHR0cDovL3d3dy5odG1sNXJvY2tzLmNvbS9lbi90dXRvcmlhbHMvZGV2ZWxvcGVydG9vbHMvc291cmNlbWFwcy8jdG9jLXNvdXJjZXVybClcclxuICAgICAqIGZvciBlYXNpZXIgZGVidWdnaW5nLlxyXG4gICAgICpcclxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHByZWNvbXBpbGluZyB0ZW1wbGF0ZXMgc2VlXHJcbiAgICAgKiBbbG9kYXNoJ3MgY3VzdG9tIGJ1aWxkcyBkb2N1bWVudGF0aW9uXShodHRwczovL2xvZGFzaC5jb20vY3VzdG9tLWJ1aWxkcykuXHJcbiAgICAgKlxyXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gQ2hyb21lIGV4dGVuc2lvbiBzYW5kYm94ZXMgc2VlXHJcbiAgICAgKiBbQ2hyb21lJ3MgZXh0ZW5zaW9ucyBkb2N1bWVudGF0aW9uXShodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2V4dGVuc2lvbnMvc2FuZGJveGluZ0V2YWwpLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBzaW5jZSAwLjEuMFxyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgdGVtcGxhdGUgc3RyaW5nLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuZXNjYXBlPV8udGVtcGxhdGVTZXR0aW5ncy5lc2NhcGVdXHJcbiAgICAgKiAgVGhlIEhUTUwgXCJlc2NhcGVcIiBkZWxpbWl0ZXIuXHJcbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuZXZhbHVhdGU9Xy50ZW1wbGF0ZVNldHRpbmdzLmV2YWx1YXRlXVxyXG4gICAgICogIFRoZSBcImV2YWx1YXRlXCIgZGVsaW1pdGVyLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmltcG9ydHM9Xy50ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHNdXHJcbiAgICAgKiAgQW4gb2JqZWN0IHRvIGltcG9ydCBpbnRvIHRoZSB0ZW1wbGF0ZSBhcyBmcmVlIHZhcmlhYmxlcy5cclxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5pbnRlcnBvbGF0ZT1fLnRlbXBsYXRlU2V0dGluZ3MuaW50ZXJwb2xhdGVdXHJcbiAgICAgKiAgVGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc291cmNlVVJMPSdsb2Rhc2gudGVtcGxhdGVTb3VyY2VzW25dJ11cclxuICAgICAqICBUaGUgc291cmNlVVJMIG9mIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy52YXJpYWJsZT0nb2JqJ11cclxuICAgICAqICBUaGUgZGF0YSBvYmplY3QgdmFyaWFibGUgbmFtZS5cclxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXHJcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNvbXBpbGVkIHRlbXBsYXRlIGZ1bmN0aW9uLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiAvLyBVc2UgdGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIgdG8gY3JlYXRlIGEgY29tcGlsZWQgdGVtcGxhdGUuXHJcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gdXNlciAlPiEnKTtcclxuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnZnJlZCcgfSk7XHJcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCEnXHJcbiAgICAgKlxyXG4gICAgICogLy8gVXNlIHRoZSBIVE1MIFwiZXNjYXBlXCIgZGVsaW1pdGVyIHRvIGVzY2FwZSBkYXRhIHByb3BlcnR5IHZhbHVlcy5cclxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzxiPjwlLSB2YWx1ZSAlPjwvYj4nKTtcclxuICAgICAqIGNvbXBpbGVkKHsgJ3ZhbHVlJzogJzxzY3JpcHQ+JyB9KTtcclxuICAgICAqIC8vID0+ICc8Yj4mbHQ7c2NyaXB0Jmd0OzwvYj4nXHJcbiAgICAgKlxyXG4gICAgICogLy8gVXNlIHRoZSBcImV2YWx1YXRlXCIgZGVsaW1pdGVyIHRvIGV4ZWN1dGUgSmF2YVNjcmlwdCBhbmQgZ2VuZXJhdGUgSFRNTC5cclxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlIF8uZm9yRWFjaCh1c2VycywgZnVuY3Rpb24odXNlcikgeyAlPjxsaT48JS0gdXNlciAlPjwvbGk+PCUgfSk7ICU+Jyk7XHJcbiAgICAgKiBjb21waWxlZCh7ICd1c2Vycyc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcclxuICAgICAqIC8vID0+ICc8bGk+ZnJlZDwvbGk+PGxpPmJhcm5leTwvbGk+J1xyXG4gICAgICpcclxuICAgICAqIC8vIFVzZSB0aGUgaW50ZXJuYWwgYHByaW50YCBmdW5jdGlvbiBpbiBcImV2YWx1YXRlXCIgZGVsaW1pdGVycy5cclxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlIHByaW50KFwiaGVsbG8gXCIgKyB1c2VyKTsgJT4hJyk7XHJcbiAgICAgKiBjb21waWxlZCh7ICd1c2VyJzogJ2Jhcm5leScgfSk7XHJcbiAgICAgKiAvLyA9PiAnaGVsbG8gYmFybmV5ISdcclxuICAgICAqXHJcbiAgICAgKiAvLyBVc2UgdGhlIEVTIHRlbXBsYXRlIGxpdGVyYWwgZGVsaW1pdGVyIGFzIGFuIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXHJcbiAgICAgKiAvLyBEaXNhYmxlIHN1cHBvcnQgYnkgcmVwbGFjaW5nIHRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxyXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gJHsgdXNlciB9IScpO1xyXG4gICAgICogY29tcGlsZWQoeyAndXNlcic6ICdwZWJibGVzJyB9KTtcclxuICAgICAqIC8vID0+ICdoZWxsbyBwZWJibGVzISdcclxuICAgICAqXHJcbiAgICAgKiAvLyBVc2UgYmFja3NsYXNoZXMgdG8gdHJlYXQgZGVsaW1pdGVycyBhcyBwbGFpbiB0ZXh0LlxyXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCU9IFwiXFxcXDwlLSB2YWx1ZSAlXFxcXD5cIiAlPicpO1xyXG4gICAgICogY29tcGlsZWQoeyAndmFsdWUnOiAnaWdub3JlZCcgfSk7XHJcbiAgICAgKiAvLyA9PiAnPCUtIHZhbHVlICU+J1xyXG4gICAgICpcclxuICAgICAqIC8vIFVzZSB0aGUgYGltcG9ydHNgIG9wdGlvbiB0byBpbXBvcnQgYGpRdWVyeWAgYXMgYGpxYC5cclxuICAgICAqIHZhciB0ZXh0ID0gJzwlIGpxLmVhY2godXNlcnMsIGZ1bmN0aW9uKHVzZXIpIHsgJT48bGk+PCUtIHVzZXIgJT48L2xpPjwlIH0pOyAlPic7XHJcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKHRleHQsIHsgJ2ltcG9ydHMnOiB7ICdqcSc6IGpRdWVyeSB9IH0pO1xyXG4gICAgICogY29tcGlsZWQoeyAndXNlcnMnOiBbJ2ZyZWQnLCAnYmFybmV5J10gfSk7XHJcbiAgICAgKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcclxuICAgICAqXHJcbiAgICAgKiAvLyBVc2UgdGhlIGBzb3VyY2VVUkxgIG9wdGlvbiB0byBzcGVjaWZ5IGEgY3VzdG9tIHNvdXJjZVVSTCBmb3IgdGhlIHRlbXBsYXRlLlxyXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gPCU9IHVzZXIgJT4hJywgeyAnc291cmNlVVJMJzogJy9iYXNpYy9ncmVldGluZy5qc3QnIH0pO1xyXG4gICAgICogY29tcGlsZWQoZGF0YSk7XHJcbiAgICAgKiAvLyA9PiBGaW5kIHRoZSBzb3VyY2Ugb2YgXCJncmVldGluZy5qc3RcIiB1bmRlciB0aGUgU291cmNlcyB0YWIgb3IgUmVzb3VyY2VzIHBhbmVsIG9mIHRoZSB3ZWIgaW5zcGVjdG9yLlxyXG4gICAgICpcclxuICAgICAqIC8vIFVzZSB0aGUgYHZhcmlhYmxlYCBvcHRpb24gdG8gZW5zdXJlIGEgd2l0aC1zdGF0ZW1lbnQgaXNuJ3QgdXNlZCBpbiB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXHJcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoaSA8JT0gZGF0YS51c2VyICU+IScsIHsgJ3ZhcmlhYmxlJzogJ2RhdGEnIH0pO1xyXG4gICAgICogY29tcGlsZWQuc291cmNlO1xyXG4gICAgICogLy8gPT4gZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICogLy8gICB2YXIgX190LCBfX3AgPSAnJztcclxuICAgICAqIC8vICAgX19wICs9ICdoaSAnICsgKChfX3QgPSAoIGRhdGEudXNlciApKSA9PSBudWxsID8gJycgOiBfX3QpICsgJyEnO1xyXG4gICAgICogLy8gICByZXR1cm4gX19wO1xyXG4gICAgICogLy8gfVxyXG4gICAgICpcclxuICAgICAqIC8vIFVzZSBjdXN0b20gdGVtcGxhdGUgZGVsaW1pdGVycy5cclxuICAgICAqIF8udGVtcGxhdGVTZXR0aW5ncy5pbnRlcnBvbGF0ZSA9IC97eyhbXFxzXFxTXSs/KX19L2c7XHJcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyB7eyB1c2VyIH19IScpO1xyXG4gICAgICogY29tcGlsZWQoeyAndXNlcic6ICdtdXN0YWNoZScgfSk7XHJcbiAgICAgKiAvLyA9PiAnaGVsbG8gbXVzdGFjaGUhJ1xyXG4gICAgICpcclxuICAgICAqIC8vIFVzZSB0aGUgYHNvdXJjZWAgcHJvcGVydHkgdG8gaW5saW5lIGNvbXBpbGVkIHRlbXBsYXRlcyBmb3IgbWVhbmluZ2Z1bFxyXG4gICAgICogLy8gbGluZSBudW1iZXJzIGluIGVycm9yIG1lc3NhZ2VzIGFuZCBzdGFjayB0cmFjZXMuXHJcbiAgICAgKiBmcy53cml0ZUZpbGVTeW5jKHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAnanN0LmpzJyksICdcXFxyXG4gICAgICogICB2YXIgSlNUID0ge1xcXHJcbiAgICAgKiAgICAgXCJtYWluXCI6ICcgKyBfLnRlbXBsYXRlKG1haW5UZXh0KS5zb3VyY2UgKyAnXFxcclxuICAgICAqICAgfTtcXFxyXG4gICAgICogJyk7XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHRlbXBsYXRlKHN0cmluZywgb3B0aW9ucywgZ3VhcmQpIHtcclxuICAgICAgLy8gQmFzZWQgb24gSm9obiBSZXNpZydzIGB0bXBsYCBpbXBsZW1lbnRhdGlvblxyXG4gICAgICAvLyAoaHR0cDovL2Vqb2huLm9yZy9ibG9nL2phdmFzY3JpcHQtbWljcm8tdGVtcGxhdGluZy8pXHJcbiAgICAgIC8vIGFuZCBMYXVyYSBEb2t0b3JvdmEncyBkb1QuanMgKGh0dHBzOi8vZ2l0aHViLmNvbS9vbGFkby9kb1QpLlxyXG4gICAgICB2YXIgc2V0dGluZ3MgPSBsb2Rhc2gudGVtcGxhdGVTZXR0aW5ncztcclxuXHJcbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIG9wdGlvbnMsIGd1YXJkKSkge1xyXG4gICAgICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcclxuICAgICAgb3B0aW9ucyA9IGFzc2lnbkluV2l0aCh7fSwgb3B0aW9ucywgc2V0dGluZ3MsIGN1c3RvbURlZmF1bHRzQXNzaWduSW4pO1xyXG5cclxuICAgICAgdmFyIGltcG9ydHMgPSBhc3NpZ25JbldpdGgoe30sIG9wdGlvbnMuaW1wb3J0cywgc2V0dGluZ3MuaW1wb3J0cywgY3VzdG9tRGVmYXVsdHNBc3NpZ25JbiksXHJcbiAgICAgICAgICBpbXBvcnRzS2V5cyA9IGtleXMoaW1wb3J0cyksXHJcbiAgICAgICAgICBpbXBvcnRzVmFsdWVzID0gYmFzZVZhbHVlcyhpbXBvcnRzLCBpbXBvcnRzS2V5cyk7XHJcblxyXG4gICAgICB2YXIgaXNFc2NhcGluZyxcclxuICAgICAgICAgIGlzRXZhbHVhdGluZyxcclxuICAgICAgICAgIGluZGV4ID0gMCxcclxuICAgICAgICAgIGludGVycG9sYXRlID0gb3B0aW9ucy5pbnRlcnBvbGF0ZSB8fCByZU5vTWF0Y2gsXHJcbiAgICAgICAgICBzb3VyY2UgPSBcIl9fcCArPSAnXCI7XHJcblxyXG4gICAgICAvLyBDb21waWxlIHRoZSByZWdleHAgdG8gbWF0Y2ggZWFjaCBkZWxpbWl0ZXIuXHJcbiAgICAgIHZhciByZURlbGltaXRlcnMgPSBSZWdFeHAoXHJcbiAgICAgICAgKG9wdGlvbnMuZXNjYXBlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wnICtcclxuICAgICAgICBpbnRlcnBvbGF0ZS5zb3VyY2UgKyAnfCcgK1xyXG4gICAgICAgIChpbnRlcnBvbGF0ZSA9PT0gcmVJbnRlcnBvbGF0ZSA/IHJlRXNUZW1wbGF0ZSA6IHJlTm9NYXRjaCkuc291cmNlICsgJ3wnICtcclxuICAgICAgICAob3B0aW9ucy5ldmFsdWF0ZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArICd8JCdcclxuICAgICAgLCAnZycpO1xyXG5cclxuICAgICAgLy8gVXNlIGEgc291cmNlVVJMIGZvciBlYXNpZXIgZGVidWdnaW5nLlxyXG4gICAgICAvLyBUaGUgc291cmNlVVJMIGdldHMgaW5qZWN0ZWQgaW50byB0aGUgc291cmNlIHRoYXQncyBldmFsLWVkLCBzbyBiZSBjYXJlZnVsXHJcbiAgICAgIC8vIHRvIG5vcm1hbGl6ZSBhbGwga2luZHMgb2Ygd2hpdGVzcGFjZSwgc28gZS5nLiBuZXdsaW5lcyAoYW5kIHVuaWNvZGUgdmVyc2lvbnMgb2YgaXQpIGNhbid0IHNuZWFrIGluXHJcbiAgICAgIC8vIGFuZCBlc2NhcGUgdGhlIGNvbW1lbnQsIHRodXMgaW5qZWN0aW5nIGNvZGUgdGhhdCBnZXRzIGV2YWxlZC5cclxuICAgICAgdmFyIHNvdXJjZVVSTCA9ICcvLyMgc291cmNlVVJMPScgK1xyXG4gICAgICAgIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsICdzb3VyY2VVUkwnKVxyXG4gICAgICAgICAgPyAob3B0aW9ucy5zb3VyY2VVUkwgKyAnJykucmVwbGFjZSgvXFxzL2csICcgJylcclxuICAgICAgICAgIDogKCdsb2Rhc2gudGVtcGxhdGVTb3VyY2VzWycgKyAoKyt0ZW1wbGF0ZUNvdW50ZXIpICsgJ10nKVxyXG4gICAgICAgICkgKyAnXFxuJztcclxuXHJcbiAgICAgIHN0cmluZy5yZXBsYWNlKHJlRGVsaW1pdGVycywgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZVZhbHVlLCBpbnRlcnBvbGF0ZVZhbHVlLCBlc1RlbXBsYXRlVmFsdWUsIGV2YWx1YXRlVmFsdWUsIG9mZnNldCkge1xyXG4gICAgICAgIGludGVycG9sYXRlVmFsdWUgfHwgKGludGVycG9sYXRlVmFsdWUgPSBlc1RlbXBsYXRlVmFsdWUpO1xyXG5cclxuICAgICAgICAvLyBFc2NhcGUgY2hhcmFjdGVycyB0aGF0IGNhbid0IGJlIGluY2x1ZGVkIGluIHN0cmluZyBsaXRlcmFscy5cclxuICAgICAgICBzb3VyY2UgKz0gc3RyaW5nLnNsaWNlKGluZGV4LCBvZmZzZXQpLnJlcGxhY2UocmVVbmVzY2FwZWRTdHJpbmcsIGVzY2FwZVN0cmluZ0NoYXIpO1xyXG5cclxuICAgICAgICAvLyBSZXBsYWNlIGRlbGltaXRlcnMgd2l0aCBzbmlwcGV0cy5cclxuICAgICAgICBpZiAoZXNjYXBlVmFsdWUpIHtcclxuICAgICAgICAgIGlzRXNjYXBpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgc291cmNlICs9IFwiJyArXFxuX19lKFwiICsgZXNjYXBlVmFsdWUgKyBcIikgK1xcbidcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGV2YWx1YXRlVmFsdWUpIHtcclxuICAgICAgICAgIGlzRXZhbHVhdGluZyA9IHRydWU7XHJcbiAgICAgICAgICBzb3VyY2UgKz0gXCInO1xcblwiICsgZXZhbHVhdGVWYWx1ZSArIFwiO1xcbl9fcCArPSAnXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpbnRlcnBvbGF0ZVZhbHVlKSB7XHJcbiAgICAgICAgICBzb3VyY2UgKz0gXCInICtcXG4oKF9fdCA9IChcIiArIGludGVycG9sYXRlVmFsdWUgKyBcIikpID09IG51bGwgPyAnJyA6IF9fdCkgK1xcbidcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XHJcblxyXG4gICAgICAgIC8vIFRoZSBKUyBlbmdpbmUgZW1iZWRkZWQgaW4gQWRvYmUgcHJvZHVjdHMgbmVlZHMgYG1hdGNoYCByZXR1cm5lZCBpblxyXG4gICAgICAgIC8vIG9yZGVyIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3QgYG9mZnNldGAgdmFsdWUuXHJcbiAgICAgICAgcmV0dXJuIG1hdGNoO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHNvdXJjZSArPSBcIic7XFxuXCI7XHJcblxyXG4gICAgICAvLyBJZiBgdmFyaWFibGVgIGlzIG5vdCBzcGVjaWZpZWQgd3JhcCBhIHdpdGgtc3RhdGVtZW50IGFyb3VuZCB0aGUgZ2VuZXJhdGVkXHJcbiAgICAgIC8vIGNvZGUgdG8gYWRkIHRoZSBkYXRhIG9iamVjdCB0byB0aGUgdG9wIG9mIHRoZSBzY29wZSBjaGFpbi5cclxuICAgICAgdmFyIHZhcmlhYmxlID0gaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCAndmFyaWFibGUnKSAmJiBvcHRpb25zLnZhcmlhYmxlO1xyXG4gICAgICBpZiAoIXZhcmlhYmxlKSB7XHJcbiAgICAgICAgc291cmNlID0gJ3dpdGggKG9iaikge1xcbicgKyBzb3VyY2UgKyAnXFxufVxcbic7XHJcbiAgICAgIH1cclxuICAgICAgLy8gVGhyb3cgYW4gZXJyb3IgaWYgYSBmb3JiaWRkZW4gY2hhcmFjdGVyIHdhcyBmb3VuZCBpbiBgdmFyaWFibGVgLCB0byBwcmV2ZW50XHJcbiAgICAgIC8vIHBvdGVudGlhbCBjb21tYW5kIGluamVjdGlvbiBhdHRhY2tzLlxyXG4gICAgICBlbHNlIGlmIChyZUZvcmJpZGRlbklkZW50aWZpZXJDaGFycy50ZXN0KHZhcmlhYmxlKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihJTlZBTElEX1RFTVBMX1ZBUl9FUlJPUl9URVhUKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2xlYW51cCBjb2RlIGJ5IHN0cmlwcGluZyBlbXB0eSBzdHJpbmdzLlxyXG4gICAgICBzb3VyY2UgPSAoaXNFdmFsdWF0aW5nID8gc291cmNlLnJlcGxhY2UocmVFbXB0eVN0cmluZ0xlYWRpbmcsICcnKSA6IHNvdXJjZSlcclxuICAgICAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nTWlkZGxlLCAnJDEnKVxyXG4gICAgICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdUcmFpbGluZywgJyQxOycpO1xyXG5cclxuICAgICAgLy8gRnJhbWUgY29kZSBhcyB0aGUgZnVuY3Rpb24gYm9keS5cclxuICAgICAgc291cmNlID0gJ2Z1bmN0aW9uKCcgKyAodmFyaWFibGUgfHwgJ29iaicpICsgJykge1xcbicgK1xyXG4gICAgICAgICh2YXJpYWJsZVxyXG4gICAgICAgICAgPyAnJ1xyXG4gICAgICAgICAgOiAnb2JqIHx8IChvYmogPSB7fSk7XFxuJ1xyXG4gICAgICAgICkgK1xyXG4gICAgICAgIFwidmFyIF9fdCwgX19wID0gJydcIiArXHJcbiAgICAgICAgKGlzRXNjYXBpbmdcclxuICAgICAgICAgICA/ICcsIF9fZSA9IF8uZXNjYXBlJ1xyXG4gICAgICAgICAgIDogJydcclxuICAgICAgICApICtcclxuICAgICAgICAoaXNFdmFsdWF0aW5nXHJcbiAgICAgICAgICA/ICcsIF9faiA9IEFycmF5LnByb3RvdHlwZS5qb2luO1xcbicgK1xyXG4gICAgICAgICAgICBcImZ1bmN0aW9uIHByaW50KCkgeyBfX3AgKz0gX19qLmNhbGwoYXJndW1lbnRzLCAnJykgfVxcblwiXHJcbiAgICAgICAgICA6ICc7XFxuJ1xyXG4gICAgICAgICkgK1xyXG4gICAgICAgIHNvdXJjZSArXHJcbiAgICAgICAgJ3JldHVybiBfX3BcXG59JztcclxuXHJcbiAgICAgIHZhciByZXN1bHQgPSBhdHRlbXB0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBGdW5jdGlvbihpbXBvcnRzS2V5cywgc291cmNlVVJMICsgJ3JldHVybiAnICsgc291cmNlKVxyXG4gICAgICAgICAgLmFwcGx5KHVuZGVmaW5lZCwgaW1wb3J0c1ZhbHVlcyk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gUHJvdmlkZSB0aGUgY29tcGlsZWQgZnVuY3Rpb24ncyBzb3VyY2UgYnkgaXRzIGB0b1N0cmluZ2AgbWV0aG9kIG9yXHJcbiAgICAgIC8vIHRoZSBgc291cmNlYCBwcm9wZXJ0eSBhcyBhIGNvbnZlbmllbmNlIGZvciBpbmxpbmluZyBjb21waWxlZCB0ZW1wbGF0ZXMuXHJcbiAgICAgIHJlc3VsdC5zb3VyY2UgPSBzb3VyY2U7XHJcbiAgICAgIGlmIChpc0Vycm9yKHJlc3VsdCkpIHtcclxuICAgICAgICB0aHJvdyByZXN1bHQ7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgLCBhcyBhIHdob2xlLCB0byBsb3dlciBjYXNlIGp1c3QgbGlrZVxyXG4gICAgICogW1N0cmluZyN0b0xvd2VyQ2FzZV0oaHR0cHM6Ly9tZG4uaW8vdG9Mb3dlckNhc2UpLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgNC4wLjBcclxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBsb3dlciBjYXNlZCBzdHJpbmcuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8udG9Mb3dlcignLS1Gb28tQmFyLS0nKTtcclxuICAgICAqIC8vID0+ICctLWZvby1iYXItLSdcclxuICAgICAqXHJcbiAgICAgKiBfLnRvTG93ZXIoJ2Zvb0JhcicpO1xyXG4gICAgICogLy8gPT4gJ2Zvb2JhcidcclxuICAgICAqXHJcbiAgICAgKiBfLnRvTG93ZXIoJ19fRk9PX0JBUl9fJyk7XHJcbiAgICAgKiAvLyA9PiAnX19mb29fYmFyX18nXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHRvTG93ZXIodmFsdWUpIHtcclxuICAgICAgcmV0dXJuIHRvU3RyaW5nKHZhbHVlKS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AsIGFzIGEgd2hvbGUsIHRvIHVwcGVyIGNhc2UganVzdCBsaWtlXHJcbiAgICAgKiBbU3RyaW5nI3RvVXBwZXJDYXNlXShodHRwczovL21kbi5pby90b1VwcGVyQ2FzZSkuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSA0LjAuMFxyXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVwcGVyIGNhc2VkIHN0cmluZy5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogXy50b1VwcGVyKCctLWZvby1iYXItLScpO1xyXG4gICAgICogLy8gPT4gJy0tRk9PLUJBUi0tJ1xyXG4gICAgICpcclxuICAgICAqIF8udG9VcHBlcignZm9vQmFyJyk7XHJcbiAgICAgKiAvLyA9PiAnRk9PQkFSJ1xyXG4gICAgICpcclxuICAgICAqIF8udG9VcHBlcignX19mb29fYmFyX18nKTtcclxuICAgICAqIC8vID0+ICdfX0ZPT19CQVJfXydcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdG9VcHBlcih2YWx1ZSkge1xyXG4gICAgICByZXR1cm4gdG9TdHJpbmcodmFsdWUpLnRvVXBwZXJDYXNlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2Ugb3Igc3BlY2lmaWVkIGNoYXJhY3RlcnMgZnJvbSBgc3RyaW5nYC5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDMuMC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cmltLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz13aGl0ZXNwYWNlXSBUaGUgY2hhcmFjdGVycyB0byB0cmltLlxyXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLnRyaW0oJyAgYWJjICAnKTtcclxuICAgICAqIC8vID0+ICdhYmMnXHJcbiAgICAgKlxyXG4gICAgICogXy50cmltKCctXy1hYmMtXy0nLCAnXy0nKTtcclxuICAgICAqIC8vID0+ICdhYmMnXHJcbiAgICAgKlxyXG4gICAgICogXy5tYXAoWycgIGZvbyAgJywgJyAgYmFyICAnXSwgXy50cmltKTtcclxuICAgICAqIC8vID0+IFsnZm9vJywgJ2JhciddXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHRyaW0oc3RyaW5nLCBjaGFycywgZ3VhcmQpIHtcclxuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcclxuICAgICAgaWYgKHN0cmluZyAmJiAoZ3VhcmQgfHwgY2hhcnMgPT09IHVuZGVmaW5lZCkpIHtcclxuICAgICAgICByZXR1cm4gYmFzZVRyaW0oc3RyaW5nKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIXN0cmluZyB8fCAhKGNoYXJzID0gYmFzZVRvU3RyaW5nKGNoYXJzKSkpIHtcclxuICAgICAgICByZXR1cm4gc3RyaW5nO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBzdHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShzdHJpbmcpLFxyXG4gICAgICAgICAgY2hyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoY2hhcnMpLFxyXG4gICAgICAgICAgc3RhcnQgPSBjaGFyc1N0YXJ0SW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scyksXHJcbiAgICAgICAgICBlbmQgPSBjaGFyc0VuZEluZGV4KHN0clN5bWJvbHMsIGNoclN5bWJvbHMpICsgMTtcclxuXHJcbiAgICAgIHJldHVybiBjYXN0U2xpY2Uoc3RyU3ltYm9scywgc3RhcnQsIGVuZCkuam9pbignJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHRyYWlsaW5nIHdoaXRlc3BhY2Ugb3Igc3BlY2lmaWVkIGNoYXJhY3RlcnMgZnJvbSBgc3RyaW5nYC5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDQuMC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cmltLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz13aGl0ZXNwYWNlXSBUaGUgY2hhcmFjdGVycyB0byB0cmltLlxyXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLnRyaW1FbmQoJyAgYWJjICAnKTtcclxuICAgICAqIC8vID0+ICcgIGFiYydcclxuICAgICAqXHJcbiAgICAgKiBfLnRyaW1FbmQoJy1fLWFiYy1fLScsICdfLScpO1xyXG4gICAgICogLy8gPT4gJy1fLWFiYydcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdHJpbUVuZChzdHJpbmcsIGNoYXJzLCBndWFyZCkge1xyXG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xyXG4gICAgICBpZiAoc3RyaW5nICYmIChndWFyZCB8fCBjaGFycyA9PT0gdW5kZWZpbmVkKSkge1xyXG4gICAgICAgIHJldHVybiBzdHJpbmcuc2xpY2UoMCwgdHJpbW1lZEVuZEluZGV4KHN0cmluZykgKyAxKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIXN0cmluZyB8fCAhKGNoYXJzID0gYmFzZVRvU3RyaW5nKGNoYXJzKSkpIHtcclxuICAgICAgICByZXR1cm4gc3RyaW5nO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBzdHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShzdHJpbmcpLFxyXG4gICAgICAgICAgZW5kID0gY2hhcnNFbmRJbmRleChzdHJTeW1ib2xzLCBzdHJpbmdUb0FycmF5KGNoYXJzKSkgKyAxO1xyXG5cclxuICAgICAgcmV0dXJuIGNhc3RTbGljZShzdHJTeW1ib2xzLCAwLCBlbmQpLmpvaW4oJycpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBsZWFkaW5nIHdoaXRlc3BhY2Ugb3Igc3BlY2lmaWVkIGNoYXJhY3RlcnMgZnJvbSBgc3RyaW5nYC5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDQuMC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cmltLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz13aGl0ZXNwYWNlXSBUaGUgY2hhcmFjdGVycyB0byB0cmltLlxyXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLnRyaW1TdGFydCgnICBhYmMgICcpO1xyXG4gICAgICogLy8gPT4gJ2FiYyAgJ1xyXG4gICAgICpcclxuICAgICAqIF8udHJpbVN0YXJ0KCctXy1hYmMtXy0nLCAnXy0nKTtcclxuICAgICAqIC8vID0+ICdhYmMtXy0nXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHRyaW1TdGFydChzdHJpbmcsIGNoYXJzLCBndWFyZCkge1xyXG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xyXG4gICAgICBpZiAoc3RyaW5nICYmIChndWFyZCB8fCBjaGFycyA9PT0gdW5kZWZpbmVkKSkge1xyXG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShyZVRyaW1TdGFydCwgJycpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghc3RyaW5nIHx8ICEoY2hhcnMgPSBiYXNlVG9TdHJpbmcoY2hhcnMpKSkge1xyXG4gICAgICAgIHJldHVybiBzdHJpbmc7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIHN0clN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KHN0cmluZyksXHJcbiAgICAgICAgICBzdGFydCA9IGNoYXJzU3RhcnRJbmRleChzdHJTeW1ib2xzLCBzdHJpbmdUb0FycmF5KGNoYXJzKSk7XHJcblxyXG4gICAgICByZXR1cm4gY2FzdFNsaWNlKHN0clN5bWJvbHMsIHN0YXJ0KS5qb2luKCcnKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRydW5jYXRlcyBgc3RyaW5nYCBpZiBpdCdzIGxvbmdlciB0aGFuIHRoZSBnaXZlbiBtYXhpbXVtIHN0cmluZyBsZW5ndGguXHJcbiAgICAgKiBUaGUgbGFzdCBjaGFyYWN0ZXJzIG9mIHRoZSB0cnVuY2F0ZWQgc3RyaW5nIGFyZSByZXBsYWNlZCB3aXRoIHRoZSBvbWlzc2lvblxyXG4gICAgICogc3RyaW5nIHdoaWNoIGRlZmF1bHRzIHRvIFwiLi4uXCIuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSA0LjAuMFxyXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJ1bmNhdGUuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5sZW5ndGg9MzBdIFRoZSBtYXhpbXVtIHN0cmluZyBsZW5ndGguXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMub21pc3Npb249Jy4uLiddIFRoZSBzdHJpbmcgdG8gaW5kaWNhdGUgdGV4dCBpcyBvbWl0dGVkLlxyXG4gICAgICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBbb3B0aW9ucy5zZXBhcmF0b3JdIFRoZSBzZXBhcmF0b3IgcGF0dGVybiB0byB0cnVuY2F0ZSB0by5cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRydW5jYXRlZCBzdHJpbmcuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8udHJ1bmNhdGUoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nKTtcclxuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm8uLi4nXHJcbiAgICAgKlxyXG4gICAgICogXy50cnVuY2F0ZSgnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycsIHtcclxuICAgICAqICAgJ2xlbmd0aCc6IDI0LFxyXG4gICAgICogICAnc2VwYXJhdG9yJzogJyAnXHJcbiAgICAgKiB9KTtcclxuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUsLi4uJ1xyXG4gICAgICpcclxuICAgICAqIF8udHJ1bmNhdGUoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nLCB7XHJcbiAgICAgKiAgICdsZW5ndGgnOiAyNCxcclxuICAgICAqICAgJ3NlcGFyYXRvcic6IC8sPyArL1xyXG4gICAgICogfSk7XHJcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLi4uJ1xyXG4gICAgICpcclxuICAgICAqIF8udHJ1bmNhdGUoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nLCB7XHJcbiAgICAgKiAgICdvbWlzc2lvbic6ICcgWy4uLl0nXHJcbiAgICAgKiB9KTtcclxuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWcgWy4uLl0nXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHRydW5jYXRlKHN0cmluZywgb3B0aW9ucykge1xyXG4gICAgICB2YXIgbGVuZ3RoID0gREVGQVVMVF9UUlVOQ19MRU5HVEgsXHJcbiAgICAgICAgICBvbWlzc2lvbiA9IERFRkFVTFRfVFJVTkNfT01JU1NJT047XHJcblxyXG4gICAgICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcclxuICAgICAgICB2YXIgc2VwYXJhdG9yID0gJ3NlcGFyYXRvcicgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc2VwYXJhdG9yIDogc2VwYXJhdG9yO1xyXG4gICAgICAgIGxlbmd0aCA9ICdsZW5ndGgnIGluIG9wdGlvbnMgPyB0b0ludGVnZXIob3B0aW9ucy5sZW5ndGgpIDogbGVuZ3RoO1xyXG4gICAgICAgIG9taXNzaW9uID0gJ29taXNzaW9uJyBpbiBvcHRpb25zID8gYmFzZVRvU3RyaW5nKG9wdGlvbnMub21pc3Npb24pIDogb21pc3Npb247XHJcbiAgICAgIH1cclxuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcclxuXHJcbiAgICAgIHZhciBzdHJMZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xyXG4gICAgICBpZiAoaGFzVW5pY29kZShzdHJpbmcpKSB7XHJcbiAgICAgICAgdmFyIHN0clN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KHN0cmluZyk7XHJcbiAgICAgICAgc3RyTGVuZ3RoID0gc3RyU3ltYm9scy5sZW5ndGg7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGxlbmd0aCA+PSBzdHJMZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gc3RyaW5nO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBlbmQgPSBsZW5ndGggLSBzdHJpbmdTaXplKG9taXNzaW9uKTtcclxuICAgICAgaWYgKGVuZCA8IDEpIHtcclxuICAgICAgICByZXR1cm4gb21pc3Npb247XHJcbiAgICAgIH1cclxuICAgICAgdmFyIHJlc3VsdCA9IHN0clN5bWJvbHNcclxuICAgICAgICA/IGNhc3RTbGljZShzdHJTeW1ib2xzLCAwLCBlbmQpLmpvaW4oJycpXHJcbiAgICAgICAgOiBzdHJpbmcuc2xpY2UoMCwgZW5kKTtcclxuXHJcbiAgICAgIGlmIChzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiByZXN1bHQgKyBvbWlzc2lvbjtcclxuICAgICAgfVxyXG4gICAgICBpZiAoc3RyU3ltYm9scykge1xyXG4gICAgICAgIGVuZCArPSAocmVzdWx0Lmxlbmd0aCAtIGVuZCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGlzUmVnRXhwKHNlcGFyYXRvcikpIHtcclxuICAgICAgICBpZiAoc3RyaW5nLnNsaWNlKGVuZCkuc2VhcmNoKHNlcGFyYXRvcikpIHtcclxuICAgICAgICAgIHZhciBtYXRjaCxcclxuICAgICAgICAgICAgICBzdWJzdHJpbmcgPSByZXN1bHQ7XHJcblxyXG4gICAgICAgICAgaWYgKCFzZXBhcmF0b3IuZ2xvYmFsKSB7XHJcbiAgICAgICAgICAgIHNlcGFyYXRvciA9IFJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLCB0b1N0cmluZyhyZUZsYWdzLmV4ZWMoc2VwYXJhdG9yKSkgKyAnZycpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgc2VwYXJhdG9yLmxhc3RJbmRleCA9IDA7XHJcbiAgICAgICAgICB3aGlsZSAoKG1hdGNoID0gc2VwYXJhdG9yLmV4ZWMoc3Vic3RyaW5nKSkpIHtcclxuICAgICAgICAgICAgdmFyIG5ld0VuZCA9IG1hdGNoLmluZGV4O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIG5ld0VuZCA9PT0gdW5kZWZpbmVkID8gZW5kIDogbmV3RW5kKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAoc3RyaW5nLmluZGV4T2YoYmFzZVRvU3RyaW5nKHNlcGFyYXRvciksIGVuZCkgIT0gZW5kKSB7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gcmVzdWx0Lmxhc3RJbmRleE9mKHNlcGFyYXRvcik7XHJcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcclxuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCBpbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByZXN1bHQgKyBvbWlzc2lvbjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBpbnZlcnNlIG9mIGBfLmVzY2FwZWA7IHRoaXMgbWV0aG9kIGNvbnZlcnRzIHRoZSBIVE1MIGVudGl0aWVzXHJcbiAgICAgKiBgJmFtcDtgLCBgJmx0O2AsIGAmZ3Q7YCwgYCZxdW90O2AsIGFuZCBgJiMzOTtgIGluIGBzdHJpbmdgIHRvXHJcbiAgICAgKiB0aGVpciBjb3JyZXNwb25kaW5nIGNoYXJhY3RlcnMuXHJcbiAgICAgKlxyXG4gICAgICogKipOb3RlOioqIE5vIG90aGVyIEhUTUwgZW50aXRpZXMgYXJlIHVuZXNjYXBlZC4gVG8gdW5lc2NhcGUgYWRkaXRpb25hbFxyXG4gICAgICogSFRNTCBlbnRpdGllcyB1c2UgYSB0aGlyZC1wYXJ0eSBsaWJyYXJ5IGxpa2UgW19oZV9dKGh0dHBzOi8vbXRocy5iZS9oZSkuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAwLjYuMFxyXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdW5lc2NhcGUuXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmVzY2FwZWQgc3RyaW5nLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLnVuZXNjYXBlKCdmcmVkLCBiYXJuZXksICZhbXA7IHBlYmJsZXMnKTtcclxuICAgICAqIC8vID0+ICdmcmVkLCBiYXJuZXksICYgcGViYmxlcydcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdW5lc2NhcGUoc3RyaW5nKSB7XHJcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XHJcbiAgICAgIHJldHVybiAoc3RyaW5nICYmIHJlSGFzRXNjYXBlZEh0bWwudGVzdChzdHJpbmcpKVxyXG4gICAgICAgID8gc3RyaW5nLnJlcGxhY2UocmVFc2NhcGVkSHRtbCwgdW5lc2NhcGVIdG1sQ2hhcilcclxuICAgICAgICA6IHN0cmluZztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgLCBhcyBzcGFjZSBzZXBhcmF0ZWQgd29yZHMsIHRvIHVwcGVyIGNhc2UuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSA0LjAuMFxyXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVwcGVyIGNhc2VkIHN0cmluZy5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogXy51cHBlckNhc2UoJy0tZm9vLWJhcicpO1xyXG4gICAgICogLy8gPT4gJ0ZPTyBCQVInXHJcbiAgICAgKlxyXG4gICAgICogXy51cHBlckNhc2UoJ2Zvb0JhcicpO1xyXG4gICAgICogLy8gPT4gJ0ZPTyBCQVInXHJcbiAgICAgKlxyXG4gICAgICogXy51cHBlckNhc2UoJ19fZm9vX2Jhcl9fJyk7XHJcbiAgICAgKiAvLyA9PiAnRk9PIEJBUidcclxuICAgICAqL1xyXG4gICAgdmFyIHVwcGVyQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xyXG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJyAnIDogJycpICsgd29yZC50b1VwcGVyQ2FzZSgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGBzdHJpbmdgIHRvIHVwcGVyIGNhc2UuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSA0LjAuMFxyXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8udXBwZXJGaXJzdCgnZnJlZCcpO1xyXG4gICAgICogLy8gPT4gJ0ZyZWQnXHJcbiAgICAgKlxyXG4gICAgICogXy51cHBlckZpcnN0KCdGUkVEJyk7XHJcbiAgICAgKiAvLyA9PiAnRlJFRCdcclxuICAgICAqL1xyXG4gICAgdmFyIHVwcGVyRmlyc3QgPSBjcmVhdGVDYXNlRmlyc3QoJ3RvVXBwZXJDYXNlJyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTcGxpdHMgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBpdHMgd29yZHMuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAzLjAuMFxyXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cclxuICAgICAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gW3BhdHRlcm5dIFRoZSBwYXR0ZXJuIHRvIG1hdGNoIHdvcmRzLlxyXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cclxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd29yZHMgb2YgYHN0cmluZ2AuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8ud29yZHMoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XHJcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnLCAnYmFybmV5JywgJ3BlYmJsZXMnXVxyXG4gICAgICpcclxuICAgICAqIF8ud29yZHMoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJywgL1teLCBdKy9nKTtcclxuICAgICAqIC8vID0+IFsnZnJlZCcsICdiYXJuZXknLCAnJicsICdwZWJibGVzJ11cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gd29yZHMoc3RyaW5nLCBwYXR0ZXJuLCBndWFyZCkge1xyXG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xyXG4gICAgICBwYXR0ZXJuID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBwYXR0ZXJuO1xyXG5cclxuICAgICAgaWYgKHBhdHRlcm4gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiBoYXNVbmljb2RlV29yZChzdHJpbmcpID8gdW5pY29kZVdvcmRzKHN0cmluZykgOiBhc2NpaVdvcmRzKHN0cmluZyk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHN0cmluZy5tYXRjaChwYXR0ZXJuKSB8fCBbXTtcclxuICAgIH1cclxuXHJcbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBdHRlbXB0cyB0byBpbnZva2UgYGZ1bmNgLCByZXR1cm5pbmcgZWl0aGVyIHRoZSByZXN1bHQgb3IgdGhlIGNhdWdodCBlcnJvclxyXG4gICAgICogb2JqZWN0LiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRvIGBmdW5jYCB3aGVuIGl0J3MgaW52b2tlZC5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDMuMC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXR0ZW1wdC5cclxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxyXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGBmdW5jYCByZXN1bHQgb3IgZXJyb3Igb2JqZWN0LlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiAvLyBBdm9pZCB0aHJvd2luZyBlcnJvcnMgZm9yIGludmFsaWQgc2VsZWN0b3JzLlxyXG4gICAgICogdmFyIGVsZW1lbnRzID0gXy5hdHRlbXB0KGZ1bmN0aW9uKHNlbGVjdG9yKSB7XHJcbiAgICAgKiAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcclxuICAgICAqIH0sICc+Xz4nKTtcclxuICAgICAqXHJcbiAgICAgKiBpZiAoXy5pc0Vycm9yKGVsZW1lbnRzKSkge1xyXG4gICAgICogICBlbGVtZW50cyA9IFtdO1xyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICB2YXIgYXR0ZW1wdCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIGFyZ3MpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gYXBwbHkoZnVuYywgdW5kZWZpbmVkLCBhcmdzKTtcclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIHJldHVybiBpc0Vycm9yKGUpID8gZSA6IG5ldyBFcnJvcihlKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCaW5kcyBtZXRob2RzIG9mIGFuIG9iamVjdCB0byB0aGUgb2JqZWN0IGl0c2VsZiwgb3ZlcndyaXRpbmcgdGhlIGV4aXN0aW5nXHJcbiAgICAgKiBtZXRob2QuXHJcbiAgICAgKlxyXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIGJvdW5kIGZ1bmN0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAc2luY2UgMC4xLjBcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGJpbmQgYW5kIGFzc2lnbiB0aGUgYm91bmQgbWV0aG9kcyB0by5cclxuICAgICAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IG1ldGhvZE5hbWVzIFRoZSBvYmplY3QgbWV0aG9kIG5hbWVzIHRvIGJpbmQuXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiB2YXIgdmlldyA9IHtcclxuICAgICAqICAgJ2xhYmVsJzogJ2RvY3MnLFxyXG4gICAgICogICAnY2xpY2snOiBmdW5jdGlvbigpIHtcclxuICAgICAqICAgICBjb25zb2xlLmxvZygnY2xpY2tlZCAnICsgdGhpcy5sYWJlbCk7XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH07XHJcbiAgICAgKlxyXG4gICAgICogXy5iaW5kQWxsKHZpZXcsIFsnY2xpY2snXSk7XHJcbiAgICAgKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgdmlldy5jbGljayk7XHJcbiAgICAgKiAvLyA9PiBMb2dzICdjbGlja2VkIGRvY3MnIHdoZW4gY2xpY2tlZC5cclxuICAgICAqL1xyXG4gICAgdmFyIGJpbmRBbGwgPSBmbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIG1ldGhvZE5hbWVzKSB7XHJcbiAgICAgIGFycmF5RWFjaChtZXRob2ROYW1lcywgZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgICAga2V5ID0gdG9LZXkoa2V5KTtcclxuICAgICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIGJpbmQob2JqZWN0W2tleV0sIG9iamVjdCkpO1xyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIG9iamVjdDtcclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaXRlcmF0ZXMgb3ZlciBgcGFpcnNgIGFuZCBpbnZva2VzIHRoZSBjb3JyZXNwb25kaW5nXHJcbiAgICAgKiBmdW5jdGlvbiBvZiB0aGUgZmlyc3QgcHJlZGljYXRlIHRvIHJldHVybiB0cnV0aHkuIFRoZSBwcmVkaWNhdGUtZnVuY3Rpb25cclxuICAgICAqIHBhaXJzIGFyZSBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHMgb2YgdGhlIGNyZWF0ZWRcclxuICAgICAqIGZ1bmN0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgNC4wLjBcclxuICAgICAqIEBjYXRlZ29yeSBVdGlsXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYWlycyBUaGUgcHJlZGljYXRlLWZ1bmN0aW9uIHBhaXJzLlxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG9zaXRlIGZ1bmN0aW9uLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiB2YXIgZnVuYyA9IF8uY29uZChbXHJcbiAgICAgKiAgIFtfLm1hdGNoZXMoeyAnYSc6IDEgfSksICAgICAgICAgICBfLmNvbnN0YW50KCdtYXRjaGVzIEEnKV0sXHJcbiAgICAgKiAgIFtfLmNvbmZvcm1zKHsgJ2InOiBfLmlzTnVtYmVyIH0pLCBfLmNvbnN0YW50KCdtYXRjaGVzIEInKV0sXHJcbiAgICAgKiAgIFtfLnN0dWJUcnVlLCAgICAgICAgICAgICAgICAgICAgICBfLmNvbnN0YW50KCdubyBtYXRjaCcpXVxyXG4gICAgICogXSk7XHJcbiAgICAgKlxyXG4gICAgICogZnVuYyh7ICdhJzogMSwgJ2InOiAyIH0pO1xyXG4gICAgICogLy8gPT4gJ21hdGNoZXMgQSdcclxuICAgICAqXHJcbiAgICAgKiBmdW5jKHsgJ2EnOiAwLCAnYic6IDEgfSk7XHJcbiAgICAgKiAvLyA9PiAnbWF0Y2hlcyBCJ1xyXG4gICAgICpcclxuICAgICAqIGZ1bmMoeyAnYSc6ICcxJywgJ2InOiAnMicgfSk7XHJcbiAgICAgKiAvLyA9PiAnbm8gbWF0Y2gnXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNvbmQocGFpcnMpIHtcclxuICAgICAgdmFyIGxlbmd0aCA9IHBhaXJzID09IG51bGwgPyAwIDogcGFpcnMubGVuZ3RoLFxyXG4gICAgICAgICAgdG9JdGVyYXRlZSA9IGdldEl0ZXJhdGVlKCk7XHJcblxyXG4gICAgICBwYWlycyA9ICFsZW5ndGggPyBbXSA6IGFycmF5TWFwKHBhaXJzLCBmdW5jdGlvbihwYWlyKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBwYWlyWzFdICE9ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFt0b0l0ZXJhdGVlKHBhaXJbMF0pLCBwYWlyWzFdXTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xyXG4gICAgICAgIHZhciBpbmRleCA9IC0xO1xyXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgICB2YXIgcGFpciA9IHBhaXJzW2luZGV4XTtcclxuICAgICAgICAgIGlmIChhcHBseShwYWlyWzBdLCB0aGlzLCBhcmdzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXBwbHkocGFpclsxXSwgdGhpcywgYXJncyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIHByZWRpY2F0ZSBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHdpdGhcclxuICAgICAqIHRoZSBjb3JyZXNwb25kaW5nIHByb3BlcnR5IHZhbHVlcyBvZiBhIGdpdmVuIG9iamVjdCwgcmV0dXJuaW5nIGB0cnVlYCBpZlxyXG4gICAgICogYWxsIHByZWRpY2F0ZXMgcmV0dXJuIHRydXRoeSwgZWxzZSBgZmFsc2VgLlxyXG4gICAgICpcclxuICAgICAqICoqTm90ZToqKiBUaGUgY3JlYXRlZCBmdW5jdGlvbiBpcyBlcXVpdmFsZW50IHRvIGBfLmNvbmZvcm1zVG9gIHdpdGhcclxuICAgICAqIGBzb3VyY2VgIHBhcnRpYWxseSBhcHBsaWVkLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgNC4wLjBcclxuICAgICAqIEBjYXRlZ29yeSBVdGlsXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgcHJlZGljYXRlcyB0byBjb25mb3JtIHRvLlxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogdmFyIG9iamVjdHMgPSBbXHJcbiAgICAgKiAgIHsgJ2EnOiAyLCAnYic6IDEgfSxcclxuICAgICAqICAgeyAnYSc6IDEsICdiJzogMiB9XHJcbiAgICAgKiBdO1xyXG4gICAgICpcclxuICAgICAqIF8uZmlsdGVyKG9iamVjdHMsIF8uY29uZm9ybXMoeyAnYic6IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gPiAxOyB9IH0pKTtcclxuICAgICAqIC8vID0+IFt7ICdhJzogMSwgJ2InOiAyIH1dXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNvbmZvcm1zKHNvdXJjZSkge1xyXG4gICAgICByZXR1cm4gYmFzZUNvbmZvcm1zKGJhc2VDbG9uZShzb3VyY2UsIENMT05FX0RFRVBfRkxBRykpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgMi40LjBcclxuICAgICAqIEBjYXRlZ29yeSBVdGlsXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29uc3RhbnQgZnVuY3Rpb24uXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLmNvbnN0YW50KHsgJ2EnOiAxIH0pKTtcclxuICAgICAqXHJcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcclxuICAgICAqIC8vID0+IFt7ICdhJzogMSB9LCB7ICdhJzogMSB9XVxyXG4gICAgICpcclxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xyXG4gICAgICogLy8gPT4gdHJ1ZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGB2YWx1ZWAgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBkZWZhdWx0IHZhbHVlIHNob3VsZCBiZSByZXR1cm5lZCBpblxyXG4gICAgICogaXRzIHBsYWNlLiBUaGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaWYgYHZhbHVlYCBpcyBgTmFOYCwgYG51bGxgLFxyXG4gICAgICogb3IgYHVuZGVmaW5lZGAuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSA0LjE0LjBcclxuICAgICAqIEBjYXRlZ29yeSBVdGlsXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICAgICAqIEBwYXJhbSB7Kn0gZGVmYXVsdFZhbHVlIFRoZSBkZWZhdWx0IHZhbHVlLlxyXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLmRlZmF1bHRUbygxLCAxMCk7XHJcbiAgICAgKiAvLyA9PiAxXHJcbiAgICAgKlxyXG4gICAgICogXy5kZWZhdWx0VG8odW5kZWZpbmVkLCAxMCk7XHJcbiAgICAgKiAvLyA9PiAxMFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBkZWZhdWx0VG8odmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgICByZXR1cm4gKHZhbHVlID09IG51bGwgfHwgdmFsdWUgIT09IHZhbHVlKSA/IGRlZmF1bHRWYWx1ZSA6IHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgcmVzdWx0IG9mIGludm9raW5nIHRoZSBnaXZlbiBmdW5jdGlvbnNcclxuICAgICAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLCB3aGVyZSBlYWNoIHN1Y2Nlc3NpdmVcclxuICAgICAqIGludm9jYXRpb24gaXMgc3VwcGxpZWQgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAzLjAuMFxyXG4gICAgICogQGNhdGVnb3J5IFV0aWxcclxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbZnVuY3NdIFRoZSBmdW5jdGlvbnMgdG8gaW52b2tlLlxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG9zaXRlIGZ1bmN0aW9uLlxyXG4gICAgICogQHNlZSBfLmZsb3dSaWdodFxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xyXG4gICAgICogICByZXR1cm4gbiAqIG47XHJcbiAgICAgKiB9XHJcbiAgICAgKlxyXG4gICAgICogdmFyIGFkZFNxdWFyZSA9IF8uZmxvdyhbXy5hZGQsIHNxdWFyZV0pO1xyXG4gICAgICogYWRkU3F1YXJlKDEsIDIpO1xyXG4gICAgICogLy8gPT4gOVxyXG4gICAgICovXHJcbiAgICB2YXIgZmxvdyA9IGNyZWF0ZUZsb3coKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmxvd2AgZXhjZXB0IHRoYXQgaXQgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXRcclxuICAgICAqIGludm9rZXMgdGhlIGdpdmVuIGZ1bmN0aW9ucyBmcm9tIHJpZ2h0IHRvIGxlZnQuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHNpbmNlIDMuMC4wXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQGNhdGVnb3J5IFV0aWxcclxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbZnVuY3NdIFRoZSBmdW5jdGlvbnMgdG8gaW52b2tlLlxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG9zaXRlIGZ1bmN0aW9uLlxyXG4gICAgICogQHNlZSBfLmZsb3dcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcclxuICAgICAqICAgcmV0dXJuIG4gKiBuO1xyXG4gICAgICogfVxyXG4gICAgICpcclxuICAgICAqIHZhciBhZGRTcXVhcmUgPSBfLmZsb3dSaWdodChbc3F1YXJlLCBfLmFkZF0pO1xyXG4gICAgICogYWRkU3F1YXJlKDEsIDIpO1xyXG4gICAgICogLy8gPT4gOVxyXG4gICAgICovXHJcbiAgICB2YXIgZmxvd1JpZ2h0ID0gY3JlYXRlRmxvdyh0cnVlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBzaW5jZSAwLjEuMFxyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBjYXRlZ29yeSBVdGlsXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cclxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xyXG4gICAgICpcclxuICAgICAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcclxuICAgICAqIC8vID0+IHRydWVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcclxuICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYXJndW1lbnRzIG9mIHRoZSBjcmVhdGVkXHJcbiAgICAgKiBmdW5jdGlvbi4gSWYgYGZ1bmNgIGlzIGEgcHJvcGVydHkgbmFtZSwgdGhlIGNyZWF0ZWQgZnVuY3Rpb24gcmV0dXJucyB0aGVcclxuICAgICAqIHByb3BlcnR5IHZhbHVlIGZvciBhIGdpdmVuIGVsZW1lbnQuIElmIGBmdW5jYCBpcyBhbiBhcnJheSBvciBvYmplY3QsIHRoZVxyXG4gICAgICogY3JlYXRlZCBmdW5jdGlvbiByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBjb250YWluIHRoZSBlcXVpdmFsZW50XHJcbiAgICAgKiBzb3VyY2UgcHJvcGVydGllcywgb3RoZXJ3aXNlIGl0IHJldHVybnMgYGZhbHNlYC5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAc2luY2UgNC4wLjBcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxyXG4gICAgICogQHBhcmFtIHsqfSBbZnVuYz1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhIGNhbGxiYWNrLlxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjYWxsYmFjay5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogdmFyIHVzZXJzID0gW1xyXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcclxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XHJcbiAgICAgKiBdO1xyXG4gICAgICpcclxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXHJcbiAgICAgKiBfLmZpbHRlcih1c2VycywgXy5pdGVyYXRlZSh7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiB0cnVlIH0pKTtcclxuICAgICAqIC8vID0+IFt7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfV1cclxuICAgICAqXHJcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXHJcbiAgICAgKiBfLmZpbHRlcih1c2VycywgXy5pdGVyYXRlZShbJ3VzZXInLCAnZnJlZCddKSk7XHJcbiAgICAgKiAvLyA9PiBbeyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH1dXHJcbiAgICAgKlxyXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXHJcbiAgICAgKiBfLm1hcCh1c2VycywgXy5pdGVyYXRlZSgndXNlcicpKTtcclxuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxyXG4gICAgICpcclxuICAgICAqIC8vIENyZWF0ZSBjdXN0b20gaXRlcmF0ZWUgc2hvcnRoYW5kcy5cclxuICAgICAqIF8uaXRlcmF0ZWUgPSBfLndyYXAoXy5pdGVyYXRlZSwgZnVuY3Rpb24oaXRlcmF0ZWUsIGZ1bmMpIHtcclxuICAgICAqICAgcmV0dXJuICFfLmlzUmVnRXhwKGZ1bmMpID8gaXRlcmF0ZWUoZnVuYykgOiBmdW5jdGlvbihzdHJpbmcpIHtcclxuICAgICAqICAgICByZXR1cm4gZnVuYy50ZXN0KHN0cmluZyk7XHJcbiAgICAgKiAgIH07XHJcbiAgICAgKiB9KTtcclxuICAgICAqXHJcbiAgICAgKiBfLmZpbHRlcihbJ2FiYycsICdkZWYnXSwgL2VmLyk7XHJcbiAgICAgKiAvLyA9PiBbJ2RlZiddXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGl0ZXJhdGVlKGZ1bmMpIHtcclxuICAgICAgcmV0dXJuIGJhc2VJdGVyYXRlZSh0eXBlb2YgZnVuYyA9PSAnZnVuY3Rpb24nID8gZnVuYyA6IGJhc2VDbG9uZShmdW5jLCBDTE9ORV9ERUVQX0ZMQUcpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIGEgcGFydGlhbCBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiBhIGdpdmVuXHJcbiAgICAgKiBvYmplY3QgYW5kIGBzb3VyY2VgLCByZXR1cm5pbmcgYHRydWVgIGlmIHRoZSBnaXZlbiBvYmplY3QgaGFzIGVxdWl2YWxlbnRcclxuICAgICAqIHByb3BlcnR5IHZhbHVlcywgZWxzZSBgZmFsc2VgLlxyXG4gICAgICpcclxuICAgICAqICoqTm90ZToqKiBUaGUgY3JlYXRlZCBmdW5jdGlvbiBpcyBlcXVpdmFsZW50IHRvIGBfLmlzTWF0Y2hgIHdpdGggYHNvdXJjZWBcclxuICAgICAqIHBhcnRpYWxseSBhcHBsaWVkLlxyXG4gICAgICpcclxuICAgICAqIFBhcnRpYWwgY29tcGFyaXNvbnMgd2lsbCBtYXRjaCBlbXB0eSBhcnJheSBhbmQgZW1wdHkgb2JqZWN0IGBzb3VyY2VgXHJcbiAgICAgKiB2YWx1ZXMgYWdhaW5zdCBhbnkgYXJyYXkgb3Igb2JqZWN0IHZhbHVlLCByZXNwZWN0aXZlbHkuIFNlZSBgXy5pc0VxdWFsYFxyXG4gICAgICogZm9yIGEgbGlzdCBvZiBzdXBwb3J0ZWQgdmFsdWUgY29tcGFyaXNvbnMuXHJcbiAgICAgKlxyXG4gICAgICogKipOb3RlOioqIE11bHRpcGxlIHZhbHVlcyBjYW4gYmUgY2hlY2tlZCBieSBjb21iaW5pbmcgc2V2ZXJhbCBtYXRjaGVyc1xyXG4gICAgICogdXNpbmcgYF8ub3ZlclNvbWVgXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAzLjAuMFxyXG4gICAgICogQGNhdGVnb3J5IFV0aWxcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXHJcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcclxuICAgICAqICAgeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH0sXHJcbiAgICAgKiAgIHsgJ2EnOiA0LCAnYic6IDUsICdjJzogNiB9XHJcbiAgICAgKiBdO1xyXG4gICAgICpcclxuICAgICAqIF8uZmlsdGVyKG9iamVjdHMsIF8ubWF0Y2hlcyh7ICdhJzogNCwgJ2MnOiA2IH0pKTtcclxuICAgICAqIC8vID0+IFt7ICdhJzogNCwgJ2InOiA1LCAnYyc6IDYgfV1cclxuICAgICAqXHJcbiAgICAgKiAvLyBDaGVja2luZyBmb3Igc2V2ZXJhbCBwb3NzaWJsZSB2YWx1ZXNcclxuICAgICAqIF8uZmlsdGVyKG9iamVjdHMsIF8ub3ZlclNvbWUoW18ubWF0Y2hlcyh7ICdhJzogMSB9KSwgXy5tYXRjaGVzKHsgJ2EnOiA0IH0pXSkpO1xyXG4gICAgICogLy8gPT4gW3sgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9LCB7ICdhJzogNCwgJ2InOiA1LCAnYyc6IDYgfV1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gbWF0Y2hlcyhzb3VyY2UpIHtcclxuICAgICAgcmV0dXJuIGJhc2VNYXRjaGVzKGJhc2VDbG9uZShzb3VyY2UsIENMT05FX0RFRVBfRkxBRykpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgYSBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIHRoZVxyXG4gICAgICogdmFsdWUgYXQgYHBhdGhgIG9mIGEgZ2l2ZW4gb2JqZWN0IHRvIGBzcmNWYWx1ZWAsIHJldHVybmluZyBgdHJ1ZWAgaWYgdGhlXHJcbiAgICAgKiBvYmplY3QgdmFsdWUgaXMgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxyXG4gICAgICpcclxuICAgICAqICoqTm90ZToqKiBQYXJ0aWFsIGNvbXBhcmlzb25zIHdpbGwgbWF0Y2ggZW1wdHkgYXJyYXkgYW5kIGVtcHR5IG9iamVjdFxyXG4gICAgICogYHNyY1ZhbHVlYCB2YWx1ZXMgYWdhaW5zdCBhbnkgYXJyYXkgb3Igb2JqZWN0IHZhbHVlLCByZXNwZWN0aXZlbHkuIFNlZVxyXG4gICAgICogYF8uaXNFcXVhbGAgZm9yIGEgbGlzdCBvZiBzdXBwb3J0ZWQgdmFsdWUgY29tcGFyaXNvbnMuXHJcbiAgICAgKlxyXG4gICAgICogKipOb3RlOioqIE11bHRpcGxlIHZhbHVlcyBjYW4gYmUgY2hlY2tlZCBieSBjb21iaW5pbmcgc2V2ZXJhbCBtYXRjaGVyc1xyXG4gICAgICogdXNpbmcgYF8ub3ZlclNvbWVgXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAzLjIuMFxyXG4gICAgICogQGNhdGVnb3J5IFV0aWxcclxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXHJcbiAgICAgKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cclxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIHZhciBvYmplY3RzID0gW1xyXG4gICAgICogICB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfSxcclxuICAgICAqICAgeyAnYSc6IDQsICdiJzogNSwgJ2MnOiA2IH1cclxuICAgICAqIF07XHJcbiAgICAgKlxyXG4gICAgICogXy5maW5kKG9iamVjdHMsIF8ubWF0Y2hlc1Byb3BlcnR5KCdhJywgNCkpO1xyXG4gICAgICogLy8gPT4geyAnYSc6IDQsICdiJzogNSwgJ2MnOiA2IH1cclxuICAgICAqXHJcbiAgICAgKiAvLyBDaGVja2luZyBmb3Igc2V2ZXJhbCBwb3NzaWJsZSB2YWx1ZXNcclxuICAgICAqIF8uZmlsdGVyKG9iamVjdHMsIF8ub3ZlclNvbWUoW18ubWF0Y2hlc1Byb3BlcnR5KCdhJywgMSksIF8ubWF0Y2hlc1Byb3BlcnR5KCdhJywgNCldKSk7XHJcbiAgICAgKiAvLyA9PiBbeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH0sIHsgJ2EnOiA0LCAnYic6IDUsICdjJzogNiB9XVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBtYXRjaGVzUHJvcGVydHkocGF0aCwgc3JjVmFsdWUpIHtcclxuICAgICAgcmV0dXJuIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgYmFzZUNsb25lKHNyY1ZhbHVlLCBDTE9ORV9ERUVQX0ZMQUcpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIG1ldGhvZCBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXHJcbiAgICAgKiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRvIHRoZSBpbnZva2VkIG1ldGhvZC5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDMuNy4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxyXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIG1ldGhvZCB0byBpbnZva2UuXHJcbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXHJcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBpbnZva2VyIGZ1bmN0aW9uLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcclxuICAgICAqICAgeyAnYSc6IHsgJ2InOiBfLmNvbnN0YW50KDIpIH0gfSxcclxuICAgICAqICAgeyAnYSc6IHsgJ2InOiBfLmNvbnN0YW50KDEpIH0gfVxyXG4gICAgICogXTtcclxuICAgICAqXHJcbiAgICAgKiBfLm1hcChvYmplY3RzLCBfLm1ldGhvZCgnYS5iJykpO1xyXG4gICAgICogLy8gPT4gWzIsIDFdXHJcbiAgICAgKlxyXG4gICAgICogXy5tYXAob2JqZWN0cywgXy5tZXRob2QoWydhJywgJ2InXSkpO1xyXG4gICAgICogLy8gPT4gWzIsIDFdXHJcbiAgICAgKi9cclxuICAgIHZhciBtZXRob2QgPSBiYXNlUmVzdChmdW5jdGlvbihwYXRoLCBhcmdzKSB7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcclxuICAgICAgICByZXR1cm4gYmFzZUludm9rZShvYmplY3QsIHBhdGgsIGFyZ3MpO1xyXG4gICAgICB9O1xyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ubWV0aG9kYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlc1xyXG4gICAgICogdGhlIG1ldGhvZCBhdCBhIGdpdmVuIHBhdGggb2YgYG9iamVjdGAuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmVcclxuICAgICAqIHByb3ZpZGVkIHRvIHRoZSBpbnZva2VkIG1ldGhvZC5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDMuNy4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxyXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgaW52b2tlciBmdW5jdGlvbi5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogdmFyIGFycmF5ID0gXy50aW1lcygzLCBfLmNvbnN0YW50KSxcclxuICAgICAqICAgICBvYmplY3QgPSB7ICdhJzogYXJyYXksICdiJzogYXJyYXksICdjJzogYXJyYXkgfTtcclxuICAgICAqXHJcbiAgICAgKiBfLm1hcChbJ2FbMl0nLCAnY1swXSddLCBfLm1ldGhvZE9mKG9iamVjdCkpO1xyXG4gICAgICogLy8gPT4gWzIsIDBdXHJcbiAgICAgKlxyXG4gICAgICogXy5tYXAoW1snYScsICcyJ10sIFsnYycsICcwJ11dLCBfLm1ldGhvZE9mKG9iamVjdCkpO1xyXG4gICAgICogLy8gPT4gWzIsIDBdXHJcbiAgICAgKi9cclxuICAgIHZhciBtZXRob2RPZiA9IGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgYXJncykge1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24ocGF0aCkge1xyXG4gICAgICAgIHJldHVybiBiYXNlSW52b2tlKG9iamVjdCwgcGF0aCwgYXJncyk7XHJcbiAgICAgIH07XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYWxsIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBmdW5jdGlvbiBwcm9wZXJ0aWVzIG9mIGEgc291cmNlXHJcbiAgICAgKiBvYmplY3QgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC4gSWYgYG9iamVjdGAgaXMgYSBmdW5jdGlvbiwgdGhlbiBtZXRob2RzXHJcbiAgICAgKiBhcmUgYWRkZWQgdG8gaXRzIHByb3RvdHlwZSBhcyB3ZWxsLlxyXG4gICAgICpcclxuICAgICAqICoqTm90ZToqKiBVc2UgYF8ucnVuSW5Db250ZXh0YCB0byBjcmVhdGUgYSBwcmlzdGluZSBgbG9kYXNoYCBmdW5jdGlvbiB0b1xyXG4gICAgICogYXZvaWQgY29uZmxpY3RzIGNhdXNlZCBieSBtb2RpZnlpbmcgdGhlIG9yaWdpbmFsLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBzaW5jZSAwLjEuMFxyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBjYXRlZ29yeSBVdGlsXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdH0gW29iamVjdD1sb2Rhc2hdIFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgZnVuY3Rpb25zIHRvIGFkZC5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGFpbj10cnVlXSBTcGVjaWZ5IHdoZXRoZXIgbWl4aW5zIGFyZSBjaGFpbmFibGUuXHJcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb258T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBmdW5jdGlvbiB2b3dlbHMoc3RyaW5nKSB7XHJcbiAgICAgKiAgIHJldHVybiBfLmZpbHRlcihzdHJpbmcsIGZ1bmN0aW9uKHYpIHtcclxuICAgICAqICAgICByZXR1cm4gL1thZWlvdV0vaS50ZXN0KHYpO1xyXG4gICAgICogICB9KTtcclxuICAgICAqIH1cclxuICAgICAqXHJcbiAgICAgKiBfLm1peGluKHsgJ3Zvd2Vscyc6IHZvd2VscyB9KTtcclxuICAgICAqIF8udm93ZWxzKCdmcmVkJyk7XHJcbiAgICAgKiAvLyA9PiBbJ2UnXVxyXG4gICAgICpcclxuICAgICAqIF8oJ2ZyZWQnKS52b3dlbHMoKS52YWx1ZSgpO1xyXG4gICAgICogLy8gPT4gWydlJ11cclxuICAgICAqXHJcbiAgICAgKiBfLm1peGluKHsgJ3Zvd2Vscyc6IHZvd2VscyB9LCB7ICdjaGFpbic6IGZhbHNlIH0pO1xyXG4gICAgICogXygnZnJlZCcpLnZvd2VscygpO1xyXG4gICAgICogLy8gPT4gWydlJ11cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gbWl4aW4ob2JqZWN0LCBzb3VyY2UsIG9wdGlvbnMpIHtcclxuICAgICAgdmFyIHByb3BzID0ga2V5cyhzb3VyY2UpLFxyXG4gICAgICAgICAgbWV0aG9kTmFtZXMgPSBiYXNlRnVuY3Rpb25zKHNvdXJjZSwgcHJvcHMpO1xyXG5cclxuICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCAmJlxyXG4gICAgICAgICAgIShpc09iamVjdChzb3VyY2UpICYmIChtZXRob2ROYW1lcy5sZW5ndGggfHwgIXByb3BzLmxlbmd0aCkpKSB7XHJcbiAgICAgICAgb3B0aW9ucyA9IHNvdXJjZTtcclxuICAgICAgICBzb3VyY2UgPSBvYmplY3Q7XHJcbiAgICAgICAgb2JqZWN0ID0gdGhpcztcclxuICAgICAgICBtZXRob2ROYW1lcyA9IGJhc2VGdW5jdGlvbnMoc291cmNlLCBrZXlzKHNvdXJjZSkpO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBjaGFpbiA9ICEoaXNPYmplY3Qob3B0aW9ucykgJiYgJ2NoYWluJyBpbiBvcHRpb25zKSB8fCAhIW9wdGlvbnMuY2hhaW4sXHJcbiAgICAgICAgICBpc0Z1bmMgPSBpc0Z1bmN0aW9uKG9iamVjdCk7XHJcblxyXG4gICAgICBhcnJheUVhY2gobWV0aG9kTmFtZXMsIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcclxuICAgICAgICB2YXIgZnVuYyA9IHNvdXJjZVttZXRob2ROYW1lXTtcclxuICAgICAgICBvYmplY3RbbWV0aG9kTmFtZV0gPSBmdW5jO1xyXG4gICAgICAgIGlmIChpc0Z1bmMpIHtcclxuICAgICAgICAgIG9iamVjdC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGNoYWluQWxsID0gdGhpcy5fX2NoYWluX187XHJcbiAgICAgICAgICAgIGlmIChjaGFpbiB8fCBjaGFpbkFsbCkge1xyXG4gICAgICAgICAgICAgIHZhciByZXN1bHQgPSBvYmplY3QodGhpcy5fX3dyYXBwZWRfXyksXHJcbiAgICAgICAgICAgICAgICAgIGFjdGlvbnMgPSByZXN1bHQuX19hY3Rpb25zX18gPSBjb3B5QXJyYXkodGhpcy5fX2FjdGlvbnNfXyk7XHJcblxyXG4gICAgICAgICAgICAgIGFjdGlvbnMucHVzaCh7ICdmdW5jJzogZnVuYywgJ2FyZ3MnOiBhcmd1bWVudHMsICd0aGlzQXJnJzogb2JqZWN0IH0pO1xyXG4gICAgICAgICAgICAgIHJlc3VsdC5fX2NoYWluX18gPSBjaGFpbkFsbDtcclxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KG9iamVjdCwgYXJyYXlQdXNoKFt0aGlzLnZhbHVlKCldLCBhcmd1bWVudHMpKTtcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHJldHVybiBvYmplY3Q7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXZlcnRzIHRoZSBgX2AgdmFyaWFibGUgdG8gaXRzIHByZXZpb3VzIHZhbHVlIGFuZCByZXR1cm5zIGEgcmVmZXJlbmNlIHRvXHJcbiAgICAgKiB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHNpbmNlIDAuMS4wXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQGNhdGVnb3J5IFV0aWxcclxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIHZhciBsb2Rhc2ggPSBfLm5vQ29uZmxpY3QoKTtcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gbm9Db25mbGljdCgpIHtcclxuICAgICAgaWYgKHJvb3QuXyA9PT0gdGhpcykge1xyXG4gICAgICAgIHJvb3QuXyA9IG9sZERhc2g7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGB1bmRlZmluZWRgLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgMi4zLjBcclxuICAgICAqIEBjYXRlZ29yeSBVdGlsXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8udGltZXMoMiwgXy5ub29wKTtcclxuICAgICAqIC8vID0+IFt1bmRlZmluZWQsIHVuZGVmaW5lZF1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gbm9vcCgpIHtcclxuICAgICAgLy8gTm8gb3BlcmF0aW9uIHBlcmZvcm1lZC5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGdldHMgdGhlIGFyZ3VtZW50IGF0IGluZGV4IGBuYC4gSWYgYG5gIGlzIG5lZ2F0aXZlLFxyXG4gICAgICogdGhlIG50aCBhcmd1bWVudCBmcm9tIHRoZSBlbmQgaXMgcmV0dXJuZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSA0LjAuMFxyXG4gICAgICogQGNhdGVnb3J5IFV0aWxcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0wXSBUaGUgaW5kZXggb2YgdGhlIGFyZ3VtZW50IHRvIHJldHVybi5cclxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhc3MtdGhydSBmdW5jdGlvbi5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogdmFyIGZ1bmMgPSBfLm50aEFyZygxKTtcclxuICAgICAqIGZ1bmMoJ2EnLCAnYicsICdjJywgJ2QnKTtcclxuICAgICAqIC8vID0+ICdiJ1xyXG4gICAgICpcclxuICAgICAqIHZhciBmdW5jID0gXy5udGhBcmcoLTIpO1xyXG4gICAgICogZnVuYygnYScsICdiJywgJ2MnLCAnZCcpO1xyXG4gICAgICogLy8gPT4gJ2MnXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG50aEFyZyhuKSB7XHJcbiAgICAgIG4gPSB0b0ludGVnZXIobik7XHJcbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XHJcbiAgICAgICAgcmV0dXJuIGJhc2VOdGgoYXJncywgbik7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgaXRlcmF0ZWVzYCB3aXRoIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXNcclxuICAgICAqIGFuZCByZXR1cm5zIHRoZWlyIHJlc3VsdHMuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSA0LjAuMFxyXG4gICAgICogQGNhdGVnb3J5IFV0aWxcclxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbaXRlcmF0ZWVzPVtfLmlkZW50aXR5XV1cclxuICAgICAqICBUaGUgaXRlcmF0ZWVzIHRvIGludm9rZS5cclxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiB2YXIgZnVuYyA9IF8ub3ZlcihbTWF0aC5tYXgsIE1hdGgubWluXSk7XHJcbiAgICAgKlxyXG4gICAgICogZnVuYygxLCAyLCAzLCA0KTtcclxuICAgICAqIC8vID0+IFs0LCAxXVxyXG4gICAgICovXHJcbiAgICB2YXIgb3ZlciA9IGNyZWF0ZU92ZXIoYXJyYXlNYXApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmICoqYWxsKiogb2YgdGhlIGBwcmVkaWNhdGVzYCByZXR1cm5cclxuICAgICAqIHRydXRoeSB3aGVuIGludm9rZWQgd2l0aCB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxyXG4gICAgICpcclxuICAgICAqIEZvbGxvd2luZyBzaG9ydGhhbmRzIGFyZSBwb3NzaWJsZSBmb3IgcHJvdmlkaW5nIHByZWRpY2F0ZXMuXHJcbiAgICAgKiBQYXNzIGFuIGBPYmplY3RgIGFuZCBpdCB3aWxsIGJlIHVzZWQgYXMgYW4gcGFyYW1ldGVyIGZvciBgXy5tYXRjaGVzYCB0byBjcmVhdGUgdGhlIHByZWRpY2F0ZS5cclxuICAgICAqIFBhc3MgYW4gYEFycmF5YCBvZiBwYXJhbWV0ZXJzIGZvciBgXy5tYXRjaGVzUHJvcGVydHlgIGFuZCB0aGUgcHJlZGljYXRlIHdpbGwgYmUgY3JlYXRlZCB1c2luZyB0aGVtLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgNC4wLjBcclxuICAgICAqIEBjYXRlZ29yeSBVdGlsXHJcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW3ByZWRpY2F0ZXM9W18uaWRlbnRpdHldXVxyXG4gICAgICogIFRoZSBwcmVkaWNhdGVzIHRvIGNoZWNrLlxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIHZhciBmdW5jID0gXy5vdmVyRXZlcnkoW0Jvb2xlYW4sIGlzRmluaXRlXSk7XHJcbiAgICAgKlxyXG4gICAgICogZnVuYygnMScpO1xyXG4gICAgICogLy8gPT4gdHJ1ZVxyXG4gICAgICpcclxuICAgICAqIGZ1bmMobnVsbCk7XHJcbiAgICAgKiAvLyA9PiBmYWxzZVxyXG4gICAgICpcclxuICAgICAqIGZ1bmMoTmFOKTtcclxuICAgICAqIC8vID0+IGZhbHNlXHJcbiAgICAgKi9cclxuICAgIHZhciBvdmVyRXZlcnkgPSBjcmVhdGVPdmVyKGFycmF5RXZlcnkpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmICoqYW55Kiogb2YgdGhlIGBwcmVkaWNhdGVzYCByZXR1cm5cclxuICAgICAqIHRydXRoeSB3aGVuIGludm9rZWQgd2l0aCB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxyXG4gICAgICpcclxuICAgICAqIEZvbGxvd2luZyBzaG9ydGhhbmRzIGFyZSBwb3NzaWJsZSBmb3IgcHJvdmlkaW5nIHByZWRpY2F0ZXMuXHJcbiAgICAgKiBQYXNzIGFuIGBPYmplY3RgIGFuZCBpdCB3aWxsIGJlIHVzZWQgYXMgYW4gcGFyYW1ldGVyIGZvciBgXy5tYXRjaGVzYCB0byBjcmVhdGUgdGhlIHByZWRpY2F0ZS5cclxuICAgICAqIFBhc3MgYW4gYEFycmF5YCBvZiBwYXJhbWV0ZXJzIGZvciBgXy5tYXRjaGVzUHJvcGVydHlgIGFuZCB0aGUgcHJlZGljYXRlIHdpbGwgYmUgY3JlYXRlZCB1c2luZyB0aGVtLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgNC4wLjBcclxuICAgICAqIEBjYXRlZ29yeSBVdGlsXHJcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW3ByZWRpY2F0ZXM9W18uaWRlbnRpdHldXVxyXG4gICAgICogIFRoZSBwcmVkaWNhdGVzIHRvIGNoZWNrLlxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIHZhciBmdW5jID0gXy5vdmVyU29tZShbQm9vbGVhbiwgaXNGaW5pdGVdKTtcclxuICAgICAqXHJcbiAgICAgKiBmdW5jKCcxJyk7XHJcbiAgICAgKiAvLyA9PiB0cnVlXHJcbiAgICAgKlxyXG4gICAgICogZnVuYyhudWxsKTtcclxuICAgICAqIC8vID0+IHRydWVcclxuICAgICAqXHJcbiAgICAgKiBmdW5jKE5hTik7XHJcbiAgICAgKiAvLyA9PiBmYWxzZVxyXG4gICAgICpcclxuICAgICAqIHZhciBtYXRjaGVzRnVuYyA9IF8ub3ZlclNvbWUoW3sgJ2EnOiAxIH0sIHsgJ2EnOiAyIH1dKVxyXG4gICAgICogdmFyIG1hdGNoZXNQcm9wZXJ0eUZ1bmMgPSBfLm92ZXJTb21lKFtbJ2EnLCAxXSwgWydhJywgMl1dKVxyXG4gICAgICovXHJcbiAgICB2YXIgb3ZlclNvbWUgPSBjcmVhdGVPdmVyKGFycmF5U29tZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAyLjQuMFxyXG4gICAgICogQGNhdGVnb3J5IFV0aWxcclxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXHJcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogdmFyIG9iamVjdHMgPSBbXHJcbiAgICAgKiAgIHsgJ2EnOiB7ICdiJzogMiB9IH0sXHJcbiAgICAgKiAgIHsgJ2EnOiB7ICdiJzogMSB9IH1cclxuICAgICAqIF07XHJcbiAgICAgKlxyXG4gICAgICogXy5tYXAob2JqZWN0cywgXy5wcm9wZXJ0eSgnYS5iJykpO1xyXG4gICAgICogLy8gPT4gWzIsIDFdXHJcbiAgICAgKlxyXG4gICAgICogXy5tYXAoXy5zb3J0Qnkob2JqZWN0cywgXy5wcm9wZXJ0eShbJ2EnLCAnYiddKSksICdhLmInKTtcclxuICAgICAqIC8vID0+IFsxLCAyXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBwcm9wZXJ0eShwYXRoKSB7XHJcbiAgICAgIHJldHVybiBpc0tleShwYXRoKSA/IGJhc2VQcm9wZXJ0eSh0b0tleShwYXRoKSkgOiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLnByb3BlcnR5YDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJuc1xyXG4gICAgICogdGhlIHZhbHVlIGF0IGEgZ2l2ZW4gcGF0aCBvZiBgb2JqZWN0YC5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHNpbmNlIDMuMC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIHZhciBhcnJheSA9IFswLCAxLCAyXSxcclxuICAgICAqICAgICBvYmplY3QgPSB7ICdhJzogYXJyYXksICdiJzogYXJyYXksICdjJzogYXJyYXkgfTtcclxuICAgICAqXHJcbiAgICAgKiBfLm1hcChbJ2FbMl0nLCAnY1swXSddLCBfLnByb3BlcnR5T2Yob2JqZWN0KSk7XHJcbiAgICAgKiAvLyA9PiBbMiwgMF1cclxuICAgICAqXHJcbiAgICAgKiBfLm1hcChbWydhJywgJzInXSwgWydjJywgJzAnXV0sIF8ucHJvcGVydHlPZihvYmplY3QpKTtcclxuICAgICAqIC8vID0+IFsyLCAwXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBwcm9wZXJ0eU9mKG9iamVjdCkge1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24ocGF0aCkge1xyXG4gICAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgbnVtYmVycyAocG9zaXRpdmUgYW5kL29yIG5lZ2F0aXZlKSBwcm9ncmVzc2luZyBmcm9tXHJcbiAgICAgKiBgc3RhcnRgIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZywgYGVuZGAuIEEgc3RlcCBvZiBgLTFgIGlzIHVzZWQgaWYgYSBuZWdhdGl2ZVxyXG4gICAgICogYHN0YXJ0YCBpcyBzcGVjaWZpZWQgd2l0aG91dCBhbiBgZW5kYCBvciBgc3RlcGAuIElmIGBlbmRgIGlzIG5vdCBzcGVjaWZpZWQsXHJcbiAgICAgKiBpdCdzIHNldCB0byBgc3RhcnRgIHdpdGggYHN0YXJ0YCB0aGVuIHNldCB0byBgMGAuXHJcbiAgICAgKlxyXG4gICAgICogKipOb3RlOioqIEphdmFTY3JpcHQgZm9sbG93cyB0aGUgSUVFRS03NTQgc3RhbmRhcmQgZm9yIHJlc29sdmluZ1xyXG4gICAgICogZmxvYXRpbmctcG9pbnQgdmFsdWVzIHdoaWNoIGNhbiBwcm9kdWNlIHVuZXhwZWN0ZWQgcmVzdWx0cy5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAc2luY2UgMC4xLjBcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RlcD0xXSBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBieS5cclxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZ2Ugb2YgbnVtYmVycy5cclxuICAgICAqIEBzZWUgXy5pblJhbmdlLCBfLnJhbmdlUmlnaHRcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogXy5yYW5nZSg0KTtcclxuICAgICAqIC8vID0+IFswLCAxLCAyLCAzXVxyXG4gICAgICpcclxuICAgICAqIF8ucmFuZ2UoLTQpO1xyXG4gICAgICogLy8gPT4gWzAsIC0xLCAtMiwgLTNdXHJcbiAgICAgKlxyXG4gICAgICogXy5yYW5nZSgxLCA1KTtcclxuICAgICAqIC8vID0+IFsxLCAyLCAzLCA0XVxyXG4gICAgICpcclxuICAgICAqIF8ucmFuZ2UoMCwgMjAsIDUpO1xyXG4gICAgICogLy8gPT4gWzAsIDUsIDEwLCAxNV1cclxuICAgICAqXHJcbiAgICAgKiBfLnJhbmdlKDAsIC00LCAtMSk7XHJcbiAgICAgKiAvLyA9PiBbMCwgLTEsIC0yLCAtM11cclxuICAgICAqXHJcbiAgICAgKiBfLnJhbmdlKDEsIDQsIDApO1xyXG4gICAgICogLy8gPT4gWzEsIDEsIDFdXHJcbiAgICAgKlxyXG4gICAgICogXy5yYW5nZSgwKTtcclxuICAgICAqIC8vID0+IFtdXHJcbiAgICAgKi9cclxuICAgIHZhciByYW5nZSA9IGNyZWF0ZVJhbmdlKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnJhbmdlYCBleGNlcHQgdGhhdCBpdCBwb3B1bGF0ZXMgdmFsdWVzIGluXHJcbiAgICAgKiBkZXNjZW5kaW5nIG9yZGVyLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgNC4wLjBcclxuICAgICAqIEBjYXRlZ29yeSBVdGlsXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGVwPTFdIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5nZSBvZiBudW1iZXJzLlxyXG4gICAgICogQHNlZSBfLmluUmFuZ2UsIF8ucmFuZ2VcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogXy5yYW5nZVJpZ2h0KDQpO1xyXG4gICAgICogLy8gPT4gWzMsIDIsIDEsIDBdXHJcbiAgICAgKlxyXG4gICAgICogXy5yYW5nZVJpZ2h0KC00KTtcclxuICAgICAqIC8vID0+IFstMywgLTIsIC0xLCAwXVxyXG4gICAgICpcclxuICAgICAqIF8ucmFuZ2VSaWdodCgxLCA1KTtcclxuICAgICAqIC8vID0+IFs0LCAzLCAyLCAxXVxyXG4gICAgICpcclxuICAgICAqIF8ucmFuZ2VSaWdodCgwLCAyMCwgNSk7XHJcbiAgICAgKiAvLyA9PiBbMTUsIDEwLCA1LCAwXVxyXG4gICAgICpcclxuICAgICAqIF8ucmFuZ2VSaWdodCgwLCAtNCwgLTEpO1xyXG4gICAgICogLy8gPT4gWy0zLCAtMiwgLTEsIDBdXHJcbiAgICAgKlxyXG4gICAgICogXy5yYW5nZVJpZ2h0KDEsIDQsIDApO1xyXG4gICAgICogLy8gPT4gWzEsIDEsIDFdXHJcbiAgICAgKlxyXG4gICAgICogXy5yYW5nZVJpZ2h0KDApO1xyXG4gICAgICogLy8gPT4gW11cclxuICAgICAqL1xyXG4gICAgdmFyIHJhbmdlUmlnaHQgPSBjcmVhdGVSYW5nZSh0cnVlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSA0LjEzLjBcclxuICAgICAqIEBjYXRlZ29yeSBVdGlsXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xyXG4gICAgICpcclxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5cyk7XHJcbiAgICAgKiAvLyA9PiBbW10sIFtdXVxyXG4gICAgICpcclxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcclxuICAgICAqIC8vID0+IGZhbHNlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgNC4xMy4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XHJcbiAgICAgKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBzdHViRmFsc2UoKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgNC4xMy4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxyXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IG9iamVjdC5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uc3R1Yk9iamVjdCk7XHJcbiAgICAgKlxyXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0cyk7XHJcbiAgICAgKiAvLyA9PiBbe30sIHt9XVxyXG4gICAgICpcclxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xyXG4gICAgICogLy8gPT4gZmFsc2VcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gc3R1Yk9iamVjdCgpIHtcclxuICAgICAgcmV0dXJuIHt9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBhbiBlbXB0eSBzdHJpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSA0LjEzLjBcclxuICAgICAqIEBjYXRlZ29yeSBVdGlsXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlbXB0eSBzdHJpbmcuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8udGltZXMoMiwgXy5zdHViU3RyaW5nKTtcclxuICAgICAqIC8vID0+IFsnJywgJyddXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHN0dWJTdHJpbmcoKSB7XHJcbiAgICAgIHJldHVybiAnJztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYHRydWVgLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgNC4xMy4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLnRpbWVzKDIsIF8uc3R1YlRydWUpO1xyXG4gICAgICogLy8gPT4gW3RydWUsIHRydWVdXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHN0dWJUcnVlKCkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEludm9rZXMgdGhlIGl0ZXJhdGVlIGBuYCB0aW1lcywgcmV0dXJuaW5nIGFuIGFycmF5IG9mIHRoZSByZXN1bHRzIG9mXHJcbiAgICAgKiBlYWNoIGludm9jYXRpb24uIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAoaW5kZXgpLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBzaW5jZSAwLjEuMFxyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBjYXRlZ29yeSBVdGlsXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8udGltZXMoMywgU3RyaW5nKTtcclxuICAgICAqIC8vID0+IFsnMCcsICcxJywgJzInXVxyXG4gICAgICpcclxuICAgICAqICBfLnRpbWVzKDQsIF8uY29uc3RhbnQoMCkpO1xyXG4gICAgICogLy8gPT4gWzAsIDAsIDAsIDBdXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHRpbWVzKG4sIGl0ZXJhdGVlKSB7XHJcbiAgICAgIG4gPSB0b0ludGVnZXIobik7XHJcbiAgICAgIGlmIChuIDwgMSB8fCBuID4gTUFYX1NBRkVfSU5URUdFUikge1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgaW5kZXggPSBNQVhfQVJSQVlfTEVOR1RILFxyXG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWluKG4sIE1BWF9BUlJBWV9MRU5HVEgpO1xyXG5cclxuICAgICAgaXRlcmF0ZWUgPSBnZXRJdGVyYXRlZShpdGVyYXRlZSk7XHJcbiAgICAgIG4gLT0gTUFYX0FSUkFZX0xFTkdUSDtcclxuXHJcbiAgICAgIHZhciByZXN1bHQgPSBiYXNlVGltZXMobGVuZ3RoLCBpdGVyYXRlZSk7XHJcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbikge1xyXG4gICAgICAgIGl0ZXJhdGVlKGluZGV4KTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSA0LjAuMFxyXG4gICAgICogQGNhdGVnb3J5IFV0aWxcclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBwcm9wZXJ0eSBwYXRoIGFycmF5LlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLnRvUGF0aCgnYS5iLmMnKTtcclxuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXVxyXG4gICAgICpcclxuICAgICAqIF8udG9QYXRoKCdhWzBdLmIuYycpO1xyXG4gICAgICogLy8gPT4gWydhJywgJzAnLCAnYicsICdjJ11cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdG9QYXRoKHZhbHVlKSB7XHJcbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiBhcnJheU1hcCh2YWx1ZSwgdG9LZXkpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBpc1N5bWJvbCh2YWx1ZSkgPyBbdmFsdWVdIDogY29weUFycmF5KHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyBhIHVuaXF1ZSBJRC4gSWYgYHByZWZpeGAgaXMgZ2l2ZW4sIHRoZSBJRCBpcyBhcHBlbmRlZCB0byBpdC5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAc2luY2UgMC4xLjBcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwcmVmaXg9JyddIFRoZSB2YWx1ZSB0byBwcmVmaXggdGhlIElEIHdpdGguXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmlxdWUgSUQuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8udW5pcXVlSWQoJ2NvbnRhY3RfJyk7XHJcbiAgICAgKiAvLyA9PiAnY29udGFjdF8xMDQnXHJcbiAgICAgKlxyXG4gICAgICogXy51bmlxdWVJZCgpO1xyXG4gICAgICogLy8gPT4gJzEwNSdcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdW5pcXVlSWQocHJlZml4KSB7XHJcbiAgICAgIHZhciBpZCA9ICsraWRDb3VudGVyO1xyXG4gICAgICByZXR1cm4gdG9TdHJpbmcocHJlZml4KSArIGlkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgdHdvIG51bWJlcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAzLjQuMFxyXG4gICAgICogQGNhdGVnb3J5IE1hdGhcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhdWdlbmQgVGhlIGZpcnN0IG51bWJlciBpbiBhbiBhZGRpdGlvbi5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhZGRlbmQgVGhlIHNlY29uZCBudW1iZXIgaW4gYW4gYWRkaXRpb24uXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0b3RhbC5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogXy5hZGQoNiwgNCk7XHJcbiAgICAgKiAvLyA9PiAxMFxyXG4gICAgICovXHJcbiAgICB2YXIgYWRkID0gY3JlYXRlTWF0aE9wZXJhdGlvbihmdW5jdGlvbihhdWdlbmQsIGFkZGVuZCkge1xyXG4gICAgICByZXR1cm4gYXVnZW5kICsgYWRkZW5kO1xyXG4gICAgfSwgMCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyBgbnVtYmVyYCByb3VuZGVkIHVwIHRvIGBwcmVjaXNpb25gLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgMy4xMC4wXHJcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIHJvdW5kIHVwLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmVjaXNpb249MF0gVGhlIHByZWNpc2lvbiB0byByb3VuZCB1cCB0by5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJvdW5kZWQgdXAgbnVtYmVyLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLmNlaWwoNC4wMDYpO1xyXG4gICAgICogLy8gPT4gNVxyXG4gICAgICpcclxuICAgICAqIF8uY2VpbCg2LjAwNCwgMik7XHJcbiAgICAgKiAvLyA9PiA2LjAxXHJcbiAgICAgKlxyXG4gICAgICogXy5jZWlsKDYwNDAsIC0yKTtcclxuICAgICAqIC8vID0+IDYxMDBcclxuICAgICAqL1xyXG4gICAgdmFyIGNlaWwgPSBjcmVhdGVSb3VuZCgnY2VpbCcpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGl2aWRlIHR3byBudW1iZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgNC43LjBcclxuICAgICAqIEBjYXRlZ29yeSBNYXRoXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGl2aWRlbmQgVGhlIGZpcnN0IG51bWJlciBpbiBhIGRpdmlzaW9uLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpdmlzb3IgVGhlIHNlY29uZCBudW1iZXIgaW4gYSBkaXZpc2lvbi5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHF1b3RpZW50LlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLmRpdmlkZSg2LCA0KTtcclxuICAgICAqIC8vID0+IDEuNVxyXG4gICAgICovXHJcbiAgICB2YXIgZGl2aWRlID0gY3JlYXRlTWF0aE9wZXJhdGlvbihmdW5jdGlvbihkaXZpZGVuZCwgZGl2aXNvcikge1xyXG4gICAgICByZXR1cm4gZGl2aWRlbmQgLyBkaXZpc29yO1xyXG4gICAgfSwgMSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyBgbnVtYmVyYCByb3VuZGVkIGRvd24gdG8gYHByZWNpc2lvbmAuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAzLjEwLjBcclxuICAgICAqIEBjYXRlZ29yeSBNYXRoXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gcm91bmQgZG93bi5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJlY2lzaW9uPTBdIFRoZSBwcmVjaXNpb24gdG8gcm91bmQgZG93biB0by5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJvdW5kZWQgZG93biBudW1iZXIuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8uZmxvb3IoNC4wMDYpO1xyXG4gICAgICogLy8gPT4gNFxyXG4gICAgICpcclxuICAgICAqIF8uZmxvb3IoMC4wNDYsIDIpO1xyXG4gICAgICogLy8gPT4gMC4wNFxyXG4gICAgICpcclxuICAgICAqIF8uZmxvb3IoNDA2MCwgLTIpO1xyXG4gICAgICogLy8gPT4gNDAwMFxyXG4gICAgICovXHJcbiAgICB2YXIgZmxvb3IgPSBjcmVhdGVSb3VuZCgnZmxvb3InKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGVzIHRoZSBtYXhpbXVtIHZhbHVlIG9mIGBhcnJheWAuIElmIGBhcnJheWAgaXMgZW1wdHkgb3IgZmFsc2V5LFxyXG4gICAgICogYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHNpbmNlIDAuMS4wXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQGNhdGVnb3J5IE1hdGhcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXHJcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZS5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogXy5tYXgoWzQsIDIsIDgsIDZdKTtcclxuICAgICAqIC8vID0+IDhcclxuICAgICAqXHJcbiAgICAgKiBfLm1heChbXSk7XHJcbiAgICAgKiAvLyA9PiB1bmRlZmluZWRcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gbWF4KGFycmF5KSB7XHJcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxyXG4gICAgICAgID8gYmFzZUV4dHJlbXVtKGFycmF5LCBpZGVudGl0eSwgYmFzZUd0KVxyXG4gICAgICAgIDogdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5tYXhgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xyXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaFxyXG4gICAgICogdGhlIHZhbHVlIGlzIHJhbmtlZC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSA0LjAuMFxyXG4gICAgICogQGNhdGVnb3J5IE1hdGhcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXHJcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZS5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnbic6IDEgfSwgeyAnbic6IDIgfV07XHJcbiAgICAgKlxyXG4gICAgICogXy5tYXhCeShvYmplY3RzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLm47IH0pO1xyXG4gICAgICogLy8gPT4geyAnbic6IDIgfVxyXG4gICAgICpcclxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxyXG4gICAgICogXy5tYXhCeShvYmplY3RzLCAnbicpO1xyXG4gICAgICogLy8gPT4geyAnbic6IDIgfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBtYXhCeShhcnJheSwgaXRlcmF0ZWUpIHtcclxuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXHJcbiAgICAgICAgPyBiYXNlRXh0cmVtdW0oYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSwgYmFzZUd0KVxyXG4gICAgICAgIDogdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgdGhlIG1lYW4gb2YgdGhlIHZhbHVlcyBpbiBgYXJyYXlgLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgNC4wLjBcclxuICAgICAqIEBjYXRlZ29yeSBNYXRoXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbWVhbi5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogXy5tZWFuKFs0LCAyLCA4LCA2XSk7XHJcbiAgICAgKiAvLyA9PiA1XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG1lYW4oYXJyYXkpIHtcclxuICAgICAgcmV0dXJuIGJhc2VNZWFuKGFycmF5LCBpZGVudGl0eSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLm1lYW5gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xyXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIHZhbHVlIHRvIGJlIGF2ZXJhZ2VkLlxyXG4gICAgICogVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSA0LjcuMFxyXG4gICAgICogQGNhdGVnb3J5IE1hdGhcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBtZWFuLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICduJzogNCB9LCB7ICduJzogMiB9LCB7ICduJzogOCB9LCB7ICduJzogNiB9XTtcclxuICAgICAqXHJcbiAgICAgKiBfLm1lYW5CeShvYmplY3RzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLm47IH0pO1xyXG4gICAgICogLy8gPT4gNVxyXG4gICAgICpcclxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxyXG4gICAgICogXy5tZWFuQnkob2JqZWN0cywgJ24nKTtcclxuICAgICAqIC8vID0+IDVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gbWVhbkJ5KGFycmF5LCBpdGVyYXRlZSkge1xyXG4gICAgICByZXR1cm4gYmFzZU1lYW4oYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyB0aGUgbWluaW11bSB2YWx1ZSBvZiBgYXJyYXlgLiBJZiBgYXJyYXlgIGlzIGVtcHR5IG9yIGZhbHNleSxcclxuICAgICAqIGB1bmRlZmluZWRgIGlzIHJldHVybmVkLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBzaW5jZSAwLjEuMFxyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBjYXRlZ29yeSBNYXRoXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxyXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1pbmltdW0gdmFsdWUuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8ubWluKFs0LCAyLCA4LCA2XSk7XHJcbiAgICAgKiAvLyA9PiAyXHJcbiAgICAgKlxyXG4gICAgICogXy5taW4oW10pO1xyXG4gICAgICogLy8gPT4gdW5kZWZpbmVkXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG1pbihhcnJheSkge1xyXG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcclxuICAgICAgICA/IGJhc2VFeHRyZW11bShhcnJheSwgaWRlbnRpdHksIGJhc2VMdClcclxuICAgICAgICA6IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWluYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcclxuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBpbiBgYXJyYXlgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2hcclxuICAgICAqIHRoZSB2YWx1ZSBpcyByYW5rZWQuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgNC4wLjBcclxuICAgICAqIEBjYXRlZ29yeSBNYXRoXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxyXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1pbmltdW0gdmFsdWUuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ24nOiAxIH0sIHsgJ24nOiAyIH1dO1xyXG4gICAgICpcclxuICAgICAqIF8ubWluQnkob2JqZWN0cywgZnVuY3Rpb24obykgeyByZXR1cm4gby5uOyB9KTtcclxuICAgICAqIC8vID0+IHsgJ24nOiAxIH1cclxuICAgICAqXHJcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cclxuICAgICAqIF8ubWluQnkob2JqZWN0cywgJ24nKTtcclxuICAgICAqIC8vID0+IHsgJ24nOiAxIH1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gbWluQnkoYXJyYXksIGl0ZXJhdGVlKSB7XHJcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxyXG4gICAgICAgID8gYmFzZUV4dHJlbXVtKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMiksIGJhc2VMdClcclxuICAgICAgICA6IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE11bHRpcGx5IHR3byBudW1iZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgNC43LjBcclxuICAgICAqIEBjYXRlZ29yeSBNYXRoXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbXVsdGlwbGllciBUaGUgZmlyc3QgbnVtYmVyIGluIGEgbXVsdGlwbGljYXRpb24uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbXVsdGlwbGljYW5kIFRoZSBzZWNvbmQgbnVtYmVyIGluIGEgbXVsdGlwbGljYXRpb24uXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBwcm9kdWN0LlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBfLm11bHRpcGx5KDYsIDQpO1xyXG4gICAgICogLy8gPT4gMjRcclxuICAgICAqL1xyXG4gICAgdmFyIG11bHRpcGx5ID0gY3JlYXRlTWF0aE9wZXJhdGlvbihmdW5jdGlvbihtdWx0aXBsaWVyLCBtdWx0aXBsaWNhbmQpIHtcclxuICAgICAgcmV0dXJuIG11bHRpcGxpZXIgKiBtdWx0aXBsaWNhbmQ7XHJcbiAgICB9LCAxKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGVzIGBudW1iZXJgIHJvdW5kZWQgdG8gYHByZWNpc2lvbmAuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAzLjEwLjBcclxuICAgICAqIEBjYXRlZ29yeSBNYXRoXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gcm91bmQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ByZWNpc2lvbj0wXSBUaGUgcHJlY2lzaW9uIHRvIHJvdW5kIHRvLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcm91bmRlZCBudW1iZXIuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8ucm91bmQoNC4wMDYpO1xyXG4gICAgICogLy8gPT4gNFxyXG4gICAgICpcclxuICAgICAqIF8ucm91bmQoNC4wMDYsIDIpO1xyXG4gICAgICogLy8gPT4gNC4wMVxyXG4gICAgICpcclxuICAgICAqIF8ucm91bmQoNDA2MCwgLTIpO1xyXG4gICAgICogLy8gPT4gNDEwMFxyXG4gICAgICovXHJcbiAgICB2YXIgcm91bmQgPSBjcmVhdGVSb3VuZCgncm91bmQnKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN1YnRyYWN0IHR3byBudW1iZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZW1iZXJPZiBfXHJcbiAgICAgKiBAc2luY2UgNC4wLjBcclxuICAgICAqIEBjYXRlZ29yeSBNYXRoXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWludWVuZCBUaGUgZmlyc3QgbnVtYmVyIGluIGEgc3VidHJhY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3VidHJhaGVuZCBUaGUgc2Vjb25kIG51bWJlciBpbiBhIHN1YnRyYWN0aW9uLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgZGlmZmVyZW5jZS5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogXy5zdWJ0cmFjdCg2LCA0KTtcclxuICAgICAqIC8vID0+IDJcclxuICAgICAqL1xyXG4gICAgdmFyIHN1YnRyYWN0ID0gY3JlYXRlTWF0aE9wZXJhdGlvbihmdW5jdGlvbihtaW51ZW5kLCBzdWJ0cmFoZW5kKSB7XHJcbiAgICAgIHJldHVybiBtaW51ZW5kIC0gc3VidHJhaGVuZDtcclxuICAgIH0sIDApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgdGhlIHN1bSBvZiB0aGUgdmFsdWVzIGluIGBhcnJheWAuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSAzLjQuMFxyXG4gICAgICogQGNhdGVnb3J5IE1hdGhcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdW0uXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIF8uc3VtKFs0LCAyLCA4LCA2XSk7XHJcbiAgICAgKiAvLyA9PiAyMFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBzdW0oYXJyYXkpIHtcclxuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXHJcbiAgICAgICAgPyBiYXNlU3VtKGFycmF5LCBpZGVudGl0eSlcclxuICAgICAgICA6IDA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnN1bWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXHJcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgdmFsdWUgdG8gYmUgc3VtbWVkLlxyXG4gICAgICogVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1lbWJlck9mIF9cclxuICAgICAqIEBzaW5jZSA0LjAuMFxyXG4gICAgICogQGNhdGVnb3J5IE1hdGhcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdW0uXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ24nOiA0IH0sIHsgJ24nOiAyIH0sIHsgJ24nOiA4IH0sIHsgJ24nOiA2IH1dO1xyXG4gICAgICpcclxuICAgICAqIF8uc3VtQnkob2JqZWN0cywgZnVuY3Rpb24obykgeyByZXR1cm4gby5uOyB9KTtcclxuICAgICAqIC8vID0+IDIwXHJcbiAgICAgKlxyXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXHJcbiAgICAgKiBfLnN1bUJ5KG9iamVjdHMsICduJyk7XHJcbiAgICAgKiAvLyA9PiAyMFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBzdW1CeShhcnJheSwgaXRlcmF0ZWUpIHtcclxuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXHJcbiAgICAgICAgPyBiYXNlU3VtKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpXHJcbiAgICAgICAgOiAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuXHJcbiAgICAvLyBBZGQgbWV0aG9kcyB0aGF0IHJldHVybiB3cmFwcGVkIHZhbHVlcyBpbiBjaGFpbiBzZXF1ZW5jZXMuXHJcbiAgICBsb2Rhc2guYWZ0ZXIgPSBhZnRlcjtcclxuICAgIGxvZGFzaC5hcnkgPSBhcnk7XHJcbiAgICBsb2Rhc2guYXNzaWduID0gYXNzaWduO1xyXG4gICAgbG9kYXNoLmFzc2lnbkluID0gYXNzaWduSW47XHJcbiAgICBsb2Rhc2guYXNzaWduSW5XaXRoID0gYXNzaWduSW5XaXRoO1xyXG4gICAgbG9kYXNoLmFzc2lnbldpdGggPSBhc3NpZ25XaXRoO1xyXG4gICAgbG9kYXNoLmF0ID0gYXQ7XHJcbiAgICBsb2Rhc2guYmVmb3JlID0gYmVmb3JlO1xyXG4gICAgbG9kYXNoLmJpbmQgPSBiaW5kO1xyXG4gICAgbG9kYXNoLmJpbmRBbGwgPSBiaW5kQWxsO1xyXG4gICAgbG9kYXNoLmJpbmRLZXkgPSBiaW5kS2V5O1xyXG4gICAgbG9kYXNoLmNhc3RBcnJheSA9IGNhc3RBcnJheTtcclxuICAgIGxvZGFzaC5jaGFpbiA9IGNoYWluO1xyXG4gICAgbG9kYXNoLmNodW5rID0gY2h1bms7XHJcbiAgICBsb2Rhc2guY29tcGFjdCA9IGNvbXBhY3Q7XHJcbiAgICBsb2Rhc2guY29uY2F0ID0gY29uY2F0O1xyXG4gICAgbG9kYXNoLmNvbmQgPSBjb25kO1xyXG4gICAgbG9kYXNoLmNvbmZvcm1zID0gY29uZm9ybXM7XHJcbiAgICBsb2Rhc2guY29uc3RhbnQgPSBjb25zdGFudDtcclxuICAgIGxvZGFzaC5jb3VudEJ5ID0gY291bnRCeTtcclxuICAgIGxvZGFzaC5jcmVhdGUgPSBjcmVhdGU7XHJcbiAgICBsb2Rhc2guY3VycnkgPSBjdXJyeTtcclxuICAgIGxvZGFzaC5jdXJyeVJpZ2h0ID0gY3VycnlSaWdodDtcclxuICAgIGxvZGFzaC5kZWJvdW5jZSA9IGRlYm91bmNlO1xyXG4gICAgbG9kYXNoLmRlZmF1bHRzID0gZGVmYXVsdHM7XHJcbiAgICBsb2Rhc2guZGVmYXVsdHNEZWVwID0gZGVmYXVsdHNEZWVwO1xyXG4gICAgbG9kYXNoLmRlZmVyID0gZGVmZXI7XHJcbiAgICBsb2Rhc2guZGVsYXkgPSBkZWxheTtcclxuICAgIGxvZGFzaC5kaWZmZXJlbmNlID0gZGlmZmVyZW5jZTtcclxuICAgIGxvZGFzaC5kaWZmZXJlbmNlQnkgPSBkaWZmZXJlbmNlQnk7XHJcbiAgICBsb2Rhc2guZGlmZmVyZW5jZVdpdGggPSBkaWZmZXJlbmNlV2l0aDtcclxuICAgIGxvZGFzaC5kcm9wID0gZHJvcDtcclxuICAgIGxvZGFzaC5kcm9wUmlnaHQgPSBkcm9wUmlnaHQ7XHJcbiAgICBsb2Rhc2guZHJvcFJpZ2h0V2hpbGUgPSBkcm9wUmlnaHRXaGlsZTtcclxuICAgIGxvZGFzaC5kcm9wV2hpbGUgPSBkcm9wV2hpbGU7XHJcbiAgICBsb2Rhc2guZmlsbCA9IGZpbGw7XHJcbiAgICBsb2Rhc2guZmlsdGVyID0gZmlsdGVyO1xyXG4gICAgbG9kYXNoLmZsYXRNYXAgPSBmbGF0TWFwO1xyXG4gICAgbG9kYXNoLmZsYXRNYXBEZWVwID0gZmxhdE1hcERlZXA7XHJcbiAgICBsb2Rhc2guZmxhdE1hcERlcHRoID0gZmxhdE1hcERlcHRoO1xyXG4gICAgbG9kYXNoLmZsYXR0ZW4gPSBmbGF0dGVuO1xyXG4gICAgbG9kYXNoLmZsYXR0ZW5EZWVwID0gZmxhdHRlbkRlZXA7XHJcbiAgICBsb2Rhc2guZmxhdHRlbkRlcHRoID0gZmxhdHRlbkRlcHRoO1xyXG4gICAgbG9kYXNoLmZsaXAgPSBmbGlwO1xyXG4gICAgbG9kYXNoLmZsb3cgPSBmbG93O1xyXG4gICAgbG9kYXNoLmZsb3dSaWdodCA9IGZsb3dSaWdodDtcclxuICAgIGxvZGFzaC5mcm9tUGFpcnMgPSBmcm9tUGFpcnM7XHJcbiAgICBsb2Rhc2guZnVuY3Rpb25zID0gZnVuY3Rpb25zO1xyXG4gICAgbG9kYXNoLmZ1bmN0aW9uc0luID0gZnVuY3Rpb25zSW47XHJcbiAgICBsb2Rhc2guZ3JvdXBCeSA9IGdyb3VwQnk7XHJcbiAgICBsb2Rhc2guaW5pdGlhbCA9IGluaXRpYWw7XHJcbiAgICBsb2Rhc2guaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uO1xyXG4gICAgbG9kYXNoLmludGVyc2VjdGlvbkJ5ID0gaW50ZXJzZWN0aW9uQnk7XHJcbiAgICBsb2Rhc2guaW50ZXJzZWN0aW9uV2l0aCA9IGludGVyc2VjdGlvbldpdGg7XHJcbiAgICBsb2Rhc2guaW52ZXJ0ID0gaW52ZXJ0O1xyXG4gICAgbG9kYXNoLmludmVydEJ5ID0gaW52ZXJ0Qnk7XHJcbiAgICBsb2Rhc2guaW52b2tlTWFwID0gaW52b2tlTWFwO1xyXG4gICAgbG9kYXNoLml0ZXJhdGVlID0gaXRlcmF0ZWU7XHJcbiAgICBsb2Rhc2gua2V5QnkgPSBrZXlCeTtcclxuICAgIGxvZGFzaC5rZXlzID0ga2V5cztcclxuICAgIGxvZGFzaC5rZXlzSW4gPSBrZXlzSW47XHJcbiAgICBsb2Rhc2gubWFwID0gbWFwO1xyXG4gICAgbG9kYXNoLm1hcEtleXMgPSBtYXBLZXlzO1xyXG4gICAgbG9kYXNoLm1hcFZhbHVlcyA9IG1hcFZhbHVlcztcclxuICAgIGxvZGFzaC5tYXRjaGVzID0gbWF0Y2hlcztcclxuICAgIGxvZGFzaC5tYXRjaGVzUHJvcGVydHkgPSBtYXRjaGVzUHJvcGVydHk7XHJcbiAgICBsb2Rhc2gubWVtb2l6ZSA9IG1lbW9pemU7XHJcbiAgICBsb2Rhc2gubWVyZ2UgPSBtZXJnZTtcclxuICAgIGxvZGFzaC5tZXJnZVdpdGggPSBtZXJnZVdpdGg7XHJcbiAgICBsb2Rhc2gubWV0aG9kID0gbWV0aG9kO1xyXG4gICAgbG9kYXNoLm1ldGhvZE9mID0gbWV0aG9kT2Y7XHJcbiAgICBsb2Rhc2gubWl4aW4gPSBtaXhpbjtcclxuICAgIGxvZGFzaC5uZWdhdGUgPSBuZWdhdGU7XHJcbiAgICBsb2Rhc2gubnRoQXJnID0gbnRoQXJnO1xyXG4gICAgbG9kYXNoLm9taXQgPSBvbWl0O1xyXG4gICAgbG9kYXNoLm9taXRCeSA9IG9taXRCeTtcclxuICAgIGxvZGFzaC5vbmNlID0gb25jZTtcclxuICAgIGxvZGFzaC5vcmRlckJ5ID0gb3JkZXJCeTtcclxuICAgIGxvZGFzaC5vdmVyID0gb3ZlcjtcclxuICAgIGxvZGFzaC5vdmVyQXJncyA9IG92ZXJBcmdzO1xyXG4gICAgbG9kYXNoLm92ZXJFdmVyeSA9IG92ZXJFdmVyeTtcclxuICAgIGxvZGFzaC5vdmVyU29tZSA9IG92ZXJTb21lO1xyXG4gICAgbG9kYXNoLnBhcnRpYWwgPSBwYXJ0aWFsO1xyXG4gICAgbG9kYXNoLnBhcnRpYWxSaWdodCA9IHBhcnRpYWxSaWdodDtcclxuICAgIGxvZGFzaC5wYXJ0aXRpb24gPSBwYXJ0aXRpb247XHJcbiAgICBsb2Rhc2gucGljayA9IHBpY2s7XHJcbiAgICBsb2Rhc2gucGlja0J5ID0gcGlja0J5O1xyXG4gICAgbG9kYXNoLnByb3BlcnR5ID0gcHJvcGVydHk7XHJcbiAgICBsb2Rhc2gucHJvcGVydHlPZiA9IHByb3BlcnR5T2Y7XHJcbiAgICBsb2Rhc2gucHVsbCA9IHB1bGw7XHJcbiAgICBsb2Rhc2gucHVsbEFsbCA9IHB1bGxBbGw7XHJcbiAgICBsb2Rhc2gucHVsbEFsbEJ5ID0gcHVsbEFsbEJ5O1xyXG4gICAgbG9kYXNoLnB1bGxBbGxXaXRoID0gcHVsbEFsbFdpdGg7XHJcbiAgICBsb2Rhc2gucHVsbEF0ID0gcHVsbEF0O1xyXG4gICAgbG9kYXNoLnJhbmdlID0gcmFuZ2U7XHJcbiAgICBsb2Rhc2gucmFuZ2VSaWdodCA9IHJhbmdlUmlnaHQ7XHJcbiAgICBsb2Rhc2gucmVhcmcgPSByZWFyZztcclxuICAgIGxvZGFzaC5yZWplY3QgPSByZWplY3Q7XHJcbiAgICBsb2Rhc2gucmVtb3ZlID0gcmVtb3ZlO1xyXG4gICAgbG9kYXNoLnJlc3QgPSByZXN0O1xyXG4gICAgbG9kYXNoLnJldmVyc2UgPSByZXZlcnNlO1xyXG4gICAgbG9kYXNoLnNhbXBsZVNpemUgPSBzYW1wbGVTaXplO1xyXG4gICAgbG9kYXNoLnNldCA9IHNldDtcclxuICAgIGxvZGFzaC5zZXRXaXRoID0gc2V0V2l0aDtcclxuICAgIGxvZGFzaC5zaHVmZmxlID0gc2h1ZmZsZTtcclxuICAgIGxvZGFzaC5zbGljZSA9IHNsaWNlO1xyXG4gICAgbG9kYXNoLnNvcnRCeSA9IHNvcnRCeTtcclxuICAgIGxvZGFzaC5zb3J0ZWRVbmlxID0gc29ydGVkVW5pcTtcclxuICAgIGxvZGFzaC5zb3J0ZWRVbmlxQnkgPSBzb3J0ZWRVbmlxQnk7XHJcbiAgICBsb2Rhc2guc3BsaXQgPSBzcGxpdDtcclxuICAgIGxvZGFzaC5zcHJlYWQgPSBzcHJlYWQ7XHJcbiAgICBsb2Rhc2gudGFpbCA9IHRhaWw7XHJcbiAgICBsb2Rhc2gudGFrZSA9IHRha2U7XHJcbiAgICBsb2Rhc2gudGFrZVJpZ2h0ID0gdGFrZVJpZ2h0O1xyXG4gICAgbG9kYXNoLnRha2VSaWdodFdoaWxlID0gdGFrZVJpZ2h0V2hpbGU7XHJcbiAgICBsb2Rhc2gudGFrZVdoaWxlID0gdGFrZVdoaWxlO1xyXG4gICAgbG9kYXNoLnRhcCA9IHRhcDtcclxuICAgIGxvZGFzaC50aHJvdHRsZSA9IHRocm90dGxlO1xyXG4gICAgbG9kYXNoLnRocnUgPSB0aHJ1O1xyXG4gICAgbG9kYXNoLnRvQXJyYXkgPSB0b0FycmF5O1xyXG4gICAgbG9kYXNoLnRvUGFpcnMgPSB0b1BhaXJzO1xyXG4gICAgbG9kYXNoLnRvUGFpcnNJbiA9IHRvUGFpcnNJbjtcclxuICAgIGxvZGFzaC50b1BhdGggPSB0b1BhdGg7XHJcbiAgICBsb2Rhc2gudG9QbGFpbk9iamVjdCA9IHRvUGxhaW5PYmplY3Q7XHJcbiAgICBsb2Rhc2gudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xyXG4gICAgbG9kYXNoLnVuYXJ5ID0gdW5hcnk7XHJcbiAgICBsb2Rhc2gudW5pb24gPSB1bmlvbjtcclxuICAgIGxvZGFzaC51bmlvbkJ5ID0gdW5pb25CeTtcclxuICAgIGxvZGFzaC51bmlvbldpdGggPSB1bmlvbldpdGg7XHJcbiAgICBsb2Rhc2gudW5pcSA9IHVuaXE7XHJcbiAgICBsb2Rhc2gudW5pcUJ5ID0gdW5pcUJ5O1xyXG4gICAgbG9kYXNoLnVuaXFXaXRoID0gdW5pcVdpdGg7XHJcbiAgICBsb2Rhc2gudW5zZXQgPSB1bnNldDtcclxuICAgIGxvZGFzaC51bnppcCA9IHVuemlwO1xyXG4gICAgbG9kYXNoLnVuemlwV2l0aCA9IHVuemlwV2l0aDtcclxuICAgIGxvZGFzaC51cGRhdGUgPSB1cGRhdGU7XHJcbiAgICBsb2Rhc2gudXBkYXRlV2l0aCA9IHVwZGF0ZVdpdGg7XHJcbiAgICBsb2Rhc2gudmFsdWVzID0gdmFsdWVzO1xyXG4gICAgbG9kYXNoLnZhbHVlc0luID0gdmFsdWVzSW47XHJcbiAgICBsb2Rhc2gud2l0aG91dCA9IHdpdGhvdXQ7XHJcbiAgICBsb2Rhc2gud29yZHMgPSB3b3JkcztcclxuICAgIGxvZGFzaC53cmFwID0gd3JhcDtcclxuICAgIGxvZGFzaC54b3IgPSB4b3I7XHJcbiAgICBsb2Rhc2gueG9yQnkgPSB4b3JCeTtcclxuICAgIGxvZGFzaC54b3JXaXRoID0geG9yV2l0aDtcclxuICAgIGxvZGFzaC56aXAgPSB6aXA7XHJcbiAgICBsb2Rhc2guemlwT2JqZWN0ID0gemlwT2JqZWN0O1xyXG4gICAgbG9kYXNoLnppcE9iamVjdERlZXAgPSB6aXBPYmplY3REZWVwO1xyXG4gICAgbG9kYXNoLnppcFdpdGggPSB6aXBXaXRoO1xyXG5cclxuICAgIC8vIEFkZCBhbGlhc2VzLlxyXG4gICAgbG9kYXNoLmVudHJpZXMgPSB0b1BhaXJzO1xyXG4gICAgbG9kYXNoLmVudHJpZXNJbiA9IHRvUGFpcnNJbjtcclxuICAgIGxvZGFzaC5leHRlbmQgPSBhc3NpZ25JbjtcclxuICAgIGxvZGFzaC5leHRlbmRXaXRoID0gYXNzaWduSW5XaXRoO1xyXG5cclxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBsb2Rhc2gucHJvdG90eXBlYC5cclxuICAgIG1peGluKGxvZGFzaCwgbG9kYXNoKTtcclxuXHJcbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcblxyXG4gICAgLy8gQWRkIG1ldGhvZHMgdGhhdCByZXR1cm4gdW53cmFwcGVkIHZhbHVlcyBpbiBjaGFpbiBzZXF1ZW5jZXMuXHJcbiAgICBsb2Rhc2guYWRkID0gYWRkO1xyXG4gICAgbG9kYXNoLmF0dGVtcHQgPSBhdHRlbXB0O1xyXG4gICAgbG9kYXNoLmNhbWVsQ2FzZSA9IGNhbWVsQ2FzZTtcclxuICAgIGxvZGFzaC5jYXBpdGFsaXplID0gY2FwaXRhbGl6ZTtcclxuICAgIGxvZGFzaC5jZWlsID0gY2VpbDtcclxuICAgIGxvZGFzaC5jbGFtcCA9IGNsYW1wO1xyXG4gICAgbG9kYXNoLmNsb25lID0gY2xvbmU7XHJcbiAgICBsb2Rhc2guY2xvbmVEZWVwID0gY2xvbmVEZWVwO1xyXG4gICAgbG9kYXNoLmNsb25lRGVlcFdpdGggPSBjbG9uZURlZXBXaXRoO1xyXG4gICAgbG9kYXNoLmNsb25lV2l0aCA9IGNsb25lV2l0aDtcclxuICAgIGxvZGFzaC5jb25mb3Jtc1RvID0gY29uZm9ybXNUbztcclxuICAgIGxvZGFzaC5kZWJ1cnIgPSBkZWJ1cnI7XHJcbiAgICBsb2Rhc2guZGVmYXVsdFRvID0gZGVmYXVsdFRvO1xyXG4gICAgbG9kYXNoLmRpdmlkZSA9IGRpdmlkZTtcclxuICAgIGxvZGFzaC5lbmRzV2l0aCA9IGVuZHNXaXRoO1xyXG4gICAgbG9kYXNoLmVxID0gZXE7XHJcbiAgICBsb2Rhc2guZXNjYXBlID0gZXNjYXBlO1xyXG4gICAgbG9kYXNoLmVzY2FwZVJlZ0V4cCA9IGVzY2FwZVJlZ0V4cDtcclxuICAgIGxvZGFzaC5ldmVyeSA9IGV2ZXJ5O1xyXG4gICAgbG9kYXNoLmZpbmQgPSBmaW5kO1xyXG4gICAgbG9kYXNoLmZpbmRJbmRleCA9IGZpbmRJbmRleDtcclxuICAgIGxvZGFzaC5maW5kS2V5ID0gZmluZEtleTtcclxuICAgIGxvZGFzaC5maW5kTGFzdCA9IGZpbmRMYXN0O1xyXG4gICAgbG9kYXNoLmZpbmRMYXN0SW5kZXggPSBmaW5kTGFzdEluZGV4O1xyXG4gICAgbG9kYXNoLmZpbmRMYXN0S2V5ID0gZmluZExhc3RLZXk7XHJcbiAgICBsb2Rhc2guZmxvb3IgPSBmbG9vcjtcclxuICAgIGxvZGFzaC5mb3JFYWNoID0gZm9yRWFjaDtcclxuICAgIGxvZGFzaC5mb3JFYWNoUmlnaHQgPSBmb3JFYWNoUmlnaHQ7XHJcbiAgICBsb2Rhc2guZm9ySW4gPSBmb3JJbjtcclxuICAgIGxvZGFzaC5mb3JJblJpZ2h0ID0gZm9ySW5SaWdodDtcclxuICAgIGxvZGFzaC5mb3JPd24gPSBmb3JPd247XHJcbiAgICBsb2Rhc2guZm9yT3duUmlnaHQgPSBmb3JPd25SaWdodDtcclxuICAgIGxvZGFzaC5nZXQgPSBnZXQ7XHJcbiAgICBsb2Rhc2guZ3QgPSBndDtcclxuICAgIGxvZGFzaC5ndGUgPSBndGU7XHJcbiAgICBsb2Rhc2guaGFzID0gaGFzO1xyXG4gICAgbG9kYXNoLmhhc0luID0gaGFzSW47XHJcbiAgICBsb2Rhc2guaGVhZCA9IGhlYWQ7XHJcbiAgICBsb2Rhc2guaWRlbnRpdHkgPSBpZGVudGl0eTtcclxuICAgIGxvZGFzaC5pbmNsdWRlcyA9IGluY2x1ZGVzO1xyXG4gICAgbG9kYXNoLmluZGV4T2YgPSBpbmRleE9mO1xyXG4gICAgbG9kYXNoLmluUmFuZ2UgPSBpblJhbmdlO1xyXG4gICAgbG9kYXNoLmludm9rZSA9IGludm9rZTtcclxuICAgIGxvZGFzaC5pc0FyZ3VtZW50cyA9IGlzQXJndW1lbnRzO1xyXG4gICAgbG9kYXNoLmlzQXJyYXkgPSBpc0FycmF5O1xyXG4gICAgbG9kYXNoLmlzQXJyYXlCdWZmZXIgPSBpc0FycmF5QnVmZmVyO1xyXG4gICAgbG9kYXNoLmlzQXJyYXlMaWtlID0gaXNBcnJheUxpa2U7XHJcbiAgICBsb2Rhc2guaXNBcnJheUxpa2VPYmplY3QgPSBpc0FycmF5TGlrZU9iamVjdDtcclxuICAgIGxvZGFzaC5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XHJcbiAgICBsb2Rhc2guaXNCdWZmZXIgPSBpc0J1ZmZlcjtcclxuICAgIGxvZGFzaC5pc0RhdGUgPSBpc0RhdGU7XHJcbiAgICBsb2Rhc2guaXNFbGVtZW50ID0gaXNFbGVtZW50O1xyXG4gICAgbG9kYXNoLmlzRW1wdHkgPSBpc0VtcHR5O1xyXG4gICAgbG9kYXNoLmlzRXF1YWwgPSBpc0VxdWFsO1xyXG4gICAgbG9kYXNoLmlzRXF1YWxXaXRoID0gaXNFcXVhbFdpdGg7XHJcbiAgICBsb2Rhc2guaXNFcnJvciA9IGlzRXJyb3I7XHJcbiAgICBsb2Rhc2guaXNGaW5pdGUgPSBpc0Zpbml0ZTtcclxuICAgIGxvZGFzaC5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcclxuICAgIGxvZGFzaC5pc0ludGVnZXIgPSBpc0ludGVnZXI7XHJcbiAgICBsb2Rhc2guaXNMZW5ndGggPSBpc0xlbmd0aDtcclxuICAgIGxvZGFzaC5pc01hcCA9IGlzTWFwO1xyXG4gICAgbG9kYXNoLmlzTWF0Y2ggPSBpc01hdGNoO1xyXG4gICAgbG9kYXNoLmlzTWF0Y2hXaXRoID0gaXNNYXRjaFdpdGg7XHJcbiAgICBsb2Rhc2guaXNOYU4gPSBpc05hTjtcclxuICAgIGxvZGFzaC5pc05hdGl2ZSA9IGlzTmF0aXZlO1xyXG4gICAgbG9kYXNoLmlzTmlsID0gaXNOaWw7XHJcbiAgICBsb2Rhc2guaXNOdWxsID0gaXNOdWxsO1xyXG4gICAgbG9kYXNoLmlzTnVtYmVyID0gaXNOdW1iZXI7XHJcbiAgICBsb2Rhc2guaXNPYmplY3QgPSBpc09iamVjdDtcclxuICAgIGxvZGFzaC5pc09iamVjdExpa2UgPSBpc09iamVjdExpa2U7XHJcbiAgICBsb2Rhc2guaXNQbGFpbk9iamVjdCA9IGlzUGxhaW5PYmplY3Q7XHJcbiAgICBsb2Rhc2guaXNSZWdFeHAgPSBpc1JlZ0V4cDtcclxuICAgIGxvZGFzaC5pc1NhZmVJbnRlZ2VyID0gaXNTYWZlSW50ZWdlcjtcclxuICAgIGxvZGFzaC5pc1NldCA9IGlzU2V0O1xyXG4gICAgbG9kYXNoLmlzU3RyaW5nID0gaXNTdHJpbmc7XHJcbiAgICBsb2Rhc2guaXNTeW1ib2wgPSBpc1N5bWJvbDtcclxuICAgIGxvZGFzaC5pc1R5cGVkQXJyYXkgPSBpc1R5cGVkQXJyYXk7XHJcbiAgICBsb2Rhc2guaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcclxuICAgIGxvZGFzaC5pc1dlYWtNYXAgPSBpc1dlYWtNYXA7XHJcbiAgICBsb2Rhc2guaXNXZWFrU2V0ID0gaXNXZWFrU2V0O1xyXG4gICAgbG9kYXNoLmpvaW4gPSBqb2luO1xyXG4gICAgbG9kYXNoLmtlYmFiQ2FzZSA9IGtlYmFiQ2FzZTtcclxuICAgIGxvZGFzaC5sYXN0ID0gbGFzdDtcclxuICAgIGxvZGFzaC5sYXN0SW5kZXhPZiA9IGxhc3RJbmRleE9mO1xyXG4gICAgbG9kYXNoLmxvd2VyQ2FzZSA9IGxvd2VyQ2FzZTtcclxuICAgIGxvZGFzaC5sb3dlckZpcnN0ID0gbG93ZXJGaXJzdDtcclxuICAgIGxvZGFzaC5sdCA9IGx0O1xyXG4gICAgbG9kYXNoLmx0ZSA9IGx0ZTtcclxuICAgIGxvZGFzaC5tYXggPSBtYXg7XHJcbiAgICBsb2Rhc2gubWF4QnkgPSBtYXhCeTtcclxuICAgIGxvZGFzaC5tZWFuID0gbWVhbjtcclxuICAgIGxvZGFzaC5tZWFuQnkgPSBtZWFuQnk7XHJcbiAgICBsb2Rhc2gubWluID0gbWluO1xyXG4gICAgbG9kYXNoLm1pbkJ5ID0gbWluQnk7XHJcbiAgICBsb2Rhc2guc3R1YkFycmF5ID0gc3R1YkFycmF5O1xyXG4gICAgbG9kYXNoLnN0dWJGYWxzZSA9IHN0dWJGYWxzZTtcclxuICAgIGxvZGFzaC5zdHViT2JqZWN0ID0gc3R1Yk9iamVjdDtcclxuICAgIGxvZGFzaC5zdHViU3RyaW5nID0gc3R1YlN0cmluZztcclxuICAgIGxvZGFzaC5zdHViVHJ1ZSA9IHN0dWJUcnVlO1xyXG4gICAgbG9kYXNoLm11bHRpcGx5ID0gbXVsdGlwbHk7XHJcbiAgICBsb2Rhc2gubnRoID0gbnRoO1xyXG4gICAgbG9kYXNoLm5vQ29uZmxpY3QgPSBub0NvbmZsaWN0O1xyXG4gICAgbG9kYXNoLm5vb3AgPSBub29wO1xyXG4gICAgbG9kYXNoLm5vdyA9IG5vdztcclxuICAgIGxvZGFzaC5wYWQgPSBwYWQ7XHJcbiAgICBsb2Rhc2gucGFkRW5kID0gcGFkRW5kO1xyXG4gICAgbG9kYXNoLnBhZFN0YXJ0ID0gcGFkU3RhcnQ7XHJcbiAgICBsb2Rhc2gucGFyc2VJbnQgPSBwYXJzZUludDtcclxuICAgIGxvZGFzaC5yYW5kb20gPSByYW5kb207XHJcbiAgICBsb2Rhc2gucmVkdWNlID0gcmVkdWNlO1xyXG4gICAgbG9kYXNoLnJlZHVjZVJpZ2h0ID0gcmVkdWNlUmlnaHQ7XHJcbiAgICBsb2Rhc2gucmVwZWF0ID0gcmVwZWF0O1xyXG4gICAgbG9kYXNoLnJlcGxhY2UgPSByZXBsYWNlO1xyXG4gICAgbG9kYXNoLnJlc3VsdCA9IHJlc3VsdDtcclxuICAgIGxvZGFzaC5yb3VuZCA9IHJvdW5kO1xyXG4gICAgbG9kYXNoLnJ1bkluQ29udGV4dCA9IHJ1bkluQ29udGV4dDtcclxuICAgIGxvZGFzaC5zYW1wbGUgPSBzYW1wbGU7XHJcbiAgICBsb2Rhc2guc2l6ZSA9IHNpemU7XHJcbiAgICBsb2Rhc2guc25ha2VDYXNlID0gc25ha2VDYXNlO1xyXG4gICAgbG9kYXNoLnNvbWUgPSBzb21lO1xyXG4gICAgbG9kYXNoLnNvcnRlZEluZGV4ID0gc29ydGVkSW5kZXg7XHJcbiAgICBsb2Rhc2guc29ydGVkSW5kZXhCeSA9IHNvcnRlZEluZGV4Qnk7XHJcbiAgICBsb2Rhc2guc29ydGVkSW5kZXhPZiA9IHNvcnRlZEluZGV4T2Y7XHJcbiAgICBsb2Rhc2guc29ydGVkTGFzdEluZGV4ID0gc29ydGVkTGFzdEluZGV4O1xyXG4gICAgbG9kYXNoLnNvcnRlZExhc3RJbmRleEJ5ID0gc29ydGVkTGFzdEluZGV4Qnk7XHJcbiAgICBsb2Rhc2guc29ydGVkTGFzdEluZGV4T2YgPSBzb3J0ZWRMYXN0SW5kZXhPZjtcclxuICAgIGxvZGFzaC5zdGFydENhc2UgPSBzdGFydENhc2U7XHJcbiAgICBsb2Rhc2guc3RhcnRzV2l0aCA9IHN0YXJ0c1dpdGg7XHJcbiAgICBsb2Rhc2guc3VidHJhY3QgPSBzdWJ0cmFjdDtcclxuICAgIGxvZGFzaC5zdW0gPSBzdW07XHJcbiAgICBsb2Rhc2guc3VtQnkgPSBzdW1CeTtcclxuICAgIGxvZGFzaC50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xyXG4gICAgbG9kYXNoLnRpbWVzID0gdGltZXM7XHJcbiAgICBsb2Rhc2gudG9GaW5pdGUgPSB0b0Zpbml0ZTtcclxuICAgIGxvZGFzaC50b0ludGVnZXIgPSB0b0ludGVnZXI7XHJcbiAgICBsb2Rhc2gudG9MZW5ndGggPSB0b0xlbmd0aDtcclxuICAgIGxvZGFzaC50b0xvd2VyID0gdG9Mb3dlcjtcclxuICAgIGxvZGFzaC50b051bWJlciA9IHRvTnVtYmVyO1xyXG4gICAgbG9kYXNoLnRvU2FmZUludGVnZXIgPSB0b1NhZmVJbnRlZ2VyO1xyXG4gICAgbG9kYXNoLnRvU3RyaW5nID0gdG9TdHJpbmc7XHJcbiAgICBsb2Rhc2gudG9VcHBlciA9IHRvVXBwZXI7XHJcbiAgICBsb2Rhc2gudHJpbSA9IHRyaW07XHJcbiAgICBsb2Rhc2gudHJpbUVuZCA9IHRyaW1FbmQ7XHJcbiAgICBsb2Rhc2gudHJpbVN0YXJ0ID0gdHJpbVN0YXJ0O1xyXG4gICAgbG9kYXNoLnRydW5jYXRlID0gdHJ1bmNhdGU7XHJcbiAgICBsb2Rhc2gudW5lc2NhcGUgPSB1bmVzY2FwZTtcclxuICAgIGxvZGFzaC51bmlxdWVJZCA9IHVuaXF1ZUlkO1xyXG4gICAgbG9kYXNoLnVwcGVyQ2FzZSA9IHVwcGVyQ2FzZTtcclxuICAgIGxvZGFzaC51cHBlckZpcnN0ID0gdXBwZXJGaXJzdDtcclxuXHJcbiAgICAvLyBBZGQgYWxpYXNlcy5cclxuICAgIGxvZGFzaC5lYWNoID0gZm9yRWFjaDtcclxuICAgIGxvZGFzaC5lYWNoUmlnaHQgPSBmb3JFYWNoUmlnaHQ7XHJcbiAgICBsb2Rhc2guZmlyc3QgPSBoZWFkO1xyXG5cclxuICAgIG1peGluKGxvZGFzaCwgKGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgc291cmNlID0ge307XHJcbiAgICAgIGJhc2VGb3JPd24obG9kYXNoLCBmdW5jdGlvbihmdW5jLCBtZXRob2ROYW1lKSB7XHJcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKGxvZGFzaC5wcm90b3R5cGUsIG1ldGhvZE5hbWUpKSB7XHJcbiAgICAgICAgICBzb3VyY2VbbWV0aG9kTmFtZV0gPSBmdW5jO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiBzb3VyY2U7XHJcbiAgICB9KCkpLCB7ICdjaGFpbic6IGZhbHNlIH0pO1xyXG5cclxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzZW1hbnRpYyB2ZXJzaW9uIG51bWJlci5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWVtYmVyT2YgX1xyXG4gICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAqL1xyXG4gICAgbG9kYXNoLlZFUlNJT04gPSBWRVJTSU9OO1xyXG5cclxuICAgIC8vIEFzc2lnbiBkZWZhdWx0IHBsYWNlaG9sZGVycy5cclxuICAgIGFycmF5RWFjaChbJ2JpbmQnLCAnYmluZEtleScsICdjdXJyeScsICdjdXJyeVJpZ2h0JywgJ3BhcnRpYWwnLCAncGFydGlhbFJpZ2h0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcclxuICAgICAgbG9kYXNoW21ldGhvZE5hbWVdLnBsYWNlaG9sZGVyID0gbG9kYXNoO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyBmb3IgYF8uZHJvcGAgYW5kIGBfLnRha2VgIHZhcmlhbnRzLlxyXG4gICAgYXJyYXlFYWNoKFsnZHJvcCcsICd0YWtlJ10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XHJcbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKG4pIHtcclxuICAgICAgICBuID0gbiA9PT0gdW5kZWZpbmVkID8gMSA6IG5hdGl2ZU1heCh0b0ludGVnZXIobiksIDApO1xyXG5cclxuICAgICAgICB2YXIgcmVzdWx0ID0gKHRoaXMuX19maWx0ZXJlZF9fICYmICFpbmRleClcclxuICAgICAgICAgID8gbmV3IExhenlXcmFwcGVyKHRoaXMpXHJcbiAgICAgICAgICA6IHRoaXMuY2xvbmUoKTtcclxuXHJcbiAgICAgICAgaWYgKHJlc3VsdC5fX2ZpbHRlcmVkX18pIHtcclxuICAgICAgICAgIHJlc3VsdC5fX3Rha2VDb3VudF9fID0gbmF0aXZlTWluKG4sIHJlc3VsdC5fX3Rha2VDb3VudF9fKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmVzdWx0Ll9fdmlld3NfXy5wdXNoKHtcclxuICAgICAgICAgICAgJ3NpemUnOiBuYXRpdmVNaW4obiwgTUFYX0FSUkFZX0xFTkdUSCksXHJcbiAgICAgICAgICAgICd0eXBlJzogbWV0aG9kTmFtZSArIChyZXN1bHQuX19kaXJfXyA8IDAgPyAnUmlnaHQnIDogJycpXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lICsgJ1JpZ2h0J10gPSBmdW5jdGlvbihuKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpW21ldGhvZE5hbWVdKG4pLnJldmVyc2UoKTtcclxuICAgICAgfTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgdGhhdCBhY2NlcHQgYW4gYGl0ZXJhdGVlYCB2YWx1ZS5cclxuICAgIGFycmF5RWFjaChbJ2ZpbHRlcicsICdtYXAnLCAndGFrZVdoaWxlJ10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XHJcbiAgICAgIHZhciB0eXBlID0gaW5kZXggKyAxLFxyXG4gICAgICAgICAgaXNGaWx0ZXIgPSB0eXBlID09IExBWllfRklMVEVSX0ZMQUcgfHwgdHlwZSA9PSBMQVpZX1dISUxFX0ZMQUc7XHJcblxyXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbihpdGVyYXRlZSkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNsb25lKCk7XHJcbiAgICAgICAgcmVzdWx0Ll9faXRlcmF0ZWVzX18ucHVzaCh7XHJcbiAgICAgICAgICAnaXRlcmF0ZWUnOiBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMyksXHJcbiAgICAgICAgICAndHlwZSc6IHR5cGVcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXN1bHQuX19maWx0ZXJlZF9fID0gcmVzdWx0Ll9fZmlsdGVyZWRfXyB8fCBpc0ZpbHRlcjtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICB9O1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyBmb3IgYF8uaGVhZGAgYW5kIGBfLmxhc3RgLlxyXG4gICAgYXJyYXlFYWNoKFsnaGVhZCcsICdsYXN0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XHJcbiAgICAgIHZhciB0YWtlTmFtZSA9ICd0YWtlJyArIChpbmRleCA/ICdSaWdodCcgOiAnJyk7XHJcblxyXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpc1t0YWtlTmFtZV0oMSkudmFsdWUoKVswXTtcclxuICAgICAgfTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgZm9yIGBfLmluaXRpYWxgIGFuZCBgXy50YWlsYC5cclxuICAgIGFycmF5RWFjaChbJ2luaXRpYWwnLCAndGFpbCddLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xyXG4gICAgICB2YXIgZHJvcE5hbWUgPSAnZHJvcCcgKyAoaW5kZXggPyAnJyA6ICdSaWdodCcpO1xyXG5cclxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX19maWx0ZXJlZF9fID8gbmV3IExhenlXcmFwcGVyKHRoaXMpIDogdGhpc1tkcm9wTmFtZV0oMSk7XHJcbiAgICAgIH07XHJcbiAgICB9KTtcclxuXHJcbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuY29tcGFjdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIoaWRlbnRpdHkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIocHJlZGljYXRlKS5oZWFkKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5maW5kTGFzdCA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKCkuZmluZChwcmVkaWNhdGUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuaW52b2tlTWFwID0gYmFzZVJlc3QoZnVuY3Rpb24ocGF0aCwgYXJncykge1xyXG4gICAgICBpZiAodHlwZW9mIHBhdGggPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHJldHVybiBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIGJhc2VJbnZva2UodmFsdWUsIHBhdGgsIGFyZ3MpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5yZWplY3QgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKG5lZ2F0ZShnZXRJdGVyYXRlZShwcmVkaWNhdGUpKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcclxuICAgICAgc3RhcnQgPSB0b0ludGVnZXIoc3RhcnQpO1xyXG5cclxuICAgICAgdmFyIHJlc3VsdCA9IHRoaXM7XHJcbiAgICAgIGlmIChyZXN1bHQuX19maWx0ZXJlZF9fICYmIChzdGFydCA+IDAgfHwgZW5kIDwgMCkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IExhenlXcmFwcGVyKHJlc3VsdCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHN0YXJ0IDwgMCkge1xyXG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC50YWtlUmlnaHQoLXN0YXJ0KTtcclxuICAgICAgfSBlbHNlIGlmIChzdGFydCkge1xyXG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5kcm9wKHN0YXJ0KTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoZW5kICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBlbmQgPSB0b0ludGVnZXIoZW5kKTtcclxuICAgICAgICByZXN1bHQgPSBlbmQgPCAwID8gcmVzdWx0LmRyb3BSaWdodCgtZW5kKSA6IHJlc3VsdC50YWtlKGVuZCAtIHN0YXJ0KTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuXHJcbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUudGFrZVJpZ2h0V2hpbGUgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpLnRha2VXaGlsZShwcmVkaWNhdGUpLnJldmVyc2UoKTtcclxuICAgIH07XHJcblxyXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIHRoaXMudGFrZShNQVhfQVJSQVlfTEVOR1RIKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyB0byBgbG9kYXNoLnByb3RvdHlwZWAuXHJcbiAgICBiYXNlRm9yT3duKExhenlXcmFwcGVyLnByb3RvdHlwZSwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xyXG4gICAgICB2YXIgY2hlY2tJdGVyYXRlZSA9IC9eKD86ZmlsdGVyfGZpbmR8bWFwfHJlamVjdCl8V2hpbGUkLy50ZXN0KG1ldGhvZE5hbWUpLFxyXG4gICAgICAgICAgaXNUYWtlciA9IC9eKD86aGVhZHxsYXN0KSQvLnRlc3QobWV0aG9kTmFtZSksXHJcbiAgICAgICAgICBsb2Rhc2hGdW5jID0gbG9kYXNoW2lzVGFrZXIgPyAoJ3Rha2UnICsgKG1ldGhvZE5hbWUgPT0gJ2xhc3QnID8gJ1JpZ2h0JyA6ICcnKSkgOiBtZXRob2ROYW1lXSxcclxuICAgICAgICAgIHJldFVud3JhcHBlZCA9IGlzVGFrZXIgfHwgL15maW5kLy50ZXN0KG1ldGhvZE5hbWUpO1xyXG5cclxuICAgICAgaWYgKCFsb2Rhc2hGdW5jKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9fd3JhcHBlZF9fLFxyXG4gICAgICAgICAgICBhcmdzID0gaXNUYWtlciA/IFsxXSA6IGFyZ3VtZW50cyxcclxuICAgICAgICAgICAgaXNMYXp5ID0gdmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcixcclxuICAgICAgICAgICAgaXRlcmF0ZWUgPSBhcmdzWzBdLFxyXG4gICAgICAgICAgICB1c2VMYXp5ID0gaXNMYXp5IHx8IGlzQXJyYXkodmFsdWUpO1xyXG5cclxuICAgICAgICB2YXIgaW50ZXJjZXB0b3IgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGxvZGFzaEZ1bmMuYXBwbHkobG9kYXNoLCBhcnJheVB1c2goW3ZhbHVlXSwgYXJncykpO1xyXG4gICAgICAgICAgcmV0dXJuIChpc1Rha2VyICYmIGNoYWluQWxsKSA/IHJlc3VsdFswXSA6IHJlc3VsdDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBpZiAodXNlTGF6eSAmJiBjaGVja0l0ZXJhdGVlICYmIHR5cGVvZiBpdGVyYXRlZSA9PSAnZnVuY3Rpb24nICYmIGl0ZXJhdGVlLmxlbmd0aCAhPSAxKSB7XHJcbiAgICAgICAgICAvLyBBdm9pZCBsYXp5IHVzZSBpZiB0aGUgaXRlcmF0ZWUgaGFzIGEgXCJsZW5ndGhcIiB2YWx1ZSBvdGhlciB0aGFuIGAxYC5cclxuICAgICAgICAgIGlzTGF6eSA9IHVzZUxhenkgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNoYWluQWxsID0gdGhpcy5fX2NoYWluX18sXHJcbiAgICAgICAgICAgIGlzSHlicmlkID0gISF0aGlzLl9fYWN0aW9uc19fLmxlbmd0aCxcclxuICAgICAgICAgICAgaXNVbndyYXBwZWQgPSByZXRVbndyYXBwZWQgJiYgIWNoYWluQWxsLFxyXG4gICAgICAgICAgICBvbmx5TGF6eSA9IGlzTGF6eSAmJiAhaXNIeWJyaWQ7XHJcblxyXG4gICAgICAgIGlmICghcmV0VW53cmFwcGVkICYmIHVzZUxhenkpIHtcclxuICAgICAgICAgIHZhbHVlID0gb25seUxhenkgPyB2YWx1ZSA6IG5ldyBMYXp5V3JhcHBlcih0aGlzKTtcclxuICAgICAgICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHZhbHVlLCBhcmdzKTtcclxuICAgICAgICAgIHJlc3VsdC5fX2FjdGlvbnNfXy5wdXNoKHsgJ2Z1bmMnOiB0aHJ1LCAnYXJncyc6IFtpbnRlcmNlcHRvcl0sICd0aGlzQXJnJzogdW5kZWZpbmVkIH0pO1xyXG4gICAgICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHJlc3VsdCwgY2hhaW5BbGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNVbndyYXBwZWQgJiYgb25seUxhenkpIHtcclxuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQgPSB0aGlzLnRocnUoaW50ZXJjZXB0b3IpO1xyXG4gICAgICAgIHJldHVybiBpc1Vud3JhcHBlZCA/IChpc1Rha2VyID8gcmVzdWx0LnZhbHVlKClbMF0gOiByZXN1bHQudmFsdWUoKSkgOiByZXN1bHQ7XHJcbiAgICAgIH07XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBBZGQgYEFycmF5YCBtZXRob2RzIHRvIGBsb2Rhc2gucHJvdG90eXBlYC5cclxuICAgIGFycmF5RWFjaChbJ3BvcCcsICdwdXNoJywgJ3NoaWZ0JywgJ3NvcnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xyXG4gICAgICB2YXIgZnVuYyA9IGFycmF5UHJvdG9bbWV0aG9kTmFtZV0sXHJcbiAgICAgICAgICBjaGFpbk5hbWUgPSAvXig/OnB1c2h8c29ydHx1bnNoaWZ0KSQvLnRlc3QobWV0aG9kTmFtZSkgPyAndGFwJyA6ICd0aHJ1JyxcclxuICAgICAgICAgIHJldFVud3JhcHBlZCA9IC9eKD86cG9wfHNoaWZ0KSQvLnRlc3QobWV0aG9kTmFtZSk7XHJcblxyXG4gICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XHJcbiAgICAgICAgaWYgKHJldFVud3JhcHBlZCAmJiAhdGhpcy5fX2NoYWluX18pIHtcclxuICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWUoKTtcclxuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbXSwgYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzW2NoYWluTmFtZV0oZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbXSwgYXJncyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH07XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBNYXAgbWluaWZpZWQgbWV0aG9kIG5hbWVzIHRvIHRoZWlyIHJlYWwgbmFtZXMuXHJcbiAgICBiYXNlRm9yT3duKExhenlXcmFwcGVyLnByb3RvdHlwZSwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xyXG4gICAgICB2YXIgbG9kYXNoRnVuYyA9IGxvZGFzaFttZXRob2ROYW1lXTtcclxuICAgICAgaWYgKGxvZGFzaEZ1bmMpIHtcclxuICAgICAgICB2YXIga2V5ID0gbG9kYXNoRnVuYy5uYW1lICsgJyc7XHJcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlYWxOYW1lcywga2V5KSkge1xyXG4gICAgICAgICAgcmVhbE5hbWVzW2tleV0gPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVhbE5hbWVzW2tleV0ucHVzaCh7ICduYW1lJzogbWV0aG9kTmFtZSwgJ2Z1bmMnOiBsb2Rhc2hGdW5jIH0pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZWFsTmFtZXNbY3JlYXRlSHlicmlkKHVuZGVmaW5lZCwgV1JBUF9CSU5EX0tFWV9GTEFHKS5uYW1lXSA9IFt7XHJcbiAgICAgICduYW1lJzogJ3dyYXBwZXInLFxyXG4gICAgICAnZnVuYyc6IHVuZGVmaW5lZFxyXG4gICAgfV07XHJcblxyXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYExhenlXcmFwcGVyYC5cclxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5jbG9uZSA9IGxhenlDbG9uZTtcclxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5yZXZlcnNlID0gbGF6eVJldmVyc2U7XHJcbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUudmFsdWUgPSBsYXp5VmFsdWU7XHJcblxyXG4gICAgLy8gQWRkIGNoYWluIHNlcXVlbmNlIG1ldGhvZHMgdG8gdGhlIGBsb2Rhc2hgIHdyYXBwZXIuXHJcbiAgICBsb2Rhc2gucHJvdG90eXBlLmF0ID0gd3JhcHBlckF0O1xyXG4gICAgbG9kYXNoLnByb3RvdHlwZS5jaGFpbiA9IHdyYXBwZXJDaGFpbjtcclxuICAgIGxvZGFzaC5wcm90b3R5cGUuY29tbWl0ID0gd3JhcHBlckNvbW1pdDtcclxuICAgIGxvZGFzaC5wcm90b3R5cGUubmV4dCA9IHdyYXBwZXJOZXh0O1xyXG4gICAgbG9kYXNoLnByb3RvdHlwZS5wbGFudCA9IHdyYXBwZXJQbGFudDtcclxuICAgIGxvZGFzaC5wcm90b3R5cGUucmV2ZXJzZSA9IHdyYXBwZXJSZXZlcnNlO1xyXG4gICAgbG9kYXNoLnByb3RvdHlwZS50b0pTT04gPSBsb2Rhc2gucHJvdG90eXBlLnZhbHVlT2YgPSBsb2Rhc2gucHJvdG90eXBlLnZhbHVlID0gd3JhcHBlclZhbHVlO1xyXG5cclxuICAgIC8vIEFkZCBsYXp5IGFsaWFzZXMuXHJcbiAgICBsb2Rhc2gucHJvdG90eXBlLmZpcnN0ID0gbG9kYXNoLnByb3RvdHlwZS5oZWFkO1xyXG5cclxuICAgIGlmIChzeW1JdGVyYXRvcikge1xyXG4gICAgICBsb2Rhc2gucHJvdG90eXBlW3N5bUl0ZXJhdG9yXSA9IHdyYXBwZXJUb0l0ZXJhdG9yO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxvZGFzaDtcclxuICB9KTtcclxuXHJcbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcblxyXG4gIC8vIEV4cG9ydCBsb2Rhc2guXHJcbiAgdmFyIF8gPSBydW5JbkNvbnRleHQoKTtcclxuXHJcbiAgLy8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3IgY29uZGl0aW9uIHBhdHRlcm5zIGxpa2U6XHJcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAvLyBFeHBvc2UgTG9kYXNoIG9uIHRoZSBnbG9iYWwgb2JqZWN0IHRvIHByZXZlbnQgZXJyb3JzIHdoZW4gTG9kYXNoIGlzXHJcbiAgICAvLyBsb2FkZWQgYnkgYSBzY3JpcHQgdGFnIGluIHRoZSBwcmVzZW5jZSBvZiBhbiBBTUQgbG9hZGVyLlxyXG4gICAgLy8gU2VlIGh0dHA6Ly9yZXF1aXJlanMub3JnL2RvY3MvZXJyb3JzLmh0bWwjbWlzbWF0Y2ggZm9yIG1vcmUgZGV0YWlscy5cclxuICAgIC8vIFVzZSBgXy5ub0NvbmZsaWN0YCB0byByZW1vdmUgTG9kYXNoIGZyb20gdGhlIGdsb2JhbCBvYmplY3QuXHJcbiAgICByb290Ll8gPSBfO1xyXG5cclxuICAgIC8vIERlZmluZSBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlIHNvLCB0aHJvdWdoIHBhdGggbWFwcGluZywgaXQgY2FuIGJlXHJcbiAgICAvLyByZWZlcmVuY2VkIGFzIHRoZSBcInVuZGVyc2NvcmVcIiBtb2R1bGUuXHJcbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiBfO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIC8vIENoZWNrIGZvciBgZXhwb3J0c2AgYWZ0ZXIgYGRlZmluZWAgaW4gY2FzZSBhIGJ1aWxkIG9wdGltaXplciBhZGRzIGl0LlxyXG4gIGVsc2UgaWYgKGZyZWVNb2R1bGUpIHtcclxuICAgIC8vIEV4cG9ydCBmb3IgTm9kZS5qcy5cclxuICAgIChmcmVlTW9kdWxlLmV4cG9ydHMgPSBfKS5fID0gXztcclxuICAgIC8vIEV4cG9ydCBmb3IgQ29tbW9uSlMgc3VwcG9ydC5cclxuICAgIGZyZWVFeHBvcnRzLl8gPSBfO1xyXG4gIH1cclxuICBlbHNlIHtcclxuICAgIC8vIEV4cG9ydCB0byB0aGUgZ2xvYmFsIG9iamVjdC5cclxuICAgIHJvb3QuXyA9IF87XHJcbiAgfVxyXG59LmNhbGwodGhpcykpO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lodash/lodash.js\n");

/***/ }),

/***/ "./node_modules/loglevel/lib/loglevel.js":
/*!***********************************************!*\
  !*** ./node_modules/loglevel/lib/loglevel.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\r\n* loglevel - https://github.com/pimterry/loglevel\r\n*\r\n* Copyright (c) 2013 Tim Perry\r\n* Licensed under the MIT license.\r\n*/\r\n(function (root, definition) {\r\n    \"use strict\";\r\n    if (true) {\r\n        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n    } else {}\r\n}(this, function () {\r\n    \"use strict\";\r\n\r\n    // Slightly dubious tricks to cut down minimized file size\r\n    var noop = function() {};\r\n    var undefinedType = \"undefined\";\r\n    var isIE = (typeof window !== undefinedType) && (typeof window.navigator !== undefinedType) && (\r\n        /Trident\\/|MSIE /.test(window.navigator.userAgent)\r\n    );\r\n\r\n    var logMethods = [\r\n        \"trace\",\r\n        \"debug\",\r\n        \"info\",\r\n        \"warn\",\r\n        \"error\"\r\n    ];\r\n\r\n    // Cross-browser bind equivalent that works at least back to IE6\r\n    function bindMethod(obj, methodName) {\r\n        var method = obj[methodName];\r\n        if (typeof method.bind === 'function') {\r\n            return method.bind(obj);\r\n        } else {\r\n            try {\r\n                return Function.prototype.bind.call(method, obj);\r\n            } catch (e) {\r\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\r\n                return function() {\r\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    // Trace() doesn't print the message in IE, so for that case we need to wrap it\r\n    function traceForIE() {\r\n        if (console.log) {\r\n            if (console.log.apply) {\r\n                console.log.apply(console, arguments);\r\n            } else {\r\n                // In old IE, native console methods themselves don't have apply().\r\n                Function.prototype.apply.apply(console.log, [console, arguments]);\r\n            }\r\n        }\r\n        if (console.trace) console.trace();\r\n    }\r\n\r\n    // Build the best logging method possible for this env\r\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\r\n    function realMethod(methodName) {\r\n        if (methodName === 'debug') {\r\n            methodName = 'log';\r\n        }\r\n\r\n        if (typeof console === undefinedType) {\r\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\r\n        } else if (methodName === 'trace' && isIE) {\r\n            return traceForIE;\r\n        } else if (console[methodName] !== undefined) {\r\n            return bindMethod(console, methodName);\r\n        } else if (console.log !== undefined) {\r\n            return bindMethod(console, 'log');\r\n        } else {\r\n            return noop;\r\n        }\r\n    }\r\n\r\n    // These private functions always need `this` to be set properly\r\n\r\n    function replaceLoggingMethods(level, loggerName) {\r\n        /*jshint validthis:true */\r\n        for (var i = 0; i < logMethods.length; i++) {\r\n            var methodName = logMethods[i];\r\n            this[methodName] = (i < level) ?\r\n                noop :\r\n                this.methodFactory(methodName, level, loggerName);\r\n        }\r\n\r\n        // Define log.log as an alias for log.debug\r\n        this.log = this.debug;\r\n    }\r\n\r\n    // In old IE versions, the console isn't present until you first open it.\r\n    // We build realMethod() replacements here that regenerate logging methods\r\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\r\n        return function () {\r\n            if (typeof console !== undefinedType) {\r\n                replaceLoggingMethods.call(this, level, loggerName);\r\n                this[methodName].apply(this, arguments);\r\n            }\r\n        };\r\n    }\r\n\r\n    // By default, we use closely bound real methods wherever possible, and\r\n    // otherwise we wait for a console to appear, and then try again.\r\n    function defaultMethodFactory(methodName, level, loggerName) {\r\n        /*jshint validthis:true */\r\n        return realMethod(methodName) ||\r\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\r\n    }\r\n\r\n    function Logger(name, defaultLevel, factory) {\r\n      var self = this;\r\n      var currentLevel;\r\n      defaultLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\r\n\r\n      var storageKey = \"loglevel\";\r\n      if (typeof name === \"string\") {\r\n        storageKey += \":\" + name;\r\n      } else if (typeof name === \"symbol\") {\r\n        storageKey = undefined;\r\n      }\r\n\r\n      function persistLevelIfPossible(levelNum) {\r\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\r\n\r\n          if (typeof window === undefinedType || !storageKey) return;\r\n\r\n          // Use localStorage if available\r\n          try {\r\n              window.localStorage[storageKey] = levelName;\r\n              return;\r\n          } catch (ignore) {}\r\n\r\n          // Use session cookie as fallback\r\n          try {\r\n              window.document.cookie =\r\n                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\r\n          } catch (ignore) {}\r\n      }\r\n\r\n      function getPersistedLevel() {\r\n          var storedLevel;\r\n\r\n          if (typeof window === undefinedType || !storageKey) return;\r\n\r\n          try {\r\n              storedLevel = window.localStorage[storageKey];\r\n          } catch (ignore) {}\r\n\r\n          // Fallback to cookies if local storage gives us nothing\r\n          if (typeof storedLevel === undefinedType) {\r\n              try {\r\n                  var cookie = window.document.cookie;\r\n                  var location = cookie.indexOf(\r\n                      encodeURIComponent(storageKey) + \"=\");\r\n                  if (location !== -1) {\r\n                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\r\n                  }\r\n              } catch (ignore) {}\r\n          }\r\n\r\n          // If the stored level is not valid, treat it as if nothing was stored.\r\n          if (self.levels[storedLevel] === undefined) {\r\n              storedLevel = undefined;\r\n          }\r\n\r\n          return storedLevel;\r\n      }\r\n\r\n      function clearPersistedLevel() {\r\n          if (typeof window === undefinedType || !storageKey) return;\r\n\r\n          // Use localStorage if available\r\n          try {\r\n              window.localStorage.removeItem(storageKey);\r\n              return;\r\n          } catch (ignore) {}\r\n\r\n          // Use session cookie as fallback\r\n          try {\r\n              window.document.cookie =\r\n                encodeURIComponent(storageKey) + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC\";\r\n          } catch (ignore) {}\r\n      }\r\n\r\n      /*\r\n       *\r\n       * Public logger API - see https://github.com/pimterry/loglevel for details\r\n       *\r\n       */\r\n\r\n      self.name = name;\r\n\r\n      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\r\n          \"ERROR\": 4, \"SILENT\": 5};\r\n\r\n      self.methodFactory = factory || defaultMethodFactory;\r\n\r\n      self.getLevel = function () {\r\n          return currentLevel;\r\n      };\r\n\r\n      self.setLevel = function (level, persist) {\r\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\r\n              level = self.levels[level.toUpperCase()];\r\n          }\r\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\r\n              currentLevel = level;\r\n              if (persist !== false) {  // defaults to true\r\n                  persistLevelIfPossible(level);\r\n              }\r\n              replaceLoggingMethods.call(self, level, name);\r\n              if (typeof console === undefinedType && level < self.levels.SILENT) {\r\n                  return \"No console available for logging\";\r\n              }\r\n          } else {\r\n              throw \"log.setLevel() called with invalid level: \" + level;\r\n          }\r\n      };\r\n\r\n      self.setDefaultLevel = function (level) {\r\n          defaultLevel = level;\r\n          if (!getPersistedLevel()) {\r\n              self.setLevel(level, false);\r\n          }\r\n      };\r\n\r\n      self.resetLevel = function () {\r\n          self.setLevel(defaultLevel, false);\r\n          clearPersistedLevel();\r\n      };\r\n\r\n      self.enableAll = function(persist) {\r\n          self.setLevel(self.levels.TRACE, persist);\r\n      };\r\n\r\n      self.disableAll = function(persist) {\r\n          self.setLevel(self.levels.SILENT, persist);\r\n      };\r\n\r\n      // Initialize with the right level\r\n      var initialLevel = getPersistedLevel();\r\n      if (initialLevel == null) {\r\n          initialLevel = defaultLevel;\r\n      }\r\n      self.setLevel(initialLevel, false);\r\n    }\r\n\r\n    /*\r\n     *\r\n     * Top-level API\r\n     *\r\n     */\r\n\r\n    var defaultLogger = new Logger();\r\n\r\n    var _loggersByName = {};\r\n    defaultLogger.getLogger = function getLogger(name) {\r\n        if ((typeof name !== \"symbol\" && typeof name !== \"string\") || name === \"\") {\r\n          throw new TypeError(\"You must supply a name when creating a logger.\");\r\n        }\r\n\r\n        var logger = _loggersByName[name];\r\n        if (!logger) {\r\n          logger = _loggersByName[name] = new Logger(\r\n            name, defaultLogger.getLevel(), defaultLogger.methodFactory);\r\n        }\r\n        return logger;\r\n    };\r\n\r\n    // Grab the current global log variable in case of overwrite\r\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\r\n    defaultLogger.noConflict = function() {\r\n        if (typeof window !== undefinedType &&\r\n               window.log === defaultLogger) {\r\n            window.log = _log;\r\n        }\r\n\r\n        return defaultLogger;\r\n    };\r\n\r\n    defaultLogger.getLoggers = function getLoggers() {\r\n        return _loggersByName;\r\n    };\r\n\r\n    // ES6 default export, for compatibility\r\n    defaultLogger['default'] = defaultLogger;\r\n\r\n    return defaultLogger;\r\n}));\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9nbGV2ZWwvbGliL2xvZ2xldmVsLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQTBDO0FBQ2xELFFBQVEsb0NBQU8sVUFBVTtBQUFBO0FBQUE7QUFBQTtBQUFBLGtHQUFDO0FBQzFCLE1BQU0sS0FBSyxFQUlOO0FBQ0wsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckUsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9nbGV2ZWwvbGliL2xvZ2xldmVsLmpzPzY4NmMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuKiBsb2dsZXZlbCAtIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbFxyXG4qXHJcbiogQ29weXJpZ2h0IChjKSAyMDEzIFRpbSBQZXJyeVxyXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cclxuKi9cclxuKGZ1bmN0aW9uIChyb290LCBkZWZpbml0aW9uKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcclxuICAgICAgICBkZWZpbmUoZGVmaW5pdGlvbik7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XHJcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJvb3QubG9nID0gZGVmaW5pdGlvbigpO1xyXG4gICAgfVxyXG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAgIC8vIFNsaWdodGx5IGR1YmlvdXMgdHJpY2tzIHRvIGN1dCBkb3duIG1pbmltaXplZCBmaWxlIHNpemVcclxuICAgIHZhciBub29wID0gZnVuY3Rpb24oKSB7fTtcclxuICAgIHZhciB1bmRlZmluZWRUeXBlID0gXCJ1bmRlZmluZWRcIjtcclxuICAgIHZhciBpc0lFID0gKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUpICYmICh0eXBlb2Ygd2luZG93Lm5hdmlnYXRvciAhPT0gdW5kZWZpbmVkVHlwZSkgJiYgKFxyXG4gICAgICAgIC9UcmlkZW50XFwvfE1TSUUgLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KVxyXG4gICAgKTtcclxuXHJcbiAgICB2YXIgbG9nTWV0aG9kcyA9IFtcclxuICAgICAgICBcInRyYWNlXCIsXHJcbiAgICAgICAgXCJkZWJ1Z1wiLFxyXG4gICAgICAgIFwiaW5mb1wiLFxyXG4gICAgICAgIFwid2FyblwiLFxyXG4gICAgICAgIFwiZXJyb3JcIlxyXG4gICAgXTtcclxuXHJcbiAgICAvLyBDcm9zcy1icm93c2VyIGJpbmQgZXF1aXZhbGVudCB0aGF0IHdvcmtzIGF0IGxlYXN0IGJhY2sgdG8gSUU2XHJcbiAgICBmdW5jdGlvbiBiaW5kTWV0aG9kKG9iaiwgbWV0aG9kTmFtZSkge1xyXG4gICAgICAgIHZhciBtZXRob2QgPSBvYmpbbWV0aG9kTmFtZV07XHJcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QuYmluZCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kLmJpbmQob2JqKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwobWV0aG9kLCBvYmopO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBNaXNzaW5nIGJpbmQgc2hpbSBvciBJRTggKyBNb2Rlcm5penIsIGZhbGxiYWNrIHRvIHdyYXBwaW5nXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseShtZXRob2QsIFtvYmosIGFyZ3VtZW50c10pO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBUcmFjZSgpIGRvZXNuJ3QgcHJpbnQgdGhlIG1lc3NhZ2UgaW4gSUUsIHNvIGZvciB0aGF0IGNhc2Ugd2UgbmVlZCB0byB3cmFwIGl0XHJcbiAgICBmdW5jdGlvbiB0cmFjZUZvcklFKCkge1xyXG4gICAgICAgIGlmIChjb25zb2xlLmxvZykge1xyXG4gICAgICAgICAgICBpZiAoY29uc29sZS5sb2cuYXBwbHkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJbiBvbGQgSUUsIG5hdGl2ZSBjb25zb2xlIG1ldGhvZHMgdGhlbXNlbHZlcyBkb24ndCBoYXZlIGFwcGx5KCkuXHJcbiAgICAgICAgICAgICAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkoY29uc29sZS5sb2csIFtjb25zb2xlLCBhcmd1bWVudHNdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29uc29sZS50cmFjZSkgY29uc29sZS50cmFjZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEJ1aWxkIHRoZSBiZXN0IGxvZ2dpbmcgbWV0aG9kIHBvc3NpYmxlIGZvciB0aGlzIGVudlxyXG4gICAgLy8gV2hlcmV2ZXIgcG9zc2libGUgd2Ugd2FudCB0byBiaW5kLCBub3Qgd3JhcCwgdG8gcHJlc2VydmUgc3RhY2sgdHJhY2VzXHJcbiAgICBmdW5jdGlvbiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHtcclxuICAgICAgICBpZiAobWV0aG9kTmFtZSA9PT0gJ2RlYnVnJykge1xyXG4gICAgICAgICAgICBtZXRob2ROYW1lID0gJ2xvZyc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBObyBtZXRob2QgcG9zc2libGUsIGZvciBub3cgLSBmaXhlZCBsYXRlciBieSBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzXHJcbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2ROYW1lID09PSAndHJhY2UnICYmIGlzSUUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRyYWNlRm9ySUU7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjb25zb2xlW21ldGhvZE5hbWVdICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgbWV0aG9kTmFtZSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjb25zb2xlLmxvZyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBiaW5kTWV0aG9kKGNvbnNvbGUsICdsb2cnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbm9vcDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVGhlc2UgcHJpdmF0ZSBmdW5jdGlvbnMgYWx3YXlzIG5lZWQgYHRoaXNgIHRvIGJlIHNldCBwcm9wZXJseVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlcGxhY2VMb2dnaW5nTWV0aG9kcyhsZXZlbCwgbG9nZ2VyTmFtZSkge1xyXG4gICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2dNZXRob2RzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBtZXRob2ROYW1lID0gbG9nTWV0aG9kc1tpXTtcclxuICAgICAgICAgICAgdGhpc1ttZXRob2ROYW1lXSA9IChpIDwgbGV2ZWwpID9cclxuICAgICAgICAgICAgICAgIG5vb3AgOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5tZXRob2RGYWN0b3J5KG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERlZmluZSBsb2cubG9nIGFzIGFuIGFsaWFzIGZvciBsb2cuZGVidWdcclxuICAgICAgICB0aGlzLmxvZyA9IHRoaXMuZGVidWc7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSW4gb2xkIElFIHZlcnNpb25zLCB0aGUgY29uc29sZSBpc24ndCBwcmVzZW50IHVudGlsIHlvdSBmaXJzdCBvcGVuIGl0LlxyXG4gICAgLy8gV2UgYnVpbGQgcmVhbE1ldGhvZCgpIHJlcGxhY2VtZW50cyBoZXJlIHRoYXQgcmVnZW5lcmF0ZSBsb2dnaW5nIG1ldGhvZHNcclxuICAgIGZ1bmN0aW9uIGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IHVuZGVmaW5lZFR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHRoaXMsIGxldmVsLCBsb2dnZXJOYW1lKTtcclxuICAgICAgICAgICAgICAgIHRoaXNbbWV0aG9kTmFtZV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQnkgZGVmYXVsdCwgd2UgdXNlIGNsb3NlbHkgYm91bmQgcmVhbCBtZXRob2RzIHdoZXJldmVyIHBvc3NpYmxlLCBhbmRcclxuICAgIC8vIG90aGVyd2lzZSB3ZSB3YWl0IGZvciBhIGNvbnNvbGUgdG8gYXBwZWFyLCBhbmQgdGhlbiB0cnkgYWdhaW4uXHJcbiAgICBmdW5jdGlvbiBkZWZhdWx0TWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSkge1xyXG4gICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXHJcbiAgICAgICAgcmV0dXJuIHJlYWxNZXRob2QobWV0aG9kTmFtZSkgfHxcclxuICAgICAgICAgICAgICAgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIExvZ2dlcihuYW1lLCBkZWZhdWx0TGV2ZWwsIGZhY3RvcnkpIHtcclxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICB2YXIgY3VycmVudExldmVsO1xyXG4gICAgICBkZWZhdWx0TGV2ZWwgPSBkZWZhdWx0TGV2ZWwgPT0gbnVsbCA/IFwiV0FSTlwiIDogZGVmYXVsdExldmVsO1xyXG5cclxuICAgICAgdmFyIHN0b3JhZ2VLZXkgPSBcImxvZ2xldmVsXCI7XHJcbiAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIHN0b3JhZ2VLZXkgKz0gXCI6XCIgKyBuYW1lO1xyXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBuYW1lID09PSBcInN5bWJvbFwiKSB7XHJcbiAgICAgICAgc3RvcmFnZUtleSA9IHVuZGVmaW5lZDtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbE51bSkge1xyXG4gICAgICAgICAgdmFyIGxldmVsTmFtZSA9IChsb2dNZXRob2RzW2xldmVsTnVtXSB8fCAnc2lsZW50JykudG9VcHBlckNhc2UoKTtcclxuXHJcbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSB8fCAhc3RvcmFnZUtleSkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgIC8vIFVzZSBsb2NhbFN0b3JhZ2UgaWYgYXZhaWxhYmxlXHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Vbc3RvcmFnZUtleV0gPSBsZXZlbE5hbWU7XHJcbiAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxyXG5cclxuICAgICAgICAgIC8vIFVzZSBzZXNzaW9uIGNvb2tpZSBhcyBmYWxsYmFja1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuY29va2llID1cclxuICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArIFwiPVwiICsgbGV2ZWxOYW1lICsgXCI7XCI7XHJcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIGdldFBlcnNpc3RlZExldmVsKCkge1xyXG4gICAgICAgICAgdmFyIHN0b3JlZExldmVsO1xyXG5cclxuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlIHx8ICFzdG9yYWdlS2V5KSByZXR1cm47XHJcblxyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHdpbmRvdy5sb2NhbFN0b3JhZ2Vbc3RvcmFnZUtleV07XHJcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XHJcblxyXG4gICAgICAgICAgLy8gRmFsbGJhY2sgdG8gY29va2llcyBpZiBsb2NhbCBzdG9yYWdlIGdpdmVzIHVzIG5vdGhpbmdcclxuICAgICAgICAgIGlmICh0eXBlb2Ygc3RvcmVkTGV2ZWwgPT09IHVuZGVmaW5lZFR5cGUpIHtcclxuICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICB2YXIgY29va2llID0gd2luZG93LmRvY3VtZW50LmNvb2tpZTtcclxuICAgICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gY29va2llLmluZGV4T2YoXHJcbiAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyBcIj1cIik7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChsb2NhdGlvbiAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHN0b3JlZExldmVsID0gL14oW147XSspLy5leGVjKGNvb2tpZS5zbGljZShsb2NhdGlvbikpWzFdO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIElmIHRoZSBzdG9yZWQgbGV2ZWwgaXMgbm90IHZhbGlkLCB0cmVhdCBpdCBhcyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXHJcbiAgICAgICAgICBpZiAoc2VsZi5sZXZlbHNbc3RvcmVkTGV2ZWxdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm4gc3RvcmVkTGV2ZWw7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIGNsZWFyUGVyc2lzdGVkTGV2ZWwoKSB7XHJcbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSB8fCAhc3RvcmFnZUtleSkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgIC8vIFVzZSBsb2NhbFN0b3JhZ2UgaWYgYXZhaWxhYmxlXHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShzdG9yYWdlS2V5KTtcclxuICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XHJcblxyXG4gICAgICAgICAgLy8gVXNlIHNlc3Npb24gY29va2llIGFzIGZhbGxiYWNrXHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5jb29raWUgPVxyXG4gICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgXCI9OyBleHBpcmVzPVRodSwgMDEgSmFuIDE5NzAgMDA6MDA6MDAgVVRDXCI7XHJcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8qXHJcbiAgICAgICAqXHJcbiAgICAgICAqIFB1YmxpYyBsb2dnZXIgQVBJIC0gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbCBmb3IgZGV0YWlsc1xyXG4gICAgICAgKlxyXG4gICAgICAgKi9cclxuXHJcbiAgICAgIHNlbGYubmFtZSA9IG5hbWU7XHJcblxyXG4gICAgICBzZWxmLmxldmVscyA9IHsgXCJUUkFDRVwiOiAwLCBcIkRFQlVHXCI6IDEsIFwiSU5GT1wiOiAyLCBcIldBUk5cIjogMyxcclxuICAgICAgICAgIFwiRVJST1JcIjogNCwgXCJTSUxFTlRcIjogNX07XHJcblxyXG4gICAgICBzZWxmLm1ldGhvZEZhY3RvcnkgPSBmYWN0b3J5IHx8IGRlZmF1bHRNZXRob2RGYWN0b3J5O1xyXG5cclxuICAgICAgc2VsZi5nZXRMZXZlbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHJldHVybiBjdXJyZW50TGV2ZWw7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBzZWxmLnNldExldmVsID0gZnVuY3Rpb24gKGxldmVsLCBwZXJzaXN0KSB7XHJcbiAgICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcInN0cmluZ1wiICYmIHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICBsZXZlbCA9IHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJudW1iZXJcIiAmJiBsZXZlbCA+PSAwICYmIGxldmVsIDw9IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xyXG4gICAgICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IGxldmVsO1xyXG4gICAgICAgICAgICAgIGlmIChwZXJzaXN0ICE9PSBmYWxzZSkgeyAgLy8gZGVmYXVsdHMgdG8gdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwoc2VsZiwgbGV2ZWwsIG5hbWUpO1xyXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSAmJiBsZXZlbCA8IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gXCJObyBjb25zb2xlIGF2YWlsYWJsZSBmb3IgbG9nZ2luZ1wiO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgXCJsb2cuc2V0TGV2ZWwoKSBjYWxsZWQgd2l0aCBpbnZhbGlkIGxldmVsOiBcIiArIGxldmVsO1xyXG4gICAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgc2VsZi5zZXREZWZhdWx0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwpIHtcclxuICAgICAgICAgIGRlZmF1bHRMZXZlbCA9IGxldmVsO1xyXG4gICAgICAgICAgaWYgKCFnZXRQZXJzaXN0ZWRMZXZlbCgpKSB7XHJcbiAgICAgICAgICAgICAgc2VsZi5zZXRMZXZlbChsZXZlbCwgZmFsc2UpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgc2VsZi5yZXNldExldmVsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChkZWZhdWx0TGV2ZWwsIGZhbHNlKTtcclxuICAgICAgICAgIGNsZWFyUGVyc2lzdGVkTGV2ZWwoKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHNlbGYuZW5hYmxlQWxsID0gZnVuY3Rpb24ocGVyc2lzdCkge1xyXG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5UUkFDRSwgcGVyc2lzdCk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBzZWxmLmRpc2FibGVBbGwgPSBmdW5jdGlvbihwZXJzaXN0KSB7XHJcbiAgICAgICAgICBzZWxmLnNldExldmVsKHNlbGYubGV2ZWxzLlNJTEVOVCwgcGVyc2lzdCk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvLyBJbml0aWFsaXplIHdpdGggdGhlIHJpZ2h0IGxldmVsXHJcbiAgICAgIHZhciBpbml0aWFsTGV2ZWwgPSBnZXRQZXJzaXN0ZWRMZXZlbCgpO1xyXG4gICAgICBpZiAoaW5pdGlhbExldmVsID09IG51bGwpIHtcclxuICAgICAgICAgIGluaXRpYWxMZXZlbCA9IGRlZmF1bHRMZXZlbDtcclxuICAgICAgfVxyXG4gICAgICBzZWxmLnNldExldmVsKGluaXRpYWxMZXZlbCwgZmFsc2UpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qXHJcbiAgICAgKlxyXG4gICAgICogVG9wLWxldmVsIEFQSVxyXG4gICAgICpcclxuICAgICAqL1xyXG5cclxuICAgIHZhciBkZWZhdWx0TG9nZ2VyID0gbmV3IExvZ2dlcigpO1xyXG5cclxuICAgIHZhciBfbG9nZ2Vyc0J5TmFtZSA9IHt9O1xyXG4gICAgZGVmYXVsdExvZ2dlci5nZXRMb2dnZXIgPSBmdW5jdGlvbiBnZXRMb2dnZXIobmFtZSkge1xyXG4gICAgICAgIGlmICgodHlwZW9mIG5hbWUgIT09IFwic3ltYm9sXCIgJiYgdHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIpIHx8IG5hbWUgPT09IFwiXCIpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJZb3UgbXVzdCBzdXBwbHkgYSBuYW1lIHdoZW4gY3JlYXRpbmcgYSBsb2dnZXIuXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGxvZ2dlciA9IF9sb2dnZXJzQnlOYW1lW25hbWVdO1xyXG4gICAgICAgIGlmICghbG9nZ2VyKSB7XHJcbiAgICAgICAgICBsb2dnZXIgPSBfbG9nZ2Vyc0J5TmFtZVtuYW1lXSA9IG5ldyBMb2dnZXIoXHJcbiAgICAgICAgICAgIG5hbWUsIGRlZmF1bHRMb2dnZXIuZ2V0TGV2ZWwoKSwgZGVmYXVsdExvZ2dlci5tZXRob2RGYWN0b3J5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGxvZ2dlcjtcclxuICAgIH07XHJcblxyXG4gICAgLy8gR3JhYiB0aGUgY3VycmVudCBnbG9iYWwgbG9nIHZhcmlhYmxlIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXHJcbiAgICB2YXIgX2xvZyA9ICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlKSA/IHdpbmRvdy5sb2cgOiB1bmRlZmluZWQ7XHJcbiAgICBkZWZhdWx0TG9nZ2VyLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSAmJlxyXG4gICAgICAgICAgICAgICB3aW5kb3cubG9nID09PSBkZWZhdWx0TG9nZ2VyKSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5sb2cgPSBfbG9nO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRMb2dnZXI7XHJcbiAgICB9O1xyXG5cclxuICAgIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VycyA9IGZ1bmN0aW9uIGdldExvZ2dlcnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9sb2dnZXJzQnlOYW1lO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBFUzYgZGVmYXVsdCBleHBvcnQsIGZvciBjb21wYXRpYmlsaXR5XHJcbiAgICBkZWZhdWx0TG9nZ2VyWydkZWZhdWx0J10gPSBkZWZhdWx0TG9nZ2VyO1xyXG5cclxuICAgIHJldHVybiBkZWZhdWx0TG9nZ2VyO1xyXG59KSk7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/loglevel/lib/loglevel.js\n");

/***/ }),

/***/ "./node_modules/md5.js/index.js":
/*!**************************************!*\
  !*** ./node_modules/md5.js/index.js ***!
  \**************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\r\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\r\nvar HashBase = __webpack_require__(/*! hash-base */ \"./node_modules/hash-base/index.js\")\r\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer)\r\n\r\nvar ARRAY16 = new Array(16)\r\n\r\nfunction MD5 () {\r\n  HashBase.call(this, 64)\r\n\r\n  // state\r\n  this._a = 0x67452301\r\n  this._b = 0xefcdab89\r\n  this._c = 0x98badcfe\r\n  this._d = 0x10325476\r\n}\r\n\r\ninherits(MD5, HashBase)\r\n\r\nMD5.prototype._update = function () {\r\n  var M = ARRAY16\r\n  for (var i = 0; i < 16; ++i) M[i] = this._block.readInt32LE(i * 4)\r\n\r\n  var a = this._a\r\n  var b = this._b\r\n  var c = this._c\r\n  var d = this._d\r\n\r\n  a = fnF(a, b, c, d, M[0], 0xd76aa478, 7)\r\n  d = fnF(d, a, b, c, M[1], 0xe8c7b756, 12)\r\n  c = fnF(c, d, a, b, M[2], 0x242070db, 17)\r\n  b = fnF(b, c, d, a, M[3], 0xc1bdceee, 22)\r\n  a = fnF(a, b, c, d, M[4], 0xf57c0faf, 7)\r\n  d = fnF(d, a, b, c, M[5], 0x4787c62a, 12)\r\n  c = fnF(c, d, a, b, M[6], 0xa8304613, 17)\r\n  b = fnF(b, c, d, a, M[7], 0xfd469501, 22)\r\n  a = fnF(a, b, c, d, M[8], 0x698098d8, 7)\r\n  d = fnF(d, a, b, c, M[9], 0x8b44f7af, 12)\r\n  c = fnF(c, d, a, b, M[10], 0xffff5bb1, 17)\r\n  b = fnF(b, c, d, a, M[11], 0x895cd7be, 22)\r\n  a = fnF(a, b, c, d, M[12], 0x6b901122, 7)\r\n  d = fnF(d, a, b, c, M[13], 0xfd987193, 12)\r\n  c = fnF(c, d, a, b, M[14], 0xa679438e, 17)\r\n  b = fnF(b, c, d, a, M[15], 0x49b40821, 22)\r\n\r\n  a = fnG(a, b, c, d, M[1], 0xf61e2562, 5)\r\n  d = fnG(d, a, b, c, M[6], 0xc040b340, 9)\r\n  c = fnG(c, d, a, b, M[11], 0x265e5a51, 14)\r\n  b = fnG(b, c, d, a, M[0], 0xe9b6c7aa, 20)\r\n  a = fnG(a, b, c, d, M[5], 0xd62f105d, 5)\r\n  d = fnG(d, a, b, c, M[10], 0x02441453, 9)\r\n  c = fnG(c, d, a, b, M[15], 0xd8a1e681, 14)\r\n  b = fnG(b, c, d, a, M[4], 0xe7d3fbc8, 20)\r\n  a = fnG(a, b, c, d, M[9], 0x21e1cde6, 5)\r\n  d = fnG(d, a, b, c, M[14], 0xc33707d6, 9)\r\n  c = fnG(c, d, a, b, M[3], 0xf4d50d87, 14)\r\n  b = fnG(b, c, d, a, M[8], 0x455a14ed, 20)\r\n  a = fnG(a, b, c, d, M[13], 0xa9e3e905, 5)\r\n  d = fnG(d, a, b, c, M[2], 0xfcefa3f8, 9)\r\n  c = fnG(c, d, a, b, M[7], 0x676f02d9, 14)\r\n  b = fnG(b, c, d, a, M[12], 0x8d2a4c8a, 20)\r\n\r\n  a = fnH(a, b, c, d, M[5], 0xfffa3942, 4)\r\n  d = fnH(d, a, b, c, M[8], 0x8771f681, 11)\r\n  c = fnH(c, d, a, b, M[11], 0x6d9d6122, 16)\r\n  b = fnH(b, c, d, a, M[14], 0xfde5380c, 23)\r\n  a = fnH(a, b, c, d, M[1], 0xa4beea44, 4)\r\n  d = fnH(d, a, b, c, M[4], 0x4bdecfa9, 11)\r\n  c = fnH(c, d, a, b, M[7], 0xf6bb4b60, 16)\r\n  b = fnH(b, c, d, a, M[10], 0xbebfbc70, 23)\r\n  a = fnH(a, b, c, d, M[13], 0x289b7ec6, 4)\r\n  d = fnH(d, a, b, c, M[0], 0xeaa127fa, 11)\r\n  c = fnH(c, d, a, b, M[3], 0xd4ef3085, 16)\r\n  b = fnH(b, c, d, a, M[6], 0x04881d05, 23)\r\n  a = fnH(a, b, c, d, M[9], 0xd9d4d039, 4)\r\n  d = fnH(d, a, b, c, M[12], 0xe6db99e5, 11)\r\n  c = fnH(c, d, a, b, M[15], 0x1fa27cf8, 16)\r\n  b = fnH(b, c, d, a, M[2], 0xc4ac5665, 23)\r\n\r\n  a = fnI(a, b, c, d, M[0], 0xf4292244, 6)\r\n  d = fnI(d, a, b, c, M[7], 0x432aff97, 10)\r\n  c = fnI(c, d, a, b, M[14], 0xab9423a7, 15)\r\n  b = fnI(b, c, d, a, M[5], 0xfc93a039, 21)\r\n  a = fnI(a, b, c, d, M[12], 0x655b59c3, 6)\r\n  d = fnI(d, a, b, c, M[3], 0x8f0ccc92, 10)\r\n  c = fnI(c, d, a, b, M[10], 0xffeff47d, 15)\r\n  b = fnI(b, c, d, a, M[1], 0x85845dd1, 21)\r\n  a = fnI(a, b, c, d, M[8], 0x6fa87e4f, 6)\r\n  d = fnI(d, a, b, c, M[15], 0xfe2ce6e0, 10)\r\n  c = fnI(c, d, a, b, M[6], 0xa3014314, 15)\r\n  b = fnI(b, c, d, a, M[13], 0x4e0811a1, 21)\r\n  a = fnI(a, b, c, d, M[4], 0xf7537e82, 6)\r\n  d = fnI(d, a, b, c, M[11], 0xbd3af235, 10)\r\n  c = fnI(c, d, a, b, M[2], 0x2ad7d2bb, 15)\r\n  b = fnI(b, c, d, a, M[9], 0xeb86d391, 21)\r\n\r\n  this._a = (this._a + a) | 0\r\n  this._b = (this._b + b) | 0\r\n  this._c = (this._c + c) | 0\r\n  this._d = (this._d + d) | 0\r\n}\r\n\r\nMD5.prototype._digest = function () {\r\n  // create padding and handle blocks\r\n  this._block[this._blockOffset++] = 0x80\r\n  if (this._blockOffset > 56) {\r\n    this._block.fill(0, this._blockOffset, 64)\r\n    this._update()\r\n    this._blockOffset = 0\r\n  }\r\n\r\n  this._block.fill(0, this._blockOffset, 56)\r\n  this._block.writeUInt32LE(this._length[0], 56)\r\n  this._block.writeUInt32LE(this._length[1], 60)\r\n  this._update()\r\n\r\n  // produce result\r\n  var buffer = Buffer.allocUnsafe(16)\r\n  buffer.writeInt32LE(this._a, 0)\r\n  buffer.writeInt32LE(this._b, 4)\r\n  buffer.writeInt32LE(this._c, 8)\r\n  buffer.writeInt32LE(this._d, 12)\r\n  return buffer\r\n}\r\n\r\nfunction rotl (x, n) {\r\n  return (x << n) | (x >>> (32 - n))\r\n}\r\n\r\nfunction fnF (a, b, c, d, m, k, s) {\r\n  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + b) | 0\r\n}\r\n\r\nfunction fnG (a, b, c, d, m, k, s) {\r\n  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + b) | 0\r\n}\r\n\r\nfunction fnH (a, b, c, d, m, k, s) {\r\n  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + b) | 0\r\n}\r\n\r\nfunction fnI (a, b, c, d, m, k, s) {\r\n  return (rotl((a + ((c ^ (b | (~d)))) + m + k) | 0, s) + b) | 0\r\n}\r\n\r\nmodule.exports = MD5\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWQ1LmpzL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1osZUFBZSxtQkFBTyxDQUFDLDZEQUFVO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyxvREFBVztBQUNsQyxhQUFhLHNGQUE2QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21kNS5qcy9pbmRleC5qcz82NzNjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xyXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXHJcbnZhciBIYXNoQmFzZSA9IHJlcXVpcmUoJ2hhc2gtYmFzZScpXHJcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxyXG5cclxudmFyIEFSUkFZMTYgPSBuZXcgQXJyYXkoMTYpXHJcblxyXG5mdW5jdGlvbiBNRDUgKCkge1xyXG4gIEhhc2hCYXNlLmNhbGwodGhpcywgNjQpXHJcblxyXG4gIC8vIHN0YXRlXHJcbiAgdGhpcy5fYSA9IDB4Njc0NTIzMDFcclxuICB0aGlzLl9iID0gMHhlZmNkYWI4OVxyXG4gIHRoaXMuX2MgPSAweDk4YmFkY2ZlXHJcbiAgdGhpcy5fZCA9IDB4MTAzMjU0NzZcclxufVxyXG5cclxuaW5oZXJpdHMoTUQ1LCBIYXNoQmFzZSlcclxuXHJcbk1ENS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgTSA9IEFSUkFZMTZcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIE1baV0gPSB0aGlzLl9ibG9jay5yZWFkSW50MzJMRShpICogNClcclxuXHJcbiAgdmFyIGEgPSB0aGlzLl9hXHJcbiAgdmFyIGIgPSB0aGlzLl9iXHJcbiAgdmFyIGMgPSB0aGlzLl9jXHJcbiAgdmFyIGQgPSB0aGlzLl9kXHJcblxyXG4gIGEgPSBmbkYoYSwgYiwgYywgZCwgTVswXSwgMHhkNzZhYTQ3OCwgNylcclxuICBkID0gZm5GKGQsIGEsIGIsIGMsIE1bMV0sIDB4ZThjN2I3NTYsIDEyKVxyXG4gIGMgPSBmbkYoYywgZCwgYSwgYiwgTVsyXSwgMHgyNDIwNzBkYiwgMTcpXHJcbiAgYiA9IGZuRihiLCBjLCBkLCBhLCBNWzNdLCAweGMxYmRjZWVlLCAyMilcclxuICBhID0gZm5GKGEsIGIsIGMsIGQsIE1bNF0sIDB4ZjU3YzBmYWYsIDcpXHJcbiAgZCA9IGZuRihkLCBhLCBiLCBjLCBNWzVdLCAweDQ3ODdjNjJhLCAxMilcclxuICBjID0gZm5GKGMsIGQsIGEsIGIsIE1bNl0sIDB4YTgzMDQ2MTMsIDE3KVxyXG4gIGIgPSBmbkYoYiwgYywgZCwgYSwgTVs3XSwgMHhmZDQ2OTUwMSwgMjIpXHJcbiAgYSA9IGZuRihhLCBiLCBjLCBkLCBNWzhdLCAweDY5ODA5OGQ4LCA3KVxyXG4gIGQgPSBmbkYoZCwgYSwgYiwgYywgTVs5XSwgMHg4YjQ0ZjdhZiwgMTIpXHJcbiAgYyA9IGZuRihjLCBkLCBhLCBiLCBNWzEwXSwgMHhmZmZmNWJiMSwgMTcpXHJcbiAgYiA9IGZuRihiLCBjLCBkLCBhLCBNWzExXSwgMHg4OTVjZDdiZSwgMjIpXHJcbiAgYSA9IGZuRihhLCBiLCBjLCBkLCBNWzEyXSwgMHg2YjkwMTEyMiwgNylcclxuICBkID0gZm5GKGQsIGEsIGIsIGMsIE1bMTNdLCAweGZkOTg3MTkzLCAxMilcclxuICBjID0gZm5GKGMsIGQsIGEsIGIsIE1bMTRdLCAweGE2Nzk0MzhlLCAxNylcclxuICBiID0gZm5GKGIsIGMsIGQsIGEsIE1bMTVdLCAweDQ5YjQwODIxLCAyMilcclxuXHJcbiAgYSA9IGZuRyhhLCBiLCBjLCBkLCBNWzFdLCAweGY2MWUyNTYyLCA1KVxyXG4gIGQgPSBmbkcoZCwgYSwgYiwgYywgTVs2XSwgMHhjMDQwYjM0MCwgOSlcclxuICBjID0gZm5HKGMsIGQsIGEsIGIsIE1bMTFdLCAweDI2NWU1YTUxLCAxNClcclxuICBiID0gZm5HKGIsIGMsIGQsIGEsIE1bMF0sIDB4ZTliNmM3YWEsIDIwKVxyXG4gIGEgPSBmbkcoYSwgYiwgYywgZCwgTVs1XSwgMHhkNjJmMTA1ZCwgNSlcclxuICBkID0gZm5HKGQsIGEsIGIsIGMsIE1bMTBdLCAweDAyNDQxNDUzLCA5KVxyXG4gIGMgPSBmbkcoYywgZCwgYSwgYiwgTVsxNV0sIDB4ZDhhMWU2ODEsIDE0KVxyXG4gIGIgPSBmbkcoYiwgYywgZCwgYSwgTVs0XSwgMHhlN2QzZmJjOCwgMjApXHJcbiAgYSA9IGZuRyhhLCBiLCBjLCBkLCBNWzldLCAweDIxZTFjZGU2LCA1KVxyXG4gIGQgPSBmbkcoZCwgYSwgYiwgYywgTVsxNF0sIDB4YzMzNzA3ZDYsIDkpXHJcbiAgYyA9IGZuRyhjLCBkLCBhLCBiLCBNWzNdLCAweGY0ZDUwZDg3LCAxNClcclxuICBiID0gZm5HKGIsIGMsIGQsIGEsIE1bOF0sIDB4NDU1YTE0ZWQsIDIwKVxyXG4gIGEgPSBmbkcoYSwgYiwgYywgZCwgTVsxM10sIDB4YTllM2U5MDUsIDUpXHJcbiAgZCA9IGZuRyhkLCBhLCBiLCBjLCBNWzJdLCAweGZjZWZhM2Y4LCA5KVxyXG4gIGMgPSBmbkcoYywgZCwgYSwgYiwgTVs3XSwgMHg2NzZmMDJkOSwgMTQpXHJcbiAgYiA9IGZuRyhiLCBjLCBkLCBhLCBNWzEyXSwgMHg4ZDJhNGM4YSwgMjApXHJcblxyXG4gIGEgPSBmbkgoYSwgYiwgYywgZCwgTVs1XSwgMHhmZmZhMzk0MiwgNClcclxuICBkID0gZm5IKGQsIGEsIGIsIGMsIE1bOF0sIDB4ODc3MWY2ODEsIDExKVxyXG4gIGMgPSBmbkgoYywgZCwgYSwgYiwgTVsxMV0sIDB4NmQ5ZDYxMjIsIDE2KVxyXG4gIGIgPSBmbkgoYiwgYywgZCwgYSwgTVsxNF0sIDB4ZmRlNTM4MGMsIDIzKVxyXG4gIGEgPSBmbkgoYSwgYiwgYywgZCwgTVsxXSwgMHhhNGJlZWE0NCwgNClcclxuICBkID0gZm5IKGQsIGEsIGIsIGMsIE1bNF0sIDB4NGJkZWNmYTksIDExKVxyXG4gIGMgPSBmbkgoYywgZCwgYSwgYiwgTVs3XSwgMHhmNmJiNGI2MCwgMTYpXHJcbiAgYiA9IGZuSChiLCBjLCBkLCBhLCBNWzEwXSwgMHhiZWJmYmM3MCwgMjMpXHJcbiAgYSA9IGZuSChhLCBiLCBjLCBkLCBNWzEzXSwgMHgyODliN2VjNiwgNClcclxuICBkID0gZm5IKGQsIGEsIGIsIGMsIE1bMF0sIDB4ZWFhMTI3ZmEsIDExKVxyXG4gIGMgPSBmbkgoYywgZCwgYSwgYiwgTVszXSwgMHhkNGVmMzA4NSwgMTYpXHJcbiAgYiA9IGZuSChiLCBjLCBkLCBhLCBNWzZdLCAweDA0ODgxZDA1LCAyMylcclxuICBhID0gZm5IKGEsIGIsIGMsIGQsIE1bOV0sIDB4ZDlkNGQwMzksIDQpXHJcbiAgZCA9IGZuSChkLCBhLCBiLCBjLCBNWzEyXSwgMHhlNmRiOTllNSwgMTEpXHJcbiAgYyA9IGZuSChjLCBkLCBhLCBiLCBNWzE1XSwgMHgxZmEyN2NmOCwgMTYpXHJcbiAgYiA9IGZuSChiLCBjLCBkLCBhLCBNWzJdLCAweGM0YWM1NjY1LCAyMylcclxuXHJcbiAgYSA9IGZuSShhLCBiLCBjLCBkLCBNWzBdLCAweGY0MjkyMjQ0LCA2KVxyXG4gIGQgPSBmbkkoZCwgYSwgYiwgYywgTVs3XSwgMHg0MzJhZmY5NywgMTApXHJcbiAgYyA9IGZuSShjLCBkLCBhLCBiLCBNWzE0XSwgMHhhYjk0MjNhNywgMTUpXHJcbiAgYiA9IGZuSShiLCBjLCBkLCBhLCBNWzVdLCAweGZjOTNhMDM5LCAyMSlcclxuICBhID0gZm5JKGEsIGIsIGMsIGQsIE1bMTJdLCAweDY1NWI1OWMzLCA2KVxyXG4gIGQgPSBmbkkoZCwgYSwgYiwgYywgTVszXSwgMHg4ZjBjY2M5MiwgMTApXHJcbiAgYyA9IGZuSShjLCBkLCBhLCBiLCBNWzEwXSwgMHhmZmVmZjQ3ZCwgMTUpXHJcbiAgYiA9IGZuSShiLCBjLCBkLCBhLCBNWzFdLCAweDg1ODQ1ZGQxLCAyMSlcclxuICBhID0gZm5JKGEsIGIsIGMsIGQsIE1bOF0sIDB4NmZhODdlNGYsIDYpXHJcbiAgZCA9IGZuSShkLCBhLCBiLCBjLCBNWzE1XSwgMHhmZTJjZTZlMCwgMTApXHJcbiAgYyA9IGZuSShjLCBkLCBhLCBiLCBNWzZdLCAweGEzMDE0MzE0LCAxNSlcclxuICBiID0gZm5JKGIsIGMsIGQsIGEsIE1bMTNdLCAweDRlMDgxMWExLCAyMSlcclxuICBhID0gZm5JKGEsIGIsIGMsIGQsIE1bNF0sIDB4Zjc1MzdlODIsIDYpXHJcbiAgZCA9IGZuSShkLCBhLCBiLCBjLCBNWzExXSwgMHhiZDNhZjIzNSwgMTApXHJcbiAgYyA9IGZuSShjLCBkLCBhLCBiLCBNWzJdLCAweDJhZDdkMmJiLCAxNSlcclxuICBiID0gZm5JKGIsIGMsIGQsIGEsIE1bOV0sIDB4ZWI4NmQzOTEsIDIxKVxyXG5cclxuICB0aGlzLl9hID0gKHRoaXMuX2EgKyBhKSB8IDBcclxuICB0aGlzLl9iID0gKHRoaXMuX2IgKyBiKSB8IDBcclxuICB0aGlzLl9jID0gKHRoaXMuX2MgKyBjKSB8IDBcclxuICB0aGlzLl9kID0gKHRoaXMuX2QgKyBkKSB8IDBcclxufVxyXG5cclxuTUQ1LnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gKCkge1xyXG4gIC8vIGNyZWF0ZSBwYWRkaW5nIGFuZCBoYW5kbGUgYmxvY2tzXHJcbiAgdGhpcy5fYmxvY2tbdGhpcy5fYmxvY2tPZmZzZXQrK10gPSAweDgwXHJcbiAgaWYgKHRoaXMuX2Jsb2NrT2Zmc2V0ID4gNTYpIHtcclxuICAgIHRoaXMuX2Jsb2NrLmZpbGwoMCwgdGhpcy5fYmxvY2tPZmZzZXQsIDY0KVxyXG4gICAgdGhpcy5fdXBkYXRlKClcclxuICAgIHRoaXMuX2Jsb2NrT2Zmc2V0ID0gMFxyXG4gIH1cclxuXHJcbiAgdGhpcy5fYmxvY2suZmlsbCgwLCB0aGlzLl9ibG9ja09mZnNldCwgNTYpXHJcbiAgdGhpcy5fYmxvY2sud3JpdGVVSW50MzJMRSh0aGlzLl9sZW5ndGhbMF0sIDU2KVxyXG4gIHRoaXMuX2Jsb2NrLndyaXRlVUludDMyTEUodGhpcy5fbGVuZ3RoWzFdLCA2MClcclxuICB0aGlzLl91cGRhdGUoKVxyXG5cclxuICAvLyBwcm9kdWNlIHJlc3VsdFxyXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMTYpXHJcbiAgYnVmZmVyLndyaXRlSW50MzJMRSh0aGlzLl9hLCAwKVxyXG4gIGJ1ZmZlci53cml0ZUludDMyTEUodGhpcy5fYiwgNClcclxuICBidWZmZXIud3JpdGVJbnQzMkxFKHRoaXMuX2MsIDgpXHJcbiAgYnVmZmVyLndyaXRlSW50MzJMRSh0aGlzLl9kLCAxMilcclxuICByZXR1cm4gYnVmZmVyXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJvdGwgKHgsIG4pIHtcclxuICByZXR1cm4gKHggPDwgbikgfCAoeCA+Pj4gKDMyIC0gbikpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZuRiAoYSwgYiwgYywgZCwgbSwgaywgcykge1xyXG4gIHJldHVybiAocm90bCgoYSArICgoYiAmIGMpIHwgKCh+YikgJiBkKSkgKyBtICsgaykgfCAwLCBzKSArIGIpIHwgMFxyXG59XHJcblxyXG5mdW5jdGlvbiBmbkcgKGEsIGIsIGMsIGQsIG0sIGssIHMpIHtcclxuICByZXR1cm4gKHJvdGwoKGEgKyAoKGIgJiBkKSB8IChjICYgKH5kKSkpICsgbSArIGspIHwgMCwgcykgKyBiKSB8IDBcclxufVxyXG5cclxuZnVuY3Rpb24gZm5IIChhLCBiLCBjLCBkLCBtLCBrLCBzKSB7XHJcbiAgcmV0dXJuIChyb3RsKChhICsgKGIgXiBjIF4gZCkgKyBtICsgaykgfCAwLCBzKSArIGIpIHwgMFxyXG59XHJcblxyXG5mdW5jdGlvbiBmbkkgKGEsIGIsIGMsIGQsIG0sIGssIHMpIHtcclxuICByZXR1cm4gKHJvdGwoKGEgKyAoKGMgXiAoYiB8ICh+ZCkpKSkgKyBtICsgaykgfCAwLCBzKSArIGIpIHwgMFxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1ENVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/md5.js/index.js\n");

/***/ }),

/***/ "./node_modules/next/dist/compiled/stream-browserify/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/next/dist/compiled/stream-browserify/index.js ***!
  \********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var __dirname = \"/\";\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/process/browser.js\");\n(function(){var e={526:function(e){if(typeof Object.create===\"function\"){e.exports=function inherits(e,t){if(t){e.super_=t;e.prototype=Object.create(t.prototype,{constructor:{value:e,enumerable:false,writable:true,configurable:true}})}}}else{e.exports=function inherits(e,t){if(t){e.super_=t;var TempCtor=function(){};TempCtor.prototype=t.prototype;e.prototype=new TempCtor;e.prototype.constructor=e}}}},118:function(e,t,r){var n=r(300);var i=n.Buffer;function copyProps(e,t){for(var r in e){t[r]=e[r]}}if(i.from&&i.alloc&&i.allocUnsafe&&i.allocUnsafeSlow){e.exports=n}else{copyProps(n,t);t.Buffer=SafeBuffer}function SafeBuffer(e,t,r){return i(e,t,r)}SafeBuffer.prototype=Object.create(i.prototype);copyProps(i,SafeBuffer);SafeBuffer.from=function(e,t,r){if(typeof e===\"number\"){throw new TypeError(\"Argument must not be a number\")}return i(e,t,r)};SafeBuffer.alloc=function(e,t,r){if(typeof e!==\"number\"){throw new TypeError(\"Argument must be a number\")}var n=i(e);if(t!==undefined){if(typeof r===\"string\"){n.fill(t,r)}else{n.fill(t)}}else{n.fill(0)}return n};SafeBuffer.allocUnsafe=function(e){if(typeof e!==\"number\"){throw new TypeError(\"Argument must be a number\")}return i(e)};SafeBuffer.allocUnsafeSlow=function(e){if(typeof e!==\"number\"){throw new TypeError(\"Argument must be a number\")}return n.SlowBuffer(e)}},562:function(e,t,r){e.exports=Stream;var n=r(361).EventEmitter;var i=r(526);i(Stream,n);Stream.Readable=r(375);Stream.Writable=r(886);Stream.Duplex=r(239);Stream.Transform=r(786);Stream.PassThrough=r(663);Stream.finished=r(494);Stream.pipeline=r(229);Stream.Stream=Stream;function Stream(){n.call(this)}Stream.prototype.pipe=function(e,t){var r=this;function ondata(t){if(e.writable){if(false===e.write(t)&&r.pause){r.pause()}}}r.on(\"data\",ondata);function ondrain(){if(r.readable&&r.resume){r.resume()}}e.on(\"drain\",ondrain);if(!e._isStdio&&(!t||t.end!==false)){r.on(\"end\",onend);r.on(\"close\",onclose)}var i=false;function onend(){if(i)return;i=true;e.end()}function onclose(){if(i)return;i=true;if(typeof e.destroy===\"function\")e.destroy()}function onerror(e){cleanup();if(n.listenerCount(this,\"error\")===0){throw e}}r.on(\"error\",onerror);e.on(\"error\",onerror);function cleanup(){r.removeListener(\"data\",ondata);e.removeListener(\"drain\",ondrain);r.removeListener(\"end\",onend);r.removeListener(\"close\",onclose);r.removeListener(\"error\",onerror);e.removeListener(\"error\",onerror);r.removeListener(\"end\",cleanup);r.removeListener(\"close\",cleanup);e.removeListener(\"close\",cleanup)}r.on(\"end\",cleanup);r.on(\"close\",cleanup);e.on(\"close\",cleanup);e.emit(\"pipe\",r);return e}},833:function(e){\"use strict\";const t={};function createErrorType(e,r,n){if(!n){n=Error}function getMessage(e,t,n){if(typeof r===\"string\"){return r}else{return r(e,t,n)}}class NodeError extends n{constructor(e,t,r){super(getMessage(e,t,r))}}NodeError.prototype.name=n.name;NodeError.prototype.code=e;t[e]=NodeError}function oneOf(e,t){if(Array.isArray(e)){const r=e.length;e=e.map((e=>String(e)));if(r>2){return`one of ${t} ${e.slice(0,r-1).join(\", \")}, or `+e[r-1]}else if(r===2){return`one of ${t} ${e[0]} or ${e[1]}`}else{return`of ${t} ${e[0]}`}}else{return`of ${t} ${String(e)}`}}function startsWith(e,t,r){return e.substr(!r||r<0?0:+r,t.length)===t}function endsWith(e,t,r){if(r===undefined||r>e.length){r=e.length}return e.substring(r-t.length,r)===t}function includes(e,t,r){if(typeof r!==\"number\"){r=0}if(r+t.length>e.length){return false}else{return e.indexOf(t,r)!==-1}}createErrorType(\"ERR_INVALID_OPT_VALUE\",(function(e,t){return'The value \"'+t+'\" is invalid for option \"'+e+'\"'}),TypeError);createErrorType(\"ERR_INVALID_ARG_TYPE\",(function(e,t,r){let n;if(typeof t===\"string\"&&startsWith(t,\"not \")){n=\"must not be\";t=t.replace(/^not /,\"\")}else{n=\"must be\"}let i;if(endsWith(e,\" argument\")){i=`The ${e} ${n} ${oneOf(t,\"type\")}`}else{const r=includes(e,\".\")?\"property\":\"argument\";i=`The \"${e}\" ${r} ${n} ${oneOf(t,\"type\")}`}i+=`. Received type ${typeof r}`;return i}),TypeError);createErrorType(\"ERR_STREAM_PUSH_AFTER_EOF\",\"stream.push() after EOF\");createErrorType(\"ERR_METHOD_NOT_IMPLEMENTED\",(function(e){return\"The \"+e+\" method is not implemented\"}));createErrorType(\"ERR_STREAM_PREMATURE_CLOSE\",\"Premature close\");createErrorType(\"ERR_STREAM_DESTROYED\",(function(e){return\"Cannot call \"+e+\" after a stream was destroyed\"}));createErrorType(\"ERR_MULTIPLE_CALLBACK\",\"Callback called multiple times\");createErrorType(\"ERR_STREAM_CANNOT_PIPE\",\"Cannot pipe, not readable\");createErrorType(\"ERR_STREAM_WRITE_AFTER_END\",\"write after end\");createErrorType(\"ERR_STREAM_NULL_VALUES\",\"May not write null values to stream\",TypeError);createErrorType(\"ERR_UNKNOWN_ENCODING\",(function(e){return\"Unknown encoding: \"+e}),TypeError);createErrorType(\"ERR_STREAM_UNSHIFT_AFTER_END_EVENT\",\"stream.unshift() after end event\");e.exports.q=t},239:function(e,t,r){\"use strict\";var n=Object.keys||function(e){var t=[];for(var r in e){t.push(r)}return t};e.exports=Duplex;var i=r(375);var a=r(886);r(526)(Duplex,i);{var o=n(a.prototype);for(var s=0;s<o.length;s++){var f=o[s];if(!Duplex.prototype[f])Duplex.prototype[f]=a.prototype[f]}}function Duplex(e){if(!(this instanceof Duplex))return new Duplex(e);i.call(this,e);a.call(this,e);this.allowHalfOpen=true;if(e){if(e.readable===false)this.readable=false;if(e.writable===false)this.writable=false;if(e.allowHalfOpen===false){this.allowHalfOpen=false;this.once(\"end\",onend)}}}Object.defineProperty(Duplex.prototype,\"writableHighWaterMark\",{enumerable:false,get:function get(){return this._writableState.highWaterMark}});Object.defineProperty(Duplex.prototype,\"writableBuffer\",{enumerable:false,get:function get(){return this._writableState&&this._writableState.getBuffer()}});Object.defineProperty(Duplex.prototype,\"writableLength\",{enumerable:false,get:function get(){return this._writableState.length}});function onend(){if(this._writableState.ended)return;process.nextTick(onEndNT,this)}function onEndNT(e){e.end()}Object.defineProperty(Duplex.prototype,\"destroyed\",{enumerable:false,get:function get(){if(this._readableState===undefined||this._writableState===undefined){return false}return this._readableState.destroyed&&this._writableState.destroyed},set:function set(e){if(this._readableState===undefined||this._writableState===undefined){return}this._readableState.destroyed=e;this._writableState.destroyed=e}})},663:function(e,t,r){\"use strict\";e.exports=PassThrough;var n=r(786);r(526)(PassThrough,n);function PassThrough(e){if(!(this instanceof PassThrough))return new PassThrough(e);n.call(this,e)}PassThrough.prototype._transform=function(e,t,r){r(null,e)}},375:function(e,t,r){\"use strict\";e.exports=Readable;var n;Readable.ReadableState=ReadableState;var i=r(361).EventEmitter;var a=function EElistenerCount(e,t){return e.listeners(t).length};var o=r(919);var s=r(300).Buffer;var f=__webpack_require__.g.Uint8Array||function(){};function _uint8ArrayToBuffer(e){return s.from(e)}function _isUint8Array(e){return s.isBuffer(e)||e instanceof f}var l=r(837);var u;if(l&&l.debuglog){u=l.debuglog(\"stream\")}else{u=function debug(){}}var d=r(914);var c=r(364);var h=r(322),p=h.getHighWaterMark;var b=r(833).q,g=b.ERR_INVALID_ARG_TYPE,y=b.ERR_STREAM_PUSH_AFTER_EOF,_=b.ERR_METHOD_NOT_IMPLEMENTED,v=b.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;var w;var m;var S;r(526)(Readable,o);var R=c.errorOrDestroy;var E=[\"error\",\"close\",\"destroy\",\"pause\",\"resume\"];function prependListener(e,t,r){if(typeof e.prependListener===\"function\")return e.prependListener(t,r);if(!e._events||!e._events[t])e.on(t,r);else if(Array.isArray(e._events[t]))e._events[t].unshift(r);else e._events[t]=[r,e._events[t]]}function ReadableState(e,t,i){n=n||r(239);e=e||{};if(typeof i!==\"boolean\")i=t instanceof n;this.objectMode=!!e.objectMode;if(i)this.objectMode=this.objectMode||!!e.readableObjectMode;this.highWaterMark=p(this,e,\"readableHighWaterMark\",i);this.buffer=new d;this.length=0;this.pipes=null;this.pipesCount=0;this.flowing=null;this.ended=false;this.endEmitted=false;this.reading=false;this.sync=true;this.needReadable=false;this.emittedReadable=false;this.readableListening=false;this.resumeScheduled=false;this.paused=true;this.emitClose=e.emitClose!==false;this.autoDestroy=!!e.autoDestroy;this.destroyed=false;this.defaultEncoding=e.defaultEncoding||\"utf8\";this.awaitDrain=0;this.readingMore=false;this.decoder=null;this.encoding=null;if(e.encoding){if(!w)w=r(642).s;this.decoder=new w(e.encoding);this.encoding=e.encoding}}function Readable(e){n=n||r(239);if(!(this instanceof Readable))return new Readable(e);var t=this instanceof n;this._readableState=new ReadableState(e,this,t);this.readable=true;if(e){if(typeof e.read===\"function\")this._read=e.read;if(typeof e.destroy===\"function\")this._destroy=e.destroy}o.call(this)}Object.defineProperty(Readable.prototype,\"destroyed\",{enumerable:false,get:function get(){if(this._readableState===undefined){return false}return this._readableState.destroyed},set:function set(e){if(!this._readableState){return}this._readableState.destroyed=e}});Readable.prototype.destroy=c.destroy;Readable.prototype._undestroy=c.undestroy;Readable.prototype._destroy=function(e,t){t(e)};Readable.prototype.push=function(e,t){var r=this._readableState;var n;if(!r.objectMode){if(typeof e===\"string\"){t=t||r.defaultEncoding;if(t!==r.encoding){e=s.from(e,t);t=\"\"}n=true}}else{n=true}return readableAddChunk(this,e,t,false,n)};Readable.prototype.unshift=function(e){return readableAddChunk(this,e,null,true,false)};function readableAddChunk(e,t,r,n,i){u(\"readableAddChunk\",t);var a=e._readableState;if(t===null){a.reading=false;onEofChunk(e,a)}else{var o;if(!i)o=chunkInvalid(a,t);if(o){R(e,o)}else if(a.objectMode||t&&t.length>0){if(typeof t!==\"string\"&&!a.objectMode&&Object.getPrototypeOf(t)!==s.prototype){t=_uint8ArrayToBuffer(t)}if(n){if(a.endEmitted)R(e,new v);else addChunk(e,a,t,true)}else if(a.ended){R(e,new y)}else if(a.destroyed){return false}else{a.reading=false;if(a.decoder&&!r){t=a.decoder.write(t);if(a.objectMode||t.length!==0)addChunk(e,a,t,false);else maybeReadMore(e,a)}else{addChunk(e,a,t,false)}}}else if(!n){a.reading=false;maybeReadMore(e,a)}}return!a.ended&&(a.length<a.highWaterMark||a.length===0)}function addChunk(e,t,r,n){if(t.flowing&&t.length===0&&!t.sync){t.awaitDrain=0;e.emit(\"data\",r)}else{t.length+=t.objectMode?1:r.length;if(n)t.buffer.unshift(r);else t.buffer.push(r);if(t.needReadable)emitReadable(e)}maybeReadMore(e,t)}function chunkInvalid(e,t){var r;if(!_isUint8Array(t)&&typeof t!==\"string\"&&t!==undefined&&!e.objectMode){r=new g(\"chunk\",[\"string\",\"Buffer\",\"Uint8Array\"],t)}return r}Readable.prototype.isPaused=function(){return this._readableState.flowing===false};Readable.prototype.setEncoding=function(e){if(!w)w=r(642).s;var t=new w(e);this._readableState.decoder=t;this._readableState.encoding=this._readableState.decoder.encoding;var n=this._readableState.buffer.head;var i=\"\";while(n!==null){i+=t.write(n.data);n=n.next}this._readableState.buffer.clear();if(i!==\"\")this._readableState.buffer.push(i);this._readableState.length=i.length;return this};var T=1073741824;function computeNewHighWaterMark(e){if(e>=T){e=T}else{e--;e|=e>>>1;e|=e>>>2;e|=e>>>4;e|=e>>>8;e|=e>>>16;e++}return e}function howMuchToRead(e,t){if(e<=0||t.length===0&&t.ended)return 0;if(t.objectMode)return 1;if(e!==e){if(t.flowing&&t.length)return t.buffer.head.data.length;else return t.length}if(e>t.highWaterMark)t.highWaterMark=computeNewHighWaterMark(e);if(e<=t.length)return e;if(!t.ended){t.needReadable=true;return 0}return t.length}Readable.prototype.read=function(e){u(\"read\",e);e=parseInt(e,10);var t=this._readableState;var r=e;if(e!==0)t.emittedReadable=false;if(e===0&&t.needReadable&&((t.highWaterMark!==0?t.length>=t.highWaterMark:t.length>0)||t.ended)){u(\"read: emitReadable\",t.length,t.ended);if(t.length===0&&t.ended)endReadable(this);else emitReadable(this);return null}e=howMuchToRead(e,t);if(e===0&&t.ended){if(t.length===0)endReadable(this);return null}var n=t.needReadable;u(\"need readable\",n);if(t.length===0||t.length-e<t.highWaterMark){n=true;u(\"length less than watermark\",n)}if(t.ended||t.reading){n=false;u(\"reading or ended\",n)}else if(n){u(\"do read\");t.reading=true;t.sync=true;if(t.length===0)t.needReadable=true;this._read(t.highWaterMark);t.sync=false;if(!t.reading)e=howMuchToRead(r,t)}var i;if(e>0)i=fromList(e,t);else i=null;if(i===null){t.needReadable=t.length<=t.highWaterMark;e=0}else{t.length-=e;t.awaitDrain=0}if(t.length===0){if(!t.ended)t.needReadable=true;if(r!==e&&t.ended)endReadable(this)}if(i!==null)this.emit(\"data\",i);return i};function onEofChunk(e,t){u(\"onEofChunk\");if(t.ended)return;if(t.decoder){var r=t.decoder.end();if(r&&r.length){t.buffer.push(r);t.length+=t.objectMode?1:r.length}}t.ended=true;if(t.sync){emitReadable(e)}else{t.needReadable=false;if(!t.emittedReadable){t.emittedReadable=true;emitReadable_(e)}}}function emitReadable(e){var t=e._readableState;u(\"emitReadable\",t.needReadable,t.emittedReadable);t.needReadable=false;if(!t.emittedReadable){u(\"emitReadable\",t.flowing);t.emittedReadable=true;process.nextTick(emitReadable_,e)}}function emitReadable_(e){var t=e._readableState;u(\"emitReadable_\",t.destroyed,t.length,t.ended);if(!t.destroyed&&(t.length||t.ended)){e.emit(\"readable\");t.emittedReadable=false}t.needReadable=!t.flowing&&!t.ended&&t.length<=t.highWaterMark;flow(e)}function maybeReadMore(e,t){if(!t.readingMore){t.readingMore=true;process.nextTick(maybeReadMore_,e,t)}}function maybeReadMore_(e,t){while(!t.reading&&!t.ended&&(t.length<t.highWaterMark||t.flowing&&t.length===0)){var r=t.length;u(\"maybeReadMore read 0\");e.read(0);if(r===t.length)break}t.readingMore=false}Readable.prototype._read=function(e){R(this,new _(\"_read()\"))};Readable.prototype.pipe=function(e,t){var r=this;var n=this._readableState;switch(n.pipesCount){case 0:n.pipes=e;break;case 1:n.pipes=[n.pipes,e];break;default:n.pipes.push(e);break}n.pipesCount+=1;u(\"pipe count=%d opts=%j\",n.pipesCount,t);var i=(!t||t.end!==false)&&e!==process.stdout&&e!==process.stderr;var o=i?onend:unpipe;if(n.endEmitted)process.nextTick(o);else r.once(\"end\",o);e.on(\"unpipe\",onunpipe);function onunpipe(e,t){u(\"onunpipe\");if(e===r){if(t&&t.hasUnpiped===false){t.hasUnpiped=true;cleanup()}}}function onend(){u(\"onend\");e.end()}var s=pipeOnDrain(r);e.on(\"drain\",s);var f=false;function cleanup(){u(\"cleanup\");e.removeListener(\"close\",onclose);e.removeListener(\"finish\",onfinish);e.removeListener(\"drain\",s);e.removeListener(\"error\",onerror);e.removeListener(\"unpipe\",onunpipe);r.removeListener(\"end\",onend);r.removeListener(\"end\",unpipe);r.removeListener(\"data\",ondata);f=true;if(n.awaitDrain&&(!e._writableState||e._writableState.needDrain))s()}r.on(\"data\",ondata);function ondata(t){u(\"ondata\");var i=e.write(t);u(\"dest.write\",i);if(i===false){if((n.pipesCount===1&&n.pipes===e||n.pipesCount>1&&indexOf(n.pipes,e)!==-1)&&!f){u(\"false write response, pause\",n.awaitDrain);n.awaitDrain++}r.pause()}}function onerror(t){u(\"onerror\",t);unpipe();e.removeListener(\"error\",onerror);if(a(e,\"error\")===0)R(e,t)}prependListener(e,\"error\",onerror);function onclose(){e.removeListener(\"finish\",onfinish);unpipe()}e.once(\"close\",onclose);function onfinish(){u(\"onfinish\");e.removeListener(\"close\",onclose);unpipe()}e.once(\"finish\",onfinish);function unpipe(){u(\"unpipe\");r.unpipe(e)}e.emit(\"pipe\",r);if(!n.flowing){u(\"pipe resume\");r.resume()}return e};function pipeOnDrain(e){return function pipeOnDrainFunctionResult(){var t=e._readableState;u(\"pipeOnDrain\",t.awaitDrain);if(t.awaitDrain)t.awaitDrain--;if(t.awaitDrain===0&&a(e,\"data\")){t.flowing=true;flow(e)}}}Readable.prototype.unpipe=function(e){var t=this._readableState;var r={hasUnpiped:false};if(t.pipesCount===0)return this;if(t.pipesCount===1){if(e&&e!==t.pipes)return this;if(!e)e=t.pipes;t.pipes=null;t.pipesCount=0;t.flowing=false;if(e)e.emit(\"unpipe\",this,r);return this}if(!e){var n=t.pipes;var i=t.pipesCount;t.pipes=null;t.pipesCount=0;t.flowing=false;for(var a=0;a<i;a++){n[a].emit(\"unpipe\",this,{hasUnpiped:false})}return this}var o=indexOf(t.pipes,e);if(o===-1)return this;t.pipes.splice(o,1);t.pipesCount-=1;if(t.pipesCount===1)t.pipes=t.pipes[0];e.emit(\"unpipe\",this,r);return this};Readable.prototype.on=function(e,t){var r=o.prototype.on.call(this,e,t);var n=this._readableState;if(e===\"data\"){n.readableListening=this.listenerCount(\"readable\")>0;if(n.flowing!==false)this.resume()}else if(e===\"readable\"){if(!n.endEmitted&&!n.readableListening){n.readableListening=n.needReadable=true;n.flowing=false;n.emittedReadable=false;u(\"on readable\",n.length,n.reading);if(n.length){emitReadable(this)}else if(!n.reading){process.nextTick(nReadingNextTick,this)}}}return r};Readable.prototype.addListener=Readable.prototype.on;Readable.prototype.removeListener=function(e,t){var r=o.prototype.removeListener.call(this,e,t);if(e===\"readable\"){process.nextTick(updateReadableListening,this)}return r};Readable.prototype.removeAllListeners=function(e){var t=o.prototype.removeAllListeners.apply(this,arguments);if(e===\"readable\"||e===undefined){process.nextTick(updateReadableListening,this)}return t};function updateReadableListening(e){var t=e._readableState;t.readableListening=e.listenerCount(\"readable\")>0;if(t.resumeScheduled&&!t.paused){t.flowing=true}else if(e.listenerCount(\"data\")>0){e.resume()}}function nReadingNextTick(e){u(\"readable nexttick read 0\");e.read(0)}Readable.prototype.resume=function(){var e=this._readableState;if(!e.flowing){u(\"resume\");e.flowing=!e.readableListening;resume(this,e)}e.paused=false;return this};function resume(e,t){if(!t.resumeScheduled){t.resumeScheduled=true;process.nextTick(resume_,e,t)}}function resume_(e,t){u(\"resume\",t.reading);if(!t.reading){e.read(0)}t.resumeScheduled=false;e.emit(\"resume\");flow(e);if(t.flowing&&!t.reading)e.read(0)}Readable.prototype.pause=function(){u(\"call pause flowing=%j\",this._readableState.flowing);if(this._readableState.flowing!==false){u(\"pause\");this._readableState.flowing=false;this.emit(\"pause\")}this._readableState.paused=true;return this};function flow(e){var t=e._readableState;u(\"flow\",t.flowing);while(t.flowing&&e.read()!==null){}}Readable.prototype.wrap=function(e){var t=this;var r=this._readableState;var n=false;e.on(\"end\",(function(){u(\"wrapped end\");if(r.decoder&&!r.ended){var e=r.decoder.end();if(e&&e.length)t.push(e)}t.push(null)}));e.on(\"data\",(function(i){u(\"wrapped data\");if(r.decoder)i=r.decoder.write(i);if(r.objectMode&&(i===null||i===undefined))return;else if(!r.objectMode&&(!i||!i.length))return;var a=t.push(i);if(!a){n=true;e.pause()}}));for(var i in e){if(this[i]===undefined&&typeof e[i]===\"function\"){this[i]=function methodWrap(t){return function methodWrapReturnFunction(){return e[t].apply(e,arguments)}}(i)}}for(var a=0;a<E.length;a++){e.on(E[a],this.emit.bind(this,E[a]))}this._read=function(t){u(\"wrapped _read\",t);if(n){n=false;e.resume()}};return this};if(typeof Symbol===\"function\"){Readable.prototype[Symbol.asyncIterator]=function(){if(m===undefined){m=r(771)}return m(this)}}Object.defineProperty(Readable.prototype,\"readableHighWaterMark\",{enumerable:false,get:function get(){return this._readableState.highWaterMark}});Object.defineProperty(Readable.prototype,\"readableBuffer\",{enumerable:false,get:function get(){return this._readableState&&this._readableState.buffer}});Object.defineProperty(Readable.prototype,\"readableFlowing\",{enumerable:false,get:function get(){return this._readableState.flowing},set:function set(e){if(this._readableState){this._readableState.flowing=e}}});Readable._fromList=fromList;Object.defineProperty(Readable.prototype,\"readableLength\",{enumerable:false,get:function get(){return this._readableState.length}});function fromList(e,t){if(t.length===0)return null;var r;if(t.objectMode)r=t.buffer.shift();else if(!e||e>=t.length){if(t.decoder)r=t.buffer.join(\"\");else if(t.buffer.length===1)r=t.buffer.first();else r=t.buffer.concat(t.length);t.buffer.clear()}else{r=t.buffer.consume(e,t.decoder)}return r}function endReadable(e){var t=e._readableState;u(\"endReadable\",t.endEmitted);if(!t.endEmitted){t.ended=true;process.nextTick(endReadableNT,t,e)}}function endReadableNT(e,t){u(\"endReadableNT\",e.endEmitted,e.length);if(!e.endEmitted&&e.length===0){e.endEmitted=true;t.readable=false;t.emit(\"end\");if(e.autoDestroy){var r=t._writableState;if(!r||r.autoDestroy&&r.finished){t.destroy()}}}}if(typeof Symbol===\"function\"){Readable.from=function(e,t){if(S===undefined){S=r(16)}return S(Readable,e,t)}}function indexOf(e,t){for(var r=0,n=e.length;r<n;r++){if(e[r]===t)return r}return-1}},786:function(e,t,r){\"use strict\";e.exports=Transform;var n=r(833).q,i=n.ERR_METHOD_NOT_IMPLEMENTED,a=n.ERR_MULTIPLE_CALLBACK,o=n.ERR_TRANSFORM_ALREADY_TRANSFORMING,s=n.ERR_TRANSFORM_WITH_LENGTH_0;var f=r(239);r(526)(Transform,f);function afterTransform(e,t){var r=this._transformState;r.transforming=false;var n=r.writecb;if(n===null){return this.emit(\"error\",new a)}r.writechunk=null;r.writecb=null;if(t!=null)this.push(t);n(e);var i=this._readableState;i.reading=false;if(i.needReadable||i.length<i.highWaterMark){this._read(i.highWaterMark)}}function Transform(e){if(!(this instanceof Transform))return new Transform(e);f.call(this,e);this._transformState={afterTransform:afterTransform.bind(this),needTransform:false,transforming:false,writecb:null,writechunk:null,writeencoding:null};this._readableState.needReadable=true;this._readableState.sync=false;if(e){if(typeof e.transform===\"function\")this._transform=e.transform;if(typeof e.flush===\"function\")this._flush=e.flush}this.on(\"prefinish\",prefinish)}function prefinish(){var e=this;if(typeof this._flush===\"function\"&&!this._readableState.destroyed){this._flush((function(t,r){done(e,t,r)}))}else{done(this,null,null)}}Transform.prototype.push=function(e,t){this._transformState.needTransform=false;return f.prototype.push.call(this,e,t)};Transform.prototype._transform=function(e,t,r){r(new i(\"_transform()\"))};Transform.prototype._write=function(e,t,r){var n=this._transformState;n.writecb=r;n.writechunk=e;n.writeencoding=t;if(!n.transforming){var i=this._readableState;if(n.needTransform||i.needReadable||i.length<i.highWaterMark)this._read(i.highWaterMark)}};Transform.prototype._read=function(e){var t=this._transformState;if(t.writechunk!==null&&!t.transforming){t.transforming=true;this._transform(t.writechunk,t.writeencoding,t.afterTransform)}else{t.needTransform=true}};Transform.prototype._destroy=function(e,t){f.prototype._destroy.call(this,e,(function(e){t(e)}))};function done(e,t,r){if(t)return e.emit(\"error\",t);if(r!=null)e.push(r);if(e._writableState.length)throw new s;if(e._transformState.transforming)throw new o;return e.push(null)}},886:function(e,t,r){\"use strict\";e.exports=Writable;function WriteReq(e,t,r){this.chunk=e;this.encoding=t;this.callback=r;this.next=null}function CorkedRequest(e){var t=this;this.next=null;this.entry=null;this.finish=function(){onCorkedFinish(t,e)}}var n;Writable.WritableState=WritableState;var i={deprecate:r(121)};var a=r(919);var o=r(300).Buffer;var s=__webpack_require__.g.Uint8Array||function(){};function _uint8ArrayToBuffer(e){return o.from(e)}function _isUint8Array(e){return o.isBuffer(e)||e instanceof s}var f=r(364);var l=r(322),u=l.getHighWaterMark;var d=r(833).q,c=d.ERR_INVALID_ARG_TYPE,h=d.ERR_METHOD_NOT_IMPLEMENTED,p=d.ERR_MULTIPLE_CALLBACK,b=d.ERR_STREAM_CANNOT_PIPE,g=d.ERR_STREAM_DESTROYED,y=d.ERR_STREAM_NULL_VALUES,_=d.ERR_STREAM_WRITE_AFTER_END,v=d.ERR_UNKNOWN_ENCODING;var w=f.errorOrDestroy;r(526)(Writable,a);function nop(){}function WritableState(e,t,i){n=n||r(239);e=e||{};if(typeof i!==\"boolean\")i=t instanceof n;this.objectMode=!!e.objectMode;if(i)this.objectMode=this.objectMode||!!e.writableObjectMode;this.highWaterMark=u(this,e,\"writableHighWaterMark\",i);this.finalCalled=false;this.needDrain=false;this.ending=false;this.ended=false;this.finished=false;this.destroyed=false;var a=e.decodeStrings===false;this.decodeStrings=!a;this.defaultEncoding=e.defaultEncoding||\"utf8\";this.length=0;this.writing=false;this.corked=0;this.sync=true;this.bufferProcessing=false;this.onwrite=function(e){onwrite(t,e)};this.writecb=null;this.writelen=0;this.bufferedRequest=null;this.lastBufferedRequest=null;this.pendingcb=0;this.prefinished=false;this.errorEmitted=false;this.emitClose=e.emitClose!==false;this.autoDestroy=!!e.autoDestroy;this.bufferedRequestCount=0;this.corkedRequestsFree=new CorkedRequest(this)}WritableState.prototype.getBuffer=function getBuffer(){var e=this.bufferedRequest;var t=[];while(e){t.push(e);e=e.next}return t};(function(){try{Object.defineProperty(WritableState.prototype,\"buffer\",{get:i.deprecate((function writableStateBufferGetter(){return this.getBuffer()}),\"_writableState.buffer is deprecated. Use _writableState.getBuffer \"+\"instead.\",\"DEP0003\")})}catch(e){}})();var m;if(typeof Symbol===\"function\"&&Symbol.hasInstance&&typeof Function.prototype[Symbol.hasInstance]===\"function\"){m=Function.prototype[Symbol.hasInstance];Object.defineProperty(Writable,Symbol.hasInstance,{value:function value(e){if(m.call(this,e))return true;if(this!==Writable)return false;return e&&e._writableState instanceof WritableState}})}else{m=function realHasInstance(e){return e instanceof this}}function Writable(e){n=n||r(239);var t=this instanceof n;if(!t&&!m.call(Writable,this))return new Writable(e);this._writableState=new WritableState(e,this,t);this.writable=true;if(e){if(typeof e.write===\"function\")this._write=e.write;if(typeof e.writev===\"function\")this._writev=e.writev;if(typeof e.destroy===\"function\")this._destroy=e.destroy;if(typeof e.final===\"function\")this._final=e.final}a.call(this)}Writable.prototype.pipe=function(){w(this,new b)};function writeAfterEnd(e,t){var r=new _;w(e,r);process.nextTick(t,r)}function validChunk(e,t,r,n){var i;if(r===null){i=new y}else if(typeof r!==\"string\"&&!t.objectMode){i=new c(\"chunk\",[\"string\",\"Buffer\"],r)}if(i){w(e,i);process.nextTick(n,i);return false}return true}Writable.prototype.write=function(e,t,r){var n=this._writableState;var i=false;var a=!n.objectMode&&_isUint8Array(e);if(a&&!o.isBuffer(e)){e=_uint8ArrayToBuffer(e)}if(typeof t===\"function\"){r=t;t=null}if(a)t=\"buffer\";else if(!t)t=n.defaultEncoding;if(typeof r!==\"function\")r=nop;if(n.ending)writeAfterEnd(this,r);else if(a||validChunk(this,n,e,r)){n.pendingcb++;i=writeOrBuffer(this,n,a,e,t,r)}return i};Writable.prototype.cork=function(){this._writableState.corked++};Writable.prototype.uncork=function(){var e=this._writableState;if(e.corked){e.corked--;if(!e.writing&&!e.corked&&!e.bufferProcessing&&e.bufferedRequest)clearBuffer(this,e)}};Writable.prototype.setDefaultEncoding=function setDefaultEncoding(e){if(typeof e===\"string\")e=e.toLowerCase();if(!([\"hex\",\"utf8\",\"utf-8\",\"ascii\",\"binary\",\"base64\",\"ucs2\",\"ucs-2\",\"utf16le\",\"utf-16le\",\"raw\"].indexOf((e+\"\").toLowerCase())>-1))throw new v(e);this._writableState.defaultEncoding=e;return this};Object.defineProperty(Writable.prototype,\"writableBuffer\",{enumerable:false,get:function get(){return this._writableState&&this._writableState.getBuffer()}});function decodeChunk(e,t,r){if(!e.objectMode&&e.decodeStrings!==false&&typeof t===\"string\"){t=o.from(t,r)}return t}Object.defineProperty(Writable.prototype,\"writableHighWaterMark\",{enumerable:false,get:function get(){return this._writableState.highWaterMark}});function writeOrBuffer(e,t,r,n,i,a){if(!r){var o=decodeChunk(t,n,i);if(n!==o){r=true;i=\"buffer\";n=o}}var s=t.objectMode?1:n.length;t.length+=s;var f=t.length<t.highWaterMark;if(!f)t.needDrain=true;if(t.writing||t.corked){var l=t.lastBufferedRequest;t.lastBufferedRequest={chunk:n,encoding:i,isBuf:r,callback:a,next:null};if(l){l.next=t.lastBufferedRequest}else{t.bufferedRequest=t.lastBufferedRequest}t.bufferedRequestCount+=1}else{doWrite(e,t,false,s,n,i,a)}return f}function doWrite(e,t,r,n,i,a,o){t.writelen=n;t.writecb=o;t.writing=true;t.sync=true;if(t.destroyed)t.onwrite(new g(\"write\"));else if(r)e._writev(i,t.onwrite);else e._write(i,a,t.onwrite);t.sync=false}function onwriteError(e,t,r,n,i){--t.pendingcb;if(r){process.nextTick(i,n);process.nextTick(finishMaybe,e,t);e._writableState.errorEmitted=true;w(e,n)}else{i(n);e._writableState.errorEmitted=true;w(e,n);finishMaybe(e,t)}}function onwriteStateUpdate(e){e.writing=false;e.writecb=null;e.length-=e.writelen;e.writelen=0}function onwrite(e,t){var r=e._writableState;var n=r.sync;var i=r.writecb;if(typeof i!==\"function\")throw new p;onwriteStateUpdate(r);if(t)onwriteError(e,r,n,t,i);else{var a=needFinish(r)||e.destroyed;if(!a&&!r.corked&&!r.bufferProcessing&&r.bufferedRequest){clearBuffer(e,r)}if(n){process.nextTick(afterWrite,e,r,a,i)}else{afterWrite(e,r,a,i)}}}function afterWrite(e,t,r,n){if(!r)onwriteDrain(e,t);t.pendingcb--;n();finishMaybe(e,t)}function onwriteDrain(e,t){if(t.length===0&&t.needDrain){t.needDrain=false;e.emit(\"drain\")}}function clearBuffer(e,t){t.bufferProcessing=true;var r=t.bufferedRequest;if(e._writev&&r&&r.next){var n=t.bufferedRequestCount;var i=new Array(n);var a=t.corkedRequestsFree;a.entry=r;var o=0;var s=true;while(r){i[o]=r;if(!r.isBuf)s=false;r=r.next;o+=1}i.allBuffers=s;doWrite(e,t,true,t.length,i,\"\",a.finish);t.pendingcb++;t.lastBufferedRequest=null;if(a.next){t.corkedRequestsFree=a.next;a.next=null}else{t.corkedRequestsFree=new CorkedRequest(t)}t.bufferedRequestCount=0}else{while(r){var f=r.chunk;var l=r.encoding;var u=r.callback;var d=t.objectMode?1:f.length;doWrite(e,t,false,d,f,l,u);r=r.next;t.bufferedRequestCount--;if(t.writing){break}}if(r===null)t.lastBufferedRequest=null}t.bufferedRequest=r;t.bufferProcessing=false}Writable.prototype._write=function(e,t,r){r(new h(\"_write()\"))};Writable.prototype._writev=null;Writable.prototype.end=function(e,t,r){var n=this._writableState;if(typeof e===\"function\"){r=e;e=null;t=null}else if(typeof t===\"function\"){r=t;t=null}if(e!==null&&e!==undefined)this.write(e,t);if(n.corked){n.corked=1;this.uncork()}if(!n.ending)endWritable(this,n,r);return this};Object.defineProperty(Writable.prototype,\"writableLength\",{enumerable:false,get:function get(){return this._writableState.length}});function needFinish(e){return e.ending&&e.length===0&&e.bufferedRequest===null&&!e.finished&&!e.writing}function callFinal(e,t){e._final((function(r){t.pendingcb--;if(r){w(e,r)}t.prefinished=true;e.emit(\"prefinish\");finishMaybe(e,t)}))}function prefinish(e,t){if(!t.prefinished&&!t.finalCalled){if(typeof e._final===\"function\"&&!t.destroyed){t.pendingcb++;t.finalCalled=true;process.nextTick(callFinal,e,t)}else{t.prefinished=true;e.emit(\"prefinish\")}}}function finishMaybe(e,t){var r=needFinish(t);if(r){prefinish(e,t);if(t.pendingcb===0){t.finished=true;e.emit(\"finish\");if(t.autoDestroy){var n=e._readableState;if(!n||n.autoDestroy&&n.endEmitted){e.destroy()}}}}return r}function endWritable(e,t,r){t.ending=true;finishMaybe(e,t);if(r){if(t.finished)process.nextTick(r);else e.once(\"finish\",r)}t.ended=true;e.writable=false}function onCorkedFinish(e,t,r){var n=e.entry;e.entry=null;while(n){var i=n.callback;t.pendingcb--;i(r);n=n.next}t.corkedRequestsFree.next=e}Object.defineProperty(Writable.prototype,\"destroyed\",{enumerable:false,get:function get(){if(this._writableState===undefined){return false}return this._writableState.destroyed},set:function set(e){if(!this._writableState){return}this._writableState.destroyed=e}});Writable.prototype.destroy=f.destroy;Writable.prototype._undestroy=f.undestroy;Writable.prototype._destroy=function(e,t){t(e)}},771:function(e,t,r){\"use strict\";var n;function _defineProperty(e,t,r){if(t in e){Object.defineProperty(e,t,{value:r,enumerable:true,configurable:true,writable:true})}else{e[t]=r}return e}var i=r(494);var a=Symbol(\"lastResolve\");var o=Symbol(\"lastReject\");var s=Symbol(\"error\");var f=Symbol(\"ended\");var l=Symbol(\"lastPromise\");var u=Symbol(\"handlePromise\");var d=Symbol(\"stream\");function createIterResult(e,t){return{value:e,done:t}}function readAndResolve(e){var t=e[a];if(t!==null){var r=e[d].read();if(r!==null){e[l]=null;e[a]=null;e[o]=null;t(createIterResult(r,false))}}}function onReadable(e){process.nextTick(readAndResolve,e)}function wrapForNext(e,t){return function(r,n){e.then((function(){if(t[f]){r(createIterResult(undefined,true));return}t[u](r,n)}),n)}}var c=Object.getPrototypeOf((function(){}));var h=Object.setPrototypeOf((n={get stream(){return this[d]},next:function next(){var e=this;var t=this[s];if(t!==null){return Promise.reject(t)}if(this[f]){return Promise.resolve(createIterResult(undefined,true))}if(this[d].destroyed){return new Promise((function(t,r){process.nextTick((function(){if(e[s]){r(e[s])}else{t(createIterResult(undefined,true))}}))}))}var r=this[l];var n;if(r){n=new Promise(wrapForNext(r,this))}else{var i=this[d].read();if(i!==null){return Promise.resolve(createIterResult(i,false))}n=new Promise(this[u])}this[l]=n;return n}},_defineProperty(n,Symbol.asyncIterator,(function(){return this})),_defineProperty(n,\"return\",(function _return(){var e=this;return new Promise((function(t,r){e[d].destroy(null,(function(e){if(e){r(e);return}t(createIterResult(undefined,true))}))}))})),n),c);var p=function createReadableStreamAsyncIterator(e){var t;var r=Object.create(h,(t={},_defineProperty(t,d,{value:e,writable:true}),_defineProperty(t,a,{value:null,writable:true}),_defineProperty(t,o,{value:null,writable:true}),_defineProperty(t,s,{value:null,writable:true}),_defineProperty(t,f,{value:e._readableState.endEmitted,writable:true}),_defineProperty(t,u,{value:function value(e,t){var n=r[d].read();if(n){r[l]=null;r[a]=null;r[o]=null;e(createIterResult(n,false))}else{r[a]=e;r[o]=t}},writable:true}),t));r[l]=null;i(e,(function(e){if(e&&e.code!==\"ERR_STREAM_PREMATURE_CLOSE\"){var t=r[o];if(t!==null){r[l]=null;r[a]=null;r[o]=null;t(e)}r[s]=e;return}var n=r[a];if(n!==null){r[l]=null;r[a]=null;r[o]=null;n(createIterResult(undefined,true))}r[f]=true}));e.on(\"readable\",onReadable.bind(null,r));return r};e.exports=p},914:function(e,t,r){\"use strict\";function ownKeys(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);if(t)n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}));r.push.apply(r,n)}return r}function _objectSpread(e){for(var t=1;t<arguments.length;t++){var r=arguments[t]!=null?arguments[t]:{};if(t%2){ownKeys(Object(r),true).forEach((function(t){_defineProperty(e,t,r[t])}))}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(e,Object.getOwnPropertyDescriptors(r))}else{ownKeys(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}}return e}function _defineProperty(e,t,r){if(t in e){Object.defineProperty(e,t,{value:r,enumerable:true,configurable:true,writable:true})}else{e[t]=r}return e}function _classCallCheck(e,t){if(!(e instanceof t)){throw new TypeError(\"Cannot call a class as a function\")}}function _defineProperties(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||false;n.configurable=true;if(\"value\"in n)n.writable=true;Object.defineProperty(e,n.key,n)}}function _createClass(e,t,r){if(t)_defineProperties(e.prototype,t);if(r)_defineProperties(e,r);return e}var n=r(300),i=n.Buffer;var a=r(837),o=a.inspect;var s=o&&o.custom||\"inspect\";function copyBuffer(e,t,r){i.prototype.copy.call(e,t,r)}e.exports=function(){function BufferList(){_classCallCheck(this,BufferList);this.head=null;this.tail=null;this.length=0}_createClass(BufferList,[{key:\"push\",value:function push(e){var t={data:e,next:null};if(this.length>0)this.tail.next=t;else this.head=t;this.tail=t;++this.length}},{key:\"unshift\",value:function unshift(e){var t={data:e,next:this.head};if(this.length===0)this.tail=t;this.head=t;++this.length}},{key:\"shift\",value:function shift(){if(this.length===0)return;var e=this.head.data;if(this.length===1)this.head=this.tail=null;else this.head=this.head.next;--this.length;return e}},{key:\"clear\",value:function clear(){this.head=this.tail=null;this.length=0}},{key:\"join\",value:function join(e){if(this.length===0)return\"\";var t=this.head;var r=\"\"+t.data;while(t=t.next){r+=e+t.data}return r}},{key:\"concat\",value:function concat(e){if(this.length===0)return i.alloc(0);var t=i.allocUnsafe(e>>>0);var r=this.head;var n=0;while(r){copyBuffer(r.data,t,n);n+=r.data.length;r=r.next}return t}},{key:\"consume\",value:function consume(e,t){var r;if(e<this.head.data.length){r=this.head.data.slice(0,e);this.head.data=this.head.data.slice(e)}else if(e===this.head.data.length){r=this.shift()}else{r=t?this._getString(e):this._getBuffer(e)}return r}},{key:\"first\",value:function first(){return this.head.data}},{key:\"_getString\",value:function _getString(e){var t=this.head;var r=1;var n=t.data;e-=n.length;while(t=t.next){var i=t.data;var a=e>i.length?i.length:e;if(a===i.length)n+=i;else n+=i.slice(0,e);e-=a;if(e===0){if(a===i.length){++r;if(t.next)this.head=t.next;else this.head=this.tail=null}else{this.head=t;t.data=i.slice(a)}break}++r}this.length-=r;return n}},{key:\"_getBuffer\",value:function _getBuffer(e){var t=i.allocUnsafe(e);var r=this.head;var n=1;r.data.copy(t);e-=r.data.length;while(r=r.next){var a=r.data;var o=e>a.length?a.length:e;a.copy(t,t.length-e,0,o);e-=o;if(e===0){if(o===a.length){++n;if(r.next)this.head=r.next;else this.head=this.tail=null}else{this.head=r;r.data=a.slice(o)}break}++n}this.length-=n;return t}},{key:s,value:function value(e,t){return o(this,_objectSpread({},t,{depth:0,customInspect:false}))}}]);return BufferList}()},364:function(e){\"use strict\";function destroy(e,t){var r=this;var n=this._readableState&&this._readableState.destroyed;var i=this._writableState&&this._writableState.destroyed;if(n||i){if(t){t(e)}else if(e){if(!this._writableState){process.nextTick(emitErrorNT,this,e)}else if(!this._writableState.errorEmitted){this._writableState.errorEmitted=true;process.nextTick(emitErrorNT,this,e)}}return this}if(this._readableState){this._readableState.destroyed=true}if(this._writableState){this._writableState.destroyed=true}this._destroy(e||null,(function(e){if(!t&&e){if(!r._writableState){process.nextTick(emitErrorAndCloseNT,r,e)}else if(!r._writableState.errorEmitted){r._writableState.errorEmitted=true;process.nextTick(emitErrorAndCloseNT,r,e)}else{process.nextTick(emitCloseNT,r)}}else if(t){process.nextTick(emitCloseNT,r);t(e)}else{process.nextTick(emitCloseNT,r)}}));return this}function emitErrorAndCloseNT(e,t){emitErrorNT(e,t);emitCloseNT(e)}function emitCloseNT(e){if(e._writableState&&!e._writableState.emitClose)return;if(e._readableState&&!e._readableState.emitClose)return;e.emit(\"close\")}function undestroy(){if(this._readableState){this._readableState.destroyed=false;this._readableState.reading=false;this._readableState.ended=false;this._readableState.endEmitted=false}if(this._writableState){this._writableState.destroyed=false;this._writableState.ended=false;this._writableState.ending=false;this._writableState.finalCalled=false;this._writableState.prefinished=false;this._writableState.finished=false;this._writableState.errorEmitted=false}}function emitErrorNT(e,t){e.emit(\"error\",t)}function errorOrDestroy(e,t){var r=e._readableState;var n=e._writableState;if(r&&r.autoDestroy||n&&n.autoDestroy)e.destroy(t);else e.emit(\"error\",t)}e.exports={destroy:destroy,undestroy:undestroy,errorOrDestroy:errorOrDestroy}},494:function(e,t,r){\"use strict\";var n=r(833).q.ERR_STREAM_PREMATURE_CLOSE;function once(e){var t=false;return function(){if(t)return;t=true;for(var r=arguments.length,n=new Array(r),i=0;i<r;i++){n[i]=arguments[i]}e.apply(this,n)}}function noop(){}function isRequest(e){return e.setHeader&&typeof e.abort===\"function\"}function eos(e,t,r){if(typeof t===\"function\")return eos(e,null,t);if(!t)t={};r=once(r||noop);var i=t.readable||t.readable!==false&&e.readable;var a=t.writable||t.writable!==false&&e.writable;var o=function onlegacyfinish(){if(!e.writable)f()};var s=e._writableState&&e._writableState.finished;var f=function onfinish(){a=false;s=true;if(!i)r.call(e)};var l=e._readableState&&e._readableState.endEmitted;var u=function onend(){i=false;l=true;if(!a)r.call(e)};var d=function onerror(t){r.call(e,t)};var c=function onclose(){var t;if(i&&!l){if(!e._readableState||!e._readableState.ended)t=new n;return r.call(e,t)}if(a&&!s){if(!e._writableState||!e._writableState.ended)t=new n;return r.call(e,t)}};var h=function onrequest(){e.req.on(\"finish\",f)};if(isRequest(e)){e.on(\"complete\",f);e.on(\"abort\",c);if(e.req)h();else e.on(\"request\",h)}else if(a&&!e._writableState){e.on(\"end\",o);e.on(\"close\",o)}e.on(\"end\",u);e.on(\"finish\",f);if(t.error!==false)e.on(\"error\",d);e.on(\"close\",c);return function(){e.removeListener(\"complete\",f);e.removeListener(\"abort\",c);e.removeListener(\"request\",h);if(e.req)e.req.removeListener(\"finish\",f);e.removeListener(\"end\",o);e.removeListener(\"close\",o);e.removeListener(\"finish\",f);e.removeListener(\"end\",u);e.removeListener(\"error\",d);e.removeListener(\"close\",c)}}e.exports=eos},16:function(e,t,r){\"use strict\";function asyncGeneratorStep(e,t,r,n,i,a,o){try{var s=e[a](o);var f=s.value}catch(e){r(e);return}if(s.done){t(f)}else{Promise.resolve(f).then(n,i)}}function _asyncToGenerator(e){return function(){var t=this,r=arguments;return new Promise((function(n,i){var a=e.apply(t,r);function _next(e){asyncGeneratorStep(a,n,i,_next,_throw,\"next\",e)}function _throw(e){asyncGeneratorStep(a,n,i,_next,_throw,\"throw\",e)}_next(undefined)}))}}function ownKeys(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);if(t)n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}));r.push.apply(r,n)}return r}function _objectSpread(e){for(var t=1;t<arguments.length;t++){var r=arguments[t]!=null?arguments[t]:{};if(t%2){ownKeys(Object(r),true).forEach((function(t){_defineProperty(e,t,r[t])}))}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(e,Object.getOwnPropertyDescriptors(r))}else{ownKeys(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}}return e}function _defineProperty(e,t,r){if(t in e){Object.defineProperty(e,t,{value:r,enumerable:true,configurable:true,writable:true})}else{e[t]=r}return e}var n=r(833).q.ERR_INVALID_ARG_TYPE;function from(e,t,r){var i;if(t&&typeof t.next===\"function\"){i=t}else if(t&&t[Symbol.asyncIterator])i=t[Symbol.asyncIterator]();else if(t&&t[Symbol.iterator])i=t[Symbol.iterator]();else throw new n(\"iterable\",[\"Iterable\"],t);var a=new e(_objectSpread({objectMode:true},r));var o=false;a._read=function(){if(!o){o=true;next()}};function next(){return _next2.apply(this,arguments)}function _next2(){_next2=_asyncToGenerator((function*(){try{var e=yield i.next(),t=e.value,r=e.done;if(r){a.push(null)}else if(a.push(yield t)){next()}else{o=false}}catch(e){a.destroy(e)}}));return _next2.apply(this,arguments)}return a}e.exports=from},229:function(e,t,r){\"use strict\";var n;function once(e){var t=false;return function(){if(t)return;t=true;e.apply(void 0,arguments)}}var i=r(833).q,a=i.ERR_MISSING_ARGS,o=i.ERR_STREAM_DESTROYED;function noop(e){if(e)throw e}function isRequest(e){return e.setHeader&&typeof e.abort===\"function\"}function destroyer(e,t,i,a){a=once(a);var s=false;e.on(\"close\",(function(){s=true}));if(n===undefined)n=r(494);n(e,{readable:t,writable:i},(function(e){if(e)return a(e);s=true;a()}));var f=false;return function(t){if(s)return;if(f)return;f=true;if(isRequest(e))return e.abort();if(typeof e.destroy===\"function\")return e.destroy();a(t||new o(\"pipe\"))}}function call(e){e()}function pipe(e,t){return e.pipe(t)}function popCallback(e){if(!e.length)return noop;if(typeof e[e.length-1]!==\"function\")return noop;return e.pop()}function pipeline(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++){t[r]=arguments[r]}var n=popCallback(t);if(Array.isArray(t[0]))t=t[0];if(t.length<2){throw new a(\"streams\")}var i;var o=t.map((function(e,r){var a=r<t.length-1;var s=r>0;return destroyer(e,a,s,(function(e){if(!i)i=e;if(e)o.forEach(call);if(a)return;o.forEach(call);n(i)}))}));return t.reduce(pipe)}e.exports=pipeline},322:function(e,t,r){\"use strict\";var n=r(833).q.ERR_INVALID_OPT_VALUE;function highWaterMarkFrom(e,t,r){return e.highWaterMark!=null?e.highWaterMark:t?e[r]:null}function getHighWaterMark(e,t,r,i){var a=highWaterMarkFrom(t,i,r);if(a!=null){if(!(isFinite(a)&&Math.floor(a)===a)||a<0){var o=i?r:\"highWaterMark\";throw new n(o,a)}return Math.floor(a)}return e.objectMode?16:16*1024}e.exports={getHighWaterMark:getHighWaterMark}},919:function(e,t,r){e.exports=r(781)},642:function(e,t,r){\"use strict\";var n=r(118).Buffer;var i=n.isEncoding||function(e){e=\"\"+e;switch(e&&e.toLowerCase()){case\"hex\":case\"utf8\":case\"utf-8\":case\"ascii\":case\"binary\":case\"base64\":case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":case\"raw\":return true;default:return false}};function _normalizeEncoding(e){if(!e)return\"utf8\";var t;while(true){switch(e){case\"utf8\":case\"utf-8\":return\"utf8\";case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return\"utf16le\";case\"latin1\":case\"binary\":return\"latin1\";case\"base64\":case\"ascii\":case\"hex\":return e;default:if(t)return;e=(\"\"+e).toLowerCase();t=true}}}function normalizeEncoding(e){var t=_normalizeEncoding(e);if(typeof t!==\"string\"&&(n.isEncoding===i||!i(e)))throw new Error(\"Unknown encoding: \"+e);return t||e}t.s=StringDecoder;function StringDecoder(e){this.encoding=normalizeEncoding(e);var t;switch(this.encoding){case\"utf16le\":this.text=utf16Text;this.end=utf16End;t=4;break;case\"utf8\":this.fillLast=utf8FillLast;t=4;break;case\"base64\":this.text=base64Text;this.end=base64End;t=3;break;default:this.write=simpleWrite;this.end=simpleEnd;return}this.lastNeed=0;this.lastTotal=0;this.lastChar=n.allocUnsafe(t)}StringDecoder.prototype.write=function(e){if(e.length===0)return\"\";var t;var r;if(this.lastNeed){t=this.fillLast(e);if(t===undefined)return\"\";r=this.lastNeed;this.lastNeed=0}else{r=0}if(r<e.length)return t?t+this.text(e,r):this.text(e,r);return t||\"\"};StringDecoder.prototype.end=utf8End;StringDecoder.prototype.text=utf8Text;StringDecoder.prototype.fillLast=function(e){if(this.lastNeed<=e.length){e.copy(this.lastChar,this.lastTotal-this.lastNeed,0,this.lastNeed);return this.lastChar.toString(this.encoding,0,this.lastTotal)}e.copy(this.lastChar,this.lastTotal-this.lastNeed,0,e.length);this.lastNeed-=e.length};function utf8CheckByte(e){if(e<=127)return 0;else if(e>>5===6)return 2;else if(e>>4===14)return 3;else if(e>>3===30)return 4;return e>>6===2?-1:-2}function utf8CheckIncomplete(e,t,r){var n=t.length-1;if(n<r)return 0;var i=utf8CheckByte(t[n]);if(i>=0){if(i>0)e.lastNeed=i-1;return i}if(--n<r||i===-2)return 0;i=utf8CheckByte(t[n]);if(i>=0){if(i>0)e.lastNeed=i-2;return i}if(--n<r||i===-2)return 0;i=utf8CheckByte(t[n]);if(i>=0){if(i>0){if(i===2)i=0;else e.lastNeed=i-3}return i}return 0}function utf8CheckExtraBytes(e,t,r){if((t[0]&192)!==128){e.lastNeed=0;return\"�\"}if(e.lastNeed>1&&t.length>1){if((t[1]&192)!==128){e.lastNeed=1;return\"�\"}if(e.lastNeed>2&&t.length>2){if((t[2]&192)!==128){e.lastNeed=2;return\"�\"}}}}function utf8FillLast(e){var t=this.lastTotal-this.lastNeed;var r=utf8CheckExtraBytes(this,e,t);if(r!==undefined)return r;if(this.lastNeed<=e.length){e.copy(this.lastChar,t,0,this.lastNeed);return this.lastChar.toString(this.encoding,0,this.lastTotal)}e.copy(this.lastChar,t,0,e.length);this.lastNeed-=e.length}function utf8Text(e,t){var r=utf8CheckIncomplete(this,e,t);if(!this.lastNeed)return e.toString(\"utf8\",t);this.lastTotal=r;var n=e.length-(r-this.lastNeed);e.copy(this.lastChar,0,n);return e.toString(\"utf8\",t,n)}function utf8End(e){var t=e&&e.length?this.write(e):\"\";if(this.lastNeed)return t+\"�\";return t}function utf16Text(e,t){if((e.length-t)%2===0){var r=e.toString(\"utf16le\",t);if(r){var n=r.charCodeAt(r.length-1);if(n>=55296&&n<=56319){this.lastNeed=2;this.lastTotal=4;this.lastChar[0]=e[e.length-2];this.lastChar[1]=e[e.length-1];return r.slice(0,-1)}}return r}this.lastNeed=1;this.lastTotal=2;this.lastChar[0]=e[e.length-1];return e.toString(\"utf16le\",t,e.length-1)}function utf16End(e){var t=e&&e.length?this.write(e):\"\";if(this.lastNeed){var r=this.lastTotal-this.lastNeed;return t+this.lastChar.toString(\"utf16le\",0,r)}return t}function base64Text(e,t){var r=(e.length-t)%3;if(r===0)return e.toString(\"base64\",t);this.lastNeed=3-r;this.lastTotal=3;if(r===1){this.lastChar[0]=e[e.length-1]}else{this.lastChar[0]=e[e.length-2];this.lastChar[1]=e[e.length-1]}return e.toString(\"base64\",t,e.length-r)}function base64End(e){var t=e&&e.length?this.write(e):\"\";if(this.lastNeed)return t+this.lastChar.toString(\"base64\",0,3-this.lastNeed);return t}function simpleWrite(e){return e.toString(this.encoding)}function simpleEnd(e){return e&&e.length?this.write(e):\"\"}},121:function(e){e.exports=deprecate;function deprecate(e,t){if(config(\"noDeprecation\")){return e}var r=false;function deprecated(){if(!r){if(config(\"throwDeprecation\")){throw new Error(t)}else if(config(\"traceDeprecation\")){console.trace(t)}else{console.warn(t)}r=true}return e.apply(this,arguments)}return deprecated}function config(e){try{if(!__webpack_require__.g.localStorage)return false}catch(e){return false}var t=__webpack_require__.g.localStorage[e];if(null==t)return false;return String(t).toLowerCase()===\"true\"}},300:function(e){\"use strict\";e.exports=__webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")},361:function(e){\"use strict\";e.exports=__webpack_require__(/*! events */ \"./node_modules/events/events.js\")},781:function(e){\"use strict\";e.exports=(__webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter)},837:function(e){\"use strict\";e.exports=__webpack_require__(/*! util */ \"./node_modules/util/util.js\")}};var t={};function __nccwpck_require__(r){var n=t[r];if(n!==undefined){return n.exports}var i=t[r]={exports:{}};var a=true;try{e[r](i,i.exports,__nccwpck_require__);a=false}finally{if(a)delete t[r]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var r=__nccwpck_require__(562);module.exports=r})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3N0cmVhbS1icm93c2VyaWZ5L2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7O0FBQUEsWUFBWSxPQUFPLGdCQUFnQixzQ0FBc0MsaUNBQWlDLE1BQU0sV0FBVyx1Q0FBdUMsYUFBYSwwREFBMEQsSUFBSSxLQUFLLGlDQUFpQyxNQUFNLFdBQVcsMEJBQTBCLCtCQUErQix5QkFBeUIsNkJBQTZCLHFCQUFxQixhQUFhLGVBQWUsd0JBQXdCLGdCQUFnQixXQUFXLHNEQUFzRCxZQUFZLEtBQUssZUFBZSxvQkFBb0IsMkJBQTJCLGdCQUFnQixnREFBZ0Qsd0JBQXdCLGdDQUFnQyx3QkFBd0IscURBQXFELGlCQUFpQixpQ0FBaUMsd0JBQXdCLGlEQUFpRCxXQUFXLGtCQUFrQix3QkFBd0IsWUFBWSxLQUFLLFdBQVcsS0FBSyxVQUFVLFVBQVUsbUNBQW1DLHdCQUF3QixpREFBaUQsYUFBYSx1Q0FBdUMsd0JBQXdCLGlEQUFpRCx3QkFBd0IscUJBQXFCLGlCQUFpQiwwQkFBMEIsYUFBYSxZQUFZLHVCQUF1Qix1QkFBdUIscUJBQXFCLHdCQUF3QiwwQkFBMEIsdUJBQXVCLHVCQUF1QixxQkFBcUIsa0JBQWtCLGFBQWEsb0NBQW9DLFdBQVcsbUJBQW1CLGVBQWUsZ0NBQWdDLFlBQVksb0JBQW9CLG1CQUFtQix5QkFBeUIsWUFBWSxzQkFBc0IscUNBQXFDLGtCQUFrQixzQkFBc0IsWUFBWSxpQkFBaUIsWUFBWSxPQUFPLFFBQVEsbUJBQW1CLFlBQVksT0FBTyw2Q0FBNkMsb0JBQW9CLFVBQVUsc0NBQXNDLFNBQVMsc0JBQXNCLHNCQUFzQixtQkFBbUIsZ0NBQWdDLGtDQUFrQyw4QkFBOEIsa0NBQWtDLGtDQUFrQyxrQ0FBa0MsZ0NBQWdDLGtDQUFrQyxrQ0FBa0Msb0JBQW9CLHNCQUFzQixzQkFBc0IsaUJBQWlCLFVBQVUsaUJBQWlCLGFBQWEsV0FBVyxnQ0FBZ0MsT0FBTyxRQUFRLDJCQUEyQix3QkFBd0IsU0FBUyxL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QVMsYUFBYSxNQUFNLHFCQUFNLGlCQUFpQix3QkFBd0IseUNBQXlDLGlCQUFpQixhQUFhLFVBQVUsbUJBQU8sQ0FBQyw4Q0FBUSxFQUFFLGlCQUFpQixhQUFhLFVBQVUsbUJBQU8sQ0FBQywrQ0FBUSxFQUFFLGlCQUFpQixhQUFhLFVBQVUsbUZBQThCLENBQUMsaUJBQWlCLGFBQWEsVUFBVSxtQkFBTyxDQUFDLHlDQUFNLElBQUksU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssK0JBQStCLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3N0cmVhbS1icm93c2VyaWZ5L2luZGV4LmpzPzkzNDUiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7dmFyIGU9ezUyNjpmdW5jdGlvbihlKXtpZih0eXBlb2YgT2JqZWN0LmNyZWF0ZT09PVwiZnVuY3Rpb25cIil7ZS5leHBvcnRzPWZ1bmN0aW9uIGluaGVyaXRzKGUsdCl7aWYodCl7ZS5zdXBlcl89dDtlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6ZSxlbnVtZXJhYmxlOmZhbHNlLHdyaXRhYmxlOnRydWUsY29uZmlndXJhYmxlOnRydWV9fSl9fX1lbHNle2UuZXhwb3J0cz1mdW5jdGlvbiBpbmhlcml0cyhlLHQpe2lmKHQpe2Uuc3VwZXJfPXQ7dmFyIFRlbXBDdG9yPWZ1bmN0aW9uKCl7fTtUZW1wQ3Rvci5wcm90b3R5cGU9dC5wcm90b3R5cGU7ZS5wcm90b3R5cGU9bmV3IFRlbXBDdG9yO2UucHJvdG90eXBlLmNvbnN0cnVjdG9yPWV9fX19LDExODpmdW5jdGlvbihlLHQscil7dmFyIG49cigzMDApO3ZhciBpPW4uQnVmZmVyO2Z1bmN0aW9uIGNvcHlQcm9wcyhlLHQpe2Zvcih2YXIgciBpbiBlKXt0W3JdPWVbcl19fWlmKGkuZnJvbSYmaS5hbGxvYyYmaS5hbGxvY1Vuc2FmZSYmaS5hbGxvY1Vuc2FmZVNsb3cpe2UuZXhwb3J0cz1ufWVsc2V7Y29weVByb3BzKG4sdCk7dC5CdWZmZXI9U2FmZUJ1ZmZlcn1mdW5jdGlvbiBTYWZlQnVmZmVyKGUsdCxyKXtyZXR1cm4gaShlLHQscil9U2FmZUJ1ZmZlci5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShpLnByb3RvdHlwZSk7Y29weVByb3BzKGksU2FmZUJ1ZmZlcik7U2FmZUJ1ZmZlci5mcm9tPWZ1bmN0aW9uKGUsdCxyKXtpZih0eXBlb2YgZT09PVwibnVtYmVyXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlclwiKX1yZXR1cm4gaShlLHQscil9O1NhZmVCdWZmZXIuYWxsb2M9ZnVuY3Rpb24oZSx0LHIpe2lmKHR5cGVvZiBlIT09XCJudW1iZXJcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXJcIil9dmFyIG49aShlKTtpZih0IT09dW5kZWZpbmVkKXtpZih0eXBlb2Ygcj09PVwic3RyaW5nXCIpe24uZmlsbCh0LHIpfWVsc2V7bi5maWxsKHQpfX1lbHNle24uZmlsbCgwKX1yZXR1cm4gbn07U2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZT1mdW5jdGlvbihlKXtpZih0eXBlb2YgZSE9PVwibnVtYmVyXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyXCIpfXJldHVybiBpKGUpfTtTYWZlQnVmZmVyLmFsbG9jVW5zYWZlU2xvdz1mdW5jdGlvbihlKXtpZih0eXBlb2YgZSE9PVwibnVtYmVyXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyXCIpfXJldHVybiBuLlNsb3dCdWZmZXIoZSl9fSw1NjI6ZnVuY3Rpb24oZSx0LHIpe2UuZXhwb3J0cz1TdHJlYW07dmFyIG49cigzNjEpLkV2ZW50RW1pdHRlcjt2YXIgaT1yKDUyNik7aShTdHJlYW0sbik7U3RyZWFtLlJlYWRhYmxlPXIoMzc1KTtTdHJlYW0uV3JpdGFibGU9cig4ODYpO1N0cmVhbS5EdXBsZXg9cigyMzkpO1N0cmVhbS5UcmFuc2Zvcm09cig3ODYpO1N0cmVhbS5QYXNzVGhyb3VnaD1yKDY2Myk7U3RyZWFtLmZpbmlzaGVkPXIoNDk0KTtTdHJlYW0ucGlwZWxpbmU9cigyMjkpO1N0cmVhbS5TdHJlYW09U3RyZWFtO2Z1bmN0aW9uIFN0cmVhbSgpe24uY2FsbCh0aGlzKX1TdHJlYW0ucHJvdG90eXBlLnBpcGU9ZnVuY3Rpb24oZSx0KXt2YXIgcj10aGlzO2Z1bmN0aW9uIG9uZGF0YSh0KXtpZihlLndyaXRhYmxlKXtpZihmYWxzZT09PWUud3JpdGUodCkmJnIucGF1c2Upe3IucGF1c2UoKX19fXIub24oXCJkYXRhXCIsb25kYXRhKTtmdW5jdGlvbiBvbmRyYWluKCl7aWYoci5yZWFkYWJsZSYmci5yZXN1bWUpe3IucmVzdW1lKCl9fWUub24oXCJkcmFpblwiLG9uZHJhaW4pO2lmKCFlLl9pc1N0ZGlvJiYoIXR8fHQuZW5kIT09ZmFsc2UpKXtyLm9uKFwiZW5kXCIsb25lbmQpO3Iub24oXCJjbG9zZVwiLG9uY2xvc2UpfXZhciBpPWZhbHNlO2Z1bmN0aW9uIG9uZW5kKCl7aWYoaSlyZXR1cm47aT10cnVlO2UuZW5kKCl9ZnVuY3Rpb24gb25jbG9zZSgpe2lmKGkpcmV0dXJuO2k9dHJ1ZTtpZih0eXBlb2YgZS5kZXN0cm95PT09XCJmdW5jdGlvblwiKWUuZGVzdHJveSgpfWZ1bmN0aW9uIG9uZXJyb3IoZSl7Y2xlYW51cCgpO2lmKG4ubGlzdGVuZXJDb3VudCh0aGlzLFwiZXJyb3JcIik9PT0wKXt0aHJvdyBlfX1yLm9uKFwiZXJyb3JcIixvbmVycm9yKTtlLm9uKFwiZXJyb3JcIixvbmVycm9yKTtmdW5jdGlvbiBjbGVhbnVwKCl7ci5yZW1vdmVMaXN0ZW5lcihcImRhdGFcIixvbmRhdGEpO2UucmVtb3ZlTGlzdGVuZXIoXCJkcmFpblwiLG9uZHJhaW4pO3IucmVtb3ZlTGlzdGVuZXIoXCJlbmRcIixvbmVuZCk7ci5yZW1vdmVMaXN0ZW5lcihcImNsb3NlXCIsb25jbG9zZSk7ci5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsb25lcnJvcik7ZS5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsb25lcnJvcik7ci5yZW1vdmVMaXN0ZW5lcihcImVuZFwiLGNsZWFudXApO3IucmVtb3ZlTGlzdGVuZXIoXCJjbG9zZVwiLGNsZWFudXApO2UucmVtb3ZlTGlzdGVuZXIoXCJjbG9zZVwiLGNsZWFudXApfXIub24oXCJlbmRcIixjbGVhbnVwKTtyLm9uKFwiY2xvc2VcIixjbGVhbnVwKTtlLm9uKFwiY2xvc2VcIixjbGVhbnVwKTtlLmVtaXQoXCJwaXBlXCIscik7cmV0dXJuIGV9fSw4MzM6ZnVuY3Rpb24oZSl7XCJ1c2Ugc3RyaWN0XCI7Y29uc3QgdD17fTtmdW5jdGlvbiBjcmVhdGVFcnJvclR5cGUoZSxyLG4pe2lmKCFuKXtuPUVycm9yfWZ1bmN0aW9uIGdldE1lc3NhZ2UoZSx0LG4pe2lmKHR5cGVvZiByPT09XCJzdHJpbmdcIil7cmV0dXJuIHJ9ZWxzZXtyZXR1cm4gcihlLHQsbil9fWNsYXNzIE5vZGVFcnJvciBleHRlbmRzIG57Y29uc3RydWN0b3IoZSx0LHIpe3N1cGVyKGdldE1lc3NhZ2UoZSx0LHIpKX19Tm9kZUVycm9yLnByb3RvdHlwZS5uYW1lPW4ubmFtZTtOb2RlRXJyb3IucHJvdG90eXBlLmNvZGU9ZTt0W2VdPU5vZGVFcnJvcn1mdW5jdGlvbiBvbmVPZihlLHQpe2lmKEFycmF5LmlzQXJyYXkoZSkpe2NvbnN0IHI9ZS5sZW5ndGg7ZT1lLm1hcCgoZT0+U3RyaW5nKGUpKSk7aWYocj4yKXtyZXR1cm5gb25lIG9mICR7dH0gJHtlLnNsaWNlKDAsci0xKS5qb2luKFwiLCBcIil9LCBvciBgK2Vbci0xXX1lbHNlIGlmKHI9PT0yKXtyZXR1cm5gb25lIG9mICR7dH0gJHtlWzBdfSBvciAke2VbMV19YH1lbHNle3JldHVybmBvZiAke3R9ICR7ZVswXX1gfX1lbHNle3JldHVybmBvZiAke3R9ICR7U3RyaW5nKGUpfWB9fWZ1bmN0aW9uIHN0YXJ0c1dpdGgoZSx0LHIpe3JldHVybiBlLnN1YnN0cighcnx8cjwwPzA6K3IsdC5sZW5ndGgpPT09dH1mdW5jdGlvbiBlbmRzV2l0aChlLHQscil7aWYocj09PXVuZGVmaW5lZHx8cj5lLmxlbmd0aCl7cj1lLmxlbmd0aH1yZXR1cm4gZS5zdWJzdHJpbmcoci10Lmxlbmd0aCxyKT09PXR9ZnVuY3Rpb24gaW5jbHVkZXMoZSx0LHIpe2lmKHR5cGVvZiByIT09XCJudW1iZXJcIil7cj0wfWlmKHIrdC5sZW5ndGg+ZS5sZW5ndGgpe3JldHVybiBmYWxzZX1lbHNle3JldHVybiBlLmluZGV4T2YodCxyKSE9PS0xfX1jcmVhdGVFcnJvclR5cGUoXCJFUlJfSU5WQUxJRF9PUFRfVkFMVUVcIiwoZnVuY3Rpb24oZSx0KXtyZXR1cm4nVGhlIHZhbHVlIFwiJyt0KydcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCInK2UrJ1wiJ30pLFR5cGVFcnJvcik7Y3JlYXRlRXJyb3JUeXBlKFwiRVJSX0lOVkFMSURfQVJHX1RZUEVcIiwoZnVuY3Rpb24oZSx0LHIpe2xldCBuO2lmKHR5cGVvZiB0PT09XCJzdHJpbmdcIiYmc3RhcnRzV2l0aCh0LFwibm90IFwiKSl7bj1cIm11c3Qgbm90IGJlXCI7dD10LnJlcGxhY2UoL15ub3QgLyxcIlwiKX1lbHNle249XCJtdXN0IGJlXCJ9bGV0IGk7aWYoZW5kc1dpdGgoZSxcIiBhcmd1bWVudFwiKSl7aT1gVGhlICR7ZX0gJHtufSAke29uZU9mKHQsXCJ0eXBlXCIpfWB9ZWxzZXtjb25zdCByPWluY2x1ZGVzKGUsXCIuXCIpP1wicHJvcGVydHlcIjpcImFyZ3VtZW50XCI7aT1gVGhlIFwiJHtlfVwiICR7cn0gJHtufSAke29uZU9mKHQsXCJ0eXBlXCIpfWB9aSs9YC4gUmVjZWl2ZWQgdHlwZSAke3R5cGVvZiByfWA7cmV0dXJuIGl9KSxUeXBlRXJyb3IpO2NyZWF0ZUVycm9yVHlwZShcIkVSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0ZcIixcInN0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GXCIpO2NyZWF0ZUVycm9yVHlwZShcIkVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEXCIsKGZ1bmN0aW9uKGUpe3JldHVyblwiVGhlIFwiK2UrXCIgbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZFwifSkpO2NyZWF0ZUVycm9yVHlwZShcIkVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFXCIsXCJQcmVtYXR1cmUgY2xvc2VcIik7Y3JlYXRlRXJyb3JUeXBlKFwiRVJSX1NUUkVBTV9ERVNUUk9ZRURcIiwoZnVuY3Rpb24oZSl7cmV0dXJuXCJDYW5ub3QgY2FsbCBcIitlK1wiIGFmdGVyIGEgc3RyZWFtIHdhcyBkZXN0cm95ZWRcIn0pKTtjcmVhdGVFcnJvclR5cGUoXCJFUlJfTVVMVElQTEVfQ0FMTEJBQ0tcIixcIkNhbGxiYWNrIGNhbGxlZCBtdWx0aXBsZSB0aW1lc1wiKTtjcmVhdGVFcnJvclR5cGUoXCJFUlJfU1RSRUFNX0NBTk5PVF9QSVBFXCIsXCJDYW5ub3QgcGlwZSwgbm90IHJlYWRhYmxlXCIpO2NyZWF0ZUVycm9yVHlwZShcIkVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5EXCIsXCJ3cml0ZSBhZnRlciBlbmRcIik7Y3JlYXRlRXJyb3JUeXBlKFwiRVJSX1NUUkVBTV9OVUxMX1ZBTFVFU1wiLFwiTWF5IG5vdCB3cml0ZSBudWxsIHZhbHVlcyB0byBzdHJlYW1cIixUeXBlRXJyb3IpO2NyZWF0ZUVycm9yVHlwZShcIkVSUl9VTktOT1dOX0VOQ09ESU5HXCIsKGZ1bmN0aW9uKGUpe3JldHVyblwiVW5rbm93biBlbmNvZGluZzogXCIrZX0pLFR5cGVFcnJvcik7Y3JlYXRlRXJyb3JUeXBlKFwiRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVFwiLFwic3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnRcIik7ZS5leHBvcnRzLnE9dH0sMjM5OmZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1PYmplY3Qua2V5c3x8ZnVuY3Rpb24oZSl7dmFyIHQ9W107Zm9yKHZhciByIGluIGUpe3QucHVzaChyKX1yZXR1cm4gdH07ZS5leHBvcnRzPUR1cGxleDt2YXIgaT1yKDM3NSk7dmFyIGE9cig4ODYpO3IoNTI2KShEdXBsZXgsaSk7e3ZhciBvPW4oYS5wcm90b3R5cGUpO2Zvcih2YXIgcz0wO3M8by5sZW5ndGg7cysrKXt2YXIgZj1vW3NdO2lmKCFEdXBsZXgucHJvdG90eXBlW2ZdKUR1cGxleC5wcm90b3R5cGVbZl09YS5wcm90b3R5cGVbZl19fWZ1bmN0aW9uIER1cGxleChlKXtpZighKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKXJldHVybiBuZXcgRHVwbGV4KGUpO2kuY2FsbCh0aGlzLGUpO2EuY2FsbCh0aGlzLGUpO3RoaXMuYWxsb3dIYWxmT3Blbj10cnVlO2lmKGUpe2lmKGUucmVhZGFibGU9PT1mYWxzZSl0aGlzLnJlYWRhYmxlPWZhbHNlO2lmKGUud3JpdGFibGU9PT1mYWxzZSl0aGlzLndyaXRhYmxlPWZhbHNlO2lmKGUuYWxsb3dIYWxmT3Blbj09PWZhbHNlKXt0aGlzLmFsbG93SGFsZk9wZW49ZmFsc2U7dGhpcy5vbmNlKFwiZW5kXCIsb25lbmQpfX19T2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsXCJ3cml0YWJsZUhpZ2hXYXRlck1hcmtcIix7ZW51bWVyYWJsZTpmYWxzZSxnZXQ6ZnVuY3Rpb24gZ2V0KCl7cmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFya319KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSxcIndyaXRhYmxlQnVmZmVyXCIse2VudW1lcmFibGU6ZmFsc2UsZ2V0OmZ1bmN0aW9uIGdldCgpe3JldHVybiB0aGlzLl93cml0YWJsZVN0YXRlJiZ0aGlzLl93cml0YWJsZVN0YXRlLmdldEJ1ZmZlcigpfX0pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLFwid3JpdGFibGVMZW5ndGhcIix7ZW51bWVyYWJsZTpmYWxzZSxnZXQ6ZnVuY3Rpb24gZ2V0KCl7cmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUubGVuZ3RofX0pO2Z1bmN0aW9uIG9uZW5kKCl7aWYodGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZClyZXR1cm47cHJvY2Vzcy5uZXh0VGljayhvbkVuZE5ULHRoaXMpfWZ1bmN0aW9uIG9uRW5kTlQoZSl7ZS5lbmQoKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSxcImRlc3Ryb3llZFwiLHtlbnVtZXJhYmxlOmZhbHNlLGdldDpmdW5jdGlvbiBnZXQoKXtpZih0aGlzLl9yZWFkYWJsZVN0YXRlPT09dW5kZWZpbmVkfHx0aGlzLl93cml0YWJsZVN0YXRlPT09dW5kZWZpbmVkKXtyZXR1cm4gZmFsc2V9cmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkJiZ0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZH0sc2V0OmZ1bmN0aW9uIHNldChlKXtpZih0aGlzLl9yZWFkYWJsZVN0YXRlPT09dW5kZWZpbmVkfHx0aGlzLl93cml0YWJsZVN0YXRlPT09dW5kZWZpbmVkKXtyZXR1cm59dGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ9ZTt0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZD1lfX0pfSw2NjM6ZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1QYXNzVGhyb3VnaDt2YXIgbj1yKDc4Nik7cig1MjYpKFBhc3NUaHJvdWdoLG4pO2Z1bmN0aW9uIFBhc3NUaHJvdWdoKGUpe2lmKCEodGhpcyBpbnN0YW5jZW9mIFBhc3NUaHJvdWdoKSlyZXR1cm4gbmV3IFBhc3NUaHJvdWdoKGUpO24uY2FsbCh0aGlzLGUpfVBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtPWZ1bmN0aW9uKGUsdCxyKXtyKG51bGwsZSl9fSwzNzU6ZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1SZWFkYWJsZTt2YXIgbjtSZWFkYWJsZS5SZWFkYWJsZVN0YXRlPVJlYWRhYmxlU3RhdGU7dmFyIGk9cigzNjEpLkV2ZW50RW1pdHRlcjt2YXIgYT1mdW5jdGlvbiBFRWxpc3RlbmVyQ291bnQoZSx0KXtyZXR1cm4gZS5saXN0ZW5lcnModCkubGVuZ3RofTt2YXIgbz1yKDkxOSk7dmFyIHM9cigzMDApLkJ1ZmZlcjt2YXIgZj1nbG9iYWwuVWludDhBcnJheXx8ZnVuY3Rpb24oKXt9O2Z1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoZSl7cmV0dXJuIHMuZnJvbShlKX1mdW5jdGlvbiBfaXNVaW50OEFycmF5KGUpe3JldHVybiBzLmlzQnVmZmVyKGUpfHxlIGluc3RhbmNlb2YgZn12YXIgbD1yKDgzNyk7dmFyIHU7aWYobCYmbC5kZWJ1Z2xvZyl7dT1sLmRlYnVnbG9nKFwic3RyZWFtXCIpfWVsc2V7dT1mdW5jdGlvbiBkZWJ1Zygpe319dmFyIGQ9cig5MTQpO3ZhciBjPXIoMzY0KTt2YXIgaD1yKDMyMikscD1oLmdldEhpZ2hXYXRlck1hcms7dmFyIGI9cig4MzMpLnEsZz1iLkVSUl9JTlZBTElEX0FSR19UWVBFLHk9Yi5FUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GLF89Yi5FUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCx2PWIuRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVDt2YXIgdzt2YXIgbTt2YXIgUztyKDUyNikoUmVhZGFibGUsbyk7dmFyIFI9Yy5lcnJvck9yRGVzdHJveTt2YXIgRT1bXCJlcnJvclwiLFwiY2xvc2VcIixcImRlc3Ryb3lcIixcInBhdXNlXCIsXCJyZXN1bWVcIl07ZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKGUsdCxyKXtpZih0eXBlb2YgZS5wcmVwZW5kTGlzdGVuZXI9PT1cImZ1bmN0aW9uXCIpcmV0dXJuIGUucHJlcGVuZExpc3RlbmVyKHQscik7aWYoIWUuX2V2ZW50c3x8IWUuX2V2ZW50c1t0XSllLm9uKHQscik7ZWxzZSBpZihBcnJheS5pc0FycmF5KGUuX2V2ZW50c1t0XSkpZS5fZXZlbnRzW3RdLnVuc2hpZnQocik7ZWxzZSBlLl9ldmVudHNbdF09W3IsZS5fZXZlbnRzW3RdXX1mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKGUsdCxpKXtuPW58fHIoMjM5KTtlPWV8fHt9O2lmKHR5cGVvZiBpIT09XCJib29sZWFuXCIpaT10IGluc3RhbmNlb2Ygbjt0aGlzLm9iamVjdE1vZGU9ISFlLm9iamVjdE1vZGU7aWYoaSl0aGlzLm9iamVjdE1vZGU9dGhpcy5vYmplY3RNb2RlfHwhIWUucmVhZGFibGVPYmplY3RNb2RlO3RoaXMuaGlnaFdhdGVyTWFyaz1wKHRoaXMsZSxcInJlYWRhYmxlSGlnaFdhdGVyTWFya1wiLGkpO3RoaXMuYnVmZmVyPW5ldyBkO3RoaXMubGVuZ3RoPTA7dGhpcy5waXBlcz1udWxsO3RoaXMucGlwZXNDb3VudD0wO3RoaXMuZmxvd2luZz1udWxsO3RoaXMuZW5kZWQ9ZmFsc2U7dGhpcy5lbmRFbWl0dGVkPWZhbHNlO3RoaXMucmVhZGluZz1mYWxzZTt0aGlzLnN5bmM9dHJ1ZTt0aGlzLm5lZWRSZWFkYWJsZT1mYWxzZTt0aGlzLmVtaXR0ZWRSZWFkYWJsZT1mYWxzZTt0aGlzLnJlYWRhYmxlTGlzdGVuaW5nPWZhbHNlO3RoaXMucmVzdW1lU2NoZWR1bGVkPWZhbHNlO3RoaXMucGF1c2VkPXRydWU7dGhpcy5lbWl0Q2xvc2U9ZS5lbWl0Q2xvc2UhPT1mYWxzZTt0aGlzLmF1dG9EZXN0cm95PSEhZS5hdXRvRGVzdHJveTt0aGlzLmRlc3Ryb3llZD1mYWxzZTt0aGlzLmRlZmF1bHRFbmNvZGluZz1lLmRlZmF1bHRFbmNvZGluZ3x8XCJ1dGY4XCI7dGhpcy5hd2FpdERyYWluPTA7dGhpcy5yZWFkaW5nTW9yZT1mYWxzZTt0aGlzLmRlY29kZXI9bnVsbDt0aGlzLmVuY29kaW5nPW51bGw7aWYoZS5lbmNvZGluZyl7aWYoIXcpdz1yKDY0Mikuczt0aGlzLmRlY29kZXI9bmV3IHcoZS5lbmNvZGluZyk7dGhpcy5lbmNvZGluZz1lLmVuY29kaW5nfX1mdW5jdGlvbiBSZWFkYWJsZShlKXtuPW58fHIoMjM5KTtpZighKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpcmV0dXJuIG5ldyBSZWFkYWJsZShlKTt2YXIgdD10aGlzIGluc3RhbmNlb2Ygbjt0aGlzLl9yZWFkYWJsZVN0YXRlPW5ldyBSZWFkYWJsZVN0YXRlKGUsdGhpcyx0KTt0aGlzLnJlYWRhYmxlPXRydWU7aWYoZSl7aWYodHlwZW9mIGUucmVhZD09PVwiZnVuY3Rpb25cIil0aGlzLl9yZWFkPWUucmVhZDtpZih0eXBlb2YgZS5kZXN0cm95PT09XCJmdW5jdGlvblwiKXRoaXMuX2Rlc3Ryb3k9ZS5kZXN0cm95fW8uY2FsbCh0aGlzKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLFwiZGVzdHJveWVkXCIse2VudW1lcmFibGU6ZmFsc2UsZ2V0OmZ1bmN0aW9uIGdldCgpe2lmKHRoaXMuX3JlYWRhYmxlU3RhdGU9PT11bmRlZmluZWQpe3JldHVybiBmYWxzZX1yZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWR9LHNldDpmdW5jdGlvbiBzZXQoZSl7aWYoIXRoaXMuX3JlYWRhYmxlU3RhdGUpe3JldHVybn10aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZD1lfX0pO1JlYWRhYmxlLnByb3RvdHlwZS5kZXN0cm95PWMuZGVzdHJveTtSZWFkYWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveT1jLnVuZGVzdHJveTtSZWFkYWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3k9ZnVuY3Rpb24oZSx0KXt0KGUpfTtSZWFkYWJsZS5wcm90b3R5cGUucHVzaD1mdW5jdGlvbihlLHQpe3ZhciByPXRoaXMuX3JlYWRhYmxlU3RhdGU7dmFyIG47aWYoIXIub2JqZWN0TW9kZSl7aWYodHlwZW9mIGU9PT1cInN0cmluZ1wiKXt0PXR8fHIuZGVmYXVsdEVuY29kaW5nO2lmKHQhPT1yLmVuY29kaW5nKXtlPXMuZnJvbShlLHQpO3Q9XCJcIn1uPXRydWV9fWVsc2V7bj10cnVlfXJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsZSx0LGZhbHNlLG4pfTtSZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdD1mdW5jdGlvbihlKXtyZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLGUsbnVsbCx0cnVlLGZhbHNlKX07ZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhlLHQscixuLGkpe3UoXCJyZWFkYWJsZUFkZENodW5rXCIsdCk7dmFyIGE9ZS5fcmVhZGFibGVTdGF0ZTtpZih0PT09bnVsbCl7YS5yZWFkaW5nPWZhbHNlO29uRW9mQ2h1bmsoZSxhKX1lbHNle3ZhciBvO2lmKCFpKW89Y2h1bmtJbnZhbGlkKGEsdCk7aWYobyl7UihlLG8pfWVsc2UgaWYoYS5vYmplY3RNb2RlfHx0JiZ0Lmxlbmd0aD4wKXtpZih0eXBlb2YgdCE9PVwic3RyaW5nXCImJiFhLm9iamVjdE1vZGUmJk9iamVjdC5nZXRQcm90b3R5cGVPZih0KSE9PXMucHJvdG90eXBlKXt0PV91aW50OEFycmF5VG9CdWZmZXIodCl9aWYobil7aWYoYS5lbmRFbWl0dGVkKVIoZSxuZXcgdik7ZWxzZSBhZGRDaHVuayhlLGEsdCx0cnVlKX1lbHNlIGlmKGEuZW5kZWQpe1IoZSxuZXcgeSl9ZWxzZSBpZihhLmRlc3Ryb3llZCl7cmV0dXJuIGZhbHNlfWVsc2V7YS5yZWFkaW5nPWZhbHNlO2lmKGEuZGVjb2RlciYmIXIpe3Q9YS5kZWNvZGVyLndyaXRlKHQpO2lmKGEub2JqZWN0TW9kZXx8dC5sZW5ndGghPT0wKWFkZENodW5rKGUsYSx0LGZhbHNlKTtlbHNlIG1heWJlUmVhZE1vcmUoZSxhKX1lbHNle2FkZENodW5rKGUsYSx0LGZhbHNlKX19fWVsc2UgaWYoIW4pe2EucmVhZGluZz1mYWxzZTttYXliZVJlYWRNb3JlKGUsYSl9fXJldHVybiFhLmVuZGVkJiYoYS5sZW5ndGg8YS5oaWdoV2F0ZXJNYXJrfHxhLmxlbmd0aD09PTApfWZ1bmN0aW9uIGFkZENodW5rKGUsdCxyLG4pe2lmKHQuZmxvd2luZyYmdC5sZW5ndGg9PT0wJiYhdC5zeW5jKXt0LmF3YWl0RHJhaW49MDtlLmVtaXQoXCJkYXRhXCIscil9ZWxzZXt0Lmxlbmd0aCs9dC5vYmplY3RNb2RlPzE6ci5sZW5ndGg7aWYobil0LmJ1ZmZlci51bnNoaWZ0KHIpO2Vsc2UgdC5idWZmZXIucHVzaChyKTtpZih0Lm5lZWRSZWFkYWJsZSllbWl0UmVhZGFibGUoZSl9bWF5YmVSZWFkTW9yZShlLHQpfWZ1bmN0aW9uIGNodW5rSW52YWxpZChlLHQpe3ZhciByO2lmKCFfaXNVaW50OEFycmF5KHQpJiZ0eXBlb2YgdCE9PVwic3RyaW5nXCImJnQhPT11bmRlZmluZWQmJiFlLm9iamVjdE1vZGUpe3I9bmV3IGcoXCJjaHVua1wiLFtcInN0cmluZ1wiLFwiQnVmZmVyXCIsXCJVaW50OEFycmF5XCJdLHQpfXJldHVybiByfVJlYWRhYmxlLnByb3RvdHlwZS5pc1BhdXNlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmc9PT1mYWxzZX07UmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nPWZ1bmN0aW9uKGUpe2lmKCF3KXc9cig2NDIpLnM7dmFyIHQ9bmV3IHcoZSk7dGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyPXQ7dGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZz10aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIuZW5jb2Rpbmc7dmFyIG49dGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIuaGVhZDt2YXIgaT1cIlwiO3doaWxlKG4hPT1udWxsKXtpKz10LndyaXRlKG4uZGF0YSk7bj1uLm5leHR9dGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIuY2xlYXIoKTtpZihpIT09XCJcIil0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlci5wdXNoKGkpO3RoaXMuX3JlYWRhYmxlU3RhdGUubGVuZ3RoPWkubGVuZ3RoO3JldHVybiB0aGlzfTt2YXIgVD0xMDczNzQxODI0O2Z1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKGUpe2lmKGU+PVQpe2U9VH1lbHNle2UtLTtlfD1lPj4+MTtlfD1lPj4+MjtlfD1lPj4+NDtlfD1lPj4+ODtlfD1lPj4+MTY7ZSsrfXJldHVybiBlfWZ1bmN0aW9uIGhvd011Y2hUb1JlYWQoZSx0KXtpZihlPD0wfHx0Lmxlbmd0aD09PTAmJnQuZW5kZWQpcmV0dXJuIDA7aWYodC5vYmplY3RNb2RlKXJldHVybiAxO2lmKGUhPT1lKXtpZih0LmZsb3dpbmcmJnQubGVuZ3RoKXJldHVybiB0LmJ1ZmZlci5oZWFkLmRhdGEubGVuZ3RoO2Vsc2UgcmV0dXJuIHQubGVuZ3RofWlmKGU+dC5oaWdoV2F0ZXJNYXJrKXQuaGlnaFdhdGVyTWFyaz1jb21wdXRlTmV3SGlnaFdhdGVyTWFyayhlKTtpZihlPD10Lmxlbmd0aClyZXR1cm4gZTtpZighdC5lbmRlZCl7dC5uZWVkUmVhZGFibGU9dHJ1ZTtyZXR1cm4gMH1yZXR1cm4gdC5sZW5ndGh9UmVhZGFibGUucHJvdG90eXBlLnJlYWQ9ZnVuY3Rpb24oZSl7dShcInJlYWRcIixlKTtlPXBhcnNlSW50KGUsMTApO3ZhciB0PXRoaXMuX3JlYWRhYmxlU3RhdGU7dmFyIHI9ZTtpZihlIT09MCl0LmVtaXR0ZWRSZWFkYWJsZT1mYWxzZTtpZihlPT09MCYmdC5uZWVkUmVhZGFibGUmJigodC5oaWdoV2F0ZXJNYXJrIT09MD90Lmxlbmd0aD49dC5oaWdoV2F0ZXJNYXJrOnQubGVuZ3RoPjApfHx0LmVuZGVkKSl7dShcInJlYWQ6IGVtaXRSZWFkYWJsZVwiLHQubGVuZ3RoLHQuZW5kZWQpO2lmKHQubGVuZ3RoPT09MCYmdC5lbmRlZCllbmRSZWFkYWJsZSh0aGlzKTtlbHNlIGVtaXRSZWFkYWJsZSh0aGlzKTtyZXR1cm4gbnVsbH1lPWhvd011Y2hUb1JlYWQoZSx0KTtpZihlPT09MCYmdC5lbmRlZCl7aWYodC5sZW5ndGg9PT0wKWVuZFJlYWRhYmxlKHRoaXMpO3JldHVybiBudWxsfXZhciBuPXQubmVlZFJlYWRhYmxlO3UoXCJuZWVkIHJlYWRhYmxlXCIsbik7aWYodC5sZW5ndGg9PT0wfHx0Lmxlbmd0aC1lPHQuaGlnaFdhdGVyTWFyayl7bj10cnVlO3UoXCJsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFya1wiLG4pfWlmKHQuZW5kZWR8fHQucmVhZGluZyl7bj1mYWxzZTt1KFwicmVhZGluZyBvciBlbmRlZFwiLG4pfWVsc2UgaWYobil7dShcImRvIHJlYWRcIik7dC5yZWFkaW5nPXRydWU7dC5zeW5jPXRydWU7aWYodC5sZW5ndGg9PT0wKXQubmVlZFJlYWRhYmxlPXRydWU7dGhpcy5fcmVhZCh0LmhpZ2hXYXRlck1hcmspO3Quc3luYz1mYWxzZTtpZighdC5yZWFkaW5nKWU9aG93TXVjaFRvUmVhZChyLHQpfXZhciBpO2lmKGU+MClpPWZyb21MaXN0KGUsdCk7ZWxzZSBpPW51bGw7aWYoaT09PW51bGwpe3QubmVlZFJlYWRhYmxlPXQubGVuZ3RoPD10LmhpZ2hXYXRlck1hcms7ZT0wfWVsc2V7dC5sZW5ndGgtPWU7dC5hd2FpdERyYWluPTB9aWYodC5sZW5ndGg9PT0wKXtpZighdC5lbmRlZCl0Lm5lZWRSZWFkYWJsZT10cnVlO2lmKHIhPT1lJiZ0LmVuZGVkKWVuZFJlYWRhYmxlKHRoaXMpfWlmKGkhPT1udWxsKXRoaXMuZW1pdChcImRhdGFcIixpKTtyZXR1cm4gaX07ZnVuY3Rpb24gb25Fb2ZDaHVuayhlLHQpe3UoXCJvbkVvZkNodW5rXCIpO2lmKHQuZW5kZWQpcmV0dXJuO2lmKHQuZGVjb2Rlcil7dmFyIHI9dC5kZWNvZGVyLmVuZCgpO2lmKHImJnIubGVuZ3RoKXt0LmJ1ZmZlci5wdXNoKHIpO3QubGVuZ3RoKz10Lm9iamVjdE1vZGU/MTpyLmxlbmd0aH19dC5lbmRlZD10cnVlO2lmKHQuc3luYyl7ZW1pdFJlYWRhYmxlKGUpfWVsc2V7dC5uZWVkUmVhZGFibGU9ZmFsc2U7aWYoIXQuZW1pdHRlZFJlYWRhYmxlKXt0LmVtaXR0ZWRSZWFkYWJsZT10cnVlO2VtaXRSZWFkYWJsZV8oZSl9fX1mdW5jdGlvbiBlbWl0UmVhZGFibGUoZSl7dmFyIHQ9ZS5fcmVhZGFibGVTdGF0ZTt1KFwiZW1pdFJlYWRhYmxlXCIsdC5uZWVkUmVhZGFibGUsdC5lbWl0dGVkUmVhZGFibGUpO3QubmVlZFJlYWRhYmxlPWZhbHNlO2lmKCF0LmVtaXR0ZWRSZWFkYWJsZSl7dShcImVtaXRSZWFkYWJsZVwiLHQuZmxvd2luZyk7dC5lbWl0dGVkUmVhZGFibGU9dHJ1ZTtwcm9jZXNzLm5leHRUaWNrKGVtaXRSZWFkYWJsZV8sZSl9fWZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oZSl7dmFyIHQ9ZS5fcmVhZGFibGVTdGF0ZTt1KFwiZW1pdFJlYWRhYmxlX1wiLHQuZGVzdHJveWVkLHQubGVuZ3RoLHQuZW5kZWQpO2lmKCF0LmRlc3Ryb3llZCYmKHQubGVuZ3RofHx0LmVuZGVkKSl7ZS5lbWl0KFwicmVhZGFibGVcIik7dC5lbWl0dGVkUmVhZGFibGU9ZmFsc2V9dC5uZWVkUmVhZGFibGU9IXQuZmxvd2luZyYmIXQuZW5kZWQmJnQubGVuZ3RoPD10LmhpZ2hXYXRlck1hcms7ZmxvdyhlKX1mdW5jdGlvbiBtYXliZVJlYWRNb3JlKGUsdCl7aWYoIXQucmVhZGluZ01vcmUpe3QucmVhZGluZ01vcmU9dHJ1ZTtwcm9jZXNzLm5leHRUaWNrKG1heWJlUmVhZE1vcmVfLGUsdCl9fWZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKGUsdCl7d2hpbGUoIXQucmVhZGluZyYmIXQuZW5kZWQmJih0Lmxlbmd0aDx0LmhpZ2hXYXRlck1hcmt8fHQuZmxvd2luZyYmdC5sZW5ndGg9PT0wKSl7dmFyIHI9dC5sZW5ndGg7dShcIm1heWJlUmVhZE1vcmUgcmVhZCAwXCIpO2UucmVhZCgwKTtpZihyPT09dC5sZW5ndGgpYnJlYWt9dC5yZWFkaW5nTW9yZT1mYWxzZX1SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQ9ZnVuY3Rpb24oZSl7Uih0aGlzLG5ldyBfKFwiX3JlYWQoKVwiKSl9O1JlYWRhYmxlLnByb3RvdHlwZS5waXBlPWZ1bmN0aW9uKGUsdCl7dmFyIHI9dGhpczt2YXIgbj10aGlzLl9yZWFkYWJsZVN0YXRlO3N3aXRjaChuLnBpcGVzQ291bnQpe2Nhc2UgMDpuLnBpcGVzPWU7YnJlYWs7Y2FzZSAxOm4ucGlwZXM9W24ucGlwZXMsZV07YnJlYWs7ZGVmYXVsdDpuLnBpcGVzLnB1c2goZSk7YnJlYWt9bi5waXBlc0NvdW50Kz0xO3UoXCJwaXBlIGNvdW50PSVkIG9wdHM9JWpcIixuLnBpcGVzQ291bnQsdCk7dmFyIGk9KCF0fHx0LmVuZCE9PWZhbHNlKSYmZSE9PXByb2Nlc3Muc3Rkb3V0JiZlIT09cHJvY2Vzcy5zdGRlcnI7dmFyIG89aT9vbmVuZDp1bnBpcGU7aWYobi5lbmRFbWl0dGVkKXByb2Nlc3MubmV4dFRpY2sobyk7ZWxzZSByLm9uY2UoXCJlbmRcIixvKTtlLm9uKFwidW5waXBlXCIsb251bnBpcGUpO2Z1bmN0aW9uIG9udW5waXBlKGUsdCl7dShcIm9udW5waXBlXCIpO2lmKGU9PT1yKXtpZih0JiZ0Lmhhc1VucGlwZWQ9PT1mYWxzZSl7dC5oYXNVbnBpcGVkPXRydWU7Y2xlYW51cCgpfX19ZnVuY3Rpb24gb25lbmQoKXt1KFwib25lbmRcIik7ZS5lbmQoKX12YXIgcz1waXBlT25EcmFpbihyKTtlLm9uKFwiZHJhaW5cIixzKTt2YXIgZj1mYWxzZTtmdW5jdGlvbiBjbGVhbnVwKCl7dShcImNsZWFudXBcIik7ZS5yZW1vdmVMaXN0ZW5lcihcImNsb3NlXCIsb25jbG9zZSk7ZS5yZW1vdmVMaXN0ZW5lcihcImZpbmlzaFwiLG9uZmluaXNoKTtlLnJlbW92ZUxpc3RlbmVyKFwiZHJhaW5cIixzKTtlLnJlbW92ZUxpc3RlbmVyKFwiZXJyb3JcIixvbmVycm9yKTtlLnJlbW92ZUxpc3RlbmVyKFwidW5waXBlXCIsb251bnBpcGUpO3IucmVtb3ZlTGlzdGVuZXIoXCJlbmRcIixvbmVuZCk7ci5yZW1vdmVMaXN0ZW5lcihcImVuZFwiLHVucGlwZSk7ci5yZW1vdmVMaXN0ZW5lcihcImRhdGFcIixvbmRhdGEpO2Y9dHJ1ZTtpZihuLmF3YWl0RHJhaW4mJighZS5fd3JpdGFibGVTdGF0ZXx8ZS5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKXMoKX1yLm9uKFwiZGF0YVwiLG9uZGF0YSk7ZnVuY3Rpb24gb25kYXRhKHQpe3UoXCJvbmRhdGFcIik7dmFyIGk9ZS53cml0ZSh0KTt1KFwiZGVzdC53cml0ZVwiLGkpO2lmKGk9PT1mYWxzZSl7aWYoKG4ucGlwZXNDb3VudD09PTEmJm4ucGlwZXM9PT1lfHxuLnBpcGVzQ291bnQ+MSYmaW5kZXhPZihuLnBpcGVzLGUpIT09LTEpJiYhZil7dShcImZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZVwiLG4uYXdhaXREcmFpbik7bi5hd2FpdERyYWluKyt9ci5wYXVzZSgpfX1mdW5jdGlvbiBvbmVycm9yKHQpe3UoXCJvbmVycm9yXCIsdCk7dW5waXBlKCk7ZS5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsb25lcnJvcik7aWYoYShlLFwiZXJyb3JcIik9PT0wKVIoZSx0KX1wcmVwZW5kTGlzdGVuZXIoZSxcImVycm9yXCIsb25lcnJvcik7ZnVuY3Rpb24gb25jbG9zZSgpe2UucmVtb3ZlTGlzdGVuZXIoXCJmaW5pc2hcIixvbmZpbmlzaCk7dW5waXBlKCl9ZS5vbmNlKFwiY2xvc2VcIixvbmNsb3NlKTtmdW5jdGlvbiBvbmZpbmlzaCgpe3UoXCJvbmZpbmlzaFwiKTtlLnJlbW92ZUxpc3RlbmVyKFwiY2xvc2VcIixvbmNsb3NlKTt1bnBpcGUoKX1lLm9uY2UoXCJmaW5pc2hcIixvbmZpbmlzaCk7ZnVuY3Rpb24gdW5waXBlKCl7dShcInVucGlwZVwiKTtyLnVucGlwZShlKX1lLmVtaXQoXCJwaXBlXCIscik7aWYoIW4uZmxvd2luZyl7dShcInBpcGUgcmVzdW1lXCIpO3IucmVzdW1lKCl9cmV0dXJuIGV9O2Z1bmN0aW9uIHBpcGVPbkRyYWluKGUpe3JldHVybiBmdW5jdGlvbiBwaXBlT25EcmFpbkZ1bmN0aW9uUmVzdWx0KCl7dmFyIHQ9ZS5fcmVhZGFibGVTdGF0ZTt1KFwicGlwZU9uRHJhaW5cIix0LmF3YWl0RHJhaW4pO2lmKHQuYXdhaXREcmFpbil0LmF3YWl0RHJhaW4tLTtpZih0LmF3YWl0RHJhaW49PT0wJiZhKGUsXCJkYXRhXCIpKXt0LmZsb3dpbmc9dHJ1ZTtmbG93KGUpfX19UmVhZGFibGUucHJvdG90eXBlLnVucGlwZT1mdW5jdGlvbihlKXt2YXIgdD10aGlzLl9yZWFkYWJsZVN0YXRlO3ZhciByPXtoYXNVbnBpcGVkOmZhbHNlfTtpZih0LnBpcGVzQ291bnQ9PT0wKXJldHVybiB0aGlzO2lmKHQucGlwZXNDb3VudD09PTEpe2lmKGUmJmUhPT10LnBpcGVzKXJldHVybiB0aGlzO2lmKCFlKWU9dC5waXBlczt0LnBpcGVzPW51bGw7dC5waXBlc0NvdW50PTA7dC5mbG93aW5nPWZhbHNlO2lmKGUpZS5lbWl0KFwidW5waXBlXCIsdGhpcyxyKTtyZXR1cm4gdGhpc31pZighZSl7dmFyIG49dC5waXBlczt2YXIgaT10LnBpcGVzQ291bnQ7dC5waXBlcz1udWxsO3QucGlwZXNDb3VudD0wO3QuZmxvd2luZz1mYWxzZTtmb3IodmFyIGE9MDthPGk7YSsrKXtuW2FdLmVtaXQoXCJ1bnBpcGVcIix0aGlzLHtoYXNVbnBpcGVkOmZhbHNlfSl9cmV0dXJuIHRoaXN9dmFyIG89aW5kZXhPZih0LnBpcGVzLGUpO2lmKG89PT0tMSlyZXR1cm4gdGhpczt0LnBpcGVzLnNwbGljZShvLDEpO3QucGlwZXNDb3VudC09MTtpZih0LnBpcGVzQ291bnQ9PT0xKXQucGlwZXM9dC5waXBlc1swXTtlLmVtaXQoXCJ1bnBpcGVcIix0aGlzLHIpO3JldHVybiB0aGlzfTtSZWFkYWJsZS5wcm90b3R5cGUub249ZnVuY3Rpb24oZSx0KXt2YXIgcj1vLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsZSx0KTt2YXIgbj10aGlzLl9yZWFkYWJsZVN0YXRlO2lmKGU9PT1cImRhdGFcIil7bi5yZWFkYWJsZUxpc3RlbmluZz10aGlzLmxpc3RlbmVyQ291bnQoXCJyZWFkYWJsZVwiKT4wO2lmKG4uZmxvd2luZyE9PWZhbHNlKXRoaXMucmVzdW1lKCl9ZWxzZSBpZihlPT09XCJyZWFkYWJsZVwiKXtpZighbi5lbmRFbWl0dGVkJiYhbi5yZWFkYWJsZUxpc3RlbmluZyl7bi5yZWFkYWJsZUxpc3RlbmluZz1uLm5lZWRSZWFkYWJsZT10cnVlO24uZmxvd2luZz1mYWxzZTtuLmVtaXR0ZWRSZWFkYWJsZT1mYWxzZTt1KFwib24gcmVhZGFibGVcIixuLmxlbmd0aCxuLnJlYWRpbmcpO2lmKG4ubGVuZ3RoKXtlbWl0UmVhZGFibGUodGhpcyl9ZWxzZSBpZighbi5yZWFkaW5nKXtwcm9jZXNzLm5leHRUaWNrKG5SZWFkaW5nTmV4dFRpY2ssdGhpcyl9fX1yZXR1cm4gcn07UmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyPVJlYWRhYmxlLnByb3RvdHlwZS5vbjtSZWFkYWJsZS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI9ZnVuY3Rpb24oZSx0KXt2YXIgcj1vLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lci5jYWxsKHRoaXMsZSx0KTtpZihlPT09XCJyZWFkYWJsZVwiKXtwcm9jZXNzLm5leHRUaWNrKHVwZGF0ZVJlYWRhYmxlTGlzdGVuaW5nLHRoaXMpfXJldHVybiByfTtSZWFkYWJsZS5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzPWZ1bmN0aW9uKGUpe3ZhciB0PW8ucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycy5hcHBseSh0aGlzLGFyZ3VtZW50cyk7aWYoZT09PVwicmVhZGFibGVcInx8ZT09PXVuZGVmaW5lZCl7cHJvY2Vzcy5uZXh0VGljayh1cGRhdGVSZWFkYWJsZUxpc3RlbmluZyx0aGlzKX1yZXR1cm4gdH07ZnVuY3Rpb24gdXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcoZSl7dmFyIHQ9ZS5fcmVhZGFibGVTdGF0ZTt0LnJlYWRhYmxlTGlzdGVuaW5nPWUubGlzdGVuZXJDb3VudChcInJlYWRhYmxlXCIpPjA7aWYodC5yZXN1bWVTY2hlZHVsZWQmJiF0LnBhdXNlZCl7dC5mbG93aW5nPXRydWV9ZWxzZSBpZihlLmxpc3RlbmVyQ291bnQoXCJkYXRhXCIpPjApe2UucmVzdW1lKCl9fWZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soZSl7dShcInJlYWRhYmxlIG5leHR0aWNrIHJlYWQgMFwiKTtlLnJlYWQoMCl9UmVhZGFibGUucHJvdG90eXBlLnJlc3VtZT1mdW5jdGlvbigpe3ZhciBlPXRoaXMuX3JlYWRhYmxlU3RhdGU7aWYoIWUuZmxvd2luZyl7dShcInJlc3VtZVwiKTtlLmZsb3dpbmc9IWUucmVhZGFibGVMaXN0ZW5pbmc7cmVzdW1lKHRoaXMsZSl9ZS5wYXVzZWQ9ZmFsc2U7cmV0dXJuIHRoaXN9O2Z1bmN0aW9uIHJlc3VtZShlLHQpe2lmKCF0LnJlc3VtZVNjaGVkdWxlZCl7dC5yZXN1bWVTY2hlZHVsZWQ9dHJ1ZTtwcm9jZXNzLm5leHRUaWNrKHJlc3VtZV8sZSx0KX19ZnVuY3Rpb24gcmVzdW1lXyhlLHQpe3UoXCJyZXN1bWVcIix0LnJlYWRpbmcpO2lmKCF0LnJlYWRpbmcpe2UucmVhZCgwKX10LnJlc3VtZVNjaGVkdWxlZD1mYWxzZTtlLmVtaXQoXCJyZXN1bWVcIik7ZmxvdyhlKTtpZih0LmZsb3dpbmcmJiF0LnJlYWRpbmcpZS5yZWFkKDApfVJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZT1mdW5jdGlvbigpe3UoXCJjYWxsIHBhdXNlIGZsb3dpbmc9JWpcIix0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO2lmKHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyE9PWZhbHNlKXt1KFwicGF1c2VcIik7dGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nPWZhbHNlO3RoaXMuZW1pdChcInBhdXNlXCIpfXRoaXMuX3JlYWRhYmxlU3RhdGUucGF1c2VkPXRydWU7cmV0dXJuIHRoaXN9O2Z1bmN0aW9uIGZsb3coZSl7dmFyIHQ9ZS5fcmVhZGFibGVTdGF0ZTt1KFwiZmxvd1wiLHQuZmxvd2luZyk7d2hpbGUodC5mbG93aW5nJiZlLnJlYWQoKSE9PW51bGwpe319UmVhZGFibGUucHJvdG90eXBlLndyYXA9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpczt2YXIgcj10aGlzLl9yZWFkYWJsZVN0YXRlO3ZhciBuPWZhbHNlO2Uub24oXCJlbmRcIiwoZnVuY3Rpb24oKXt1KFwid3JhcHBlZCBlbmRcIik7aWYoci5kZWNvZGVyJiYhci5lbmRlZCl7dmFyIGU9ci5kZWNvZGVyLmVuZCgpO2lmKGUmJmUubGVuZ3RoKXQucHVzaChlKX10LnB1c2gobnVsbCl9KSk7ZS5vbihcImRhdGFcIiwoZnVuY3Rpb24oaSl7dShcIndyYXBwZWQgZGF0YVwiKTtpZihyLmRlY29kZXIpaT1yLmRlY29kZXIud3JpdGUoaSk7aWYoci5vYmplY3RNb2RlJiYoaT09PW51bGx8fGk9PT11bmRlZmluZWQpKXJldHVybjtlbHNlIGlmKCFyLm9iamVjdE1vZGUmJighaXx8IWkubGVuZ3RoKSlyZXR1cm47dmFyIGE9dC5wdXNoKGkpO2lmKCFhKXtuPXRydWU7ZS5wYXVzZSgpfX0pKTtmb3IodmFyIGkgaW4gZSl7aWYodGhpc1tpXT09PXVuZGVmaW5lZCYmdHlwZW9mIGVbaV09PT1cImZ1bmN0aW9uXCIpe3RoaXNbaV09ZnVuY3Rpb24gbWV0aG9kV3JhcCh0KXtyZXR1cm4gZnVuY3Rpb24gbWV0aG9kV3JhcFJldHVybkZ1bmN0aW9uKCl7cmV0dXJuIGVbdF0uYXBwbHkoZSxhcmd1bWVudHMpfX0oaSl9fWZvcih2YXIgYT0wO2E8RS5sZW5ndGg7YSsrKXtlLm9uKEVbYV0sdGhpcy5lbWl0LmJpbmQodGhpcyxFW2FdKSl9dGhpcy5fcmVhZD1mdW5jdGlvbih0KXt1KFwid3JhcHBlZCBfcmVhZFwiLHQpO2lmKG4pe249ZmFsc2U7ZS5yZXN1bWUoKX19O3JldHVybiB0aGlzfTtpZih0eXBlb2YgU3ltYm9sPT09XCJmdW5jdGlvblwiKXtSZWFkYWJsZS5wcm90b3R5cGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdPWZ1bmN0aW9uKCl7aWYobT09PXVuZGVmaW5lZCl7bT1yKDc3MSl9cmV0dXJuIG0odGhpcyl9fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsXCJyZWFkYWJsZUhpZ2hXYXRlck1hcmtcIix7ZW51bWVyYWJsZTpmYWxzZSxnZXQ6ZnVuY3Rpb24gZ2V0KCl7cmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuaGlnaFdhdGVyTWFya319KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLFwicmVhZGFibGVCdWZmZXJcIix7ZW51bWVyYWJsZTpmYWxzZSxnZXQ6ZnVuY3Rpb24gZ2V0KCl7cmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUmJnRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyfX0pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsXCJyZWFkYWJsZUZsb3dpbmdcIix7ZW51bWVyYWJsZTpmYWxzZSxnZXQ6ZnVuY3Rpb24gZ2V0KCl7cmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZ30sc2V0OmZ1bmN0aW9uIHNldChlKXtpZih0aGlzLl9yZWFkYWJsZVN0YXRlKXt0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmc9ZX19fSk7UmVhZGFibGUuX2Zyb21MaXN0PWZyb21MaXN0O09iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsXCJyZWFkYWJsZUxlbmd0aFwiLHtlbnVtZXJhYmxlOmZhbHNlLGdldDpmdW5jdGlvbiBnZXQoKXtyZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5sZW5ndGh9fSk7ZnVuY3Rpb24gZnJvbUxpc3QoZSx0KXtpZih0Lmxlbmd0aD09PTApcmV0dXJuIG51bGw7dmFyIHI7aWYodC5vYmplY3RNb2RlKXI9dC5idWZmZXIuc2hpZnQoKTtlbHNlIGlmKCFlfHxlPj10Lmxlbmd0aCl7aWYodC5kZWNvZGVyKXI9dC5idWZmZXIuam9pbihcIlwiKTtlbHNlIGlmKHQuYnVmZmVyLmxlbmd0aD09PTEpcj10LmJ1ZmZlci5maXJzdCgpO2Vsc2Ugcj10LmJ1ZmZlci5jb25jYXQodC5sZW5ndGgpO3QuYnVmZmVyLmNsZWFyKCl9ZWxzZXtyPXQuYnVmZmVyLmNvbnN1bWUoZSx0LmRlY29kZXIpfXJldHVybiByfWZ1bmN0aW9uIGVuZFJlYWRhYmxlKGUpe3ZhciB0PWUuX3JlYWRhYmxlU3RhdGU7dShcImVuZFJlYWRhYmxlXCIsdC5lbmRFbWl0dGVkKTtpZighdC5lbmRFbWl0dGVkKXt0LmVuZGVkPXRydWU7cHJvY2Vzcy5uZXh0VGljayhlbmRSZWFkYWJsZU5ULHQsZSl9fWZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoZSx0KXt1KFwiZW5kUmVhZGFibGVOVFwiLGUuZW5kRW1pdHRlZCxlLmxlbmd0aCk7aWYoIWUuZW5kRW1pdHRlZCYmZS5sZW5ndGg9PT0wKXtlLmVuZEVtaXR0ZWQ9dHJ1ZTt0LnJlYWRhYmxlPWZhbHNlO3QuZW1pdChcImVuZFwiKTtpZihlLmF1dG9EZXN0cm95KXt2YXIgcj10Ll93cml0YWJsZVN0YXRlO2lmKCFyfHxyLmF1dG9EZXN0cm95JiZyLmZpbmlzaGVkKXt0LmRlc3Ryb3koKX19fX1pZih0eXBlb2YgU3ltYm9sPT09XCJmdW5jdGlvblwiKXtSZWFkYWJsZS5mcm9tPWZ1bmN0aW9uKGUsdCl7aWYoUz09PXVuZGVmaW5lZCl7Uz1yKDE2KX1yZXR1cm4gUyhSZWFkYWJsZSxlLHQpfX1mdW5jdGlvbiBpbmRleE9mKGUsdCl7Zm9yKHZhciByPTAsbj1lLmxlbmd0aDtyPG47cisrKXtpZihlW3JdPT09dClyZXR1cm4gcn1yZXR1cm4tMX19LDc4NjpmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPVRyYW5zZm9ybTt2YXIgbj1yKDgzMykucSxpPW4uRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQsYT1uLkVSUl9NVUxUSVBMRV9DQUxMQkFDSyxvPW4uRVJSX1RSQU5TRk9STV9BTFJFQURZX1RSQU5TRk9STUlORyxzPW4uRVJSX1RSQU5TRk9STV9XSVRIX0xFTkdUSF8wO3ZhciBmPXIoMjM5KTtyKDUyNikoVHJhbnNmb3JtLGYpO2Z1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKGUsdCl7dmFyIHI9dGhpcy5fdHJhbnNmb3JtU3RhdGU7ci50cmFuc2Zvcm1pbmc9ZmFsc2U7dmFyIG49ci53cml0ZWNiO2lmKG49PT1udWxsKXtyZXR1cm4gdGhpcy5lbWl0KFwiZXJyb3JcIixuZXcgYSl9ci53cml0ZWNodW5rPW51bGw7ci53cml0ZWNiPW51bGw7aWYodCE9bnVsbCl0aGlzLnB1c2godCk7bihlKTt2YXIgaT10aGlzLl9yZWFkYWJsZVN0YXRlO2kucmVhZGluZz1mYWxzZTtpZihpLm5lZWRSZWFkYWJsZXx8aS5sZW5ndGg8aS5oaWdoV2F0ZXJNYXJrKXt0aGlzLl9yZWFkKGkuaGlnaFdhdGVyTWFyayl9fWZ1bmN0aW9uIFRyYW5zZm9ybShlKXtpZighKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKXJldHVybiBuZXcgVHJhbnNmb3JtKGUpO2YuY2FsbCh0aGlzLGUpO3RoaXMuX3RyYW5zZm9ybVN0YXRlPXthZnRlclRyYW5zZm9ybTphZnRlclRyYW5zZm9ybS5iaW5kKHRoaXMpLG5lZWRUcmFuc2Zvcm06ZmFsc2UsdHJhbnNmb3JtaW5nOmZhbHNlLHdyaXRlY2I6bnVsbCx3cml0ZWNodW5rOm51bGwsd3JpdGVlbmNvZGluZzpudWxsfTt0aGlzLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZT10cnVlO3RoaXMuX3JlYWRhYmxlU3RhdGUuc3luYz1mYWxzZTtpZihlKXtpZih0eXBlb2YgZS50cmFuc2Zvcm09PT1cImZ1bmN0aW9uXCIpdGhpcy5fdHJhbnNmb3JtPWUudHJhbnNmb3JtO2lmKHR5cGVvZiBlLmZsdXNoPT09XCJmdW5jdGlvblwiKXRoaXMuX2ZsdXNoPWUuZmx1c2h9dGhpcy5vbihcInByZWZpbmlzaFwiLHByZWZpbmlzaCl9ZnVuY3Rpb24gcHJlZmluaXNoKCl7dmFyIGU9dGhpcztpZih0eXBlb2YgdGhpcy5fZmx1c2g9PT1cImZ1bmN0aW9uXCImJiF0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCl7dGhpcy5fZmx1c2goKGZ1bmN0aW9uKHQscil7ZG9uZShlLHQscil9KSl9ZWxzZXtkb25lKHRoaXMsbnVsbCxudWxsKX19VHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKGUsdCl7dGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybT1mYWxzZTtyZXR1cm4gZi5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsZSx0KX07VHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtPWZ1bmN0aW9uKGUsdCxyKXtyKG5ldyBpKFwiX3RyYW5zZm9ybSgpXCIpKX07VHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGU9ZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXRoaXMuX3RyYW5zZm9ybVN0YXRlO24ud3JpdGVjYj1yO24ud3JpdGVjaHVuaz1lO24ud3JpdGVlbmNvZGluZz10O2lmKCFuLnRyYW5zZm9ybWluZyl7dmFyIGk9dGhpcy5fcmVhZGFibGVTdGF0ZTtpZihuLm5lZWRUcmFuc2Zvcm18fGkubmVlZFJlYWRhYmxlfHxpLmxlbmd0aDxpLmhpZ2hXYXRlck1hcmspdGhpcy5fcmVhZChpLmhpZ2hXYXRlck1hcmspfX07VHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZD1mdW5jdGlvbihlKXt2YXIgdD10aGlzLl90cmFuc2Zvcm1TdGF0ZTtpZih0LndyaXRlY2h1bmshPT1udWxsJiYhdC50cmFuc2Zvcm1pbmcpe3QudHJhbnNmb3JtaW5nPXRydWU7dGhpcy5fdHJhbnNmb3JtKHQud3JpdGVjaHVuayx0LndyaXRlZW5jb2RpbmcsdC5hZnRlclRyYW5zZm9ybSl9ZWxzZXt0Lm5lZWRUcmFuc2Zvcm09dHJ1ZX19O1RyYW5zZm9ybS5wcm90b3R5cGUuX2Rlc3Ryb3k9ZnVuY3Rpb24oZSx0KXtmLnByb3RvdHlwZS5fZGVzdHJveS5jYWxsKHRoaXMsZSwoZnVuY3Rpb24oZSl7dChlKX0pKX07ZnVuY3Rpb24gZG9uZShlLHQscil7aWYodClyZXR1cm4gZS5lbWl0KFwiZXJyb3JcIix0KTtpZihyIT1udWxsKWUucHVzaChyKTtpZihlLl93cml0YWJsZVN0YXRlLmxlbmd0aCl0aHJvdyBuZXcgcztpZihlLl90cmFuc2Zvcm1TdGF0ZS50cmFuc2Zvcm1pbmcpdGhyb3cgbmV3IG87cmV0dXJuIGUucHVzaChudWxsKX19LDg4NjpmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPVdyaXRhYmxlO2Z1bmN0aW9uIFdyaXRlUmVxKGUsdCxyKXt0aGlzLmNodW5rPWU7dGhpcy5lbmNvZGluZz10O3RoaXMuY2FsbGJhY2s9cjt0aGlzLm5leHQ9bnVsbH1mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KGUpe3ZhciB0PXRoaXM7dGhpcy5uZXh0PW51bGw7dGhpcy5lbnRyeT1udWxsO3RoaXMuZmluaXNoPWZ1bmN0aW9uKCl7b25Db3JrZWRGaW5pc2godCxlKX19dmFyIG47V3JpdGFibGUuV3JpdGFibGVTdGF0ZT1Xcml0YWJsZVN0YXRlO3ZhciBpPXtkZXByZWNhdGU6cigxMjEpfTt2YXIgYT1yKDkxOSk7dmFyIG89cigzMDApLkJ1ZmZlcjt2YXIgcz1nbG9iYWwuVWludDhBcnJheXx8ZnVuY3Rpb24oKXt9O2Z1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoZSl7cmV0dXJuIG8uZnJvbShlKX1mdW5jdGlvbiBfaXNVaW50OEFycmF5KGUpe3JldHVybiBvLmlzQnVmZmVyKGUpfHxlIGluc3RhbmNlb2Ygc312YXIgZj1yKDM2NCk7dmFyIGw9cigzMjIpLHU9bC5nZXRIaWdoV2F0ZXJNYXJrO3ZhciBkPXIoODMzKS5xLGM9ZC5FUlJfSU5WQUxJRF9BUkdfVFlQRSxoPWQuRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQscD1kLkVSUl9NVUxUSVBMRV9DQUxMQkFDSyxiPWQuRVJSX1NUUkVBTV9DQU5OT1RfUElQRSxnPWQuRVJSX1NUUkVBTV9ERVNUUk9ZRUQseT1kLkVSUl9TVFJFQU1fTlVMTF9WQUxVRVMsXz1kLkVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5ELHY9ZC5FUlJfVU5LTk9XTl9FTkNPRElORzt2YXIgdz1mLmVycm9yT3JEZXN0cm95O3IoNTI2KShXcml0YWJsZSxhKTtmdW5jdGlvbiBub3AoKXt9ZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShlLHQsaSl7bj1ufHxyKDIzOSk7ZT1lfHx7fTtpZih0eXBlb2YgaSE9PVwiYm9vbGVhblwiKWk9dCBpbnN0YW5jZW9mIG47dGhpcy5vYmplY3RNb2RlPSEhZS5vYmplY3RNb2RlO2lmKGkpdGhpcy5vYmplY3RNb2RlPXRoaXMub2JqZWN0TW9kZXx8ISFlLndyaXRhYmxlT2JqZWN0TW9kZTt0aGlzLmhpZ2hXYXRlck1hcms9dSh0aGlzLGUsXCJ3cml0YWJsZUhpZ2hXYXRlck1hcmtcIixpKTt0aGlzLmZpbmFsQ2FsbGVkPWZhbHNlO3RoaXMubmVlZERyYWluPWZhbHNlO3RoaXMuZW5kaW5nPWZhbHNlO3RoaXMuZW5kZWQ9ZmFsc2U7dGhpcy5maW5pc2hlZD1mYWxzZTt0aGlzLmRlc3Ryb3llZD1mYWxzZTt2YXIgYT1lLmRlY29kZVN0cmluZ3M9PT1mYWxzZTt0aGlzLmRlY29kZVN0cmluZ3M9IWE7dGhpcy5kZWZhdWx0RW5jb2Rpbmc9ZS5kZWZhdWx0RW5jb2Rpbmd8fFwidXRmOFwiO3RoaXMubGVuZ3RoPTA7dGhpcy53cml0aW5nPWZhbHNlO3RoaXMuY29ya2VkPTA7dGhpcy5zeW5jPXRydWU7dGhpcy5idWZmZXJQcm9jZXNzaW5nPWZhbHNlO3RoaXMub253cml0ZT1mdW5jdGlvbihlKXtvbndyaXRlKHQsZSl9O3RoaXMud3JpdGVjYj1udWxsO3RoaXMud3JpdGVsZW49MDt0aGlzLmJ1ZmZlcmVkUmVxdWVzdD1udWxsO3RoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdD1udWxsO3RoaXMucGVuZGluZ2NiPTA7dGhpcy5wcmVmaW5pc2hlZD1mYWxzZTt0aGlzLmVycm9yRW1pdHRlZD1mYWxzZTt0aGlzLmVtaXRDbG9zZT1lLmVtaXRDbG9zZSE9PWZhbHNlO3RoaXMuYXV0b0Rlc3Ryb3k9ISFlLmF1dG9EZXN0cm95O3RoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQ9MDt0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZT1uZXcgQ29ya2VkUmVxdWVzdCh0aGlzKX1Xcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXI9ZnVuY3Rpb24gZ2V0QnVmZmVyKCl7dmFyIGU9dGhpcy5idWZmZXJlZFJlcXVlc3Q7dmFyIHQ9W107d2hpbGUoZSl7dC5wdXNoKGUpO2U9ZS5uZXh0fXJldHVybiB0fTsoZnVuY3Rpb24oKXt0cnl7T2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RhdGUucHJvdG90eXBlLFwiYnVmZmVyXCIse2dldDppLmRlcHJlY2F0ZSgoZnVuY3Rpb24gd3JpdGFibGVTdGF0ZUJ1ZmZlckdldHRlcigpe3JldHVybiB0aGlzLmdldEJ1ZmZlcigpfSksXCJfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIF93cml0YWJsZVN0YXRlLmdldEJ1ZmZlciBcIitcImluc3RlYWQuXCIsXCJERVAwMDAzXCIpfSl9Y2F0Y2goZSl7fX0pKCk7dmFyIG07aWYodHlwZW9mIFN5bWJvbD09PVwiZnVuY3Rpb25cIiYmU3ltYm9sLmhhc0luc3RhbmNlJiZ0eXBlb2YgRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV09PT1cImZ1bmN0aW9uXCIpe209RnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV07T2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLFN5bWJvbC5oYXNJbnN0YW5jZSx7dmFsdWU6ZnVuY3Rpb24gdmFsdWUoZSl7aWYobS5jYWxsKHRoaXMsZSkpcmV0dXJuIHRydWU7aWYodGhpcyE9PVdyaXRhYmxlKXJldHVybiBmYWxzZTtyZXR1cm4gZSYmZS5fd3JpdGFibGVTdGF0ZSBpbnN0YW5jZW9mIFdyaXRhYmxlU3RhdGV9fSl9ZWxzZXttPWZ1bmN0aW9uIHJlYWxIYXNJbnN0YW5jZShlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIHRoaXN9fWZ1bmN0aW9uIFdyaXRhYmxlKGUpe249bnx8cigyMzkpO3ZhciB0PXRoaXMgaW5zdGFuY2VvZiBuO2lmKCF0JiYhbS5jYWxsKFdyaXRhYmxlLHRoaXMpKXJldHVybiBuZXcgV3JpdGFibGUoZSk7dGhpcy5fd3JpdGFibGVTdGF0ZT1uZXcgV3JpdGFibGVTdGF0ZShlLHRoaXMsdCk7dGhpcy53cml0YWJsZT10cnVlO2lmKGUpe2lmKHR5cGVvZiBlLndyaXRlPT09XCJmdW5jdGlvblwiKXRoaXMuX3dyaXRlPWUud3JpdGU7aWYodHlwZW9mIGUud3JpdGV2PT09XCJmdW5jdGlvblwiKXRoaXMuX3dyaXRldj1lLndyaXRldjtpZih0eXBlb2YgZS5kZXN0cm95PT09XCJmdW5jdGlvblwiKXRoaXMuX2Rlc3Ryb3k9ZS5kZXN0cm95O2lmKHR5cGVvZiBlLmZpbmFsPT09XCJmdW5jdGlvblwiKXRoaXMuX2ZpbmFsPWUuZmluYWx9YS5jYWxsKHRoaXMpfVdyaXRhYmxlLnByb3RvdHlwZS5waXBlPWZ1bmN0aW9uKCl7dyh0aGlzLG5ldyBiKX07ZnVuY3Rpb24gd3JpdGVBZnRlckVuZChlLHQpe3ZhciByPW5ldyBfO3coZSxyKTtwcm9jZXNzLm5leHRUaWNrKHQscil9ZnVuY3Rpb24gdmFsaWRDaHVuayhlLHQscixuKXt2YXIgaTtpZihyPT09bnVsbCl7aT1uZXcgeX1lbHNlIGlmKHR5cGVvZiByIT09XCJzdHJpbmdcIiYmIXQub2JqZWN0TW9kZSl7aT1uZXcgYyhcImNodW5rXCIsW1wic3RyaW5nXCIsXCJCdWZmZXJcIl0scil9aWYoaSl7dyhlLGkpO3Byb2Nlc3MubmV4dFRpY2sobixpKTtyZXR1cm4gZmFsc2V9cmV0dXJuIHRydWV9V3JpdGFibGUucHJvdG90eXBlLndyaXRlPWZ1bmN0aW9uKGUsdCxyKXt2YXIgbj10aGlzLl93cml0YWJsZVN0YXRlO3ZhciBpPWZhbHNlO3ZhciBhPSFuLm9iamVjdE1vZGUmJl9pc1VpbnQ4QXJyYXkoZSk7aWYoYSYmIW8uaXNCdWZmZXIoZSkpe2U9X3VpbnQ4QXJyYXlUb0J1ZmZlcihlKX1pZih0eXBlb2YgdD09PVwiZnVuY3Rpb25cIil7cj10O3Q9bnVsbH1pZihhKXQ9XCJidWZmZXJcIjtlbHNlIGlmKCF0KXQ9bi5kZWZhdWx0RW5jb2Rpbmc7aWYodHlwZW9mIHIhPT1cImZ1bmN0aW9uXCIpcj1ub3A7aWYobi5lbmRpbmcpd3JpdGVBZnRlckVuZCh0aGlzLHIpO2Vsc2UgaWYoYXx8dmFsaWRDaHVuayh0aGlzLG4sZSxyKSl7bi5wZW5kaW5nY2IrKztpPXdyaXRlT3JCdWZmZXIodGhpcyxuLGEsZSx0LHIpfXJldHVybiBpfTtXcml0YWJsZS5wcm90b3R5cGUuY29yaz1mdW5jdGlvbigpe3RoaXMuX3dyaXRhYmxlU3RhdGUuY29ya2VkKyt9O1dyaXRhYmxlLnByb3RvdHlwZS51bmNvcms9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLl93cml0YWJsZVN0YXRlO2lmKGUuY29ya2VkKXtlLmNvcmtlZC0tO2lmKCFlLndyaXRpbmcmJiFlLmNvcmtlZCYmIWUuYnVmZmVyUHJvY2Vzc2luZyYmZS5idWZmZXJlZFJlcXVlc3QpY2xlYXJCdWZmZXIodGhpcyxlKX19O1dyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2Rpbmc9ZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGUpe2lmKHR5cGVvZiBlPT09XCJzdHJpbmdcIillPWUudG9Mb3dlckNhc2UoKTtpZighKFtcImhleFwiLFwidXRmOFwiLFwidXRmLThcIixcImFzY2lpXCIsXCJiaW5hcnlcIixcImJhc2U2NFwiLFwidWNzMlwiLFwidWNzLTJcIixcInV0ZjE2bGVcIixcInV0Zi0xNmxlXCIsXCJyYXdcIl0uaW5kZXhPZigoZStcIlwiKS50b0xvd2VyQ2FzZSgpKT4tMSkpdGhyb3cgbmV3IHYoZSk7dGhpcy5fd3JpdGFibGVTdGF0ZS5kZWZhdWx0RW5jb2Rpbmc9ZTtyZXR1cm4gdGhpc307T2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSxcIndyaXRhYmxlQnVmZmVyXCIse2VudW1lcmFibGU6ZmFsc2UsZ2V0OmZ1bmN0aW9uIGdldCgpe3JldHVybiB0aGlzLl93cml0YWJsZVN0YXRlJiZ0aGlzLl93cml0YWJsZVN0YXRlLmdldEJ1ZmZlcigpfX0pO2Z1bmN0aW9uIGRlY29kZUNodW5rKGUsdCxyKXtpZighZS5vYmplY3RNb2RlJiZlLmRlY29kZVN0cmluZ3MhPT1mYWxzZSYmdHlwZW9mIHQ9PT1cInN0cmluZ1wiKXt0PW8uZnJvbSh0LHIpfXJldHVybiB0fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsXCJ3cml0YWJsZUhpZ2hXYXRlck1hcmtcIix7ZW51bWVyYWJsZTpmYWxzZSxnZXQ6ZnVuY3Rpb24gZ2V0KCl7cmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFya319KTtmdW5jdGlvbiB3cml0ZU9yQnVmZmVyKGUsdCxyLG4saSxhKXtpZighcil7dmFyIG89ZGVjb2RlQ2h1bmsodCxuLGkpO2lmKG4hPT1vKXtyPXRydWU7aT1cImJ1ZmZlclwiO249b319dmFyIHM9dC5vYmplY3RNb2RlPzE6bi5sZW5ndGg7dC5sZW5ndGgrPXM7dmFyIGY9dC5sZW5ndGg8dC5oaWdoV2F0ZXJNYXJrO2lmKCFmKXQubmVlZERyYWluPXRydWU7aWYodC53cml0aW5nfHx0LmNvcmtlZCl7dmFyIGw9dC5sYXN0QnVmZmVyZWRSZXF1ZXN0O3QubGFzdEJ1ZmZlcmVkUmVxdWVzdD17Y2h1bms6bixlbmNvZGluZzppLGlzQnVmOnIsY2FsbGJhY2s6YSxuZXh0Om51bGx9O2lmKGwpe2wubmV4dD10Lmxhc3RCdWZmZXJlZFJlcXVlc3R9ZWxzZXt0LmJ1ZmZlcmVkUmVxdWVzdD10Lmxhc3RCdWZmZXJlZFJlcXVlc3R9dC5idWZmZXJlZFJlcXVlc3RDb3VudCs9MX1lbHNle2RvV3JpdGUoZSx0LGZhbHNlLHMsbixpLGEpfXJldHVybiBmfWZ1bmN0aW9uIGRvV3JpdGUoZSx0LHIsbixpLGEsbyl7dC53cml0ZWxlbj1uO3Qud3JpdGVjYj1vO3Qud3JpdGluZz10cnVlO3Quc3luYz10cnVlO2lmKHQuZGVzdHJveWVkKXQub253cml0ZShuZXcgZyhcIndyaXRlXCIpKTtlbHNlIGlmKHIpZS5fd3JpdGV2KGksdC5vbndyaXRlKTtlbHNlIGUuX3dyaXRlKGksYSx0Lm9ud3JpdGUpO3Quc3luYz1mYWxzZX1mdW5jdGlvbiBvbndyaXRlRXJyb3IoZSx0LHIsbixpKXstLXQucGVuZGluZ2NiO2lmKHIpe3Byb2Nlc3MubmV4dFRpY2soaSxuKTtwcm9jZXNzLm5leHRUaWNrKGZpbmlzaE1heWJlLGUsdCk7ZS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQ9dHJ1ZTt3KGUsbil9ZWxzZXtpKG4pO2UuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkPXRydWU7dyhlLG4pO2ZpbmlzaE1heWJlKGUsdCl9fWZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShlKXtlLndyaXRpbmc9ZmFsc2U7ZS53cml0ZWNiPW51bGw7ZS5sZW5ndGgtPWUud3JpdGVsZW47ZS53cml0ZWxlbj0wfWZ1bmN0aW9uIG9ud3JpdGUoZSx0KXt2YXIgcj1lLl93cml0YWJsZVN0YXRlO3ZhciBuPXIuc3luYzt2YXIgaT1yLndyaXRlY2I7aWYodHlwZW9mIGkhPT1cImZ1bmN0aW9uXCIpdGhyb3cgbmV3IHA7b253cml0ZVN0YXRlVXBkYXRlKHIpO2lmKHQpb253cml0ZUVycm9yKGUscixuLHQsaSk7ZWxzZXt2YXIgYT1uZWVkRmluaXNoKHIpfHxlLmRlc3Ryb3llZDtpZighYSYmIXIuY29ya2VkJiYhci5idWZmZXJQcm9jZXNzaW5nJiZyLmJ1ZmZlcmVkUmVxdWVzdCl7Y2xlYXJCdWZmZXIoZSxyKX1pZihuKXtwcm9jZXNzLm5leHRUaWNrKGFmdGVyV3JpdGUsZSxyLGEsaSl9ZWxzZXthZnRlcldyaXRlKGUscixhLGkpfX19ZnVuY3Rpb24gYWZ0ZXJXcml0ZShlLHQscixuKXtpZighcilvbndyaXRlRHJhaW4oZSx0KTt0LnBlbmRpbmdjYi0tO24oKTtmaW5pc2hNYXliZShlLHQpfWZ1bmN0aW9uIG9ud3JpdGVEcmFpbihlLHQpe2lmKHQubGVuZ3RoPT09MCYmdC5uZWVkRHJhaW4pe3QubmVlZERyYWluPWZhbHNlO2UuZW1pdChcImRyYWluXCIpfX1mdW5jdGlvbiBjbGVhckJ1ZmZlcihlLHQpe3QuYnVmZmVyUHJvY2Vzc2luZz10cnVlO3ZhciByPXQuYnVmZmVyZWRSZXF1ZXN0O2lmKGUuX3dyaXRldiYmciYmci5uZXh0KXt2YXIgbj10LmJ1ZmZlcmVkUmVxdWVzdENvdW50O3ZhciBpPW5ldyBBcnJheShuKTt2YXIgYT10LmNvcmtlZFJlcXVlc3RzRnJlZTthLmVudHJ5PXI7dmFyIG89MDt2YXIgcz10cnVlO3doaWxlKHIpe2lbb109cjtpZighci5pc0J1ZilzPWZhbHNlO3I9ci5uZXh0O28rPTF9aS5hbGxCdWZmZXJzPXM7ZG9Xcml0ZShlLHQsdHJ1ZSx0Lmxlbmd0aCxpLFwiXCIsYS5maW5pc2gpO3QucGVuZGluZ2NiKys7dC5sYXN0QnVmZmVyZWRSZXF1ZXN0PW51bGw7aWYoYS5uZXh0KXt0LmNvcmtlZFJlcXVlc3RzRnJlZT1hLm5leHQ7YS5uZXh0PW51bGx9ZWxzZXt0LmNvcmtlZFJlcXVlc3RzRnJlZT1uZXcgQ29ya2VkUmVxdWVzdCh0KX10LmJ1ZmZlcmVkUmVxdWVzdENvdW50PTB9ZWxzZXt3aGlsZShyKXt2YXIgZj1yLmNodW5rO3ZhciBsPXIuZW5jb2Rpbmc7dmFyIHU9ci5jYWxsYmFjazt2YXIgZD10Lm9iamVjdE1vZGU/MTpmLmxlbmd0aDtkb1dyaXRlKGUsdCxmYWxzZSxkLGYsbCx1KTtyPXIubmV4dDt0LmJ1ZmZlcmVkUmVxdWVzdENvdW50LS07aWYodC53cml0aW5nKXticmVha319aWYocj09PW51bGwpdC5sYXN0QnVmZmVyZWRSZXF1ZXN0PW51bGx9dC5idWZmZXJlZFJlcXVlc3Q9cjt0LmJ1ZmZlclByb2Nlc3Npbmc9ZmFsc2V9V3JpdGFibGUucHJvdG90eXBlLl93cml0ZT1mdW5jdGlvbihlLHQscil7cihuZXcgaChcIl93cml0ZSgpXCIpKX07V3JpdGFibGUucHJvdG90eXBlLl93cml0ZXY9bnVsbDtXcml0YWJsZS5wcm90b3R5cGUuZW5kPWZ1bmN0aW9uKGUsdCxyKXt2YXIgbj10aGlzLl93cml0YWJsZVN0YXRlO2lmKHR5cGVvZiBlPT09XCJmdW5jdGlvblwiKXtyPWU7ZT1udWxsO3Q9bnVsbH1lbHNlIGlmKHR5cGVvZiB0PT09XCJmdW5jdGlvblwiKXtyPXQ7dD1udWxsfWlmKGUhPT1udWxsJiZlIT09dW5kZWZpbmVkKXRoaXMud3JpdGUoZSx0KTtpZihuLmNvcmtlZCl7bi5jb3JrZWQ9MTt0aGlzLnVuY29yaygpfWlmKCFuLmVuZGluZyllbmRXcml0YWJsZSh0aGlzLG4scik7cmV0dXJuIHRoaXN9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsXCJ3cml0YWJsZUxlbmd0aFwiLHtlbnVtZXJhYmxlOmZhbHNlLGdldDpmdW5jdGlvbiBnZXQoKXtyZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5sZW5ndGh9fSk7ZnVuY3Rpb24gbmVlZEZpbmlzaChlKXtyZXR1cm4gZS5lbmRpbmcmJmUubGVuZ3RoPT09MCYmZS5idWZmZXJlZFJlcXVlc3Q9PT1udWxsJiYhZS5maW5pc2hlZCYmIWUud3JpdGluZ31mdW5jdGlvbiBjYWxsRmluYWwoZSx0KXtlLl9maW5hbCgoZnVuY3Rpb24ocil7dC5wZW5kaW5nY2ItLTtpZihyKXt3KGUscil9dC5wcmVmaW5pc2hlZD10cnVlO2UuZW1pdChcInByZWZpbmlzaFwiKTtmaW5pc2hNYXliZShlLHQpfSkpfWZ1bmN0aW9uIHByZWZpbmlzaChlLHQpe2lmKCF0LnByZWZpbmlzaGVkJiYhdC5maW5hbENhbGxlZCl7aWYodHlwZW9mIGUuX2ZpbmFsPT09XCJmdW5jdGlvblwiJiYhdC5kZXN0cm95ZWQpe3QucGVuZGluZ2NiKys7dC5maW5hbENhbGxlZD10cnVlO3Byb2Nlc3MubmV4dFRpY2soY2FsbEZpbmFsLGUsdCl9ZWxzZXt0LnByZWZpbmlzaGVkPXRydWU7ZS5lbWl0KFwicHJlZmluaXNoXCIpfX19ZnVuY3Rpb24gZmluaXNoTWF5YmUoZSx0KXt2YXIgcj1uZWVkRmluaXNoKHQpO2lmKHIpe3ByZWZpbmlzaChlLHQpO2lmKHQucGVuZGluZ2NiPT09MCl7dC5maW5pc2hlZD10cnVlO2UuZW1pdChcImZpbmlzaFwiKTtpZih0LmF1dG9EZXN0cm95KXt2YXIgbj1lLl9yZWFkYWJsZVN0YXRlO2lmKCFufHxuLmF1dG9EZXN0cm95JiZuLmVuZEVtaXR0ZWQpe2UuZGVzdHJveSgpfX19fXJldHVybiByfWZ1bmN0aW9uIGVuZFdyaXRhYmxlKGUsdCxyKXt0LmVuZGluZz10cnVlO2ZpbmlzaE1heWJlKGUsdCk7aWYocil7aWYodC5maW5pc2hlZClwcm9jZXNzLm5leHRUaWNrKHIpO2Vsc2UgZS5vbmNlKFwiZmluaXNoXCIscil9dC5lbmRlZD10cnVlO2Uud3JpdGFibGU9ZmFsc2V9ZnVuY3Rpb24gb25Db3JrZWRGaW5pc2goZSx0LHIpe3ZhciBuPWUuZW50cnk7ZS5lbnRyeT1udWxsO3doaWxlKG4pe3ZhciBpPW4uY2FsbGJhY2s7dC5wZW5kaW5nY2ItLTtpKHIpO249bi5uZXh0fXQuY29ya2VkUmVxdWVzdHNGcmVlLm5leHQ9ZX1PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLFwiZGVzdHJveWVkXCIse2VudW1lcmFibGU6ZmFsc2UsZ2V0OmZ1bmN0aW9uIGdldCgpe2lmKHRoaXMuX3dyaXRhYmxlU3RhdGU9PT11bmRlZmluZWQpe3JldHVybiBmYWxzZX1yZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWR9LHNldDpmdW5jdGlvbiBzZXQoZSl7aWYoIXRoaXMuX3dyaXRhYmxlU3RhdGUpe3JldHVybn10aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZD1lfX0pO1dyaXRhYmxlLnByb3RvdHlwZS5kZXN0cm95PWYuZGVzdHJveTtXcml0YWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveT1mLnVuZGVzdHJveTtXcml0YWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3k9ZnVuY3Rpb24oZSx0KXt0KGUpfX0sNzcxOmZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbjtmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkoZSx0LHIpe2lmKHQgaW4gZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7dmFsdWU6cixlbnVtZXJhYmxlOnRydWUsY29uZmlndXJhYmxlOnRydWUsd3JpdGFibGU6dHJ1ZX0pfWVsc2V7ZVt0XT1yfXJldHVybiBlfXZhciBpPXIoNDk0KTt2YXIgYT1TeW1ib2woXCJsYXN0UmVzb2x2ZVwiKTt2YXIgbz1TeW1ib2woXCJsYXN0UmVqZWN0XCIpO3ZhciBzPVN5bWJvbChcImVycm9yXCIpO3ZhciBmPVN5bWJvbChcImVuZGVkXCIpO3ZhciBsPVN5bWJvbChcImxhc3RQcm9taXNlXCIpO3ZhciB1PVN5bWJvbChcImhhbmRsZVByb21pc2VcIik7dmFyIGQ9U3ltYm9sKFwic3RyZWFtXCIpO2Z1bmN0aW9uIGNyZWF0ZUl0ZXJSZXN1bHQoZSx0KXtyZXR1cm57dmFsdWU6ZSxkb25lOnR9fWZ1bmN0aW9uIHJlYWRBbmRSZXNvbHZlKGUpe3ZhciB0PWVbYV07aWYodCE9PW51bGwpe3ZhciByPWVbZF0ucmVhZCgpO2lmKHIhPT1udWxsKXtlW2xdPW51bGw7ZVthXT1udWxsO2Vbb109bnVsbDt0KGNyZWF0ZUl0ZXJSZXN1bHQocixmYWxzZSkpfX19ZnVuY3Rpb24gb25SZWFkYWJsZShlKXtwcm9jZXNzLm5leHRUaWNrKHJlYWRBbmRSZXNvbHZlLGUpfWZ1bmN0aW9uIHdyYXBGb3JOZXh0KGUsdCl7cmV0dXJuIGZ1bmN0aW9uKHIsbil7ZS50aGVuKChmdW5jdGlvbigpe2lmKHRbZl0pe3IoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsdHJ1ZSkpO3JldHVybn10W3VdKHIsbil9KSxuKX19dmFyIGM9T2JqZWN0LmdldFByb3RvdHlwZU9mKChmdW5jdGlvbigpe30pKTt2YXIgaD1PYmplY3Quc2V0UHJvdG90eXBlT2YoKG49e2dldCBzdHJlYW0oKXtyZXR1cm4gdGhpc1tkXX0sbmV4dDpmdW5jdGlvbiBuZXh0KCl7dmFyIGU9dGhpczt2YXIgdD10aGlzW3NdO2lmKHQhPT1udWxsKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QodCl9aWYodGhpc1tmXSl7cmV0dXJuIFByb21pc2UucmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCx0cnVlKSl9aWYodGhpc1tkXS5kZXN0cm95ZWQpe3JldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24odCxyKXtwcm9jZXNzLm5leHRUaWNrKChmdW5jdGlvbigpe2lmKGVbc10pe3IoZVtzXSl9ZWxzZXt0KGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLHRydWUpKX19KSl9KSl9dmFyIHI9dGhpc1tsXTt2YXIgbjtpZihyKXtuPW5ldyBQcm9taXNlKHdyYXBGb3JOZXh0KHIsdGhpcykpfWVsc2V7dmFyIGk9dGhpc1tkXS5yZWFkKCk7aWYoaSE9PW51bGwpe3JldHVybiBQcm9taXNlLnJlc29sdmUoY3JlYXRlSXRlclJlc3VsdChpLGZhbHNlKSl9bj1uZXcgUHJvbWlzZSh0aGlzW3VdKX10aGlzW2xdPW47cmV0dXJuIG59fSxfZGVmaW5lUHJvcGVydHkobixTeW1ib2wuYXN5bmNJdGVyYXRvciwoZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30pKSxfZGVmaW5lUHJvcGVydHkobixcInJldHVyblwiLChmdW5jdGlvbiBfcmV0dXJuKCl7dmFyIGU9dGhpcztyZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKHQscil7ZVtkXS5kZXN0cm95KG51bGwsKGZ1bmN0aW9uKGUpe2lmKGUpe3IoZSk7cmV0dXJufXQoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsdHJ1ZSkpfSkpfSkpfSkpLG4pLGMpO3ZhciBwPWZ1bmN0aW9uIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcihlKXt2YXIgdDt2YXIgcj1PYmplY3QuY3JlYXRlKGgsKHQ9e30sX2RlZmluZVByb3BlcnR5KHQsZCx7dmFsdWU6ZSx3cml0YWJsZTp0cnVlfSksX2RlZmluZVByb3BlcnR5KHQsYSx7dmFsdWU6bnVsbCx3cml0YWJsZTp0cnVlfSksX2RlZmluZVByb3BlcnR5KHQsbyx7dmFsdWU6bnVsbCx3cml0YWJsZTp0cnVlfSksX2RlZmluZVByb3BlcnR5KHQscyx7dmFsdWU6bnVsbCx3cml0YWJsZTp0cnVlfSksX2RlZmluZVByb3BlcnR5KHQsZix7dmFsdWU6ZS5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkLHdyaXRhYmxlOnRydWV9KSxfZGVmaW5lUHJvcGVydHkodCx1LHt2YWx1ZTpmdW5jdGlvbiB2YWx1ZShlLHQpe3ZhciBuPXJbZF0ucmVhZCgpO2lmKG4pe3JbbF09bnVsbDtyW2FdPW51bGw7cltvXT1udWxsO2UoY3JlYXRlSXRlclJlc3VsdChuLGZhbHNlKSl9ZWxzZXtyW2FdPWU7cltvXT10fX0sd3JpdGFibGU6dHJ1ZX0pLHQpKTtyW2xdPW51bGw7aShlLChmdW5jdGlvbihlKXtpZihlJiZlLmNvZGUhPT1cIkVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFXCIpe3ZhciB0PXJbb107aWYodCE9PW51bGwpe3JbbF09bnVsbDtyW2FdPW51bGw7cltvXT1udWxsO3QoZSl9cltzXT1lO3JldHVybn12YXIgbj1yW2FdO2lmKG4hPT1udWxsKXtyW2xdPW51bGw7clthXT1udWxsO3Jbb109bnVsbDtuKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLHRydWUpKX1yW2ZdPXRydWV9KSk7ZS5vbihcInJlYWRhYmxlXCIsb25SZWFkYWJsZS5iaW5kKG51bGwscikpO3JldHVybiByfTtlLmV4cG9ydHM9cH0sOTE0OmZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBvd25LZXlzKGUsdCl7dmFyIHI9T2JqZWN0LmtleXMoZSk7aWYoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyl7dmFyIG49T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtpZih0KW49bi5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsdCkuZW51bWVyYWJsZX0pKTtyLnB1c2guYXBwbHkocixuKX1yZXR1cm4gcn1mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpe2Zvcih2YXIgdD0xO3Q8YXJndW1lbnRzLmxlbmd0aDt0Kyspe3ZhciByPWFyZ3VtZW50c1t0XSE9bnVsbD9hcmd1bWVudHNbdF06e307aWYodCUyKXtvd25LZXlzKE9iamVjdChyKSx0cnVlKS5mb3JFYWNoKChmdW5jdGlvbih0KXtfZGVmaW5lUHJvcGVydHkoZSx0LHJbdF0pfSkpfWVsc2UgaWYoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpe09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMocikpfWVsc2V7b3duS2V5cyhPYmplY3QocikpLmZvckVhY2goKGZ1bmN0aW9uKHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihyLHQpKX0pKX19cmV0dXJuIGV9ZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KGUsdCxyKXtpZih0IGluIGUpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse3ZhbHVlOnIsZW51bWVyYWJsZTp0cnVlLGNvbmZpZ3VyYWJsZTp0cnVlLHdyaXRhYmxlOnRydWV9KX1lbHNle2VbdF09cn1yZXR1cm4gZX1mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX19ZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXMoZSx0KXtmb3IodmFyIHI9MDtyPHQubGVuZ3RoO3IrKyl7dmFyIG49dFtyXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHxmYWxzZTtuLmNvbmZpZ3VyYWJsZT10cnVlO2lmKFwidmFsdWVcImluIG4pbi53cml0YWJsZT10cnVlO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG4ua2V5LG4pfX1mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoZSx0LHIpe2lmKHQpX2RlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsdCk7aWYocilfZGVmaW5lUHJvcGVydGllcyhlLHIpO3JldHVybiBlfXZhciBuPXIoMzAwKSxpPW4uQnVmZmVyO3ZhciBhPXIoODM3KSxvPWEuaW5zcGVjdDt2YXIgcz1vJiZvLmN1c3RvbXx8XCJpbnNwZWN0XCI7ZnVuY3Rpb24gY29weUJ1ZmZlcihlLHQscil7aS5wcm90b3R5cGUuY29weS5jYWxsKGUsdCxyKX1lLmV4cG9ydHM9ZnVuY3Rpb24oKXtmdW5jdGlvbiBCdWZmZXJMaXN0KCl7X2NsYXNzQ2FsbENoZWNrKHRoaXMsQnVmZmVyTGlzdCk7dGhpcy5oZWFkPW51bGw7dGhpcy50YWlsPW51bGw7dGhpcy5sZW5ndGg9MH1fY3JlYXRlQ2xhc3MoQnVmZmVyTGlzdCxbe2tleTpcInB1c2hcIix2YWx1ZTpmdW5jdGlvbiBwdXNoKGUpe3ZhciB0PXtkYXRhOmUsbmV4dDpudWxsfTtpZih0aGlzLmxlbmd0aD4wKXRoaXMudGFpbC5uZXh0PXQ7ZWxzZSB0aGlzLmhlYWQ9dDt0aGlzLnRhaWw9dDsrK3RoaXMubGVuZ3RofX0se2tleTpcInVuc2hpZnRcIix2YWx1ZTpmdW5jdGlvbiB1bnNoaWZ0KGUpe3ZhciB0PXtkYXRhOmUsbmV4dDp0aGlzLmhlYWR9O2lmKHRoaXMubGVuZ3RoPT09MCl0aGlzLnRhaWw9dDt0aGlzLmhlYWQ9dDsrK3RoaXMubGVuZ3RofX0se2tleTpcInNoaWZ0XCIsdmFsdWU6ZnVuY3Rpb24gc2hpZnQoKXtpZih0aGlzLmxlbmd0aD09PTApcmV0dXJuO3ZhciBlPXRoaXMuaGVhZC5kYXRhO2lmKHRoaXMubGVuZ3RoPT09MSl0aGlzLmhlYWQ9dGhpcy50YWlsPW51bGw7ZWxzZSB0aGlzLmhlYWQ9dGhpcy5oZWFkLm5leHQ7LS10aGlzLmxlbmd0aDtyZXR1cm4gZX19LHtrZXk6XCJjbGVhclwiLHZhbHVlOmZ1bmN0aW9uIGNsZWFyKCl7dGhpcy5oZWFkPXRoaXMudGFpbD1udWxsO3RoaXMubGVuZ3RoPTB9fSx7a2V5Olwiam9pblwiLHZhbHVlOmZ1bmN0aW9uIGpvaW4oZSl7aWYodGhpcy5sZW5ndGg9PT0wKXJldHVyblwiXCI7dmFyIHQ9dGhpcy5oZWFkO3ZhciByPVwiXCIrdC5kYXRhO3doaWxlKHQ9dC5uZXh0KXtyKz1lK3QuZGF0YX1yZXR1cm4gcn19LHtrZXk6XCJjb25jYXRcIix2YWx1ZTpmdW5jdGlvbiBjb25jYXQoZSl7aWYodGhpcy5sZW5ndGg9PT0wKXJldHVybiBpLmFsbG9jKDApO3ZhciB0PWkuYWxsb2NVbnNhZmUoZT4+PjApO3ZhciByPXRoaXMuaGVhZDt2YXIgbj0wO3doaWxlKHIpe2NvcHlCdWZmZXIoci5kYXRhLHQsbik7bis9ci5kYXRhLmxlbmd0aDtyPXIubmV4dH1yZXR1cm4gdH19LHtrZXk6XCJjb25zdW1lXCIsdmFsdWU6ZnVuY3Rpb24gY29uc3VtZShlLHQpe3ZhciByO2lmKGU8dGhpcy5oZWFkLmRhdGEubGVuZ3RoKXtyPXRoaXMuaGVhZC5kYXRhLnNsaWNlKDAsZSk7dGhpcy5oZWFkLmRhdGE9dGhpcy5oZWFkLmRhdGEuc2xpY2UoZSl9ZWxzZSBpZihlPT09dGhpcy5oZWFkLmRhdGEubGVuZ3RoKXtyPXRoaXMuc2hpZnQoKX1lbHNle3I9dD90aGlzLl9nZXRTdHJpbmcoZSk6dGhpcy5fZ2V0QnVmZmVyKGUpfXJldHVybiByfX0se2tleTpcImZpcnN0XCIsdmFsdWU6ZnVuY3Rpb24gZmlyc3QoKXtyZXR1cm4gdGhpcy5oZWFkLmRhdGF9fSx7a2V5OlwiX2dldFN0cmluZ1wiLHZhbHVlOmZ1bmN0aW9uIF9nZXRTdHJpbmcoZSl7dmFyIHQ9dGhpcy5oZWFkO3ZhciByPTE7dmFyIG49dC5kYXRhO2UtPW4ubGVuZ3RoO3doaWxlKHQ9dC5uZXh0KXt2YXIgaT10LmRhdGE7dmFyIGE9ZT5pLmxlbmd0aD9pLmxlbmd0aDplO2lmKGE9PT1pLmxlbmd0aCluKz1pO2Vsc2Ugbis9aS5zbGljZSgwLGUpO2UtPWE7aWYoZT09PTApe2lmKGE9PT1pLmxlbmd0aCl7KytyO2lmKHQubmV4dCl0aGlzLmhlYWQ9dC5uZXh0O2Vsc2UgdGhpcy5oZWFkPXRoaXMudGFpbD1udWxsfWVsc2V7dGhpcy5oZWFkPXQ7dC5kYXRhPWkuc2xpY2UoYSl9YnJlYWt9KytyfXRoaXMubGVuZ3RoLT1yO3JldHVybiBufX0se2tleTpcIl9nZXRCdWZmZXJcIix2YWx1ZTpmdW5jdGlvbiBfZ2V0QnVmZmVyKGUpe3ZhciB0PWkuYWxsb2NVbnNhZmUoZSk7dmFyIHI9dGhpcy5oZWFkO3ZhciBuPTE7ci5kYXRhLmNvcHkodCk7ZS09ci5kYXRhLmxlbmd0aDt3aGlsZShyPXIubmV4dCl7dmFyIGE9ci5kYXRhO3ZhciBvPWU+YS5sZW5ndGg/YS5sZW5ndGg6ZTthLmNvcHkodCx0Lmxlbmd0aC1lLDAsbyk7ZS09bztpZihlPT09MCl7aWYobz09PWEubGVuZ3RoKXsrK247aWYoci5uZXh0KXRoaXMuaGVhZD1yLm5leHQ7ZWxzZSB0aGlzLmhlYWQ9dGhpcy50YWlsPW51bGx9ZWxzZXt0aGlzLmhlYWQ9cjtyLmRhdGE9YS5zbGljZShvKX1icmVha30rK259dGhpcy5sZW5ndGgtPW47cmV0dXJuIHR9fSx7a2V5OnMsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoZSx0KXtyZXR1cm4gbyh0aGlzLF9vYmplY3RTcHJlYWQoe30sdCx7ZGVwdGg6MCxjdXN0b21JbnNwZWN0OmZhbHNlfSkpfX1dKTtyZXR1cm4gQnVmZmVyTGlzdH0oKX0sMzY0OmZ1bmN0aW9uKGUpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGRlc3Ryb3koZSx0KXt2YXIgcj10aGlzO3ZhciBuPXRoaXMuX3JlYWRhYmxlU3RhdGUmJnRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO3ZhciBpPXRoaXMuX3dyaXRhYmxlU3RhdGUmJnRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO2lmKG58fGkpe2lmKHQpe3QoZSl9ZWxzZSBpZihlKXtpZighdGhpcy5fd3JpdGFibGVTdGF0ZSl7cHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JOVCx0aGlzLGUpfWVsc2UgaWYoIXRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKXt0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZD10cnVlO3Byb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yTlQsdGhpcyxlKX19cmV0dXJuIHRoaXN9aWYodGhpcy5fcmVhZGFibGVTdGF0ZSl7dGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ9dHJ1ZX1pZih0aGlzLl93cml0YWJsZVN0YXRlKXt0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZD10cnVlfXRoaXMuX2Rlc3Ryb3koZXx8bnVsbCwoZnVuY3Rpb24oZSl7aWYoIXQmJmUpe2lmKCFyLl93cml0YWJsZVN0YXRlKXtwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvckFuZENsb3NlTlQscixlKX1lbHNlIGlmKCFyLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCl7ci5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQ9dHJ1ZTtwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvckFuZENsb3NlTlQscixlKX1lbHNle3Byb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlTlQscil9fWVsc2UgaWYodCl7cHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2VOVCxyKTt0KGUpfWVsc2V7cHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2VOVCxyKX19KSk7cmV0dXJuIHRoaXN9ZnVuY3Rpb24gZW1pdEVycm9yQW5kQ2xvc2VOVChlLHQpe2VtaXRFcnJvck5UKGUsdCk7ZW1pdENsb3NlTlQoZSl9ZnVuY3Rpb24gZW1pdENsb3NlTlQoZSl7aWYoZS5fd3JpdGFibGVTdGF0ZSYmIWUuX3dyaXRhYmxlU3RhdGUuZW1pdENsb3NlKXJldHVybjtpZihlLl9yZWFkYWJsZVN0YXRlJiYhZS5fcmVhZGFibGVTdGF0ZS5lbWl0Q2xvc2UpcmV0dXJuO2UuZW1pdChcImNsb3NlXCIpfWZ1bmN0aW9uIHVuZGVzdHJveSgpe2lmKHRoaXMuX3JlYWRhYmxlU3RhdGUpe3RoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkPWZhbHNlO3RoaXMuX3JlYWRhYmxlU3RhdGUucmVhZGluZz1mYWxzZTt0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZGVkPWZhbHNlO3RoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZD1mYWxzZX1pZih0aGlzLl93cml0YWJsZVN0YXRlKXt0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZD1mYWxzZTt0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkPWZhbHNlO3RoaXMuX3dyaXRhYmxlU3RhdGUuZW5kaW5nPWZhbHNlO3RoaXMuX3dyaXRhYmxlU3RhdGUuZmluYWxDYWxsZWQ9ZmFsc2U7dGhpcy5fd3JpdGFibGVTdGF0ZS5wcmVmaW5pc2hlZD1mYWxzZTt0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkPWZhbHNlO3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkPWZhbHNlfX1mdW5jdGlvbiBlbWl0RXJyb3JOVChlLHQpe2UuZW1pdChcImVycm9yXCIsdCl9ZnVuY3Rpb24gZXJyb3JPckRlc3Ryb3koZSx0KXt2YXIgcj1lLl9yZWFkYWJsZVN0YXRlO3ZhciBuPWUuX3dyaXRhYmxlU3RhdGU7aWYociYmci5hdXRvRGVzdHJveXx8biYmbi5hdXRvRGVzdHJveSllLmRlc3Ryb3kodCk7ZWxzZSBlLmVtaXQoXCJlcnJvclwiLHQpfWUuZXhwb3J0cz17ZGVzdHJveTpkZXN0cm95LHVuZGVzdHJveTp1bmRlc3Ryb3ksZXJyb3JPckRlc3Ryb3k6ZXJyb3JPckRlc3Ryb3l9fSw0OTQ6ZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoODMzKS5xLkVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFO2Z1bmN0aW9uIG9uY2UoZSl7dmFyIHQ9ZmFsc2U7cmV0dXJuIGZ1bmN0aW9uKCl7aWYodClyZXR1cm47dD10cnVlO2Zvcih2YXIgcj1hcmd1bWVudHMubGVuZ3RoLG49bmV3IEFycmF5KHIpLGk9MDtpPHI7aSsrKXtuW2ldPWFyZ3VtZW50c1tpXX1lLmFwcGx5KHRoaXMsbil9fWZ1bmN0aW9uIG5vb3AoKXt9ZnVuY3Rpb24gaXNSZXF1ZXN0KGUpe3JldHVybiBlLnNldEhlYWRlciYmdHlwZW9mIGUuYWJvcnQ9PT1cImZ1bmN0aW9uXCJ9ZnVuY3Rpb24gZW9zKGUsdCxyKXtpZih0eXBlb2YgdD09PVwiZnVuY3Rpb25cIilyZXR1cm4gZW9zKGUsbnVsbCx0KTtpZighdCl0PXt9O3I9b25jZShyfHxub29wKTt2YXIgaT10LnJlYWRhYmxlfHx0LnJlYWRhYmxlIT09ZmFsc2UmJmUucmVhZGFibGU7dmFyIGE9dC53cml0YWJsZXx8dC53cml0YWJsZSE9PWZhbHNlJiZlLndyaXRhYmxlO3ZhciBvPWZ1bmN0aW9uIG9ubGVnYWN5ZmluaXNoKCl7aWYoIWUud3JpdGFibGUpZigpfTt2YXIgcz1lLl93cml0YWJsZVN0YXRlJiZlLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkO3ZhciBmPWZ1bmN0aW9uIG9uZmluaXNoKCl7YT1mYWxzZTtzPXRydWU7aWYoIWkpci5jYWxsKGUpfTt2YXIgbD1lLl9yZWFkYWJsZVN0YXRlJiZlLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQ7dmFyIHU9ZnVuY3Rpb24gb25lbmQoKXtpPWZhbHNlO2w9dHJ1ZTtpZighYSlyLmNhbGwoZSl9O3ZhciBkPWZ1bmN0aW9uIG9uZXJyb3IodCl7ci5jYWxsKGUsdCl9O3ZhciBjPWZ1bmN0aW9uIG9uY2xvc2UoKXt2YXIgdDtpZihpJiYhbCl7aWYoIWUuX3JlYWRhYmxlU3RhdGV8fCFlLl9yZWFkYWJsZVN0YXRlLmVuZGVkKXQ9bmV3IG47cmV0dXJuIHIuY2FsbChlLHQpfWlmKGEmJiFzKXtpZighZS5fd3JpdGFibGVTdGF0ZXx8IWUuX3dyaXRhYmxlU3RhdGUuZW5kZWQpdD1uZXcgbjtyZXR1cm4gci5jYWxsKGUsdCl9fTt2YXIgaD1mdW5jdGlvbiBvbnJlcXVlc3QoKXtlLnJlcS5vbihcImZpbmlzaFwiLGYpfTtpZihpc1JlcXVlc3QoZSkpe2Uub24oXCJjb21wbGV0ZVwiLGYpO2Uub24oXCJhYm9ydFwiLGMpO2lmKGUucmVxKWgoKTtlbHNlIGUub24oXCJyZXF1ZXN0XCIsaCl9ZWxzZSBpZihhJiYhZS5fd3JpdGFibGVTdGF0ZSl7ZS5vbihcImVuZFwiLG8pO2Uub24oXCJjbG9zZVwiLG8pfWUub24oXCJlbmRcIix1KTtlLm9uKFwiZmluaXNoXCIsZik7aWYodC5lcnJvciE9PWZhbHNlKWUub24oXCJlcnJvclwiLGQpO2Uub24oXCJjbG9zZVwiLGMpO3JldHVybiBmdW5jdGlvbigpe2UucmVtb3ZlTGlzdGVuZXIoXCJjb21wbGV0ZVwiLGYpO2UucmVtb3ZlTGlzdGVuZXIoXCJhYm9ydFwiLGMpO2UucmVtb3ZlTGlzdGVuZXIoXCJyZXF1ZXN0XCIsaCk7aWYoZS5yZXEpZS5yZXEucmVtb3ZlTGlzdGVuZXIoXCJmaW5pc2hcIixmKTtlLnJlbW92ZUxpc3RlbmVyKFwiZW5kXCIsbyk7ZS5yZW1vdmVMaXN0ZW5lcihcImNsb3NlXCIsbyk7ZS5yZW1vdmVMaXN0ZW5lcihcImZpbmlzaFwiLGYpO2UucmVtb3ZlTGlzdGVuZXIoXCJlbmRcIix1KTtlLnJlbW92ZUxpc3RlbmVyKFwiZXJyb3JcIixkKTtlLnJlbW92ZUxpc3RlbmVyKFwiY2xvc2VcIixjKX19ZS5leHBvcnRzPWVvc30sMTY6ZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChlLHQscixuLGksYSxvKXt0cnl7dmFyIHM9ZVthXShvKTt2YXIgZj1zLnZhbHVlfWNhdGNoKGUpe3IoZSk7cmV0dXJufWlmKHMuZG9uZSl7dChmKX1lbHNle1Byb21pc2UucmVzb2x2ZShmKS50aGVuKG4saSl9fWZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGUpe3JldHVybiBmdW5jdGlvbigpe3ZhciB0PXRoaXMscj1hcmd1bWVudHM7cmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbihuLGkpe3ZhciBhPWUuYXBwbHkodCxyKTtmdW5jdGlvbiBfbmV4dChlKXthc3luY0dlbmVyYXRvclN0ZXAoYSxuLGksX25leHQsX3Rocm93LFwibmV4dFwiLGUpfWZ1bmN0aW9uIF90aHJvdyhlKXthc3luY0dlbmVyYXRvclN0ZXAoYSxuLGksX25leHQsX3Rocm93LFwidGhyb3dcIixlKX1fbmV4dCh1bmRlZmluZWQpfSkpfX1mdW5jdGlvbiBvd25LZXlzKGUsdCl7dmFyIHI9T2JqZWN0LmtleXMoZSk7aWYoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyl7dmFyIG49T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtpZih0KW49bi5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsdCkuZW51bWVyYWJsZX0pKTtyLnB1c2guYXBwbHkocixuKX1yZXR1cm4gcn1mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpe2Zvcih2YXIgdD0xO3Q8YXJndW1lbnRzLmxlbmd0aDt0Kyspe3ZhciByPWFyZ3VtZW50c1t0XSE9bnVsbD9hcmd1bWVudHNbdF06e307aWYodCUyKXtvd25LZXlzKE9iamVjdChyKSx0cnVlKS5mb3JFYWNoKChmdW5jdGlvbih0KXtfZGVmaW5lUHJvcGVydHkoZSx0LHJbdF0pfSkpfWVsc2UgaWYoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpe09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMocikpfWVsc2V7b3duS2V5cyhPYmplY3QocikpLmZvckVhY2goKGZ1bmN0aW9uKHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihyLHQpKX0pKX19cmV0dXJuIGV9ZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KGUsdCxyKXtpZih0IGluIGUpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse3ZhbHVlOnIsZW51bWVyYWJsZTp0cnVlLGNvbmZpZ3VyYWJsZTp0cnVlLHdyaXRhYmxlOnRydWV9KX1lbHNle2VbdF09cn1yZXR1cm4gZX12YXIgbj1yKDgzMykucS5FUlJfSU5WQUxJRF9BUkdfVFlQRTtmdW5jdGlvbiBmcm9tKGUsdCxyKXt2YXIgaTtpZih0JiZ0eXBlb2YgdC5uZXh0PT09XCJmdW5jdGlvblwiKXtpPXR9ZWxzZSBpZih0JiZ0W1N5bWJvbC5hc3luY0l0ZXJhdG9yXSlpPXRbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7ZWxzZSBpZih0JiZ0W1N5bWJvbC5pdGVyYXRvcl0paT10W1N5bWJvbC5pdGVyYXRvcl0oKTtlbHNlIHRocm93IG5ldyBuKFwiaXRlcmFibGVcIixbXCJJdGVyYWJsZVwiXSx0KTt2YXIgYT1uZXcgZShfb2JqZWN0U3ByZWFkKHtvYmplY3RNb2RlOnRydWV9LHIpKTt2YXIgbz1mYWxzZTthLl9yZWFkPWZ1bmN0aW9uKCl7aWYoIW8pe289dHJ1ZTtuZXh0KCl9fTtmdW5jdGlvbiBuZXh0KCl7cmV0dXJuIF9uZXh0Mi5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZnVuY3Rpb24gX25leHQyKCl7X25leHQyPV9hc3luY1RvR2VuZXJhdG9yKChmdW5jdGlvbiooKXt0cnl7dmFyIGU9eWllbGQgaS5uZXh0KCksdD1lLnZhbHVlLHI9ZS5kb25lO2lmKHIpe2EucHVzaChudWxsKX1lbHNlIGlmKGEucHVzaCh5aWVsZCB0KSl7bmV4dCgpfWVsc2V7bz1mYWxzZX19Y2F0Y2goZSl7YS5kZXN0cm95KGUpfX0pKTtyZXR1cm4gX25leHQyLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1yZXR1cm4gYX1lLmV4cG9ydHM9ZnJvbX0sMjI5OmZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbjtmdW5jdGlvbiBvbmNlKGUpe3ZhciB0PWZhbHNlO3JldHVybiBmdW5jdGlvbigpe2lmKHQpcmV0dXJuO3Q9dHJ1ZTtlLmFwcGx5KHZvaWQgMCxhcmd1bWVudHMpfX12YXIgaT1yKDgzMykucSxhPWkuRVJSX01JU1NJTkdfQVJHUyxvPWkuRVJSX1NUUkVBTV9ERVNUUk9ZRUQ7ZnVuY3Rpb24gbm9vcChlKXtpZihlKXRocm93IGV9ZnVuY3Rpb24gaXNSZXF1ZXN0KGUpe3JldHVybiBlLnNldEhlYWRlciYmdHlwZW9mIGUuYWJvcnQ9PT1cImZ1bmN0aW9uXCJ9ZnVuY3Rpb24gZGVzdHJveWVyKGUsdCxpLGEpe2E9b25jZShhKTt2YXIgcz1mYWxzZTtlLm9uKFwiY2xvc2VcIiwoZnVuY3Rpb24oKXtzPXRydWV9KSk7aWYobj09PXVuZGVmaW5lZCluPXIoNDk0KTtuKGUse3JlYWRhYmxlOnQsd3JpdGFibGU6aX0sKGZ1bmN0aW9uKGUpe2lmKGUpcmV0dXJuIGEoZSk7cz10cnVlO2EoKX0pKTt2YXIgZj1mYWxzZTtyZXR1cm4gZnVuY3Rpb24odCl7aWYocylyZXR1cm47aWYoZilyZXR1cm47Zj10cnVlO2lmKGlzUmVxdWVzdChlKSlyZXR1cm4gZS5hYm9ydCgpO2lmKHR5cGVvZiBlLmRlc3Ryb3k9PT1cImZ1bmN0aW9uXCIpcmV0dXJuIGUuZGVzdHJveSgpO2EodHx8bmV3IG8oXCJwaXBlXCIpKX19ZnVuY3Rpb24gY2FsbChlKXtlKCl9ZnVuY3Rpb24gcGlwZShlLHQpe3JldHVybiBlLnBpcGUodCl9ZnVuY3Rpb24gcG9wQ2FsbGJhY2soZSl7aWYoIWUubGVuZ3RoKXJldHVybiBub29wO2lmKHR5cGVvZiBlW2UubGVuZ3RoLTFdIT09XCJmdW5jdGlvblwiKXJldHVybiBub29wO3JldHVybiBlLnBvcCgpfWZ1bmN0aW9uIHBpcGVsaW5lKCl7Zm9yKHZhciBlPWFyZ3VtZW50cy5sZW5ndGgsdD1uZXcgQXJyYXkoZSkscj0wO3I8ZTtyKyspe3Rbcl09YXJndW1lbnRzW3JdfXZhciBuPXBvcENhbGxiYWNrKHQpO2lmKEFycmF5LmlzQXJyYXkodFswXSkpdD10WzBdO2lmKHQubGVuZ3RoPDIpe3Rocm93IG5ldyBhKFwic3RyZWFtc1wiKX12YXIgaTt2YXIgbz10Lm1hcCgoZnVuY3Rpb24oZSxyKXt2YXIgYT1yPHQubGVuZ3RoLTE7dmFyIHM9cj4wO3JldHVybiBkZXN0cm95ZXIoZSxhLHMsKGZ1bmN0aW9uKGUpe2lmKCFpKWk9ZTtpZihlKW8uZm9yRWFjaChjYWxsKTtpZihhKXJldHVybjtvLmZvckVhY2goY2FsbCk7bihpKX0pKX0pKTtyZXR1cm4gdC5yZWR1Y2UocGlwZSl9ZS5leHBvcnRzPXBpcGVsaW5lfSwzMjI6ZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoODMzKS5xLkVSUl9JTlZBTElEX09QVF9WQUxVRTtmdW5jdGlvbiBoaWdoV2F0ZXJNYXJrRnJvbShlLHQscil7cmV0dXJuIGUuaGlnaFdhdGVyTWFyayE9bnVsbD9lLmhpZ2hXYXRlck1hcms6dD9lW3JdOm51bGx9ZnVuY3Rpb24gZ2V0SGlnaFdhdGVyTWFyayhlLHQscixpKXt2YXIgYT1oaWdoV2F0ZXJNYXJrRnJvbSh0LGkscik7aWYoYSE9bnVsbCl7aWYoIShpc0Zpbml0ZShhKSYmTWF0aC5mbG9vcihhKT09PWEpfHxhPDApe3ZhciBvPWk/cjpcImhpZ2hXYXRlck1hcmtcIjt0aHJvdyBuZXcgbihvLGEpfXJldHVybiBNYXRoLmZsb29yKGEpfXJldHVybiBlLm9iamVjdE1vZGU/MTY6MTYqMTAyNH1lLmV4cG9ydHM9e2dldEhpZ2hXYXRlck1hcms6Z2V0SGlnaFdhdGVyTWFya319LDkxOTpmdW5jdGlvbihlLHQscil7ZS5leHBvcnRzPXIoNzgxKX0sNjQyOmZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yKDExOCkuQnVmZmVyO3ZhciBpPW4uaXNFbmNvZGluZ3x8ZnVuY3Rpb24oZSl7ZT1cIlwiK2U7c3dpdGNoKGUmJmUudG9Mb3dlckNhc2UoKSl7Y2FzZVwiaGV4XCI6Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6Y2FzZVwiYXNjaWlcIjpjYXNlXCJiaW5hcnlcIjpjYXNlXCJiYXNlNjRcIjpjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpjYXNlXCJyYXdcIjpyZXR1cm4gdHJ1ZTtkZWZhdWx0OnJldHVybiBmYWxzZX19O2Z1bmN0aW9uIF9ub3JtYWxpemVFbmNvZGluZyhlKXtpZighZSlyZXR1cm5cInV0ZjhcIjt2YXIgdDt3aGlsZSh0cnVlKXtzd2l0Y2goZSl7Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6cmV0dXJuXCJ1dGY4XCI7Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuXCJ1dGYxNmxlXCI7Y2FzZVwibGF0aW4xXCI6Y2FzZVwiYmluYXJ5XCI6cmV0dXJuXCJsYXRpbjFcIjtjYXNlXCJiYXNlNjRcIjpjYXNlXCJhc2NpaVwiOmNhc2VcImhleFwiOnJldHVybiBlO2RlZmF1bHQ6aWYodClyZXR1cm47ZT0oXCJcIitlKS50b0xvd2VyQ2FzZSgpO3Q9dHJ1ZX19fWZ1bmN0aW9uIG5vcm1hbGl6ZUVuY29kaW5nKGUpe3ZhciB0PV9ub3JtYWxpemVFbmNvZGluZyhlKTtpZih0eXBlb2YgdCE9PVwic3RyaW5nXCImJihuLmlzRW5jb2Rpbmc9PT1pfHwhaShlKSkpdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIrZSk7cmV0dXJuIHR8fGV9dC5zPVN0cmluZ0RlY29kZXI7ZnVuY3Rpb24gU3RyaW5nRGVjb2RlcihlKXt0aGlzLmVuY29kaW5nPW5vcm1hbGl6ZUVuY29kaW5nKGUpO3ZhciB0O3N3aXRjaCh0aGlzLmVuY29kaW5nKXtjYXNlXCJ1dGYxNmxlXCI6dGhpcy50ZXh0PXV0ZjE2VGV4dDt0aGlzLmVuZD11dGYxNkVuZDt0PTQ7YnJlYWs7Y2FzZVwidXRmOFwiOnRoaXMuZmlsbExhc3Q9dXRmOEZpbGxMYXN0O3Q9NDticmVhaztjYXNlXCJiYXNlNjRcIjp0aGlzLnRleHQ9YmFzZTY0VGV4dDt0aGlzLmVuZD1iYXNlNjRFbmQ7dD0zO2JyZWFrO2RlZmF1bHQ6dGhpcy53cml0ZT1zaW1wbGVXcml0ZTt0aGlzLmVuZD1zaW1wbGVFbmQ7cmV0dXJufXRoaXMubGFzdE5lZWQ9MDt0aGlzLmxhc3RUb3RhbD0wO3RoaXMubGFzdENoYXI9bi5hbGxvY1Vuc2FmZSh0KX1TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZT1mdW5jdGlvbihlKXtpZihlLmxlbmd0aD09PTApcmV0dXJuXCJcIjt2YXIgdDt2YXIgcjtpZih0aGlzLmxhc3ROZWVkKXt0PXRoaXMuZmlsbExhc3QoZSk7aWYodD09PXVuZGVmaW5lZClyZXR1cm5cIlwiO3I9dGhpcy5sYXN0TmVlZDt0aGlzLmxhc3ROZWVkPTB9ZWxzZXtyPTB9aWYocjxlLmxlbmd0aClyZXR1cm4gdD90K3RoaXMudGV4dChlLHIpOnRoaXMudGV4dChlLHIpO3JldHVybiB0fHxcIlwifTtTdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQ9dXRmOEVuZDtTdHJpbmdEZWNvZGVyLnByb3RvdHlwZS50ZXh0PXV0ZjhUZXh0O1N0cmluZ0RlY29kZXIucHJvdG90eXBlLmZpbGxMYXN0PWZ1bmN0aW9uKGUpe2lmKHRoaXMubGFzdE5lZWQ8PWUubGVuZ3RoKXtlLmNvcHkodGhpcy5sYXN0Q2hhcix0aGlzLmxhc3RUb3RhbC10aGlzLmxhc3ROZWVkLDAsdGhpcy5sYXN0TmVlZCk7cmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywwLHRoaXMubGFzdFRvdGFsKX1lLmNvcHkodGhpcy5sYXN0Q2hhcix0aGlzLmxhc3RUb3RhbC10aGlzLmxhc3ROZWVkLDAsZS5sZW5ndGgpO3RoaXMubGFzdE5lZWQtPWUubGVuZ3RofTtmdW5jdGlvbiB1dGY4Q2hlY2tCeXRlKGUpe2lmKGU8PTEyNylyZXR1cm4gMDtlbHNlIGlmKGU+PjU9PT02KXJldHVybiAyO2Vsc2UgaWYoZT4+ND09PTE0KXJldHVybiAzO2Vsc2UgaWYoZT4+Mz09PTMwKXJldHVybiA0O3JldHVybiBlPj42PT09Mj8tMTotMn1mdW5jdGlvbiB1dGY4Q2hlY2tJbmNvbXBsZXRlKGUsdCxyKXt2YXIgbj10Lmxlbmd0aC0xO2lmKG48cilyZXR1cm4gMDt2YXIgaT11dGY4Q2hlY2tCeXRlKHRbbl0pO2lmKGk+PTApe2lmKGk+MCllLmxhc3ROZWVkPWktMTtyZXR1cm4gaX1pZigtLW48cnx8aT09PS0yKXJldHVybiAwO2k9dXRmOENoZWNrQnl0ZSh0W25dKTtpZihpPj0wKXtpZihpPjApZS5sYXN0TmVlZD1pLTI7cmV0dXJuIGl9aWYoLS1uPHJ8fGk9PT0tMilyZXR1cm4gMDtpPXV0ZjhDaGVja0J5dGUodFtuXSk7aWYoaT49MCl7aWYoaT4wKXtpZihpPT09MilpPTA7ZWxzZSBlLmxhc3ROZWVkPWktM31yZXR1cm4gaX1yZXR1cm4gMH1mdW5jdGlvbiB1dGY4Q2hlY2tFeHRyYUJ5dGVzKGUsdCxyKXtpZigodFswXSYxOTIpIT09MTI4KXtlLmxhc3ROZWVkPTA7cmV0dXJuXCLvv71cIn1pZihlLmxhc3ROZWVkPjEmJnQubGVuZ3RoPjEpe2lmKCh0WzFdJjE5MikhPT0xMjgpe2UubGFzdE5lZWQ9MTtyZXR1cm5cIu+/vVwifWlmKGUubGFzdE5lZWQ+MiYmdC5sZW5ndGg+Mil7aWYoKHRbMl0mMTkyKSE9PTEyOCl7ZS5sYXN0TmVlZD0yO3JldHVyblwi77+9XCJ9fX19ZnVuY3Rpb24gdXRmOEZpbGxMYXN0KGUpe3ZhciB0PXRoaXMubGFzdFRvdGFsLXRoaXMubGFzdE5lZWQ7dmFyIHI9dXRmOENoZWNrRXh0cmFCeXRlcyh0aGlzLGUsdCk7aWYociE9PXVuZGVmaW5lZClyZXR1cm4gcjtpZih0aGlzLmxhc3ROZWVkPD1lLmxlbmd0aCl7ZS5jb3B5KHRoaXMubGFzdENoYXIsdCwwLHRoaXMubGFzdE5lZWQpO3JldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsMCx0aGlzLmxhc3RUb3RhbCl9ZS5jb3B5KHRoaXMubGFzdENoYXIsdCwwLGUubGVuZ3RoKTt0aGlzLmxhc3ROZWVkLT1lLmxlbmd0aH1mdW5jdGlvbiB1dGY4VGV4dChlLHQpe3ZhciByPXV0ZjhDaGVja0luY29tcGxldGUodGhpcyxlLHQpO2lmKCF0aGlzLmxhc3ROZWVkKXJldHVybiBlLnRvU3RyaW5nKFwidXRmOFwiLHQpO3RoaXMubGFzdFRvdGFsPXI7dmFyIG49ZS5sZW5ndGgtKHItdGhpcy5sYXN0TmVlZCk7ZS5jb3B5KHRoaXMubGFzdENoYXIsMCxuKTtyZXR1cm4gZS50b1N0cmluZyhcInV0ZjhcIix0LG4pfWZ1bmN0aW9uIHV0ZjhFbmQoZSl7dmFyIHQ9ZSYmZS5sZW5ndGg/dGhpcy53cml0ZShlKTpcIlwiO2lmKHRoaXMubGFzdE5lZWQpcmV0dXJuIHQrXCLvv71cIjtyZXR1cm4gdH1mdW5jdGlvbiB1dGYxNlRleHQoZSx0KXtpZigoZS5sZW5ndGgtdCklMj09PTApe3ZhciByPWUudG9TdHJpbmcoXCJ1dGYxNmxlXCIsdCk7aWYocil7dmFyIG49ci5jaGFyQ29kZUF0KHIubGVuZ3RoLTEpO2lmKG4+PTU1Mjk2JiZuPD01NjMxOSl7dGhpcy5sYXN0TmVlZD0yO3RoaXMubGFzdFRvdGFsPTQ7dGhpcy5sYXN0Q2hhclswXT1lW2UubGVuZ3RoLTJdO3RoaXMubGFzdENoYXJbMV09ZVtlLmxlbmd0aC0xXTtyZXR1cm4gci5zbGljZSgwLC0xKX19cmV0dXJuIHJ9dGhpcy5sYXN0TmVlZD0xO3RoaXMubGFzdFRvdGFsPTI7dGhpcy5sYXN0Q2hhclswXT1lW2UubGVuZ3RoLTFdO3JldHVybiBlLnRvU3RyaW5nKFwidXRmMTZsZVwiLHQsZS5sZW5ndGgtMSl9ZnVuY3Rpb24gdXRmMTZFbmQoZSl7dmFyIHQ9ZSYmZS5sZW5ndGg/dGhpcy53cml0ZShlKTpcIlwiO2lmKHRoaXMubGFzdE5lZWQpe3ZhciByPXRoaXMubGFzdFRvdGFsLXRoaXMubGFzdE5lZWQ7cmV0dXJuIHQrdGhpcy5sYXN0Q2hhci50b1N0cmluZyhcInV0ZjE2bGVcIiwwLHIpfXJldHVybiB0fWZ1bmN0aW9uIGJhc2U2NFRleHQoZSx0KXt2YXIgcj0oZS5sZW5ndGgtdCklMztpZihyPT09MClyZXR1cm4gZS50b1N0cmluZyhcImJhc2U2NFwiLHQpO3RoaXMubGFzdE5lZWQ9My1yO3RoaXMubGFzdFRvdGFsPTM7aWYocj09PTEpe3RoaXMubGFzdENoYXJbMF09ZVtlLmxlbmd0aC0xXX1lbHNle3RoaXMubGFzdENoYXJbMF09ZVtlLmxlbmd0aC0yXTt0aGlzLmxhc3RDaGFyWzFdPWVbZS5sZW5ndGgtMV19cmV0dXJuIGUudG9TdHJpbmcoXCJiYXNlNjRcIix0LGUubGVuZ3RoLXIpfWZ1bmN0aW9uIGJhc2U2NEVuZChlKXt2YXIgdD1lJiZlLmxlbmd0aD90aGlzLndyaXRlKGUpOlwiXCI7aWYodGhpcy5sYXN0TmVlZClyZXR1cm4gdCt0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKFwiYmFzZTY0XCIsMCwzLXRoaXMubGFzdE5lZWQpO3JldHVybiB0fWZ1bmN0aW9uIHNpbXBsZVdyaXRlKGUpe3JldHVybiBlLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpfWZ1bmN0aW9uIHNpbXBsZUVuZChlKXtyZXR1cm4gZSYmZS5sZW5ndGg/dGhpcy53cml0ZShlKTpcIlwifX0sMTIxOmZ1bmN0aW9uKGUpe2UuZXhwb3J0cz1kZXByZWNhdGU7ZnVuY3Rpb24gZGVwcmVjYXRlKGUsdCl7aWYoY29uZmlnKFwibm9EZXByZWNhdGlvblwiKSl7cmV0dXJuIGV9dmFyIHI9ZmFsc2U7ZnVuY3Rpb24gZGVwcmVjYXRlZCgpe2lmKCFyKXtpZihjb25maWcoXCJ0aHJvd0RlcHJlY2F0aW9uXCIpKXt0aHJvdyBuZXcgRXJyb3IodCl9ZWxzZSBpZihjb25maWcoXCJ0cmFjZURlcHJlY2F0aW9uXCIpKXtjb25zb2xlLnRyYWNlKHQpfWVsc2V7Y29uc29sZS53YXJuKHQpfXI9dHJ1ZX1yZXR1cm4gZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9cmV0dXJuIGRlcHJlY2F0ZWR9ZnVuY3Rpb24gY29uZmlnKGUpe3RyeXtpZighZ2xvYmFsLmxvY2FsU3RvcmFnZSlyZXR1cm4gZmFsc2V9Y2F0Y2goZSl7cmV0dXJuIGZhbHNlfXZhciB0PWdsb2JhbC5sb2NhbFN0b3JhZ2VbZV07aWYobnVsbD09dClyZXR1cm4gZmFsc2U7cmV0dXJuIFN0cmluZyh0KS50b0xvd2VyQ2FzZSgpPT09XCJ0cnVlXCJ9fSwzMDA6ZnVuY3Rpb24oZSl7XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPXJlcXVpcmUoXCJidWZmZXJcIil9LDM2MTpmdW5jdGlvbihlKXtcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9cmVxdWlyZShcImV2ZW50c1wiKX0sNzgxOmZ1bmN0aW9uKGUpe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1yZXF1aXJlKFwiZXZlbnRzXCIpLkV2ZW50RW1pdHRlcn0sODM3OmZ1bmN0aW9uKGUpe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1yZXF1aXJlKFwidXRpbFwiKX19O3ZhciB0PXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18ocil7dmFyIG49dFtyXTtpZihuIT09dW5kZWZpbmVkKXtyZXR1cm4gbi5leHBvcnRzfXZhciBpPXRbcl09e2V4cG9ydHM6e319O3ZhciBhPXRydWU7dHJ5e2Vbcl0oaSxpLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7YT1mYWxzZX1maW5hbGx5e2lmKGEpZGVsZXRlIHRbcl19cmV0dXJuIGkuZXhwb3J0c31pZih0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyE9PVwidW5kZWZpbmVkXCIpX19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIHI9X19uY2N3cGNrX3JlcXVpcmVfXyg1NjIpO21vZHVsZS5leHBvcnRzPXJ9KSgpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/stream-browserify/index.js\n");

/***/ }),

/***/ "./node_modules/object-is/implementation.js":
/*!**************************************************!*\
  !*** ./node_modules/object-is/implementation.js ***!
  \**************************************************/
/***/ (function(module) {

"use strict";
eval("\r\n\r\nvar numberIsNaN = function (value) {\r\n\treturn value !== value;\r\n};\r\n\r\nmodule.exports = function is(a, b) {\r\n\tif (a === 0 && b === 0) {\r\n\t\treturn 1 / a === 1 / b;\r\n\t}\r\n\tif (a === b) {\r\n\t\treturn true;\r\n\t}\r\n\tif (numberIsNaN(a) && numberIsNaN(b)) {\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n};\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvb2JqZWN0LWlzL2ltcGxlbWVudGF0aW9uLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9vYmplY3QtaXMvaW1wbGVtZW50YXRpb24uanM/MGE4NSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgbnVtYmVySXNOYU4gPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuXHRyZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpcyhhLCBiKSB7XHJcblx0aWYgKGEgPT09IDAgJiYgYiA9PT0gMCkge1xyXG5cdFx0cmV0dXJuIDEgLyBhID09PSAxIC8gYjtcclxuXHR9XHJcblx0aWYgKGEgPT09IGIpIHtcclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH1cclxuXHRpZiAobnVtYmVySXNOYU4oYSkgJiYgbnVtYmVySXNOYU4oYikpIHtcclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH1cclxuXHRyZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/object-is/implementation.js\n");

/***/ }),

/***/ "./node_modules/object-is/index.js":
/*!*****************************************!*\
  !*** ./node_modules/object-is/index.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar define = __webpack_require__(/*! define-properties */ \"./node_modules/define-properties/index.js\");\r\nvar callBind = __webpack_require__(/*! call-bind */ \"./node_modules/call-bind/index.js\");\r\n\r\nvar implementation = __webpack_require__(/*! ./implementation */ \"./node_modules/object-is/implementation.js\");\r\nvar getPolyfill = __webpack_require__(/*! ./polyfill */ \"./node_modules/object-is/polyfill.js\");\r\nvar shim = __webpack_require__(/*! ./shim */ \"./node_modules/object-is/shim.js\");\r\n\r\nvar polyfill = callBind(getPolyfill(), Object);\r\n\r\ndefine(polyfill, {\r\n\tgetPolyfill: getPolyfill,\r\n\timplementation: implementation,\r\n\tshim: shim\r\n});\r\n\r\nmodule.exports = polyfill;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvb2JqZWN0LWlzL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSxhQUFhLG1CQUFPLENBQUMsb0VBQW1CO0FBQ3hDLGVBQWUsbUJBQU8sQ0FBQyxvREFBVztBQUNsQztBQUNBLHFCQUFxQixtQkFBTyxDQUFDLG9FQUFrQjtBQUMvQyxrQkFBa0IsbUJBQU8sQ0FBQyx3REFBWTtBQUN0QyxXQUFXLG1CQUFPLENBQUMsZ0RBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvb2JqZWN0LWlzL2luZGV4LmpzPzYxYzMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGRlZmluZSA9IHJlcXVpcmUoJ2RlZmluZS1wcm9wZXJ0aWVzJyk7XHJcbnZhciBjYWxsQmluZCA9IHJlcXVpcmUoJ2NhbGwtYmluZCcpO1xyXG5cclxudmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xyXG52YXIgZ2V0UG9seWZpbGwgPSByZXF1aXJlKCcuL3BvbHlmaWxsJyk7XHJcbnZhciBzaGltID0gcmVxdWlyZSgnLi9zaGltJyk7XHJcblxyXG52YXIgcG9seWZpbGwgPSBjYWxsQmluZChnZXRQb2x5ZmlsbCgpLCBPYmplY3QpO1xyXG5cclxuZGVmaW5lKHBvbHlmaWxsLCB7XHJcblx0Z2V0UG9seWZpbGw6IGdldFBvbHlmaWxsLFxyXG5cdGltcGxlbWVudGF0aW9uOiBpbXBsZW1lbnRhdGlvbixcclxuXHRzaGltOiBzaGltXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBwb2x5ZmlsbDtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/object-is/index.js\n");

/***/ }),

/***/ "./node_modules/object-is/polyfill.js":
/*!********************************************!*\
  !*** ./node_modules/object-is/polyfill.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar implementation = __webpack_require__(/*! ./implementation */ \"./node_modules/object-is/implementation.js\");\r\n\r\nmodule.exports = function getPolyfill() {\r\n\treturn typeof Object.is === 'function' ? Object.is : implementation;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvb2JqZWN0LWlzL3BvbHlmaWxsLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSxxQkFBcUIsbUJBQU8sQ0FBQyxvRUFBa0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL29iamVjdC1pcy9wb2x5ZmlsbC5qcz82ZGU1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBpbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0UG9seWZpbGwoKSB7XHJcblx0cmV0dXJuIHR5cGVvZiBPYmplY3QuaXMgPT09ICdmdW5jdGlvbicgPyBPYmplY3QuaXMgOiBpbXBsZW1lbnRhdGlvbjtcclxufTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/object-is/polyfill.js\n");

/***/ }),

/***/ "./node_modules/object-is/shim.js":
/*!****************************************!*\
  !*** ./node_modules/object-is/shim.js ***!
  \****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar getPolyfill = __webpack_require__(/*! ./polyfill */ \"./node_modules/object-is/polyfill.js\");\r\nvar define = __webpack_require__(/*! define-properties */ \"./node_modules/define-properties/index.js\");\r\n\r\nmodule.exports = function shimObjectIs() {\r\n\tvar polyfill = getPolyfill();\r\n\tdefine(Object, { is: polyfill }, {\r\n\t\tis: function testObjectIs() {\r\n\t\t\treturn Object.is !== polyfill;\r\n\t\t}\r\n\t});\r\n\treturn polyfill;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvb2JqZWN0LWlzL3NoaW0uanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLHdEQUFZO0FBQ3RDLGFBQWEsbUJBQU8sQ0FBQyxvRUFBbUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL29iamVjdC1pcy9zaGltLmpzPzJmNGEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGdldFBvbHlmaWxsID0gcmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xyXG52YXIgZGVmaW5lID0gcmVxdWlyZSgnZGVmaW5lLXByb3BlcnRpZXMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2hpbU9iamVjdElzKCkge1xyXG5cdHZhciBwb2x5ZmlsbCA9IGdldFBvbHlmaWxsKCk7XHJcblx0ZGVmaW5lKE9iamVjdCwgeyBpczogcG9seWZpbGwgfSwge1xyXG5cdFx0aXM6IGZ1bmN0aW9uIHRlc3RPYmplY3RJcygpIHtcclxuXHRcdFx0cmV0dXJuIE9iamVjdC5pcyAhPT0gcG9seWZpbGw7XHJcblx0XHR9XHJcblx0fSk7XHJcblx0cmV0dXJuIHBvbHlmaWxsO1xyXG59O1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/object-is/shim.js\n");

/***/ }),

/***/ "./node_modules/object-keys/implementation.js":
/*!****************************************************!*\
  !*** ./node_modules/object-keys/implementation.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar keysShim;\r\nif (!Object.keys) {\r\n\t// modified from https://github.com/es-shims/es5-shim\r\n\tvar has = Object.prototype.hasOwnProperty;\r\n\tvar toStr = Object.prototype.toString;\r\n\tvar isArgs = __webpack_require__(/*! ./isArguments */ \"./node_modules/object-keys/isArguments.js\"); // eslint-disable-line global-require\r\n\tvar isEnumerable = Object.prototype.propertyIsEnumerable;\r\n\tvar hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');\r\n\tvar hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');\r\n\tvar dontEnums = [\r\n\t\t'toString',\r\n\t\t'toLocaleString',\r\n\t\t'valueOf',\r\n\t\t'hasOwnProperty',\r\n\t\t'isPrototypeOf',\r\n\t\t'propertyIsEnumerable',\r\n\t\t'constructor'\r\n\t];\r\n\tvar equalsConstructorPrototype = function (o) {\r\n\t\tvar ctor = o.constructor;\r\n\t\treturn ctor && ctor.prototype === o;\r\n\t};\r\n\tvar excludedKeys = {\r\n\t\t$applicationCache: true,\r\n\t\t$console: true,\r\n\t\t$external: true,\r\n\t\t$frame: true,\r\n\t\t$frameElement: true,\r\n\t\t$frames: true,\r\n\t\t$innerHeight: true,\r\n\t\t$innerWidth: true,\r\n\t\t$onmozfullscreenchange: true,\r\n\t\t$onmozfullscreenerror: true,\r\n\t\t$outerHeight: true,\r\n\t\t$outerWidth: true,\r\n\t\t$pageXOffset: true,\r\n\t\t$pageYOffset: true,\r\n\t\t$parent: true,\r\n\t\t$scrollLeft: true,\r\n\t\t$scrollTop: true,\r\n\t\t$scrollX: true,\r\n\t\t$scrollY: true,\r\n\t\t$self: true,\r\n\t\t$webkitIndexedDB: true,\r\n\t\t$webkitStorageInfo: true,\r\n\t\t$window: true\r\n\t};\r\n\tvar hasAutomationEqualityBug = (function () {\r\n\t\t/* global window */\r\n\t\tif (typeof window === 'undefined') { return false; }\r\n\t\tfor (var k in window) {\r\n\t\t\ttry {\r\n\t\t\t\tif (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tequalsConstructorPrototype(window[k]);\r\n\t\t\t\t\t} catch (e) {\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} catch (e) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}());\r\n\tvar equalsConstructorPrototypeIfNotBuggy = function (o) {\r\n\t\t/* global window */\r\n\t\tif (typeof window === 'undefined' || !hasAutomationEqualityBug) {\r\n\t\t\treturn equalsConstructorPrototype(o);\r\n\t\t}\r\n\t\ttry {\r\n\t\t\treturn equalsConstructorPrototype(o);\r\n\t\t} catch (e) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t};\r\n\r\n\tkeysShim = function keys(object) {\r\n\t\tvar isObject = object !== null && typeof object === 'object';\r\n\t\tvar isFunction = toStr.call(object) === '[object Function]';\r\n\t\tvar isArguments = isArgs(object);\r\n\t\tvar isString = isObject && toStr.call(object) === '[object String]';\r\n\t\tvar theKeys = [];\r\n\r\n\t\tif (!isObject && !isFunction && !isArguments) {\r\n\t\t\tthrow new TypeError('Object.keys called on a non-object');\r\n\t\t}\r\n\r\n\t\tvar skipProto = hasProtoEnumBug && isFunction;\r\n\t\tif (isString && object.length > 0 && !has.call(object, 0)) {\r\n\t\t\tfor (var i = 0; i < object.length; ++i) {\r\n\t\t\t\ttheKeys.push(String(i));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (isArguments && object.length > 0) {\r\n\t\t\tfor (var j = 0; j < object.length; ++j) {\r\n\t\t\t\ttheKeys.push(String(j));\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor (var name in object) {\r\n\t\t\t\tif (!(skipProto && name === 'prototype') && has.call(object, name)) {\r\n\t\t\t\t\ttheKeys.push(String(name));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (hasDontEnumBug) {\r\n\t\t\tvar skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);\r\n\r\n\t\t\tfor (var k = 0; k < dontEnums.length; ++k) {\r\n\t\t\t\tif (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {\r\n\t\t\t\t\ttheKeys.push(dontEnums[k]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn theKeys;\r\n\t};\r\n}\r\nmodule.exports = keysShim;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvb2JqZWN0LWtleXMvaW1wbGVtZW50YXRpb24uanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMsZ0VBQWUsR0FBRztBQUN4QztBQUNBLDJDQUEyQyxnQkFBZ0I7QUFDM0QsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvb2JqZWN0LWtleXMvaW1wbGVtZW50YXRpb24uanM/NTBhZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG52YXIga2V5c1NoaW07XHJcbmlmICghT2JqZWN0LmtleXMpIHtcclxuXHQvLyBtb2RpZmllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbVxyXG5cdHZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xyXG5cdHZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XHJcblx0dmFyIGlzQXJncyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBnbG9iYWwtcmVxdWlyZVxyXG5cdHZhciBpc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xyXG5cdHZhciBoYXNEb250RW51bUJ1ZyA9ICFpc0VudW1lcmFibGUuY2FsbCh7IHRvU3RyaW5nOiBudWxsIH0sICd0b1N0cmluZycpO1xyXG5cdHZhciBoYXNQcm90b0VudW1CdWcgPSBpc0VudW1lcmFibGUuY2FsbChmdW5jdGlvbiAoKSB7fSwgJ3Byb3RvdHlwZScpO1xyXG5cdHZhciBkb250RW51bXMgPSBbXHJcblx0XHQndG9TdHJpbmcnLFxyXG5cdFx0J3RvTG9jYWxlU3RyaW5nJyxcclxuXHRcdCd2YWx1ZU9mJyxcclxuXHRcdCdoYXNPd25Qcm9wZXJ0eScsXHJcblx0XHQnaXNQcm90b3R5cGVPZicsXHJcblx0XHQncHJvcGVydHlJc0VudW1lcmFibGUnLFxyXG5cdFx0J2NvbnN0cnVjdG9yJ1xyXG5cdF07XHJcblx0dmFyIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlID0gZnVuY3Rpb24gKG8pIHtcclxuXHRcdHZhciBjdG9yID0gby5jb25zdHJ1Y3RvcjtcclxuXHRcdHJldHVybiBjdG9yICYmIGN0b3IucHJvdG90eXBlID09PSBvO1xyXG5cdH07XHJcblx0dmFyIGV4Y2x1ZGVkS2V5cyA9IHtcclxuXHRcdCRhcHBsaWNhdGlvbkNhY2hlOiB0cnVlLFxyXG5cdFx0JGNvbnNvbGU6IHRydWUsXHJcblx0XHQkZXh0ZXJuYWw6IHRydWUsXHJcblx0XHQkZnJhbWU6IHRydWUsXHJcblx0XHQkZnJhbWVFbGVtZW50OiB0cnVlLFxyXG5cdFx0JGZyYW1lczogdHJ1ZSxcclxuXHRcdCRpbm5lckhlaWdodDogdHJ1ZSxcclxuXHRcdCRpbm5lcldpZHRoOiB0cnVlLFxyXG5cdFx0JG9ubW96ZnVsbHNjcmVlbmNoYW5nZTogdHJ1ZSxcclxuXHRcdCRvbm1vemZ1bGxzY3JlZW5lcnJvcjogdHJ1ZSxcclxuXHRcdCRvdXRlckhlaWdodDogdHJ1ZSxcclxuXHRcdCRvdXRlcldpZHRoOiB0cnVlLFxyXG5cdFx0JHBhZ2VYT2Zmc2V0OiB0cnVlLFxyXG5cdFx0JHBhZ2VZT2Zmc2V0OiB0cnVlLFxyXG5cdFx0JHBhcmVudDogdHJ1ZSxcclxuXHRcdCRzY3JvbGxMZWZ0OiB0cnVlLFxyXG5cdFx0JHNjcm9sbFRvcDogdHJ1ZSxcclxuXHRcdCRzY3JvbGxYOiB0cnVlLFxyXG5cdFx0JHNjcm9sbFk6IHRydWUsXHJcblx0XHQkc2VsZjogdHJ1ZSxcclxuXHRcdCR3ZWJraXRJbmRleGVkREI6IHRydWUsXHJcblx0XHQkd2Via2l0U3RvcmFnZUluZm86IHRydWUsXHJcblx0XHQkd2luZG93OiB0cnVlXHJcblx0fTtcclxuXHR2YXIgaGFzQXV0b21hdGlvbkVxdWFsaXR5QnVnID0gKGZ1bmN0aW9uICgpIHtcclxuXHRcdC8qIGdsb2JhbCB3aW5kb3cgKi9cclxuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgeyByZXR1cm4gZmFsc2U7IH1cclxuXHRcdGZvciAodmFyIGsgaW4gd2luZG93KSB7XHJcblx0XHRcdHRyeSB7XHJcblx0XHRcdFx0aWYgKCFleGNsdWRlZEtleXNbJyQnICsga10gJiYgaGFzLmNhbGwod2luZG93LCBrKSAmJiB3aW5kb3dba10gIT09IG51bGwgJiYgdHlwZW9mIHdpbmRvd1trXSA9PT0gJ29iamVjdCcpIHtcclxuXHRcdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHRcdGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlKHdpbmRvd1trXSk7XHJcblx0XHRcdFx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBjYXRjaCAoZSkge1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fSgpKTtcclxuXHR2YXIgZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGVJZk5vdEJ1Z2d5ID0gZnVuY3Rpb24gKG8pIHtcclxuXHRcdC8qIGdsb2JhbCB3aW5kb3cgKi9cclxuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhaGFzQXV0b21hdGlvbkVxdWFsaXR5QnVnKSB7XHJcblx0XHRcdHJldHVybiBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZShvKTtcclxuXHRcdH1cclxuXHRcdHRyeSB7XHJcblx0XHRcdHJldHVybiBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZShvKTtcclxuXHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdGtleXNTaGltID0gZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcclxuXHRcdHZhciBpc09iamVjdCA9IG9iamVjdCAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JztcclxuXHRcdHZhciBpc0Z1bmN0aW9uID0gdG9TdHIuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xyXG5cdFx0dmFyIGlzQXJndW1lbnRzID0gaXNBcmdzKG9iamVjdCk7XHJcblx0XHR2YXIgaXNTdHJpbmcgPSBpc09iamVjdCAmJiB0b1N0ci5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xyXG5cdFx0dmFyIHRoZUtleXMgPSBbXTtcclxuXHJcblx0XHRpZiAoIWlzT2JqZWN0ICYmICFpc0Z1bmN0aW9uICYmICFpc0FyZ3VtZW50cykge1xyXG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3Qua2V5cyBjYWxsZWQgb24gYSBub24tb2JqZWN0Jyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHNraXBQcm90byA9IGhhc1Byb3RvRW51bUJ1ZyAmJiBpc0Z1bmN0aW9uO1xyXG5cdFx0aWYgKGlzU3RyaW5nICYmIG9iamVjdC5sZW5ndGggPiAwICYmICFoYXMuY2FsbChvYmplY3QsIDApKSB7XHJcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0Lmxlbmd0aDsgKytpKSB7XHJcblx0XHRcdFx0dGhlS2V5cy5wdXNoKFN0cmluZyhpKSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoaXNBcmd1bWVudHMgJiYgb2JqZWN0Lmxlbmd0aCA+IDApIHtcclxuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBvYmplY3QubGVuZ3RoOyArK2opIHtcclxuXHRcdFx0XHR0aGVLZXlzLnB1c2goU3RyaW5nKGopKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Zm9yICh2YXIgbmFtZSBpbiBvYmplY3QpIHtcclxuXHRcdFx0XHRpZiAoIShza2lwUHJvdG8gJiYgbmFtZSA9PT0gJ3Byb3RvdHlwZScpICYmIGhhcy5jYWxsKG9iamVjdCwgbmFtZSkpIHtcclxuXHRcdFx0XHRcdHRoZUtleXMucHVzaChTdHJpbmcobmFtZSkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChoYXNEb250RW51bUJ1Zykge1xyXG5cdFx0XHR2YXIgc2tpcENvbnN0cnVjdG9yID0gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGVJZk5vdEJ1Z2d5KG9iamVjdCk7XHJcblxyXG5cdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IGRvbnRFbnVtcy5sZW5ndGg7ICsraykge1xyXG5cdFx0XHRcdGlmICghKHNraXBDb25zdHJ1Y3RvciAmJiBkb250RW51bXNba10gPT09ICdjb25zdHJ1Y3RvcicpICYmIGhhcy5jYWxsKG9iamVjdCwgZG9udEVudW1zW2tdKSkge1xyXG5cdFx0XHRcdFx0dGhlS2V5cy5wdXNoKGRvbnRFbnVtc1trXSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhlS2V5cztcclxuXHR9O1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0ga2V5c1NoaW07XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/object-keys/implementation.js\n");

/***/ }),

/***/ "./node_modules/object-keys/index.js":
/*!*******************************************!*\
  !*** ./node_modules/object-keys/index.js ***!
  \*******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar slice = Array.prototype.slice;\r\nvar isArgs = __webpack_require__(/*! ./isArguments */ \"./node_modules/object-keys/isArguments.js\");\r\n\r\nvar origKeys = Object.keys;\r\nvar keysShim = origKeys ? function keys(o) { return origKeys(o); } : __webpack_require__(/*! ./implementation */ \"./node_modules/object-keys/implementation.js\");\r\n\r\nvar originalKeys = Object.keys;\r\n\r\nkeysShim.shim = function shimObjectKeys() {\r\n\tif (Object.keys) {\r\n\t\tvar keysWorksWithArguments = (function () {\r\n\t\t\t// Safari 5.0 bug\r\n\t\t\tvar args = Object.keys(arguments);\r\n\t\t\treturn args && args.length === arguments.length;\r\n\t\t}(1, 2));\r\n\t\tif (!keysWorksWithArguments) {\r\n\t\t\tObject.keys = function keys(object) { // eslint-disable-line func-name-matching\r\n\t\t\t\tif (isArgs(object)) {\r\n\t\t\t\t\treturn originalKeys(slice.call(object));\r\n\t\t\t\t}\r\n\t\t\t\treturn originalKeys(object);\r\n\t\t\t};\r\n\t\t}\r\n\t} else {\r\n\t\tObject.keys = keysShim;\r\n\t}\r\n\treturn Object.keys || keysShim;\r\n};\r\n\r\nmodule.exports = keysShim;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvb2JqZWN0LWtleXMvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLGdFQUFlO0FBQ3BDO0FBQ0E7QUFDQSw2Q0FBNkMsc0JBQXNCLEVBQUUsbUJBQU8sQ0FBQyxzRUFBa0I7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL29iamVjdC1rZXlzL2luZGV4LmpzPzZlYjAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xyXG52YXIgaXNBcmdzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpO1xyXG5cclxudmFyIG9yaWdLZXlzID0gT2JqZWN0LmtleXM7XHJcbnZhciBrZXlzU2hpbSA9IG9yaWdLZXlzID8gZnVuY3Rpb24ga2V5cyhvKSB7IHJldHVybiBvcmlnS2V5cyhvKTsgfSA6IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcclxuXHJcbnZhciBvcmlnaW5hbEtleXMgPSBPYmplY3Qua2V5cztcclxuXHJcbmtleXNTaGltLnNoaW0gPSBmdW5jdGlvbiBzaGltT2JqZWN0S2V5cygpIHtcclxuXHRpZiAoT2JqZWN0LmtleXMpIHtcclxuXHRcdHZhciBrZXlzV29ya3NXaXRoQXJndW1lbnRzID0gKGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0Ly8gU2FmYXJpIDUuMCBidWdcclxuXHRcdFx0dmFyIGFyZ3MgPSBPYmplY3Qua2V5cyhhcmd1bWVudHMpO1xyXG5cdFx0XHRyZXR1cm4gYXJncyAmJiBhcmdzLmxlbmd0aCA9PT0gYXJndW1lbnRzLmxlbmd0aDtcclxuXHRcdH0oMSwgMikpO1xyXG5cdFx0aWYgKCFrZXlzV29ya3NXaXRoQXJndW1lbnRzKSB7XHJcblx0XHRcdE9iamVjdC5rZXlzID0gZnVuY3Rpb24ga2V5cyhvYmplY3QpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBmdW5jLW5hbWUtbWF0Y2hpbmdcclxuXHRcdFx0XHRpZiAoaXNBcmdzKG9iamVjdCkpIHtcclxuXHRcdFx0XHRcdHJldHVybiBvcmlnaW5hbEtleXMoc2xpY2UuY2FsbChvYmplY3QpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIG9yaWdpbmFsS2V5cyhvYmplY3QpO1xyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cdH0gZWxzZSB7XHJcblx0XHRPYmplY3Qua2V5cyA9IGtleXNTaGltO1xyXG5cdH1cclxuXHRyZXR1cm4gT2JqZWN0LmtleXMgfHwga2V5c1NoaW07XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGtleXNTaGltO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/object-keys/index.js\n");

/***/ }),

/***/ "./node_modules/object-keys/isArguments.js":
/*!*************************************************!*\
  !*** ./node_modules/object-keys/isArguments.js ***!
  \*************************************************/
/***/ (function(module) {

"use strict";
eval("\r\n\r\nvar toStr = Object.prototype.toString;\r\n\r\nmodule.exports = function isArguments(value) {\r\n\tvar str = toStr.call(value);\r\n\tvar isArgs = str === '[object Arguments]';\r\n\tif (!isArgs) {\r\n\t\tisArgs = str !== '[object Array]' &&\r\n\t\t\tvalue !== null &&\r\n\t\t\ttypeof value === 'object' &&\r\n\t\t\ttypeof value.length === 'number' &&\r\n\t\t\tvalue.length >= 0 &&\r\n\t\t\ttoStr.call(value.callee) === '[object Function]';\r\n\t}\r\n\treturn isArgs;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvb2JqZWN0LWtleXMvaXNBcmd1bWVudHMuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvb2JqZWN0LWtleXMvaXNBcmd1bWVudHMuanM/MjE4YSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xyXG5cdHZhciBzdHIgPSB0b1N0ci5jYWxsKHZhbHVlKTtcclxuXHR2YXIgaXNBcmdzID0gc3RyID09PSAnW29iamVjdCBBcmd1bWVudHNdJztcclxuXHRpZiAoIWlzQXJncykge1xyXG5cdFx0aXNBcmdzID0gc3RyICE9PSAnW29iamVjdCBBcnJheV0nICYmXHJcblx0XHRcdHZhbHVlICE9PSBudWxsICYmXHJcblx0XHRcdHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcclxuXHRcdFx0dHlwZW9mIHZhbHVlLmxlbmd0aCA9PT0gJ251bWJlcicgJiZcclxuXHRcdFx0dmFsdWUubGVuZ3RoID49IDAgJiZcclxuXHRcdFx0dG9TdHIuY2FsbCh2YWx1ZS5jYWxsZWUpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xyXG5cdH1cclxuXHRyZXR1cm4gaXNBcmdzO1xyXG59O1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/object-keys/isArguments.js\n");

/***/ }),

/***/ "./node_modules/oblivious-set/dist/es/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/oblivious-set/dist/es/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ObliviousSet\": function() { return /* binding */ ObliviousSet; },\n/* harmony export */   \"removeTooOldValues\": function() { return /* binding */ removeTooOldValues; },\n/* harmony export */   \"now\": function() { return /* binding */ now; }\n/* harmony export */ });\n/**\r\n * this is a set which automatically forgets\r\n * a given entry when a new entry is set and the ttl\r\n * of the old one is over\r\n */\r\nvar ObliviousSet = /** @class */ (function () {\r\n    function ObliviousSet(ttl) {\r\n        this.ttl = ttl;\r\n        this.set = new Set();\r\n        this.timeMap = new Map();\r\n    }\r\n    ObliviousSet.prototype.has = function (value) {\r\n        return this.set.has(value);\r\n    };\r\n    ObliviousSet.prototype.add = function (value) {\r\n        var _this = this;\r\n        this.timeMap.set(value, now());\r\n        this.set.add(value);\r\n        /**\r\n         * When a new value is added,\r\n         * start the cleanup at the next tick\r\n         * to not block the cpu for more important stuff\r\n         * that might happen.\r\n         */\r\n        setTimeout(function () {\r\n            removeTooOldValues(_this);\r\n        }, 0);\r\n    };\r\n    ObliviousSet.prototype.clear = function () {\r\n        this.set.clear();\r\n        this.timeMap.clear();\r\n    };\r\n    return ObliviousSet;\r\n}());\r\n\r\n/**\r\n * Removes all entries from the set\r\n * where the TTL has expired\r\n */\r\nfunction removeTooOldValues(obliviousSet) {\r\n    var olderThen = now() - obliviousSet.ttl;\r\n    var iterator = obliviousSet.set[Symbol.iterator]();\r\n    /**\r\n     * Because we can assume the new values are added at the bottom,\r\n     * we start from the top and stop as soon as we reach a non-too-old value.\r\n     */\r\n    while (true) {\r\n        var value = iterator.next().value;\r\n        if (!value) {\r\n            return; // no more elements\r\n        }\r\n        var time = obliviousSet.timeMap.get(value);\r\n        if (time < olderThen) {\r\n            obliviousSet.timeMap.delete(value);\r\n            obliviousSet.set.delete(value);\r\n        }\r\n        else {\r\n            // We reached a value that is not old enough\r\n            return;\r\n        }\r\n    }\r\n}\r\nfunction now() {\r\n    return new Date().getTime();\r\n}\r\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvb2JsaXZpb3VzLXNldC9kaXN0L2VzL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUN1QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9vYmxpdmlvdXMtc2V0L2Rpc3QvZXMvaW5kZXguanM/ZTc5YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogdGhpcyBpcyBhIHNldCB3aGljaCBhdXRvbWF0aWNhbGx5IGZvcmdldHNcclxuICogYSBnaXZlbiBlbnRyeSB3aGVuIGEgbmV3IGVudHJ5IGlzIHNldCBhbmQgdGhlIHR0bFxyXG4gKiBvZiB0aGUgb2xkIG9uZSBpcyBvdmVyXHJcbiAqL1xyXG52YXIgT2JsaXZpb3VzU2V0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gT2JsaXZpb3VzU2V0KHR0bCkge1xyXG4gICAgICAgIHRoaXMudHRsID0gdHRsO1xyXG4gICAgICAgIHRoaXMuc2V0ID0gbmV3IFNldCgpO1xyXG4gICAgICAgIHRoaXMudGltZU1hcCA9IG5ldyBNYXAoKTtcclxuICAgIH1cclxuICAgIE9ibGl2aW91c1NldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0Lmhhcyh2YWx1ZSk7XHJcbiAgICB9O1xyXG4gICAgT2JsaXZpb3VzU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMudGltZU1hcC5zZXQodmFsdWUsIG5vdygpKTtcclxuICAgICAgICB0aGlzLnNldC5hZGQodmFsdWUpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdoZW4gYSBuZXcgdmFsdWUgaXMgYWRkZWQsXHJcbiAgICAgICAgICogc3RhcnQgdGhlIGNsZWFudXAgYXQgdGhlIG5leHQgdGlja1xyXG4gICAgICAgICAqIHRvIG5vdCBibG9jayB0aGUgY3B1IGZvciBtb3JlIGltcG9ydGFudCBzdHVmZlxyXG4gICAgICAgICAqIHRoYXQgbWlnaHQgaGFwcGVuLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZW1vdmVUb29PbGRWYWx1ZXMoX3RoaXMpO1xyXG4gICAgICAgIH0sIDApO1xyXG4gICAgfTtcclxuICAgIE9ibGl2aW91c1NldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5zZXQuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLnRpbWVNYXAuY2xlYXIoKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gT2JsaXZpb3VzU2V0O1xyXG59KCkpO1xyXG5leHBvcnQgeyBPYmxpdmlvdXNTZXQgfTtcclxuLyoqXHJcbiAqIFJlbW92ZXMgYWxsIGVudHJpZXMgZnJvbSB0aGUgc2V0XHJcbiAqIHdoZXJlIHRoZSBUVEwgaGFzIGV4cGlyZWRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVUb29PbGRWYWx1ZXMob2JsaXZpb3VzU2V0KSB7XHJcbiAgICB2YXIgb2xkZXJUaGVuID0gbm93KCkgLSBvYmxpdmlvdXNTZXQudHRsO1xyXG4gICAgdmFyIGl0ZXJhdG9yID0gb2JsaXZpb3VzU2V0LnNldFtTeW1ib2wuaXRlcmF0b3JdKCk7XHJcbiAgICAvKipcclxuICAgICAqIEJlY2F1c2Ugd2UgY2FuIGFzc3VtZSB0aGUgbmV3IHZhbHVlcyBhcmUgYWRkZWQgYXQgdGhlIGJvdHRvbSxcclxuICAgICAqIHdlIHN0YXJ0IGZyb20gdGhlIHRvcCBhbmQgc3RvcCBhcyBzb29uIGFzIHdlIHJlYWNoIGEgbm9uLXRvby1vbGQgdmFsdWUuXHJcbiAgICAgKi9cclxuICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gaXRlcmF0b3IubmV4dCgpLnZhbHVlO1xyXG4gICAgICAgIGlmICghdmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuOyAvLyBubyBtb3JlIGVsZW1lbnRzXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB0aW1lID0gb2JsaXZpb3VzU2V0LnRpbWVNYXAuZ2V0KHZhbHVlKTtcclxuICAgICAgICBpZiAodGltZSA8IG9sZGVyVGhlbikge1xyXG4gICAgICAgICAgICBvYmxpdmlvdXNTZXQudGltZU1hcC5kZWxldGUodmFsdWUpO1xyXG4gICAgICAgICAgICBvYmxpdmlvdXNTZXQuc2V0LmRlbGV0ZSh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBXZSByZWFjaGVkIGEgdmFsdWUgdGhhdCBpcyBub3Qgb2xkIGVub3VnaFxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBub3coKSB7XHJcbiAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/oblivious-set/dist/es/index.js\n");

/***/ }),

/***/ "./node_modules/once/once.js":
/*!***********************************!*\
  !*** ./node_modules/once/once.js ***!
  \***********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var wrappy = __webpack_require__(/*! wrappy */ \"./node_modules/wrappy/wrappy.js\")\r\nmodule.exports = wrappy(once)\r\nmodule.exports.strict = wrappy(onceStrict)\r\n\r\nonce.proto = once(function () {\r\n  Object.defineProperty(Function.prototype, 'once', {\r\n    value: function () {\r\n      return once(this)\r\n    },\r\n    configurable: true\r\n  })\r\n\r\n  Object.defineProperty(Function.prototype, 'onceStrict', {\r\n    value: function () {\r\n      return onceStrict(this)\r\n    },\r\n    configurable: true\r\n  })\r\n})\r\n\r\nfunction once (fn) {\r\n  var f = function () {\r\n    if (f.called) return f.value\r\n    f.called = true\r\n    return f.value = fn.apply(this, arguments)\r\n  }\r\n  f.called = false\r\n  return f\r\n}\r\n\r\nfunction onceStrict (fn) {\r\n  var f = function () {\r\n    if (f.called)\r\n      throw new Error(f.onceError)\r\n    f.called = true\r\n    return f.value = fn.apply(this, arguments)\r\n  }\r\n  var name = fn.name || 'Function wrapped with `once`'\r\n  f.onceError = name + \" shouldn't be called more than once\"\r\n  f.called = false\r\n  return f\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvb25jZS9vbmNlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLGFBQWEsbUJBQU8sQ0FBQywrQ0FBUTtBQUM3QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9vbmNlL29uY2UuanM/NTNiOCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgd3JhcHB5ID0gcmVxdWlyZSgnd3JhcHB5JylcclxubW9kdWxlLmV4cG9ydHMgPSB3cmFwcHkob25jZSlcclxubW9kdWxlLmV4cG9ydHMuc3RyaWN0ID0gd3JhcHB5KG9uY2VTdHJpY3QpXHJcblxyXG5vbmNlLnByb3RvID0gb25jZShmdW5jdGlvbiAoKSB7XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1bmN0aW9uLnByb3RvdHlwZSwgJ29uY2UnLCB7XHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gb25jZSh0aGlzKVxyXG4gICAgfSxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gIH0pXHJcblxyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGdW5jdGlvbi5wcm90b3R5cGUsICdvbmNlU3RyaWN0Jywge1xyXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIG9uY2VTdHJpY3QodGhpcylcclxuICAgIH0sXHJcbiAgICBjb25maWd1cmFibGU6IHRydWVcclxuICB9KVxyXG59KVxyXG5cclxuZnVuY3Rpb24gb25jZSAoZm4pIHtcclxuICB2YXIgZiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmIChmLmNhbGxlZCkgcmV0dXJuIGYudmFsdWVcclxuICAgIGYuY2FsbGVkID0gdHJ1ZVxyXG4gICAgcmV0dXJuIGYudmFsdWUgPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXHJcbiAgfVxyXG4gIGYuY2FsbGVkID0gZmFsc2VcclxuICByZXR1cm4gZlxyXG59XHJcblxyXG5mdW5jdGlvbiBvbmNlU3RyaWN0IChmbikge1xyXG4gIHZhciBmID0gZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKGYuY2FsbGVkKVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZi5vbmNlRXJyb3IpXHJcbiAgICBmLmNhbGxlZCA9IHRydWVcclxuICAgIHJldHVybiBmLnZhbHVlID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKVxyXG4gIH1cclxuICB2YXIgbmFtZSA9IGZuLm5hbWUgfHwgJ0Z1bmN0aW9uIHdyYXBwZWQgd2l0aCBgb25jZWAnXHJcbiAgZi5vbmNlRXJyb3IgPSBuYW1lICsgXCIgc2hvdWxkbid0IGJlIGNhbGxlZCBtb3JlIHRoYW4gb25jZVwiXHJcbiAgZi5jYWxsZWQgPSBmYWxzZVxyXG4gIHJldHVybiBmXHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/once/once.js\n");

/***/ }),

/***/ "./node_modules/pump/index.js":
/*!************************************!*\
  !*** ./node_modules/pump/index.js ***!
  \************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/process/browser.js\");\nvar once = __webpack_require__(/*! once */ \"./node_modules/once/once.js\")\r\nvar eos = __webpack_require__(/*! end-of-stream */ \"./node_modules/end-of-stream/index.js\")\r\nvar fs = __webpack_require__(/*! fs */ \"?7a07\") // we only need fs to get the ReadStream and WriteStream prototypes\r\n\r\nvar noop = function () {}\r\nvar ancient = /^v?\\.0/.test(process.version)\r\n\r\nvar isFn = function (fn) {\r\n  return typeof fn === 'function'\r\n}\r\n\r\nvar isFS = function (stream) {\r\n  if (!ancient) return false // newer node version do not need to care about fs is a special way\r\n  if (!fs) return false // browser\r\n  return (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) && isFn(stream.close)\r\n}\r\n\r\nvar isRequest = function (stream) {\r\n  return stream.setHeader && isFn(stream.abort)\r\n}\r\n\r\nvar destroyer = function (stream, reading, writing, callback) {\r\n  callback = once(callback)\r\n\r\n  var closed = false\r\n  stream.on('close', function () {\r\n    closed = true\r\n  })\r\n\r\n  eos(stream, {readable: reading, writable: writing}, function (err) {\r\n    if (err) return callback(err)\r\n    closed = true\r\n    callback()\r\n  })\r\n\r\n  var destroyed = false\r\n  return function (err) {\r\n    if (closed) return\r\n    if (destroyed) return\r\n    destroyed = true\r\n\r\n    if (isFS(stream)) return stream.close(noop) // use close for fs streams to avoid fd leaks\r\n    if (isRequest(stream)) return stream.abort() // request.destroy just do .end - .abort is what we want\r\n\r\n    if (isFn(stream.destroy)) return stream.destroy()\r\n\r\n    callback(err || new Error('stream was destroyed'))\r\n  }\r\n}\r\n\r\nvar call = function (fn) {\r\n  fn()\r\n}\r\n\r\nvar pipe = function (from, to) {\r\n  return from.pipe(to)\r\n}\r\n\r\nvar pump = function () {\r\n  var streams = Array.prototype.slice.call(arguments)\r\n  var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop\r\n\r\n  if (Array.isArray(streams[0])) streams = streams[0]\r\n  if (streams.length < 2) throw new Error('pump requires two streams per minimum')\r\n\r\n  var error\r\n  var destroys = streams.map(function (stream, i) {\r\n    var reading = i < streams.length - 1\r\n    var writing = i > 0\r\n    return destroyer(stream, reading, writing, function (err) {\r\n      if (!error) error = err\r\n      if (err) destroys.forEach(call)\r\n      if (reading) return\r\n      destroys.forEach(call)\r\n      callback(error)\r\n    })\r\n  })\r\n\r\n  return streams.reduce(pipe)\r\n}\r\n\r\nmodule.exports = pump\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHVtcC9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsV0FBVyxtQkFBTyxDQUFDLHlDQUFNO0FBQ3pCLFVBQVUsbUJBQU8sQ0FBQyw0REFBZTtBQUNqQyxTQUFTLG1CQUFPLENBQUMsaUJBQUk7QUFDckI7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGVBQWUscUNBQXFDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wdW1wL2luZGV4LmpzPzMzZGQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIG9uY2UgPSByZXF1aXJlKCdvbmNlJylcclxudmFyIGVvcyA9IHJlcXVpcmUoJ2VuZC1vZi1zdHJlYW0nKVxyXG52YXIgZnMgPSByZXF1aXJlKCdmcycpIC8vIHdlIG9ubHkgbmVlZCBmcyB0byBnZXQgdGhlIFJlYWRTdHJlYW0gYW5kIFdyaXRlU3RyZWFtIHByb3RvdHlwZXNcclxuXHJcbnZhciBub29wID0gZnVuY3Rpb24gKCkge31cclxudmFyIGFuY2llbnQgPSAvXnY/XFwuMC8udGVzdChwcm9jZXNzLnZlcnNpb24pXHJcblxyXG52YXIgaXNGbiA9IGZ1bmN0aW9uIChmbikge1xyXG4gIHJldHVybiB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbidcclxufVxyXG5cclxudmFyIGlzRlMgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XHJcbiAgaWYgKCFhbmNpZW50KSByZXR1cm4gZmFsc2UgLy8gbmV3ZXIgbm9kZSB2ZXJzaW9uIGRvIG5vdCBuZWVkIHRvIGNhcmUgYWJvdXQgZnMgaXMgYSBzcGVjaWFsIHdheVxyXG4gIGlmICghZnMpIHJldHVybiBmYWxzZSAvLyBicm93c2VyXHJcbiAgcmV0dXJuIChzdHJlYW0gaW5zdGFuY2VvZiAoZnMuUmVhZFN0cmVhbSB8fCBub29wKSB8fCBzdHJlYW0gaW5zdGFuY2VvZiAoZnMuV3JpdGVTdHJlYW0gfHwgbm9vcCkpICYmIGlzRm4oc3RyZWFtLmNsb3NlKVxyXG59XHJcblxyXG52YXIgaXNSZXF1ZXN0ID0gZnVuY3Rpb24gKHN0cmVhbSkge1xyXG4gIHJldHVybiBzdHJlYW0uc2V0SGVhZGVyICYmIGlzRm4oc3RyZWFtLmFib3J0KVxyXG59XHJcblxyXG52YXIgZGVzdHJveWVyID0gZnVuY3Rpb24gKHN0cmVhbSwgcmVhZGluZywgd3JpdGluZywgY2FsbGJhY2spIHtcclxuICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2spXHJcblxyXG4gIHZhciBjbG9zZWQgPSBmYWxzZVxyXG4gIHN0cmVhbS5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICBjbG9zZWQgPSB0cnVlXHJcbiAgfSlcclxuXHJcbiAgZW9zKHN0cmVhbSwge3JlYWRhYmxlOiByZWFkaW5nLCB3cml0YWJsZTogd3JpdGluZ30sIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXHJcbiAgICBjbG9zZWQgPSB0cnVlXHJcbiAgICBjYWxsYmFjaygpXHJcbiAgfSlcclxuXHJcbiAgdmFyIGRlc3Ryb3llZCA9IGZhbHNlXHJcbiAgcmV0dXJuIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgIGlmIChjbG9zZWQpIHJldHVyblxyXG4gICAgaWYgKGRlc3Ryb3llZCkgcmV0dXJuXHJcbiAgICBkZXN0cm95ZWQgPSB0cnVlXHJcblxyXG4gICAgaWYgKGlzRlMoc3RyZWFtKSkgcmV0dXJuIHN0cmVhbS5jbG9zZShub29wKSAvLyB1c2UgY2xvc2UgZm9yIGZzIHN0cmVhbXMgdG8gYXZvaWQgZmQgbGVha3NcclxuICAgIGlmIChpc1JlcXVlc3Qoc3RyZWFtKSkgcmV0dXJuIHN0cmVhbS5hYm9ydCgpIC8vIHJlcXVlc3QuZGVzdHJveSBqdXN0IGRvIC5lbmQgLSAuYWJvcnQgaXMgd2hhdCB3ZSB3YW50XHJcblxyXG4gICAgaWYgKGlzRm4oc3RyZWFtLmRlc3Ryb3kpKSByZXR1cm4gc3RyZWFtLmRlc3Ryb3koKVxyXG5cclxuICAgIGNhbGxiYWNrKGVyciB8fCBuZXcgRXJyb3IoJ3N0cmVhbSB3YXMgZGVzdHJveWVkJykpXHJcbiAgfVxyXG59XHJcblxyXG52YXIgY2FsbCA9IGZ1bmN0aW9uIChmbikge1xyXG4gIGZuKClcclxufVxyXG5cclxudmFyIHBpcGUgPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcclxuICByZXR1cm4gZnJvbS5waXBlKHRvKVxyXG59XHJcblxyXG52YXIgcHVtcCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgc3RyZWFtcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cylcclxuICB2YXIgY2FsbGJhY2sgPSBpc0ZuKHN0cmVhbXNbc3RyZWFtcy5sZW5ndGggLSAxXSB8fCBub29wKSAmJiBzdHJlYW1zLnBvcCgpIHx8IG5vb3BcclxuXHJcbiAgaWYgKEFycmF5LmlzQXJyYXkoc3RyZWFtc1swXSkpIHN0cmVhbXMgPSBzdHJlYW1zWzBdXHJcbiAgaWYgKHN0cmVhbXMubGVuZ3RoIDwgMikgdGhyb3cgbmV3IEVycm9yKCdwdW1wIHJlcXVpcmVzIHR3byBzdHJlYW1zIHBlciBtaW5pbXVtJylcclxuXHJcbiAgdmFyIGVycm9yXHJcbiAgdmFyIGRlc3Ryb3lzID0gc3RyZWFtcy5tYXAoZnVuY3Rpb24gKHN0cmVhbSwgaSkge1xyXG4gICAgdmFyIHJlYWRpbmcgPSBpIDwgc3RyZWFtcy5sZW5ndGggLSAxXHJcbiAgICB2YXIgd3JpdGluZyA9IGkgPiAwXHJcbiAgICByZXR1cm4gZGVzdHJveWVyKHN0cmVhbSwgcmVhZGluZywgd3JpdGluZywgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICBpZiAoIWVycm9yKSBlcnJvciA9IGVyclxyXG4gICAgICBpZiAoZXJyKSBkZXN0cm95cy5mb3JFYWNoKGNhbGwpXHJcbiAgICAgIGlmIChyZWFkaW5nKSByZXR1cm5cclxuICAgICAgZGVzdHJveXMuZm9yRWFjaChjYWxsKVxyXG4gICAgICBjYWxsYmFjayhlcnJvcilcclxuICAgIH0pXHJcbiAgfSlcclxuXHJcbiAgcmV0dXJuIHN0cmVhbXMucmVkdWNlKHBpcGUpXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gcHVtcFxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/pump/index.js\n");

/***/ }),

/***/ "./node_modules/randombytes/browser.js":
/*!*********************************************!*\
  !*** ./node_modules/randombytes/browser.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/process/browser.js\");\n\r\n\r\n// limit of Crypto.getRandomValues()\r\n// https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues\r\nvar MAX_BYTES = 65536\r\n\r\n// Node supports requesting up to this number of bytes\r\n// https://github.com/nodejs/node/blob/master/lib/internal/crypto/random.js#L48\r\nvar MAX_UINT32 = 4294967295\r\n\r\nfunction oldBrowser () {\r\n  throw new Error('Secure random number generation is not supported by this browser.\\nUse Chrome, Firefox or Internet Explorer 11')\r\n}\r\n\r\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer)\r\nvar crypto = __webpack_require__.g.crypto || __webpack_require__.g.msCrypto\r\n\r\nif (crypto && crypto.getRandomValues) {\r\n  module.exports = randomBytes\r\n} else {\r\n  module.exports = oldBrowser\r\n}\r\n\r\nfunction randomBytes (size, cb) {\r\n  // phantomjs needs to throw\r\n  if (size > MAX_UINT32) throw new RangeError('requested too many random bytes')\r\n\r\n  var bytes = Buffer.allocUnsafe(size)\r\n\r\n  if (size > 0) {  // getRandomValues fails on IE if size == 0\r\n    if (size > MAX_BYTES) { // this is the max bytes crypto.getRandomValues\r\n      // can do at once see https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues\r\n      for (var generated = 0; generated < size; generated += MAX_BYTES) {\r\n        // buffer.slice automatically checks if the end is past the end of\r\n        // the buffer so we don't have to here\r\n        crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES))\r\n      }\r\n    } else {\r\n      crypto.getRandomValues(bytes)\r\n    }\r\n  }\r\n\r\n  if (typeof cb === 'function') {\r\n    return process.nextTick(function () {\r\n      cb(null, bytes)\r\n    })\r\n  }\r\n\r\n  return bytes\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmFuZG9tYnl0ZXMvYnJvd3Nlci5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsc0ZBQTZCO0FBQzFDLGFBQWEscUJBQU0sV0FBVyxxQkFBTTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLDRCQUE0QjtBQUM1QjtBQUNBLDhCQUE4QixrQkFBa0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmFuZG9tYnl0ZXMvYnJvd3Nlci5qcz83YjhiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xyXG5cclxuLy8gbGltaXQgb2YgQ3J5cHRvLmdldFJhbmRvbVZhbHVlcygpXHJcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DcnlwdG8vZ2V0UmFuZG9tVmFsdWVzXHJcbnZhciBNQVhfQllURVMgPSA2NTUzNlxyXG5cclxuLy8gTm9kZSBzdXBwb3J0cyByZXF1ZXN0aW5nIHVwIHRvIHRoaXMgbnVtYmVyIG9mIGJ5dGVzXHJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL21hc3Rlci9saWIvaW50ZXJuYWwvY3J5cHRvL3JhbmRvbS5qcyNMNDhcclxudmFyIE1BWF9VSU5UMzIgPSA0Mjk0OTY3Mjk1XHJcblxyXG5mdW5jdGlvbiBvbGRCcm93c2VyICgpIHtcclxuICB0aHJvdyBuZXcgRXJyb3IoJ1NlY3VyZSByYW5kb20gbnVtYmVyIGdlbmVyYXRpb24gaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIGJyb3dzZXIuXFxuVXNlIENocm9tZSwgRmlyZWZveCBvciBJbnRlcm5ldCBFeHBsb3JlciAxMScpXHJcbn1cclxuXHJcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxyXG52YXIgY3J5cHRvID0gZ2xvYmFsLmNyeXB0byB8fCBnbG9iYWwubXNDcnlwdG9cclxuXHJcbmlmIChjcnlwdG8gJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xyXG4gIG1vZHVsZS5leHBvcnRzID0gcmFuZG9tQnl0ZXNcclxufSBlbHNlIHtcclxuICBtb2R1bGUuZXhwb3J0cyA9IG9sZEJyb3dzZXJcclxufVxyXG5cclxuZnVuY3Rpb24gcmFuZG9tQnl0ZXMgKHNpemUsIGNiKSB7XHJcbiAgLy8gcGhhbnRvbWpzIG5lZWRzIHRvIHRocm93XHJcbiAgaWYgKHNpemUgPiBNQVhfVUlOVDMyKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcigncmVxdWVzdGVkIHRvbyBtYW55IHJhbmRvbSBieXRlcycpXHJcblxyXG4gIHZhciBieXRlcyA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShzaXplKVxyXG5cclxuICBpZiAoc2l6ZSA+IDApIHsgIC8vIGdldFJhbmRvbVZhbHVlcyBmYWlscyBvbiBJRSBpZiBzaXplID09IDBcclxuICAgIGlmIChzaXplID4gTUFYX0JZVEVTKSB7IC8vIHRoaXMgaXMgdGhlIG1heCBieXRlcyBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzXHJcbiAgICAgIC8vIGNhbiBkbyBhdCBvbmNlIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXNcclxuICAgICAgZm9yICh2YXIgZ2VuZXJhdGVkID0gMDsgZ2VuZXJhdGVkIDwgc2l6ZTsgZ2VuZXJhdGVkICs9IE1BWF9CWVRFUykge1xyXG4gICAgICAgIC8vIGJ1ZmZlci5zbGljZSBhdXRvbWF0aWNhbGx5IGNoZWNrcyBpZiB0aGUgZW5kIGlzIHBhc3QgdGhlIGVuZCBvZlxyXG4gICAgICAgIC8vIHRoZSBidWZmZXIgc28gd2UgZG9uJ3QgaGF2ZSB0byBoZXJlXHJcbiAgICAgICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhieXRlcy5zbGljZShnZW5lcmF0ZWQsIGdlbmVyYXRlZCArIE1BWF9CWVRFUykpXHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYnl0ZXMpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGNiKG51bGwsIGJ5dGVzKVxyXG4gICAgfSlcclxuICB9XHJcblxyXG4gIHJldHVybiBieXRlc1xyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/randombytes/browser.js\n");

/***/ }),

/***/ "./node_modules/readable-stream/errors-browser.js":
/*!********************************************************!*\
  !*** ./node_modules/readable-stream/errors-browser.js ***!
  \********************************************************/
/***/ (function(module) {

"use strict";
eval("\r\n\r\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\r\n\r\nvar codes = {};\r\n\r\nfunction createErrorType(code, message, Base) {\r\n  if (!Base) {\r\n    Base = Error;\r\n  }\r\n\r\n  function getMessage(arg1, arg2, arg3) {\r\n    if (typeof message === 'string') {\r\n      return message;\r\n    } else {\r\n      return message(arg1, arg2, arg3);\r\n    }\r\n  }\r\n\r\n  var NodeError =\r\n  /*#__PURE__*/\r\n  function (_Base) {\r\n    _inheritsLoose(NodeError, _Base);\r\n\r\n    function NodeError(arg1, arg2, arg3) {\r\n      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;\r\n    }\r\n\r\n    return NodeError;\r\n  }(Base);\r\n\r\n  NodeError.prototype.name = Base.name;\r\n  NodeError.prototype.code = code;\r\n  codes[code] = NodeError;\r\n} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js\r\n\r\n\r\nfunction oneOf(expected, thing) {\r\n  if (Array.isArray(expected)) {\r\n    var len = expected.length;\r\n    expected = expected.map(function (i) {\r\n      return String(i);\r\n    });\r\n\r\n    if (len > 2) {\r\n      return \"one of \".concat(thing, \" \").concat(expected.slice(0, len - 1).join(', '), \", or \") + expected[len - 1];\r\n    } else if (len === 2) {\r\n      return \"one of \".concat(thing, \" \").concat(expected[0], \" or \").concat(expected[1]);\r\n    } else {\r\n      return \"of \".concat(thing, \" \").concat(expected[0]);\r\n    }\r\n  } else {\r\n    return \"of \".concat(thing, \" \").concat(String(expected));\r\n  }\r\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith\r\n\r\n\r\nfunction startsWith(str, search, pos) {\r\n  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;\r\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith\r\n\r\n\r\nfunction endsWith(str, search, this_len) {\r\n  if (this_len === undefined || this_len > str.length) {\r\n    this_len = str.length;\r\n  }\r\n\r\n  return str.substring(this_len - search.length, this_len) === search;\r\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes\r\n\r\n\r\nfunction includes(str, search, start) {\r\n  if (typeof start !== 'number') {\r\n    start = 0;\r\n  }\r\n\r\n  if (start + search.length > str.length) {\r\n    return false;\r\n  } else {\r\n    return str.indexOf(search, start) !== -1;\r\n  }\r\n}\r\n\r\ncreateErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {\r\n  return 'The value \"' + value + '\" is invalid for option \"' + name + '\"';\r\n}, TypeError);\r\ncreateErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {\r\n  // determiner: 'must be' or 'must not be'\r\n  var determiner;\r\n\r\n  if (typeof expected === 'string' && startsWith(expected, 'not ')) {\r\n    determiner = 'must not be';\r\n    expected = expected.replace(/^not /, '');\r\n  } else {\r\n    determiner = 'must be';\r\n  }\r\n\r\n  var msg;\r\n\r\n  if (endsWith(name, ' argument')) {\r\n    // For cases like 'first argument'\r\n    msg = \"The \".concat(name, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\r\n  } else {\r\n    var type = includes(name, '.') ? 'property' : 'argument';\r\n    msg = \"The \\\"\".concat(name, \"\\\" \").concat(type, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\r\n  }\r\n\r\n  msg += \". Received type \".concat(typeof actual);\r\n  return msg;\r\n}, TypeError);\r\ncreateErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');\r\ncreateErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {\r\n  return 'The ' + name + ' method is not implemented';\r\n});\r\ncreateErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');\r\ncreateErrorType('ERR_STREAM_DESTROYED', function (name) {\r\n  return 'Cannot call ' + name + ' after a stream was destroyed';\r\n});\r\ncreateErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');\r\ncreateErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');\r\ncreateErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');\r\ncreateErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);\r\ncreateErrorType('ERR_UNKNOWN_ENCODING', function (arg) {\r\n  return 'Unknown encoding: ' + arg;\r\n}, TypeError);\r\ncreateErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');\r\nmodule.exports.codes = codes;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2Vycm9ycy1icm93c2VyLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSxnREFBZ0QsMERBQTBELDJDQUEyQztBQUNySjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxvQkFBb0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9lcnJvcnMtYnJvd3Nlci5qcz9hNmE4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxyXG5cclxudmFyIGNvZGVzID0ge307XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVFcnJvclR5cGUoY29kZSwgbWVzc2FnZSwgQmFzZSkge1xyXG4gIGlmICghQmFzZSkge1xyXG4gICAgQmFzZSA9IEVycm9yO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0TWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKSB7XHJcbiAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIHJldHVybiBtZXNzYWdlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIG1lc3NhZ2UoYXJnMSwgYXJnMiwgYXJnMyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB2YXIgTm9kZUVycm9yID1cclxuICAvKiNfX1BVUkVfXyovXHJcbiAgZnVuY3Rpb24gKF9CYXNlKSB7XHJcbiAgICBfaW5oZXJpdHNMb29zZShOb2RlRXJyb3IsIF9CYXNlKTtcclxuXHJcbiAgICBmdW5jdGlvbiBOb2RlRXJyb3IoYXJnMSwgYXJnMiwgYXJnMykge1xyXG4gICAgICByZXR1cm4gX0Jhc2UuY2FsbCh0aGlzLCBnZXRNZXNzYWdlKGFyZzEsIGFyZzIsIGFyZzMpKSB8fCB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBOb2RlRXJyb3I7XHJcbiAgfShCYXNlKTtcclxuXHJcbiAgTm9kZUVycm9yLnByb3RvdHlwZS5uYW1lID0gQmFzZS5uYW1lO1xyXG4gIE5vZGVFcnJvci5wcm90b3R5cGUuY29kZSA9IGNvZGU7XHJcbiAgY29kZXNbY29kZV0gPSBOb2RlRXJyb3I7XHJcbn0gLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvdjEwLjguMC9saWIvaW50ZXJuYWwvZXJyb3JzLmpzXHJcblxyXG5cclxuZnVuY3Rpb24gb25lT2YoZXhwZWN0ZWQsIHRoaW5nKSB7XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkoZXhwZWN0ZWQpKSB7XHJcbiAgICB2YXIgbGVuID0gZXhwZWN0ZWQubGVuZ3RoO1xyXG4gICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5tYXAoZnVuY3Rpb24gKGkpIHtcclxuICAgICAgcmV0dXJuIFN0cmluZyhpKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGlmIChsZW4gPiAyKSB7XHJcbiAgICAgIHJldHVybiBcIm9uZSBvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWQuc2xpY2UoMCwgbGVuIC0gMSkuam9pbignLCAnKSwgXCIsIG9yIFwiKSArIGV4cGVjdGVkW2xlbiAtIDFdO1xyXG4gICAgfSBlbHNlIGlmIChsZW4gPT09IDIpIHtcclxuICAgICAgcmV0dXJuIFwib25lIG9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChleHBlY3RlZFswXSwgXCIgb3IgXCIpLmNvbmNhdChleHBlY3RlZFsxXSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gXCJvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRbMF0pO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gXCJvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoU3RyaW5nKGV4cGVjdGVkKSk7XHJcbiAgfVxyXG59IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9zdGFydHNXaXRoXHJcblxyXG5cclxuZnVuY3Rpb24gc3RhcnRzV2l0aChzdHIsIHNlYXJjaCwgcG9zKSB7XHJcbiAgcmV0dXJuIHN0ci5zdWJzdHIoIXBvcyB8fCBwb3MgPCAwID8gMCA6ICtwb3MsIHNlYXJjaC5sZW5ndGgpID09PSBzZWFyY2g7XHJcbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2VuZHNXaXRoXHJcblxyXG5cclxuZnVuY3Rpb24gZW5kc1dpdGgoc3RyLCBzZWFyY2gsIHRoaXNfbGVuKSB7XHJcbiAgaWYgKHRoaXNfbGVuID09PSB1bmRlZmluZWQgfHwgdGhpc19sZW4gPiBzdHIubGVuZ3RoKSB7XHJcbiAgICB0aGlzX2xlbiA9IHN0ci5sZW5ndGg7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3RyLnN1YnN0cmluZyh0aGlzX2xlbiAtIHNlYXJjaC5sZW5ndGgsIHRoaXNfbGVuKSA9PT0gc2VhcmNoO1xyXG59IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9pbmNsdWRlc1xyXG5cclxuXHJcbmZ1bmN0aW9uIGluY2x1ZGVzKHN0ciwgc2VhcmNoLCBzdGFydCkge1xyXG4gIGlmICh0eXBlb2Ygc3RhcnQgIT09ICdudW1iZXInKSB7XHJcbiAgICBzdGFydCA9IDA7XHJcbiAgfVxyXG5cclxuICBpZiAoc3RhcnQgKyBzZWFyY2gubGVuZ3RoID4gc3RyLmxlbmd0aCkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gc3RyLmluZGV4T2Yoc2VhcmNoLCBzdGFydCkgIT09IC0xO1xyXG4gIH1cclxufVxyXG5cclxuY3JlYXRlRXJyb3JUeXBlKCdFUlJfSU5WQUxJRF9PUFRfVkFMVUUnLCBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcclxuICByZXR1cm4gJ1RoZSB2YWx1ZSBcIicgKyB2YWx1ZSArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCInICsgbmFtZSArICdcIic7XHJcbn0sIFR5cGVFcnJvcik7XHJcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0lOVkFMSURfQVJHX1RZUEUnLCBmdW5jdGlvbiAobmFtZSwgZXhwZWN0ZWQsIGFjdHVhbCkge1xyXG4gIC8vIGRldGVybWluZXI6ICdtdXN0IGJlJyBvciAnbXVzdCBub3QgYmUnXHJcbiAgdmFyIGRldGVybWluZXI7XHJcblxyXG4gIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT09ICdzdHJpbmcnICYmIHN0YXJ0c1dpdGgoZXhwZWN0ZWQsICdub3QgJykpIHtcclxuICAgIGRldGVybWluZXIgPSAnbXVzdCBub3QgYmUnO1xyXG4gICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5yZXBsYWNlKC9ebm90IC8sICcnKTtcclxuICB9IGVsc2Uge1xyXG4gICAgZGV0ZXJtaW5lciA9ICdtdXN0IGJlJztcclxuICB9XHJcblxyXG4gIHZhciBtc2c7XHJcblxyXG4gIGlmIChlbmRzV2l0aChuYW1lLCAnIGFyZ3VtZW50JykpIHtcclxuICAgIC8vIEZvciBjYXNlcyBsaWtlICdmaXJzdCBhcmd1bWVudCdcclxuICAgIG1zZyA9IFwiVGhlIFwiLmNvbmNhdChuYW1lLCBcIiBcIikuY29uY2F0KGRldGVybWluZXIsIFwiIFwiKS5jb25jYXQob25lT2YoZXhwZWN0ZWQsICd0eXBlJykpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB2YXIgdHlwZSA9IGluY2x1ZGVzKG5hbWUsICcuJykgPyAncHJvcGVydHknIDogJ2FyZ3VtZW50JztcclxuICAgIG1zZyA9IFwiVGhlIFxcXCJcIi5jb25jYXQobmFtZSwgXCJcXFwiIFwiKS5jb25jYXQodHlwZSwgXCIgXCIpLmNvbmNhdChkZXRlcm1pbmVyLCBcIiBcIikuY29uY2F0KG9uZU9mKGV4cGVjdGVkLCAndHlwZScpKTtcclxuICB9XHJcblxyXG4gIG1zZyArPSBcIi4gUmVjZWl2ZWQgdHlwZSBcIi5jb25jYXQodHlwZW9mIGFjdHVhbCk7XHJcbiAgcmV0dXJuIG1zZztcclxufSwgVHlwZUVycm9yKTtcclxuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GJywgJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJyk7XHJcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQnLCBmdW5jdGlvbiAobmFtZSkge1xyXG4gIHJldHVybiAnVGhlICcgKyBuYW1lICsgJyBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkJztcclxufSk7XHJcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UnLCAnUHJlbWF0dXJlIGNsb3NlJyk7XHJcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9ERVNUUk9ZRUQnLCBmdW5jdGlvbiAobmFtZSkge1xyXG4gIHJldHVybiAnQ2Fubm90IGNhbGwgJyArIG5hbWUgKyAnIGFmdGVyIGEgc3RyZWFtIHdhcyBkZXN0cm95ZWQnO1xyXG59KTtcclxuY3JlYXRlRXJyb3JUeXBlKCdFUlJfTVVMVElQTEVfQ0FMTEJBQ0snLCAnQ2FsbGJhY2sgY2FsbGVkIG11bHRpcGxlIHRpbWVzJyk7XHJcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9DQU5OT1RfUElQRScsICdDYW5ub3QgcGlwZSwgbm90IHJlYWRhYmxlJyk7XHJcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQnLCAnd3JpdGUgYWZ0ZXIgZW5kJyk7XHJcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUycsICdNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbScsIFR5cGVFcnJvcik7XHJcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1VOS05PV05fRU5DT0RJTkcnLCBmdW5jdGlvbiAoYXJnKSB7XHJcbiAgcmV0dXJuICdVbmtub3duIGVuY29kaW5nOiAnICsgYXJnO1xyXG59LCBUeXBlRXJyb3IpO1xyXG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQnLCAnc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKTtcclxubW9kdWxlLmV4cG9ydHMuY29kZXMgPSBjb2RlcztcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/readable-stream/errors-browser.js\n");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_duplex.js":
/*!************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_duplex.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/process/browser.js\");\n// Copyright Joyent, Inc. and other Node contributors.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the\r\n// \"Software\"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n// persons to whom the Software is furnished to do so, subject to the\r\n// following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n// a duplex stream is just a stream that is both readable and writable.\r\n// Since JS doesn't have multiple prototypal inheritance, this class\r\n// prototypally inherits from Readable, and then parasitically from\r\n// Writable.\r\n\r\n/*<replacement>*/\r\n\r\nvar objectKeys = Object.keys || function (obj) {\r\n  var keys = [];\r\n\r\n  for (var key in obj) {\r\n    keys.push(key);\r\n  }\r\n\r\n  return keys;\r\n};\r\n/*</replacement>*/\r\n\r\n\r\nmodule.exports = Duplex;\r\n\r\nvar Readable = __webpack_require__(/*! ./_stream_readable */ \"./node_modules/readable-stream/lib/_stream_readable.js\");\r\n\r\nvar Writable = __webpack_require__(/*! ./_stream_writable */ \"./node_modules/readable-stream/lib/_stream_writable.js\");\r\n\r\n__webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")(Duplex, Readable);\r\n\r\n{\r\n  // Allow the keys array to be GC'ed.\r\n  var keys = objectKeys(Writable.prototype);\r\n\r\n  for (var v = 0; v < keys.length; v++) {\r\n    var method = keys[v];\r\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\r\n  }\r\n}\r\n\r\nfunction Duplex(options) {\r\n  if (!(this instanceof Duplex)) return new Duplex(options);\r\n  Readable.call(this, options);\r\n  Writable.call(this, options);\r\n  this.allowHalfOpen = true;\r\n\r\n  if (options) {\r\n    if (options.readable === false) this.readable = false;\r\n    if (options.writable === false) this.writable = false;\r\n\r\n    if (options.allowHalfOpen === false) {\r\n      this.allowHalfOpen = false;\r\n      this.once('end', onend);\r\n    }\r\n  }\r\n}\r\n\r\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\r\n  // making it explicit this property is not enumerable\r\n  // because otherwise some prototype manipulation in\r\n  // userland will fail\r\n  enumerable: false,\r\n  get: function get() {\r\n    return this._writableState.highWaterMark;\r\n  }\r\n});\r\nObject.defineProperty(Duplex.prototype, 'writableBuffer', {\r\n  // making it explicit this property is not enumerable\r\n  // because otherwise some prototype manipulation in\r\n  // userland will fail\r\n  enumerable: false,\r\n  get: function get() {\r\n    return this._writableState && this._writableState.getBuffer();\r\n  }\r\n});\r\nObject.defineProperty(Duplex.prototype, 'writableLength', {\r\n  // making it explicit this property is not enumerable\r\n  // because otherwise some prototype manipulation in\r\n  // userland will fail\r\n  enumerable: false,\r\n  get: function get() {\r\n    return this._writableState.length;\r\n  }\r\n}); // the no-half-open enforcer\r\n\r\nfunction onend() {\r\n  // If the writable side ended, then we're ok.\r\n  if (this._writableState.ended) return; // no more data can be written.\r\n  // But allow more writes to happen in this tick.\r\n\r\n  process.nextTick(onEndNT, this);\r\n}\r\n\r\nfunction onEndNT(self) {\r\n  self.end();\r\n}\r\n\r\nObject.defineProperty(Duplex.prototype, 'destroyed', {\r\n  // making it explicit this property is not enumerable\r\n  // because otherwise some prototype manipulation in\r\n  // userland will fail\r\n  enumerable: false,\r\n  get: function get() {\r\n    if (this._readableState === undefined || this._writableState === undefined) {\r\n      return false;\r\n    }\r\n\r\n    return this._readableState.destroyed && this._writableState.destroyed;\r\n  },\r\n  set: function set(value) {\r\n    // we ignore the value if the stream\r\n    // has not been initialized yet\r\n    if (this._readableState === undefined || this._writableState === undefined) {\r\n      return;\r\n    } // backward compatibility, the user is explicitly\r\n    // managing destroyed\r\n\r\n\r\n    this._readableState.destroyed = value;\r\n    this._writableState.destroyed = value;\r\n  }\r\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxrRkFBb0I7QUFDM0M7QUFDQSxlQUFlLG1CQUFPLENBQUMsa0ZBQW9CO0FBQzNDO0FBQ0EsbUJBQU8sQ0FBQyw2REFBVTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHO0FBQ0o7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQSxFQUFFLE9BQU87QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcz81MDYyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxyXG4vL1xyXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxyXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXHJcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xyXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXHJcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcclxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXHJcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG4vL1xyXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxyXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuLy9cclxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xyXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXHJcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cclxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXHJcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxyXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXHJcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXHJcbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXHJcbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXHJcbi8vIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb21cclxuLy8gV3JpdGFibGUuXHJcbid1c2Ugc3RyaWN0JztcclxuLyo8cmVwbGFjZW1lbnQ+Ki9cclxuXHJcbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xyXG4gIHZhciBrZXlzID0gW107XHJcblxyXG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcclxuICAgIGtleXMucHVzaChrZXkpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGtleXM7XHJcbn07XHJcbi8qPC9yZXBsYWNlbWVudD4qL1xyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xyXG5cclxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XHJcblxyXG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcclxuXHJcbnJlcXVpcmUoJ2luaGVyaXRzJykoRHVwbGV4LCBSZWFkYWJsZSk7XHJcblxyXG57XHJcbiAgLy8gQWxsb3cgdGhlIGtleXMgYXJyYXkgdG8gYmUgR0MnZWQuXHJcbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7XHJcblxyXG4gIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xyXG4gICAgdmFyIG1ldGhvZCA9IGtleXNbdl07XHJcbiAgICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSkgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xyXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcclxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xyXG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XHJcbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcclxuXHJcbiAgaWYgKG9wdGlvbnMpIHtcclxuICAgIGlmIChvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSkgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xyXG4gICAgaWYgKG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XHJcblxyXG4gICAgaWYgKG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpIHtcclxuICAgICAgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XHJcbiAgICAgIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XHJcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcclxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cclxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcclxuICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcclxuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XHJcbiAgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUJ1ZmZlcicsIHtcclxuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxyXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxyXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxyXG4gIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIoKTtcclxuICB9XHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlTGVuZ3RoJywge1xyXG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXHJcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXHJcbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXHJcbiAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5sZW5ndGg7XHJcbiAgfVxyXG59KTsgLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxyXG5cclxuZnVuY3Rpb24gb25lbmQoKSB7XHJcbiAgLy8gSWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsIHRoZW4gd2UncmUgb2suXHJcbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHJldHVybjsgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxyXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxyXG5cclxuICBwcm9jZXNzLm5leHRUaWNrKG9uRW5kTlQsIHRoaXMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBvbkVuZE5UKHNlbGYpIHtcclxuICBzZWxmLmVuZCgpO1xyXG59XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcclxuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxyXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxyXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxyXG4gIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xyXG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcclxuICB9LFxyXG4gIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XHJcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cclxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcclxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH0gLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxyXG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXHJcblxyXG5cclxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XHJcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xyXG4gIH1cclxufSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/readable-stream/lib/_stream_duplex.js\n");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_passthrough.js":
/*!*****************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_passthrough.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the\r\n// \"Software\"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n// persons to whom the Software is furnished to do so, subject to the\r\n// following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n// a passthrough stream.\r\n// basically just the most minimal sort of Transform stream.\r\n// Every written chunk gets output as-is.\r\n\r\n\r\nmodule.exports = PassThrough;\r\n\r\nvar Transform = __webpack_require__(/*! ./_stream_transform */ \"./node_modules/readable-stream/lib/_stream_transform.js\");\r\n\r\n__webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")(PassThrough, Transform);\r\n\r\nfunction PassThrough(options) {\r\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\r\n  Transform.call(this, options);\r\n}\r\n\r\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\r\n  cb(null, chunk);\r\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLG9GQUFxQjtBQUM3QztBQUNBLG1CQUFPLENBQUMsNkRBQVU7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanM/ODAyMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cclxuLy9cclxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcclxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxyXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcclxuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxyXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XHJcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxyXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuLy9cclxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcclxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbi8vXHJcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1NcclxuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxyXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXHJcbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxyXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1JcclxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxyXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG4vLyBhIHBhc3N0aHJvdWdoIHN0cmVhbS5cclxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXHJcbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2g7XHJcblxyXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9fc3RyZWFtX3RyYW5zZm9ybScpO1xyXG5cclxucmVxdWlyZSgnaW5oZXJpdHMnKShQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcclxuXHJcbmZ1bmN0aW9uIFBhc3NUaHJvdWdoKG9wdGlvbnMpIHtcclxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKSByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpO1xyXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xyXG59XHJcblxyXG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XHJcbiAgY2IobnVsbCwgY2h1bmspO1xyXG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/readable-stream/lib/_stream_passthrough.js\n");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_readable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_readable.js ***!
  \**************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/process/browser.js\");\n// Copyright Joyent, Inc. and other Node contributors.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the\r\n// \"Software\"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n// persons to whom the Software is furnished to do so, subject to the\r\n// following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n\r\nmodule.exports = Readable;\r\n/*<replacement>*/\r\n\r\nvar Duplex;\r\n/*</replacement>*/\r\n\r\nReadable.ReadableState = ReadableState;\r\n/*<replacement>*/\r\n\r\nvar EE = (__webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter);\r\n\r\nvar EElistenerCount = function EElistenerCount(emitter, type) {\r\n  return emitter.listeners(type).length;\r\n};\r\n/*</replacement>*/\r\n\r\n/*<replacement>*/\r\n\r\n\r\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \"./node_modules/readable-stream/lib/internal/streams/stream-browser.js\");\r\n/*</replacement>*/\r\n\r\n\r\nvar Buffer = (__webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\").Buffer);\r\n\r\nvar OurUint8Array = __webpack_require__.g.Uint8Array || function () {};\r\n\r\nfunction _uint8ArrayToBuffer(chunk) {\r\n  return Buffer.from(chunk);\r\n}\r\n\r\nfunction _isUint8Array(obj) {\r\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\r\n}\r\n/*<replacement>*/\r\n\r\n\r\nvar debugUtil = __webpack_require__(/*! util */ \"?8c28\");\r\n\r\nvar debug;\r\n\r\nif (debugUtil && debugUtil.debuglog) {\r\n  debug = debugUtil.debuglog('stream');\r\n} else {\r\n  debug = function debug() {};\r\n}\r\n/*</replacement>*/\r\n\r\n\r\nvar BufferList = __webpack_require__(/*! ./internal/streams/buffer_list */ \"./node_modules/readable-stream/lib/internal/streams/buffer_list.js\");\r\n\r\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"./node_modules/readable-stream/lib/internal/streams/destroy.js\");\r\n\r\nvar _require = __webpack_require__(/*! ./internal/streams/state */ \"./node_modules/readable-stream/lib/internal/streams/state.js\"),\r\n    getHighWaterMark = _require.getHighWaterMark;\r\n\r\nvar _require$codes = (__webpack_require__(/*! ../errors */ \"./node_modules/readable-stream/errors-browser.js\").codes),\r\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\r\n    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,\r\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\r\n    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.\r\n\r\n\r\nvar StringDecoder;\r\nvar createReadableStreamAsyncIterator;\r\nvar from;\r\n\r\n__webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")(Readable, Stream);\r\n\r\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\r\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\r\n\r\nfunction prependListener(emitter, event, fn) {\r\n  // Sadly this is not cacheable as some libraries bundle their own\r\n  // event emitter implementation with them.\r\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any\r\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\r\n  // to continue to work with older versions of Node.js that do not include\r\n  // the prependListener() method. The goal is to eventually remove this hack.\r\n\r\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\r\n}\r\n\r\nfunction ReadableState(options, stream, isDuplex) {\r\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\r\n  options = options || {}; // Duplex streams are both readable and writable, but share\r\n  // the same options object.\r\n  // However, some cases require setting options to different\r\n  // values for the readable and the writable sides of the duplex stream.\r\n  // These options can be provided separately as readableXXX and writableXXX.\r\n\r\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to\r\n  // make all the buffer merging and length checks go away\r\n\r\n  this.objectMode = !!options.objectMode;\r\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer\r\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\r\n\r\n  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the\r\n  // linked list can remove elements from the beginning faster than\r\n  // array.shift()\r\n\r\n  this.buffer = new BufferList();\r\n  this.length = 0;\r\n  this.pipes = null;\r\n  this.pipesCount = 0;\r\n  this.flowing = null;\r\n  this.ended = false;\r\n  this.endEmitted = false;\r\n  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted\r\n  // immediately, or on a later tick.  We set this to true at first, because\r\n  // any actions that shouldn't happen until \"later\" should generally also\r\n  // not happen before the first read call.\r\n\r\n  this.sync = true; // whenever we return null, then we set a flag to say\r\n  // that we're awaiting a 'readable' event emission.\r\n\r\n  this.needReadable = false;\r\n  this.emittedReadable = false;\r\n  this.readableListening = false;\r\n  this.resumeScheduled = false;\r\n  this.paused = true; // Should close be emitted on destroy. Defaults to true.\r\n\r\n  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')\r\n\r\n  this.autoDestroy = !!options.autoDestroy; // has it been destroyed\r\n\r\n  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string\r\n  // encoding is 'binary' so we have to make this configurable.\r\n  // Everything else in the universe uses 'utf8', though.\r\n\r\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s\r\n\r\n  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled\r\n\r\n  this.readingMore = false;\r\n  this.decoder = null;\r\n  this.encoding = null;\r\n\r\n  if (options.encoding) {\r\n    if (!StringDecoder) StringDecoder = (__webpack_require__(/*! string_decoder/ */ \"./node_modules/string_decoder/lib/string_decoder.js\").StringDecoder);\r\n    this.decoder = new StringDecoder(options.encoding);\r\n    this.encoding = options.encoding;\r\n  }\r\n}\r\n\r\nfunction Readable(options) {\r\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\r\n  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside\r\n  // the ReadableState constructor, at least with V8 6.5\r\n\r\n  var isDuplex = this instanceof Duplex;\r\n  this._readableState = new ReadableState(options, this, isDuplex); // legacy\r\n\r\n  this.readable = true;\r\n\r\n  if (options) {\r\n    if (typeof options.read === 'function') this._read = options.read;\r\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\r\n  }\r\n\r\n  Stream.call(this);\r\n}\r\n\r\nObject.defineProperty(Readable.prototype, 'destroyed', {\r\n  // making it explicit this property is not enumerable\r\n  // because otherwise some prototype manipulation in\r\n  // userland will fail\r\n  enumerable: false,\r\n  get: function get() {\r\n    if (this._readableState === undefined) {\r\n      return false;\r\n    }\r\n\r\n    return this._readableState.destroyed;\r\n  },\r\n  set: function set(value) {\r\n    // we ignore the value if the stream\r\n    // has not been initialized yet\r\n    if (!this._readableState) {\r\n      return;\r\n    } // backward compatibility, the user is explicitly\r\n    // managing destroyed\r\n\r\n\r\n    this._readableState.destroyed = value;\r\n  }\r\n});\r\nReadable.prototype.destroy = destroyImpl.destroy;\r\nReadable.prototype._undestroy = destroyImpl.undestroy;\r\n\r\nReadable.prototype._destroy = function (err, cb) {\r\n  cb(err);\r\n}; // Manually shove something into the read() buffer.\r\n// This returns true if the highWaterMark has not been hit yet,\r\n// similar to how Writable.write() returns true if you should\r\n// write() some more.\r\n\r\n\r\nReadable.prototype.push = function (chunk, encoding) {\r\n  var state = this._readableState;\r\n  var skipChunkCheck;\r\n\r\n  if (!state.objectMode) {\r\n    if (typeof chunk === 'string') {\r\n      encoding = encoding || state.defaultEncoding;\r\n\r\n      if (encoding !== state.encoding) {\r\n        chunk = Buffer.from(chunk, encoding);\r\n        encoding = '';\r\n      }\r\n\r\n      skipChunkCheck = true;\r\n    }\r\n  } else {\r\n    skipChunkCheck = true;\r\n  }\r\n\r\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\r\n}; // Unshift should *always* be something directly out of read()\r\n\r\n\r\nReadable.prototype.unshift = function (chunk) {\r\n  return readableAddChunk(this, chunk, null, true, false);\r\n};\r\n\r\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\r\n  debug('readableAddChunk', chunk);\r\n  var state = stream._readableState;\r\n\r\n  if (chunk === null) {\r\n    state.reading = false;\r\n    onEofChunk(stream, state);\r\n  } else {\r\n    var er;\r\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\r\n\r\n    if (er) {\r\n      errorOrDestroy(stream, er);\r\n    } else if (state.objectMode || chunk && chunk.length > 0) {\r\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\r\n        chunk = _uint8ArrayToBuffer(chunk);\r\n      }\r\n\r\n      if (addToFront) {\r\n        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);\r\n      } else if (state.ended) {\r\n        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\r\n      } else if (state.destroyed) {\r\n        return false;\r\n      } else {\r\n        state.reading = false;\r\n\r\n        if (state.decoder && !encoding) {\r\n          chunk = state.decoder.write(chunk);\r\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\r\n        } else {\r\n          addChunk(stream, state, chunk, false);\r\n        }\r\n      }\r\n    } else if (!addToFront) {\r\n      state.reading = false;\r\n      maybeReadMore(stream, state);\r\n    }\r\n  } // We can push more data if we are below the highWaterMark.\r\n  // Also, if we have no data yet, we can stand some more bytes.\r\n  // This is to work around cases where hwm=0, such as the repl.\r\n\r\n\r\n  return !state.ended && (state.length < state.highWaterMark || state.length === 0);\r\n}\r\n\r\nfunction addChunk(stream, state, chunk, addToFront) {\r\n  if (state.flowing && state.length === 0 && !state.sync) {\r\n    state.awaitDrain = 0;\r\n    stream.emit('data', chunk);\r\n  } else {\r\n    // update the buffer info.\r\n    state.length += state.objectMode ? 1 : chunk.length;\r\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\r\n    if (state.needReadable) emitReadable(stream);\r\n  }\r\n\r\n  maybeReadMore(stream, state);\r\n}\r\n\r\nfunction chunkInvalid(state, chunk) {\r\n  var er;\r\n\r\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\r\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);\r\n  }\r\n\r\n  return er;\r\n}\r\n\r\nReadable.prototype.isPaused = function () {\r\n  return this._readableState.flowing === false;\r\n}; // backwards compatibility.\r\n\r\n\r\nReadable.prototype.setEncoding = function (enc) {\r\n  if (!StringDecoder) StringDecoder = (__webpack_require__(/*! string_decoder/ */ \"./node_modules/string_decoder/lib/string_decoder.js\").StringDecoder);\r\n  var decoder = new StringDecoder(enc);\r\n  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8\r\n\r\n  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:\r\n\r\n  var p = this._readableState.buffer.head;\r\n  var content = '';\r\n\r\n  while (p !== null) {\r\n    content += decoder.write(p.data);\r\n    p = p.next;\r\n  }\r\n\r\n  this._readableState.buffer.clear();\r\n\r\n  if (content !== '') this._readableState.buffer.push(content);\r\n  this._readableState.length = content.length;\r\n  return this;\r\n}; // Don't raise the hwm > 1GB\r\n\r\n\r\nvar MAX_HWM = 0x40000000;\r\n\r\nfunction computeNewHighWaterMark(n) {\r\n  if (n >= MAX_HWM) {\r\n    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.\r\n    n = MAX_HWM;\r\n  } else {\r\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\r\n    // tiny amounts\r\n    n--;\r\n    n |= n >>> 1;\r\n    n |= n >>> 2;\r\n    n |= n >>> 4;\r\n    n |= n >>> 8;\r\n    n |= n >>> 16;\r\n    n++;\r\n  }\r\n\r\n  return n;\r\n} // This function is designed to be inlinable, so please take care when making\r\n// changes to the function body.\r\n\r\n\r\nfunction howMuchToRead(n, state) {\r\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\r\n  if (state.objectMode) return 1;\r\n\r\n  if (n !== n) {\r\n    // Only flow one buffer at a time\r\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\r\n  } // If we're asking for more than the current hwm, then raise the hwm.\r\n\r\n\r\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\r\n  if (n <= state.length) return n; // Don't have enough\r\n\r\n  if (!state.ended) {\r\n    state.needReadable = true;\r\n    return 0;\r\n  }\r\n\r\n  return state.length;\r\n} // you can override either this method, or the async _read(n) below.\r\n\r\n\r\nReadable.prototype.read = function (n) {\r\n  debug('read', n);\r\n  n = parseInt(n, 10);\r\n  var state = this._readableState;\r\n  var nOrig = n;\r\n  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we\r\n  // already have a bunch of data in the buffer, then just trigger\r\n  // the 'readable' event and move on.\r\n\r\n  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\r\n    debug('read: emitReadable', state.length, state.ended);\r\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\r\n    return null;\r\n  }\r\n\r\n  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.\r\n\r\n  if (n === 0 && state.ended) {\r\n    if (state.length === 0) endReadable(this);\r\n    return null;\r\n  } // All the actual chunk generation logic needs to be\r\n  // *below* the call to _read.  The reason is that in certain\r\n  // synthetic stream cases, such as passthrough streams, _read\r\n  // may be a completely synchronous operation which may change\r\n  // the state of the read buffer, providing enough data when\r\n  // before there was *not* enough.\r\n  //\r\n  // So, the steps are:\r\n  // 1. Figure out what the state of things will be after we do\r\n  // a read from the buffer.\r\n  //\r\n  // 2. If that resulting state will trigger a _read, then call _read.\r\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\r\n  // deeply ugly to write APIs this way, but that still doesn't mean\r\n  // that the Readable class should behave improperly, as streams are\r\n  // designed to be sync/async agnostic.\r\n  // Take note if the _read call is sync or async (ie, if the read call\r\n  // has returned yet), so that we know whether or not it's safe to emit\r\n  // 'readable' etc.\r\n  //\r\n  // 3. Actually pull the requested chunks out of the buffer and return.\r\n  // if we need a readable event, then we need to do some reading.\r\n\r\n\r\n  var doRead = state.needReadable;\r\n  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some\r\n\r\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\r\n    doRead = true;\r\n    debug('length less than watermark', doRead);\r\n  } // however, if we've ended, then there's no point, and if we're already\r\n  // reading, then it's unnecessary.\r\n\r\n\r\n  if (state.ended || state.reading) {\r\n    doRead = false;\r\n    debug('reading or ended', doRead);\r\n  } else if (doRead) {\r\n    debug('do read');\r\n    state.reading = true;\r\n    state.sync = true; // if the length is currently zero, then we *need* a readable event.\r\n\r\n    if (state.length === 0) state.needReadable = true; // call internal read method\r\n\r\n    this._read(state.highWaterMark);\r\n\r\n    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,\r\n    // and we need to re-evaluate how much data we can return to the user.\r\n\r\n    if (!state.reading) n = howMuchToRead(nOrig, state);\r\n  }\r\n\r\n  var ret;\r\n  if (n > 0) ret = fromList(n, state);else ret = null;\r\n\r\n  if (ret === null) {\r\n    state.needReadable = state.length <= state.highWaterMark;\r\n    n = 0;\r\n  } else {\r\n    state.length -= n;\r\n    state.awaitDrain = 0;\r\n  }\r\n\r\n  if (state.length === 0) {\r\n    // If we have nothing in the buffer, then we want to know\r\n    // as soon as we *do* get something into the buffer.\r\n    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.\r\n\r\n    if (nOrig !== n && state.ended) endReadable(this);\r\n  }\r\n\r\n  if (ret !== null) this.emit('data', ret);\r\n  return ret;\r\n};\r\n\r\nfunction onEofChunk(stream, state) {\r\n  debug('onEofChunk');\r\n  if (state.ended) return;\r\n\r\n  if (state.decoder) {\r\n    var chunk = state.decoder.end();\r\n\r\n    if (chunk && chunk.length) {\r\n      state.buffer.push(chunk);\r\n      state.length += state.objectMode ? 1 : chunk.length;\r\n    }\r\n  }\r\n\r\n  state.ended = true;\r\n\r\n  if (state.sync) {\r\n    // if we are sync, wait until next tick to emit the data.\r\n    // Otherwise we risk emitting data in the flow()\r\n    // the readable code triggers during a read() call\r\n    emitReadable(stream);\r\n  } else {\r\n    // emit 'readable' now to make sure it gets picked up.\r\n    state.needReadable = false;\r\n\r\n    if (!state.emittedReadable) {\r\n      state.emittedReadable = true;\r\n      emitReadable_(stream);\r\n    }\r\n  }\r\n} // Don't emit readable right away in sync mode, because this can trigger\r\n// another read() call => stack overflow.  This way, it might trigger\r\n// a nextTick recursion warning, but that's not so bad.\r\n\r\n\r\nfunction emitReadable(stream) {\r\n  var state = stream._readableState;\r\n  debug('emitReadable', state.needReadable, state.emittedReadable);\r\n  state.needReadable = false;\r\n\r\n  if (!state.emittedReadable) {\r\n    debug('emitReadable', state.flowing);\r\n    state.emittedReadable = true;\r\n    process.nextTick(emitReadable_, stream);\r\n  }\r\n}\r\n\r\nfunction emitReadable_(stream) {\r\n  var state = stream._readableState;\r\n  debug('emitReadable_', state.destroyed, state.length, state.ended);\r\n\r\n  if (!state.destroyed && (state.length || state.ended)) {\r\n    stream.emit('readable');\r\n    state.emittedReadable = false;\r\n  } // The stream needs another readable event if\r\n  // 1. It is not flowing, as the flow mechanism will take\r\n  //    care of it.\r\n  // 2. It is not ended.\r\n  // 3. It is below the highWaterMark, so we can schedule\r\n  //    another readable later.\r\n\r\n\r\n  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;\r\n  flow(stream);\r\n} // at this point, the user has presumably seen the 'readable' event,\r\n// and called read() to consume some data.  that may have triggered\r\n// in turn another _read(n) call, in which case reading = true if\r\n// it's in progress.\r\n// However, if we're not ended, or reading, and the length < hwm,\r\n// then go ahead and try to read some more preemptively.\r\n\r\n\r\nfunction maybeReadMore(stream, state) {\r\n  if (!state.readingMore) {\r\n    state.readingMore = true;\r\n    process.nextTick(maybeReadMore_, stream, state);\r\n  }\r\n}\r\n\r\nfunction maybeReadMore_(stream, state) {\r\n  // Attempt to read more data if we should.\r\n  //\r\n  // The conditions for reading more data are (one of):\r\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\r\n  //   is responsible for filling the buffer with enough data if such data\r\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\r\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\r\n  //   when the stream consumer calls read() instead.\r\n  // - No data in the buffer, and the stream is in flowing mode. In this mode\r\n  //   the loop below is responsible for ensuring read() is called. Failing to\r\n  //   call read here would abort the flow and there's no other mechanism for\r\n  //   continuing the flow if the stream consumer has just subscribed to the\r\n  //   'data' event.\r\n  //\r\n  // In addition to the above conditions to keep reading data, the following\r\n  // conditions prevent the data from being read:\r\n  // - The stream has ended (state.ended).\r\n  // - There is already a pending 'read' operation (state.reading). This is a\r\n  //   case where the the stream has called the implementation defined _read()\r\n  //   method, but they are processing the call asynchronously and have _not_\r\n  //   called push() with new data. In this case we skip performing more\r\n  //   read()s. The execution ends in this method again after the _read() ends\r\n  //   up calling push() with more data.\r\n  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {\r\n    var len = state.length;\r\n    debug('maybeReadMore read 0');\r\n    stream.read(0);\r\n    if (len === state.length) // didn't get any data, stop spinning.\r\n      break;\r\n  }\r\n\r\n  state.readingMore = false;\r\n} // abstract method.  to be overridden in specific implementation classes.\r\n// call cb(er, data) where data is <= n in length.\r\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\r\n// arbitrary, and perhaps not very meaningful.\r\n\r\n\r\nReadable.prototype._read = function (n) {\r\n  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));\r\n};\r\n\r\nReadable.prototype.pipe = function (dest, pipeOpts) {\r\n  var src = this;\r\n  var state = this._readableState;\r\n\r\n  switch (state.pipesCount) {\r\n    case 0:\r\n      state.pipes = dest;\r\n      break;\r\n\r\n    case 1:\r\n      state.pipes = [state.pipes, dest];\r\n      break;\r\n\r\n    default:\r\n      state.pipes.push(dest);\r\n      break;\r\n  }\r\n\r\n  state.pipesCount += 1;\r\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\r\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\r\n  var endFn = doEnd ? onend : unpipe;\r\n  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);\r\n  dest.on('unpipe', onunpipe);\r\n\r\n  function onunpipe(readable, unpipeInfo) {\r\n    debug('onunpipe');\r\n\r\n    if (readable === src) {\r\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\r\n        unpipeInfo.hasUnpiped = true;\r\n        cleanup();\r\n      }\r\n    }\r\n  }\r\n\r\n  function onend() {\r\n    debug('onend');\r\n    dest.end();\r\n  } // when the dest drains, it reduces the awaitDrain counter\r\n  // on the source.  This would be more elegant with a .once()\r\n  // handler in flow(), but adding and removing repeatedly is\r\n  // too slow.\r\n\r\n\r\n  var ondrain = pipeOnDrain(src);\r\n  dest.on('drain', ondrain);\r\n  var cleanedUp = false;\r\n\r\n  function cleanup() {\r\n    debug('cleanup'); // cleanup event handlers once the pipe is broken\r\n\r\n    dest.removeListener('close', onclose);\r\n    dest.removeListener('finish', onfinish);\r\n    dest.removeListener('drain', ondrain);\r\n    dest.removeListener('error', onerror);\r\n    dest.removeListener('unpipe', onunpipe);\r\n    src.removeListener('end', onend);\r\n    src.removeListener('end', unpipe);\r\n    src.removeListener('data', ondata);\r\n    cleanedUp = true; // if the reader is waiting for a drain event from this\r\n    // specific writer, then it would cause it to never start\r\n    // flowing again.\r\n    // So, if this is awaiting a drain, then we just call it now.\r\n    // If we don't know, then assume that we are waiting for one.\r\n\r\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\r\n  }\r\n\r\n  src.on('data', ondata);\r\n\r\n  function ondata(chunk) {\r\n    debug('ondata');\r\n    var ret = dest.write(chunk);\r\n    debug('dest.write', ret);\r\n\r\n    if (ret === false) {\r\n      // If the user unpiped during `dest.write()`, it is possible\r\n      // to get stuck in a permanently paused state if that write\r\n      // also returned false.\r\n      // => Check whether `dest` is still a piping destination.\r\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\r\n        debug('false write response, pause', state.awaitDrain);\r\n        state.awaitDrain++;\r\n      }\r\n\r\n      src.pause();\r\n    }\r\n  } // if the dest has an error, then stop piping into it.\r\n  // however, don't suppress the throwing behavior for this.\r\n\r\n\r\n  function onerror(er) {\r\n    debug('onerror', er);\r\n    unpipe();\r\n    dest.removeListener('error', onerror);\r\n    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);\r\n  } // Make sure our error handler is attached before userland ones.\r\n\r\n\r\n  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.\r\n\r\n  function onclose() {\r\n    dest.removeListener('finish', onfinish);\r\n    unpipe();\r\n  }\r\n\r\n  dest.once('close', onclose);\r\n\r\n  function onfinish() {\r\n    debug('onfinish');\r\n    dest.removeListener('close', onclose);\r\n    unpipe();\r\n  }\r\n\r\n  dest.once('finish', onfinish);\r\n\r\n  function unpipe() {\r\n    debug('unpipe');\r\n    src.unpipe(dest);\r\n  } // tell the dest that it's being piped to\r\n\r\n\r\n  dest.emit('pipe', src); // start the flow if it hasn't been started already.\r\n\r\n  if (!state.flowing) {\r\n    debug('pipe resume');\r\n    src.resume();\r\n  }\r\n\r\n  return dest;\r\n};\r\n\r\nfunction pipeOnDrain(src) {\r\n  return function pipeOnDrainFunctionResult() {\r\n    var state = src._readableState;\r\n    debug('pipeOnDrain', state.awaitDrain);\r\n    if (state.awaitDrain) state.awaitDrain--;\r\n\r\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\r\n      state.flowing = true;\r\n      flow(src);\r\n    }\r\n  };\r\n}\r\n\r\nReadable.prototype.unpipe = function (dest) {\r\n  var state = this._readableState;\r\n  var unpipeInfo = {\r\n    hasUnpiped: false\r\n  }; // if we're not piping anywhere, then do nothing.\r\n\r\n  if (state.pipesCount === 0) return this; // just one destination.  most common case.\r\n\r\n  if (state.pipesCount === 1) {\r\n    // passed in one, but it's not the right one.\r\n    if (dest && dest !== state.pipes) return this;\r\n    if (!dest) dest = state.pipes; // got a match.\r\n\r\n    state.pipes = null;\r\n    state.pipesCount = 0;\r\n    state.flowing = false;\r\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\r\n    return this;\r\n  } // slow case. multiple pipe destinations.\r\n\r\n\r\n  if (!dest) {\r\n    // remove all.\r\n    var dests = state.pipes;\r\n    var len = state.pipesCount;\r\n    state.pipes = null;\r\n    state.pipesCount = 0;\r\n    state.flowing = false;\r\n\r\n    for (var i = 0; i < len; i++) {\r\n      dests[i].emit('unpipe', this, {\r\n        hasUnpiped: false\r\n      });\r\n    }\r\n\r\n    return this;\r\n  } // try to find the right one.\r\n\r\n\r\n  var index = indexOf(state.pipes, dest);\r\n  if (index === -1) return this;\r\n  state.pipes.splice(index, 1);\r\n  state.pipesCount -= 1;\r\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\r\n  dest.emit('unpipe', this, unpipeInfo);\r\n  return this;\r\n}; // set up data events if they are asked for\r\n// Ensure readable listeners eventually get something\r\n\r\n\r\nReadable.prototype.on = function (ev, fn) {\r\n  var res = Stream.prototype.on.call(this, ev, fn);\r\n  var state = this._readableState;\r\n\r\n  if (ev === 'data') {\r\n    // update readableListening so that resume() may be a no-op\r\n    // a few lines down. This is needed to support once('readable').\r\n    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused\r\n\r\n    if (state.flowing !== false) this.resume();\r\n  } else if (ev === 'readable') {\r\n    if (!state.endEmitted && !state.readableListening) {\r\n      state.readableListening = state.needReadable = true;\r\n      state.flowing = false;\r\n      state.emittedReadable = false;\r\n      debug('on readable', state.length, state.reading);\r\n\r\n      if (state.length) {\r\n        emitReadable(this);\r\n      } else if (!state.reading) {\r\n        process.nextTick(nReadingNextTick, this);\r\n      }\r\n    }\r\n  }\r\n\r\n  return res;\r\n};\r\n\r\nReadable.prototype.addListener = Readable.prototype.on;\r\n\r\nReadable.prototype.removeListener = function (ev, fn) {\r\n  var res = Stream.prototype.removeListener.call(this, ev, fn);\r\n\r\n  if (ev === 'readable') {\r\n    // We need to check if there is someone still listening to\r\n    // readable and reset the state. However this needs to happen\r\n    // after readable has been emitted but before I/O (nextTick) to\r\n    // support once('readable', fn) cycles. This means that calling\r\n    // resume within the same tick will have no\r\n    // effect.\r\n    process.nextTick(updateReadableListening, this);\r\n  }\r\n\r\n  return res;\r\n};\r\n\r\nReadable.prototype.removeAllListeners = function (ev) {\r\n  var res = Stream.prototype.removeAllListeners.apply(this, arguments);\r\n\r\n  if (ev === 'readable' || ev === undefined) {\r\n    // We need to check if there is someone still listening to\r\n    // readable and reset the state. However this needs to happen\r\n    // after readable has been emitted but before I/O (nextTick) to\r\n    // support once('readable', fn) cycles. This means that calling\r\n    // resume within the same tick will have no\r\n    // effect.\r\n    process.nextTick(updateReadableListening, this);\r\n  }\r\n\r\n  return res;\r\n};\r\n\r\nfunction updateReadableListening(self) {\r\n  var state = self._readableState;\r\n  state.readableListening = self.listenerCount('readable') > 0;\r\n\r\n  if (state.resumeScheduled && !state.paused) {\r\n    // flowing needs to be set to true now, otherwise\r\n    // the upcoming resume will not flow.\r\n    state.flowing = true; // crude way to check if we should resume\r\n  } else if (self.listenerCount('data') > 0) {\r\n    self.resume();\r\n  }\r\n}\r\n\r\nfunction nReadingNextTick(self) {\r\n  debug('readable nexttick read 0');\r\n  self.read(0);\r\n} // pause() and resume() are remnants of the legacy readable stream API\r\n// If the user uses them, then switch into old mode.\r\n\r\n\r\nReadable.prototype.resume = function () {\r\n  var state = this._readableState;\r\n\r\n  if (!state.flowing) {\r\n    debug('resume'); // we flow only if there is no one listening\r\n    // for readable, but we still have to call\r\n    // resume()\r\n\r\n    state.flowing = !state.readableListening;\r\n    resume(this, state);\r\n  }\r\n\r\n  state.paused = false;\r\n  return this;\r\n};\r\n\r\nfunction resume(stream, state) {\r\n  if (!state.resumeScheduled) {\r\n    state.resumeScheduled = true;\r\n    process.nextTick(resume_, stream, state);\r\n  }\r\n}\r\n\r\nfunction resume_(stream, state) {\r\n  debug('resume', state.reading);\r\n\r\n  if (!state.reading) {\r\n    stream.read(0);\r\n  }\r\n\r\n  state.resumeScheduled = false;\r\n  stream.emit('resume');\r\n  flow(stream);\r\n  if (state.flowing && !state.reading) stream.read(0);\r\n}\r\n\r\nReadable.prototype.pause = function () {\r\n  debug('call pause flowing=%j', this._readableState.flowing);\r\n\r\n  if (this._readableState.flowing !== false) {\r\n    debug('pause');\r\n    this._readableState.flowing = false;\r\n    this.emit('pause');\r\n  }\r\n\r\n  this._readableState.paused = true;\r\n  return this;\r\n};\r\n\r\nfunction flow(stream) {\r\n  var state = stream._readableState;\r\n  debug('flow', state.flowing);\r\n\r\n  while (state.flowing && stream.read() !== null) {\r\n    ;\r\n  }\r\n} // wrap an old-style stream as the async data source.\r\n// This is *not* part of the readable stream interface.\r\n// It is an ugly unfortunate mess of history.\r\n\r\n\r\nReadable.prototype.wrap = function (stream) {\r\n  var _this = this;\r\n\r\n  var state = this._readableState;\r\n  var paused = false;\r\n  stream.on('end', function () {\r\n    debug('wrapped end');\r\n\r\n    if (state.decoder && !state.ended) {\r\n      var chunk = state.decoder.end();\r\n      if (chunk && chunk.length) _this.push(chunk);\r\n    }\r\n\r\n    _this.push(null);\r\n  });\r\n  stream.on('data', function (chunk) {\r\n    debug('wrapped data');\r\n    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode\r\n\r\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\r\n\r\n    var ret = _this.push(chunk);\r\n\r\n    if (!ret) {\r\n      paused = true;\r\n      stream.pause();\r\n    }\r\n  }); // proxy all the other methods.\r\n  // important when wrapping filters and duplexes.\r\n\r\n  for (var i in stream) {\r\n    if (this[i] === undefined && typeof stream[i] === 'function') {\r\n      this[i] = function methodWrap(method) {\r\n        return function methodWrapReturnFunction() {\r\n          return stream[method].apply(stream, arguments);\r\n        };\r\n      }(i);\r\n    }\r\n  } // proxy certain important events.\r\n\r\n\r\n  for (var n = 0; n < kProxyEvents.length; n++) {\r\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\r\n  } // when we try to consume some more bytes, simply unpause the\r\n  // underlying stream.\r\n\r\n\r\n  this._read = function (n) {\r\n    debug('wrapped _read', n);\r\n\r\n    if (paused) {\r\n      paused = false;\r\n      stream.resume();\r\n    }\r\n  };\r\n\r\n  return this;\r\n};\r\n\r\nif (typeof Symbol === 'function') {\r\n  Readable.prototype[Symbol.asyncIterator] = function () {\r\n    if (createReadableStreamAsyncIterator === undefined) {\r\n      createReadableStreamAsyncIterator = __webpack_require__(/*! ./internal/streams/async_iterator */ \"./node_modules/readable-stream/lib/internal/streams/async_iterator.js\");\r\n    }\r\n\r\n    return createReadableStreamAsyncIterator(this);\r\n  };\r\n}\r\n\r\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\r\n  // making it explicit this property is not enumerable\r\n  // because otherwise some prototype manipulation in\r\n  // userland will fail\r\n  enumerable: false,\r\n  get: function get() {\r\n    return this._readableState.highWaterMark;\r\n  }\r\n});\r\nObject.defineProperty(Readable.prototype, 'readableBuffer', {\r\n  // making it explicit this property is not enumerable\r\n  // because otherwise some prototype manipulation in\r\n  // userland will fail\r\n  enumerable: false,\r\n  get: function get() {\r\n    return this._readableState && this._readableState.buffer;\r\n  }\r\n});\r\nObject.defineProperty(Readable.prototype, 'readableFlowing', {\r\n  // making it explicit this property is not enumerable\r\n  // because otherwise some prototype manipulation in\r\n  // userland will fail\r\n  enumerable: false,\r\n  get: function get() {\r\n    return this._readableState.flowing;\r\n  },\r\n  set: function set(state) {\r\n    if (this._readableState) {\r\n      this._readableState.flowing = state;\r\n    }\r\n  }\r\n}); // exposed for testing purposes only.\r\n\r\nReadable._fromList = fromList;\r\nObject.defineProperty(Readable.prototype, 'readableLength', {\r\n  // making it explicit this property is not enumerable\r\n  // because otherwise some prototype manipulation in\r\n  // userland will fail\r\n  enumerable: false,\r\n  get: function get() {\r\n    return this._readableState.length;\r\n  }\r\n}); // Pluck off n bytes from an array of buffers.\r\n// Length is the combined lengths of all the buffers in the list.\r\n// This function is designed to be inlinable, so please take care when making\r\n// changes to the function body.\r\n\r\nfunction fromList(n, state) {\r\n  // nothing buffered\r\n  if (state.length === 0) return null;\r\n  var ret;\r\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\r\n    // read it all, truncate the list\r\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);\r\n    state.buffer.clear();\r\n  } else {\r\n    // read part of list\r\n    ret = state.buffer.consume(n, state.decoder);\r\n  }\r\n  return ret;\r\n}\r\n\r\nfunction endReadable(stream) {\r\n  var state = stream._readableState;\r\n  debug('endReadable', state.endEmitted);\r\n\r\n  if (!state.endEmitted) {\r\n    state.ended = true;\r\n    process.nextTick(endReadableNT, state, stream);\r\n  }\r\n}\r\n\r\nfunction endReadableNT(state, stream) {\r\n  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.\r\n\r\n  if (!state.endEmitted && state.length === 0) {\r\n    state.endEmitted = true;\r\n    stream.readable = false;\r\n    stream.emit('end');\r\n\r\n    if (state.autoDestroy) {\r\n      // In case of duplex streams we need a way to detect\r\n      // if the writable side is ready for autoDestroy as well\r\n      var wState = stream._writableState;\r\n\r\n      if (!wState || wState.autoDestroy && wState.finished) {\r\n        stream.destroy();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nif (typeof Symbol === 'function') {\r\n  Readable.from = function (iterable, opts) {\r\n    if (from === undefined) {\r\n      from = __webpack_require__(/*! ./internal/streams/from */ \"./node_modules/readable-stream/lib/internal/streams/from-browser.js\");\r\n    }\r\n\r\n    return from(Readable, iterable, opts);\r\n  };\r\n}\r\n\r\nfunction indexOf(xs, x) {\r\n  for (var i = 0, l = xs.length; i < l; i++) {\r\n    if (xs[i] === x) return i;\r\n  }\r\n\r\n  return -1;\r\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzLmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsbUZBQThCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyx3R0FBMkI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsYUFBYSw0RUFBd0I7QUFDckM7QUFDQSxvQkFBb0IscUJBQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLG1CQUFNO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLDBHQUFnQztBQUN6RDtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLGtHQUE0QjtBQUN0RDtBQUNBLGVBQWUsbUJBQU8sQ0FBQyw4RkFBMEI7QUFDakQ7QUFDQTtBQUNBLHFCQUFxQixnR0FBMEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFPLENBQUMsNkRBQVU7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsbUZBQW1GO0FBQzVKO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtQkFBTyxDQUFDLDhFQUFrQjtBQUMvQywyQkFBMkI7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixRQUFRLE9BQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksT0FBTztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksT0FBTztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksT0FBTztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsR0FBRztBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGtCQUFrQix5QkFBeUI7QUFDM0M7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLG1CQUFPLENBQUMsZ0hBQW1DO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEdBQUc7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0EsbURBQW1ELCtEQUErRDtBQUNsSDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLE9BQU87QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsb0dBQXlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE9BQU87QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzPzIyMTgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXHJcbi8vXHJcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXHJcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcclxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXHJcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcclxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxyXG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcclxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbi8vXHJcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXHJcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4vL1xyXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXHJcbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcclxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxyXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcclxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXHJcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcclxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcclxuLyo8cmVwbGFjZW1lbnQ+Ki9cclxuXHJcbnZhciBEdXBsZXg7XHJcbi8qPC9yZXBsYWNlbWVudD4qL1xyXG5cclxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XHJcbi8qPHJlcGxhY2VtZW50PiovXHJcblxyXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XHJcblxyXG52YXIgRUVsaXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gRUVsaXN0ZW5lckNvdW50KGVtaXR0ZXIsIHR5cGUpIHtcclxuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xyXG59O1xyXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cclxuXHJcbi8qPHJlcGxhY2VtZW50PiovXHJcblxyXG5cclxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcclxuLyo8L3JlcGxhY2VtZW50PiovXHJcblxyXG5cclxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcclxuXHJcbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XHJcblxyXG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XHJcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcclxuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcclxufVxyXG4vKjxyZXBsYWNlbWVudD4qL1xyXG5cclxuXHJcbnZhciBkZWJ1Z1V0aWwgPSByZXF1aXJlKCd1dGlsJyk7XHJcblxyXG52YXIgZGVidWc7XHJcblxyXG5pZiAoZGVidWdVdGlsICYmIGRlYnVnVXRpbC5kZWJ1Z2xvZykge1xyXG4gIGRlYnVnID0gZGVidWdVdGlsLmRlYnVnbG9nKCdzdHJlYW0nKTtcclxufSBlbHNlIHtcclxuICBkZWJ1ZyA9IGZ1bmN0aW9uIGRlYnVnKCkge307XHJcbn1cclxuLyo8L3JlcGxhY2VtZW50PiovXHJcblxyXG5cclxudmFyIEJ1ZmZlckxpc3QgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvYnVmZmVyX2xpc3QnKTtcclxuXHJcbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XHJcblxyXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RhdGUnKSxcclxuICAgIGdldEhpZ2hXYXRlck1hcmsgPSBfcmVxdWlyZS5nZXRIaWdoV2F0ZXJNYXJrO1xyXG5cclxudmFyIF9yZXF1aXJlJGNvZGVzID0gcmVxdWlyZSgnLi4vZXJyb3JzJykuY29kZXMsXHJcbiAgICBFUlJfSU5WQUxJRF9BUkdfVFlQRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9JTlZBTElEX0FSR19UWVBFLFxyXG4gICAgRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRiA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YsXHJcbiAgICBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVELFxyXG4gICAgRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQ7IC8vIExhenkgbG9hZGVkIHRvIGltcHJvdmUgdGhlIHN0YXJ0dXAgcGVyZm9ybWFuY2UuXHJcblxyXG5cclxudmFyIFN0cmluZ0RlY29kZXI7XHJcbnZhciBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3I7XHJcbnZhciBmcm9tO1xyXG5cclxucmVxdWlyZSgnaW5oZXJpdHMnKShSZWFkYWJsZSwgU3RyZWFtKTtcclxuXHJcbnZhciBlcnJvck9yRGVzdHJveSA9IGRlc3Ryb3lJbXBsLmVycm9yT3JEZXN0cm95O1xyXG52YXIga1Byb3h5RXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xyXG5cclxuZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbikge1xyXG4gIC8vIFNhZGx5IHRoaXMgaXMgbm90IGNhY2hlYWJsZSBhcyBzb21lIGxpYnJhcmllcyBidW5kbGUgdGhlaXIgb3duXHJcbiAgLy8gZXZlbnQgZW1pdHRlciBpbXBsZW1lbnRhdGlvbiB3aXRoIHRoZW0uXHJcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50LCBmbik7IC8vIFRoaXMgaXMgYSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnlcclxuICAvLyB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy4gVGhpcyBpcyBoZXJlIG9ubHkgYmVjYXVzZSB0aGlzIGNvZGUgbmVlZHNcclxuICAvLyB0byBjb250aW51ZSB0byB3b3JrIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgTm9kZS5qcyB0aGF0IGRvIG5vdCBpbmNsdWRlXHJcbiAgLy8gdGhlIHByZXBlbmRMaXN0ZW5lcigpIG1ldGhvZC4gVGhlIGdvYWwgaXMgdG8gZXZlbnR1YWxseSByZW1vdmUgdGhpcyBoYWNrLlxyXG5cclxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkgZW1pdHRlci5vbihldmVudCwgZm4pO2Vsc2UgaWYgKEFycmF5LmlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbik7ZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXTtcclxufVxyXG5cclxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0sIGlzRHVwbGV4KSB7XHJcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcclxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcclxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cclxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxyXG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXHJcbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXHJcblxyXG4gIGlmICh0eXBlb2YgaXNEdXBsZXggIT09ICdib29sZWFuJykgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7IC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXHJcbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcclxuXHJcbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XHJcbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTsgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXHJcblxyXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IGdldEhpZ2hXYXRlck1hcmsodGhpcywgb3B0aW9ucywgJ3JlYWRhYmxlSGlnaFdhdGVyTWFyaycsIGlzRHVwbGV4KTsgLy8gQSBsaW5rZWQgbGlzdCBpcyB1c2VkIHRvIHN0b3JlIGRhdGEgY2h1bmtzIGluc3RlYWQgb2YgYW4gYXJyYXkgYmVjYXVzZSB0aGVcclxuICAvLyBsaW5rZWQgbGlzdCBjYW4gcmVtb3ZlIGVsZW1lbnRzIGZyb20gdGhlIGJlZ2lubmluZyBmYXN0ZXIgdGhhblxyXG4gIC8vIGFycmF5LnNoaWZ0KClcclxuXHJcbiAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyTGlzdCgpO1xyXG4gIHRoaXMubGVuZ3RoID0gMDtcclxuICB0aGlzLnBpcGVzID0gbnVsbDtcclxuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xyXG4gIHRoaXMuZmxvd2luZyA9IG51bGw7XHJcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xyXG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xyXG4gIHRoaXMucmVhZGluZyA9IGZhbHNlOyAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBldmVudCAncmVhZGFibGUnLydkYXRhJyBpcyBlbWl0dGVkXHJcbiAgLy8gaW1tZWRpYXRlbHksIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2VcclxuICAvLyBhbnkgYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xyXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCByZWFkIGNhbGwuXHJcblxyXG4gIHRoaXMuc3luYyA9IHRydWU7IC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XHJcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXHJcblxyXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XHJcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcclxuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XHJcbiAgdGhpcy5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcclxuICB0aGlzLnBhdXNlZCA9IHRydWU7IC8vIFNob3VsZCBjbG9zZSBiZSBlbWl0dGVkIG9uIGRlc3Ryb3kuIERlZmF1bHRzIHRvIHRydWUuXHJcblxyXG4gIHRoaXMuZW1pdENsb3NlID0gb3B0aW9ucy5lbWl0Q2xvc2UgIT09IGZhbHNlOyAvLyBTaG91bGQgLmRlc3Ryb3koKSBiZSBjYWxsZWQgYWZ0ZXIgJ2VuZCcgKGFuZCBwb3RlbnRpYWxseSAnZmluaXNoJylcclxuXHJcbiAgdGhpcy5hdXRvRGVzdHJveSA9ICEhb3B0aW9ucy5hdXRvRGVzdHJveTsgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXHJcblxyXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7IC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcclxuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXHJcbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxyXG5cclxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JzsgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcclxuXHJcbiAgdGhpcy5hd2FpdERyYWluID0gMDsgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxyXG5cclxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XHJcbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcclxuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcclxuXHJcbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcclxuICAgIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XHJcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcclxuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xyXG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XHJcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTsgLy8gQ2hlY2tpbmcgZm9yIGEgU3RyZWFtLkR1cGxleCBpbnN0YW5jZSBpcyBmYXN0ZXIgaGVyZSBpbnN0ZWFkIG9mIGluc2lkZVxyXG4gIC8vIHRoZSBSZWFkYWJsZVN0YXRlIGNvbnN0cnVjdG9yLCBhdCBsZWFzdCB3aXRoIFY4IDYuNVxyXG5cclxuICB2YXIgaXNEdXBsZXggPSB0aGlzIGluc3RhbmNlb2YgRHVwbGV4O1xyXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzLCBpc0R1cGxleCk7IC8vIGxlZ2FjeVxyXG5cclxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcclxuXHJcbiAgaWYgKG9wdGlvbnMpIHtcclxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAnZnVuY3Rpb24nKSB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkO1xyXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XHJcbiAgfVxyXG5cclxuICBTdHJlYW0uY2FsbCh0aGlzKTtcclxufVxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcclxuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxyXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxyXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxyXG4gIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xyXG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xyXG4gIH0sXHJcbiAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcclxuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxyXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxyXG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH0gLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxyXG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXHJcblxyXG5cclxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XHJcbiAgfVxyXG59KTtcclxuUmVhZGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xyXG5SZWFkYWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcclxuXHJcblJlYWRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XHJcbiAgY2IoZXJyKTtcclxufTsgLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXHJcbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxyXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXHJcbi8vIHdyaXRlKCkgc29tZSBtb3JlLlxyXG5cclxuXHJcblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xyXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XHJcbiAgdmFyIHNraXBDaHVua0NoZWNrO1xyXG5cclxuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUpIHtcclxuICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xyXG5cclxuICAgICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xyXG4gICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcclxuICAgICAgICBlbmNvZGluZyA9ICcnO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBlbmNvZGluZywgZmFsc2UsIHNraXBDaHVua0NoZWNrKTtcclxufTsgLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcclxuXHJcblxyXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykge1xyXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBudWxsLCB0cnVlLCBmYWxzZSk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250LCBza2lwQ2h1bmtDaGVjaykge1xyXG4gIGRlYnVnKCdyZWFkYWJsZUFkZENodW5rJywgY2h1bmspO1xyXG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcclxuXHJcbiAgaWYgKGNodW5rID09PSBudWxsKSB7XHJcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XHJcbiAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB2YXIgZXI7XHJcbiAgICBpZiAoIXNraXBDaHVua0NoZWNrKSBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xyXG5cclxuICAgIGlmIChlcikge1xyXG4gICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTtcclxuICAgIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihjaHVuaykgIT09IEJ1ZmZlci5wcm90b3R5cGUpIHtcclxuICAgICAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoYWRkVG9Gcm9udCkge1xyXG4gICAgICAgIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBlcnJvck9yRGVzdHJveShzdHJlYW0sIG5ldyBFUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UKCkpO2Vsc2UgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIHRydWUpO1xyXG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZGVkKSB7XHJcbiAgICAgICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBuZXcgRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRigpKTtcclxuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5kZXN0cm95ZWQpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xyXG5cclxuICAgICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhZW5jb2RpbmcpIHtcclxuICAgICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XHJcbiAgICAgICAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuay5sZW5ndGggIT09IDApIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7ZWxzZSBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xyXG4gICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XHJcbiAgICAgIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XHJcbiAgICB9XHJcbiAgfSAvLyBXZSBjYW4gcHVzaCBtb3JlIGRhdGEgaWYgd2UgYXJlIGJlbG93IHRoZSBoaWdoV2F0ZXJNYXJrLlxyXG4gIC8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lIG1vcmUgYnl0ZXMuXHJcbiAgLy8gVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCwgc3VjaCBhcyB0aGUgcmVwbC5cclxuXHJcblxyXG4gIHJldHVybiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUubGVuZ3RoID09PSAwKTtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGFkZFRvRnJvbnQpIHtcclxuICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcclxuICAgIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xyXG4gICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXHJcbiAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XHJcbiAgICBpZiAoYWRkVG9Gcm9udCkgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO2Vsc2Ugc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xyXG4gICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSkgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XHJcbiAgfVxyXG5cclxuICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XHJcbiAgdmFyIGVyO1xyXG5cclxuICBpZiAoIV9pc1VpbnQ4QXJyYXkoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xyXG4gICAgZXIgPSBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2NodW5rJywgWydzdHJpbmcnLCAnQnVmZmVyJywgJ1VpbnQ4QXJyYXknXSwgY2h1bmspO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGVyO1xyXG59XHJcblxyXG5SZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9PT0gZmFsc2U7XHJcbn07IC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxyXG5cclxuXHJcblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmMpIHtcclxuICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xyXG4gIHZhciBkZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcclxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBkZWNvZGVyOyAvLyBJZiBzZXRFbmNvZGluZyhudWxsKSwgZGVjb2Rlci5lbmNvZGluZyBlcXVhbHMgdXRmOFxyXG5cclxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyLmVuY29kaW5nOyAvLyBJdGVyYXRlIG92ZXIgY3VycmVudCBidWZmZXIgdG8gY29udmVydCBhbHJlYWR5IHN0b3JlZCBCdWZmZXJzOlxyXG5cclxuICB2YXIgcCA9IHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyLmhlYWQ7XHJcbiAgdmFyIGNvbnRlbnQgPSAnJztcclxuXHJcbiAgd2hpbGUgKHAgIT09IG51bGwpIHtcclxuICAgIGNvbnRlbnQgKz0gZGVjb2Rlci53cml0ZShwLmRhdGEpO1xyXG4gICAgcCA9IHAubmV4dDtcclxuICB9XHJcblxyXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyLmNsZWFyKCk7XHJcblxyXG4gIGlmIChjb250ZW50ICE9PSAnJykgdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIucHVzaChjb250ZW50KTtcclxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmxlbmd0aCA9IGNvbnRlbnQubGVuZ3RoO1xyXG4gIHJldHVybiB0aGlzO1xyXG59OyAvLyBEb24ndCByYWlzZSB0aGUgaHdtID4gMUdCXHJcblxyXG5cclxudmFyIE1BWF9IV00gPSAweDQwMDAwMDAwO1xyXG5cclxuZnVuY3Rpb24gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobikge1xyXG4gIGlmIChuID49IE1BWF9IV00pIHtcclxuICAgIC8vIFRPRE8ocm9uYWcpOiBUaHJvdyBFUlJfVkFMVUVfT1VUX09GX1JBTkdFLlxyXG4gICAgbiA9IE1BWF9IV007XHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDIgdG8gcHJldmVudCBpbmNyZWFzaW5nIGh3bSBleGNlc3NpdmVseSBpblxyXG4gICAgLy8gdGlueSBhbW91bnRzXHJcbiAgICBuLS07XHJcbiAgICBuIHw9IG4gPj4+IDE7XHJcbiAgICBuIHw9IG4gPj4+IDI7XHJcbiAgICBuIHw9IG4gPj4+IDQ7XHJcbiAgICBuIHw9IG4gPj4+IDg7XHJcbiAgICBuIHw9IG4gPj4+IDE2O1xyXG4gICAgbisrO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG47XHJcbn0gLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcclxuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cclxuXHJcblxyXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XHJcbiAgaWYgKG4gPD0gMCB8fCBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIHJldHVybiAwO1xyXG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXR1cm4gMTtcclxuXHJcbiAgaWYgKG4gIT09IG4pIHtcclxuICAgIC8vIE9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxyXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoKSByZXR1cm4gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YS5sZW5ndGg7ZWxzZSByZXR1cm4gc3RhdGUubGVuZ3RoO1xyXG4gIH0gLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIGN1cnJlbnQgaHdtLCB0aGVuIHJhaXNlIHRoZSBod20uXHJcblxyXG5cclxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKTtcclxuICBpZiAobiA8PSBzdGF0ZS5sZW5ndGgpIHJldHVybiBuOyAvLyBEb24ndCBoYXZlIGVub3VnaFxyXG5cclxuICBpZiAoIXN0YXRlLmVuZGVkKSB7XHJcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3RhdGUubGVuZ3RoO1xyXG59IC8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXHJcblxyXG5cclxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAobikge1xyXG4gIGRlYnVnKCdyZWFkJywgbik7XHJcbiAgbiA9IHBhcnNlSW50KG4sIDEwKTtcclxuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xyXG4gIHZhciBuT3JpZyA9IG47XHJcbiAgaWYgKG4gIT09IDApIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlOyAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXHJcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxyXG5cclxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5uZWVkUmVhZGFibGUgJiYgKChzdGF0ZS5oaWdoV2F0ZXJNYXJrICE9PSAwID8gc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgOiBzdGF0ZS5sZW5ndGggPiAwKSB8fCBzdGF0ZS5lbmRlZCkpIHtcclxuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcclxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO2Vsc2UgZW1pdFJlYWRhYmxlKHRoaXMpO1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7IC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cclxuXHJcbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcclxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIGVuZFJlYWRhYmxlKHRoaXMpO1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfSAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXHJcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXHJcbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxyXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcclxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxyXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxyXG4gIC8vXHJcbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XHJcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xyXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXHJcbiAgLy9cclxuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxyXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xyXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxyXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcclxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxyXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxyXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcclxuICAvLyAncmVhZGFibGUnIGV0Yy5cclxuICAvL1xyXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cclxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXHJcblxyXG5cclxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xyXG4gIGRlYnVnKCduZWVkIHJlYWRhYmxlJywgZG9SZWFkKTsgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXHJcblxyXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcclxuICAgIGRvUmVhZCA9IHRydWU7XHJcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xyXG4gIH0gLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcclxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXHJcblxyXG5cclxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xyXG4gICAgZG9SZWFkID0gZmFsc2U7XHJcbiAgICBkZWJ1ZygncmVhZGluZyBvciBlbmRlZCcsIGRvUmVhZCk7XHJcbiAgfSBlbHNlIGlmIChkb1JlYWQpIHtcclxuICAgIGRlYnVnKCdkbyByZWFkJyk7XHJcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcclxuICAgIHN0YXRlLnN5bmMgPSB0cnVlOyAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxyXG5cclxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7IC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcclxuXHJcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xyXG5cclxuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTsgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSxcclxuICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cclxuXHJcbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XHJcbiAgfVxyXG5cclxuICB2YXIgcmV0O1xyXG4gIGlmIChuID4gMCkgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO2Vsc2UgcmV0ID0gbnVsbDtcclxuXHJcbiAgaWYgKHJldCA9PT0gbnVsbCkge1xyXG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gc3RhdGUubGVuZ3RoIDw9IHN0YXRlLmhpZ2hXYXRlck1hcms7XHJcbiAgICBuID0gMDtcclxuICB9IGVsc2Uge1xyXG4gICAgc3RhdGUubGVuZ3RoIC09IG47XHJcbiAgICBzdGF0ZS5hd2FpdERyYWluID0gMDtcclxuICB9XHJcblxyXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHtcclxuICAgIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xyXG4gICAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxyXG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTsgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxyXG5cclxuICAgIGlmIChuT3JpZyAhPT0gbiAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7XHJcbiAgfVxyXG5cclxuICBpZiAocmV0ICE9PSBudWxsKSB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xyXG4gIHJldHVybiByZXQ7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcclxuICBkZWJ1Zygnb25Fb2ZDaHVuaycpO1xyXG4gIGlmIChzdGF0ZS5lbmRlZCkgcmV0dXJuO1xyXG5cclxuICBpZiAoc3RhdGUuZGVjb2Rlcikge1xyXG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcclxuXHJcbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XHJcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcclxuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xyXG5cclxuICBpZiAoc3RhdGUuc3luYykge1xyXG4gICAgLy8gaWYgd2UgYXJlIHN5bmMsIHdhaXQgdW50aWwgbmV4dCB0aWNrIHRvIGVtaXQgdGhlIGRhdGEuXHJcbiAgICAvLyBPdGhlcndpc2Ugd2UgcmlzayBlbWl0dGluZyBkYXRhIGluIHRoZSBmbG93KClcclxuICAgIC8vIHRoZSByZWFkYWJsZSBjb2RlIHRyaWdnZXJzIGR1cmluZyBhIHJlYWQoKSBjYWxsXHJcbiAgICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcclxuICB9IGVsc2Uge1xyXG4gICAgLy8gZW1pdCAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXHJcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcclxuXHJcbiAgICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xyXG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xyXG4gICAgICBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XHJcbiAgICB9XHJcbiAgfVxyXG59IC8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcclxuLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLlxyXG5cclxuXHJcbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcclxuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XHJcbiAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLm5lZWRSZWFkYWJsZSwgc3RhdGUuZW1pdHRlZFJlYWRhYmxlKTtcclxuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcclxuXHJcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcclxuICAgIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5mbG93aW5nKTtcclxuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XHJcbiAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xyXG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcclxuICBkZWJ1ZygnZW1pdFJlYWRhYmxlXycsIHN0YXRlLmRlc3Ryb3llZCwgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XHJcblxyXG4gIGlmICghc3RhdGUuZGVzdHJveWVkICYmIChzdGF0ZS5sZW5ndGggfHwgc3RhdGUuZW5kZWQpKSB7XHJcbiAgICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcclxuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xyXG4gIH0gLy8gVGhlIHN0cmVhbSBuZWVkcyBhbm90aGVyIHJlYWRhYmxlIGV2ZW50IGlmXHJcbiAgLy8gMS4gSXQgaXMgbm90IGZsb3dpbmcsIGFzIHRoZSBmbG93IG1lY2hhbmlzbSB3aWxsIHRha2VcclxuICAvLyAgICBjYXJlIG9mIGl0LlxyXG4gIC8vIDIuIEl0IGlzIG5vdCBlbmRlZC5cclxuICAvLyAzLiBJdCBpcyBiZWxvdyB0aGUgaGlnaFdhdGVyTWFyaywgc28gd2UgY2FuIHNjaGVkdWxlXHJcbiAgLy8gICAgYW5vdGhlciByZWFkYWJsZSBsYXRlci5cclxuXHJcblxyXG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9ICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPD0gc3RhdGUuaGlnaFdhdGVyTWFyaztcclxuICBmbG93KHN0cmVhbSk7XHJcbn0gLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcclxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxyXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxyXG4vLyBpdCdzIGluIHByb2dyZXNzLlxyXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxyXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxyXG5cclxuXHJcbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xyXG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcclxuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcclxuICAgIHByb2Nlc3MubmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xyXG4gIC8vIEF0dGVtcHQgdG8gcmVhZCBtb3JlIGRhdGEgaWYgd2Ugc2hvdWxkLlxyXG4gIC8vXHJcbiAgLy8gVGhlIGNvbmRpdGlvbnMgZm9yIHJlYWRpbmcgbW9yZSBkYXRhIGFyZSAob25lIG9mKTpcclxuICAvLyAtIE5vdCBlbm91Z2ggZGF0YSBidWZmZXJlZCAoc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykuIFRoZSBsb29wXHJcbiAgLy8gICBpcyByZXNwb25zaWJsZSBmb3IgZmlsbGluZyB0aGUgYnVmZmVyIHdpdGggZW5vdWdoIGRhdGEgaWYgc3VjaCBkYXRhXHJcbiAgLy8gICBpcyBhdmFpbGFibGUuIElmIGhpZ2hXYXRlck1hcmsgaXMgMCBhbmQgd2UgYXJlIG5vdCBpbiB0aGUgZmxvd2luZyBtb2RlXHJcbiAgLy8gICB3ZSBzaG91bGQgX25vdF8gYXR0ZW1wdCB0byBidWZmZXIgYW55IGV4dHJhIGRhdGEuIFdlJ2xsIGdldCBtb3JlIGRhdGFcclxuICAvLyAgIHdoZW4gdGhlIHN0cmVhbSBjb25zdW1lciBjYWxscyByZWFkKCkgaW5zdGVhZC5cclxuICAvLyAtIE5vIGRhdGEgaW4gdGhlIGJ1ZmZlciwgYW5kIHRoZSBzdHJlYW0gaXMgaW4gZmxvd2luZyBtb2RlLiBJbiB0aGlzIG1vZGVcclxuICAvLyAgIHRoZSBsb29wIGJlbG93IGlzIHJlc3BvbnNpYmxlIGZvciBlbnN1cmluZyByZWFkKCkgaXMgY2FsbGVkLiBGYWlsaW5nIHRvXHJcbiAgLy8gICBjYWxsIHJlYWQgaGVyZSB3b3VsZCBhYm9ydCB0aGUgZmxvdyBhbmQgdGhlcmUncyBubyBvdGhlciBtZWNoYW5pc20gZm9yXHJcbiAgLy8gICBjb250aW51aW5nIHRoZSBmbG93IGlmIHRoZSBzdHJlYW0gY29uc3VtZXIgaGFzIGp1c3Qgc3Vic2NyaWJlZCB0byB0aGVcclxuICAvLyAgICdkYXRhJyBldmVudC5cclxuICAvL1xyXG4gIC8vIEluIGFkZGl0aW9uIHRvIHRoZSBhYm92ZSBjb25kaXRpb25zIHRvIGtlZXAgcmVhZGluZyBkYXRhLCB0aGUgZm9sbG93aW5nXHJcbiAgLy8gY29uZGl0aW9ucyBwcmV2ZW50IHRoZSBkYXRhIGZyb20gYmVpbmcgcmVhZDpcclxuICAvLyAtIFRoZSBzdHJlYW0gaGFzIGVuZGVkIChzdGF0ZS5lbmRlZCkuXHJcbiAgLy8gLSBUaGVyZSBpcyBhbHJlYWR5IGEgcGVuZGluZyAncmVhZCcgb3BlcmF0aW9uIChzdGF0ZS5yZWFkaW5nKS4gVGhpcyBpcyBhXHJcbiAgLy8gICBjYXNlIHdoZXJlIHRoZSB0aGUgc3RyZWFtIGhhcyBjYWxsZWQgdGhlIGltcGxlbWVudGF0aW9uIGRlZmluZWQgX3JlYWQoKVxyXG4gIC8vICAgbWV0aG9kLCBidXQgdGhleSBhcmUgcHJvY2Vzc2luZyB0aGUgY2FsbCBhc3luY2hyb25vdXNseSBhbmQgaGF2ZSBfbm90X1xyXG4gIC8vICAgY2FsbGVkIHB1c2goKSB3aXRoIG5ldyBkYXRhLiBJbiB0aGlzIGNhc2Ugd2Ugc2tpcCBwZXJmb3JtaW5nIG1vcmVcclxuICAvLyAgIHJlYWQoKXMuIFRoZSBleGVjdXRpb24gZW5kcyBpbiB0aGlzIG1ldGhvZCBhZ2FpbiBhZnRlciB0aGUgX3JlYWQoKSBlbmRzXHJcbiAgLy8gICB1cCBjYWxsaW5nIHB1c2goKSB3aXRoIG1vcmUgZGF0YS5cclxuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwKSkge1xyXG4gICAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcclxuICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpO1xyXG4gICAgc3RyZWFtLnJlYWQoMCk7XHJcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXHJcbiAgICAgIGJyZWFrO1xyXG4gIH1cclxuXHJcbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcclxufSAvLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXHJcbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXHJcbi8vIGZvciB2aXJ0dWFsIChub24tc3RyaW5nLCBub24tYnVmZmVyKSBzdHJlYW1zLCBcImxlbmd0aFwiIGlzIHNvbWV3aGF0XHJcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cclxuXHJcblxyXG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xyXG4gIGVycm9yT3JEZXN0cm95KHRoaXMsIG5ldyBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCgnX3JlYWQoKScpKTtcclxufTtcclxuXHJcblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3QsIHBpcGVPcHRzKSB7XHJcbiAgdmFyIHNyYyA9IHRoaXM7XHJcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcclxuXHJcbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XHJcbiAgICBjYXNlIDA6XHJcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcclxuICAgICAgYnJlYWs7XHJcblxyXG4gICAgY2FzZSAxOlxyXG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XHJcbiAgICAgIGJyZWFrO1xyXG5cclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XHJcbiAgICAgIGJyZWFrO1xyXG4gIH1cclxuXHJcbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xyXG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XHJcbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcclxuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogdW5waXBlO1xyXG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBwcm9jZXNzLm5leHRUaWNrKGVuZEZuKTtlbHNlIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7XHJcbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xyXG5cclxuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSwgdW5waXBlSW5mbykge1xyXG4gICAgZGVidWcoJ29udW5waXBlJyk7XHJcblxyXG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcclxuICAgICAgaWYgKHVucGlwZUluZm8gJiYgdW5waXBlSW5mby5oYXNVbnBpcGVkID09PSBmYWxzZSkge1xyXG4gICAgICAgIHVucGlwZUluZm8uaGFzVW5waXBlZCA9IHRydWU7XHJcbiAgICAgICAgY2xlYW51cCgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBvbmVuZCgpIHtcclxuICAgIGRlYnVnKCdvbmVuZCcpO1xyXG4gICAgZGVzdC5lbmQoKTtcclxuICB9IC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcclxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xyXG4gIC8vIHRvbyBzbG93LlxyXG5cclxuXHJcbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xyXG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XHJcbiAgdmFyIGNsZWFuZWRVcCA9IGZhbHNlO1xyXG5cclxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xyXG4gICAgZGVidWcoJ2NsZWFudXAnKTsgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxyXG5cclxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XHJcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XHJcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xyXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcclxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcclxuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xyXG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCB1bnBpcGUpO1xyXG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcclxuICAgIGNsZWFuZWRVcCA9IHRydWU7IC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcclxuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxyXG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cclxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cclxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cclxuXHJcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKSBvbmRyYWluKCk7XHJcbiAgfVxyXG5cclxuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xyXG5cclxuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcclxuICAgIGRlYnVnKCdvbmRhdGEnKTtcclxuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcclxuICAgIGRlYnVnKCdkZXN0LndyaXRlJywgcmV0KTtcclxuXHJcbiAgICBpZiAocmV0ID09PSBmYWxzZSkge1xyXG4gICAgICAvLyBJZiB0aGUgdXNlciB1bnBpcGVkIGR1cmluZyBgZGVzdC53cml0ZSgpYCwgaXQgaXMgcG9zc2libGVcclxuICAgICAgLy8gdG8gZ2V0IHN0dWNrIGluIGEgcGVybWFuZW50bHkgcGF1c2VkIHN0YXRlIGlmIHRoYXQgd3JpdGVcclxuICAgICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS5cclxuICAgICAgLy8gPT4gQ2hlY2sgd2hldGhlciBgZGVzdGAgaXMgc3RpbGwgYSBwaXBpbmcgZGVzdGluYXRpb24uXHJcbiAgICAgIGlmICgoc3RhdGUucGlwZXNDb3VudCA9PT0gMSAmJiBzdGF0ZS5waXBlcyA9PT0gZGVzdCB8fCBzdGF0ZS5waXBlc0NvdW50ID4gMSAmJiBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KSAhPT0gLTEpICYmICFjbGVhbmVkVXApIHtcclxuICAgICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJywgc3RhdGUuYXdhaXREcmFpbik7XHJcbiAgICAgICAgc3RhdGUuYXdhaXREcmFpbisrO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzcmMucGF1c2UoKTtcclxuICAgIH1cclxuICB9IC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxyXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cclxuXHJcblxyXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcclxuICAgIGRlYnVnKCdvbmVycm9yJywgZXIpO1xyXG4gICAgdW5waXBlKCk7XHJcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xyXG4gICAgaWYgKEVFbGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMCkgZXJyb3JPckRlc3Ryb3koZGVzdCwgZXIpO1xyXG4gIH0gLy8gTWFrZSBzdXJlIG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSB1c2VybGFuZCBvbmVzLlxyXG5cclxuXHJcbiAgcHJlcGVuZExpc3RlbmVyKGRlc3QsICdlcnJvcicsIG9uZXJyb3IpOyAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxyXG5cclxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xyXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xyXG4gICAgdW5waXBlKCk7XHJcbiAgfVxyXG5cclxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XHJcblxyXG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xyXG4gICAgZGVidWcoJ29uZmluaXNoJyk7XHJcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xyXG4gICAgdW5waXBlKCk7XHJcbiAgfVxyXG5cclxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcclxuXHJcbiAgZnVuY3Rpb24gdW5waXBlKCkge1xyXG4gICAgZGVidWcoJ3VucGlwZScpO1xyXG4gICAgc3JjLnVucGlwZShkZXN0KTtcclxuICB9IC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXHJcblxyXG5cclxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpOyAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXHJcblxyXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xyXG4gICAgZGVidWcoJ3BpcGUgcmVzdW1lJyk7XHJcbiAgICBzcmMucmVzdW1lKCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZGVzdDtcclxufTtcclxuXHJcbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xyXG4gIHJldHVybiBmdW5jdGlvbiBwaXBlT25EcmFpbkZ1bmN0aW9uUmVzdWx0KCkge1xyXG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xyXG4gICAgZGVidWcoJ3BpcGVPbkRyYWluJywgc3RhdGUuYXdhaXREcmFpbik7XHJcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbikgc3RhdGUuYXdhaXREcmFpbi0tO1xyXG5cclxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIEVFbGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykpIHtcclxuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XHJcbiAgICAgIGZsb3coc3JjKTtcclxuICAgIH1cclxuICB9O1xyXG59XHJcblxyXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24gKGRlc3QpIHtcclxuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xyXG4gIHZhciB1bnBpcGVJbmZvID0ge1xyXG4gICAgaGFzVW5waXBlZDogZmFsc2VcclxuICB9OyAvLyBpZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXHJcblxyXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKSByZXR1cm4gdGhpczsgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxyXG5cclxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xyXG4gICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXHJcbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcykgcmV0dXJuIHRoaXM7XHJcbiAgICBpZiAoIWRlc3QpIGRlc3QgPSBzdGF0ZS5waXBlczsgLy8gZ290IGEgbWF0Y2guXHJcblxyXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xyXG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XHJcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XHJcbiAgICBpZiAoZGVzdCkgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH0gLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cclxuXHJcblxyXG4gIGlmICghZGVzdCkge1xyXG4gICAgLy8gcmVtb3ZlIGFsbC5cclxuICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzO1xyXG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XHJcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XHJcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcclxuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMsIHtcclxuICAgICAgICBoYXNVbnBpcGVkOiBmYWxzZVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9IC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXHJcblxyXG5cclxuICB2YXIgaW5kZXggPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcclxuICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gdGhpcztcclxuICBzdGF0ZS5waXBlcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcclxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkgc3RhdGUucGlwZXMgPSBzdGF0ZS5waXBlc1swXTtcclxuICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xyXG4gIHJldHVybiB0aGlzO1xyXG59OyAvLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXHJcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXHJcblxyXG5cclxuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBmbikge1xyXG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcclxuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xyXG5cclxuICBpZiAoZXYgPT09ICdkYXRhJykge1xyXG4gICAgLy8gdXBkYXRlIHJlYWRhYmxlTGlzdGVuaW5nIHNvIHRoYXQgcmVzdW1lKCkgbWF5IGJlIGEgbm8tb3BcclxuICAgIC8vIGEgZmV3IGxpbmVzIGRvd24uIFRoaXMgaXMgbmVlZGVkIHRvIHN1cHBvcnQgb25jZSgncmVhZGFibGUnKS5cclxuICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gdGhpcy5saXN0ZW5lckNvdW50KCdyZWFkYWJsZScpID4gMDsgLy8gVHJ5IHN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZFxyXG5cclxuICAgIGlmIChzdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkgdGhpcy5yZXN1bWUoKTtcclxuICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XHJcbiAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XHJcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcclxuICAgICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xyXG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcclxuICAgICAgZGVidWcoJ29uIHJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5yZWFkaW5nKTtcclxuXHJcbiAgICAgIGlmIChzdGF0ZS5sZW5ndGgpIHtcclxuICAgICAgICBlbWl0UmVhZGFibGUodGhpcyk7XHJcbiAgICAgIH0gZWxzZSBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcclxuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKG5SZWFkaW5nTmV4dFRpY2ssIHRoaXMpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcmVzO1xyXG59O1xyXG5cclxuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xyXG5cclxuUmVhZGFibGUucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGV2LCBmbikge1xyXG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyLmNhbGwodGhpcywgZXYsIGZuKTtcclxuXHJcbiAgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XHJcbiAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGlmIHRoZXJlIGlzIHNvbWVvbmUgc3RpbGwgbGlzdGVuaW5nIHRvXHJcbiAgICAvLyByZWFkYWJsZSBhbmQgcmVzZXQgdGhlIHN0YXRlLiBIb3dldmVyIHRoaXMgbmVlZHMgdG8gaGFwcGVuXHJcbiAgICAvLyBhZnRlciByZWFkYWJsZSBoYXMgYmVlbiBlbWl0dGVkIGJ1dCBiZWZvcmUgSS9PIChuZXh0VGljaykgdG9cclxuICAgIC8vIHN1cHBvcnQgb25jZSgncmVhZGFibGUnLCBmbikgY3ljbGVzLiBUaGlzIG1lYW5zIHRoYXQgY2FsbGluZ1xyXG4gICAgLy8gcmVzdW1lIHdpdGhpbiB0aGUgc2FtZSB0aWNrIHdpbGwgaGF2ZSBub1xyXG4gICAgLy8gZWZmZWN0LlxyXG4gICAgcHJvY2Vzcy5uZXh0VGljayh1cGRhdGVSZWFkYWJsZUxpc3RlbmluZywgdGhpcyk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcmVzO1xyXG59O1xyXG5cclxuUmVhZGFibGUucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIChldikge1xyXG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cclxuICBpZiAoZXYgPT09ICdyZWFkYWJsZScgfHwgZXYgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgLy8gV2UgbmVlZCB0byBjaGVjayBpZiB0aGVyZSBpcyBzb21lb25lIHN0aWxsIGxpc3RlbmluZyB0b1xyXG4gICAgLy8gcmVhZGFibGUgYW5kIHJlc2V0IHRoZSBzdGF0ZS4gSG93ZXZlciB0aGlzIG5lZWRzIHRvIGhhcHBlblxyXG4gICAgLy8gYWZ0ZXIgcmVhZGFibGUgaGFzIGJlZW4gZW1pdHRlZCBidXQgYmVmb3JlIEkvTyAobmV4dFRpY2spIHRvXHJcbiAgICAvLyBzdXBwb3J0IG9uY2UoJ3JlYWRhYmxlJywgZm4pIGN5Y2xlcy4gVGhpcyBtZWFucyB0aGF0IGNhbGxpbmdcclxuICAgIC8vIHJlc3VtZSB3aXRoaW4gdGhlIHNhbWUgdGljayB3aWxsIGhhdmUgbm9cclxuICAgIC8vIGVmZmVjdC5cclxuICAgIHByb2Nlc3MubmV4dFRpY2sodXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcsIHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHJlcztcclxufTtcclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZVJlYWRhYmxlTGlzdGVuaW5nKHNlbGYpIHtcclxuICB2YXIgc3RhdGUgPSBzZWxmLl9yZWFkYWJsZVN0YXRlO1xyXG4gIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gc2VsZi5saXN0ZW5lckNvdW50KCdyZWFkYWJsZScpID4gMDtcclxuXHJcbiAgaWYgKHN0YXRlLnJlc3VtZVNjaGVkdWxlZCAmJiAhc3RhdGUucGF1c2VkKSB7XHJcbiAgICAvLyBmbG93aW5nIG5lZWRzIHRvIGJlIHNldCB0byB0cnVlIG5vdywgb3RoZXJ3aXNlXHJcbiAgICAvLyB0aGUgdXBjb21pbmcgcmVzdW1lIHdpbGwgbm90IGZsb3cuXHJcbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTsgLy8gY3J1ZGUgd2F5IHRvIGNoZWNrIGlmIHdlIHNob3VsZCByZXN1bWVcclxuICB9IGVsc2UgaWYgKHNlbGYubGlzdGVuZXJDb3VudCgnZGF0YScpID4gMCkge1xyXG4gICAgc2VsZi5yZXN1bWUoKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xyXG4gIGRlYnVnKCdyZWFkYWJsZSBuZXh0dGljayByZWFkIDAnKTtcclxuICBzZWxmLnJlYWQoMCk7XHJcbn0gLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxyXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXHJcblxyXG5cclxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xyXG5cclxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcclxuICAgIGRlYnVnKCdyZXN1bWUnKTsgLy8gd2UgZmxvdyBvbmx5IGlmIHRoZXJlIGlzIG5vIG9uZSBsaXN0ZW5pbmdcclxuICAgIC8vIGZvciByZWFkYWJsZSwgYnV0IHdlIHN0aWxsIGhhdmUgdG8gY2FsbFxyXG4gICAgLy8gcmVzdW1lKClcclxuXHJcbiAgICBzdGF0ZS5mbG93aW5nID0gIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nO1xyXG4gICAgcmVzdW1lKHRoaXMsIHN0YXRlKTtcclxuICB9XHJcblxyXG4gIHN0YXRlLnBhdXNlZCA9IGZhbHNlO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcclxuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xyXG4gICAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gdHJ1ZTtcclxuICAgIHByb2Nlc3MubmV4dFRpY2socmVzdW1lXywgc3RyZWFtLCBzdGF0ZSk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcclxuICBkZWJ1ZygncmVzdW1lJywgc3RhdGUucmVhZGluZyk7XHJcblxyXG4gIGlmICghc3RhdGUucmVhZGluZykge1xyXG4gICAgc3RyZWFtLnJlYWQoMCk7XHJcbiAgfVxyXG5cclxuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcclxuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XHJcbiAgZmxvdyhzdHJlYW0pO1xyXG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKSBzdHJlYW0ucmVhZCgwKTtcclxufVxyXG5cclxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xyXG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xyXG5cclxuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkge1xyXG4gICAgZGVidWcoJ3BhdXNlJyk7XHJcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcclxuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcclxuICB9XHJcblxyXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUucGF1c2VkID0gdHJ1ZTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XHJcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xyXG4gIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZyk7XHJcblxyXG4gIHdoaWxlIChzdGF0ZS5mbG93aW5nICYmIHN0cmVhbS5yZWFkKCkgIT09IG51bGwpIHtcclxuICAgIDtcclxuICB9XHJcbn0gLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cclxuLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxyXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cclxuXHJcblxyXG5SZWFkYWJsZS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcclxuICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cclxuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xyXG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcclxuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcclxuICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpO1xyXG5cclxuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xyXG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xyXG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSBfdGhpcy5wdXNoKGNodW5rKTtcclxuICAgIH1cclxuXHJcbiAgICBfdGhpcy5wdXNoKG51bGwpO1xyXG4gIH0pO1xyXG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xyXG4gICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpO1xyXG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7IC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZVxyXG5cclxuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSkgcmV0dXJuO2Vsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpIHJldHVybjtcclxuXHJcbiAgICB2YXIgcmV0ID0gX3RoaXMucHVzaChjaHVuayk7XHJcblxyXG4gICAgaWYgKCFyZXQpIHtcclxuICAgICAgcGF1c2VkID0gdHJ1ZTtcclxuICAgICAgc3RyZWFtLnBhdXNlKCk7XHJcbiAgICB9XHJcbiAgfSk7IC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cclxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cclxuXHJcbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcclxuICAgIGlmICh0aGlzW2ldID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHN0cmVhbVtpXSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24gbWV0aG9kV3JhcChtZXRob2QpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbWV0aG9kV3JhcFJldHVybkZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcclxuICAgICAgICB9O1xyXG4gICAgICB9KGkpO1xyXG4gICAgfVxyXG4gIH0gLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxyXG5cclxuXHJcbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBrUHJveHlFdmVudHMubGVuZ3RoOyBuKyspIHtcclxuICAgIHN0cmVhbS5vbihrUHJveHlFdmVudHNbbl0sIHRoaXMuZW1pdC5iaW5kKHRoaXMsIGtQcm94eUV2ZW50c1tuXSkpO1xyXG4gIH0gLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxyXG4gIC8vIHVuZGVybHlpbmcgc3RyZWFtLlxyXG5cclxuXHJcbiAgdGhpcy5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XHJcbiAgICBkZWJ1Zygnd3JhcHBlZCBfcmVhZCcsIG4pO1xyXG5cclxuICAgIGlmIChwYXVzZWQpIHtcclxuICAgICAgcGF1c2VkID0gZmFsc2U7XHJcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgUmVhZGFibGUucHJvdG90eXBlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmIChjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvYXN5bmNfaXRlcmF0b3InKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yKHRoaXMpO1xyXG4gIH07XHJcbn1cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUhpZ2hXYXRlck1hcmsnLCB7XHJcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcclxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cclxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcclxuICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XHJcbiAgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlQnVmZmVyJywge1xyXG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXHJcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXHJcbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXHJcbiAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlcjtcclxuICB9XHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVGbG93aW5nJywge1xyXG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXHJcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXHJcbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXHJcbiAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nO1xyXG4gIH0sXHJcbiAgc2V0OiBmdW5jdGlvbiBzZXQoc3RhdGUpIHtcclxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XHJcbiAgICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IHN0YXRlO1xyXG4gICAgfVxyXG4gIH1cclxufSk7IC8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cclxuXHJcblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVMZW5ndGgnLCB7XHJcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcclxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cclxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcclxuICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmxlbmd0aDtcclxuICB9XHJcbn0pOyAvLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXHJcbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXHJcbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXHJcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXHJcblxyXG5mdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZSkge1xyXG4gIC8vIG5vdGhpbmcgYnVmZmVyZWRcclxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcclxuICB2YXIgcmV0O1xyXG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXQgPSBzdGF0ZS5idWZmZXIuc2hpZnQoKTtlbHNlIGlmICghbiB8fCBuID49IHN0YXRlLmxlbmd0aCkge1xyXG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XHJcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgcmV0ID0gc3RhdGUuYnVmZmVyLmpvaW4oJycpO2Vsc2UgaWYgKHN0YXRlLmJ1ZmZlci5sZW5ndGggPT09IDEpIHJldCA9IHN0YXRlLmJ1ZmZlci5maXJzdCgpO2Vsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpO1xyXG4gICAgc3RhdGUuYnVmZmVyLmNsZWFyKCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIHJlYWQgcGFydCBvZiBsaXN0XHJcbiAgICByZXQgPSBzdGF0ZS5idWZmZXIuY29uc3VtZShuLCBzdGF0ZS5kZWNvZGVyKTtcclxuICB9XHJcbiAgcmV0dXJuIHJldDtcclxufVxyXG5cclxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XHJcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xyXG4gIGRlYnVnKCdlbmRSZWFkYWJsZScsIHN0YXRlLmVuZEVtaXR0ZWQpO1xyXG5cclxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHtcclxuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcclxuICAgIHByb2Nlc3MubmV4dFRpY2soZW5kUmVhZGFibGVOVCwgc3RhdGUsIHN0cmVhbSk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBlbmRSZWFkYWJsZU5UKHN0YXRlLCBzdHJlYW0pIHtcclxuICBkZWJ1ZygnZW5kUmVhZGFibGVOVCcsIHN0YXRlLmVuZEVtaXR0ZWQsIHN0YXRlLmxlbmd0aCk7IC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxyXG5cclxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XHJcbiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcclxuICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xyXG4gICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xyXG5cclxuICAgIGlmIChzdGF0ZS5hdXRvRGVzdHJveSkge1xyXG4gICAgICAvLyBJbiBjYXNlIG9mIGR1cGxleCBzdHJlYW1zIHdlIG5lZWQgYSB3YXkgdG8gZGV0ZWN0XHJcbiAgICAgIC8vIGlmIHRoZSB3cml0YWJsZSBzaWRlIGlzIHJlYWR5IGZvciBhdXRvRGVzdHJveSBhcyB3ZWxsXHJcbiAgICAgIHZhciB3U3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XHJcblxyXG4gICAgICBpZiAoIXdTdGF0ZSB8fCB3U3RhdGUuYXV0b0Rlc3Ryb3kgJiYgd1N0YXRlLmZpbmlzaGVkKSB7XHJcbiAgICAgICAgc3RyZWFtLmRlc3Ryb3koKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcclxuICBSZWFkYWJsZS5mcm9tID0gZnVuY3Rpb24gKGl0ZXJhYmxlLCBvcHRzKSB7XHJcbiAgICBpZiAoZnJvbSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGZyb20gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZnJvbScpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmcm9tKFJlYWRhYmxlLCBpdGVyYWJsZSwgb3B0cyk7XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xyXG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIC0xO1xyXG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/readable-stream/lib/_stream_readable.js\n");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_transform.js":
/*!***************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_transform.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the\r\n// \"Software\"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n// persons to whom the Software is furnished to do so, subject to the\r\n// following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n// a transform stream is a readable/writable stream where you do\r\n// something with the data.  Sometimes it's called a \"filter\",\r\n// but that's not a great name for it, since that implies a thing where\r\n// some bits pass through, and others are simply ignored.  (That would\r\n// be a valid example of a transform, of course.)\r\n//\r\n// While the output is causally related to the input, it's not a\r\n// necessarily symmetric or synchronous transformation.  For example,\r\n// a zlib stream might take multiple plain-text writes(), and then\r\n// emit a single compressed chunk some time in the future.\r\n//\r\n// Here's how this works:\r\n//\r\n// The Transform stream has all the aspects of the readable and writable\r\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\r\n// internally, and returns false if there's a lot of pending writes\r\n// buffered up.  When you call read(), that calls _read(n) until\r\n// there's enough pending readable data buffered up.\r\n//\r\n// In a transform stream, the written data is placed in a buffer.  When\r\n// _read(n) is called, it transforms the queued up data, calling the\r\n// buffered _write cb's as it consumes chunks.  If consuming a single\r\n// written chunk would result in multiple output chunks, then the first\r\n// outputted bit calls the readcb, and subsequent chunks just go into\r\n// the read buffer, and will cause it to emit 'readable' if necessary.\r\n//\r\n// This way, back-pressure is actually determined by the reading side,\r\n// since _read has to be called to start processing a new chunk.  However,\r\n// a pathological inflate type of transform can cause excessive buffering\r\n// here.  For example, imagine a stream where every byte of input is\r\n// interpreted as an integer from 0-255, and then results in that many\r\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\r\n// 1kb of data being output.  In this case, you could write a very small\r\n// amount of input, and end up with a very large amount of output.  In\r\n// such a pathological inflating mechanism, there'd be no way to tell\r\n// the system to stop doing the transform.  A single 4MB write could\r\n// cause the system to run out of memory.\r\n//\r\n// However, even in such a pathological case, only a single written chunk\r\n// would be consumed, and then the rest would wait (un-transformed) until\r\n// the results of the previous transformed chunk were consumed.\r\n\r\n\r\nmodule.exports = Transform;\r\n\r\nvar _require$codes = (__webpack_require__(/*! ../errors */ \"./node_modules/readable-stream/errors-browser.js\").codes),\r\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\r\n    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\r\n    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,\r\n    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;\r\n\r\nvar Duplex = __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\r\n\r\n__webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")(Transform, Duplex);\r\n\r\nfunction afterTransform(er, data) {\r\n  var ts = this._transformState;\r\n  ts.transforming = false;\r\n  var cb = ts.writecb;\r\n\r\n  if (cb === null) {\r\n    return this.emit('error', new ERR_MULTIPLE_CALLBACK());\r\n  }\r\n\r\n  ts.writechunk = null;\r\n  ts.writecb = null;\r\n  if (data != null) // single equals check for both `null` and `undefined`\r\n    this.push(data);\r\n  cb(er);\r\n  var rs = this._readableState;\r\n  rs.reading = false;\r\n\r\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\r\n    this._read(rs.highWaterMark);\r\n  }\r\n}\r\n\r\nfunction Transform(options) {\r\n  if (!(this instanceof Transform)) return new Transform(options);\r\n  Duplex.call(this, options);\r\n  this._transformState = {\r\n    afterTransform: afterTransform.bind(this),\r\n    needTransform: false,\r\n    transforming: false,\r\n    writecb: null,\r\n    writechunk: null,\r\n    writeencoding: null\r\n  }; // start out asking for a readable event once data is transformed.\r\n\r\n  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things\r\n  // that Readable wants before the first _read call, so unset the\r\n  // sync guard flag.\r\n\r\n  this._readableState.sync = false;\r\n\r\n  if (options) {\r\n    if (typeof options.transform === 'function') this._transform = options.transform;\r\n    if (typeof options.flush === 'function') this._flush = options.flush;\r\n  } // When the writable side finishes, then flush out anything remaining.\r\n\r\n\r\n  this.on('prefinish', prefinish);\r\n}\r\n\r\nfunction prefinish() {\r\n  var _this = this;\r\n\r\n  if (typeof this._flush === 'function' && !this._readableState.destroyed) {\r\n    this._flush(function (er, data) {\r\n      done(_this, er, data);\r\n    });\r\n  } else {\r\n    done(this, null, null);\r\n  }\r\n}\r\n\r\nTransform.prototype.push = function (chunk, encoding) {\r\n  this._transformState.needTransform = false;\r\n  return Duplex.prototype.push.call(this, chunk, encoding);\r\n}; // This is the part where you do stuff!\r\n// override this function in implementation classes.\r\n// 'chunk' is an input chunk.\r\n//\r\n// Call `push(newChunk)` to pass along transformed output\r\n// to the readable side.  You may call 'push' zero or more times.\r\n//\r\n// Call `cb(err)` when you are done with this chunk.  If you pass\r\n// an error, then that'll put the hurt on the whole operation.  If you\r\n// never call cb(), then you'll never get another chunk.\r\n\r\n\r\nTransform.prototype._transform = function (chunk, encoding, cb) {\r\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));\r\n};\r\n\r\nTransform.prototype._write = function (chunk, encoding, cb) {\r\n  var ts = this._transformState;\r\n  ts.writecb = cb;\r\n  ts.writechunk = chunk;\r\n  ts.writeencoding = encoding;\r\n\r\n  if (!ts.transforming) {\r\n    var rs = this._readableState;\r\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\r\n  }\r\n}; // Doesn't matter what the args are here.\r\n// _transform does all the work.\r\n// That we got here means that the readable side wants more data.\r\n\r\n\r\nTransform.prototype._read = function (n) {\r\n  var ts = this._transformState;\r\n\r\n  if (ts.writechunk !== null && !ts.transforming) {\r\n    ts.transforming = true;\r\n\r\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\r\n  } else {\r\n    // mark that we need a transform, so that any data that comes in\r\n    // will get processed, now that we've asked for it.\r\n    ts.needTransform = true;\r\n  }\r\n};\r\n\r\nTransform.prototype._destroy = function (err, cb) {\r\n  Duplex.prototype._destroy.call(this, err, function (err2) {\r\n    cb(err2);\r\n  });\r\n};\r\n\r\nfunction done(stream, er, data) {\r\n  if (er) return stream.emit('error', er);\r\n  if (data != null) // single equals check for both `null` and `undefined`\r\n    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases\r\n  // if there's nothing in the write buffer, then that means\r\n  // that nothing more will ever be provided\r\n\r\n  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();\r\n  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();\r\n  return stream.push(null);\r\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsYUFBYTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnR0FBMEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyw4RUFBa0I7QUFDdkM7QUFDQSxtQkFBTyxDQUFDLDZEQUFVO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanM/MjQyZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cclxuLy9cclxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcclxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxyXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcclxuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxyXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XHJcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxyXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuLy9cclxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcclxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbi8vXHJcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1NcclxuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxyXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXHJcbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxyXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1JcclxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxyXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG4vLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXHJcbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXCJmaWx0ZXJcIixcclxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcclxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxyXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXHJcbi8vXHJcbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcclxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXHJcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxyXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXHJcbi8vXHJcbi8vIEhlcmUncyBob3cgdGhpcyB3b3JrczpcclxuLy9cclxuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXHJcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcclxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xyXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXHJcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cclxuLy9cclxuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cclxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcclxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXHJcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XHJcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xyXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXHJcbi8vXHJcbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcclxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcclxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xyXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xyXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XHJcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cclxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXHJcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cclxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXHJcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXHJcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXHJcbi8vXHJcbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcclxuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxyXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XHJcblxyXG52YXIgX3JlcXVpcmUkY29kZXMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKS5jb2RlcyxcclxuICAgIEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEID0gX3JlcXVpcmUkY29kZXMuRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQsXHJcbiAgICBFUlJfTVVMVElQTEVfQ0FMTEJBQ0sgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTVVMVElQTEVfQ0FMTEJBQ0ssXHJcbiAgICBFUlJfVFJBTlNGT1JNX0FMUkVBRFlfVFJBTlNGT1JNSU5HID0gX3JlcXVpcmUkY29kZXMuRVJSX1RSQU5TRk9STV9BTFJFQURZX1RSQU5TRk9STUlORyxcclxuICAgIEVSUl9UUkFOU0ZPUk1fV0lUSF9MRU5HVEhfMCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9UUkFOU0ZPUk1fV0lUSF9MRU5HVEhfMDtcclxuXHJcbnZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XHJcblxyXG5yZXF1aXJlKCdpbmhlcml0cycpKFRyYW5zZm9ybSwgRHVwbGV4KTtcclxuXHJcbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKGVyLCBkYXRhKSB7XHJcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XHJcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XHJcbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcclxuXHJcbiAgaWYgKGNiID09PSBudWxsKSB7XHJcbiAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFUlJfTVVMVElQTEVfQ0FMTEJBQ0soKSk7XHJcbiAgfVxyXG5cclxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcclxuICB0cy53cml0ZWNiID0gbnVsbDtcclxuICBpZiAoZGF0YSAhPSBudWxsKSAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcclxuICAgIHRoaXMucHVzaChkYXRhKTtcclxuICBjYihlcik7XHJcbiAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcclxuICBycy5yZWFkaW5nID0gZmFsc2U7XHJcblxyXG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xyXG4gICAgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XHJcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpO1xyXG4gIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xyXG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlID0ge1xyXG4gICAgYWZ0ZXJUcmFuc2Zvcm06IGFmdGVyVHJhbnNmb3JtLmJpbmQodGhpcyksXHJcbiAgICBuZWVkVHJhbnNmb3JtOiBmYWxzZSxcclxuICAgIHRyYW5zZm9ybWluZzogZmFsc2UsXHJcbiAgICB3cml0ZWNiOiBudWxsLFxyXG4gICAgd3JpdGVjaHVuazogbnVsbCxcclxuICAgIHdyaXRlZW5jb2Rpbmc6IG51bGxcclxuICB9OyAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cclxuXHJcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlOyAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcclxuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXHJcbiAgLy8gc3luYyBndWFyZCBmbGFnLlxyXG5cclxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZTtcclxuXHJcbiAgaWYgKG9wdGlvbnMpIHtcclxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHRoaXMuX3RyYW5zZm9ybSA9IG9wdGlvbnMudHJhbnNmb3JtO1xyXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaCA9IG9wdGlvbnMuZmx1c2g7XHJcbiAgfSAvLyBXaGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXHJcblxyXG5cclxuICB0aGlzLm9uKCdwcmVmaW5pc2gnLCBwcmVmaW5pc2gpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwcmVmaW5pc2goKSB7XHJcbiAgdmFyIF90aGlzID0gdGhpcztcclxuXHJcbiAgaWYgKHR5cGVvZiB0aGlzLl9mbHVzaCA9PT0gJ2Z1bmN0aW9uJyAmJiAhdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQpIHtcclxuICAgIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uIChlciwgZGF0YSkge1xyXG4gICAgICBkb25lKF90aGlzLCBlciwgZGF0YSk7XHJcbiAgICB9KTtcclxuICB9IGVsc2Uge1xyXG4gICAgZG9uZSh0aGlzLCBudWxsLCBudWxsKTtcclxuICB9XHJcbn1cclxuXHJcblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcclxuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XHJcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XHJcbn07IC8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxyXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXHJcbi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXHJcbi8vXHJcbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxyXG4vLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxyXG4vL1xyXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xyXG4vLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XHJcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXHJcblxyXG5cclxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcclxuICBjYihuZXcgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQoJ190cmFuc2Zvcm0oKScpKTtcclxufTtcclxuXHJcblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcclxuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcclxuICB0cy53cml0ZWNiID0gY2I7XHJcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xyXG4gIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcclxuXHJcbiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcclxuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XHJcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fCBycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcclxuICB9XHJcbn07IC8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXHJcbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXHJcbi8vIFRoYXQgd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGUgcmVhZGFibGUgc2lkZSB3YW50cyBtb3JlIGRhdGEuXHJcblxyXG5cclxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XHJcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XHJcblxyXG4gIGlmICh0cy53cml0ZWNodW5rICE9PSBudWxsICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcclxuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XHJcblxyXG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcclxuICB9IGVsc2Uge1xyXG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxyXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXHJcbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcclxuICB9XHJcbn07XHJcblxyXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcclxuICBEdXBsZXgucHJvdG90eXBlLl9kZXN0cm95LmNhbGwodGhpcywgZXJyLCBmdW5jdGlvbiAoZXJyMikge1xyXG4gICAgY2IoZXJyMik7XHJcbiAgfSk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIsIGRhdGEpIHtcclxuICBpZiAoZXIpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XHJcbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXHJcbiAgICBzdHJlYW0ucHVzaChkYXRhKTsgLy8gVE9ETyhCcmlkZ2VBUik6IFdyaXRlIGEgdGVzdCBmb3IgdGhlc2UgdHdvIGVycm9yIGNhc2VzXHJcbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xyXG4gIC8vIHRoYXQgbm90aGluZyBtb3JlIHdpbGwgZXZlciBiZSBwcm92aWRlZFxyXG5cclxuICBpZiAoc3RyZWFtLl93cml0YWJsZVN0YXRlLmxlbmd0aCkgdGhyb3cgbmV3IEVSUl9UUkFOU0ZPUk1fV0lUSF9MRU5HVEhfMCgpO1xyXG4gIGlmIChzdHJlYW0uX3RyYW5zZm9ybVN0YXRlLnRyYW5zZm9ybWluZykgdGhyb3cgbmV3IEVSUl9UUkFOU0ZPUk1fQUxSRUFEWV9UUkFOU0ZPUk1JTkcoKTtcclxuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XHJcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/readable-stream/lib/_stream_transform.js\n");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_writable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_writable.js ***!
  \**************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/process/browser.js\");\n// Copyright Joyent, Inc. and other Node contributors.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the\r\n// \"Software\"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n// persons to whom the Software is furnished to do so, subject to the\r\n// following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n// A bit simpler than readable streams.\r\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\r\n// the drain event emission and buffering.\r\n\r\n\r\nmodule.exports = Writable;\r\n/* <replacement> */\r\n\r\nfunction WriteReq(chunk, encoding, cb) {\r\n  this.chunk = chunk;\r\n  this.encoding = encoding;\r\n  this.callback = cb;\r\n  this.next = null;\r\n} // It seems a linked list but it is not\r\n// there will be only 2 of these for each stream\r\n\r\n\r\nfunction CorkedRequest(state) {\r\n  var _this = this;\r\n\r\n  this.next = null;\r\n  this.entry = null;\r\n\r\n  this.finish = function () {\r\n    onCorkedFinish(_this, state);\r\n  };\r\n}\r\n/* </replacement> */\r\n\r\n/*<replacement>*/\r\n\r\n\r\nvar Duplex;\r\n/*</replacement>*/\r\n\r\nWritable.WritableState = WritableState;\r\n/*<replacement>*/\r\n\r\nvar internalUtil = {\r\n  deprecate: __webpack_require__(/*! util-deprecate */ \"./node_modules/util-deprecate/browser.js\")\r\n};\r\n/*</replacement>*/\r\n\r\n/*<replacement>*/\r\n\r\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \"./node_modules/readable-stream/lib/internal/streams/stream-browser.js\");\r\n/*</replacement>*/\r\n\r\n\r\nvar Buffer = (__webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\").Buffer);\r\n\r\nvar OurUint8Array = __webpack_require__.g.Uint8Array || function () {};\r\n\r\nfunction _uint8ArrayToBuffer(chunk) {\r\n  return Buffer.from(chunk);\r\n}\r\n\r\nfunction _isUint8Array(obj) {\r\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\r\n}\r\n\r\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"./node_modules/readable-stream/lib/internal/streams/destroy.js\");\r\n\r\nvar _require = __webpack_require__(/*! ./internal/streams/state */ \"./node_modules/readable-stream/lib/internal/streams/state.js\"),\r\n    getHighWaterMark = _require.getHighWaterMark;\r\n\r\nvar _require$codes = (__webpack_require__(/*! ../errors */ \"./node_modules/readable-stream/errors-browser.js\").codes),\r\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\r\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\r\n    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\r\n    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,\r\n    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,\r\n    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,\r\n    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,\r\n    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;\r\n\r\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\r\n\r\n__webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")(Writable, Stream);\r\n\r\nfunction nop() {}\r\n\r\nfunction WritableState(options, stream, isDuplex) {\r\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\r\n  options = options || {}; // Duplex streams are both readable and writable, but share\r\n  // the same options object.\r\n  // However, some cases require setting options to different\r\n  // values for the readable and the writable sides of the duplex stream,\r\n  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.\r\n\r\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream\r\n  // contains buffers or objects.\r\n\r\n  this.objectMode = !!options.objectMode;\r\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false\r\n  // Note: 0 is a valid value, means that we always return false if\r\n  // the entire buffer is not flushed immediately on write()\r\n\r\n  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called\r\n\r\n  this.finalCalled = false; // drain event flag.\r\n\r\n  this.needDrain = false; // at the start of calling end()\r\n\r\n  this.ending = false; // when end() has been called, and returned\r\n\r\n  this.ended = false; // when 'finish' is emitted\r\n\r\n  this.finished = false; // has it been destroyed\r\n\r\n  this.destroyed = false; // should we decode strings into buffers before passing to _write?\r\n  // this is here so that some node-core streams can optimize string\r\n  // handling at a lower level.\r\n\r\n  var noDecode = options.decodeStrings === false;\r\n  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string\r\n  // encoding is 'binary' so we have to make this configurable.\r\n  // Everything else in the universe uses 'utf8', though.\r\n\r\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement\r\n  // of how much we're waiting to get pushed to some underlying\r\n  // socket or file.\r\n\r\n  this.length = 0; // a flag to see when we're in the middle of a write.\r\n\r\n  this.writing = false; // when true all writes will be buffered until .uncork() call\r\n\r\n  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,\r\n  // or on a later tick.  We set this to true at first, because any\r\n  // actions that shouldn't happen until \"later\" should generally also\r\n  // not happen before the first write call.\r\n\r\n  this.sync = true; // a flag to know if we're processing previously buffered items, which\r\n  // may call the _write() callback in the same tick, so that we don't\r\n  // end up in an overlapped onwrite situation.\r\n\r\n  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)\r\n\r\n  this.onwrite = function (er) {\r\n    onwrite(stream, er);\r\n  }; // the callback that the user supplies to write(chunk,encoding,cb)\r\n\r\n\r\n  this.writecb = null; // the amount that is being written when _write is called.\r\n\r\n  this.writelen = 0;\r\n  this.bufferedRequest = null;\r\n  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks\r\n  // this must be 0 before 'finish' can be emitted\r\n\r\n  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs\r\n  // This is relevant for synchronous Transform streams\r\n\r\n  this.prefinished = false; // True if the error was already emitted and should not be thrown again\r\n\r\n  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.\r\n\r\n  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')\r\n\r\n  this.autoDestroy = !!options.autoDestroy; // count buffered requests\r\n\r\n  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always\r\n  // one allocated and free to use, and we maintain at most two\r\n\r\n  this.corkedRequestsFree = new CorkedRequest(this);\r\n}\r\n\r\nWritableState.prototype.getBuffer = function getBuffer() {\r\n  var current = this.bufferedRequest;\r\n  var out = [];\r\n\r\n  while (current) {\r\n    out.push(current);\r\n    current = current.next;\r\n  }\r\n\r\n  return out;\r\n};\r\n\r\n(function () {\r\n  try {\r\n    Object.defineProperty(WritableState.prototype, 'buffer', {\r\n      get: internalUtil.deprecate(function writableStateBufferGetter() {\r\n        return this.getBuffer();\r\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\r\n    });\r\n  } catch (_) {}\r\n})(); // Test _writableState for inheritance to account for Duplex streams,\r\n// whose prototype chain only points to Readable.\r\n\r\n\r\nvar realHasInstance;\r\n\r\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\r\n  realHasInstance = Function.prototype[Symbol.hasInstance];\r\n  Object.defineProperty(Writable, Symbol.hasInstance, {\r\n    value: function value(object) {\r\n      if (realHasInstance.call(this, object)) return true;\r\n      if (this !== Writable) return false;\r\n      return object && object._writableState instanceof WritableState;\r\n    }\r\n  });\r\n} else {\r\n  realHasInstance = function realHasInstance(object) {\r\n    return object instanceof this;\r\n  };\r\n}\r\n\r\nfunction Writable(options) {\r\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\"); // Writable ctor is applied to Duplexes, too.\r\n  // `realHasInstance` is necessary because using plain `instanceof`\r\n  // would return false, as no `_writableState` property is attached.\r\n  // Trying to use the custom `instanceof` for Writable here will also break the\r\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\r\n  // `_writableState` that would lead to infinite recursion.\r\n  // Checking for a Stream.Duplex instance is faster here instead of inside\r\n  // the WritableState constructor, at least with V8 6.5\r\n\r\n  var isDuplex = this instanceof Duplex;\r\n  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);\r\n  this._writableState = new WritableState(options, this, isDuplex); // legacy.\r\n\r\n  this.writable = true;\r\n\r\n  if (options) {\r\n    if (typeof options.write === 'function') this._write = options.write;\r\n    if (typeof options.writev === 'function') this._writev = options.writev;\r\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\r\n    if (typeof options.final === 'function') this._final = options.final;\r\n  }\r\n\r\n  Stream.call(this);\r\n} // Otherwise people can pipe Writable streams, which is just wrong.\r\n\r\n\r\nWritable.prototype.pipe = function () {\r\n  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());\r\n};\r\n\r\nfunction writeAfterEnd(stream, cb) {\r\n  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb\r\n\r\n  errorOrDestroy(stream, er);\r\n  process.nextTick(cb, er);\r\n} // Checks that a user-supplied chunk is valid, especially for the particular\r\n// mode the stream is in. Currently this means that `null` is never accepted\r\n// and undefined/non-string values are only allowed in object mode.\r\n\r\n\r\nfunction validChunk(stream, state, chunk, cb) {\r\n  var er;\r\n\r\n  if (chunk === null) {\r\n    er = new ERR_STREAM_NULL_VALUES();\r\n  } else if (typeof chunk !== 'string' && !state.objectMode) {\r\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);\r\n  }\r\n\r\n  if (er) {\r\n    errorOrDestroy(stream, er);\r\n    process.nextTick(cb, er);\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nWritable.prototype.write = function (chunk, encoding, cb) {\r\n  var state = this._writableState;\r\n  var ret = false;\r\n\r\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\r\n\r\n  if (isBuf && !Buffer.isBuffer(chunk)) {\r\n    chunk = _uint8ArrayToBuffer(chunk);\r\n  }\r\n\r\n  if (typeof encoding === 'function') {\r\n    cb = encoding;\r\n    encoding = null;\r\n  }\r\n\r\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\r\n  if (typeof cb !== 'function') cb = nop;\r\n  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\r\n    state.pendingcb++;\r\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\r\n  }\r\n  return ret;\r\n};\r\n\r\nWritable.prototype.cork = function () {\r\n  this._writableState.corked++;\r\n};\r\n\r\nWritable.prototype.uncork = function () {\r\n  var state = this._writableState;\r\n\r\n  if (state.corked) {\r\n    state.corked--;\r\n    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\r\n  }\r\n};\r\n\r\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\r\n  // node::ParseEncoding() requires lower case.\r\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\r\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);\r\n  this._writableState.defaultEncoding = encoding;\r\n  return this;\r\n};\r\n\r\nObject.defineProperty(Writable.prototype, 'writableBuffer', {\r\n  // making it explicit this property is not enumerable\r\n  // because otherwise some prototype manipulation in\r\n  // userland will fail\r\n  enumerable: false,\r\n  get: function get() {\r\n    return this._writableState && this._writableState.getBuffer();\r\n  }\r\n});\r\n\r\nfunction decodeChunk(state, chunk, encoding) {\r\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\r\n    chunk = Buffer.from(chunk, encoding);\r\n  }\r\n\r\n  return chunk;\r\n}\r\n\r\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\r\n  // making it explicit this property is not enumerable\r\n  // because otherwise some prototype manipulation in\r\n  // userland will fail\r\n  enumerable: false,\r\n  get: function get() {\r\n    return this._writableState.highWaterMark;\r\n  }\r\n}); // if we're already writing something, then just put this\r\n// in the queue, and wait our turn.  Otherwise, call _write\r\n// If we return false, then we need a drain event, so set that flag.\r\n\r\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\r\n  if (!isBuf) {\r\n    var newChunk = decodeChunk(state, chunk, encoding);\r\n\r\n    if (chunk !== newChunk) {\r\n      isBuf = true;\r\n      encoding = 'buffer';\r\n      chunk = newChunk;\r\n    }\r\n  }\r\n\r\n  var len = state.objectMode ? 1 : chunk.length;\r\n  state.length += len;\r\n  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.\r\n\r\n  if (!ret) state.needDrain = true;\r\n\r\n  if (state.writing || state.corked) {\r\n    var last = state.lastBufferedRequest;\r\n    state.lastBufferedRequest = {\r\n      chunk: chunk,\r\n      encoding: encoding,\r\n      isBuf: isBuf,\r\n      callback: cb,\r\n      next: null\r\n    };\r\n\r\n    if (last) {\r\n      last.next = state.lastBufferedRequest;\r\n    } else {\r\n      state.bufferedRequest = state.lastBufferedRequest;\r\n    }\r\n\r\n    state.bufferedRequestCount += 1;\r\n  } else {\r\n    doWrite(stream, state, false, len, chunk, encoding, cb);\r\n  }\r\n\r\n  return ret;\r\n}\r\n\r\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\r\n  state.writelen = len;\r\n  state.writecb = cb;\r\n  state.writing = true;\r\n  state.sync = true;\r\n  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\r\n  state.sync = false;\r\n}\r\n\r\nfunction onwriteError(stream, state, sync, er, cb) {\r\n  --state.pendingcb;\r\n\r\n  if (sync) {\r\n    // defer the callback if we are being called synchronously\r\n    // to avoid piling up things on the stack\r\n    process.nextTick(cb, er); // this can emit finish, and it will always happen\r\n    // after error\r\n\r\n    process.nextTick(finishMaybe, stream, state);\r\n    stream._writableState.errorEmitted = true;\r\n    errorOrDestroy(stream, er);\r\n  } else {\r\n    // the caller expect this to happen before if\r\n    // it is async\r\n    cb(er);\r\n    stream._writableState.errorEmitted = true;\r\n    errorOrDestroy(stream, er); // this can emit finish, but finish must\r\n    // always follow error\r\n\r\n    finishMaybe(stream, state);\r\n  }\r\n}\r\n\r\nfunction onwriteStateUpdate(state) {\r\n  state.writing = false;\r\n  state.writecb = null;\r\n  state.length -= state.writelen;\r\n  state.writelen = 0;\r\n}\r\n\r\nfunction onwrite(stream, er) {\r\n  var state = stream._writableState;\r\n  var sync = state.sync;\r\n  var cb = state.writecb;\r\n  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();\r\n  onwriteStateUpdate(state);\r\n  if (er) onwriteError(stream, state, sync, er, cb);else {\r\n    // Check if we're actually ready to finish, but don't emit yet\r\n    var finished = needFinish(state) || stream.destroyed;\r\n\r\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\r\n      clearBuffer(stream, state);\r\n    }\r\n\r\n    if (sync) {\r\n      process.nextTick(afterWrite, stream, state, finished, cb);\r\n    } else {\r\n      afterWrite(stream, state, finished, cb);\r\n    }\r\n  }\r\n}\r\n\r\nfunction afterWrite(stream, state, finished, cb) {\r\n  if (!finished) onwriteDrain(stream, state);\r\n  state.pendingcb--;\r\n  cb();\r\n  finishMaybe(stream, state);\r\n} // Must force callback to be called on nextTick, so that we don't\r\n// emit 'drain' before the write() consumer gets the 'false' return\r\n// value, and has a chance to attach a 'drain' listener.\r\n\r\n\r\nfunction onwriteDrain(stream, state) {\r\n  if (state.length === 0 && state.needDrain) {\r\n    state.needDrain = false;\r\n    stream.emit('drain');\r\n  }\r\n} // if there's something in the buffer waiting, then process it\r\n\r\n\r\nfunction clearBuffer(stream, state) {\r\n  state.bufferProcessing = true;\r\n  var entry = state.bufferedRequest;\r\n\r\n  if (stream._writev && entry && entry.next) {\r\n    // Fast case, write everything using _writev()\r\n    var l = state.bufferedRequestCount;\r\n    var buffer = new Array(l);\r\n    var holder = state.corkedRequestsFree;\r\n    holder.entry = entry;\r\n    var count = 0;\r\n    var allBuffers = true;\r\n\r\n    while (entry) {\r\n      buffer[count] = entry;\r\n      if (!entry.isBuf) allBuffers = false;\r\n      entry = entry.next;\r\n      count += 1;\r\n    }\r\n\r\n    buffer.allBuffers = allBuffers;\r\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time\r\n    // as the hot path ends with doWrite\r\n\r\n    state.pendingcb++;\r\n    state.lastBufferedRequest = null;\r\n\r\n    if (holder.next) {\r\n      state.corkedRequestsFree = holder.next;\r\n      holder.next = null;\r\n    } else {\r\n      state.corkedRequestsFree = new CorkedRequest(state);\r\n    }\r\n\r\n    state.bufferedRequestCount = 0;\r\n  } else {\r\n    // Slow case, write chunks one-by-one\r\n    while (entry) {\r\n      var chunk = entry.chunk;\r\n      var encoding = entry.encoding;\r\n      var cb = entry.callback;\r\n      var len = state.objectMode ? 1 : chunk.length;\r\n      doWrite(stream, state, false, len, chunk, encoding, cb);\r\n      entry = entry.next;\r\n      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then\r\n      // it means that we need to wait until it does.\r\n      // also, that means that the chunk and cb are currently\r\n      // being processed, so move the buffer counter past them.\r\n\r\n      if (state.writing) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (entry === null) state.lastBufferedRequest = null;\r\n  }\r\n\r\n  state.bufferedRequest = entry;\r\n  state.bufferProcessing = false;\r\n}\r\n\r\nWritable.prototype._write = function (chunk, encoding, cb) {\r\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));\r\n};\r\n\r\nWritable.prototype._writev = null;\r\n\r\nWritable.prototype.end = function (chunk, encoding, cb) {\r\n  var state = this._writableState;\r\n\r\n  if (typeof chunk === 'function') {\r\n    cb = chunk;\r\n    chunk = null;\r\n    encoding = null;\r\n  } else if (typeof encoding === 'function') {\r\n    cb = encoding;\r\n    encoding = null;\r\n  }\r\n\r\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks\r\n\r\n  if (state.corked) {\r\n    state.corked = 1;\r\n    this.uncork();\r\n  } // ignore unnecessary end() calls.\r\n\r\n\r\n  if (!state.ending) endWritable(this, state, cb);\r\n  return this;\r\n};\r\n\r\nObject.defineProperty(Writable.prototype, 'writableLength', {\r\n  // making it explicit this property is not enumerable\r\n  // because otherwise some prototype manipulation in\r\n  // userland will fail\r\n  enumerable: false,\r\n  get: function get() {\r\n    return this._writableState.length;\r\n  }\r\n});\r\n\r\nfunction needFinish(state) {\r\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\r\n}\r\n\r\nfunction callFinal(stream, state) {\r\n  stream._final(function (err) {\r\n    state.pendingcb--;\r\n\r\n    if (err) {\r\n      errorOrDestroy(stream, err);\r\n    }\r\n\r\n    state.prefinished = true;\r\n    stream.emit('prefinish');\r\n    finishMaybe(stream, state);\r\n  });\r\n}\r\n\r\nfunction prefinish(stream, state) {\r\n  if (!state.prefinished && !state.finalCalled) {\r\n    if (typeof stream._final === 'function' && !state.destroyed) {\r\n      state.pendingcb++;\r\n      state.finalCalled = true;\r\n      process.nextTick(callFinal, stream, state);\r\n    } else {\r\n      state.prefinished = true;\r\n      stream.emit('prefinish');\r\n    }\r\n  }\r\n}\r\n\r\nfunction finishMaybe(stream, state) {\r\n  var need = needFinish(state);\r\n\r\n  if (need) {\r\n    prefinish(stream, state);\r\n\r\n    if (state.pendingcb === 0) {\r\n      state.finished = true;\r\n      stream.emit('finish');\r\n\r\n      if (state.autoDestroy) {\r\n        // In case of duplex streams we need a way to detect\r\n        // if the readable side is ready for autoDestroy as well\r\n        var rState = stream._readableState;\r\n\r\n        if (!rState || rState.autoDestroy && rState.endEmitted) {\r\n          stream.destroy();\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return need;\r\n}\r\n\r\nfunction endWritable(stream, state, cb) {\r\n  state.ending = true;\r\n  finishMaybe(stream, state);\r\n\r\n  if (cb) {\r\n    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);\r\n  }\r\n\r\n  state.ended = true;\r\n  stream.writable = false;\r\n}\r\n\r\nfunction onCorkedFinish(corkReq, state, err) {\r\n  var entry = corkReq.entry;\r\n  corkReq.entry = null;\r\n\r\n  while (entry) {\r\n    var cb = entry.callback;\r\n    state.pendingcb--;\r\n    cb(err);\r\n    entry = entry.next;\r\n  } // reuse the free corkReq.\r\n\r\n\r\n  state.corkedRequestsFree.next = corkReq;\r\n}\r\n\r\nObject.defineProperty(Writable.prototype, 'destroyed', {\r\n  // making it explicit this property is not enumerable\r\n  // because otherwise some prototype manipulation in\r\n  // userland will fail\r\n  enumerable: false,\r\n  get: function get() {\r\n    if (this._writableState === undefined) {\r\n      return false;\r\n    }\r\n\r\n    return this._writableState.destroyed;\r\n  },\r\n  set: function set(value) {\r\n    // we ignore the value if the stream\r\n    // has not been initialized yet\r\n    if (!this._writableState) {\r\n      return;\r\n    } // backward compatibility, the user is explicitly\r\n    // managing destroyed\r\n\r\n\r\n    this._writableState.destroyed = value;\r\n  }\r\n});\r\nWritable.prototype.destroy = destroyImpl.destroy;\r\nWritable.prototype._undestroy = destroyImpl.undestroy;\r\n\r\nWritable.prototype._destroy = function (err, cb) {\r\n  cb(err);\r\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzLmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsZ0VBQWdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsd0dBQTJCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNEVBQXdCO0FBQ3JDO0FBQ0Esb0JBQW9CLHFCQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLGtHQUE0QjtBQUN0RDtBQUNBLGVBQWUsbUJBQU8sQ0FBQyw4RkFBMEI7QUFDakQ7QUFDQTtBQUNBLHFCQUFxQixnR0FBMEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFPLENBQUMsNkRBQVU7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQU8sQ0FBQyw4RUFBa0I7QUFDL0MsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRjtBQUMzRjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxJQUFJO0FBQ0osQ0FBQyxLQUFLO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtQkFBTyxDQUFDLDhFQUFrQixHQUFHO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLEVBQUUsT0FBTztBQUNULEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksT0FBTztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEdBQUc7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxzREFBc0Q7QUFDOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxPQUFPLG1CQUFtQjtBQUM5QjtBQUNBO0FBQ0EsSUFBSSxPQUFPO0FBQ1g7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxPQUFPO0FBQ2IsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLE9BQU87QUFDYixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU8sY0FBYztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzP2NmMWUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXHJcbi8vXHJcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXHJcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcclxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXHJcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcclxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxyXG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcclxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbi8vXHJcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXHJcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4vL1xyXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXHJcbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcclxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxyXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcclxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXHJcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcclxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cclxuLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXHJcbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxyXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZTtcclxuLyogPHJlcGxhY2VtZW50PiAqL1xyXG5cclxuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xyXG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcclxuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XHJcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xyXG4gIHRoaXMubmV4dCA9IG51bGw7XHJcbn0gLy8gSXQgc2VlbXMgYSBsaW5rZWQgbGlzdCBidXQgaXQgaXMgbm90XHJcbi8vIHRoZXJlIHdpbGwgYmUgb25seSAyIG9mIHRoZXNlIGZvciBlYWNoIHN0cmVhbVxyXG5cclxuXHJcbmZ1bmN0aW9uIENvcmtlZFJlcXVlc3Qoc3RhdGUpIHtcclxuICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cclxuICB0aGlzLm5leHQgPSBudWxsO1xyXG4gIHRoaXMuZW50cnkgPSBudWxsO1xyXG5cclxuICB0aGlzLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIG9uQ29ya2VkRmluaXNoKF90aGlzLCBzdGF0ZSk7XHJcbiAgfTtcclxufVxyXG4vKiA8L3JlcGxhY2VtZW50PiAqL1xyXG5cclxuLyo8cmVwbGFjZW1lbnQ+Ki9cclxuXHJcblxyXG52YXIgRHVwbGV4O1xyXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cclxuXHJcbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xyXG4vKjxyZXBsYWNlbWVudD4qL1xyXG5cclxudmFyIGludGVybmFsVXRpbCA9IHtcclxuICBkZXByZWNhdGU6IHJlcXVpcmUoJ3V0aWwtZGVwcmVjYXRlJylcclxufTtcclxuLyo8L3JlcGxhY2VtZW50PiovXHJcblxyXG4vKjxyZXBsYWNlbWVudD4qL1xyXG5cclxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcclxuLyo8L3JlcGxhY2VtZW50PiovXHJcblxyXG5cclxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcclxuXHJcbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XHJcblxyXG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XHJcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcclxuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcclxufVxyXG5cclxudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcclxuXHJcbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdGF0ZScpLFxyXG4gICAgZ2V0SGlnaFdhdGVyTWFyayA9IF9yZXF1aXJlLmdldEhpZ2hXYXRlck1hcms7XHJcblxyXG52YXIgX3JlcXVpcmUkY29kZXMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKS5jb2RlcyxcclxuICAgIEVSUl9JTlZBTElEX0FSR19UWVBFID0gX3JlcXVpcmUkY29kZXMuRVJSX0lOVkFMSURfQVJHX1RZUEUsXHJcbiAgICBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVELFxyXG4gICAgRVJSX01VTFRJUExFX0NBTExCQUNLID0gX3JlcXVpcmUkY29kZXMuRVJSX01VTFRJUExFX0NBTExCQUNLLFxyXG4gICAgRVJSX1NUUkVBTV9DQU5OT1RfUElQRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fQ0FOTk9UX1BJUEUsXHJcbiAgICBFUlJfU1RSRUFNX0RFU1RST1lFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fREVTVFJPWUVELFxyXG4gICAgRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fTlVMTF9WQUxVRVMsXHJcbiAgICBFUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5ELFxyXG4gICAgRVJSX1VOS05PV05fRU5DT0RJTkcgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfVU5LTk9XTl9FTkNPRElORztcclxuXHJcbnZhciBlcnJvck9yRGVzdHJveSA9IGRlc3Ryb3lJbXBsLmVycm9yT3JEZXN0cm95O1xyXG5cclxucmVxdWlyZSgnaW5oZXJpdHMnKShXcml0YWJsZSwgU3RyZWFtKTtcclxuXHJcbmZ1bmN0aW9uIG5vcCgpIHt9XHJcblxyXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSwgaXNEdXBsZXgpIHtcclxuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xyXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OyAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxyXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxyXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XHJcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbSxcclxuICAvLyBlLmcuIG9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlIHZzLiBvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZSwgZXRjLlxyXG5cclxuICBpZiAodHlwZW9mIGlzRHVwbGV4ICE9PSAnYm9vbGVhbicpIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4OyAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cclxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXHJcblxyXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xyXG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7IC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIHRoYXQgd2UgYWx3YXlzIHJldHVybiBmYWxzZSBpZlxyXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcclxuXHJcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZ2V0SGlnaFdhdGVyTWFyayh0aGlzLCBvcHRpb25zLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywgaXNEdXBsZXgpOyAvLyBpZiBfZmluYWwgaGFzIGJlZW4gY2FsbGVkXHJcblxyXG4gIHRoaXMuZmluYWxDYWxsZWQgPSBmYWxzZTsgLy8gZHJhaW4gZXZlbnQgZmxhZy5cclxuXHJcbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTsgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcclxuXHJcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTsgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxyXG5cclxuICB0aGlzLmVuZGVkID0gZmFsc2U7IC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxyXG5cclxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7IC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxyXG5cclxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlOyAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cclxuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcclxuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxyXG5cclxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xyXG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTsgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xyXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cclxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXHJcblxyXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnOyAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxyXG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcclxuICAvLyBzb2NrZXQgb3IgZmlsZS5cclxuXHJcbiAgdGhpcy5sZW5ndGggPSAwOyAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxyXG5cclxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTsgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbFxyXG5cclxuICB0aGlzLmNvcmtlZCA9IDA7IC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxyXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XHJcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xyXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxyXG5cclxuICB0aGlzLnN5bmMgPSB0cnVlOyAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXHJcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcclxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cclxuXHJcbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7IC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcclxuXHJcbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24gKGVyKSB7XHJcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xyXG4gIH07IC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxyXG5cclxuXHJcbiAgdGhpcy53cml0ZWNiID0gbnVsbDsgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxyXG5cclxuICB0aGlzLndyaXRlbGVuID0gMDtcclxuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XHJcbiAgdGhpcy5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDsgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcclxuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcclxuXHJcbiAgdGhpcy5wZW5kaW5nY2IgPSAwOyAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXHJcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcclxuXHJcbiAgdGhpcy5wcmVmaW5pc2hlZCA9IGZhbHNlOyAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxyXG5cclxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlOyAvLyBTaG91bGQgY2xvc2UgYmUgZW1pdHRlZCBvbiBkZXN0cm95LiBEZWZhdWx0cyB0byB0cnVlLlxyXG5cclxuICB0aGlzLmVtaXRDbG9zZSA9IG9wdGlvbnMuZW1pdENsb3NlICE9PSBmYWxzZTsgLy8gU2hvdWxkIC5kZXN0cm95KCkgYmUgY2FsbGVkIGFmdGVyICdmaW5pc2gnIChhbmQgcG90ZW50aWFsbHkgJ2VuZCcpXHJcblxyXG4gIHRoaXMuYXV0b0Rlc3Ryb3kgPSAhIW9wdGlvbnMuYXV0b0Rlc3Ryb3k7IC8vIGNvdW50IGJ1ZmZlcmVkIHJlcXVlc3RzXHJcblxyXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwOyAvLyBhbGxvY2F0ZSB0aGUgZmlyc3QgQ29ya2VkUmVxdWVzdCwgdGhlcmUgaXMgYWx3YXlzXHJcbiAgLy8gb25lIGFsbG9jYXRlZCBhbmQgZnJlZSB0byB1c2UsIGFuZCB3ZSBtYWludGFpbiBhdCBtb3N0IHR3b1xyXG5cclxuICB0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHRoaXMpO1xyXG59XHJcblxyXG5Xcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiBnZXRCdWZmZXIoKSB7XHJcbiAgdmFyIGN1cnJlbnQgPSB0aGlzLmJ1ZmZlcmVkUmVxdWVzdDtcclxuICB2YXIgb3V0ID0gW107XHJcblxyXG4gIHdoaWxlIChjdXJyZW50KSB7XHJcbiAgICBvdXQucHVzaChjdXJyZW50KTtcclxuICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuKGZ1bmN0aW9uICgpIHtcclxuICB0cnkge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RhdGUucHJvdG90eXBlLCAnYnVmZmVyJywge1xyXG4gICAgICBnZXQ6IGludGVybmFsVXRpbC5kZXByZWNhdGUoZnVuY3Rpb24gd3JpdGFibGVTdGF0ZUJ1ZmZlckdldHRlcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTtcclxuICAgICAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgKyAnaW5zdGVhZC4nLCAnREVQMDAwMycpXHJcbiAgICB9KTtcclxuICB9IGNhdGNoIChfKSB7fVxyXG59KSgpOyAvLyBUZXN0IF93cml0YWJsZVN0YXRlIGZvciBpbmhlcml0YW5jZSB0byBhY2NvdW50IGZvciBEdXBsZXggc3RyZWFtcyxcclxuLy8gd2hvc2UgcHJvdG90eXBlIGNoYWluIG9ubHkgcG9pbnRzIHRvIFJlYWRhYmxlLlxyXG5cclxuXHJcbnZhciByZWFsSGFzSW5zdGFuY2U7XHJcblxyXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaGFzSW5zdGFuY2UgJiYgdHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgcmVhbEhhc0luc3RhbmNlID0gRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV07XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLCBTeW1ib2wuaGFzSW5zdGFuY2UsIHtcclxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShvYmplY3QpIHtcclxuICAgICAgaWYgKHJlYWxIYXNJbnN0YW5jZS5jYWxsKHRoaXMsIG9iamVjdCkpIHJldHVybiB0cnVlO1xyXG4gICAgICBpZiAodGhpcyAhPT0gV3JpdGFibGUpIHJldHVybiBmYWxzZTtcclxuICAgICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuX3dyaXRhYmxlU3RhdGUgaW5zdGFuY2VvZiBXcml0YWJsZVN0YXRlO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59IGVsc2Uge1xyXG4gIHJlYWxIYXNJbnN0YW5jZSA9IGZ1bmN0aW9uIHJlYWxIYXNJbnN0YW5jZShvYmplY3QpIHtcclxuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiB0aGlzO1xyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcclxuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpOyAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRvby5cclxuICAvLyBgcmVhbEhhc0luc3RhbmNlYCBpcyBuZWNlc3NhcnkgYmVjYXVzZSB1c2luZyBwbGFpbiBgaW5zdGFuY2VvZmBcclxuICAvLyB3b3VsZCByZXR1cm4gZmFsc2UsIGFzIG5vIGBfd3JpdGFibGVTdGF0ZWAgcHJvcGVydHkgaXMgYXR0YWNoZWQuXHJcbiAgLy8gVHJ5aW5nIHRvIHVzZSB0aGUgY3VzdG9tIGBpbnN0YW5jZW9mYCBmb3IgV3JpdGFibGUgaGVyZSB3aWxsIGFsc28gYnJlYWsgdGhlXHJcbiAgLy8gTm9kZS5qcyBMYXp5VHJhbnNmb3JtIGltcGxlbWVudGF0aW9uLCB3aGljaCBoYXMgYSBub24tdHJpdmlhbCBnZXR0ZXIgZm9yXHJcbiAgLy8gYF93cml0YWJsZVN0YXRlYCB0aGF0IHdvdWxkIGxlYWQgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxyXG4gIC8vIENoZWNraW5nIGZvciBhIFN0cmVhbS5EdXBsZXggaW5zdGFuY2UgaXMgZmFzdGVyIGhlcmUgaW5zdGVhZCBvZiBpbnNpZGVcclxuICAvLyB0aGUgV3JpdGFibGVTdGF0ZSBjb25zdHJ1Y3RvciwgYXQgbGVhc3Qgd2l0aCBWOCA2LjVcclxuXHJcbiAgdmFyIGlzRHVwbGV4ID0gdGhpcyBpbnN0YW5jZW9mIER1cGxleDtcclxuICBpZiAoIWlzRHVwbGV4ICYmICFyZWFsSGFzSW5zdGFuY2UuY2FsbChXcml0YWJsZSwgdGhpcykpIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XHJcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMsIGlzRHVwbGV4KTsgLy8gbGVnYWN5LlxyXG5cclxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcclxuXHJcbiAgaWYgKG9wdGlvbnMpIHtcclxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlO1xyXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XHJcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcclxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maW5hbCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmluYWwgPSBvcHRpb25zLmZpbmFsO1xyXG4gIH1cclxuXHJcbiAgU3RyZWFtLmNhbGwodGhpcyk7XHJcbn0gLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxyXG5cclxuXHJcbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xyXG4gIGVycm9yT3JEZXN0cm95KHRoaXMsIG5ldyBFUlJfU1RSRUFNX0NBTk5PVF9QSVBFKCkpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIGNiKSB7XHJcbiAgdmFyIGVyID0gbmV3IEVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5EKCk7IC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXHJcblxyXG4gIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xyXG4gIHByb2Nlc3MubmV4dFRpY2soY2IsIGVyKTtcclxufSAvLyBDaGVja3MgdGhhdCBhIHVzZXItc3VwcGxpZWQgY2h1bmsgaXMgdmFsaWQsIGVzcGVjaWFsbHkgZm9yIHRoZSBwYXJ0aWN1bGFyXHJcbi8vIG1vZGUgdGhlIHN0cmVhbSBpcyBpbi4gQ3VycmVudGx5IHRoaXMgbWVhbnMgdGhhdCBgbnVsbGAgaXMgbmV2ZXIgYWNjZXB0ZWRcclxuLy8gYW5kIHVuZGVmaW5lZC9ub24tc3RyaW5nIHZhbHVlcyBhcmUgb25seSBhbGxvd2VkIGluIG9iamVjdCBtb2RlLlxyXG5cclxuXHJcbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XHJcbiAgdmFyIGVyO1xyXG5cclxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcclxuICAgIGVyID0gbmV3IEVSUl9TVFJFQU1fTlVMTF9WQUxVRVMoKTtcclxuICB9IGVsc2UgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcclxuICAgIGVyID0gbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdjaHVuaycsIFsnc3RyaW5nJywgJ0J1ZmZlciddLCBjaHVuayk7XHJcbiAgfVxyXG5cclxuICBpZiAoZXIpIHtcclxuICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xyXG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYiwgZXIpO1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XHJcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcclxuICB2YXIgcmV0ID0gZmFsc2U7XHJcblxyXG4gIHZhciBpc0J1ZiA9ICFzdGF0ZS5vYmplY3RNb2RlICYmIF9pc1VpbnQ4QXJyYXkoY2h1bmspO1xyXG5cclxuICBpZiAoaXNCdWYgJiYgIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIHtcclxuICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICBjYiA9IGVuY29kaW5nO1xyXG4gICAgZW5jb2RpbmcgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgaWYgKGlzQnVmKSBlbmNvZGluZyA9ICdidWZmZXInO2Vsc2UgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XHJcbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7XHJcbiAgaWYgKHN0YXRlLmVuZGluZykgd3JpdGVBZnRlckVuZCh0aGlzLCBjYik7ZWxzZSBpZiAoaXNCdWYgfHwgdmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkge1xyXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XHJcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYik7XHJcbiAgfVxyXG4gIHJldHVybiByZXQ7XHJcbn07XHJcblxyXG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uICgpIHtcclxuICB0aGlzLl93cml0YWJsZVN0YXRlLmNvcmtlZCsrO1xyXG59O1xyXG5cclxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xyXG5cclxuICBpZiAoc3RhdGUuY29ya2VkKSB7XHJcbiAgICBzdGF0ZS5jb3JrZWQtLTtcclxuICAgIGlmICghc3RhdGUud3JpdGluZyAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpO1xyXG4gIH1cclxufTtcclxuXHJcbldyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2RpbmcgPSBmdW5jdGlvbiBzZXREZWZhdWx0RW5jb2RpbmcoZW5jb2RpbmcpIHtcclxuICAvLyBub2RlOjpQYXJzZUVuY29kaW5nKCkgcmVxdWlyZXMgbG93ZXIgY2FzZS5cclxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xyXG4gIGlmICghKFsnaGV4JywgJ3V0ZjgnLCAndXRmLTgnLCAnYXNjaWknLCAnYmluYXJ5JywgJ2Jhc2U2NCcsICd1Y3MyJywgJ3Vjcy0yJywgJ3V0ZjE2bGUnLCAndXRmLTE2bGUnLCAncmF3J10uaW5kZXhPZigoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKSkgPiAtMSkpIHRocm93IG5ldyBFUlJfVU5LTk9XTl9FTkNPRElORyhlbmNvZGluZyk7XHJcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZWZhdWx0RW5jb2RpbmcgPSBlbmNvZGluZztcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUJ1ZmZlcicsIHtcclxuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxyXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxyXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxyXG4gIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIoKTtcclxuICB9XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xyXG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XHJcbiAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gY2h1bms7XHJcbn1cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XHJcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcclxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cclxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcclxuICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcclxuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XHJcbiAgfVxyXG59KTsgLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXHJcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXHJcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXHJcblxyXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XHJcbiAgaWYgKCFpc0J1Zikge1xyXG4gICAgdmFyIG5ld0NodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XHJcblxyXG4gICAgaWYgKGNodW5rICE9PSBuZXdDaHVuaykge1xyXG4gICAgICBpc0J1ZiA9IHRydWU7XHJcbiAgICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7XHJcbiAgICAgIGNodW5rID0gbmV3Q2h1bms7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XHJcbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcclxuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyazsgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXHJcblxyXG4gIGlmICghcmV0KSBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xyXG5cclxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpIHtcclxuICAgIHZhciBsYXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcclxuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSB7XHJcbiAgICAgIGNodW5rOiBjaHVuayxcclxuICAgICAgZW5jb2Rpbmc6IGVuY29kaW5nLFxyXG4gICAgICBpc0J1ZjogaXNCdWYsXHJcbiAgICAgIGNhbGxiYWNrOiBjYixcclxuICAgICAgbmV4dDogbnVsbFxyXG4gICAgfTtcclxuXHJcbiAgICBpZiAobGFzdCkge1xyXG4gICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCArPSAxO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHJldDtcclxufVxyXG5cclxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xyXG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xyXG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcclxuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcclxuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcclxuICBpZiAoc3RhdGUuZGVzdHJveWVkKSBzdGF0ZS5vbndyaXRlKG5ldyBFUlJfU1RSRUFNX0RFU1RST1lFRCgnd3JpdGUnKSk7ZWxzZSBpZiAod3JpdGV2KSBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7ZWxzZSBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XHJcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XHJcbiAgLS1zdGF0ZS5wZW5kaW5nY2I7XHJcblxyXG4gIGlmIChzeW5jKSB7XHJcbiAgICAvLyBkZWZlciB0aGUgY2FsbGJhY2sgaWYgd2UgYXJlIGJlaW5nIGNhbGxlZCBzeW5jaHJvbm91c2x5XHJcbiAgICAvLyB0byBhdm9pZCBwaWxpbmcgdXAgdGhpbmdzIG9uIHRoZSBzdGFja1xyXG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYiwgZXIpOyAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYW5kIGl0IHdpbGwgYWx3YXlzIGhhcHBlblxyXG4gICAgLy8gYWZ0ZXIgZXJyb3JcclxuXHJcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZpbmlzaE1heWJlLCBzdHJlYW0sIHN0YXRlKTtcclxuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xyXG4gICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7XHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIHRoZSBjYWxsZXIgZXhwZWN0IHRoaXMgdG8gaGFwcGVuIGJlZm9yZSBpZlxyXG4gICAgLy8gaXQgaXMgYXN5bmNcclxuICAgIGNiKGVyKTtcclxuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xyXG4gICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7IC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBidXQgZmluaXNoIG11c3RcclxuICAgIC8vIGFsd2F5cyBmb2xsb3cgZXJyb3JcclxuXHJcbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xyXG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcclxuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcclxuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XHJcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xyXG59XHJcblxyXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcclxuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XHJcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xyXG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XHJcbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVSUl9NVUxUSVBMRV9DQUxMQkFDSygpO1xyXG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XHJcbiAgaWYgKGVyKSBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtlbHNlIHtcclxuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XHJcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0YXRlKSB8fCBzdHJlYW0uZGVzdHJveWVkO1xyXG5cclxuICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIHtcclxuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHN5bmMpIHtcclxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhhZnRlcldyaXRlLCBzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcclxuICBpZiAoIWZpbmlzaGVkKSBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XHJcbiAgc3RhdGUucGVuZGluZ2NiLS07XHJcbiAgY2IoKTtcclxuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcclxufSAvLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxyXG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXHJcbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXHJcblxyXG5cclxuZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcclxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xyXG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XHJcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcclxuICB9XHJcbn0gLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcclxuXHJcblxyXG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XHJcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XHJcbiAgdmFyIGVudHJ5ID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0O1xyXG5cclxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkge1xyXG4gICAgLy8gRmFzdCBjYXNlLCB3cml0ZSBldmVyeXRoaW5nIHVzaW5nIF93cml0ZXYoKVxyXG4gICAgdmFyIGwgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudDtcclxuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobCk7XHJcbiAgICB2YXIgaG9sZGVyID0gc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlO1xyXG4gICAgaG9sZGVyLmVudHJ5ID0gZW50cnk7XHJcbiAgICB2YXIgY291bnQgPSAwO1xyXG4gICAgdmFyIGFsbEJ1ZmZlcnMgPSB0cnVlO1xyXG5cclxuICAgIHdoaWxlIChlbnRyeSkge1xyXG4gICAgICBidWZmZXJbY291bnRdID0gZW50cnk7XHJcbiAgICAgIGlmICghZW50cnkuaXNCdWYpIGFsbEJ1ZmZlcnMgPSBmYWxzZTtcclxuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xyXG4gICAgICBjb3VudCArPSAxO1xyXG4gICAgfVxyXG5cclxuICAgIGJ1ZmZlci5hbGxCdWZmZXJzID0gYWxsQnVmZmVycztcclxuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBob2xkZXIuZmluaXNoKTsgLy8gZG9Xcml0ZSBpcyBhbG1vc3QgYWx3YXlzIGFzeW5jLCBkZWZlciB0aGVzZSB0byBzYXZlIGEgYml0IG9mIHRpbWVcclxuICAgIC8vIGFzIHRoZSBob3QgcGF0aCBlbmRzIHdpdGggZG9Xcml0ZVxyXG5cclxuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xyXG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XHJcblxyXG4gICAgaWYgKGhvbGRlci5uZXh0KSB7XHJcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGhvbGRlci5uZXh0O1xyXG4gICAgICBob2xkZXIubmV4dCA9IG51bGw7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdChzdGF0ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXHJcbiAgICB3aGlsZSAoZW50cnkpIHtcclxuICAgICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XHJcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xyXG4gICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcclxuICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xyXG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xyXG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XHJcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50LS07IC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXHJcbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXHJcbiAgICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcclxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXHJcblxyXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGVudHJ5ID09PSBudWxsKSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcclxuICB9XHJcblxyXG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IGVudHJ5O1xyXG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcclxufVxyXG5cclxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XHJcbiAgY2IobmV3IEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEKCdfd3JpdGUoKScpKTtcclxufTtcclxuXHJcbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ID0gbnVsbDtcclxuXHJcbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xyXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XHJcblxyXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcclxuICAgIGNiID0gY2h1bms7XHJcbiAgICBjaHVuayA9IG51bGw7XHJcbiAgICBlbmNvZGluZyA9IG51bGw7XHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcclxuICAgIGNiID0gZW5jb2Rpbmc7XHJcbiAgICBlbmNvZGluZyA9IG51bGw7XHJcbiAgfVxyXG5cclxuICBpZiAoY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCkgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpOyAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xyXG5cclxuICBpZiAoc3RhdGUuY29ya2VkKSB7XHJcbiAgICBzdGF0ZS5jb3JrZWQgPSAxO1xyXG4gICAgdGhpcy51bmNvcmsoKTtcclxuICB9IC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cclxuXHJcblxyXG4gIGlmICghc3RhdGUuZW5kaW5nKSBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlTGVuZ3RoJywge1xyXG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXHJcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXHJcbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXHJcbiAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5sZW5ndGg7XHJcbiAgfVxyXG59KTtcclxuXHJcbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RhdGUpIHtcclxuICByZXR1cm4gc3RhdGUuZW5kaW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPT09IG51bGwgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS53cml0aW5nO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjYWxsRmluYWwoc3RyZWFtLCBzdGF0ZSkge1xyXG4gIHN0cmVhbS5fZmluYWwoZnVuY3Rpb24gKGVycikge1xyXG4gICAgc3RhdGUucGVuZGluZ2NiLS07XHJcblxyXG4gICAgaWYgKGVycikge1xyXG4gICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVycik7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xyXG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xyXG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XHJcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCAmJiAhc3RhdGUuZmluYWxDYWxsZWQpIHtcclxuICAgIGlmICh0eXBlb2Ygc3RyZWFtLl9maW5hbCA9PT0gJ2Z1bmN0aW9uJyAmJiAhc3RhdGUuZGVzdHJveWVkKSB7XHJcbiAgICAgIHN0YXRlLnBlbmRpbmdjYisrO1xyXG4gICAgICBzdGF0ZS5maW5hbENhbGxlZCA9IHRydWU7XHJcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbEZpbmFsLCBzdHJlYW0sIHN0YXRlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcclxuICAgICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xyXG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XHJcblxyXG4gIGlmIChuZWVkKSB7XHJcbiAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XHJcblxyXG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xyXG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XHJcbiAgICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTtcclxuXHJcbiAgICAgIGlmIChzdGF0ZS5hdXRvRGVzdHJveSkge1xyXG4gICAgICAgIC8vIEluIGNhc2Ugb2YgZHVwbGV4IHN0cmVhbXMgd2UgbmVlZCBhIHdheSB0byBkZXRlY3RcclxuICAgICAgICAvLyBpZiB0aGUgcmVhZGFibGUgc2lkZSBpcyByZWFkeSBmb3IgYXV0b0Rlc3Ryb3kgYXMgd2VsbFxyXG4gICAgICAgIHZhciByU3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XHJcblxyXG4gICAgICAgIGlmICghclN0YXRlIHx8IHJTdGF0ZS5hdXRvRGVzdHJveSAmJiByU3RhdGUuZW5kRW1pdHRlZCkge1xyXG4gICAgICAgICAgc3RyZWFtLmRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBuZWVkO1xyXG59XHJcblxyXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xyXG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XHJcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XHJcblxyXG4gIGlmIChjYikge1xyXG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKSBwcm9jZXNzLm5leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XHJcbiAgfVxyXG5cclxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XHJcbiAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2U7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG9uQ29ya2VkRmluaXNoKGNvcmtSZXEsIHN0YXRlLCBlcnIpIHtcclxuICB2YXIgZW50cnkgPSBjb3JrUmVxLmVudHJ5O1xyXG4gIGNvcmtSZXEuZW50cnkgPSBudWxsO1xyXG5cclxuICB3aGlsZSAoZW50cnkpIHtcclxuICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xyXG4gICAgc3RhdGUucGVuZGluZ2NiLS07XHJcbiAgICBjYihlcnIpO1xyXG4gICAgZW50cnkgPSBlbnRyeS5uZXh0O1xyXG4gIH0gLy8gcmV1c2UgdGhlIGZyZWUgY29ya1JlcS5cclxuXHJcblxyXG4gIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gY29ya1JlcTtcclxufVxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcclxuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxyXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxyXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxyXG4gIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xyXG4gICAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xyXG4gIH0sXHJcbiAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcclxuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxyXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxyXG4gICAgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH0gLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxyXG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXHJcblxyXG5cclxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XHJcbiAgfVxyXG59KTtcclxuV3JpdGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xyXG5Xcml0YWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcclxuXHJcbldyaXRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XHJcbiAgY2IoZXJyKTtcclxufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/readable-stream/lib/_stream_writable.js\n");

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/async_iterator.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/async_iterator.js ***!
  \*****************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/process/browser.js\");\n\r\n\r\nvar _Object$setPrototypeO;\r\n\r\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\r\n\r\nvar finished = __webpack_require__(/*! ./end-of-stream */ \"./node_modules/readable-stream/lib/internal/streams/end-of-stream.js\");\r\n\r\nvar kLastResolve = Symbol('lastResolve');\r\nvar kLastReject = Symbol('lastReject');\r\nvar kError = Symbol('error');\r\nvar kEnded = Symbol('ended');\r\nvar kLastPromise = Symbol('lastPromise');\r\nvar kHandlePromise = Symbol('handlePromise');\r\nvar kStream = Symbol('stream');\r\n\r\nfunction createIterResult(value, done) {\r\n  return {\r\n    value: value,\r\n    done: done\r\n  };\r\n}\r\n\r\nfunction readAndResolve(iter) {\r\n  var resolve = iter[kLastResolve];\r\n\r\n  if (resolve !== null) {\r\n    var data = iter[kStream].read(); // we defer if data is null\r\n    // we can be expecting either 'end' or\r\n    // 'error'\r\n\r\n    if (data !== null) {\r\n      iter[kLastPromise] = null;\r\n      iter[kLastResolve] = null;\r\n      iter[kLastReject] = null;\r\n      resolve(createIterResult(data, false));\r\n    }\r\n  }\r\n}\r\n\r\nfunction onReadable(iter) {\r\n  // we wait for the next tick, because it might\r\n  // emit an error with process.nextTick\r\n  process.nextTick(readAndResolve, iter);\r\n}\r\n\r\nfunction wrapForNext(lastPromise, iter) {\r\n  return function (resolve, reject) {\r\n    lastPromise.then(function () {\r\n      if (iter[kEnded]) {\r\n        resolve(createIterResult(undefined, true));\r\n        return;\r\n      }\r\n\r\n      iter[kHandlePromise](resolve, reject);\r\n    }, reject);\r\n  };\r\n}\r\n\r\nvar AsyncIteratorPrototype = Object.getPrototypeOf(function () {});\r\nvar ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {\r\n  get stream() {\r\n    return this[kStream];\r\n  },\r\n\r\n  next: function next() {\r\n    var _this = this;\r\n\r\n    // if we have detected an error in the meanwhile\r\n    // reject straight away\r\n    var error = this[kError];\r\n\r\n    if (error !== null) {\r\n      return Promise.reject(error);\r\n    }\r\n\r\n    if (this[kEnded]) {\r\n      return Promise.resolve(createIterResult(undefined, true));\r\n    }\r\n\r\n    if (this[kStream].destroyed) {\r\n      // We need to defer via nextTick because if .destroy(err) is\r\n      // called, the error will be emitted via nextTick, and\r\n      // we cannot guarantee that there is no error lingering around\r\n      // waiting to be emitted.\r\n      return new Promise(function (resolve, reject) {\r\n        process.nextTick(function () {\r\n          if (_this[kError]) {\r\n            reject(_this[kError]);\r\n          } else {\r\n            resolve(createIterResult(undefined, true));\r\n          }\r\n        });\r\n      });\r\n    } // if we have multiple next() calls\r\n    // we will wait for the previous Promise to finish\r\n    // this logic is optimized to support for await loops,\r\n    // where next() is only called once at a time\r\n\r\n\r\n    var lastPromise = this[kLastPromise];\r\n    var promise;\r\n\r\n    if (lastPromise) {\r\n      promise = new Promise(wrapForNext(lastPromise, this));\r\n    } else {\r\n      // fast path needed to support multiple this.push()\r\n      // without triggering the next() queue\r\n      var data = this[kStream].read();\r\n\r\n      if (data !== null) {\r\n        return Promise.resolve(createIterResult(data, false));\r\n      }\r\n\r\n      promise = new Promise(this[kHandlePromise]);\r\n    }\r\n\r\n    this[kLastPromise] = promise;\r\n    return promise;\r\n  }\r\n}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {\r\n  return this;\r\n}), _defineProperty(_Object$setPrototypeO, \"return\", function _return() {\r\n  var _this2 = this;\r\n\r\n  // destroy(err, cb) is a private API\r\n  // we can guarantee we have that here, because we control the\r\n  // Readable class this is attached to\r\n  return new Promise(function (resolve, reject) {\r\n    _this2[kStream].destroy(null, function (err) {\r\n      if (err) {\r\n        reject(err);\r\n        return;\r\n      }\r\n\r\n      resolve(createIterResult(undefined, true));\r\n    });\r\n  });\r\n}), _Object$setPrototypeO), AsyncIteratorPrototype);\r\n\r\nvar createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {\r\n  var _Object$create;\r\n\r\n  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {\r\n    value: stream,\r\n    writable: true\r\n  }), _defineProperty(_Object$create, kLastResolve, {\r\n    value: null,\r\n    writable: true\r\n  }), _defineProperty(_Object$create, kLastReject, {\r\n    value: null,\r\n    writable: true\r\n  }), _defineProperty(_Object$create, kError, {\r\n    value: null,\r\n    writable: true\r\n  }), _defineProperty(_Object$create, kEnded, {\r\n    value: stream._readableState.endEmitted,\r\n    writable: true\r\n  }), _defineProperty(_Object$create, kHandlePromise, {\r\n    value: function value(resolve, reject) {\r\n      var data = iterator[kStream].read();\r\n\r\n      if (data) {\r\n        iterator[kLastPromise] = null;\r\n        iterator[kLastResolve] = null;\r\n        iterator[kLastReject] = null;\r\n        resolve(createIterResult(data, false));\r\n      } else {\r\n        iterator[kLastResolve] = resolve;\r\n        iterator[kLastReject] = reject;\r\n      }\r\n    },\r\n    writable: true\r\n  }), _Object$create));\r\n  iterator[kLastPromise] = null;\r\n  finished(stream, function (err) {\r\n    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\r\n      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise\r\n      // returned by next() and store the error\r\n\r\n      if (reject !== null) {\r\n        iterator[kLastPromise] = null;\r\n        iterator[kLastResolve] = null;\r\n        iterator[kLastReject] = null;\r\n        reject(err);\r\n      }\r\n\r\n      iterator[kError] = err;\r\n      return;\r\n    }\r\n\r\n    var resolve = iterator[kLastResolve];\r\n\r\n    if (resolve !== null) {\r\n      iterator[kLastPromise] = null;\r\n      iterator[kLastResolve] = null;\r\n      iterator[kLastReject] = null;\r\n      resolve(createIterResult(undefined, true));\r\n    }\r\n\r\n    iterator[kEnded] = true;\r\n  });\r\n  stream.on('readable', onReadable.bind(null, iterator));\r\n  return iterator;\r\n};\r\n\r\nmodule.exports = createReadableStreamAsyncIterator;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2FzeW5jX2l0ZXJhdG9yLmpzLmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxrQkFBa0Isa0NBQWtDLG9FQUFvRSxLQUFLLE9BQU8sb0JBQW9CO0FBQ3BNO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLDZGQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsT0FBTztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsT0FBTztBQUNmO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RjtBQUN6RjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2FzeW5jX2l0ZXJhdG9yLmpzPzIyODUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF9PYmplY3Qkc2V0UHJvdG90eXBlTztcclxuXHJcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XHJcblxyXG52YXIgZmluaXNoZWQgPSByZXF1aXJlKCcuL2VuZC1vZi1zdHJlYW0nKTtcclxuXHJcbnZhciBrTGFzdFJlc29sdmUgPSBTeW1ib2woJ2xhc3RSZXNvbHZlJyk7XHJcbnZhciBrTGFzdFJlamVjdCA9IFN5bWJvbCgnbGFzdFJlamVjdCcpO1xyXG52YXIga0Vycm9yID0gU3ltYm9sKCdlcnJvcicpO1xyXG52YXIga0VuZGVkID0gU3ltYm9sKCdlbmRlZCcpO1xyXG52YXIga0xhc3RQcm9taXNlID0gU3ltYm9sKCdsYXN0UHJvbWlzZScpO1xyXG52YXIga0hhbmRsZVByb21pc2UgPSBTeW1ib2woJ2hhbmRsZVByb21pc2UnKTtcclxudmFyIGtTdHJlYW0gPSBTeW1ib2woJ3N0cmVhbScpO1xyXG5cclxuZnVuY3Rpb24gY3JlYXRlSXRlclJlc3VsdCh2YWx1ZSwgZG9uZSkge1xyXG4gIHJldHVybiB7XHJcbiAgICB2YWx1ZTogdmFsdWUsXHJcbiAgICBkb25lOiBkb25lXHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVhZEFuZFJlc29sdmUoaXRlcikge1xyXG4gIHZhciByZXNvbHZlID0gaXRlcltrTGFzdFJlc29sdmVdO1xyXG5cclxuICBpZiAocmVzb2x2ZSAhPT0gbnVsbCkge1xyXG4gICAgdmFyIGRhdGEgPSBpdGVyW2tTdHJlYW1dLnJlYWQoKTsgLy8gd2UgZGVmZXIgaWYgZGF0YSBpcyBudWxsXHJcbiAgICAvLyB3ZSBjYW4gYmUgZXhwZWN0aW5nIGVpdGhlciAnZW5kJyBvclxyXG4gICAgLy8gJ2Vycm9yJ1xyXG5cclxuICAgIGlmIChkYXRhICE9PSBudWxsKSB7XHJcbiAgICAgIGl0ZXJba0xhc3RQcm9taXNlXSA9IG51bGw7XHJcbiAgICAgIGl0ZXJba0xhc3RSZXNvbHZlXSA9IG51bGw7XHJcbiAgICAgIGl0ZXJba0xhc3RSZWplY3RdID0gbnVsbDtcclxuICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KGRhdGEsIGZhbHNlKSk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBvblJlYWRhYmxlKGl0ZXIpIHtcclxuICAvLyB3ZSB3YWl0IGZvciB0aGUgbmV4dCB0aWNrLCBiZWNhdXNlIGl0IG1pZ2h0XHJcbiAgLy8gZW1pdCBhbiBlcnJvciB3aXRoIHByb2Nlc3MubmV4dFRpY2tcclxuICBwcm9jZXNzLm5leHRUaWNrKHJlYWRBbmRSZXNvbHZlLCBpdGVyKTtcclxufVxyXG5cclxuZnVuY3Rpb24gd3JhcEZvck5leHQobGFzdFByb21pc2UsIGl0ZXIpIHtcclxuICByZXR1cm4gZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgbGFzdFByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGlmIChpdGVyW2tFbmRlZF0pIHtcclxuICAgICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpdGVyW2tIYW5kbGVQcm9taXNlXShyZXNvbHZlLCByZWplY3QpO1xyXG4gICAgfSwgcmVqZWN0KTtcclxuICB9O1xyXG59XHJcblxyXG52YXIgQXN5bmNJdGVyYXRvclByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihmdW5jdGlvbiAoKSB7fSk7XHJcbnZhciBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JQcm90b3R5cGUgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YoKF9PYmplY3Qkc2V0UHJvdG90eXBlTyA9IHtcclxuICBnZXQgc3RyZWFtKCkge1xyXG4gICAgcmV0dXJuIHRoaXNba1N0cmVhbV07XHJcbiAgfSxcclxuXHJcbiAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcclxuICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcblxyXG4gICAgLy8gaWYgd2UgaGF2ZSBkZXRlY3RlZCBhbiBlcnJvciBpbiB0aGUgbWVhbndoaWxlXHJcbiAgICAvLyByZWplY3Qgc3RyYWlnaHQgYXdheVxyXG4gICAgdmFyIGVycm9yID0gdGhpc1trRXJyb3JdO1xyXG5cclxuICAgIGlmIChlcnJvciAhPT0gbnVsbCkge1xyXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzW2tFbmRlZF0pIHtcclxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzW2tTdHJlYW1dLmRlc3Ryb3llZCkge1xyXG4gICAgICAvLyBXZSBuZWVkIHRvIGRlZmVyIHZpYSBuZXh0VGljayBiZWNhdXNlIGlmIC5kZXN0cm95KGVycikgaXNcclxuICAgICAgLy8gY2FsbGVkLCB0aGUgZXJyb3Igd2lsbCBiZSBlbWl0dGVkIHZpYSBuZXh0VGljaywgYW5kXHJcbiAgICAgIC8vIHdlIGNhbm5vdCBndWFyYW50ZWUgdGhhdCB0aGVyZSBpcyBubyBlcnJvciBsaW5nZXJpbmcgYXJvdW5kXHJcbiAgICAgIC8vIHdhaXRpbmcgdG8gYmUgZW1pdHRlZC5cclxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIGlmIChfdGhpc1trRXJyb3JdKSB7XHJcbiAgICAgICAgICAgIHJlamVjdChfdGhpc1trRXJyb3JdKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgICB9IC8vIGlmIHdlIGhhdmUgbXVsdGlwbGUgbmV4dCgpIGNhbGxzXHJcbiAgICAvLyB3ZSB3aWxsIHdhaXQgZm9yIHRoZSBwcmV2aW91cyBQcm9taXNlIHRvIGZpbmlzaFxyXG4gICAgLy8gdGhpcyBsb2dpYyBpcyBvcHRpbWl6ZWQgdG8gc3VwcG9ydCBmb3IgYXdhaXQgbG9vcHMsXHJcbiAgICAvLyB3aGVyZSBuZXh0KCkgaXMgb25seSBjYWxsZWQgb25jZSBhdCBhIHRpbWVcclxuXHJcblxyXG4gICAgdmFyIGxhc3RQcm9taXNlID0gdGhpc1trTGFzdFByb21pc2VdO1xyXG4gICAgdmFyIHByb21pc2U7XHJcblxyXG4gICAgaWYgKGxhc3RQcm9taXNlKSB7XHJcbiAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZSh3cmFwRm9yTmV4dChsYXN0UHJvbWlzZSwgdGhpcykpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gZmFzdCBwYXRoIG5lZWRlZCB0byBzdXBwb3J0IG11bHRpcGxlIHRoaXMucHVzaCgpXHJcbiAgICAgIC8vIHdpdGhvdXQgdHJpZ2dlcmluZyB0aGUgbmV4dCgpIHF1ZXVlXHJcbiAgICAgIHZhciBkYXRhID0gdGhpc1trU3RyZWFtXS5yZWFkKCk7XHJcblxyXG4gICAgICBpZiAoZGF0YSAhPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY3JlYXRlSXRlclJlc3VsdChkYXRhLCBmYWxzZSkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwcm9taXNlID0gbmV3IFByb21pc2UodGhpc1trSGFuZGxlUHJvbWlzZV0pO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXNba0xhc3RQcm9taXNlXSA9IHByb21pc2U7XHJcbiAgICByZXR1cm4gcHJvbWlzZTtcclxuICB9XHJcbn0sIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JHNldFByb3RvdHlwZU8sIFN5bWJvbC5hc3luY0l0ZXJhdG9yLCBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRzZXRQcm90b3R5cGVPLCBcInJldHVyblwiLCBmdW5jdGlvbiBfcmV0dXJuKCkge1xyXG4gIHZhciBfdGhpczIgPSB0aGlzO1xyXG5cclxuICAvLyBkZXN0cm95KGVyciwgY2IpIGlzIGEgcHJpdmF0ZSBBUElcclxuICAvLyB3ZSBjYW4gZ3VhcmFudGVlIHdlIGhhdmUgdGhhdCBoZXJlLCBiZWNhdXNlIHdlIGNvbnRyb2wgdGhlXHJcbiAgLy8gUmVhZGFibGUgY2xhc3MgdGhpcyBpcyBhdHRhY2hlZCB0b1xyXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICBfdGhpczJba1N0cmVhbV0uZGVzdHJveShudWxsLCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG59KSwgX09iamVjdCRzZXRQcm90b3R5cGVPKSwgQXN5bmNJdGVyYXRvclByb3RvdHlwZSk7XHJcblxyXG52YXIgY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yID0gZnVuY3Rpb24gY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yKHN0cmVhbSkge1xyXG4gIHZhciBfT2JqZWN0JGNyZWF0ZTtcclxuXHJcbiAgdmFyIGl0ZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JQcm90b3R5cGUsIChfT2JqZWN0JGNyZWF0ZSA9IHt9LCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtTdHJlYW0sIHtcclxuICAgIHZhbHVlOiBzdHJlYW0sXHJcbiAgICB3cml0YWJsZTogdHJ1ZVxyXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtMYXN0UmVzb2x2ZSwge1xyXG4gICAgdmFsdWU6IG51bGwsXHJcbiAgICB3cml0YWJsZTogdHJ1ZVxyXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtMYXN0UmVqZWN0LCB7XHJcbiAgICB2YWx1ZTogbnVsbCxcclxuICAgIHdyaXRhYmxlOiB0cnVlXHJcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0Vycm9yLCB7XHJcbiAgICB2YWx1ZTogbnVsbCxcclxuICAgIHdyaXRhYmxlOiB0cnVlXHJcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0VuZGVkLCB7XHJcbiAgICB2YWx1ZTogc3RyZWFtLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQsXHJcbiAgICB3cml0YWJsZTogdHJ1ZVxyXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtIYW5kbGVQcm9taXNlLCB7XHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgIHZhciBkYXRhID0gaXRlcmF0b3Jba1N0cmVhbV0ucmVhZCgpO1xyXG5cclxuICAgICAgaWYgKGRhdGEpIHtcclxuICAgICAgICBpdGVyYXRvcltrTGFzdFByb21pc2VdID0gbnVsbDtcclxuICAgICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gbnVsbDtcclxuICAgICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSBudWxsO1xyXG4gICAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdChkYXRhLCBmYWxzZSkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV0gPSByZXNvbHZlO1xyXG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IHJlamVjdDtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIHdyaXRhYmxlOiB0cnVlXHJcbiAgfSksIF9PYmplY3QkY3JlYXRlKSk7XHJcbiAgaXRlcmF0b3Jba0xhc3RQcm9taXNlXSA9IG51bGw7XHJcbiAgZmluaXNoZWQoc3RyZWFtLCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICBpZiAoZXJyICYmIGVyci5jb2RlICE9PSAnRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UnKSB7XHJcbiAgICAgIHZhciByZWplY3QgPSBpdGVyYXRvcltrTGFzdFJlamVjdF07IC8vIHJlamVjdCBpZiB3ZSBhcmUgd2FpdGluZyBmb3IgZGF0YSBpbiB0aGUgUHJvbWlzZVxyXG4gICAgICAvLyByZXR1cm5lZCBieSBuZXh0KCkgYW5kIHN0b3JlIHRoZSBlcnJvclxyXG5cclxuICAgICAgaWYgKHJlamVjdCAhPT0gbnVsbCkge1xyXG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xyXG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV0gPSBudWxsO1xyXG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IG51bGw7XHJcbiAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGl0ZXJhdG9yW2tFcnJvcl0gPSBlcnI7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcmVzb2x2ZSA9IGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV07XHJcblxyXG4gICAgaWYgKHJlc29sdmUgIT09IG51bGwpIHtcclxuICAgICAgaXRlcmF0b3Jba0xhc3RQcm9taXNlXSA9IG51bGw7XHJcbiAgICAgIGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV0gPSBudWxsO1xyXG4gICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSBudWxsO1xyXG4gICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XHJcbiAgICB9XHJcblxyXG4gICAgaXRlcmF0b3Jba0VuZGVkXSA9IHRydWU7XHJcbiAgfSk7XHJcbiAgc3RyZWFtLm9uKCdyZWFkYWJsZScsIG9uUmVhZGFibGUuYmluZChudWxsLCBpdGVyYXRvcikpO1xyXG4gIHJldHVybiBpdGVyYXRvcjtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/readable-stream/lib/internal/streams/async_iterator.js\n");

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/buffer_list.js":
/*!**************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/buffer_list.js ***!
  \**************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\r\n\r\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\r\n\r\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\r\n\r\nvar _require = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\"),\r\n    Buffer = _require.Buffer;\r\n\r\nvar _require2 = __webpack_require__(/*! util */ \"?c852\"),\r\n    inspect = _require2.inspect;\r\n\r\nvar custom = inspect && inspect.custom || 'inspect';\r\n\r\nfunction copyBuffer(src, target, offset) {\r\n  Buffer.prototype.copy.call(src, target, offset);\r\n}\r\n\r\nmodule.exports =\r\n/*#__PURE__*/\r\nfunction () {\r\n  function BufferList() {\r\n    _classCallCheck(this, BufferList);\r\n\r\n    this.head = null;\r\n    this.tail = null;\r\n    this.length = 0;\r\n  }\r\n\r\n  _createClass(BufferList, [{\r\n    key: \"push\",\r\n    value: function push(v) {\r\n      var entry = {\r\n        data: v,\r\n        next: null\r\n      };\r\n      if (this.length > 0) this.tail.next = entry;else this.head = entry;\r\n      this.tail = entry;\r\n      ++this.length;\r\n    }\r\n  }, {\r\n    key: \"unshift\",\r\n    value: function unshift(v) {\r\n      var entry = {\r\n        data: v,\r\n        next: this.head\r\n      };\r\n      if (this.length === 0) this.tail = entry;\r\n      this.head = entry;\r\n      ++this.length;\r\n    }\r\n  }, {\r\n    key: \"shift\",\r\n    value: function shift() {\r\n      if (this.length === 0) return;\r\n      var ret = this.head.data;\r\n      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\r\n      --this.length;\r\n      return ret;\r\n    }\r\n  }, {\r\n    key: \"clear\",\r\n    value: function clear() {\r\n      this.head = this.tail = null;\r\n      this.length = 0;\r\n    }\r\n  }, {\r\n    key: \"join\",\r\n    value: function join(s) {\r\n      if (this.length === 0) return '';\r\n      var p = this.head;\r\n      var ret = '' + p.data;\r\n\r\n      while (p = p.next) {\r\n        ret += s + p.data;\r\n      }\r\n\r\n      return ret;\r\n    }\r\n  }, {\r\n    key: \"concat\",\r\n    value: function concat(n) {\r\n      if (this.length === 0) return Buffer.alloc(0);\r\n      var ret = Buffer.allocUnsafe(n >>> 0);\r\n      var p = this.head;\r\n      var i = 0;\r\n\r\n      while (p) {\r\n        copyBuffer(p.data, ret, i);\r\n        i += p.data.length;\r\n        p = p.next;\r\n      }\r\n\r\n      return ret;\r\n    } // Consumes a specified amount of bytes or characters from the buffered data.\r\n\r\n  }, {\r\n    key: \"consume\",\r\n    value: function consume(n, hasStrings) {\r\n      var ret;\r\n\r\n      if (n < this.head.data.length) {\r\n        // `slice` is the same for buffers and strings.\r\n        ret = this.head.data.slice(0, n);\r\n        this.head.data = this.head.data.slice(n);\r\n      } else if (n === this.head.data.length) {\r\n        // First chunk is a perfect match.\r\n        ret = this.shift();\r\n      } else {\r\n        // Result spans more than one buffer.\r\n        ret = hasStrings ? this._getString(n) : this._getBuffer(n);\r\n      }\r\n\r\n      return ret;\r\n    }\r\n  }, {\r\n    key: \"first\",\r\n    value: function first() {\r\n      return this.head.data;\r\n    } // Consumes a specified amount of characters from the buffered data.\r\n\r\n  }, {\r\n    key: \"_getString\",\r\n    value: function _getString(n) {\r\n      var p = this.head;\r\n      var c = 1;\r\n      var ret = p.data;\r\n      n -= ret.length;\r\n\r\n      while (p = p.next) {\r\n        var str = p.data;\r\n        var nb = n > str.length ? str.length : n;\r\n        if (nb === str.length) ret += str;else ret += str.slice(0, n);\r\n        n -= nb;\r\n\r\n        if (n === 0) {\r\n          if (nb === str.length) {\r\n            ++c;\r\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\r\n          } else {\r\n            this.head = p;\r\n            p.data = str.slice(nb);\r\n          }\r\n\r\n          break;\r\n        }\r\n\r\n        ++c;\r\n      }\r\n\r\n      this.length -= c;\r\n      return ret;\r\n    } // Consumes a specified amount of bytes from the buffered data.\r\n\r\n  }, {\r\n    key: \"_getBuffer\",\r\n    value: function _getBuffer(n) {\r\n      var ret = Buffer.allocUnsafe(n);\r\n      var p = this.head;\r\n      var c = 1;\r\n      p.data.copy(ret);\r\n      n -= p.data.length;\r\n\r\n      while (p = p.next) {\r\n        var buf = p.data;\r\n        var nb = n > buf.length ? buf.length : n;\r\n        buf.copy(ret, ret.length - n, 0, nb);\r\n        n -= nb;\r\n\r\n        if (n === 0) {\r\n          if (nb === buf.length) {\r\n            ++c;\r\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\r\n          } else {\r\n            this.head = p;\r\n            p.data = buf.slice(nb);\r\n          }\r\n\r\n          break;\r\n        }\r\n\r\n        ++c;\r\n      }\r\n\r\n      this.length -= c;\r\n      return ret;\r\n    } // Make sure the linked list only shows the minimal necessary information.\r\n\r\n  }, {\r\n    key: custom,\r\n    value: function value(_, options) {\r\n      return inspect(this, _objectSpread({}, options, {\r\n        // Only inspect one level.\r\n        depth: 0,\r\n        // It should not recurse.\r\n        customInspect: false\r\n      }));\r\n    }\r\n  }]);\r\n\r\n  return BufferList;\r\n}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2J1ZmZlcl9saXN0LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSwyQ0FBMkMsZ0NBQWdDLG9DQUFvQyxvREFBb0QsOERBQThELGlFQUFpRSxHQUFHLGtDQUFrQztBQUN2VTtBQUNBLGlDQUFpQyxnQkFBZ0Isc0JBQXNCLE9BQU8sdURBQXVELGFBQWEsdURBQXVELDRDQUE0QyxLQUFLLDZDQUE2Qyw2RUFBNkUsT0FBTyxpREFBaUQsbUZBQW1GLE9BQU87QUFDdGdCO0FBQ0EsNENBQTRDLGtCQUFrQixrQ0FBa0Msb0VBQW9FLEtBQUssT0FBTyxvQkFBb0I7QUFDcE07QUFDQSxrREFBa0QsMENBQTBDO0FBQzVGO0FBQ0EsNENBQTRDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQ7QUFDL1A7QUFDQSw4REFBOEQsc0VBQXNFLDhEQUE4RDtBQUNsTTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyw4Q0FBUTtBQUMvQjtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsbUJBQU07QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQyxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvYnVmZmVyX2xpc3QuanM/ZmQ0NCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxyXG5cclxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XHJcblxyXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxyXG5cclxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cclxuXHJcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cclxuXHJcbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XHJcblxyXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCdidWZmZXInKSxcclxuICAgIEJ1ZmZlciA9IF9yZXF1aXJlLkJ1ZmZlcjtcclxuXHJcbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKCd1dGlsJyksXHJcbiAgICBpbnNwZWN0ID0gX3JlcXVpcmUyLmluc3BlY3Q7XHJcblxyXG52YXIgY3VzdG9tID0gaW5zcGVjdCAmJiBpbnNwZWN0LmN1c3RvbSB8fCAnaW5zcGVjdCc7XHJcblxyXG5mdW5jdGlvbiBjb3B5QnVmZmVyKHNyYywgdGFyZ2V0LCBvZmZzZXQpIHtcclxuICBCdWZmZXIucHJvdG90eXBlLmNvcHkuY2FsbChzcmMsIHRhcmdldCwgb2Zmc2V0KTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPVxyXG4vKiNfX1BVUkVfXyovXHJcbmZ1bmN0aW9uICgpIHtcclxuICBmdW5jdGlvbiBCdWZmZXJMaXN0KCkge1xyXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1ZmZlckxpc3QpO1xyXG5cclxuICAgIHRoaXMuaGVhZCA9IG51bGw7XHJcbiAgICB0aGlzLnRhaWwgPSBudWxsO1xyXG4gICAgdGhpcy5sZW5ndGggPSAwO1xyXG4gIH1cclxuXHJcbiAgX2NyZWF0ZUNsYXNzKEJ1ZmZlckxpc3QsIFt7XHJcbiAgICBrZXk6IFwicHVzaFwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1c2godikge1xyXG4gICAgICB2YXIgZW50cnkgPSB7XHJcbiAgICAgICAgZGF0YTogdixcclxuICAgICAgICBuZXh0OiBudWxsXHJcbiAgICAgIH07XHJcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA+IDApIHRoaXMudGFpbC5uZXh0ID0gZW50cnk7ZWxzZSB0aGlzLmhlYWQgPSBlbnRyeTtcclxuICAgICAgdGhpcy50YWlsID0gZW50cnk7XHJcbiAgICAgICsrdGhpcy5sZW5ndGg7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcInVuc2hpZnRcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnNoaWZ0KHYpIHtcclxuICAgICAgdmFyIGVudHJ5ID0ge1xyXG4gICAgICAgIGRhdGE6IHYsXHJcbiAgICAgICAgbmV4dDogdGhpcy5oZWFkXHJcbiAgICAgIH07XHJcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgdGhpcy50YWlsID0gZW50cnk7XHJcbiAgICAgIHRoaXMuaGVhZCA9IGVudHJ5O1xyXG4gICAgICArK3RoaXMubGVuZ3RoO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJzaGlmdFwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNoaWZ0KCkge1xyXG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybjtcclxuICAgICAgdmFyIHJldCA9IHRoaXMuaGVhZC5kYXRhO1xyXG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDtcclxuICAgICAgLS10aGlzLmxlbmd0aDtcclxuICAgICAgcmV0dXJuIHJldDtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwiY2xlYXJcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcclxuICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcclxuICAgICAgdGhpcy5sZW5ndGggPSAwO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJqb2luXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gam9pbihzKSB7XHJcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xyXG4gICAgICB2YXIgcCA9IHRoaXMuaGVhZDtcclxuICAgICAgdmFyIHJldCA9ICcnICsgcC5kYXRhO1xyXG5cclxuICAgICAgd2hpbGUgKHAgPSBwLm5leHQpIHtcclxuICAgICAgICByZXQgKz0gcyArIHAuZGF0YTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJldDtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwiY29uY2F0XCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29uY2F0KG4pIHtcclxuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xyXG4gICAgICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4gPj4+IDApO1xyXG4gICAgICB2YXIgcCA9IHRoaXMuaGVhZDtcclxuICAgICAgdmFyIGkgPSAwO1xyXG5cclxuICAgICAgd2hpbGUgKHApIHtcclxuICAgICAgICBjb3B5QnVmZmVyKHAuZGF0YSwgcmV0LCBpKTtcclxuICAgICAgICBpICs9IHAuZGF0YS5sZW5ndGg7XHJcbiAgICAgICAgcCA9IHAubmV4dDtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJldDtcclxuICAgIH0gLy8gQ29uc3VtZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIG9yIGNoYXJhY3RlcnMgZnJvbSB0aGUgYnVmZmVyZWQgZGF0YS5cclxuXHJcbiAgfSwge1xyXG4gICAga2V5OiBcImNvbnN1bWVcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25zdW1lKG4sIGhhc1N0cmluZ3MpIHtcclxuICAgICAgdmFyIHJldDtcclxuXHJcbiAgICAgIGlmIChuIDwgdGhpcy5oZWFkLmRhdGEubGVuZ3RoKSB7XHJcbiAgICAgICAgLy8gYHNsaWNlYCBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5ncy5cclxuICAgICAgICByZXQgPSB0aGlzLmhlYWQuZGF0YS5zbGljZSgwLCBuKTtcclxuICAgICAgICB0aGlzLmhlYWQuZGF0YSA9IHRoaXMuaGVhZC5kYXRhLnNsaWNlKG4pO1xyXG4gICAgICB9IGVsc2UgaWYgKG4gPT09IHRoaXMuaGVhZC5kYXRhLmxlbmd0aCkge1xyXG4gICAgICAgIC8vIEZpcnN0IGNodW5rIGlzIGEgcGVyZmVjdCBtYXRjaC5cclxuICAgICAgICByZXQgPSB0aGlzLnNoaWZ0KCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gUmVzdWx0IHNwYW5zIG1vcmUgdGhhbiBvbmUgYnVmZmVyLlxyXG4gICAgICAgIHJldCA9IGhhc1N0cmluZ3MgPyB0aGlzLl9nZXRTdHJpbmcobikgOiB0aGlzLl9nZXRCdWZmZXIobik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiByZXQ7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcImZpcnN0XCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmlyc3QoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmhlYWQuZGF0YTtcclxuICAgIH0gLy8gQ29uc3VtZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGNoYXJhY3RlcnMgZnJvbSB0aGUgYnVmZmVyZWQgZGF0YS5cclxuXHJcbiAgfSwge1xyXG4gICAga2V5OiBcIl9nZXRTdHJpbmdcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0U3RyaW5nKG4pIHtcclxuICAgICAgdmFyIHAgPSB0aGlzLmhlYWQ7XHJcbiAgICAgIHZhciBjID0gMTtcclxuICAgICAgdmFyIHJldCA9IHAuZGF0YTtcclxuICAgICAgbiAtPSByZXQubGVuZ3RoO1xyXG5cclxuICAgICAgd2hpbGUgKHAgPSBwLm5leHQpIHtcclxuICAgICAgICB2YXIgc3RyID0gcC5kYXRhO1xyXG4gICAgICAgIHZhciBuYiA9IG4gPiBzdHIubGVuZ3RoID8gc3RyLmxlbmd0aCA6IG47XHJcbiAgICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSByZXQgKz0gc3RyO2Vsc2UgcmV0ICs9IHN0ci5zbGljZSgwLCBuKTtcclxuICAgICAgICBuIC09IG5iO1xyXG5cclxuICAgICAgICBpZiAobiA9PT0gMCkge1xyXG4gICAgICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICsrYztcclxuICAgICAgICAgICAgaWYgKHAubmV4dCkgdGhpcy5oZWFkID0gcC5uZXh0O2Vsc2UgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHA7XHJcbiAgICAgICAgICAgIHAuZGF0YSA9IHN0ci5zbGljZShuYik7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICArK2M7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMubGVuZ3RoIC09IGM7XHJcbiAgICAgIHJldHVybiByZXQ7XHJcbiAgICB9IC8vIENvbnN1bWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBieXRlcyBmcm9tIHRoZSBidWZmZXJlZCBkYXRhLlxyXG5cclxuICB9LCB7XHJcbiAgICBrZXk6IFwiX2dldEJ1ZmZlclwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRCdWZmZXIobikge1xyXG4gICAgICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4pO1xyXG4gICAgICB2YXIgcCA9IHRoaXMuaGVhZDtcclxuICAgICAgdmFyIGMgPSAxO1xyXG4gICAgICBwLmRhdGEuY29weShyZXQpO1xyXG4gICAgICBuIC09IHAuZGF0YS5sZW5ndGg7XHJcblxyXG4gICAgICB3aGlsZSAocCA9IHAubmV4dCkge1xyXG4gICAgICAgIHZhciBidWYgPSBwLmRhdGE7XHJcbiAgICAgICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjtcclxuICAgICAgICBidWYuY29weShyZXQsIHJldC5sZW5ndGggLSBuLCAwLCBuYik7XHJcbiAgICAgICAgbiAtPSBuYjtcclxuXHJcbiAgICAgICAgaWYgKG4gPT09IDApIHtcclxuICAgICAgICAgIGlmIChuYiA9PT0gYnVmLmxlbmd0aCkge1xyXG4gICAgICAgICAgICArK2M7XHJcbiAgICAgICAgICAgIGlmIChwLm5leHQpIHRoaXMuaGVhZCA9IHAubmV4dDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmhlYWQgPSBwO1xyXG4gICAgICAgICAgICBwLmRhdGEgPSBidWYuc2xpY2UobmIpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgKytjO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmxlbmd0aCAtPSBjO1xyXG4gICAgICByZXR1cm4gcmV0O1xyXG4gICAgfSAvLyBNYWtlIHN1cmUgdGhlIGxpbmtlZCBsaXN0IG9ubHkgc2hvd3MgdGhlIG1pbmltYWwgbmVjZXNzYXJ5IGluZm9ybWF0aW9uLlxyXG5cclxuICB9LCB7XHJcbiAgICBrZXk6IGN1c3RvbSxcclxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShfLCBvcHRpb25zKSB7XHJcbiAgICAgIHJldHVybiBpbnNwZWN0KHRoaXMsIF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMsIHtcclxuICAgICAgICAvLyBPbmx5IGluc3BlY3Qgb25lIGxldmVsLlxyXG4gICAgICAgIGRlcHRoOiAwLFxyXG4gICAgICAgIC8vIEl0IHNob3VsZCBub3QgcmVjdXJzZS5cclxuICAgICAgICBjdXN0b21JbnNwZWN0OiBmYWxzZVxyXG4gICAgICB9KSk7XHJcbiAgICB9XHJcbiAgfV0pO1xyXG5cclxuICByZXR1cm4gQnVmZmVyTGlzdDtcclxufSgpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/readable-stream/lib/internal/streams/buffer_list.js\n");

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/destroy.js":
/*!**********************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/destroy.js ***!
  \**********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/process/browser.js\");\n // undocumented cb() API, needed for core, not for public API\r\n\r\nfunction destroy(err, cb) {\r\n  var _this = this;\r\n\r\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\r\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\r\n\r\n  if (readableDestroyed || writableDestroyed) {\r\n    if (cb) {\r\n      cb(err);\r\n    } else if (err) {\r\n      if (!this._writableState) {\r\n        process.nextTick(emitErrorNT, this, err);\r\n      } else if (!this._writableState.errorEmitted) {\r\n        this._writableState.errorEmitted = true;\r\n        process.nextTick(emitErrorNT, this, err);\r\n      }\r\n    }\r\n\r\n    return this;\r\n  } // we set destroyed to true before firing error callbacks in order\r\n  // to make it re-entrance safe in case destroy() is called within callbacks\r\n\r\n\r\n  if (this._readableState) {\r\n    this._readableState.destroyed = true;\r\n  } // if this is a duplex stream mark the writable part as destroyed as well\r\n\r\n\r\n  if (this._writableState) {\r\n    this._writableState.destroyed = true;\r\n  }\r\n\r\n  this._destroy(err || null, function (err) {\r\n    if (!cb && err) {\r\n      if (!_this._writableState) {\r\n        process.nextTick(emitErrorAndCloseNT, _this, err);\r\n      } else if (!_this._writableState.errorEmitted) {\r\n        _this._writableState.errorEmitted = true;\r\n        process.nextTick(emitErrorAndCloseNT, _this, err);\r\n      } else {\r\n        process.nextTick(emitCloseNT, _this);\r\n      }\r\n    } else if (cb) {\r\n      process.nextTick(emitCloseNT, _this);\r\n      cb(err);\r\n    } else {\r\n      process.nextTick(emitCloseNT, _this);\r\n    }\r\n  });\r\n\r\n  return this;\r\n}\r\n\r\nfunction emitErrorAndCloseNT(self, err) {\r\n  emitErrorNT(self, err);\r\n  emitCloseNT(self);\r\n}\r\n\r\nfunction emitCloseNT(self) {\r\n  if (self._writableState && !self._writableState.emitClose) return;\r\n  if (self._readableState && !self._readableState.emitClose) return;\r\n  self.emit('close');\r\n}\r\n\r\nfunction undestroy() {\r\n  if (this._readableState) {\r\n    this._readableState.destroyed = false;\r\n    this._readableState.reading = false;\r\n    this._readableState.ended = false;\r\n    this._readableState.endEmitted = false;\r\n  }\r\n\r\n  if (this._writableState) {\r\n    this._writableState.destroyed = false;\r\n    this._writableState.ended = false;\r\n    this._writableState.ending = false;\r\n    this._writableState.finalCalled = false;\r\n    this._writableState.prefinished = false;\r\n    this._writableState.finished = false;\r\n    this._writableState.errorEmitted = false;\r\n  }\r\n}\r\n\r\nfunction emitErrorNT(self, err) {\r\n  self.emit('error', err);\r\n}\r\n\r\nfunction errorOrDestroy(stream, err) {\r\n  // We have tests that rely on errors being emitted\r\n  // in the same tick, so changing this is semver major.\r\n  // For now when you opt-in to autoDestroy we allow\r\n  // the error to be emitted nextTick. In a future\r\n  // semver major update we should change the default to this.\r\n  var rState = stream._readableState;\r\n  var wState = stream._writableState;\r\n  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);\r\n}\r\n\r\nmodule.exports = {\r\n  destroy: destroy,\r\n  undestroy: undestroy,\r\n  errorOrDestroy: errorOrDestroy\r\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3kuanMuanMiLCJtYXBwaW5ncyI6IjtBQUFhLENBQUM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLFFBQVEsT0FBTztBQUNmLFFBQVE7QUFDUjtBQUNBLFFBQVEsT0FBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxPQUFPO0FBQ2YsUUFBUTtBQUNSO0FBQ0EsUUFBUSxPQUFPO0FBQ2YsUUFBUTtBQUNSLFFBQVEsT0FBTztBQUNmO0FBQ0EsTUFBTTtBQUNOLE1BQU0sT0FBTztBQUNiO0FBQ0EsTUFBTTtBQUNOLE1BQU0sT0FBTztBQUNiO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveS5qcz9jODkzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JzsgLy8gdW5kb2N1bWVudGVkIGNiKCkgQVBJLCBuZWVkZWQgZm9yIGNvcmUsIG5vdCBmb3IgcHVibGljIEFQSVxyXG5cclxuZnVuY3Rpb24gZGVzdHJveShlcnIsIGNiKSB7XHJcbiAgdmFyIF90aGlzID0gdGhpcztcclxuXHJcbiAgdmFyIHJlYWRhYmxlRGVzdHJveWVkID0gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcclxuICB2YXIgd3JpdGFibGVEZXN0cm95ZWQgPSB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xyXG5cclxuICBpZiAocmVhZGFibGVEZXN0cm95ZWQgfHwgd3JpdGFibGVEZXN0cm95ZWQpIHtcclxuICAgIGlmIChjYikge1xyXG4gICAgICBjYihlcnIpO1xyXG4gICAgfSBlbHNlIGlmIChlcnIpIHtcclxuICAgICAgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlKSB7XHJcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JOVCwgdGhpcywgZXJyKTtcclxuICAgICAgfSBlbHNlIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpIHtcclxuICAgICAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XHJcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JOVCwgdGhpcywgZXJyKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH0gLy8gd2Ugc2V0IGRlc3Ryb3llZCB0byB0cnVlIGJlZm9yZSBmaXJpbmcgZXJyb3IgY2FsbGJhY2tzIGluIG9yZGVyXHJcbiAgLy8gdG8gbWFrZSBpdCByZS1lbnRyYW5jZSBzYWZlIGluIGNhc2UgZGVzdHJveSgpIGlzIGNhbGxlZCB3aXRoaW4gY2FsbGJhY2tzXHJcblxyXG5cclxuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xyXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xyXG4gIH0gLy8gaWYgdGhpcyBpcyBhIGR1cGxleCBzdHJlYW0gbWFyayB0aGUgd3JpdGFibGUgcGFydCBhcyBkZXN0cm95ZWQgYXMgd2VsbFxyXG5cclxuXHJcbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcclxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIHRoaXMuX2Rlc3Ryb3koZXJyIHx8IG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgIGlmICghY2IgJiYgZXJyKSB7XHJcbiAgICAgIGlmICghX3RoaXMuX3dyaXRhYmxlU3RhdGUpIHtcclxuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvckFuZENsb3NlTlQsIF90aGlzLCBlcnIpO1xyXG4gICAgICB9IGVsc2UgaWYgKCFfdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpIHtcclxuICAgICAgICBfdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xyXG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yQW5kQ2xvc2VOVCwgX3RoaXMsIGVycik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2VOVCwgX3RoaXMpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGNiKSB7XHJcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlTlQsIF90aGlzKTtcclxuICAgICAgY2IoZXJyKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlTlQsIF90aGlzKTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVtaXRFcnJvckFuZENsb3NlTlQoc2VsZiwgZXJyKSB7XHJcbiAgZW1pdEVycm9yTlQoc2VsZiwgZXJyKTtcclxuICBlbWl0Q2xvc2VOVChzZWxmKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZW1pdENsb3NlTlQoc2VsZikge1xyXG4gIGlmIChzZWxmLl93cml0YWJsZVN0YXRlICYmICFzZWxmLl93cml0YWJsZVN0YXRlLmVtaXRDbG9zZSkgcmV0dXJuO1xyXG4gIGlmIChzZWxmLl9yZWFkYWJsZVN0YXRlICYmICFzZWxmLl9yZWFkYWJsZVN0YXRlLmVtaXRDbG9zZSkgcmV0dXJuO1xyXG4gIHNlbGYuZW1pdCgnY2xvc2UnKTtcclxufVxyXG5cclxuZnVuY3Rpb24gdW5kZXN0cm95KCkge1xyXG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XHJcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkaW5nID0gZmFsc2U7XHJcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XHJcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQgPSBmYWxzZTtcclxuICB9XHJcblxyXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XHJcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRpbmcgPSBmYWxzZTtcclxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluYWxDYWxsZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUucHJlZmluaXNoZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gZmFsc2U7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBlbWl0RXJyb3JOVChzZWxmLCBlcnIpIHtcclxuICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcnIpIHtcclxuICAvLyBXZSBoYXZlIHRlc3RzIHRoYXQgcmVseSBvbiBlcnJvcnMgYmVpbmcgZW1pdHRlZFxyXG4gIC8vIGluIHRoZSBzYW1lIHRpY2ssIHNvIGNoYW5naW5nIHRoaXMgaXMgc2VtdmVyIG1ham9yLlxyXG4gIC8vIEZvciBub3cgd2hlbiB5b3Ugb3B0LWluIHRvIGF1dG9EZXN0cm95IHdlIGFsbG93XHJcbiAgLy8gdGhlIGVycm9yIHRvIGJlIGVtaXR0ZWQgbmV4dFRpY2suIEluIGEgZnV0dXJlXHJcbiAgLy8gc2VtdmVyIG1ham9yIHVwZGF0ZSB3ZSBzaG91bGQgY2hhbmdlIHRoZSBkZWZhdWx0IHRvIHRoaXMuXHJcbiAgdmFyIHJTdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcclxuICB2YXIgd1N0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xyXG4gIGlmIChyU3RhdGUgJiYgclN0YXRlLmF1dG9EZXN0cm95IHx8IHdTdGF0ZSAmJiB3U3RhdGUuYXV0b0Rlc3Ryb3kpIHN0cmVhbS5kZXN0cm95KGVycik7ZWxzZSBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICBkZXN0cm95OiBkZXN0cm95LFxyXG4gIHVuZGVzdHJveTogdW5kZXN0cm95LFxyXG4gIGVycm9yT3JEZXN0cm95OiBlcnJvck9yRGVzdHJveVxyXG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/readable-stream/lib/internal/streams/destroy.js\n");

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/end-of-stream.js":
/*!****************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/end-of-stream.js ***!
  \****************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("// Ported from https://github.com/mafintosh/end-of-stream with\r\n// permission from the author, Mathias Buus (@mafintosh).\r\n\r\n\r\nvar ERR_STREAM_PREMATURE_CLOSE = (__webpack_require__(/*! ../../../errors */ \"./node_modules/readable-stream/errors-browser.js\").codes.ERR_STREAM_PREMATURE_CLOSE);\r\n\r\nfunction once(callback) {\r\n  var called = false;\r\n  return function () {\r\n    if (called) return;\r\n    called = true;\r\n\r\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\r\n      args[_key] = arguments[_key];\r\n    }\r\n\r\n    callback.apply(this, args);\r\n  };\r\n}\r\n\r\nfunction noop() {}\r\n\r\nfunction isRequest(stream) {\r\n  return stream.setHeader && typeof stream.abort === 'function';\r\n}\r\n\r\nfunction eos(stream, opts, callback) {\r\n  if (typeof opts === 'function') return eos(stream, null, opts);\r\n  if (!opts) opts = {};\r\n  callback = once(callback || noop);\r\n  var readable = opts.readable || opts.readable !== false && stream.readable;\r\n  var writable = opts.writable || opts.writable !== false && stream.writable;\r\n\r\n  var onlegacyfinish = function onlegacyfinish() {\r\n    if (!stream.writable) onfinish();\r\n  };\r\n\r\n  var writableEnded = stream._writableState && stream._writableState.finished;\r\n\r\n  var onfinish = function onfinish() {\r\n    writable = false;\r\n    writableEnded = true;\r\n    if (!readable) callback.call(stream);\r\n  };\r\n\r\n  var readableEnded = stream._readableState && stream._readableState.endEmitted;\r\n\r\n  var onend = function onend() {\r\n    readable = false;\r\n    readableEnded = true;\r\n    if (!writable) callback.call(stream);\r\n  };\r\n\r\n  var onerror = function onerror(err) {\r\n    callback.call(stream, err);\r\n  };\r\n\r\n  var onclose = function onclose() {\r\n    var err;\r\n\r\n    if (readable && !readableEnded) {\r\n      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\r\n      return callback.call(stream, err);\r\n    }\r\n\r\n    if (writable && !writableEnded) {\r\n      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\r\n      return callback.call(stream, err);\r\n    }\r\n  };\r\n\r\n  var onrequest = function onrequest() {\r\n    stream.req.on('finish', onfinish);\r\n  };\r\n\r\n  if (isRequest(stream)) {\r\n    stream.on('complete', onfinish);\r\n    stream.on('abort', onclose);\r\n    if (stream.req) onrequest();else stream.on('request', onrequest);\r\n  } else if (writable && !stream._writableState) {\r\n    // legacy streams\r\n    stream.on('end', onlegacyfinish);\r\n    stream.on('close', onlegacyfinish);\r\n  }\r\n\r\n  stream.on('end', onend);\r\n  stream.on('finish', onfinish);\r\n  if (opts.error !== false) stream.on('error', onerror);\r\n  stream.on('close', onclose);\r\n  return function () {\r\n    stream.removeListener('complete', onfinish);\r\n    stream.removeListener('abort', onclose);\r\n    stream.removeListener('request', onrequest);\r\n    if (stream.req) stream.req.removeListener('finish', onfinish);\r\n    stream.removeListener('end', onlegacyfinish);\r\n    stream.removeListener('close', onlegacyfinish);\r\n    stream.removeListener('finish', onfinish);\r\n    stream.removeListener('end', onend);\r\n    stream.removeListener('error', onerror);\r\n    stream.removeListener('close', onclose);\r\n  };\r\n}\r\n\r\nmodule.exports = eos;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2VuZC1vZi1zdHJlYW0uanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNhO0FBQ2I7QUFDQSxpQ0FBaUMsaUlBQTJEO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLGFBQWE7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZW5kLW9mLXN0cmVhbS5qcz84OGRjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFBvcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYWZpbnRvc2gvZW5kLW9mLXN0cmVhbSB3aXRoXHJcbi8vIHBlcm1pc3Npb24gZnJvbSB0aGUgYXV0aG9yLCBNYXRoaWFzIEJ1dXMgKEBtYWZpbnRvc2gpLlxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UgPSByZXF1aXJlKCcuLi8uLi8uLi9lcnJvcnMnKS5jb2Rlcy5FUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRTtcclxuXHJcbmZ1bmN0aW9uIG9uY2UoY2FsbGJhY2spIHtcclxuICB2YXIgY2FsbGVkID0gZmFsc2U7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgIGlmIChjYWxsZWQpIHJldHVybjtcclxuICAgIGNhbGxlZCA9IHRydWU7XHJcblxyXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XHJcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XHJcbiAgICB9XHJcblxyXG4gICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJncyk7XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gbm9vcCgpIHt9XHJcblxyXG5mdW5jdGlvbiBpc1JlcXVlc3Qoc3RyZWFtKSB7XHJcbiAgcmV0dXJuIHN0cmVhbS5zZXRIZWFkZXIgJiYgdHlwZW9mIHN0cmVhbS5hYm9ydCA9PT0gJ2Z1bmN0aW9uJztcclxufVxyXG5cclxuZnVuY3Rpb24gZW9zKHN0cmVhbSwgb3B0cywgY2FsbGJhY2spIHtcclxuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHJldHVybiBlb3Moc3RyZWFtLCBudWxsLCBvcHRzKTtcclxuICBpZiAoIW9wdHMpIG9wdHMgPSB7fTtcclxuICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2sgfHwgbm9vcCk7XHJcbiAgdmFyIHJlYWRhYmxlID0gb3B0cy5yZWFkYWJsZSB8fCBvcHRzLnJlYWRhYmxlICE9PSBmYWxzZSAmJiBzdHJlYW0ucmVhZGFibGU7XHJcbiAgdmFyIHdyaXRhYmxlID0gb3B0cy53cml0YWJsZSB8fCBvcHRzLndyaXRhYmxlICE9PSBmYWxzZSAmJiBzdHJlYW0ud3JpdGFibGU7XHJcblxyXG4gIHZhciBvbmxlZ2FjeWZpbmlzaCA9IGZ1bmN0aW9uIG9ubGVnYWN5ZmluaXNoKCkge1xyXG4gICAgaWYgKCFzdHJlYW0ud3JpdGFibGUpIG9uZmluaXNoKCk7XHJcbiAgfTtcclxuXHJcbiAgdmFyIHdyaXRhYmxlRW5kZWQgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGUgJiYgc3RyZWFtLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkO1xyXG5cclxuICB2YXIgb25maW5pc2ggPSBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcclxuICAgIHdyaXRhYmxlID0gZmFsc2U7XHJcbiAgICB3cml0YWJsZUVuZGVkID0gdHJ1ZTtcclxuICAgIGlmICghcmVhZGFibGUpIGNhbGxiYWNrLmNhbGwoc3RyZWFtKTtcclxuICB9O1xyXG5cclxuICB2YXIgcmVhZGFibGVFbmRlZCA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZSAmJiBzdHJlYW0uX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZDtcclxuXHJcbiAgdmFyIG9uZW5kID0gZnVuY3Rpb24gb25lbmQoKSB7XHJcbiAgICByZWFkYWJsZSA9IGZhbHNlO1xyXG4gICAgcmVhZGFibGVFbmRlZCA9IHRydWU7XHJcbiAgICBpZiAoIXdyaXRhYmxlKSBjYWxsYmFjay5jYWxsKHN0cmVhbSk7XHJcbiAgfTtcclxuXHJcbiAgdmFyIG9uZXJyb3IgPSBmdW5jdGlvbiBvbmVycm9yKGVycikge1xyXG4gICAgY2FsbGJhY2suY2FsbChzdHJlYW0sIGVycik7XHJcbiAgfTtcclxuXHJcbiAgdmFyIG9uY2xvc2UgPSBmdW5jdGlvbiBvbmNsb3NlKCkge1xyXG4gICAgdmFyIGVycjtcclxuXHJcbiAgICBpZiAocmVhZGFibGUgJiYgIXJlYWRhYmxlRW5kZWQpIHtcclxuICAgICAgaWYgKCFzdHJlYW0uX3JlYWRhYmxlU3RhdGUgfHwgIXN0cmVhbS5fcmVhZGFibGVTdGF0ZS5lbmRlZCkgZXJyID0gbmV3IEVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFKCk7XHJcbiAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHN0cmVhbSwgZXJyKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAod3JpdGFibGUgJiYgIXdyaXRhYmxlRW5kZWQpIHtcclxuICAgICAgaWYgKCFzdHJlYW0uX3dyaXRhYmxlU3RhdGUgfHwgIXN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgZXJyID0gbmV3IEVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFKCk7XHJcbiAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHN0cmVhbSwgZXJyKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICB2YXIgb25yZXF1ZXN0ID0gZnVuY3Rpb24gb25yZXF1ZXN0KCkge1xyXG4gICAgc3RyZWFtLnJlcS5vbignZmluaXNoJywgb25maW5pc2gpO1xyXG4gIH07XHJcblxyXG4gIGlmIChpc1JlcXVlc3Qoc3RyZWFtKSkge1xyXG4gICAgc3RyZWFtLm9uKCdjb21wbGV0ZScsIG9uZmluaXNoKTtcclxuICAgIHN0cmVhbS5vbignYWJvcnQnLCBvbmNsb3NlKTtcclxuICAgIGlmIChzdHJlYW0ucmVxKSBvbnJlcXVlc3QoKTtlbHNlIHN0cmVhbS5vbigncmVxdWVzdCcsIG9ucmVxdWVzdCk7XHJcbiAgfSBlbHNlIGlmICh3cml0YWJsZSAmJiAhc3RyZWFtLl93cml0YWJsZVN0YXRlKSB7XHJcbiAgICAvLyBsZWdhY3kgc3RyZWFtc1xyXG4gICAgc3RyZWFtLm9uKCdlbmQnLCBvbmxlZ2FjeWZpbmlzaCk7XHJcbiAgICBzdHJlYW0ub24oJ2Nsb3NlJywgb25sZWdhY3lmaW5pc2gpO1xyXG4gIH1cclxuXHJcbiAgc3RyZWFtLm9uKCdlbmQnLCBvbmVuZCk7XHJcbiAgc3RyZWFtLm9uKCdmaW5pc2gnLCBvbmZpbmlzaCk7XHJcbiAgaWYgKG9wdHMuZXJyb3IgIT09IGZhbHNlKSBzdHJlYW0ub24oJ2Vycm9yJywgb25lcnJvcik7XHJcbiAgc3RyZWFtLm9uKCdjbG9zZScsIG9uY2xvc2UpO1xyXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2NvbXBsZXRlJywgb25maW5pc2gpO1xyXG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdhYm9ydCcsIG9uY2xvc2UpO1xyXG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdyZXF1ZXN0Jywgb25yZXF1ZXN0KTtcclxuICAgIGlmIChzdHJlYW0ucmVxKSBzdHJlYW0ucmVxLnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XHJcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9ubGVnYWN5ZmluaXNoKTtcclxuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmxlZ2FjeWZpbmlzaCk7XHJcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcclxuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xyXG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xyXG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xyXG4gIH07XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZW9zOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/readable-stream/lib/internal/streams/end-of-stream.js\n");

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/from-browser.js":
/*!***************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/from-browser.js ***!
  \***************************************************************************/
/***/ (function(module) {

eval("module.exports = function () {\r\n  throw new Error('Readable.from is not available in the browser')\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2Zyb20tYnJvd3Nlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9mcm9tLWJyb3dzZXIuanM/OWQ1NCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcclxuICB0aHJvdyBuZXcgRXJyb3IoJ1JlYWRhYmxlLmZyb20gaXMgbm90IGF2YWlsYWJsZSBpbiB0aGUgYnJvd3NlcicpXHJcbn07XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/readable-stream/lib/internal/streams/from-browser.js\n");

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/pipeline.js":
/*!***********************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/pipeline.js ***!
  \***********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("// Ported from https://github.com/mafintosh/pump with\r\n// permission from the author, Mathias Buus (@mafintosh).\r\n\r\n\r\nvar eos;\r\n\r\nfunction once(callback) {\r\n  var called = false;\r\n  return function () {\r\n    if (called) return;\r\n    called = true;\r\n    callback.apply(void 0, arguments);\r\n  };\r\n}\r\n\r\nvar _require$codes = (__webpack_require__(/*! ../../../errors */ \"./node_modules/readable-stream/errors-browser.js\").codes),\r\n    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,\r\n    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;\r\n\r\nfunction noop(err) {\r\n  // Rethrow the error if it exists to avoid swallowing it\r\n  if (err) throw err;\r\n}\r\n\r\nfunction isRequest(stream) {\r\n  return stream.setHeader && typeof stream.abort === 'function';\r\n}\r\n\r\nfunction destroyer(stream, reading, writing, callback) {\r\n  callback = once(callback);\r\n  var closed = false;\r\n  stream.on('close', function () {\r\n    closed = true;\r\n  });\r\n  if (eos === undefined) eos = __webpack_require__(/*! ./end-of-stream */ \"./node_modules/readable-stream/lib/internal/streams/end-of-stream.js\");\r\n  eos(stream, {\r\n    readable: reading,\r\n    writable: writing\r\n  }, function (err) {\r\n    if (err) return callback(err);\r\n    closed = true;\r\n    callback();\r\n  });\r\n  var destroyed = false;\r\n  return function (err) {\r\n    if (closed) return;\r\n    if (destroyed) return;\r\n    destroyed = true; // request.destroy just do .end - .abort is what we want\r\n\r\n    if (isRequest(stream)) return stream.abort();\r\n    if (typeof stream.destroy === 'function') return stream.destroy();\r\n    callback(err || new ERR_STREAM_DESTROYED('pipe'));\r\n  };\r\n}\r\n\r\nfunction call(fn) {\r\n  fn();\r\n}\r\n\r\nfunction pipe(from, to) {\r\n  return from.pipe(to);\r\n}\r\n\r\nfunction popCallback(streams) {\r\n  if (!streams.length) return noop;\r\n  if (typeof streams[streams.length - 1] !== 'function') return noop;\r\n  return streams.pop();\r\n}\r\n\r\nfunction pipeline() {\r\n  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {\r\n    streams[_key] = arguments[_key];\r\n  }\r\n\r\n  var callback = popCallback(streams);\r\n  if (Array.isArray(streams[0])) streams = streams[0];\r\n\r\n  if (streams.length < 2) {\r\n    throw new ERR_MISSING_ARGS('streams');\r\n  }\r\n\r\n  var error;\r\n  var destroys = streams.map(function (stream, i) {\r\n    var reading = i < streams.length - 1;\r\n    var writing = i > 0;\r\n    return destroyer(stream, reading, writing, function (err) {\r\n      if (!error) error = err;\r\n      if (err) destroys.forEach(call);\r\n      if (reading) return;\r\n      destroys.forEach(call);\r\n      callback(error);\r\n    });\r\n  });\r\n  return streams.reduce(pipe);\r\n}\r\n\r\nmodule.exports = pipeline;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3BpcGVsaW5lLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzR0FBZ0M7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCwrQkFBK0IsbUJBQU8sQ0FBQyw2RkFBaUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxhQUFhO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvcGlwZWxpbmUuanM/OTVmNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBQb3J0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWFmaW50b3NoL3B1bXAgd2l0aFxyXG4vLyBwZXJtaXNzaW9uIGZyb20gdGhlIGF1dGhvciwgTWF0aGlhcyBCdXVzIChAbWFmaW50b3NoKS5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGVvcztcclxuXHJcbmZ1bmN0aW9uIG9uY2UoY2FsbGJhY2spIHtcclxuICB2YXIgY2FsbGVkID0gZmFsc2U7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgIGlmIChjYWxsZWQpIHJldHVybjtcclxuICAgIGNhbGxlZCA9IHRydWU7XHJcbiAgICBjYWxsYmFjay5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cyk7XHJcbiAgfTtcclxufVxyXG5cclxudmFyIF9yZXF1aXJlJGNvZGVzID0gcmVxdWlyZSgnLi4vLi4vLi4vZXJyb3JzJykuY29kZXMsXHJcbiAgICBFUlJfTUlTU0lOR19BUkdTID0gX3JlcXVpcmUkY29kZXMuRVJSX01JU1NJTkdfQVJHUyxcclxuICAgIEVSUl9TVFJFQU1fREVTVFJPWUVEID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9ERVNUUk9ZRUQ7XHJcblxyXG5mdW5jdGlvbiBub29wKGVycikge1xyXG4gIC8vIFJldGhyb3cgdGhlIGVycm9yIGlmIGl0IGV4aXN0cyB0byBhdm9pZCBzd2FsbG93aW5nIGl0XHJcbiAgaWYgKGVycikgdGhyb3cgZXJyO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc1JlcXVlc3Qoc3RyZWFtKSB7XHJcbiAgcmV0dXJuIHN0cmVhbS5zZXRIZWFkZXIgJiYgdHlwZW9mIHN0cmVhbS5hYm9ydCA9PT0gJ2Z1bmN0aW9uJztcclxufVxyXG5cclxuZnVuY3Rpb24gZGVzdHJveWVyKHN0cmVhbSwgcmVhZGluZywgd3JpdGluZywgY2FsbGJhY2spIHtcclxuICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2spO1xyXG4gIHZhciBjbG9zZWQgPSBmYWxzZTtcclxuICBzdHJlYW0ub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgY2xvc2VkID0gdHJ1ZTtcclxuICB9KTtcclxuICBpZiAoZW9zID09PSB1bmRlZmluZWQpIGVvcyA9IHJlcXVpcmUoJy4vZW5kLW9mLXN0cmVhbScpO1xyXG4gIGVvcyhzdHJlYW0sIHtcclxuICAgIHJlYWRhYmxlOiByZWFkaW5nLFxyXG4gICAgd3JpdGFibGU6IHdyaXRpbmdcclxuICB9LCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuICAgIGNsb3NlZCA9IHRydWU7XHJcbiAgICBjYWxsYmFjaygpO1xyXG4gIH0pO1xyXG4gIHZhciBkZXN0cm95ZWQgPSBmYWxzZTtcclxuICByZXR1cm4gZnVuY3Rpb24gKGVycikge1xyXG4gICAgaWYgKGNsb3NlZCkgcmV0dXJuO1xyXG4gICAgaWYgKGRlc3Ryb3llZCkgcmV0dXJuO1xyXG4gICAgZGVzdHJveWVkID0gdHJ1ZTsgLy8gcmVxdWVzdC5kZXN0cm95IGp1c3QgZG8gLmVuZCAtIC5hYm9ydCBpcyB3aGF0IHdlIHdhbnRcclxuXHJcbiAgICBpZiAoaXNSZXF1ZXN0KHN0cmVhbSkpIHJldHVybiBzdHJlYW0uYWJvcnQoKTtcclxuICAgIGlmICh0eXBlb2Ygc3RyZWFtLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHJldHVybiBzdHJlYW0uZGVzdHJveSgpO1xyXG4gICAgY2FsbGJhY2soZXJyIHx8IG5ldyBFUlJfU1RSRUFNX0RFU1RST1lFRCgncGlwZScpKTtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjYWxsKGZuKSB7XHJcbiAgZm4oKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcGlwZShmcm9tLCB0bykge1xyXG4gIHJldHVybiBmcm9tLnBpcGUodG8pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwb3BDYWxsYmFjayhzdHJlYW1zKSB7XHJcbiAgaWYgKCFzdHJlYW1zLmxlbmd0aCkgcmV0dXJuIG5vb3A7XHJcbiAgaWYgKHR5cGVvZiBzdHJlYW1zW3N0cmVhbXMubGVuZ3RoIC0gMV0gIT09ICdmdW5jdGlvbicpIHJldHVybiBub29wO1xyXG4gIHJldHVybiBzdHJlYW1zLnBvcCgpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwaXBlbGluZSgpIHtcclxuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc3RyZWFtcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcclxuICAgIHN0cmVhbXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XHJcbiAgfVxyXG5cclxuICB2YXIgY2FsbGJhY2sgPSBwb3BDYWxsYmFjayhzdHJlYW1zKTtcclxuICBpZiAoQXJyYXkuaXNBcnJheShzdHJlYW1zWzBdKSkgc3RyZWFtcyA9IHN0cmVhbXNbMF07XHJcblxyXG4gIGlmIChzdHJlYW1zLmxlbmd0aCA8IDIpIHtcclxuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdzdHJlYW1zJyk7XHJcbiAgfVxyXG5cclxuICB2YXIgZXJyb3I7XHJcbiAgdmFyIGRlc3Ryb3lzID0gc3RyZWFtcy5tYXAoZnVuY3Rpb24gKHN0cmVhbSwgaSkge1xyXG4gICAgdmFyIHJlYWRpbmcgPSBpIDwgc3RyZWFtcy5sZW5ndGggLSAxO1xyXG4gICAgdmFyIHdyaXRpbmcgPSBpID4gMDtcclxuICAgIHJldHVybiBkZXN0cm95ZXIoc3RyZWFtLCByZWFkaW5nLCB3cml0aW5nLCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgIGlmICghZXJyb3IpIGVycm9yID0gZXJyO1xyXG4gICAgICBpZiAoZXJyKSBkZXN0cm95cy5mb3JFYWNoKGNhbGwpO1xyXG4gICAgICBpZiAocmVhZGluZykgcmV0dXJuO1xyXG4gICAgICBkZXN0cm95cy5mb3JFYWNoKGNhbGwpO1xyXG4gICAgICBjYWxsYmFjayhlcnJvcik7XHJcbiAgICB9KTtcclxuICB9KTtcclxuICByZXR1cm4gc3RyZWFtcy5yZWR1Y2UocGlwZSk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gcGlwZWxpbmU7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/readable-stream/lib/internal/streams/pipeline.js\n");

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/state.js":
/*!********************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/state.js ***!
  \********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar ERR_INVALID_OPT_VALUE = (__webpack_require__(/*! ../../../errors */ \"./node_modules/readable-stream/errors-browser.js\").codes.ERR_INVALID_OPT_VALUE);\r\n\r\nfunction highWaterMarkFrom(options, isDuplex, duplexKey) {\r\n  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;\r\n}\r\n\r\nfunction getHighWaterMark(state, options, duplexKey, isDuplex) {\r\n  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);\r\n\r\n  if (hwm != null) {\r\n    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {\r\n      var name = isDuplex ? duplexKey : 'highWaterMark';\r\n      throw new ERR_INVALID_OPT_VALUE(name, hwm);\r\n    }\r\n\r\n    return Math.floor(hwm);\r\n  } // Default value\r\n\r\n\r\n  return state.objectMode ? 16 : 16 * 1024;\r\n}\r\n\r\nmodule.exports = {\r\n  getHighWaterMark: getHighWaterMark\r\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3N0YXRlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw0QkFBNEIsNEhBQXNEO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RhdGUuanM/MjY1NiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgRVJSX0lOVkFMSURfT1BUX1ZBTFVFID0gcmVxdWlyZSgnLi4vLi4vLi4vZXJyb3JzJykuY29kZXMuRVJSX0lOVkFMSURfT1BUX1ZBTFVFO1xyXG5cclxuZnVuY3Rpb24gaGlnaFdhdGVyTWFya0Zyb20ob3B0aW9ucywgaXNEdXBsZXgsIGR1cGxleEtleSkge1xyXG4gIHJldHVybiBvcHRpb25zLmhpZ2hXYXRlck1hcmsgIT0gbnVsbCA/IG9wdGlvbnMuaGlnaFdhdGVyTWFyayA6IGlzRHVwbGV4ID8gb3B0aW9uc1tkdXBsZXhLZXldIDogbnVsbDtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0SGlnaFdhdGVyTWFyayhzdGF0ZSwgb3B0aW9ucywgZHVwbGV4S2V5LCBpc0R1cGxleCkge1xyXG4gIHZhciBod20gPSBoaWdoV2F0ZXJNYXJrRnJvbShvcHRpb25zLCBpc0R1cGxleCwgZHVwbGV4S2V5KTtcclxuXHJcbiAgaWYgKGh3bSAhPSBudWxsKSB7XHJcbiAgICBpZiAoIShpc0Zpbml0ZShod20pICYmIE1hdGguZmxvb3IoaHdtKSA9PT0gaHdtKSB8fCBod20gPCAwKSB7XHJcbiAgICAgIHZhciBuYW1lID0gaXNEdXBsZXggPyBkdXBsZXhLZXkgOiAnaGlnaFdhdGVyTWFyayc7XHJcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9PUFRfVkFMVUUobmFtZSwgaHdtKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gTWF0aC5mbG9vcihod20pO1xyXG4gIH0gLy8gRGVmYXVsdCB2YWx1ZVxyXG5cclxuXHJcbiAgcmV0dXJuIHN0YXRlLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgZ2V0SGlnaFdhdGVyTWFyazogZ2V0SGlnaFdhdGVyTWFya1xyXG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/readable-stream/lib/internal/streams/state.js\n");

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/stream-browser.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/stream-browser.js ***!
  \*****************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbS1icm93c2VyLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLGtHQUErQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbS1icm93c2VyLmpzPzFjMjYiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/readable-stream/lib/internal/streams/stream-browser.js\n");

/***/ }),

/***/ "./node_modules/readable-stream/readable-browser.js":
/*!**********************************************************!*\
  !*** ./node_modules/readable-stream/readable-browser.js ***!
  \**********************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ./lib/_stream_readable.js */ \"./node_modules/readable-stream/lib/_stream_readable.js\");\r\nexports.Stream = exports;\r\nexports.Readable = exports;\r\nexports.Writable = __webpack_require__(/*! ./lib/_stream_writable.js */ \"./node_modules/readable-stream/lib/_stream_writable.js\");\r\nexports.Duplex = __webpack_require__(/*! ./lib/_stream_duplex.js */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\r\nexports.Transform = __webpack_require__(/*! ./lib/_stream_transform.js */ \"./node_modules/readable-stream/lib/_stream_transform.js\");\r\nexports.PassThrough = __webpack_require__(/*! ./lib/_stream_passthrough.js */ \"./node_modules/readable-stream/lib/_stream_passthrough.js\");\r\nexports.finished = __webpack_require__(/*! ./lib/internal/streams/end-of-stream.js */ \"./node_modules/readable-stream/lib/internal/streams/end-of-stream.js\");\r\nexports.pipeline = __webpack_require__(/*! ./lib/internal/streams/pipeline.js */ \"./node_modules/readable-stream/lib/internal/streams/pipeline.js\");\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLWJyb3dzZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsVUFBVSwrSEFBcUQ7QUFDL0QsY0FBYztBQUNkLGdCQUFnQjtBQUNoQixpSUFBdUQ7QUFDdkQsMkhBQW1EO0FBQ25ELG9JQUF5RDtBQUN6RCwwSUFBNkQ7QUFDN0QsNkpBQXFFO0FBQ3JFLG1KQUFnRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLWJyb3dzZXIuanM/ZjQyMyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XHJcbmV4cG9ydHMuU3RyZWFtID0gZXhwb3J0cztcclxuZXhwb3J0cy5SZWFkYWJsZSA9IGV4cG9ydHM7XHJcbmV4cG9ydHMuV3JpdGFibGUgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XHJcbmV4cG9ydHMuRHVwbGV4ID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcclxuZXhwb3J0cy5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcycpO1xyXG5leHBvcnRzLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcycpO1xyXG5leHBvcnRzLmZpbmlzaGVkID0gcmVxdWlyZSgnLi9saWIvaW50ZXJuYWwvc3RyZWFtcy9lbmQtb2Ytc3RyZWFtLmpzJyk7XHJcbmV4cG9ydHMucGlwZWxpbmUgPSByZXF1aXJlKCcuL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3BpcGVsaW5lLmpzJyk7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/readable-stream/readable-browser.js\n");

/***/ }),

/***/ "./node_modules/ripemd160/index.js":
/*!*****************************************!*\
  !*** ./node_modules/ripemd160/index.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\r\nvar Buffer = (__webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\").Buffer)\r\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\r\nvar HashBase = __webpack_require__(/*! hash-base */ \"./node_modules/hash-base/index.js\")\r\n\r\nvar ARRAY16 = new Array(16)\r\n\r\nvar zl = [\r\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\r\n  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,\r\n  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,\r\n  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,\r\n  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13\r\n]\r\n\r\nvar zr = [\r\n  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,\r\n  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,\r\n  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,\r\n  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,\r\n  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11\r\n]\r\n\r\nvar sl = [\r\n  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,\r\n  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,\r\n  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,\r\n  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,\r\n  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6\r\n]\r\n\r\nvar sr = [\r\n  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,\r\n  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,\r\n  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,\r\n  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,\r\n  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11\r\n]\r\n\r\nvar hl = [0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]\r\nvar hr = [0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]\r\n\r\nfunction RIPEMD160 () {\r\n  HashBase.call(this, 64)\r\n\r\n  // state\r\n  this._a = 0x67452301\r\n  this._b = 0xefcdab89\r\n  this._c = 0x98badcfe\r\n  this._d = 0x10325476\r\n  this._e = 0xc3d2e1f0\r\n}\r\n\r\ninherits(RIPEMD160, HashBase)\r\n\r\nRIPEMD160.prototype._update = function () {\r\n  var words = ARRAY16\r\n  for (var j = 0; j < 16; ++j) words[j] = this._block.readInt32LE(j * 4)\r\n\r\n  var al = this._a | 0\r\n  var bl = this._b | 0\r\n  var cl = this._c | 0\r\n  var dl = this._d | 0\r\n  var el = this._e | 0\r\n\r\n  var ar = this._a | 0\r\n  var br = this._b | 0\r\n  var cr = this._c | 0\r\n  var dr = this._d | 0\r\n  var er = this._e | 0\r\n\r\n  // computation\r\n  for (var i = 0; i < 80; i += 1) {\r\n    var tl\r\n    var tr\r\n    if (i < 16) {\r\n      tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i])\r\n      tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i])\r\n    } else if (i < 32) {\r\n      tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i])\r\n      tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i])\r\n    } else if (i < 48) {\r\n      tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i])\r\n      tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i])\r\n    } else if (i < 64) {\r\n      tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i])\r\n      tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i])\r\n    } else { // if (i<80) {\r\n      tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i])\r\n      tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i])\r\n    }\r\n\r\n    al = el\r\n    el = dl\r\n    dl = rotl(cl, 10)\r\n    cl = bl\r\n    bl = tl\r\n\r\n    ar = er\r\n    er = dr\r\n    dr = rotl(cr, 10)\r\n    cr = br\r\n    br = tr\r\n  }\r\n\r\n  // update state\r\n  var t = (this._b + cl + dr) | 0\r\n  this._b = (this._c + dl + er) | 0\r\n  this._c = (this._d + el + ar) | 0\r\n  this._d = (this._e + al + br) | 0\r\n  this._e = (this._a + bl + cr) | 0\r\n  this._a = t\r\n}\r\n\r\nRIPEMD160.prototype._digest = function () {\r\n  // create padding and handle blocks\r\n  this._block[this._blockOffset++] = 0x80\r\n  if (this._blockOffset > 56) {\r\n    this._block.fill(0, this._blockOffset, 64)\r\n    this._update()\r\n    this._blockOffset = 0\r\n  }\r\n\r\n  this._block.fill(0, this._blockOffset, 56)\r\n  this._block.writeUInt32LE(this._length[0], 56)\r\n  this._block.writeUInt32LE(this._length[1], 60)\r\n  this._update()\r\n\r\n  // produce result\r\n  var buffer = Buffer.alloc ? Buffer.alloc(20) : new Buffer(20)\r\n  buffer.writeInt32LE(this._a, 0)\r\n  buffer.writeInt32LE(this._b, 4)\r\n  buffer.writeInt32LE(this._c, 8)\r\n  buffer.writeInt32LE(this._d, 12)\r\n  buffer.writeInt32LE(this._e, 16)\r\n  return buffer\r\n}\r\n\r\nfunction rotl (x, n) {\r\n  return (x << n) | (x >>> (32 - n))\r\n}\r\n\r\nfunction fn1 (a, b, c, d, e, m, k, s) {\r\n  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + e) | 0\r\n}\r\n\r\nfunction fn2 (a, b, c, d, e, m, k, s) {\r\n  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + e) | 0\r\n}\r\n\r\nfunction fn3 (a, b, c, d, e, m, k, s) {\r\n  return (rotl((a + ((b | (~c)) ^ d) + m + k) | 0, s) + e) | 0\r\n}\r\n\r\nfunction fn4 (a, b, c, d, e, m, k, s) {\r\n  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + e) | 0\r\n}\r\n\r\nfunction fn5 (a, b, c, d, e, m, k, s) {\r\n  return (rotl((a + (b ^ (c | (~d))) + m + k) | 0, s) + e) | 0\r\n}\r\n\r\nmodule.exports = RIPEMD160\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmlwZW1kMTYwL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1osYUFBYSw0RUFBd0I7QUFDckMsZUFBZSxtQkFBTyxDQUFDLDZEQUFVO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyxvREFBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNLE9BQU87QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JpcGVtZDE2MC9pbmRleC5qcz8xZDk4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xyXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyXHJcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcclxudmFyIEhhc2hCYXNlID0gcmVxdWlyZSgnaGFzaC1iYXNlJylcclxuXHJcbnZhciBBUlJBWTE2ID0gbmV3IEFycmF5KDE2KVxyXG5cclxudmFyIHpsID0gW1xyXG4gIDAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsXHJcbiAgNywgNCwgMTMsIDEsIDEwLCA2LCAxNSwgMywgMTIsIDAsIDksIDUsIDIsIDE0LCAxMSwgOCxcclxuICAzLCAxMCwgMTQsIDQsIDksIDE1LCA4LCAxLCAyLCA3LCAwLCA2LCAxMywgMTEsIDUsIDEyLFxyXG4gIDEsIDksIDExLCAxMCwgMCwgOCwgMTIsIDQsIDEzLCAzLCA3LCAxNSwgMTQsIDUsIDYsIDIsXHJcbiAgNCwgMCwgNSwgOSwgNywgMTIsIDIsIDEwLCAxNCwgMSwgMywgOCwgMTEsIDYsIDE1LCAxM1xyXG5dXHJcblxyXG52YXIgenIgPSBbXHJcbiAgNSwgMTQsIDcsIDAsIDksIDIsIDExLCA0LCAxMywgNiwgMTUsIDgsIDEsIDEwLCAzLCAxMixcclxuICA2LCAxMSwgMywgNywgMCwgMTMsIDUsIDEwLCAxNCwgMTUsIDgsIDEyLCA0LCA5LCAxLCAyLFxyXG4gIDE1LCA1LCAxLCAzLCA3LCAxNCwgNiwgOSwgMTEsIDgsIDEyLCAyLCAxMCwgMCwgNCwgMTMsXHJcbiAgOCwgNiwgNCwgMSwgMywgMTEsIDE1LCAwLCA1LCAxMiwgMiwgMTMsIDksIDcsIDEwLCAxNCxcclxuICAxMiwgMTUsIDEwLCA0LCAxLCA1LCA4LCA3LCA2LCAyLCAxMywgMTQsIDAsIDMsIDksIDExXHJcbl1cclxuXHJcbnZhciBzbCA9IFtcclxuICAxMSwgMTQsIDE1LCAxMiwgNSwgOCwgNywgOSwgMTEsIDEzLCAxNCwgMTUsIDYsIDcsIDksIDgsXHJcbiAgNywgNiwgOCwgMTMsIDExLCA5LCA3LCAxNSwgNywgMTIsIDE1LCA5LCAxMSwgNywgMTMsIDEyLFxyXG4gIDExLCAxMywgNiwgNywgMTQsIDksIDEzLCAxNSwgMTQsIDgsIDEzLCA2LCA1LCAxMiwgNywgNSxcclxuICAxMSwgMTIsIDE0LCAxNSwgMTQsIDE1LCA5LCA4LCA5LCAxNCwgNSwgNiwgOCwgNiwgNSwgMTIsXHJcbiAgOSwgMTUsIDUsIDExLCA2LCA4LCAxMywgMTIsIDUsIDEyLCAxMywgMTQsIDExLCA4LCA1LCA2XHJcbl1cclxuXHJcbnZhciBzciA9IFtcclxuICA4LCA5LCA5LCAxMSwgMTMsIDE1LCAxNSwgNSwgNywgNywgOCwgMTEsIDE0LCAxNCwgMTIsIDYsXHJcbiAgOSwgMTMsIDE1LCA3LCAxMiwgOCwgOSwgMTEsIDcsIDcsIDEyLCA3LCA2LCAxNSwgMTMsIDExLFxyXG4gIDksIDcsIDE1LCAxMSwgOCwgNiwgNiwgMTQsIDEyLCAxMywgNSwgMTQsIDEzLCAxMywgNywgNSxcclxuICAxNSwgNSwgOCwgMTEsIDE0LCAxNCwgNiwgMTQsIDYsIDksIDEyLCA5LCAxMiwgNSwgMTUsIDgsXHJcbiAgOCwgNSwgMTIsIDksIDEyLCA1LCAxNCwgNiwgOCwgMTMsIDYsIDUsIDE1LCAxMywgMTEsIDExXHJcbl1cclxuXHJcbnZhciBobCA9IFsweDAwMDAwMDAwLCAweDVhODI3OTk5LCAweDZlZDllYmExLCAweDhmMWJiY2RjLCAweGE5NTNmZDRlXVxyXG52YXIgaHIgPSBbMHg1MGEyOGJlNiwgMHg1YzRkZDEyNCwgMHg2ZDcwM2VmMywgMHg3YTZkNzZlOSwgMHgwMDAwMDAwMF1cclxuXHJcbmZ1bmN0aW9uIFJJUEVNRDE2MCAoKSB7XHJcbiAgSGFzaEJhc2UuY2FsbCh0aGlzLCA2NClcclxuXHJcbiAgLy8gc3RhdGVcclxuICB0aGlzLl9hID0gMHg2NzQ1MjMwMVxyXG4gIHRoaXMuX2IgPSAweGVmY2RhYjg5XHJcbiAgdGhpcy5fYyA9IDB4OThiYWRjZmVcclxuICB0aGlzLl9kID0gMHgxMDMyNTQ3NlxyXG4gIHRoaXMuX2UgPSAweGMzZDJlMWYwXHJcbn1cclxuXHJcbmluaGVyaXRzKFJJUEVNRDE2MCwgSGFzaEJhc2UpXHJcblxyXG5SSVBFTUQxNjAucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIHdvcmRzID0gQVJSQVkxNlxyXG4gIGZvciAodmFyIGogPSAwOyBqIDwgMTY7ICsraikgd29yZHNbal0gPSB0aGlzLl9ibG9jay5yZWFkSW50MzJMRShqICogNClcclxuXHJcbiAgdmFyIGFsID0gdGhpcy5fYSB8IDBcclxuICB2YXIgYmwgPSB0aGlzLl9iIHwgMFxyXG4gIHZhciBjbCA9IHRoaXMuX2MgfCAwXHJcbiAgdmFyIGRsID0gdGhpcy5fZCB8IDBcclxuICB2YXIgZWwgPSB0aGlzLl9lIHwgMFxyXG5cclxuICB2YXIgYXIgPSB0aGlzLl9hIHwgMFxyXG4gIHZhciBiciA9IHRoaXMuX2IgfCAwXHJcbiAgdmFyIGNyID0gdGhpcy5fYyB8IDBcclxuICB2YXIgZHIgPSB0aGlzLl9kIHwgMFxyXG4gIHZhciBlciA9IHRoaXMuX2UgfCAwXHJcblxyXG4gIC8vIGNvbXB1dGF0aW9uXHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA4MDsgaSArPSAxKSB7XHJcbiAgICB2YXIgdGxcclxuICAgIHZhciB0clxyXG4gICAgaWYgKGkgPCAxNikge1xyXG4gICAgICB0bCA9IGZuMShhbCwgYmwsIGNsLCBkbCwgZWwsIHdvcmRzW3psW2ldXSwgaGxbMF0sIHNsW2ldKVxyXG4gICAgICB0ciA9IGZuNShhciwgYnIsIGNyLCBkciwgZXIsIHdvcmRzW3pyW2ldXSwgaHJbMF0sIHNyW2ldKVxyXG4gICAgfSBlbHNlIGlmIChpIDwgMzIpIHtcclxuICAgICAgdGwgPSBmbjIoYWwsIGJsLCBjbCwgZGwsIGVsLCB3b3Jkc1t6bFtpXV0sIGhsWzFdLCBzbFtpXSlcclxuICAgICAgdHIgPSBmbjQoYXIsIGJyLCBjciwgZHIsIGVyLCB3b3Jkc1t6cltpXV0sIGhyWzFdLCBzcltpXSlcclxuICAgIH0gZWxzZSBpZiAoaSA8IDQ4KSB7XHJcbiAgICAgIHRsID0gZm4zKGFsLCBibCwgY2wsIGRsLCBlbCwgd29yZHNbemxbaV1dLCBobFsyXSwgc2xbaV0pXHJcbiAgICAgIHRyID0gZm4zKGFyLCBiciwgY3IsIGRyLCBlciwgd29yZHNbenJbaV1dLCBoclsyXSwgc3JbaV0pXHJcbiAgICB9IGVsc2UgaWYgKGkgPCA2NCkge1xyXG4gICAgICB0bCA9IGZuNChhbCwgYmwsIGNsLCBkbCwgZWwsIHdvcmRzW3psW2ldXSwgaGxbM10sIHNsW2ldKVxyXG4gICAgICB0ciA9IGZuMihhciwgYnIsIGNyLCBkciwgZXIsIHdvcmRzW3pyW2ldXSwgaHJbM10sIHNyW2ldKVxyXG4gICAgfSBlbHNlIHsgLy8gaWYgKGk8ODApIHtcclxuICAgICAgdGwgPSBmbjUoYWwsIGJsLCBjbCwgZGwsIGVsLCB3b3Jkc1t6bFtpXV0sIGhsWzRdLCBzbFtpXSlcclxuICAgICAgdHIgPSBmbjEoYXIsIGJyLCBjciwgZHIsIGVyLCB3b3Jkc1t6cltpXV0sIGhyWzRdLCBzcltpXSlcclxuICAgIH1cclxuXHJcbiAgICBhbCA9IGVsXHJcbiAgICBlbCA9IGRsXHJcbiAgICBkbCA9IHJvdGwoY2wsIDEwKVxyXG4gICAgY2wgPSBibFxyXG4gICAgYmwgPSB0bFxyXG5cclxuICAgIGFyID0gZXJcclxuICAgIGVyID0gZHJcclxuICAgIGRyID0gcm90bChjciwgMTApXHJcbiAgICBjciA9IGJyXHJcbiAgICBiciA9IHRyXHJcbiAgfVxyXG5cclxuICAvLyB1cGRhdGUgc3RhdGVcclxuICB2YXIgdCA9ICh0aGlzLl9iICsgY2wgKyBkcikgfCAwXHJcbiAgdGhpcy5fYiA9ICh0aGlzLl9jICsgZGwgKyBlcikgfCAwXHJcbiAgdGhpcy5fYyA9ICh0aGlzLl9kICsgZWwgKyBhcikgfCAwXHJcbiAgdGhpcy5fZCA9ICh0aGlzLl9lICsgYWwgKyBicikgfCAwXHJcbiAgdGhpcy5fZSA9ICh0aGlzLl9hICsgYmwgKyBjcikgfCAwXHJcbiAgdGhpcy5fYSA9IHRcclxufVxyXG5cclxuUklQRU1EMTYwLnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gKCkge1xyXG4gIC8vIGNyZWF0ZSBwYWRkaW5nIGFuZCBoYW5kbGUgYmxvY2tzXHJcbiAgdGhpcy5fYmxvY2tbdGhpcy5fYmxvY2tPZmZzZXQrK10gPSAweDgwXHJcbiAgaWYgKHRoaXMuX2Jsb2NrT2Zmc2V0ID4gNTYpIHtcclxuICAgIHRoaXMuX2Jsb2NrLmZpbGwoMCwgdGhpcy5fYmxvY2tPZmZzZXQsIDY0KVxyXG4gICAgdGhpcy5fdXBkYXRlKClcclxuICAgIHRoaXMuX2Jsb2NrT2Zmc2V0ID0gMFxyXG4gIH1cclxuXHJcbiAgdGhpcy5fYmxvY2suZmlsbCgwLCB0aGlzLl9ibG9ja09mZnNldCwgNTYpXHJcbiAgdGhpcy5fYmxvY2sud3JpdGVVSW50MzJMRSh0aGlzLl9sZW5ndGhbMF0sIDU2KVxyXG4gIHRoaXMuX2Jsb2NrLndyaXRlVUludDMyTEUodGhpcy5fbGVuZ3RoWzFdLCA2MClcclxuICB0aGlzLl91cGRhdGUoKVxyXG5cclxuICAvLyBwcm9kdWNlIHJlc3VsdFxyXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MgPyBCdWZmZXIuYWxsb2MoMjApIDogbmV3IEJ1ZmZlcigyMClcclxuICBidWZmZXIud3JpdGVJbnQzMkxFKHRoaXMuX2EsIDApXHJcbiAgYnVmZmVyLndyaXRlSW50MzJMRSh0aGlzLl9iLCA0KVxyXG4gIGJ1ZmZlci53cml0ZUludDMyTEUodGhpcy5fYywgOClcclxuICBidWZmZXIud3JpdGVJbnQzMkxFKHRoaXMuX2QsIDEyKVxyXG4gIGJ1ZmZlci53cml0ZUludDMyTEUodGhpcy5fZSwgMTYpXHJcbiAgcmV0dXJuIGJ1ZmZlclxyXG59XHJcblxyXG5mdW5jdGlvbiByb3RsICh4LCBuKSB7XHJcbiAgcmV0dXJuICh4IDw8IG4pIHwgKHggPj4+ICgzMiAtIG4pKVxyXG59XHJcblxyXG5mdW5jdGlvbiBmbjEgKGEsIGIsIGMsIGQsIGUsIG0sIGssIHMpIHtcclxuICByZXR1cm4gKHJvdGwoKGEgKyAoYiBeIGMgXiBkKSArIG0gKyBrKSB8IDAsIHMpICsgZSkgfCAwXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZuMiAoYSwgYiwgYywgZCwgZSwgbSwgaywgcykge1xyXG4gIHJldHVybiAocm90bCgoYSArICgoYiAmIGMpIHwgKCh+YikgJiBkKSkgKyBtICsgaykgfCAwLCBzKSArIGUpIHwgMFxyXG59XHJcblxyXG5mdW5jdGlvbiBmbjMgKGEsIGIsIGMsIGQsIGUsIG0sIGssIHMpIHtcclxuICByZXR1cm4gKHJvdGwoKGEgKyAoKGIgfCAofmMpKSBeIGQpICsgbSArIGspIHwgMCwgcykgKyBlKSB8IDBcclxufVxyXG5cclxuZnVuY3Rpb24gZm40IChhLCBiLCBjLCBkLCBlLCBtLCBrLCBzKSB7XHJcbiAgcmV0dXJuIChyb3RsKChhICsgKChiICYgZCkgfCAoYyAmICh+ZCkpKSArIG0gKyBrKSB8IDAsIHMpICsgZSkgfCAwXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZuNSAoYSwgYiwgYywgZCwgZSwgbSwgaywgcykge1xyXG4gIHJldHVybiAocm90bCgoYSArIChiIF4gKGMgfCAofmQpKSkgKyBtICsgaykgfCAwLCBzKSArIGUpIHwgMFxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJJUEVNRDE2MFxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ripemd160/index.js\n");

/***/ }),

/***/ "./node_modules/rlp/dist.browser/index.js":
/*!************************************************!*\
  !*** ./node_modules/rlp/dist.browser/index.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.getLength = exports.decode = exports.encode = void 0;\r\nvar bn_js_1 = __importDefault(__webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\"));\r\n/**\r\n * RLP Encoding based on: https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-RLP\r\n * This function takes in a data, convert it to buffer if not, and a length for recursion\r\n * @param input - will be converted to buffer\r\n * @returns returns buffer of encoded data\r\n **/\r\nfunction encode(input) {\r\n    if (Array.isArray(input)) {\r\n        var output = [];\r\n        for (var i = 0; i < input.length; i++) {\r\n            output.push(encode(input[i]));\r\n        }\r\n        var buf = Buffer.concat(output);\r\n        return Buffer.concat([encodeLength(buf.length, 192), buf]);\r\n    }\r\n    else {\r\n        var inputBuf = toBuffer(input);\r\n        return inputBuf.length === 1 && inputBuf[0] < 128\r\n            ? inputBuf\r\n            : Buffer.concat([encodeLength(inputBuf.length, 128), inputBuf]);\r\n    }\r\n}\r\nexports.encode = encode;\r\n/**\r\n * Parse integers. Check if there is no leading zeros\r\n * @param v The value to parse\r\n * @param base The base to parse the integer into\r\n */\r\nfunction safeParseInt(v, base) {\r\n    if (v[0] === '0' && v[1] === '0') {\r\n        throw new Error('invalid RLP: extra zeros');\r\n    }\r\n    return parseInt(v, base);\r\n}\r\nfunction encodeLength(len, offset) {\r\n    if (len < 56) {\r\n        return Buffer.from([len + offset]);\r\n    }\r\n    else {\r\n        var hexLength = intToHex(len);\r\n        var lLength = hexLength.length / 2;\r\n        var firstByte = intToHex(offset + 55 + lLength);\r\n        return Buffer.from(firstByte + hexLength, 'hex');\r\n    }\r\n}\r\nfunction decode(input, stream) {\r\n    if (stream === void 0) { stream = false; }\r\n    if (!input || input.length === 0) {\r\n        return Buffer.from([]);\r\n    }\r\n    var inputBuffer = toBuffer(input);\r\n    var decoded = _decode(inputBuffer);\r\n    if (stream) {\r\n        return decoded;\r\n    }\r\n    if (decoded.remainder.length !== 0) {\r\n        throw new Error('invalid remainder');\r\n    }\r\n    return decoded.data;\r\n}\r\nexports.decode = decode;\r\n/**\r\n * Get the length of the RLP input\r\n * @param input\r\n * @returns The length of the input or an empty Buffer if no input\r\n */\r\nfunction getLength(input) {\r\n    if (!input || input.length === 0) {\r\n        return Buffer.from([]);\r\n    }\r\n    var inputBuffer = toBuffer(input);\r\n    var firstByte = inputBuffer[0];\r\n    if (firstByte <= 0x7f) {\r\n        return inputBuffer.length;\r\n    }\r\n    else if (firstByte <= 0xb7) {\r\n        return firstByte - 0x7f;\r\n    }\r\n    else if (firstByte <= 0xbf) {\r\n        return firstByte - 0xb6;\r\n    }\r\n    else if (firstByte <= 0xf7) {\r\n        // a list between  0-55 bytes long\r\n        return firstByte - 0xbf;\r\n    }\r\n    else {\r\n        // a list  over 55 bytes long\r\n        var llength = firstByte - 0xf6;\r\n        var length_1 = safeParseInt(inputBuffer.slice(1, llength).toString('hex'), 16);\r\n        return llength + length_1;\r\n    }\r\n}\r\nexports.getLength = getLength;\r\n/** Decode an input with RLP */\r\nfunction _decode(input) {\r\n    var length, llength, data, innerRemainder, d;\r\n    var decoded = [];\r\n    var firstByte = input[0];\r\n    if (firstByte <= 0x7f) {\r\n        // a single byte whose value is in the [0x00, 0x7f] range, that byte is its own RLP encoding.\r\n        return {\r\n            data: input.slice(0, 1),\r\n            remainder: input.slice(1),\r\n        };\r\n    }\r\n    else if (firstByte <= 0xb7) {\r\n        // string is 0-55 bytes long. A single byte with value 0x80 plus the length of the string followed by the string\r\n        // The range of the first byte is [0x80, 0xb7]\r\n        length = firstByte - 0x7f;\r\n        // set 0x80 null to 0\r\n        if (firstByte === 0x80) {\r\n            data = Buffer.from([]);\r\n        }\r\n        else {\r\n            data = input.slice(1, length);\r\n        }\r\n        if (length === 2 && data[0] < 0x80) {\r\n            throw new Error('invalid rlp encoding: byte must be less 0x80');\r\n        }\r\n        return {\r\n            data: data,\r\n            remainder: input.slice(length),\r\n        };\r\n    }\r\n    else if (firstByte <= 0xbf) {\r\n        // string is greater than 55 bytes long. A single byte with the value (0xb7 plus the length of the length),\r\n        // followed by the length, followed by the string\r\n        llength = firstByte - 0xb6;\r\n        if (input.length - 1 < llength) {\r\n            throw new Error('invalid RLP: not enough bytes for string length');\r\n        }\r\n        length = safeParseInt(input.slice(1, llength).toString('hex'), 16);\r\n        if (length <= 55) {\r\n            throw new Error('invalid RLP: expected string length to be greater than 55');\r\n        }\r\n        data = input.slice(llength, length + llength);\r\n        if (data.length < length) {\r\n            throw new Error('invalid RLP: not enough bytes for string');\r\n        }\r\n        return {\r\n            data: data,\r\n            remainder: input.slice(length + llength),\r\n        };\r\n    }\r\n    else if (firstByte <= 0xf7) {\r\n        // a list between  0-55 bytes long\r\n        length = firstByte - 0xbf;\r\n        innerRemainder = input.slice(1, length);\r\n        while (innerRemainder.length) {\r\n            d = _decode(innerRemainder);\r\n            decoded.push(d.data);\r\n            innerRemainder = d.remainder;\r\n        }\r\n        return {\r\n            data: decoded,\r\n            remainder: input.slice(length),\r\n        };\r\n    }\r\n    else {\r\n        // a list  over 55 bytes long\r\n        llength = firstByte - 0xf6;\r\n        length = safeParseInt(input.slice(1, llength).toString('hex'), 16);\r\n        var totalLength = llength + length;\r\n        if (totalLength > input.length) {\r\n            throw new Error('invalid rlp: total length is larger than the data');\r\n        }\r\n        innerRemainder = input.slice(llength, totalLength);\r\n        if (innerRemainder.length === 0) {\r\n            throw new Error('invalid rlp, List has a invalid length');\r\n        }\r\n        while (innerRemainder.length) {\r\n            d = _decode(innerRemainder);\r\n            decoded.push(d.data);\r\n            innerRemainder = d.remainder;\r\n        }\r\n        return {\r\n            data: decoded,\r\n            remainder: input.slice(totalLength),\r\n        };\r\n    }\r\n}\r\n/** Check if a string is prefixed by 0x */\r\nfunction isHexPrefixed(str) {\r\n    return str.slice(0, 2) === '0x';\r\n}\r\n/** Removes 0x from a given String */\r\nfunction stripHexPrefix(str) {\r\n    if (typeof str !== 'string') {\r\n        return str;\r\n    }\r\n    return isHexPrefixed(str) ? str.slice(2) : str;\r\n}\r\n/** Transform an integer into its hexadecimal value */\r\nfunction intToHex(integer) {\r\n    if (integer < 0) {\r\n        throw new Error('Invalid integer as argument, must be unsigned!');\r\n    }\r\n    var hex = integer.toString(16);\r\n    return hex.length % 2 ? \"0\" + hex : hex;\r\n}\r\n/** Pad a string to be even */\r\nfunction padToEven(a) {\r\n    return a.length % 2 ? \"0\" + a : a;\r\n}\r\n/** Transform an integer into a Buffer */\r\nfunction intToBuffer(integer) {\r\n    var hex = intToHex(integer);\r\n    return Buffer.from(hex, 'hex');\r\n}\r\n/** Transform anything into a Buffer */\r\nfunction toBuffer(v) {\r\n    if (!Buffer.isBuffer(v)) {\r\n        if (typeof v === 'string') {\r\n            if (isHexPrefixed(v)) {\r\n                return Buffer.from(padToEven(stripHexPrefix(v)), 'hex');\r\n            }\r\n            else {\r\n                return Buffer.from(v);\r\n            }\r\n        }\r\n        else if (typeof v === 'number' || typeof v === 'bigint') {\r\n            if (!v) {\r\n                return Buffer.from([]);\r\n            }\r\n            else {\r\n                return intToBuffer(v);\r\n            }\r\n        }\r\n        else if (v === null || v === undefined) {\r\n            return Buffer.from([]);\r\n        }\r\n        else if (v instanceof Uint8Array) {\r\n            return Buffer.from(v);\r\n        }\r\n        else if (bn_js_1.default.isBN(v)) {\r\n            // converts a BN to a Buffer\r\n            return Buffer.from(v.toArray());\r\n        }\r\n        else {\r\n            throw new Error('invalid type');\r\n        }\r\n    }\r\n    return v;\r\n}\r\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmxwL2Rpc3QuYnJvd3Nlci9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUIsR0FBRyxjQUFjLEdBQUcsY0FBYztBQUNuRCw4QkFBOEIsbUJBQU8sQ0FBQyw2Q0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQSxrQkFBa0IsTUFBTTtBQUN4QixlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsTUFBTTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFNBQVMsTUFBTTtBQUNmO0FBQ0E7QUFDQSx1QkFBdUIsTUFBTTtBQUM3QjtBQUNBO0FBQ0EsdUJBQXVCLE1BQU07QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsTUFBTTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsTUFBTTtBQUN6QjtBQUNBO0FBQ0EsbUJBQW1CLE1BQU07QUFDekI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE1BQU07QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmxwL2Rpc3QuYnJvd3Nlci9pbmRleC5qcz84ZDVjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuZ2V0TGVuZ3RoID0gZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLmVuY29kZSA9IHZvaWQgMDtcclxudmFyIGJuX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImJuLmpzXCIpKTtcclxuLyoqXHJcbiAqIFJMUCBFbmNvZGluZyBiYXNlZCBvbjogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dpa2kvd2lraS8lNUJFbmdsaXNoJTVELVJMUFxyXG4gKiBUaGlzIGZ1bmN0aW9uIHRha2VzIGluIGEgZGF0YSwgY29udmVydCBpdCB0byBidWZmZXIgaWYgbm90LCBhbmQgYSBsZW5ndGggZm9yIHJlY3Vyc2lvblxyXG4gKiBAcGFyYW0gaW5wdXQgLSB3aWxsIGJlIGNvbnZlcnRlZCB0byBidWZmZXJcclxuICogQHJldHVybnMgcmV0dXJucyBidWZmZXIgb2YgZW5jb2RlZCBkYXRhXHJcbiAqKi9cclxuZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcclxuICAgICAgICB2YXIgb3V0cHV0ID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBvdXRwdXQucHVzaChlbmNvZGUoaW5wdXRbaV0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGJ1ZiA9IEJ1ZmZlci5jb25jYXQob3V0cHV0KTtcclxuICAgICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbZW5jb2RlTGVuZ3RoKGJ1Zi5sZW5ndGgsIDE5MiksIGJ1Zl0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmFyIGlucHV0QnVmID0gdG9CdWZmZXIoaW5wdXQpO1xyXG4gICAgICAgIHJldHVybiBpbnB1dEJ1Zi5sZW5ndGggPT09IDEgJiYgaW5wdXRCdWZbMF0gPCAxMjhcclxuICAgICAgICAgICAgPyBpbnB1dEJ1ZlxyXG4gICAgICAgICAgICA6IEJ1ZmZlci5jb25jYXQoW2VuY29kZUxlbmd0aChpbnB1dEJ1Zi5sZW5ndGgsIDEyOCksIGlucHV0QnVmXSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XHJcbi8qKlxyXG4gKiBQYXJzZSBpbnRlZ2Vycy4gQ2hlY2sgaWYgdGhlcmUgaXMgbm8gbGVhZGluZyB6ZXJvc1xyXG4gKiBAcGFyYW0gdiBUaGUgdmFsdWUgdG8gcGFyc2VcclxuICogQHBhcmFtIGJhc2UgVGhlIGJhc2UgdG8gcGFyc2UgdGhlIGludGVnZXIgaW50b1xyXG4gKi9cclxuZnVuY3Rpb24gc2FmZVBhcnNlSW50KHYsIGJhc2UpIHtcclxuICAgIGlmICh2WzBdID09PSAnMCcgJiYgdlsxXSA9PT0gJzAnKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFJMUDogZXh0cmEgemVyb3MnKTtcclxuICAgIH1cclxuICAgIHJldHVybiBwYXJzZUludCh2LCBiYXNlKTtcclxufVxyXG5mdW5jdGlvbiBlbmNvZGVMZW5ndGgobGVuLCBvZmZzZXQpIHtcclxuICAgIGlmIChsZW4gPCA1Nikge1xyXG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShbbGVuICsgb2Zmc2V0XSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2YXIgaGV4TGVuZ3RoID0gaW50VG9IZXgobGVuKTtcclxuICAgICAgICB2YXIgbExlbmd0aCA9IGhleExlbmd0aC5sZW5ndGggLyAyO1xyXG4gICAgICAgIHZhciBmaXJzdEJ5dGUgPSBpbnRUb0hleChvZmZzZXQgKyA1NSArIGxMZW5ndGgpO1xyXG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShmaXJzdEJ5dGUgKyBoZXhMZW5ndGgsICdoZXgnKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBkZWNvZGUoaW5wdXQsIHN0cmVhbSkge1xyXG4gICAgaWYgKHN0cmVhbSA9PT0gdm9pZCAwKSB7IHN0cmVhbSA9IGZhbHNlOyB9XHJcbiAgICBpZiAoIWlucHV0IHx8IGlucHV0Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShbXSk7XHJcbiAgICB9XHJcbiAgICB2YXIgaW5wdXRCdWZmZXIgPSB0b0J1ZmZlcihpbnB1dCk7XHJcbiAgICB2YXIgZGVjb2RlZCA9IF9kZWNvZGUoaW5wdXRCdWZmZXIpO1xyXG4gICAgaWYgKHN0cmVhbSkge1xyXG4gICAgICAgIHJldHVybiBkZWNvZGVkO1xyXG4gICAgfVxyXG4gICAgaWYgKGRlY29kZWQucmVtYWluZGVyLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCByZW1haW5kZXInKTtcclxuICAgIH1cclxuICAgIHJldHVybiBkZWNvZGVkLmRhdGE7XHJcbn1cclxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XHJcbi8qKlxyXG4gKiBHZXQgdGhlIGxlbmd0aCBvZiB0aGUgUkxQIGlucHV0XHJcbiAqIEBwYXJhbSBpbnB1dFxyXG4gKiBAcmV0dXJucyBUaGUgbGVuZ3RoIG9mIHRoZSBpbnB1dCBvciBhbiBlbXB0eSBCdWZmZXIgaWYgbm8gaW5wdXRcclxuICovXHJcbmZ1bmN0aW9uIGdldExlbmd0aChpbnB1dCkge1xyXG4gICAgaWYgKCFpbnB1dCB8fCBpbnB1dC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oW10pO1xyXG4gICAgfVxyXG4gICAgdmFyIGlucHV0QnVmZmVyID0gdG9CdWZmZXIoaW5wdXQpO1xyXG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGlucHV0QnVmZmVyWzBdO1xyXG4gICAgaWYgKGZpcnN0Qnl0ZSA8PSAweDdmKSB7XHJcbiAgICAgICAgcmV0dXJuIGlucHV0QnVmZmVyLmxlbmd0aDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGZpcnN0Qnl0ZSA8PSAweGI3KSB7XHJcbiAgICAgICAgcmV0dXJuIGZpcnN0Qnl0ZSAtIDB4N2Y7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChmaXJzdEJ5dGUgPD0gMHhiZikge1xyXG4gICAgICAgIHJldHVybiBmaXJzdEJ5dGUgLSAweGI2O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZmlyc3RCeXRlIDw9IDB4ZjcpIHtcclxuICAgICAgICAvLyBhIGxpc3QgYmV0d2VlbiAgMC01NSBieXRlcyBsb25nXHJcbiAgICAgICAgcmV0dXJuIGZpcnN0Qnl0ZSAtIDB4YmY7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBhIGxpc3QgIG92ZXIgNTUgYnl0ZXMgbG9uZ1xyXG4gICAgICAgIHZhciBsbGVuZ3RoID0gZmlyc3RCeXRlIC0gMHhmNjtcclxuICAgICAgICB2YXIgbGVuZ3RoXzEgPSBzYWZlUGFyc2VJbnQoaW5wdXRCdWZmZXIuc2xpY2UoMSwgbGxlbmd0aCkudG9TdHJpbmcoJ2hleCcpLCAxNik7XHJcbiAgICAgICAgcmV0dXJuIGxsZW5ndGggKyBsZW5ndGhfMTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmdldExlbmd0aCA9IGdldExlbmd0aDtcclxuLyoqIERlY29kZSBhbiBpbnB1dCB3aXRoIFJMUCAqL1xyXG5mdW5jdGlvbiBfZGVjb2RlKGlucHV0KSB7XHJcbiAgICB2YXIgbGVuZ3RoLCBsbGVuZ3RoLCBkYXRhLCBpbm5lclJlbWFpbmRlciwgZDtcclxuICAgIHZhciBkZWNvZGVkID0gW107XHJcbiAgICB2YXIgZmlyc3RCeXRlID0gaW5wdXRbMF07XHJcbiAgICBpZiAoZmlyc3RCeXRlIDw9IDB4N2YpIHtcclxuICAgICAgICAvLyBhIHNpbmdsZSBieXRlIHdob3NlIHZhbHVlIGlzIGluIHRoZSBbMHgwMCwgMHg3Zl0gcmFuZ2UsIHRoYXQgYnl0ZSBpcyBpdHMgb3duIFJMUCBlbmNvZGluZy5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkYXRhOiBpbnB1dC5zbGljZSgwLCAxKSxcclxuICAgICAgICAgICAgcmVtYWluZGVyOiBpbnB1dC5zbGljZSgxKSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZmlyc3RCeXRlIDw9IDB4YjcpIHtcclxuICAgICAgICAvLyBzdHJpbmcgaXMgMC01NSBieXRlcyBsb25nLiBBIHNpbmdsZSBieXRlIHdpdGggdmFsdWUgMHg4MCBwbHVzIHRoZSBsZW5ndGggb2YgdGhlIHN0cmluZyBmb2xsb3dlZCBieSB0aGUgc3RyaW5nXHJcbiAgICAgICAgLy8gVGhlIHJhbmdlIG9mIHRoZSBmaXJzdCBieXRlIGlzIFsweDgwLCAweGI3XVxyXG4gICAgICAgIGxlbmd0aCA9IGZpcnN0Qnl0ZSAtIDB4N2Y7XHJcbiAgICAgICAgLy8gc2V0IDB4ODAgbnVsbCB0byAwXHJcbiAgICAgICAgaWYgKGZpcnN0Qnl0ZSA9PT0gMHg4MCkge1xyXG4gICAgICAgICAgICBkYXRhID0gQnVmZmVyLmZyb20oW10pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZGF0YSA9IGlucHV0LnNsaWNlKDEsIGxlbmd0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsZW5ndGggPT09IDIgJiYgZGF0YVswXSA8IDB4ODApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHJscCBlbmNvZGluZzogYnl0ZSBtdXN0IGJlIGxlc3MgMHg4MCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxyXG4gICAgICAgICAgICByZW1haW5kZXI6IGlucHV0LnNsaWNlKGxlbmd0aCksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGZpcnN0Qnl0ZSA8PSAweGJmKSB7XHJcbiAgICAgICAgLy8gc3RyaW5nIGlzIGdyZWF0ZXIgdGhhbiA1NSBieXRlcyBsb25nLiBBIHNpbmdsZSBieXRlIHdpdGggdGhlIHZhbHVlICgweGI3IHBsdXMgdGhlIGxlbmd0aCBvZiB0aGUgbGVuZ3RoKSxcclxuICAgICAgICAvLyBmb2xsb3dlZCBieSB0aGUgbGVuZ3RoLCBmb2xsb3dlZCBieSB0aGUgc3RyaW5nXHJcbiAgICAgICAgbGxlbmd0aCA9IGZpcnN0Qnl0ZSAtIDB4YjY7XHJcbiAgICAgICAgaWYgKGlucHV0Lmxlbmd0aCAtIDEgPCBsbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBSTFA6IG5vdCBlbm91Z2ggYnl0ZXMgZm9yIHN0cmluZyBsZW5ndGgnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGVuZ3RoID0gc2FmZVBhcnNlSW50KGlucHV0LnNsaWNlKDEsIGxsZW5ndGgpLnRvU3RyaW5nKCdoZXgnKSwgMTYpO1xyXG4gICAgICAgIGlmIChsZW5ndGggPD0gNTUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFJMUDogZXhwZWN0ZWQgc3RyaW5nIGxlbmd0aCB0byBiZSBncmVhdGVyIHRoYW4gNTUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGF0YSA9IGlucHV0LnNsaWNlKGxsZW5ndGgsIGxlbmd0aCArIGxsZW5ndGgpO1xyXG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA8IGxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgUkxQOiBub3QgZW5vdWdoIGJ5dGVzIGZvciBzdHJpbmcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZGF0YTogZGF0YSxcclxuICAgICAgICAgICAgcmVtYWluZGVyOiBpbnB1dC5zbGljZShsZW5ndGggKyBsbGVuZ3RoKSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZmlyc3RCeXRlIDw9IDB4ZjcpIHtcclxuICAgICAgICAvLyBhIGxpc3QgYmV0d2VlbiAgMC01NSBieXRlcyBsb25nXHJcbiAgICAgICAgbGVuZ3RoID0gZmlyc3RCeXRlIC0gMHhiZjtcclxuICAgICAgICBpbm5lclJlbWFpbmRlciA9IGlucHV0LnNsaWNlKDEsIGxlbmd0aCk7XHJcbiAgICAgICAgd2hpbGUgKGlubmVyUmVtYWluZGVyLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBkID0gX2RlY29kZShpbm5lclJlbWFpbmRlcik7XHJcbiAgICAgICAgICAgIGRlY29kZWQucHVzaChkLmRhdGEpO1xyXG4gICAgICAgICAgICBpbm5lclJlbWFpbmRlciA9IGQucmVtYWluZGVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkYXRhOiBkZWNvZGVkLFxyXG4gICAgICAgICAgICByZW1haW5kZXI6IGlucHV0LnNsaWNlKGxlbmd0aCksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIGEgbGlzdCAgb3ZlciA1NSBieXRlcyBsb25nXHJcbiAgICAgICAgbGxlbmd0aCA9IGZpcnN0Qnl0ZSAtIDB4ZjY7XHJcbiAgICAgICAgbGVuZ3RoID0gc2FmZVBhcnNlSW50KGlucHV0LnNsaWNlKDEsIGxsZW5ndGgpLnRvU3RyaW5nKCdoZXgnKSwgMTYpO1xyXG4gICAgICAgIHZhciB0b3RhbExlbmd0aCA9IGxsZW5ndGggKyBsZW5ndGg7XHJcbiAgICAgICAgaWYgKHRvdGFsTGVuZ3RoID4gaW5wdXQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBybHA6IHRvdGFsIGxlbmd0aCBpcyBsYXJnZXIgdGhhbiB0aGUgZGF0YScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbm5lclJlbWFpbmRlciA9IGlucHV0LnNsaWNlKGxsZW5ndGgsIHRvdGFsTGVuZ3RoKTtcclxuICAgICAgICBpZiAoaW5uZXJSZW1haW5kZXIubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBybHAsIExpc3QgaGFzIGEgaW52YWxpZCBsZW5ndGgnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKGlubmVyUmVtYWluZGVyLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBkID0gX2RlY29kZShpbm5lclJlbWFpbmRlcik7XHJcbiAgICAgICAgICAgIGRlY29kZWQucHVzaChkLmRhdGEpO1xyXG4gICAgICAgICAgICBpbm5lclJlbWFpbmRlciA9IGQucmVtYWluZGVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkYXRhOiBkZWNvZGVkLFxyXG4gICAgICAgICAgICByZW1haW5kZXI6IGlucHV0LnNsaWNlKHRvdGFsTGVuZ3RoKSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbi8qKiBDaGVjayBpZiBhIHN0cmluZyBpcyBwcmVmaXhlZCBieSAweCAqL1xyXG5mdW5jdGlvbiBpc0hleFByZWZpeGVkKHN0cikge1xyXG4gICAgcmV0dXJuIHN0ci5zbGljZSgwLCAyKSA9PT0gJzB4JztcclxufVxyXG4vKiogUmVtb3ZlcyAweCBmcm9tIGEgZ2l2ZW4gU3RyaW5nICovXHJcbmZ1bmN0aW9uIHN0cmlwSGV4UHJlZml4KHN0cikge1xyXG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgIH1cclxuICAgIHJldHVybiBpc0hleFByZWZpeGVkKHN0cikgPyBzdHIuc2xpY2UoMikgOiBzdHI7XHJcbn1cclxuLyoqIFRyYW5zZm9ybSBhbiBpbnRlZ2VyIGludG8gaXRzIGhleGFkZWNpbWFsIHZhbHVlICovXHJcbmZ1bmN0aW9uIGludFRvSGV4KGludGVnZXIpIHtcclxuICAgIGlmIChpbnRlZ2VyIDwgMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnRlZ2VyIGFzIGFyZ3VtZW50LCBtdXN0IGJlIHVuc2lnbmVkIScpO1xyXG4gICAgfVxyXG4gICAgdmFyIGhleCA9IGludGVnZXIudG9TdHJpbmcoMTYpO1xyXG4gICAgcmV0dXJuIGhleC5sZW5ndGggJSAyID8gXCIwXCIgKyBoZXggOiBoZXg7XHJcbn1cclxuLyoqIFBhZCBhIHN0cmluZyB0byBiZSBldmVuICovXHJcbmZ1bmN0aW9uIHBhZFRvRXZlbihhKSB7XHJcbiAgICByZXR1cm4gYS5sZW5ndGggJSAyID8gXCIwXCIgKyBhIDogYTtcclxufVxyXG4vKiogVHJhbnNmb3JtIGFuIGludGVnZXIgaW50byBhIEJ1ZmZlciAqL1xyXG5mdW5jdGlvbiBpbnRUb0J1ZmZlcihpbnRlZ2VyKSB7XHJcbiAgICB2YXIgaGV4ID0gaW50VG9IZXgoaW50ZWdlcik7XHJcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oaGV4LCAnaGV4Jyk7XHJcbn1cclxuLyoqIFRyYW5zZm9ybSBhbnl0aGluZyBpbnRvIGEgQnVmZmVyICovXHJcbmZ1bmN0aW9uIHRvQnVmZmVyKHYpIHtcclxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHYpKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBpZiAoaXNIZXhQcmVmaXhlZCh2KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHBhZFRvRXZlbihzdHJpcEhleFByZWZpeCh2KSksICdoZXgnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdiA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHYgPT09ICdiaWdpbnQnKSB7XHJcbiAgICAgICAgICAgIGlmICghdikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKFtdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRUb0J1ZmZlcih2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh2ID09PSBudWxsIHx8IHYgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oW10pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh2IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xyXG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGJuX2pzXzEuZGVmYXVsdC5pc0JOKHYpKSB7XHJcbiAgICAgICAgICAgIC8vIGNvbnZlcnRzIGEgQk4gdG8gYSBCdWZmZXJcclxuICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHYudG9BcnJheSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB0eXBlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHY7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/rlp/dist.browser/index.js\n");

/***/ }),

/***/ "./node_modules/sha.js/hash.js":
/*!*************************************!*\
  !*** ./node_modules/sha.js/hash.js ***!
  \*************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var Buffer = (__webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer)\r\n\r\n// prototype class for hash functions\r\nfunction Hash (blockSize, finalSize) {\r\n  this._block = Buffer.alloc(blockSize)\r\n  this._finalSize = finalSize\r\n  this._blockSize = blockSize\r\n  this._len = 0\r\n}\r\n\r\nHash.prototype.update = function (data, enc) {\r\n  if (typeof data === 'string') {\r\n    enc = enc || 'utf8'\r\n    data = Buffer.from(data, enc)\r\n  }\r\n\r\n  var block = this._block\r\n  var blockSize = this._blockSize\r\n  var length = data.length\r\n  var accum = this._len\r\n\r\n  for (var offset = 0; offset < length;) {\r\n    var assigned = accum % blockSize\r\n    var remainder = Math.min(length - offset, blockSize - assigned)\r\n\r\n    for (var i = 0; i < remainder; i++) {\r\n      block[assigned + i] = data[offset + i]\r\n    }\r\n\r\n    accum += remainder\r\n    offset += remainder\r\n\r\n    if ((accum % blockSize) === 0) {\r\n      this._update(block)\r\n    }\r\n  }\r\n\r\n  this._len += length\r\n  return this\r\n}\r\n\r\nHash.prototype.digest = function (enc) {\r\n  var rem = this._len % this._blockSize\r\n\r\n  this._block[rem] = 0x80\r\n\r\n  // zero (rem + 1) trailing bits, where (rem + 1) is the smallest\r\n  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize\r\n  this._block.fill(0, rem + 1)\r\n\r\n  if (rem >= this._finalSize) {\r\n    this._update(this._block)\r\n    this._block.fill(0)\r\n  }\r\n\r\n  var bits = this._len * 8\r\n\r\n  // uint32\r\n  if (bits <= 0xffffffff) {\r\n    this._block.writeUInt32BE(bits, this._blockSize - 4)\r\n\r\n  // uint64\r\n  } else {\r\n    var lowBits = (bits & 0xffffffff) >>> 0\r\n    var highBits = (bits - lowBits) / 0x100000000\r\n\r\n    this._block.writeUInt32BE(highBits, this._blockSize - 8)\r\n    this._block.writeUInt32BE(lowBits, this._blockSize - 4)\r\n  }\r\n\r\n  this._update(this._block)\r\n  var hash = this._hash()\r\n\r\n  return enc ? hash.toString(enc) : hash\r\n}\r\n\r\nHash.prototype._update = function () {\r\n  throw new Error('_update must be implemented by subclass')\r\n}\r\n\r\nmodule.exports = Hash\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2hhLmpzL2hhc2guanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsYUFBYSxzRkFBNkI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvc2hhLmpzL2hhc2guanM/NDU0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcclxuXHJcbi8vIHByb3RvdHlwZSBjbGFzcyBmb3IgaGFzaCBmdW5jdGlvbnNcclxuZnVuY3Rpb24gSGFzaCAoYmxvY2tTaXplLCBmaW5hbFNpemUpIHtcclxuICB0aGlzLl9ibG9jayA9IEJ1ZmZlci5hbGxvYyhibG9ja1NpemUpXHJcbiAgdGhpcy5fZmluYWxTaXplID0gZmluYWxTaXplXHJcbiAgdGhpcy5fYmxvY2tTaXplID0gYmxvY2tTaXplXHJcbiAgdGhpcy5fbGVuID0gMFxyXG59XHJcblxyXG5IYXNoLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSwgZW5jKSB7XHJcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xyXG4gICAgZW5jID0gZW5jIHx8ICd1dGY4J1xyXG4gICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEsIGVuYylcclxuICB9XHJcblxyXG4gIHZhciBibG9jayA9IHRoaXMuX2Jsb2NrXHJcbiAgdmFyIGJsb2NrU2l6ZSA9IHRoaXMuX2Jsb2NrU2l6ZVxyXG4gIHZhciBsZW5ndGggPSBkYXRhLmxlbmd0aFxyXG4gIHZhciBhY2N1bSA9IHRoaXMuX2xlblxyXG5cclxuICBmb3IgKHZhciBvZmZzZXQgPSAwOyBvZmZzZXQgPCBsZW5ndGg7KSB7XHJcbiAgICB2YXIgYXNzaWduZWQgPSBhY2N1bSAlIGJsb2NrU2l6ZVxyXG4gICAgdmFyIHJlbWFpbmRlciA9IE1hdGgubWluKGxlbmd0aCAtIG9mZnNldCwgYmxvY2tTaXplIC0gYXNzaWduZWQpXHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZW1haW5kZXI7IGkrKykge1xyXG4gICAgICBibG9ja1thc3NpZ25lZCArIGldID0gZGF0YVtvZmZzZXQgKyBpXVxyXG4gICAgfVxyXG5cclxuICAgIGFjY3VtICs9IHJlbWFpbmRlclxyXG4gICAgb2Zmc2V0ICs9IHJlbWFpbmRlclxyXG5cclxuICAgIGlmICgoYWNjdW0gJSBibG9ja1NpemUpID09PSAwKSB7XHJcbiAgICAgIHRoaXMuX3VwZGF0ZShibG9jaylcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHRoaXMuX2xlbiArPSBsZW5ndGhcclxuICByZXR1cm4gdGhpc1xyXG59XHJcblxyXG5IYXNoLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAoZW5jKSB7XHJcbiAgdmFyIHJlbSA9IHRoaXMuX2xlbiAlIHRoaXMuX2Jsb2NrU2l6ZVxyXG5cclxuICB0aGlzLl9ibG9ja1tyZW1dID0gMHg4MFxyXG5cclxuICAvLyB6ZXJvIChyZW0gKyAxKSB0cmFpbGluZyBiaXRzLCB3aGVyZSAocmVtICsgMSkgaXMgdGhlIHNtYWxsZXN0XHJcbiAgLy8gbm9uLW5lZ2F0aXZlIHNvbHV0aW9uIHRvIHRoZSBlcXVhdGlvbiAobGVuZ3RoICsgMSArIChyZW0gKyAxKSkgPT09IGZpbmFsU2l6ZSBtb2QgYmxvY2tTaXplXHJcbiAgdGhpcy5fYmxvY2suZmlsbCgwLCByZW0gKyAxKVxyXG5cclxuICBpZiAocmVtID49IHRoaXMuX2ZpbmFsU2l6ZSkge1xyXG4gICAgdGhpcy5fdXBkYXRlKHRoaXMuX2Jsb2NrKVxyXG4gICAgdGhpcy5fYmxvY2suZmlsbCgwKVxyXG4gIH1cclxuXHJcbiAgdmFyIGJpdHMgPSB0aGlzLl9sZW4gKiA4XHJcblxyXG4gIC8vIHVpbnQzMlxyXG4gIGlmIChiaXRzIDw9IDB4ZmZmZmZmZmYpIHtcclxuICAgIHRoaXMuX2Jsb2NrLndyaXRlVUludDMyQkUoYml0cywgdGhpcy5fYmxvY2tTaXplIC0gNClcclxuXHJcbiAgLy8gdWludDY0XHJcbiAgfSBlbHNlIHtcclxuICAgIHZhciBsb3dCaXRzID0gKGJpdHMgJiAweGZmZmZmZmZmKSA+Pj4gMFxyXG4gICAgdmFyIGhpZ2hCaXRzID0gKGJpdHMgLSBsb3dCaXRzKSAvIDB4MTAwMDAwMDAwXHJcblxyXG4gICAgdGhpcy5fYmxvY2sud3JpdGVVSW50MzJCRShoaWdoQml0cywgdGhpcy5fYmxvY2tTaXplIC0gOClcclxuICAgIHRoaXMuX2Jsb2NrLndyaXRlVUludDMyQkUobG93Qml0cywgdGhpcy5fYmxvY2tTaXplIC0gNClcclxuICB9XHJcblxyXG4gIHRoaXMuX3VwZGF0ZSh0aGlzLl9ibG9jaylcclxuICB2YXIgaGFzaCA9IHRoaXMuX2hhc2goKVxyXG5cclxuICByZXR1cm4gZW5jID8gaGFzaC50b1N0cmluZyhlbmMpIDogaGFzaFxyXG59XHJcblxyXG5IYXNoLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gIHRocm93IG5ldyBFcnJvcignX3VwZGF0ZSBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IHN1YmNsYXNzJylcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBIYXNoXHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/sha.js/hash.js\n");

/***/ }),

/***/ "./node_modules/sha.js/index.js":
/*!**************************************!*\
  !*** ./node_modules/sha.js/index.js ***!
  \**************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var exports = module.exports = function SHA (algorithm) {\r\n  algorithm = algorithm.toLowerCase()\r\n\r\n  var Algorithm = exports[algorithm]\r\n  if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')\r\n\r\n  return new Algorithm()\r\n}\r\n\r\nexports.sha = __webpack_require__(/*! ./sha */ \"./node_modules/sha.js/sha.js\")\r\nexports.sha1 = __webpack_require__(/*! ./sha1 */ \"./node_modules/sha.js/sha1.js\")\r\nexports.sha224 = __webpack_require__(/*! ./sha224 */ \"./node_modules/sha.js/sha224.js\")\r\nexports.sha256 = __webpack_require__(/*! ./sha256 */ \"./node_modules/sha.js/sha256.js\")\r\nexports.sha384 = __webpack_require__(/*! ./sha384 */ \"./node_modules/sha.js/sha384.js\")\r\nexports.sha512 = __webpack_require__(/*! ./sha512 */ \"./node_modules/sha.js/sha512.js\")\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2hhLmpzL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQywyQ0FBTztBQUM3QixlQUFlLG1CQUFPLENBQUMsNkNBQVE7QUFDL0IsaUJBQWlCLG1CQUFPLENBQUMsaURBQVU7QUFDbkMsaUJBQWlCLG1CQUFPLENBQUMsaURBQVU7QUFDbkMsaUJBQWlCLG1CQUFPLENBQUMsaURBQVU7QUFDbkMsaUJBQWlCLG1CQUFPLENBQUMsaURBQVUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3NoYS5qcy9pbmRleC5qcz83NDJhIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBTSEEgKGFsZ29yaXRobSkge1xyXG4gIGFsZ29yaXRobSA9IGFsZ29yaXRobS50b0xvd2VyQ2FzZSgpXHJcblxyXG4gIHZhciBBbGdvcml0aG0gPSBleHBvcnRzW2FsZ29yaXRobV1cclxuICBpZiAoIUFsZ29yaXRobSkgdGhyb3cgbmV3IEVycm9yKGFsZ29yaXRobSArICcgaXMgbm90IHN1cHBvcnRlZCAod2UgYWNjZXB0IHB1bGwgcmVxdWVzdHMpJylcclxuXHJcbiAgcmV0dXJuIG5ldyBBbGdvcml0aG0oKVxyXG59XHJcblxyXG5leHBvcnRzLnNoYSA9IHJlcXVpcmUoJy4vc2hhJylcclxuZXhwb3J0cy5zaGExID0gcmVxdWlyZSgnLi9zaGExJylcclxuZXhwb3J0cy5zaGEyMjQgPSByZXF1aXJlKCcuL3NoYTIyNCcpXHJcbmV4cG9ydHMuc2hhMjU2ID0gcmVxdWlyZSgnLi9zaGEyNTYnKVxyXG5leHBvcnRzLnNoYTM4NCA9IHJlcXVpcmUoJy4vc2hhMzg0JylcclxuZXhwb3J0cy5zaGE1MTIgPSByZXF1aXJlKCcuL3NoYTUxMicpXHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/sha.js/index.js\n");

/***/ }),

/***/ "./node_modules/sha.js/sha.js":
/*!************************************!*\
  !*** ./node_modules/sha.js/sha.js ***!
  \************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/*\r\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined\r\n * in FIPS PUB 180-1\r\n * This source code is derived from sha1.js of the same repository.\r\n * The difference between SHA-0 and SHA-1 is just a bitwise rotate left\r\n * operation was added.\r\n */\r\n\r\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\r\nvar Hash = __webpack_require__(/*! ./hash */ \"./node_modules/sha.js/hash.js\")\r\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer)\r\n\r\nvar K = [\r\n  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0\r\n]\r\n\r\nvar W = new Array(80)\r\n\r\nfunction Sha () {\r\n  this.init()\r\n  this._w = W\r\n\r\n  Hash.call(this, 64, 56)\r\n}\r\n\r\ninherits(Sha, Hash)\r\n\r\nSha.prototype.init = function () {\r\n  this._a = 0x67452301\r\n  this._b = 0xefcdab89\r\n  this._c = 0x98badcfe\r\n  this._d = 0x10325476\r\n  this._e = 0xc3d2e1f0\r\n\r\n  return this\r\n}\r\n\r\nfunction rotl5 (num) {\r\n  return (num << 5) | (num >>> 27)\r\n}\r\n\r\nfunction rotl30 (num) {\r\n  return (num << 30) | (num >>> 2)\r\n}\r\n\r\nfunction ft (s, b, c, d) {\r\n  if (s === 0) return (b & c) | ((~b) & d)\r\n  if (s === 2) return (b & c) | (b & d) | (c & d)\r\n  return b ^ c ^ d\r\n}\r\n\r\nSha.prototype._update = function (M) {\r\n  var W = this._w\r\n\r\n  var a = this._a | 0\r\n  var b = this._b | 0\r\n  var c = this._c | 0\r\n  var d = this._d | 0\r\n  var e = this._e | 0\r\n\r\n  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)\r\n  for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]\r\n\r\n  for (var j = 0; j < 80; ++j) {\r\n    var s = ~~(j / 20)\r\n    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0\r\n\r\n    e = d\r\n    d = c\r\n    c = rotl30(b)\r\n    b = a\r\n    a = t\r\n  }\r\n\r\n  this._a = (a + this._a) | 0\r\n  this._b = (b + this._b) | 0\r\n  this._c = (c + this._c) | 0\r\n  this._d = (d + this._d) | 0\r\n  this._e = (e + this._e) | 0\r\n}\r\n\r\nSha.prototype._hash = function () {\r\n  var H = Buffer.allocUnsafe(20)\r\n\r\n  H.writeInt32BE(this._a | 0, 0)\r\n  H.writeInt32BE(this._b | 0, 4)\r\n  H.writeInt32BE(this._c | 0, 8)\r\n  H.writeInt32BE(this._d | 0, 12)\r\n  H.writeInt32BE(this._e | 0, 16)\r\n\r\n  return H\r\n}\r\n\r\nmodule.exports = Sha\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2hhLmpzL3NoYS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLDZEQUFVO0FBQ2pDLFdBQVcsbUJBQU8sQ0FBQyw2Q0FBUTtBQUMzQixhQUFhLHNGQUE2QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCLFNBQVMsUUFBUTtBQUNqQjtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvc2hhLmpzL3NoYS5qcz85Njg2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXHJcbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2VjdXJlIEhhc2ggQWxnb3JpdGhtLCBTSEEtMCwgYXMgZGVmaW5lZFxyXG4gKiBpbiBGSVBTIFBVQiAxODAtMVxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGRlcml2ZWQgZnJvbSBzaGExLmpzIG9mIHRoZSBzYW1lIHJlcG9zaXRvcnkuXHJcbiAqIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gU0hBLTAgYW5kIFNIQS0xIGlzIGp1c3QgYSBiaXR3aXNlIHJvdGF0ZSBsZWZ0XHJcbiAqIG9wZXJhdGlvbiB3YXMgYWRkZWQuXHJcbiAqL1xyXG5cclxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxyXG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpXHJcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxyXG5cclxudmFyIEsgPSBbXHJcbiAgMHg1YTgyNzk5OSwgMHg2ZWQ5ZWJhMSwgMHg4ZjFiYmNkYyB8IDAsIDB4Y2E2MmMxZDYgfCAwXHJcbl1cclxuXHJcbnZhciBXID0gbmV3IEFycmF5KDgwKVxyXG5cclxuZnVuY3Rpb24gU2hhICgpIHtcclxuICB0aGlzLmluaXQoKVxyXG4gIHRoaXMuX3cgPSBXXHJcblxyXG4gIEhhc2guY2FsbCh0aGlzLCA2NCwgNTYpXHJcbn1cclxuXHJcbmluaGVyaXRzKFNoYSwgSGFzaClcclxuXHJcblNoYS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICB0aGlzLl9hID0gMHg2NzQ1MjMwMVxyXG4gIHRoaXMuX2IgPSAweGVmY2RhYjg5XHJcbiAgdGhpcy5fYyA9IDB4OThiYWRjZmVcclxuICB0aGlzLl9kID0gMHgxMDMyNTQ3NlxyXG4gIHRoaXMuX2UgPSAweGMzZDJlMWYwXHJcblxyXG4gIHJldHVybiB0aGlzXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJvdGw1IChudW0pIHtcclxuICByZXR1cm4gKG51bSA8PCA1KSB8IChudW0gPj4+IDI3KVxyXG59XHJcblxyXG5mdW5jdGlvbiByb3RsMzAgKG51bSkge1xyXG4gIHJldHVybiAobnVtIDw8IDMwKSB8IChudW0gPj4+IDIpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZ0IChzLCBiLCBjLCBkKSB7XHJcbiAgaWYgKHMgPT09IDApIHJldHVybiAoYiAmIGMpIHwgKCh+YikgJiBkKVxyXG4gIGlmIChzID09PSAyKSByZXR1cm4gKGIgJiBjKSB8IChiICYgZCkgfCAoYyAmIGQpXHJcbiAgcmV0dXJuIGIgXiBjIF4gZFxyXG59XHJcblxyXG5TaGEucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoTSkge1xyXG4gIHZhciBXID0gdGhpcy5fd1xyXG5cclxuICB2YXIgYSA9IHRoaXMuX2EgfCAwXHJcbiAgdmFyIGIgPSB0aGlzLl9iIHwgMFxyXG4gIHZhciBjID0gdGhpcy5fYyB8IDBcclxuICB2YXIgZCA9IHRoaXMuX2QgfCAwXHJcbiAgdmFyIGUgPSB0aGlzLl9lIHwgMFxyXG5cclxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIFdbaV0gPSBNLnJlYWRJbnQzMkJFKGkgKiA0KVxyXG4gIGZvciAoOyBpIDwgODA7ICsraSkgV1tpXSA9IFdbaSAtIDNdIF4gV1tpIC0gOF0gXiBXW2kgLSAxNF0gXiBXW2kgLSAxNl1cclxuXHJcbiAgZm9yICh2YXIgaiA9IDA7IGogPCA4MDsgKytqKSB7XHJcbiAgICB2YXIgcyA9IH5+KGogLyAyMClcclxuICAgIHZhciB0ID0gKHJvdGw1KGEpICsgZnQocywgYiwgYywgZCkgKyBlICsgV1tqXSArIEtbc10pIHwgMFxyXG5cclxuICAgIGUgPSBkXHJcbiAgICBkID0gY1xyXG4gICAgYyA9IHJvdGwzMChiKVxyXG4gICAgYiA9IGFcclxuICAgIGEgPSB0XHJcbiAgfVxyXG5cclxuICB0aGlzLl9hID0gKGEgKyB0aGlzLl9hKSB8IDBcclxuICB0aGlzLl9iID0gKGIgKyB0aGlzLl9iKSB8IDBcclxuICB0aGlzLl9jID0gKGMgKyB0aGlzLl9jKSB8IDBcclxuICB0aGlzLl9kID0gKGQgKyB0aGlzLl9kKSB8IDBcclxuICB0aGlzLl9lID0gKGUgKyB0aGlzLl9lKSB8IDBcclxufVxyXG5cclxuU2hhLnByb3RvdHlwZS5faGFzaCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgSCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyMClcclxuXHJcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYSB8IDAsIDApXHJcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYiB8IDAsIDQpXHJcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYyB8IDAsIDgpXHJcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZCB8IDAsIDEyKVxyXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2UgfCAwLCAxNilcclxuXHJcbiAgcmV0dXJuIEhcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTaGFcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/sha.js/sha.js\n");

/***/ }),

/***/ "./node_modules/sha.js/sha1.js":
/*!*************************************!*\
  !*** ./node_modules/sha.js/sha1.js ***!
  \*************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/*\r\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined\r\n * in FIPS PUB 180-1\r\n * Version 2.1a Copyright Paul Johnston 2000 - 2002.\r\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\r\n * Distributed under the BSD License\r\n * See http://pajhome.org.uk/crypt/md5 for details.\r\n */\r\n\r\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\r\nvar Hash = __webpack_require__(/*! ./hash */ \"./node_modules/sha.js/hash.js\")\r\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer)\r\n\r\nvar K = [\r\n  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0\r\n]\r\n\r\nvar W = new Array(80)\r\n\r\nfunction Sha1 () {\r\n  this.init()\r\n  this._w = W\r\n\r\n  Hash.call(this, 64, 56)\r\n}\r\n\r\ninherits(Sha1, Hash)\r\n\r\nSha1.prototype.init = function () {\r\n  this._a = 0x67452301\r\n  this._b = 0xefcdab89\r\n  this._c = 0x98badcfe\r\n  this._d = 0x10325476\r\n  this._e = 0xc3d2e1f0\r\n\r\n  return this\r\n}\r\n\r\nfunction rotl1 (num) {\r\n  return (num << 1) | (num >>> 31)\r\n}\r\n\r\nfunction rotl5 (num) {\r\n  return (num << 5) | (num >>> 27)\r\n}\r\n\r\nfunction rotl30 (num) {\r\n  return (num << 30) | (num >>> 2)\r\n}\r\n\r\nfunction ft (s, b, c, d) {\r\n  if (s === 0) return (b & c) | ((~b) & d)\r\n  if (s === 2) return (b & c) | (b & d) | (c & d)\r\n  return b ^ c ^ d\r\n}\r\n\r\nSha1.prototype._update = function (M) {\r\n  var W = this._w\r\n\r\n  var a = this._a | 0\r\n  var b = this._b | 0\r\n  var c = this._c | 0\r\n  var d = this._d | 0\r\n  var e = this._e | 0\r\n\r\n  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)\r\n  for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16])\r\n\r\n  for (var j = 0; j < 80; ++j) {\r\n    var s = ~~(j / 20)\r\n    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0\r\n\r\n    e = d\r\n    d = c\r\n    c = rotl30(b)\r\n    b = a\r\n    a = t\r\n  }\r\n\r\n  this._a = (a + this._a) | 0\r\n  this._b = (b + this._b) | 0\r\n  this._c = (c + this._c) | 0\r\n  this._d = (d + this._d) | 0\r\n  this._e = (e + this._e) | 0\r\n}\r\n\r\nSha1.prototype._hash = function () {\r\n  var H = Buffer.allocUnsafe(20)\r\n\r\n  H.writeInt32BE(this._a | 0, 0)\r\n  H.writeInt32BE(this._b | 0, 4)\r\n  H.writeInt32BE(this._c | 0, 8)\r\n  H.writeInt32BE(this._d | 0, 12)\r\n  H.writeInt32BE(this._e | 0, 16)\r\n\r\n  return H\r\n}\r\n\r\nmodule.exports = Sha1\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2hhLmpzL3NoYTEuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLDZEQUFVO0FBQ2pDLFdBQVcsbUJBQU8sQ0FBQyw2Q0FBUTtBQUMzQixhQUFhLHNGQUE2QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUIsU0FBUyxRQUFRO0FBQ2pCO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9zaGEuanMvc2hhMS5qcz80ZDljIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXHJcbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2VjdXJlIEhhc2ggQWxnb3JpdGhtLCBTSEEtMSwgYXMgZGVmaW5lZFxyXG4gKiBpbiBGSVBTIFBVQiAxODAtMVxyXG4gKiBWZXJzaW9uIDIuMWEgQ29weXJpZ2h0IFBhdWwgSm9obnN0b24gMjAwMCAtIDIwMDIuXHJcbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcclxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlXHJcbiAqIFNlZSBodHRwOi8vcGFqaG9tZS5vcmcudWsvY3J5cHQvbWQ1IGZvciBkZXRhaWxzLlxyXG4gKi9cclxuXHJcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcclxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxyXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcclxuXHJcbnZhciBLID0gW1xyXG4gIDB4NWE4Mjc5OTksIDB4NmVkOWViYTEsIDB4OGYxYmJjZGMgfCAwLCAweGNhNjJjMWQ2IHwgMFxyXG5dXHJcblxyXG52YXIgVyA9IG5ldyBBcnJheSg4MClcclxuXHJcbmZ1bmN0aW9uIFNoYTEgKCkge1xyXG4gIHRoaXMuaW5pdCgpXHJcbiAgdGhpcy5fdyA9IFdcclxuXHJcbiAgSGFzaC5jYWxsKHRoaXMsIDY0LCA1NilcclxufVxyXG5cclxuaW5oZXJpdHMoU2hhMSwgSGFzaClcclxuXHJcblNoYTEucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdGhpcy5fYSA9IDB4Njc0NTIzMDFcclxuICB0aGlzLl9iID0gMHhlZmNkYWI4OVxyXG4gIHRoaXMuX2MgPSAweDk4YmFkY2ZlXHJcbiAgdGhpcy5fZCA9IDB4MTAzMjU0NzZcclxuICB0aGlzLl9lID0gMHhjM2QyZTFmMFxyXG5cclxuICByZXR1cm4gdGhpc1xyXG59XHJcblxyXG5mdW5jdGlvbiByb3RsMSAobnVtKSB7XHJcbiAgcmV0dXJuIChudW0gPDwgMSkgfCAobnVtID4+PiAzMSlcclxufVxyXG5cclxuZnVuY3Rpb24gcm90bDUgKG51bSkge1xyXG4gIHJldHVybiAobnVtIDw8IDUpIHwgKG51bSA+Pj4gMjcpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJvdGwzMCAobnVtKSB7XHJcbiAgcmV0dXJuIChudW0gPDwgMzApIHwgKG51bSA+Pj4gMilcclxufVxyXG5cclxuZnVuY3Rpb24gZnQgKHMsIGIsIGMsIGQpIHtcclxuICBpZiAocyA9PT0gMCkgcmV0dXJuIChiICYgYykgfCAoKH5iKSAmIGQpXHJcbiAgaWYgKHMgPT09IDIpIHJldHVybiAoYiAmIGMpIHwgKGIgJiBkKSB8IChjICYgZClcclxuICByZXR1cm4gYiBeIGMgXiBkXHJcbn1cclxuXHJcblNoYTEucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoTSkge1xyXG4gIHZhciBXID0gdGhpcy5fd1xyXG5cclxuICB2YXIgYSA9IHRoaXMuX2EgfCAwXHJcbiAgdmFyIGIgPSB0aGlzLl9iIHwgMFxyXG4gIHZhciBjID0gdGhpcy5fYyB8IDBcclxuICB2YXIgZCA9IHRoaXMuX2QgfCAwXHJcbiAgdmFyIGUgPSB0aGlzLl9lIHwgMFxyXG5cclxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIFdbaV0gPSBNLnJlYWRJbnQzMkJFKGkgKiA0KVxyXG4gIGZvciAoOyBpIDwgODA7ICsraSkgV1tpXSA9IHJvdGwxKFdbaSAtIDNdIF4gV1tpIC0gOF0gXiBXW2kgLSAxNF0gXiBXW2kgLSAxNl0pXHJcblxyXG4gIGZvciAodmFyIGogPSAwOyBqIDwgODA7ICsraikge1xyXG4gICAgdmFyIHMgPSB+fihqIC8gMjApXHJcbiAgICB2YXIgdCA9IChyb3RsNShhKSArIGZ0KHMsIGIsIGMsIGQpICsgZSArIFdbal0gKyBLW3NdKSB8IDBcclxuXHJcbiAgICBlID0gZFxyXG4gICAgZCA9IGNcclxuICAgIGMgPSByb3RsMzAoYilcclxuICAgIGIgPSBhXHJcbiAgICBhID0gdFxyXG4gIH1cclxuXHJcbiAgdGhpcy5fYSA9IChhICsgdGhpcy5fYSkgfCAwXHJcbiAgdGhpcy5fYiA9IChiICsgdGhpcy5fYikgfCAwXHJcbiAgdGhpcy5fYyA9IChjICsgdGhpcy5fYykgfCAwXHJcbiAgdGhpcy5fZCA9IChkICsgdGhpcy5fZCkgfCAwXHJcbiAgdGhpcy5fZSA9IChlICsgdGhpcy5fZSkgfCAwXHJcbn1cclxuXHJcblNoYTEucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBIID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIwKVxyXG5cclxuICBILndyaXRlSW50MzJCRSh0aGlzLl9hIHwgMCwgMClcclxuICBILndyaXRlSW50MzJCRSh0aGlzLl9iIHwgMCwgNClcclxuICBILndyaXRlSW50MzJCRSh0aGlzLl9jIHwgMCwgOClcclxuICBILndyaXRlSW50MzJCRSh0aGlzLl9kIHwgMCwgMTIpXHJcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZSB8IDAsIDE2KVxyXG5cclxuICByZXR1cm4gSFxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNoYTFcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/sha.js/sha1.js\n");

/***/ }),

/***/ "./node_modules/sha.js/sha224.js":
/*!***************************************!*\
  !*** ./node_modules/sha.js/sha224.js ***!
  \***************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/**\r\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined\r\n * in FIPS 180-2\r\n * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.\r\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\r\n *\r\n */\r\n\r\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\r\nvar Sha256 = __webpack_require__(/*! ./sha256 */ \"./node_modules/sha.js/sha256.js\")\r\nvar Hash = __webpack_require__(/*! ./hash */ \"./node_modules/sha.js/hash.js\")\r\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer)\r\n\r\nvar W = new Array(64)\r\n\r\nfunction Sha224 () {\r\n  this.init()\r\n\r\n  this._w = W // new Array(64)\r\n\r\n  Hash.call(this, 64, 56)\r\n}\r\n\r\ninherits(Sha224, Sha256)\r\n\r\nSha224.prototype.init = function () {\r\n  this._a = 0xc1059ed8\r\n  this._b = 0x367cd507\r\n  this._c = 0x3070dd17\r\n  this._d = 0xf70e5939\r\n  this._e = 0xffc00b31\r\n  this._f = 0x68581511\r\n  this._g = 0x64f98fa7\r\n  this._h = 0xbefa4fa4\r\n\r\n  return this\r\n}\r\n\r\nSha224.prototype._hash = function () {\r\n  var H = Buffer.allocUnsafe(28)\r\n\r\n  H.writeInt32BE(this._a, 0)\r\n  H.writeInt32BE(this._b, 4)\r\n  H.writeInt32BE(this._c, 8)\r\n  H.writeInt32BE(this._d, 12)\r\n  H.writeInt32BE(this._e, 16)\r\n  H.writeInt32BE(this._f, 20)\r\n  H.writeInt32BE(this._g, 24)\r\n\r\n  return H\r\n}\r\n\r\nmodule.exports = Sha224\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2hhLmpzL3NoYTIyNC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLDZEQUFVO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQyxpREFBVTtBQUMvQixXQUFXLG1CQUFPLENBQUMsNkNBQVE7QUFDM0IsYUFBYSxzRkFBNkI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvc2hhLmpzL3NoYTIyNC5qcz85YWMyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNlY3VyZSBIYXNoIEFsZ29yaXRobSwgU0hBLTI1NiwgYXMgZGVmaW5lZFxyXG4gKiBpbiBGSVBTIDE4MC0yXHJcbiAqIFZlcnNpb24gMi4yLWJldGEgQ29weXJpZ2h0IEFuZ2VsIE1hcmluLCBQYXVsIEpvaG5zdG9uIDIwMDAgLSAyMDA5LlxyXG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XHJcbiAqXHJcbiAqL1xyXG5cclxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxyXG52YXIgU2hhMjU2ID0gcmVxdWlyZSgnLi9zaGEyNTYnKVxyXG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpXHJcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxyXG5cclxudmFyIFcgPSBuZXcgQXJyYXkoNjQpXHJcblxyXG5mdW5jdGlvbiBTaGEyMjQgKCkge1xyXG4gIHRoaXMuaW5pdCgpXHJcblxyXG4gIHRoaXMuX3cgPSBXIC8vIG5ldyBBcnJheSg2NClcclxuXHJcbiAgSGFzaC5jYWxsKHRoaXMsIDY0LCA1NilcclxufVxyXG5cclxuaW5oZXJpdHMoU2hhMjI0LCBTaGEyNTYpXHJcblxyXG5TaGEyMjQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdGhpcy5fYSA9IDB4YzEwNTllZDhcclxuICB0aGlzLl9iID0gMHgzNjdjZDUwN1xyXG4gIHRoaXMuX2MgPSAweDMwNzBkZDE3XHJcbiAgdGhpcy5fZCA9IDB4ZjcwZTU5MzlcclxuICB0aGlzLl9lID0gMHhmZmMwMGIzMVxyXG4gIHRoaXMuX2YgPSAweDY4NTgxNTExXHJcbiAgdGhpcy5fZyA9IDB4NjRmOThmYTdcclxuICB0aGlzLl9oID0gMHhiZWZhNGZhNFxyXG5cclxuICByZXR1cm4gdGhpc1xyXG59XHJcblxyXG5TaGEyMjQucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBIID0gQnVmZmVyLmFsbG9jVW5zYWZlKDI4KVxyXG5cclxuICBILndyaXRlSW50MzJCRSh0aGlzLl9hLCAwKVxyXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2IsIDQpXHJcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYywgOClcclxuICBILndyaXRlSW50MzJCRSh0aGlzLl9kLCAxMilcclxuICBILndyaXRlSW50MzJCRSh0aGlzLl9lLCAxNilcclxuICBILndyaXRlSW50MzJCRSh0aGlzLl9mLCAyMClcclxuICBILndyaXRlSW50MzJCRSh0aGlzLl9nLCAyNClcclxuXHJcbiAgcmV0dXJuIEhcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTaGEyMjRcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/sha.js/sha224.js\n");

/***/ }),

/***/ "./node_modules/sha.js/sha256.js":
/*!***************************************!*\
  !*** ./node_modules/sha.js/sha256.js ***!
  \***************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/**\r\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined\r\n * in FIPS 180-2\r\n * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.\r\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\r\n *\r\n */\r\n\r\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\r\nvar Hash = __webpack_require__(/*! ./hash */ \"./node_modules/sha.js/hash.js\")\r\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer)\r\n\r\nvar K = [\r\n  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,\r\n  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,\r\n  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,\r\n  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,\r\n  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,\r\n  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,\r\n  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,\r\n  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,\r\n  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,\r\n  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,\r\n  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,\r\n  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,\r\n  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,\r\n  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,\r\n  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,\r\n  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2\r\n]\r\n\r\nvar W = new Array(64)\r\n\r\nfunction Sha256 () {\r\n  this.init()\r\n\r\n  this._w = W // new Array(64)\r\n\r\n  Hash.call(this, 64, 56)\r\n}\r\n\r\ninherits(Sha256, Hash)\r\n\r\nSha256.prototype.init = function () {\r\n  this._a = 0x6a09e667\r\n  this._b = 0xbb67ae85\r\n  this._c = 0x3c6ef372\r\n  this._d = 0xa54ff53a\r\n  this._e = 0x510e527f\r\n  this._f = 0x9b05688c\r\n  this._g = 0x1f83d9ab\r\n  this._h = 0x5be0cd19\r\n\r\n  return this\r\n}\r\n\r\nfunction ch (x, y, z) {\r\n  return z ^ (x & (y ^ z))\r\n}\r\n\r\nfunction maj (x, y, z) {\r\n  return (x & y) | (z & (x | y))\r\n}\r\n\r\nfunction sigma0 (x) {\r\n  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)\r\n}\r\n\r\nfunction sigma1 (x) {\r\n  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)\r\n}\r\n\r\nfunction gamma0 (x) {\r\n  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)\r\n}\r\n\r\nfunction gamma1 (x) {\r\n  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)\r\n}\r\n\r\nSha256.prototype._update = function (M) {\r\n  var W = this._w\r\n\r\n  var a = this._a | 0\r\n  var b = this._b | 0\r\n  var c = this._c | 0\r\n  var d = this._d | 0\r\n  var e = this._e | 0\r\n  var f = this._f | 0\r\n  var g = this._g | 0\r\n  var h = this._h | 0\r\n\r\n  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)\r\n  for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0\r\n\r\n  for (var j = 0; j < 64; ++j) {\r\n    var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0\r\n    var T2 = (sigma0(a) + maj(a, b, c)) | 0\r\n\r\n    h = g\r\n    g = f\r\n    f = e\r\n    e = (d + T1) | 0\r\n    d = c\r\n    c = b\r\n    b = a\r\n    a = (T1 + T2) | 0\r\n  }\r\n\r\n  this._a = (a + this._a) | 0\r\n  this._b = (b + this._b) | 0\r\n  this._c = (c + this._c) | 0\r\n  this._d = (d + this._d) | 0\r\n  this._e = (e + this._e) | 0\r\n  this._f = (f + this._f) | 0\r\n  this._g = (g + this._g) | 0\r\n  this._h = (h + this._h) | 0\r\n}\r\n\r\nSha256.prototype._hash = function () {\r\n  var H = Buffer.allocUnsafe(32)\r\n\r\n  H.writeInt32BE(this._a, 0)\r\n  H.writeInt32BE(this._b, 4)\r\n  H.writeInt32BE(this._c, 8)\r\n  H.writeInt32BE(this._d, 12)\r\n  H.writeInt32BE(this._e, 16)\r\n  H.writeInt32BE(this._f, 20)\r\n  H.writeInt32BE(this._g, 24)\r\n  H.writeInt32BE(this._h, 28)\r\n\r\n  return H\r\n}\r\n\r\nmodule.exports = Sha256\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2hhLmpzL3NoYTI1Ni5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLDZEQUFVO0FBQ2pDLFdBQVcsbUJBQU8sQ0FBQyw2Q0FBUTtBQUMzQixhQUFhLHNGQUE2QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQixTQUFTLFFBQVE7QUFDakI7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3NoYS5qcy9zaGEyNTYuanM/N2U3YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0yNTYsIGFzIGRlZmluZWRcclxuICogaW4gRklQUyAxODAtMlxyXG4gKiBWZXJzaW9uIDIuMi1iZXRhIENvcHlyaWdodCBBbmdlbCBNYXJpbiwgUGF1bCBKb2huc3RvbiAyMDAwIC0gMjAwOS5cclxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxyXG4gKlxyXG4gKi9cclxuXHJcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcclxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxyXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcclxuXHJcbnZhciBLID0gW1xyXG4gIDB4NDI4QTJGOTgsIDB4NzEzNzQ0OTEsIDB4QjVDMEZCQ0YsIDB4RTlCNURCQTUsXHJcbiAgMHgzOTU2QzI1QiwgMHg1OUYxMTFGMSwgMHg5MjNGODJBNCwgMHhBQjFDNUVENSxcclxuICAweEQ4MDdBQTk4LCAweDEyODM1QjAxLCAweDI0MzE4NUJFLCAweDU1MEM3REMzLFxyXG4gIDB4NzJCRTVENzQsIDB4ODBERUIxRkUsIDB4OUJEQzA2QTcsIDB4QzE5QkYxNzQsXHJcbiAgMHhFNDlCNjlDMSwgMHhFRkJFNDc4NiwgMHgwRkMxOURDNiwgMHgyNDBDQTFDQyxcclxuICAweDJERTkyQzZGLCAweDRBNzQ4NEFBLCAweDVDQjBBOURDLCAweDc2Rjk4OERBLFxyXG4gIDB4OTgzRTUxNTIsIDB4QTgzMUM2NkQsIDB4QjAwMzI3QzgsIDB4QkY1OTdGQzcsXHJcbiAgMHhDNkUwMEJGMywgMHhENUE3OTE0NywgMHgwNkNBNjM1MSwgMHgxNDI5Mjk2NyxcclxuICAweDI3QjcwQTg1LCAweDJFMUIyMTM4LCAweDREMkM2REZDLCAweDUzMzgwRDEzLFxyXG4gIDB4NjUwQTczNTQsIDB4NzY2QTBBQkIsIDB4ODFDMkM5MkUsIDB4OTI3MjJDODUsXHJcbiAgMHhBMkJGRThBMSwgMHhBODFBNjY0QiwgMHhDMjRCOEI3MCwgMHhDNzZDNTFBMyxcclxuICAweEQxOTJFODE5LCAweEQ2OTkwNjI0LCAweEY0MEUzNTg1LCAweDEwNkFBMDcwLFxyXG4gIDB4MTlBNEMxMTYsIDB4MUUzNzZDMDgsIDB4Mjc0ODc3NEMsIDB4MzRCMEJDQjUsXHJcbiAgMHgzOTFDMENCMywgMHg0RUQ4QUE0QSwgMHg1QjlDQ0E0RiwgMHg2ODJFNkZGMyxcclxuICAweDc0OEY4MkVFLCAweDc4QTU2MzZGLCAweDg0Qzg3ODE0LCAweDhDQzcwMjA4LFxyXG4gIDB4OTBCRUZGRkEsIDB4QTQ1MDZDRUIsIDB4QkVGOUEzRjcsIDB4QzY3MTc4RjJcclxuXVxyXG5cclxudmFyIFcgPSBuZXcgQXJyYXkoNjQpXHJcblxyXG5mdW5jdGlvbiBTaGEyNTYgKCkge1xyXG4gIHRoaXMuaW5pdCgpXHJcblxyXG4gIHRoaXMuX3cgPSBXIC8vIG5ldyBBcnJheSg2NClcclxuXHJcbiAgSGFzaC5jYWxsKHRoaXMsIDY0LCA1NilcclxufVxyXG5cclxuaW5oZXJpdHMoU2hhMjU2LCBIYXNoKVxyXG5cclxuU2hhMjU2LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gIHRoaXMuX2EgPSAweDZhMDllNjY3XHJcbiAgdGhpcy5fYiA9IDB4YmI2N2FlODVcclxuICB0aGlzLl9jID0gMHgzYzZlZjM3MlxyXG4gIHRoaXMuX2QgPSAweGE1NGZmNTNhXHJcbiAgdGhpcy5fZSA9IDB4NTEwZTUyN2ZcclxuICB0aGlzLl9mID0gMHg5YjA1Njg4Y1xyXG4gIHRoaXMuX2cgPSAweDFmODNkOWFiXHJcbiAgdGhpcy5faCA9IDB4NWJlMGNkMTlcclxuXHJcbiAgcmV0dXJuIHRoaXNcclxufVxyXG5cclxuZnVuY3Rpb24gY2ggKHgsIHksIHopIHtcclxuICByZXR1cm4geiBeICh4ICYgKHkgXiB6KSlcclxufVxyXG5cclxuZnVuY3Rpb24gbWFqICh4LCB5LCB6KSB7XHJcbiAgcmV0dXJuICh4ICYgeSkgfCAoeiAmICh4IHwgeSkpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNpZ21hMCAoeCkge1xyXG4gIHJldHVybiAoeCA+Pj4gMiB8IHggPDwgMzApIF4gKHggPj4+IDEzIHwgeCA8PCAxOSkgXiAoeCA+Pj4gMjIgfCB4IDw8IDEwKVxyXG59XHJcblxyXG5mdW5jdGlvbiBzaWdtYTEgKHgpIHtcclxuICByZXR1cm4gKHggPj4+IDYgfCB4IDw8IDI2KSBeICh4ID4+PiAxMSB8IHggPDwgMjEpIF4gKHggPj4+IDI1IHwgeCA8PCA3KVxyXG59XHJcblxyXG5mdW5jdGlvbiBnYW1tYTAgKHgpIHtcclxuICByZXR1cm4gKHggPj4+IDcgfCB4IDw8IDI1KSBeICh4ID4+PiAxOCB8IHggPDwgMTQpIF4gKHggPj4+IDMpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdhbW1hMSAoeCkge1xyXG4gIHJldHVybiAoeCA+Pj4gMTcgfCB4IDw8IDE1KSBeICh4ID4+PiAxOSB8IHggPDwgMTMpIF4gKHggPj4+IDEwKVxyXG59XHJcblxyXG5TaGEyNTYucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoTSkge1xyXG4gIHZhciBXID0gdGhpcy5fd1xyXG5cclxuICB2YXIgYSA9IHRoaXMuX2EgfCAwXHJcbiAgdmFyIGIgPSB0aGlzLl9iIHwgMFxyXG4gIHZhciBjID0gdGhpcy5fYyB8IDBcclxuICB2YXIgZCA9IHRoaXMuX2QgfCAwXHJcbiAgdmFyIGUgPSB0aGlzLl9lIHwgMFxyXG4gIHZhciBmID0gdGhpcy5fZiB8IDBcclxuICB2YXIgZyA9IHRoaXMuX2cgfCAwXHJcbiAgdmFyIGggPSB0aGlzLl9oIHwgMFxyXG5cclxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIFdbaV0gPSBNLnJlYWRJbnQzMkJFKGkgKiA0KVxyXG4gIGZvciAoOyBpIDwgNjQ7ICsraSkgV1tpXSA9IChnYW1tYTEoV1tpIC0gMl0pICsgV1tpIC0gN10gKyBnYW1tYTAoV1tpIC0gMTVdKSArIFdbaSAtIDE2XSkgfCAwXHJcblxyXG4gIGZvciAodmFyIGogPSAwOyBqIDwgNjQ7ICsraikge1xyXG4gICAgdmFyIFQxID0gKGggKyBzaWdtYTEoZSkgKyBjaChlLCBmLCBnKSArIEtbal0gKyBXW2pdKSB8IDBcclxuICAgIHZhciBUMiA9IChzaWdtYTAoYSkgKyBtYWooYSwgYiwgYykpIHwgMFxyXG5cclxuICAgIGggPSBnXHJcbiAgICBnID0gZlxyXG4gICAgZiA9IGVcclxuICAgIGUgPSAoZCArIFQxKSB8IDBcclxuICAgIGQgPSBjXHJcbiAgICBjID0gYlxyXG4gICAgYiA9IGFcclxuICAgIGEgPSAoVDEgKyBUMikgfCAwXHJcbiAgfVxyXG5cclxuICB0aGlzLl9hID0gKGEgKyB0aGlzLl9hKSB8IDBcclxuICB0aGlzLl9iID0gKGIgKyB0aGlzLl9iKSB8IDBcclxuICB0aGlzLl9jID0gKGMgKyB0aGlzLl9jKSB8IDBcclxuICB0aGlzLl9kID0gKGQgKyB0aGlzLl9kKSB8IDBcclxuICB0aGlzLl9lID0gKGUgKyB0aGlzLl9lKSB8IDBcclxuICB0aGlzLl9mID0gKGYgKyB0aGlzLl9mKSB8IDBcclxuICB0aGlzLl9nID0gKGcgKyB0aGlzLl9nKSB8IDBcclxuICB0aGlzLl9oID0gKGggKyB0aGlzLl9oKSB8IDBcclxufVxyXG5cclxuU2hhMjU2LnByb3RvdHlwZS5faGFzaCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgSCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgzMilcclxuXHJcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYSwgMClcclxuICBILndyaXRlSW50MzJCRSh0aGlzLl9iLCA0KVxyXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2MsIDgpXHJcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZCwgMTIpXHJcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZSwgMTYpXHJcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZiwgMjApXHJcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZywgMjQpXHJcbiAgSC53cml0ZUludDMyQkUodGhpcy5faCwgMjgpXHJcblxyXG4gIHJldHVybiBIXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2hhMjU2XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/sha.js/sha256.js\n");

/***/ }),

/***/ "./node_modules/sha.js/sha384.js":
/*!***************************************!*\
  !*** ./node_modules/sha.js/sha384.js ***!
  \***************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\r\nvar SHA512 = __webpack_require__(/*! ./sha512 */ \"./node_modules/sha.js/sha512.js\")\r\nvar Hash = __webpack_require__(/*! ./hash */ \"./node_modules/sha.js/hash.js\")\r\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer)\r\n\r\nvar W = new Array(160)\r\n\r\nfunction Sha384 () {\r\n  this.init()\r\n  this._w = W\r\n\r\n  Hash.call(this, 128, 112)\r\n}\r\n\r\ninherits(Sha384, SHA512)\r\n\r\nSha384.prototype.init = function () {\r\n  this._ah = 0xcbbb9d5d\r\n  this._bh = 0x629a292a\r\n  this._ch = 0x9159015a\r\n  this._dh = 0x152fecd8\r\n  this._eh = 0x67332667\r\n  this._fh = 0x8eb44a87\r\n  this._gh = 0xdb0c2e0d\r\n  this._hh = 0x47b5481d\r\n\r\n  this._al = 0xc1059ed8\r\n  this._bl = 0x367cd507\r\n  this._cl = 0x3070dd17\r\n  this._dl = 0xf70e5939\r\n  this._el = 0xffc00b31\r\n  this._fl = 0x68581511\r\n  this._gl = 0x64f98fa7\r\n  this._hl = 0xbefa4fa4\r\n\r\n  return this\r\n}\r\n\r\nSha384.prototype._hash = function () {\r\n  var H = Buffer.allocUnsafe(48)\r\n\r\n  function writeInt64BE (h, l, offset) {\r\n    H.writeInt32BE(h, offset)\r\n    H.writeInt32BE(l, offset + 4)\r\n  }\r\n\r\n  writeInt64BE(this._ah, this._al, 0)\r\n  writeInt64BE(this._bh, this._bl, 8)\r\n  writeInt64BE(this._ch, this._cl, 16)\r\n  writeInt64BE(this._dh, this._dl, 24)\r\n  writeInt64BE(this._eh, this._el, 32)\r\n  writeInt64BE(this._fh, this._fl, 40)\r\n\r\n  return H\r\n}\r\n\r\nmodule.exports = Sha384\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2hhLmpzL3NoYTM4NC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG1CQUFPLENBQUMsNkRBQVU7QUFDakMsYUFBYSxtQkFBTyxDQUFDLGlEQUFVO0FBQy9CLFdBQVcsbUJBQU8sQ0FBQyw2Q0FBUTtBQUMzQixhQUFhLHNGQUE2QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9zaGEuanMvc2hhMzg0LmpzPzUzM2YiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxyXG52YXIgU0hBNTEyID0gcmVxdWlyZSgnLi9zaGE1MTInKVxyXG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpXHJcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxyXG5cclxudmFyIFcgPSBuZXcgQXJyYXkoMTYwKVxyXG5cclxuZnVuY3Rpb24gU2hhMzg0ICgpIHtcclxuICB0aGlzLmluaXQoKVxyXG4gIHRoaXMuX3cgPSBXXHJcblxyXG4gIEhhc2guY2FsbCh0aGlzLCAxMjgsIDExMilcclxufVxyXG5cclxuaW5oZXJpdHMoU2hhMzg0LCBTSEE1MTIpXHJcblxyXG5TaGEzODQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdGhpcy5fYWggPSAweGNiYmI5ZDVkXHJcbiAgdGhpcy5fYmggPSAweDYyOWEyOTJhXHJcbiAgdGhpcy5fY2ggPSAweDkxNTkwMTVhXHJcbiAgdGhpcy5fZGggPSAweDE1MmZlY2Q4XHJcbiAgdGhpcy5fZWggPSAweDY3MzMyNjY3XHJcbiAgdGhpcy5fZmggPSAweDhlYjQ0YTg3XHJcbiAgdGhpcy5fZ2ggPSAweGRiMGMyZTBkXHJcbiAgdGhpcy5faGggPSAweDQ3YjU0ODFkXHJcblxyXG4gIHRoaXMuX2FsID0gMHhjMTA1OWVkOFxyXG4gIHRoaXMuX2JsID0gMHgzNjdjZDUwN1xyXG4gIHRoaXMuX2NsID0gMHgzMDcwZGQxN1xyXG4gIHRoaXMuX2RsID0gMHhmNzBlNTkzOVxyXG4gIHRoaXMuX2VsID0gMHhmZmMwMGIzMVxyXG4gIHRoaXMuX2ZsID0gMHg2ODU4MTUxMVxyXG4gIHRoaXMuX2dsID0gMHg2NGY5OGZhN1xyXG4gIHRoaXMuX2hsID0gMHhiZWZhNGZhNFxyXG5cclxuICByZXR1cm4gdGhpc1xyXG59XHJcblxyXG5TaGEzODQucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBIID0gQnVmZmVyLmFsbG9jVW5zYWZlKDQ4KVxyXG5cclxuICBmdW5jdGlvbiB3cml0ZUludDY0QkUgKGgsIGwsIG9mZnNldCkge1xyXG4gICAgSC53cml0ZUludDMyQkUoaCwgb2Zmc2V0KVxyXG4gICAgSC53cml0ZUludDMyQkUobCwgb2Zmc2V0ICsgNClcclxuICB9XHJcblxyXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9haCwgdGhpcy5fYWwsIDApXHJcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2JoLCB0aGlzLl9ibCwgOClcclxuICB3cml0ZUludDY0QkUodGhpcy5fY2gsIHRoaXMuX2NsLCAxNilcclxuICB3cml0ZUludDY0QkUodGhpcy5fZGgsIHRoaXMuX2RsLCAyNClcclxuICB3cml0ZUludDY0QkUodGhpcy5fZWgsIHRoaXMuX2VsLCAzMilcclxuICB3cml0ZUludDY0QkUodGhpcy5fZmgsIHRoaXMuX2ZsLCA0MClcclxuXHJcbiAgcmV0dXJuIEhcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTaGEzODRcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/sha.js/sha384.js\n");

/***/ }),

/***/ "./node_modules/sha.js/sha512.js":
/*!***************************************!*\
  !*** ./node_modules/sha.js/sha512.js ***!
  \***************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\r\nvar Hash = __webpack_require__(/*! ./hash */ \"./node_modules/sha.js/hash.js\")\r\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer)\r\n\r\nvar K = [\r\n  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,\r\n  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,\r\n  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,\r\n  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,\r\n  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,\r\n  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,\r\n  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,\r\n  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,\r\n  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,\r\n  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,\r\n  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,\r\n  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,\r\n  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,\r\n  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,\r\n  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,\r\n  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,\r\n  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,\r\n  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,\r\n  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,\r\n  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,\r\n  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,\r\n  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,\r\n  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,\r\n  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,\r\n  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,\r\n  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,\r\n  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,\r\n  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,\r\n  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,\r\n  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,\r\n  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,\r\n  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,\r\n  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,\r\n  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,\r\n  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,\r\n  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,\r\n  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,\r\n  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,\r\n  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,\r\n  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817\r\n]\r\n\r\nvar W = new Array(160)\r\n\r\nfunction Sha512 () {\r\n  this.init()\r\n  this._w = W\r\n\r\n  Hash.call(this, 128, 112)\r\n}\r\n\r\ninherits(Sha512, Hash)\r\n\r\nSha512.prototype.init = function () {\r\n  this._ah = 0x6a09e667\r\n  this._bh = 0xbb67ae85\r\n  this._ch = 0x3c6ef372\r\n  this._dh = 0xa54ff53a\r\n  this._eh = 0x510e527f\r\n  this._fh = 0x9b05688c\r\n  this._gh = 0x1f83d9ab\r\n  this._hh = 0x5be0cd19\r\n\r\n  this._al = 0xf3bcc908\r\n  this._bl = 0x84caa73b\r\n  this._cl = 0xfe94f82b\r\n  this._dl = 0x5f1d36f1\r\n  this._el = 0xade682d1\r\n  this._fl = 0x2b3e6c1f\r\n  this._gl = 0xfb41bd6b\r\n  this._hl = 0x137e2179\r\n\r\n  return this\r\n}\r\n\r\nfunction Ch (x, y, z) {\r\n  return z ^ (x & (y ^ z))\r\n}\r\n\r\nfunction maj (x, y, z) {\r\n  return (x & y) | (z & (x | y))\r\n}\r\n\r\nfunction sigma0 (x, xl) {\r\n  return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25)\r\n}\r\n\r\nfunction sigma1 (x, xl) {\r\n  return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23)\r\n}\r\n\r\nfunction Gamma0 (x, xl) {\r\n  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7)\r\n}\r\n\r\nfunction Gamma0l (x, xl) {\r\n  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25)\r\n}\r\n\r\nfunction Gamma1 (x, xl) {\r\n  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6)\r\n}\r\n\r\nfunction Gamma1l (x, xl) {\r\n  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26)\r\n}\r\n\r\nfunction getCarry (a, b) {\r\n  return (a >>> 0) < (b >>> 0) ? 1 : 0\r\n}\r\n\r\nSha512.prototype._update = function (M) {\r\n  var W = this._w\r\n\r\n  var ah = this._ah | 0\r\n  var bh = this._bh | 0\r\n  var ch = this._ch | 0\r\n  var dh = this._dh | 0\r\n  var eh = this._eh | 0\r\n  var fh = this._fh | 0\r\n  var gh = this._gh | 0\r\n  var hh = this._hh | 0\r\n\r\n  var al = this._al | 0\r\n  var bl = this._bl | 0\r\n  var cl = this._cl | 0\r\n  var dl = this._dl | 0\r\n  var el = this._el | 0\r\n  var fl = this._fl | 0\r\n  var gl = this._gl | 0\r\n  var hl = this._hl | 0\r\n\r\n  for (var i = 0; i < 32; i += 2) {\r\n    W[i] = M.readInt32BE(i * 4)\r\n    W[i + 1] = M.readInt32BE(i * 4 + 4)\r\n  }\r\n  for (; i < 160; i += 2) {\r\n    var xh = W[i - 15 * 2]\r\n    var xl = W[i - 15 * 2 + 1]\r\n    var gamma0 = Gamma0(xh, xl)\r\n    var gamma0l = Gamma0l(xl, xh)\r\n\r\n    xh = W[i - 2 * 2]\r\n    xl = W[i - 2 * 2 + 1]\r\n    var gamma1 = Gamma1(xh, xl)\r\n    var gamma1l = Gamma1l(xl, xh)\r\n\r\n    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]\r\n    var Wi7h = W[i - 7 * 2]\r\n    var Wi7l = W[i - 7 * 2 + 1]\r\n\r\n    var Wi16h = W[i - 16 * 2]\r\n    var Wi16l = W[i - 16 * 2 + 1]\r\n\r\n    var Wil = (gamma0l + Wi7l) | 0\r\n    var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0\r\n    Wil = (Wil + gamma1l) | 0\r\n    Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0\r\n    Wil = (Wil + Wi16l) | 0\r\n    Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0\r\n\r\n    W[i] = Wih\r\n    W[i + 1] = Wil\r\n  }\r\n\r\n  for (var j = 0; j < 160; j += 2) {\r\n    Wih = W[j]\r\n    Wil = W[j + 1]\r\n\r\n    var majh = maj(ah, bh, ch)\r\n    var majl = maj(al, bl, cl)\r\n\r\n    var sigma0h = sigma0(ah, al)\r\n    var sigma0l = sigma0(al, ah)\r\n    var sigma1h = sigma1(eh, el)\r\n    var sigma1l = sigma1(el, eh)\r\n\r\n    // t1 = h + sigma1 + ch + K[j] + W[j]\r\n    var Kih = K[j]\r\n    var Kil = K[j + 1]\r\n\r\n    var chh = Ch(eh, fh, gh)\r\n    var chl = Ch(el, fl, gl)\r\n\r\n    var t1l = (hl + sigma1l) | 0\r\n    var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0\r\n    t1l = (t1l + chl) | 0\r\n    t1h = (t1h + chh + getCarry(t1l, chl)) | 0\r\n    t1l = (t1l + Kil) | 0\r\n    t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0\r\n    t1l = (t1l + Wil) | 0\r\n    t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0\r\n\r\n    // t2 = sigma0 + maj\r\n    var t2l = (sigma0l + majl) | 0\r\n    var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0\r\n\r\n    hh = gh\r\n    hl = gl\r\n    gh = fh\r\n    gl = fl\r\n    fh = eh\r\n    fl = el\r\n    el = (dl + t1l) | 0\r\n    eh = (dh + t1h + getCarry(el, dl)) | 0\r\n    dh = ch\r\n    dl = cl\r\n    ch = bh\r\n    cl = bl\r\n    bh = ah\r\n    bl = al\r\n    al = (t1l + t2l) | 0\r\n    ah = (t1h + t2h + getCarry(al, t1l)) | 0\r\n  }\r\n\r\n  this._al = (this._al + al) | 0\r\n  this._bl = (this._bl + bl) | 0\r\n  this._cl = (this._cl + cl) | 0\r\n  this._dl = (this._dl + dl) | 0\r\n  this._el = (this._el + el) | 0\r\n  this._fl = (this._fl + fl) | 0\r\n  this._gl = (this._gl + gl) | 0\r\n  this._hl = (this._hl + hl) | 0\r\n\r\n  this._ah = (this._ah + ah + getCarry(this._al, al)) | 0\r\n  this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0\r\n  this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0\r\n  this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0\r\n  this._eh = (this._eh + eh + getCarry(this._el, el)) | 0\r\n  this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0\r\n  this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0\r\n  this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0\r\n}\r\n\r\nSha512.prototype._hash = function () {\r\n  var H = Buffer.allocUnsafe(64)\r\n\r\n  function writeInt64BE (h, l, offset) {\r\n    H.writeInt32BE(h, offset)\r\n    H.writeInt32BE(l, offset + 4)\r\n  }\r\n\r\n  writeInt64BE(this._ah, this._al, 0)\r\n  writeInt64BE(this._bh, this._bl, 8)\r\n  writeInt64BE(this._ch, this._cl, 16)\r\n  writeInt64BE(this._dh, this._dl, 24)\r\n  writeInt64BE(this._eh, this._el, 32)\r\n  writeInt64BE(this._fh, this._fl, 40)\r\n  writeInt64BE(this._gh, this._gl, 48)\r\n  writeInt64BE(this._hh, this._hl, 56)\r\n\r\n  return H\r\n}\r\n\r\nmodule.exports = Sha512\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2hhLmpzL3NoYTUxMi5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG1CQUFPLENBQUMsNkRBQVU7QUFDakMsV0FBVyxtQkFBTyxDQUFDLDZDQUFRO0FBQzNCLGFBQWEsc0ZBQTZCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxTQUFTLFNBQVM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9zaGEuanMvc2hhNTEyLmpzP2NkYjUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxyXG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpXHJcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxyXG5cclxudmFyIEsgPSBbXHJcbiAgMHg0MjhhMmY5OCwgMHhkNzI4YWUyMiwgMHg3MTM3NDQ5MSwgMHgyM2VmNjVjZCxcclxuICAweGI1YzBmYmNmLCAweGVjNGQzYjJmLCAweGU5YjVkYmE1LCAweDgxODlkYmJjLFxyXG4gIDB4Mzk1NmMyNWIsIDB4ZjM0OGI1MzgsIDB4NTlmMTExZjEsIDB4YjYwNWQwMTksXHJcbiAgMHg5MjNmODJhNCwgMHhhZjE5NGY5YiwgMHhhYjFjNWVkNSwgMHhkYTZkODExOCxcclxuICAweGQ4MDdhYTk4LCAweGEzMDMwMjQyLCAweDEyODM1YjAxLCAweDQ1NzA2ZmJlLFxyXG4gIDB4MjQzMTg1YmUsIDB4NGVlNGIyOGMsIDB4NTUwYzdkYzMsIDB4ZDVmZmI0ZTIsXHJcbiAgMHg3MmJlNWQ3NCwgMHhmMjdiODk2ZiwgMHg4MGRlYjFmZSwgMHgzYjE2OTZiMSxcclxuICAweDliZGMwNmE3LCAweDI1YzcxMjM1LCAweGMxOWJmMTc0LCAweGNmNjkyNjk0LFxyXG4gIDB4ZTQ5YjY5YzEsIDB4OWVmMTRhZDIsIDB4ZWZiZTQ3ODYsIDB4Mzg0ZjI1ZTMsXHJcbiAgMHgwZmMxOWRjNiwgMHg4YjhjZDViNSwgMHgyNDBjYTFjYywgMHg3N2FjOWM2NSxcclxuICAweDJkZTkyYzZmLCAweDU5MmIwMjc1LCAweDRhNzQ4NGFhLCAweDZlYTZlNDgzLFxyXG4gIDB4NWNiMGE5ZGMsIDB4YmQ0MWZiZDQsIDB4NzZmOTg4ZGEsIDB4ODMxMTUzYjUsXHJcbiAgMHg5ODNlNTE1MiwgMHhlZTY2ZGZhYiwgMHhhODMxYzY2ZCwgMHgyZGI0MzIxMCxcclxuICAweGIwMDMyN2M4LCAweDk4ZmIyMTNmLCAweGJmNTk3ZmM3LCAweGJlZWYwZWU0LFxyXG4gIDB4YzZlMDBiZjMsIDB4M2RhODhmYzIsIDB4ZDVhNzkxNDcsIDB4OTMwYWE3MjUsXHJcbiAgMHgwNmNhNjM1MSwgMHhlMDAzODI2ZiwgMHgxNDI5Mjk2NywgMHgwYTBlNmU3MCxcclxuICAweDI3YjcwYTg1LCAweDQ2ZDIyZmZjLCAweDJlMWIyMTM4LCAweDVjMjZjOTI2LFxyXG4gIDB4NGQyYzZkZmMsIDB4NWFjNDJhZWQsIDB4NTMzODBkMTMsIDB4OWQ5NWIzZGYsXHJcbiAgMHg2NTBhNzM1NCwgMHg4YmFmNjNkZSwgMHg3NjZhMGFiYiwgMHgzYzc3YjJhOCxcclxuICAweDgxYzJjOTJlLCAweDQ3ZWRhZWU2LCAweDkyNzIyYzg1LCAweDE0ODIzNTNiLFxyXG4gIDB4YTJiZmU4YTEsIDB4NGNmMTAzNjQsIDB4YTgxYTY2NGIsIDB4YmM0MjMwMDEsXHJcbiAgMHhjMjRiOGI3MCwgMHhkMGY4OTc5MSwgMHhjNzZjNTFhMywgMHgwNjU0YmUzMCxcclxuICAweGQxOTJlODE5LCAweGQ2ZWY1MjE4LCAweGQ2OTkwNjI0LCAweDU1NjVhOTEwLFxyXG4gIDB4ZjQwZTM1ODUsIDB4NTc3MTIwMmEsIDB4MTA2YWEwNzAsIDB4MzJiYmQxYjgsXHJcbiAgMHgxOWE0YzExNiwgMHhiOGQyZDBjOCwgMHgxZTM3NmMwOCwgMHg1MTQxYWI1MyxcclxuICAweDI3NDg3NzRjLCAweGRmOGVlYjk5LCAweDM0YjBiY2I1LCAweGUxOWI0OGE4LFxyXG4gIDB4MzkxYzBjYjMsIDB4YzVjOTVhNjMsIDB4NGVkOGFhNGEsIDB4ZTM0MThhY2IsXHJcbiAgMHg1YjljY2E0ZiwgMHg3NzYzZTM3MywgMHg2ODJlNmZmMywgMHhkNmIyYjhhMyxcclxuICAweDc0OGY4MmVlLCAweDVkZWZiMmZjLCAweDc4YTU2MzZmLCAweDQzMTcyZjYwLFxyXG4gIDB4ODRjODc4MTQsIDB4YTFmMGFiNzIsIDB4OGNjNzAyMDgsIDB4MWE2NDM5ZWMsXHJcbiAgMHg5MGJlZmZmYSwgMHgyMzYzMWUyOCwgMHhhNDUwNmNlYiwgMHhkZTgyYmRlOSxcclxuICAweGJlZjlhM2Y3LCAweGIyYzY3OTE1LCAweGM2NzE3OGYyLCAweGUzNzI1MzJiLFxyXG4gIDB4Y2EyNzNlY2UsIDB4ZWEyNjYxOWMsIDB4ZDE4NmI4YzcsIDB4MjFjMGMyMDcsXHJcbiAgMHhlYWRhN2RkNiwgMHhjZGUwZWIxZSwgMHhmNTdkNGY3ZiwgMHhlZTZlZDE3OCxcclxuICAweDA2ZjA2N2FhLCAweDcyMTc2ZmJhLCAweDBhNjM3ZGM1LCAweGEyYzg5OGE2LFxyXG4gIDB4MTEzZjk4MDQsIDB4YmVmOTBkYWUsIDB4MWI3MTBiMzUsIDB4MTMxYzQ3MWIsXHJcbiAgMHgyOGRiNzdmNSwgMHgyMzA0N2Q4NCwgMHgzMmNhYWI3YiwgMHg0MGM3MjQ5MyxcclxuICAweDNjOWViZTBhLCAweDE1YzliZWJjLCAweDQzMWQ2N2M0LCAweDljMTAwZDRjLFxyXG4gIDB4NGNjNWQ0YmUsIDB4Y2IzZTQyYjYsIDB4NTk3ZjI5OWMsIDB4ZmM2NTdlMmEsXHJcbiAgMHg1ZmNiNmZhYiwgMHgzYWQ2ZmFlYywgMHg2YzQ0MTk4YywgMHg0YTQ3NTgxN1xyXG5dXHJcblxyXG52YXIgVyA9IG5ldyBBcnJheSgxNjApXHJcblxyXG5mdW5jdGlvbiBTaGE1MTIgKCkge1xyXG4gIHRoaXMuaW5pdCgpXHJcbiAgdGhpcy5fdyA9IFdcclxuXHJcbiAgSGFzaC5jYWxsKHRoaXMsIDEyOCwgMTEyKVxyXG59XHJcblxyXG5pbmhlcml0cyhTaGE1MTIsIEhhc2gpXHJcblxyXG5TaGE1MTIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdGhpcy5fYWggPSAweDZhMDllNjY3XHJcbiAgdGhpcy5fYmggPSAweGJiNjdhZTg1XHJcbiAgdGhpcy5fY2ggPSAweDNjNmVmMzcyXHJcbiAgdGhpcy5fZGggPSAweGE1NGZmNTNhXHJcbiAgdGhpcy5fZWggPSAweDUxMGU1MjdmXHJcbiAgdGhpcy5fZmggPSAweDliMDU2ODhjXHJcbiAgdGhpcy5fZ2ggPSAweDFmODNkOWFiXHJcbiAgdGhpcy5faGggPSAweDViZTBjZDE5XHJcblxyXG4gIHRoaXMuX2FsID0gMHhmM2JjYzkwOFxyXG4gIHRoaXMuX2JsID0gMHg4NGNhYTczYlxyXG4gIHRoaXMuX2NsID0gMHhmZTk0ZjgyYlxyXG4gIHRoaXMuX2RsID0gMHg1ZjFkMzZmMVxyXG4gIHRoaXMuX2VsID0gMHhhZGU2ODJkMVxyXG4gIHRoaXMuX2ZsID0gMHgyYjNlNmMxZlxyXG4gIHRoaXMuX2dsID0gMHhmYjQxYmQ2YlxyXG4gIHRoaXMuX2hsID0gMHgxMzdlMjE3OVxyXG5cclxuICByZXR1cm4gdGhpc1xyXG59XHJcblxyXG5mdW5jdGlvbiBDaCAoeCwgeSwgeikge1xyXG4gIHJldHVybiB6IF4gKHggJiAoeSBeIHopKVxyXG59XHJcblxyXG5mdW5jdGlvbiBtYWogKHgsIHksIHopIHtcclxuICByZXR1cm4gKHggJiB5KSB8ICh6ICYgKHggfCB5KSlcclxufVxyXG5cclxuZnVuY3Rpb24gc2lnbWEwICh4LCB4bCkge1xyXG4gIHJldHVybiAoeCA+Pj4gMjggfCB4bCA8PCA0KSBeICh4bCA+Pj4gMiB8IHggPDwgMzApIF4gKHhsID4+PiA3IHwgeCA8PCAyNSlcclxufVxyXG5cclxuZnVuY3Rpb24gc2lnbWExICh4LCB4bCkge1xyXG4gIHJldHVybiAoeCA+Pj4gMTQgfCB4bCA8PCAxOCkgXiAoeCA+Pj4gMTggfCB4bCA8PCAxNCkgXiAoeGwgPj4+IDkgfCB4IDw8IDIzKVxyXG59XHJcblxyXG5mdW5jdGlvbiBHYW1tYTAgKHgsIHhsKSB7XHJcbiAgcmV0dXJuICh4ID4+PiAxIHwgeGwgPDwgMzEpIF4gKHggPj4+IDggfCB4bCA8PCAyNCkgXiAoeCA+Pj4gNylcclxufVxyXG5cclxuZnVuY3Rpb24gR2FtbWEwbCAoeCwgeGwpIHtcclxuICByZXR1cm4gKHggPj4+IDEgfCB4bCA8PCAzMSkgXiAoeCA+Pj4gOCB8IHhsIDw8IDI0KSBeICh4ID4+PiA3IHwgeGwgPDwgMjUpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIEdhbW1hMSAoeCwgeGwpIHtcclxuICByZXR1cm4gKHggPj4+IDE5IHwgeGwgPDwgMTMpIF4gKHhsID4+PiAyOSB8IHggPDwgMykgXiAoeCA+Pj4gNilcclxufVxyXG5cclxuZnVuY3Rpb24gR2FtbWExbCAoeCwgeGwpIHtcclxuICByZXR1cm4gKHggPj4+IDE5IHwgeGwgPDwgMTMpIF4gKHhsID4+PiAyOSB8IHggPDwgMykgXiAoeCA+Pj4gNiB8IHhsIDw8IDI2KVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRDYXJyeSAoYSwgYikge1xyXG4gIHJldHVybiAoYSA+Pj4gMCkgPCAoYiA+Pj4gMCkgPyAxIDogMFxyXG59XHJcblxyXG5TaGE1MTIucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoTSkge1xyXG4gIHZhciBXID0gdGhpcy5fd1xyXG5cclxuICB2YXIgYWggPSB0aGlzLl9haCB8IDBcclxuICB2YXIgYmggPSB0aGlzLl9iaCB8IDBcclxuICB2YXIgY2ggPSB0aGlzLl9jaCB8IDBcclxuICB2YXIgZGggPSB0aGlzLl9kaCB8IDBcclxuICB2YXIgZWggPSB0aGlzLl9laCB8IDBcclxuICB2YXIgZmggPSB0aGlzLl9maCB8IDBcclxuICB2YXIgZ2ggPSB0aGlzLl9naCB8IDBcclxuICB2YXIgaGggPSB0aGlzLl9oaCB8IDBcclxuXHJcbiAgdmFyIGFsID0gdGhpcy5fYWwgfCAwXHJcbiAgdmFyIGJsID0gdGhpcy5fYmwgfCAwXHJcbiAgdmFyIGNsID0gdGhpcy5fY2wgfCAwXHJcbiAgdmFyIGRsID0gdGhpcy5fZGwgfCAwXHJcbiAgdmFyIGVsID0gdGhpcy5fZWwgfCAwXHJcbiAgdmFyIGZsID0gdGhpcy5fZmwgfCAwXHJcbiAgdmFyIGdsID0gdGhpcy5fZ2wgfCAwXHJcbiAgdmFyIGhsID0gdGhpcy5faGwgfCAwXHJcblxyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMzI7IGkgKz0gMikge1xyXG4gICAgV1tpXSA9IE0ucmVhZEludDMyQkUoaSAqIDQpXHJcbiAgICBXW2kgKyAxXSA9IE0ucmVhZEludDMyQkUoaSAqIDQgKyA0KVxyXG4gIH1cclxuICBmb3IgKDsgaSA8IDE2MDsgaSArPSAyKSB7XHJcbiAgICB2YXIgeGggPSBXW2kgLSAxNSAqIDJdXHJcbiAgICB2YXIgeGwgPSBXW2kgLSAxNSAqIDIgKyAxXVxyXG4gICAgdmFyIGdhbW1hMCA9IEdhbW1hMCh4aCwgeGwpXHJcbiAgICB2YXIgZ2FtbWEwbCA9IEdhbW1hMGwoeGwsIHhoKVxyXG5cclxuICAgIHhoID0gV1tpIC0gMiAqIDJdXHJcbiAgICB4bCA9IFdbaSAtIDIgKiAyICsgMV1cclxuICAgIHZhciBnYW1tYTEgPSBHYW1tYTEoeGgsIHhsKVxyXG4gICAgdmFyIGdhbW1hMWwgPSBHYW1tYTFsKHhsLCB4aClcclxuXHJcbiAgICAvLyBXW2ldID0gZ2FtbWEwICsgV1tpIC0gN10gKyBnYW1tYTEgKyBXW2kgLSAxNl1cclxuICAgIHZhciBXaTdoID0gV1tpIC0gNyAqIDJdXHJcbiAgICB2YXIgV2k3bCA9IFdbaSAtIDcgKiAyICsgMV1cclxuXHJcbiAgICB2YXIgV2kxNmggPSBXW2kgLSAxNiAqIDJdXHJcbiAgICB2YXIgV2kxNmwgPSBXW2kgLSAxNiAqIDIgKyAxXVxyXG5cclxuICAgIHZhciBXaWwgPSAoZ2FtbWEwbCArIFdpN2wpIHwgMFxyXG4gICAgdmFyIFdpaCA9IChnYW1tYTAgKyBXaTdoICsgZ2V0Q2FycnkoV2lsLCBnYW1tYTBsKSkgfCAwXHJcbiAgICBXaWwgPSAoV2lsICsgZ2FtbWExbCkgfCAwXHJcbiAgICBXaWggPSAoV2loICsgZ2FtbWExICsgZ2V0Q2FycnkoV2lsLCBnYW1tYTFsKSkgfCAwXHJcbiAgICBXaWwgPSAoV2lsICsgV2kxNmwpIHwgMFxyXG4gICAgV2loID0gKFdpaCArIFdpMTZoICsgZ2V0Q2FycnkoV2lsLCBXaTE2bCkpIHwgMFxyXG5cclxuICAgIFdbaV0gPSBXaWhcclxuICAgIFdbaSArIDFdID0gV2lsXHJcbiAgfVxyXG5cclxuICBmb3IgKHZhciBqID0gMDsgaiA8IDE2MDsgaiArPSAyKSB7XHJcbiAgICBXaWggPSBXW2pdXHJcbiAgICBXaWwgPSBXW2ogKyAxXVxyXG5cclxuICAgIHZhciBtYWpoID0gbWFqKGFoLCBiaCwgY2gpXHJcbiAgICB2YXIgbWFqbCA9IG1haihhbCwgYmwsIGNsKVxyXG5cclxuICAgIHZhciBzaWdtYTBoID0gc2lnbWEwKGFoLCBhbClcclxuICAgIHZhciBzaWdtYTBsID0gc2lnbWEwKGFsLCBhaClcclxuICAgIHZhciBzaWdtYTFoID0gc2lnbWExKGVoLCBlbClcclxuICAgIHZhciBzaWdtYTFsID0gc2lnbWExKGVsLCBlaClcclxuXHJcbiAgICAvLyB0MSA9IGggKyBzaWdtYTEgKyBjaCArIEtbal0gKyBXW2pdXHJcbiAgICB2YXIgS2loID0gS1tqXVxyXG4gICAgdmFyIEtpbCA9IEtbaiArIDFdXHJcblxyXG4gICAgdmFyIGNoaCA9IENoKGVoLCBmaCwgZ2gpXHJcbiAgICB2YXIgY2hsID0gQ2goZWwsIGZsLCBnbClcclxuXHJcbiAgICB2YXIgdDFsID0gKGhsICsgc2lnbWExbCkgfCAwXHJcbiAgICB2YXIgdDFoID0gKGhoICsgc2lnbWExaCArIGdldENhcnJ5KHQxbCwgaGwpKSB8IDBcclxuICAgIHQxbCA9ICh0MWwgKyBjaGwpIHwgMFxyXG4gICAgdDFoID0gKHQxaCArIGNoaCArIGdldENhcnJ5KHQxbCwgY2hsKSkgfCAwXHJcbiAgICB0MWwgPSAodDFsICsgS2lsKSB8IDBcclxuICAgIHQxaCA9ICh0MWggKyBLaWggKyBnZXRDYXJyeSh0MWwsIEtpbCkpIHwgMFxyXG4gICAgdDFsID0gKHQxbCArIFdpbCkgfCAwXHJcbiAgICB0MWggPSAodDFoICsgV2loICsgZ2V0Q2FycnkodDFsLCBXaWwpKSB8IDBcclxuXHJcbiAgICAvLyB0MiA9IHNpZ21hMCArIG1halxyXG4gICAgdmFyIHQybCA9IChzaWdtYTBsICsgbWFqbCkgfCAwXHJcbiAgICB2YXIgdDJoID0gKHNpZ21hMGggKyBtYWpoICsgZ2V0Q2FycnkodDJsLCBzaWdtYTBsKSkgfCAwXHJcblxyXG4gICAgaGggPSBnaFxyXG4gICAgaGwgPSBnbFxyXG4gICAgZ2ggPSBmaFxyXG4gICAgZ2wgPSBmbFxyXG4gICAgZmggPSBlaFxyXG4gICAgZmwgPSBlbFxyXG4gICAgZWwgPSAoZGwgKyB0MWwpIHwgMFxyXG4gICAgZWggPSAoZGggKyB0MWggKyBnZXRDYXJyeShlbCwgZGwpKSB8IDBcclxuICAgIGRoID0gY2hcclxuICAgIGRsID0gY2xcclxuICAgIGNoID0gYmhcclxuICAgIGNsID0gYmxcclxuICAgIGJoID0gYWhcclxuICAgIGJsID0gYWxcclxuICAgIGFsID0gKHQxbCArIHQybCkgfCAwXHJcbiAgICBhaCA9ICh0MWggKyB0MmggKyBnZXRDYXJyeShhbCwgdDFsKSkgfCAwXHJcbiAgfVxyXG5cclxuICB0aGlzLl9hbCA9ICh0aGlzLl9hbCArIGFsKSB8IDBcclxuICB0aGlzLl9ibCA9ICh0aGlzLl9ibCArIGJsKSB8IDBcclxuICB0aGlzLl9jbCA9ICh0aGlzLl9jbCArIGNsKSB8IDBcclxuICB0aGlzLl9kbCA9ICh0aGlzLl9kbCArIGRsKSB8IDBcclxuICB0aGlzLl9lbCA9ICh0aGlzLl9lbCArIGVsKSB8IDBcclxuICB0aGlzLl9mbCA9ICh0aGlzLl9mbCArIGZsKSB8IDBcclxuICB0aGlzLl9nbCA9ICh0aGlzLl9nbCArIGdsKSB8IDBcclxuICB0aGlzLl9obCA9ICh0aGlzLl9obCArIGhsKSB8IDBcclxuXHJcbiAgdGhpcy5fYWggPSAodGhpcy5fYWggKyBhaCArIGdldENhcnJ5KHRoaXMuX2FsLCBhbCkpIHwgMFxyXG4gIHRoaXMuX2JoID0gKHRoaXMuX2JoICsgYmggKyBnZXRDYXJyeSh0aGlzLl9ibCwgYmwpKSB8IDBcclxuICB0aGlzLl9jaCA9ICh0aGlzLl9jaCArIGNoICsgZ2V0Q2FycnkodGhpcy5fY2wsIGNsKSkgfCAwXHJcbiAgdGhpcy5fZGggPSAodGhpcy5fZGggKyBkaCArIGdldENhcnJ5KHRoaXMuX2RsLCBkbCkpIHwgMFxyXG4gIHRoaXMuX2VoID0gKHRoaXMuX2VoICsgZWggKyBnZXRDYXJyeSh0aGlzLl9lbCwgZWwpKSB8IDBcclxuICB0aGlzLl9maCA9ICh0aGlzLl9maCArIGZoICsgZ2V0Q2FycnkodGhpcy5fZmwsIGZsKSkgfCAwXHJcbiAgdGhpcy5fZ2ggPSAodGhpcy5fZ2ggKyBnaCArIGdldENhcnJ5KHRoaXMuX2dsLCBnbCkpIHwgMFxyXG4gIHRoaXMuX2hoID0gKHRoaXMuX2hoICsgaGggKyBnZXRDYXJyeSh0aGlzLl9obCwgaGwpKSB8IDBcclxufVxyXG5cclxuU2hhNTEyLnByb3RvdHlwZS5faGFzaCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgSCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg2NClcclxuXHJcbiAgZnVuY3Rpb24gd3JpdGVJbnQ2NEJFIChoLCBsLCBvZmZzZXQpIHtcclxuICAgIEgud3JpdGVJbnQzMkJFKGgsIG9mZnNldClcclxuICAgIEgud3JpdGVJbnQzMkJFKGwsIG9mZnNldCArIDQpXHJcbiAgfVxyXG5cclxuICB3cml0ZUludDY0QkUodGhpcy5fYWgsIHRoaXMuX2FsLCAwKVxyXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9iaCwgdGhpcy5fYmwsIDgpXHJcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2NoLCB0aGlzLl9jbCwgMTYpXHJcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2RoLCB0aGlzLl9kbCwgMjQpXHJcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2VoLCB0aGlzLl9lbCwgMzIpXHJcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2ZoLCB0aGlzLl9mbCwgNDApXHJcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2doLCB0aGlzLl9nbCwgNDgpXHJcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2hoLCB0aGlzLl9obCwgNTYpXHJcblxyXG4gIHJldHVybiBIXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2hhNTEyXHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/sha.js/sha512.js\n");

/***/ }),

/***/ "./node_modules/string_decoder/lib/string_decoder.js":
/*!***********************************************************!*\
  !*** ./node_modules/string_decoder/lib/string_decoder.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the\r\n// \"Software\"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n// persons to whom the Software is furnished to do so, subject to the\r\n// following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n\r\n\r\n/*<replacement>*/\r\n\r\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer);\r\n/*</replacement>*/\r\n\r\nvar isEncoding = Buffer.isEncoding || function (encoding) {\r\n  encoding = '' + encoding;\r\n  switch (encoding && encoding.toLowerCase()) {\r\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\r\n      return true;\r\n    default:\r\n      return false;\r\n  }\r\n};\r\n\r\nfunction _normalizeEncoding(enc) {\r\n  if (!enc) return 'utf8';\r\n  var retried;\r\n  while (true) {\r\n    switch (enc) {\r\n      case 'utf8':\r\n      case 'utf-8':\r\n        return 'utf8';\r\n      case 'ucs2':\r\n      case 'ucs-2':\r\n      case 'utf16le':\r\n      case 'utf-16le':\r\n        return 'utf16le';\r\n      case 'latin1':\r\n      case 'binary':\r\n        return 'latin1';\r\n      case 'base64':\r\n      case 'ascii':\r\n      case 'hex':\r\n        return enc;\r\n      default:\r\n        if (retried) return; // undefined\r\n        enc = ('' + enc).toLowerCase();\r\n        retried = true;\r\n    }\r\n  }\r\n};\r\n\r\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\r\n// modules monkey-patch it to support additional encodings\r\nfunction normalizeEncoding(enc) {\r\n  var nenc = _normalizeEncoding(enc);\r\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\r\n  return nenc || enc;\r\n}\r\n\r\n// StringDecoder provides an interface for efficiently splitting a series of\r\n// buffers into a series of JS strings without breaking apart multi-byte\r\n// characters.\r\nexports.StringDecoder = StringDecoder;\r\nfunction StringDecoder(encoding) {\r\n  this.encoding = normalizeEncoding(encoding);\r\n  var nb;\r\n  switch (this.encoding) {\r\n    case 'utf16le':\r\n      this.text = utf16Text;\r\n      this.end = utf16End;\r\n      nb = 4;\r\n      break;\r\n    case 'utf8':\r\n      this.fillLast = utf8FillLast;\r\n      nb = 4;\r\n      break;\r\n    case 'base64':\r\n      this.text = base64Text;\r\n      this.end = base64End;\r\n      nb = 3;\r\n      break;\r\n    default:\r\n      this.write = simpleWrite;\r\n      this.end = simpleEnd;\r\n      return;\r\n  }\r\n  this.lastNeed = 0;\r\n  this.lastTotal = 0;\r\n  this.lastChar = Buffer.allocUnsafe(nb);\r\n}\r\n\r\nStringDecoder.prototype.write = function (buf) {\r\n  if (buf.length === 0) return '';\r\n  var r;\r\n  var i;\r\n  if (this.lastNeed) {\r\n    r = this.fillLast(buf);\r\n    if (r === undefined) return '';\r\n    i = this.lastNeed;\r\n    this.lastNeed = 0;\r\n  } else {\r\n    i = 0;\r\n  }\r\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\r\n  return r || '';\r\n};\r\n\r\nStringDecoder.prototype.end = utf8End;\r\n\r\n// Returns only complete characters in a Buffer\r\nStringDecoder.prototype.text = utf8Text;\r\n\r\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\r\nStringDecoder.prototype.fillLast = function (buf) {\r\n  if (this.lastNeed <= buf.length) {\r\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\r\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\r\n  }\r\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\r\n  this.lastNeed -= buf.length;\r\n};\r\n\r\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\r\n// continuation byte. If an invalid byte is detected, -2 is returned.\r\nfunction utf8CheckByte(byte) {\r\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\r\n  return byte >> 6 === 0x02 ? -1 : -2;\r\n}\r\n\r\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\r\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\r\n// needed to complete the UTF-8 character (if applicable) are returned.\r\nfunction utf8CheckIncomplete(self, buf, i) {\r\n  var j = buf.length - 1;\r\n  if (j < i) return 0;\r\n  var nb = utf8CheckByte(buf[j]);\r\n  if (nb >= 0) {\r\n    if (nb > 0) self.lastNeed = nb - 1;\r\n    return nb;\r\n  }\r\n  if (--j < i || nb === -2) return 0;\r\n  nb = utf8CheckByte(buf[j]);\r\n  if (nb >= 0) {\r\n    if (nb > 0) self.lastNeed = nb - 2;\r\n    return nb;\r\n  }\r\n  if (--j < i || nb === -2) return 0;\r\n  nb = utf8CheckByte(buf[j]);\r\n  if (nb >= 0) {\r\n    if (nb > 0) {\r\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\r\n    }\r\n    return nb;\r\n  }\r\n  return 0;\r\n}\r\n\r\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\r\n// needed or are available. If we see a non-continuation byte where we expect\r\n// one, we \"replace\" the validated continuation bytes we've seen so far with\r\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\r\n// behavior. The continuation byte check is included three times in the case\r\n// where all of the continuation bytes for a character exist in the same buffer.\r\n// It is also done this way as a slight performance increase instead of using a\r\n// loop.\r\nfunction utf8CheckExtraBytes(self, buf, p) {\r\n  if ((buf[0] & 0xC0) !== 0x80) {\r\n    self.lastNeed = 0;\r\n    return '\\ufffd';\r\n  }\r\n  if (self.lastNeed > 1 && buf.length > 1) {\r\n    if ((buf[1] & 0xC0) !== 0x80) {\r\n      self.lastNeed = 1;\r\n      return '\\ufffd';\r\n    }\r\n    if (self.lastNeed > 2 && buf.length > 2) {\r\n      if ((buf[2] & 0xC0) !== 0x80) {\r\n        self.lastNeed = 2;\r\n        return '\\ufffd';\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\r\nfunction utf8FillLast(buf) {\r\n  var p = this.lastTotal - this.lastNeed;\r\n  var r = utf8CheckExtraBytes(this, buf, p);\r\n  if (r !== undefined) return r;\r\n  if (this.lastNeed <= buf.length) {\r\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\r\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\r\n  }\r\n  buf.copy(this.lastChar, p, 0, buf.length);\r\n  this.lastNeed -= buf.length;\r\n}\r\n\r\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\r\n// partial character, the character's bytes are buffered until the required\r\n// number of bytes are available.\r\nfunction utf8Text(buf, i) {\r\n  var total = utf8CheckIncomplete(this, buf, i);\r\n  if (!this.lastNeed) return buf.toString('utf8', i);\r\n  this.lastTotal = total;\r\n  var end = buf.length - (total - this.lastNeed);\r\n  buf.copy(this.lastChar, 0, end);\r\n  return buf.toString('utf8', i, end);\r\n}\r\n\r\n// For UTF-8, a replacement character is added when ending on a partial\r\n// character.\r\nfunction utf8End(buf) {\r\n  var r = buf && buf.length ? this.write(buf) : '';\r\n  if (this.lastNeed) return r + '\\ufffd';\r\n  return r;\r\n}\r\n\r\n// UTF-16LE typically needs two bytes per character, but even if we have an even\r\n// number of bytes available, we need to check if we end on a leading/high\r\n// surrogate. In that case, we need to wait for the next two bytes in order to\r\n// decode the last character properly.\r\nfunction utf16Text(buf, i) {\r\n  if ((buf.length - i) % 2 === 0) {\r\n    var r = buf.toString('utf16le', i);\r\n    if (r) {\r\n      var c = r.charCodeAt(r.length - 1);\r\n      if (c >= 0xD800 && c <= 0xDBFF) {\r\n        this.lastNeed = 2;\r\n        this.lastTotal = 4;\r\n        this.lastChar[0] = buf[buf.length - 2];\r\n        this.lastChar[1] = buf[buf.length - 1];\r\n        return r.slice(0, -1);\r\n      }\r\n    }\r\n    return r;\r\n  }\r\n  this.lastNeed = 1;\r\n  this.lastTotal = 2;\r\n  this.lastChar[0] = buf[buf.length - 1];\r\n  return buf.toString('utf16le', i, buf.length - 1);\r\n}\r\n\r\n// For UTF-16LE we do not explicitly append special replacement characters if we\r\n// end on a partial character, we simply let v8 handle that.\r\nfunction utf16End(buf) {\r\n  var r = buf && buf.length ? this.write(buf) : '';\r\n  if (this.lastNeed) {\r\n    var end = this.lastTotal - this.lastNeed;\r\n    return r + this.lastChar.toString('utf16le', 0, end);\r\n  }\r\n  return r;\r\n}\r\n\r\nfunction base64Text(buf, i) {\r\n  var n = (buf.length - i) % 3;\r\n  if (n === 0) return buf.toString('base64', i);\r\n  this.lastNeed = 3 - n;\r\n  this.lastTotal = 3;\r\n  if (n === 1) {\r\n    this.lastChar[0] = buf[buf.length - 1];\r\n  } else {\r\n    this.lastChar[0] = buf[buf.length - 2];\r\n    this.lastChar[1] = buf[buf.length - 1];\r\n  }\r\n  return buf.toString('base64', i, buf.length - n);\r\n}\r\n\r\nfunction base64End(buf) {\r\n  var r = buf && buf.length ? this.write(buf) : '';\r\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\r\n  return r;\r\n}\r\n\r\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\r\nfunction simpleWrite(buf) {\r\n  return buf.toString(this.encoding);\r\n}\r\n\r\nfunction simpleEnd(buf) {\r\n  return buf && buf.length ? this.write(buf) : '';\r\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvbGliL3N0cmluZ19kZWNvZGVyLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzRkFBNkI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNDQUFzQyxzQ0FBc0M7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3N0cmluZ19kZWNvZGVyL2xpYi9zdHJpbmdfZGVjb2Rlci5qcz84MmQwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxyXG4vL1xyXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxyXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXHJcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xyXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXHJcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcclxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXHJcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG4vL1xyXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxyXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuLy9cclxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xyXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXHJcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cclxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXHJcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxyXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXHJcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG4vKjxyZXBsYWNlbWVudD4qL1xyXG5cclxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xyXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cclxuXHJcbnZhciBpc0VuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmcgfHwgZnVuY3Rpb24gKGVuY29kaW5nKSB7XHJcbiAgZW5jb2RpbmcgPSAnJyArIGVuY29kaW5nO1xyXG4gIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgY2FzZSAnaGV4JzpjYXNlICd1dGY4JzpjYXNlICd1dGYtOCc6Y2FzZSAnYXNjaWknOmNhc2UgJ2JpbmFyeSc6Y2FzZSAnYmFzZTY0JzpjYXNlICd1Y3MyJzpjYXNlICd1Y3MtMic6Y2FzZSAndXRmMTZsZSc6Y2FzZSAndXRmLTE2bGUnOmNhc2UgJ3Jhdyc6XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIF9ub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcclxuICBpZiAoIWVuYykgcmV0dXJuICd1dGY4JztcclxuICB2YXIgcmV0cmllZDtcclxuICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgc3dpdGNoIChlbmMpIHtcclxuICAgICAgY2FzZSAndXRmOCc6XHJcbiAgICAgIGNhc2UgJ3V0Zi04JzpcclxuICAgICAgICByZXR1cm4gJ3V0ZjgnO1xyXG4gICAgICBjYXNlICd1Y3MyJzpcclxuICAgICAgY2FzZSAndWNzLTInOlxyXG4gICAgICBjYXNlICd1dGYxNmxlJzpcclxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxyXG4gICAgICAgIHJldHVybiAndXRmMTZsZSc7XHJcbiAgICAgIGNhc2UgJ2xhdGluMSc6XHJcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XHJcbiAgICAgICAgcmV0dXJuICdsYXRpbjEnO1xyXG4gICAgICBjYXNlICdiYXNlNjQnOlxyXG4gICAgICBjYXNlICdhc2NpaSc6XHJcbiAgICAgIGNhc2UgJ2hleCc6XHJcbiAgICAgICAgcmV0dXJuIGVuYztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICBpZiAocmV0cmllZCkgcmV0dXJuOyAvLyB1bmRlZmluZWRcclxuICAgICAgICBlbmMgPSAoJycgKyBlbmMpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgcmV0cmllZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gRG8gbm90IGNhY2hlIGBCdWZmZXIuaXNFbmNvZGluZ2Agd2hlbiBjaGVja2luZyBlbmNvZGluZyBuYW1lcyBhcyBzb21lXHJcbi8vIG1vZHVsZXMgbW9ua2V5LXBhdGNoIGl0IHRvIHN1cHBvcnQgYWRkaXRpb25hbCBlbmNvZGluZ3NcclxuZnVuY3Rpb24gbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XHJcbiAgdmFyIG5lbmMgPSBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKTtcclxuICBpZiAodHlwZW9mIG5lbmMgIT09ICdzdHJpbmcnICYmIChCdWZmZXIuaXNFbmNvZGluZyA9PT0gaXNFbmNvZGluZyB8fCAhaXNFbmNvZGluZyhlbmMpKSkgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jKTtcclxuICByZXR1cm4gbmVuYyB8fCBlbmM7XHJcbn1cclxuXHJcbi8vIFN0cmluZ0RlY29kZXIgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBlZmZpY2llbnRseSBzcGxpdHRpbmcgYSBzZXJpZXMgb2ZcclxuLy8gYnVmZmVycyBpbnRvIGEgc2VyaWVzIG9mIEpTIHN0cmluZ3Mgd2l0aG91dCBicmVha2luZyBhcGFydCBtdWx0aS1ieXRlXHJcbi8vIGNoYXJhY3RlcnMuXHJcbmV4cG9ydHMuU3RyaW5nRGVjb2RlciA9IFN0cmluZ0RlY29kZXI7XHJcbmZ1bmN0aW9uIFN0cmluZ0RlY29kZXIoZW5jb2RpbmcpIHtcclxuICB0aGlzLmVuY29kaW5nID0gbm9ybWFsaXplRW5jb2RpbmcoZW5jb2RpbmcpO1xyXG4gIHZhciBuYjtcclxuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcclxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxyXG4gICAgICB0aGlzLnRleHQgPSB1dGYxNlRleHQ7XHJcbiAgICAgIHRoaXMuZW5kID0gdXRmMTZFbmQ7XHJcbiAgICAgIG5iID0gNDtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlICd1dGY4JzpcclxuICAgICAgdGhpcy5maWxsTGFzdCA9IHV0ZjhGaWxsTGFzdDtcclxuICAgICAgbmIgPSA0O1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgJ2Jhc2U2NCc6XHJcbiAgICAgIHRoaXMudGV4dCA9IGJhc2U2NFRleHQ7XHJcbiAgICAgIHRoaXMuZW5kID0gYmFzZTY0RW5kO1xyXG4gICAgICBuYiA9IDM7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgdGhpcy53cml0ZSA9IHNpbXBsZVdyaXRlO1xyXG4gICAgICB0aGlzLmVuZCA9IHNpbXBsZUVuZDtcclxuICAgICAgcmV0dXJuO1xyXG4gIH1cclxuICB0aGlzLmxhc3ROZWVkID0gMDtcclxuICB0aGlzLmxhc3RUb3RhbCA9IDA7XHJcbiAgdGhpcy5sYXN0Q2hhciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuYik7XHJcbn1cclxuXHJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGJ1Zikge1xyXG4gIGlmIChidWYubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XHJcbiAgdmFyIHI7XHJcbiAgdmFyIGk7XHJcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcclxuICAgIHIgPSB0aGlzLmZpbGxMYXN0KGJ1Zik7XHJcbiAgICBpZiAociA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJyc7XHJcbiAgICBpID0gdGhpcy5sYXN0TmVlZDtcclxuICAgIHRoaXMubGFzdE5lZWQgPSAwO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBpID0gMDtcclxuICB9XHJcbiAgaWYgKGkgPCBidWYubGVuZ3RoKSByZXR1cm4gciA/IHIgKyB0aGlzLnRleHQoYnVmLCBpKSA6IHRoaXMudGV4dChidWYsIGkpO1xyXG4gIHJldHVybiByIHx8ICcnO1xyXG59O1xyXG5cclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gdXRmOEVuZDtcclxuXHJcbi8vIFJldHVybnMgb25seSBjb21wbGV0ZSBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyXHJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLnRleHQgPSB1dGY4VGV4dDtcclxuXHJcbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgcGFydGlhbCBub24tVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXJcclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZmlsbExhc3QgPSBmdW5jdGlvbiAoYnVmKSB7XHJcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xyXG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCB0aGlzLmxhc3ROZWVkKTtcclxuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcclxuICB9XHJcbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCBidWYubGVuZ3RoKTtcclxuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XHJcbn07XHJcblxyXG4vLyBDaGVja3MgdGhlIHR5cGUgb2YgYSBVVEYtOCBieXRlLCB3aGV0aGVyIGl0J3MgQVNDSUksIGEgbGVhZGluZyBieXRlLCBvciBhXHJcbi8vIGNvbnRpbnVhdGlvbiBieXRlLiBJZiBhbiBpbnZhbGlkIGJ5dGUgaXMgZGV0ZWN0ZWQsIC0yIGlzIHJldHVybmVkLlxyXG5mdW5jdGlvbiB1dGY4Q2hlY2tCeXRlKGJ5dGUpIHtcclxuICBpZiAoYnl0ZSA8PSAweDdGKSByZXR1cm4gMDtlbHNlIGlmIChieXRlID4+IDUgPT09IDB4MDYpIHJldHVybiAyO2Vsc2UgaWYgKGJ5dGUgPj4gNCA9PT0gMHgwRSkgcmV0dXJuIDM7ZWxzZSBpZiAoYnl0ZSA+PiAzID09PSAweDFFKSByZXR1cm4gNDtcclxuICByZXR1cm4gYnl0ZSA+PiA2ID09PSAweDAyID8gLTEgOiAtMjtcclxufVxyXG5cclxuLy8gQ2hlY2tzIGF0IG1vc3QgMyBieXRlcyBhdCB0aGUgZW5kIG9mIGEgQnVmZmVyIGluIG9yZGVyIHRvIGRldGVjdCBhblxyXG4vLyBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyLiBUaGUgdG90YWwgbnVtYmVyIG9mIGJ5dGVzICgyLCAzLCBvciA0KVxyXG4vLyBuZWVkZWQgdG8gY29tcGxldGUgdGhlIFVURi04IGNoYXJhY3RlciAoaWYgYXBwbGljYWJsZSkgYXJlIHJldHVybmVkLlxyXG5mdW5jdGlvbiB1dGY4Q2hlY2tJbmNvbXBsZXRlKHNlbGYsIGJ1ZiwgaSkge1xyXG4gIHZhciBqID0gYnVmLmxlbmd0aCAtIDE7XHJcbiAgaWYgKGogPCBpKSByZXR1cm4gMDtcclxuICB2YXIgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XHJcbiAgaWYgKG5iID49IDApIHtcclxuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDE7XHJcbiAgICByZXR1cm4gbmI7XHJcbiAgfVxyXG4gIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7XHJcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XHJcbiAgaWYgKG5iID49IDApIHtcclxuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDI7XHJcbiAgICByZXR1cm4gbmI7XHJcbiAgfVxyXG4gIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7XHJcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XHJcbiAgaWYgKG5iID49IDApIHtcclxuICAgIGlmIChuYiA+IDApIHtcclxuICAgICAgaWYgKG5iID09PSAyKSBuYiA9IDA7ZWxzZSBzZWxmLmxhc3ROZWVkID0gbmIgLSAzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5iO1xyXG4gIH1cclxuICByZXR1cm4gMDtcclxufVxyXG5cclxuLy8gVmFsaWRhdGVzIGFzIG1hbnkgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIGFzXHJcbi8vIG5lZWRlZCBvciBhcmUgYXZhaWxhYmxlLiBJZiB3ZSBzZWUgYSBub24tY29udGludWF0aW9uIGJ5dGUgd2hlcmUgd2UgZXhwZWN0XHJcbi8vIG9uZSwgd2UgXCJyZXBsYWNlXCIgdGhlIHZhbGlkYXRlZCBjb250aW51YXRpb24gYnl0ZXMgd2UndmUgc2VlbiBzbyBmYXIgd2l0aFxyXG4vLyBhIHNpbmdsZSBVVEYtOCByZXBsYWNlbWVudCBjaGFyYWN0ZXIgKCdcXHVmZmZkJyksIHRvIG1hdGNoIHY4J3MgVVRGLTggZGVjb2RpbmdcclxuLy8gYmVoYXZpb3IuIFRoZSBjb250aW51YXRpb24gYnl0ZSBjaGVjayBpcyBpbmNsdWRlZCB0aHJlZSB0aW1lcyBpbiB0aGUgY2FzZVxyXG4vLyB3aGVyZSBhbGwgb2YgdGhlIGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBjaGFyYWN0ZXIgZXhpc3QgaW4gdGhlIHNhbWUgYnVmZmVyLlxyXG4vLyBJdCBpcyBhbHNvIGRvbmUgdGhpcyB3YXkgYXMgYSBzbGlnaHQgcGVyZm9ybWFuY2UgaW5jcmVhc2UgaW5zdGVhZCBvZiB1c2luZyBhXHJcbi8vIGxvb3AuXHJcbmZ1bmN0aW9uIHV0ZjhDaGVja0V4dHJhQnl0ZXMoc2VsZiwgYnVmLCBwKSB7XHJcbiAgaWYgKChidWZbMF0gJiAweEMwKSAhPT0gMHg4MCkge1xyXG4gICAgc2VsZi5sYXN0TmVlZCA9IDA7XHJcbiAgICByZXR1cm4gJ1xcdWZmZmQnO1xyXG4gIH1cclxuICBpZiAoc2VsZi5sYXN0TmVlZCA+IDEgJiYgYnVmLmxlbmd0aCA+IDEpIHtcclxuICAgIGlmICgoYnVmWzFdICYgMHhDMCkgIT09IDB4ODApIHtcclxuICAgICAgc2VsZi5sYXN0TmVlZCA9IDE7XHJcbiAgICAgIHJldHVybiAnXFx1ZmZmZCc7XHJcbiAgICB9XHJcbiAgICBpZiAoc2VsZi5sYXN0TmVlZCA+IDIgJiYgYnVmLmxlbmd0aCA+IDIpIHtcclxuICAgICAgaWYgKChidWZbMl0gJiAweEMwKSAhPT0gMHg4MCkge1xyXG4gICAgICAgIHNlbGYubGFzdE5lZWQgPSAyO1xyXG4gICAgICAgIHJldHVybiAnXFx1ZmZmZCc7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlci5cclxuZnVuY3Rpb24gdXRmOEZpbGxMYXN0KGJ1Zikge1xyXG4gIHZhciBwID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xyXG4gIHZhciByID0gdXRmOENoZWNrRXh0cmFCeXRlcyh0aGlzLCBidWYsIHApO1xyXG4gIGlmIChyICE9PSB1bmRlZmluZWQpIHJldHVybiByO1xyXG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcclxuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIHRoaXMubGFzdE5lZWQpO1xyXG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xyXG4gIH1cclxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCBidWYubGVuZ3RoKTtcclxuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XHJcbn1cclxuXHJcbi8vIFJldHVybnMgYWxsIGNvbXBsZXRlIFVURi04IGNoYXJhY3RlcnMgaW4gYSBCdWZmZXIuIElmIHRoZSBCdWZmZXIgZW5kZWQgb24gYVxyXG4vLyBwYXJ0aWFsIGNoYXJhY3RlciwgdGhlIGNoYXJhY3RlcidzIGJ5dGVzIGFyZSBidWZmZXJlZCB1bnRpbCB0aGUgcmVxdWlyZWRcclxuLy8gbnVtYmVyIG9mIGJ5dGVzIGFyZSBhdmFpbGFibGUuXHJcbmZ1bmN0aW9uIHV0ZjhUZXh0KGJ1ZiwgaSkge1xyXG4gIHZhciB0b3RhbCA9IHV0ZjhDaGVja0luY29tcGxldGUodGhpcywgYnVmLCBpKTtcclxuICBpZiAoIXRoaXMubGFzdE5lZWQpIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpKTtcclxuICB0aGlzLmxhc3RUb3RhbCA9IHRvdGFsO1xyXG4gIHZhciBlbmQgPSBidWYubGVuZ3RoIC0gKHRvdGFsIC0gdGhpcy5sYXN0TmVlZCk7XHJcbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgMCwgZW5kKTtcclxuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSwgZW5kKTtcclxufVxyXG5cclxuLy8gRm9yIFVURi04LCBhIHJlcGxhY2VtZW50IGNoYXJhY3RlciBpcyBhZGRlZCB3aGVuIGVuZGluZyBvbiBhIHBhcnRpYWxcclxuLy8gY2hhcmFjdGVyLlxyXG5mdW5jdGlvbiB1dGY4RW5kKGJ1Zikge1xyXG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcclxuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyAnXFx1ZmZmZCc7XHJcbiAgcmV0dXJuIHI7XHJcbn1cclxuXHJcbi8vIFVURi0xNkxFIHR5cGljYWxseSBuZWVkcyB0d28gYnl0ZXMgcGVyIGNoYXJhY3RlciwgYnV0IGV2ZW4gaWYgd2UgaGF2ZSBhbiBldmVuXHJcbi8vIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUsIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2UgZW5kIG9uIGEgbGVhZGluZy9oaWdoXHJcbi8vIHN1cnJvZ2F0ZS4gSW4gdGhhdCBjYXNlLCB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBuZXh0IHR3byBieXRlcyBpbiBvcmRlciB0b1xyXG4vLyBkZWNvZGUgdGhlIGxhc3QgY2hhcmFjdGVyIHByb3Blcmx5LlxyXG5mdW5jdGlvbiB1dGYxNlRleHQoYnVmLCBpKSB7XHJcbiAgaWYgKChidWYubGVuZ3RoIC0gaSkgJSAyID09PSAwKSB7XHJcbiAgICB2YXIgciA9IGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGkpO1xyXG4gICAgaWYgKHIpIHtcclxuICAgICAgdmFyIGMgPSByLmNoYXJDb2RlQXQoci5sZW5ndGggLSAxKTtcclxuICAgICAgaWYgKGMgPj0gMHhEODAwICYmIGMgPD0gMHhEQkZGKSB7XHJcbiAgICAgICAgdGhpcy5sYXN0TmVlZCA9IDI7XHJcbiAgICAgICAgdGhpcy5sYXN0VG90YWwgPSA0O1xyXG4gICAgICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xyXG4gICAgICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIHJldHVybiByLnNsaWNlKDAsIC0xKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHI7XHJcbiAgfVxyXG4gIHRoaXMubGFzdE5lZWQgPSAxO1xyXG4gIHRoaXMubGFzdFRvdGFsID0gMjtcclxuICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcclxuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSwgYnVmLmxlbmd0aCAtIDEpO1xyXG59XHJcblxyXG4vLyBGb3IgVVRGLTE2TEUgd2UgZG8gbm90IGV4cGxpY2l0bHkgYXBwZW5kIHNwZWNpYWwgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBpZiB3ZVxyXG4vLyBlbmQgb24gYSBwYXJ0aWFsIGNoYXJhY3Rlciwgd2Ugc2ltcGx5IGxldCB2OCBoYW5kbGUgdGhhdC5cclxuZnVuY3Rpb24gdXRmMTZFbmQoYnVmKSB7XHJcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xyXG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XHJcbiAgICB2YXIgZW5kID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xyXG4gICAgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCd1dGYxNmxlJywgMCwgZW5kKTtcclxuICB9XHJcbiAgcmV0dXJuIHI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGJhc2U2NFRleHQoYnVmLCBpKSB7XHJcbiAgdmFyIG4gPSAoYnVmLmxlbmd0aCAtIGkpICUgMztcclxuICBpZiAobiA9PT0gMCkgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSk7XHJcbiAgdGhpcy5sYXN0TmVlZCA9IDMgLSBuO1xyXG4gIHRoaXMubGFzdFRvdGFsID0gMztcclxuICBpZiAobiA9PT0gMSkge1xyXG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XHJcbiAgfSBlbHNlIHtcclxuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xyXG4gICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XHJcbiAgfVxyXG4gIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGksIGJ1Zi5sZW5ndGggLSBuKTtcclxufVxyXG5cclxuZnVuY3Rpb24gYmFzZTY0RW5kKGJ1Zikge1xyXG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcclxuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCdiYXNlNjQnLCAwLCAzIC0gdGhpcy5sYXN0TmVlZCk7XHJcbiAgcmV0dXJuIHI7XHJcbn1cclxuXHJcbi8vIFBhc3MgYnl0ZXMgb24gdGhyb3VnaCBmb3Igc2luZ2xlLWJ5dGUgZW5jb2RpbmdzIChlLmcuIGFzY2lpLCBsYXRpbjEsIGhleClcclxuZnVuY3Rpb24gc2ltcGxlV3JpdGUoYnVmKSB7XHJcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2ltcGxlRW5kKGJ1Zikge1xyXG4gIHJldHVybiBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xyXG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/string_decoder/lib/string_decoder.js\n");

/***/ }),

/***/ "./node_modules/unload/dist/es/browser.js":
/*!************************************************!*\
  !*** ./node_modules/unload/dist/es/browser.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* global WorkerGlobalScope */\r\nfunction add(fn) {\r\n  if (typeof WorkerGlobalScope === 'function' && self instanceof WorkerGlobalScope) {// this is run inside of a webworker\r\n  } else {\r\n    /**\r\n     * if we are on react-native, there is no window.addEventListener\r\n     * @link https://github.com/pubkey/unload/issues/6\r\n     */\r\n    if (typeof window.addEventListener !== 'function') return;\r\n    /**\r\n     * for normal browser-windows, we use the beforeunload-event\r\n     */\r\n\r\n    window.addEventListener('beforeunload', function () {\r\n      fn();\r\n    }, true);\r\n    /**\r\n     * for iframes, we have to use the unload-event\r\n     * @link https://stackoverflow.com/q/47533670/3443137\r\n     */\r\n\r\n    window.addEventListener('unload', function () {\r\n      fn();\r\n    }, true);\r\n  }\r\n  /**\r\n   * TODO add fallback for safari-mobile\r\n   * @link https://stackoverflow.com/a/26193516/3443137\r\n   */\r\n\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\r\n  add: add\r\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdW5sb2FkL2Rpc3QvZXMvYnJvd3Nlci5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQWU7QUFDZjtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3VubG9hZC9kaXN0L2VzL2Jyb3dzZXIuanM/ZDQ5OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWwgV29ya2VyR2xvYmFsU2NvcGUgKi9cclxuZnVuY3Rpb24gYWRkKGZuKSB7XHJcbiAgaWYgKHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSA9PT0gJ2Z1bmN0aW9uJyAmJiBzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUpIHsvLyB0aGlzIGlzIHJ1biBpbnNpZGUgb2YgYSB3ZWJ3b3JrZXJcclxuICB9IGVsc2Uge1xyXG4gICAgLyoqXHJcbiAgICAgKiBpZiB3ZSBhcmUgb24gcmVhY3QtbmF0aXZlLCB0aGVyZSBpcyBubyB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lclxyXG4gICAgICogQGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3B1YmtleS91bmxvYWQvaXNzdWVzLzZcclxuICAgICAqL1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuO1xyXG4gICAgLyoqXHJcbiAgICAgKiBmb3Igbm9ybWFsIGJyb3dzZXItd2luZG93cywgd2UgdXNlIHRoZSBiZWZvcmV1bmxvYWQtZXZlbnRcclxuICAgICAqL1xyXG5cclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGZuKCk7XHJcbiAgICB9LCB0cnVlKTtcclxuICAgIC8qKlxyXG4gICAgICogZm9yIGlmcmFtZXMsIHdlIGhhdmUgdG8gdXNlIHRoZSB1bmxvYWQtZXZlbnRcclxuICAgICAqIEBsaW5rIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcS80NzUzMzY3MC8zNDQzMTM3XHJcbiAgICAgKi9cclxuXHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndW5sb2FkJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICBmbigpO1xyXG4gICAgfSwgdHJ1ZSk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFRPRE8gYWRkIGZhbGxiYWNrIGZvciBzYWZhcmktbW9iaWxlXHJcbiAgICogQGxpbmsgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2MTkzNTE2LzM0NDMxMzdcclxuICAgKi9cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBhZGQ6IGFkZFxyXG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/unload/dist/es/browser.js\n");

/***/ }),

/***/ "./node_modules/unload/dist/es/index.js":
/*!**********************************************!*\
  !*** ./node_modules/unload/dist/es/index.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"add\": function() { return /* binding */ add; },\n/* harmony export */   \"runAll\": function() { return /* binding */ runAll; },\n/* harmony export */   \"removeAll\": function() { return /* binding */ removeAll; },\n/* harmony export */   \"getSize\": function() { return /* binding */ getSize; }\n/* harmony export */ });\n/* harmony import */ var detect_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! detect-node */ \"./node_modules/detect-node/browser.js\");\n/* harmony import */ var detect_node__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(detect_node__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _browser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./browser.js */ \"./node_modules/unload/dist/es/browser.js\");\n/* harmony import */ var _node_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node.js */ \"?114e\");\n/* harmony import */ var _node_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_js__WEBPACK_IMPORTED_MODULE_2__);\n\r\n\r\n\r\nvar USE_METHOD = (detect_node__WEBPACK_IMPORTED_MODULE_0___default()) ? (_node_js__WEBPACK_IMPORTED_MODULE_2___default()) : _browser_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"];\r\nvar LISTENERS = new Set();\r\nvar startedListening = false;\r\n\r\nfunction startListening() {\r\n  if (startedListening) return;\r\n  startedListening = true;\r\n  USE_METHOD.add(runAll);\r\n}\r\n\r\nfunction add(fn) {\r\n  startListening();\r\n  if (typeof fn !== 'function') throw new Error('Listener is no function');\r\n  LISTENERS.add(fn);\r\n  var addReturn = {\r\n    remove: function remove() {\r\n      return LISTENERS[\"delete\"](fn);\r\n    },\r\n    run: function run() {\r\n      LISTENERS[\"delete\"](fn);\r\n      return fn();\r\n    }\r\n  };\r\n  return addReturn;\r\n}\r\nfunction runAll() {\r\n  var promises = [];\r\n  LISTENERS.forEach(function (fn) {\r\n    promises.push(fn());\r\n    LISTENERS[\"delete\"](fn);\r\n  });\r\n  return Promise.all(promises);\r\n}\r\nfunction removeAll() {\r\n  LISTENERS.clear();\r\n}\r\nfunction getSize() {\r\n  return LISTENERS.size;\r\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdW5sb2FkL2Rpc3QvZXMvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQWlDO0FBQ1E7QUFDTjtBQUNuQyxpQkFBaUIsb0RBQU0sR0FBRyxpREFBVSxHQUFHLG1EQUFhO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy91bmxvYWQvZGlzdC9lcy9pbmRleC5qcz8zMGQ2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBpc05vZGUgZnJvbSAnZGV0ZWN0LW5vZGUnO1xyXG5pbXBvcnQgQnJvd3Nlck1ldGhvZCBmcm9tICcuL2Jyb3dzZXIuanMnO1xyXG5pbXBvcnQgTm9kZU1ldGhvZCBmcm9tICcuL25vZGUuanMnO1xyXG52YXIgVVNFX01FVEhPRCA9IGlzTm9kZSA/IE5vZGVNZXRob2QgOiBCcm93c2VyTWV0aG9kO1xyXG52YXIgTElTVEVORVJTID0gbmV3IFNldCgpO1xyXG52YXIgc3RhcnRlZExpc3RlbmluZyA9IGZhbHNlO1xyXG5cclxuZnVuY3Rpb24gc3RhcnRMaXN0ZW5pbmcoKSB7XHJcbiAgaWYgKHN0YXJ0ZWRMaXN0ZW5pbmcpIHJldHVybjtcclxuICBzdGFydGVkTGlzdGVuaW5nID0gdHJ1ZTtcclxuICBVU0VfTUVUSE9ELmFkZChydW5BbGwpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYWRkKGZuKSB7XHJcbiAgc3RhcnRMaXN0ZW5pbmcoKTtcclxuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoJ0xpc3RlbmVyIGlzIG5vIGZ1bmN0aW9uJyk7XHJcbiAgTElTVEVORVJTLmFkZChmbik7XHJcbiAgdmFyIGFkZFJldHVybiA9IHtcclxuICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xyXG4gICAgICByZXR1cm4gTElTVEVORVJTW1wiZGVsZXRlXCJdKGZuKTtcclxuICAgIH0sXHJcbiAgICBydW46IGZ1bmN0aW9uIHJ1bigpIHtcclxuICAgICAgTElTVEVORVJTW1wiZGVsZXRlXCJdKGZuKTtcclxuICAgICAgcmV0dXJuIGZuKCk7XHJcbiAgICB9XHJcbiAgfTtcclxuICByZXR1cm4gYWRkUmV0dXJuO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBydW5BbGwoKSB7XHJcbiAgdmFyIHByb21pc2VzID0gW107XHJcbiAgTElTVEVORVJTLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XHJcbiAgICBwcm9taXNlcy5wdXNoKGZuKCkpO1xyXG4gICAgTElTVEVORVJTW1wiZGVsZXRlXCJdKGZuKTtcclxuICB9KTtcclxuICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVBbGwoKSB7XHJcbiAgTElTVEVORVJTLmNsZWFyKCk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFNpemUoKSB7XHJcbiAgcmV0dXJuIExJU1RFTkVSUy5zaXplO1xyXG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/unload/dist/es/index.js\n");

/***/ }),

/***/ "./node_modules/util-deprecate/browser.js":
/*!************************************************!*\
  !*** ./node_modules/util-deprecate/browser.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("\r\n/**\r\n * Module exports.\r\n */\r\n\r\nmodule.exports = deprecate;\r\n\r\n/**\r\n * Mark that a method should not be used.\r\n * Returns a modified function which warns once by default.\r\n *\r\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\r\n *\r\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\r\n * will throw an Error when invoked.\r\n *\r\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\r\n * will invoke `console.trace()` instead of `console.error()`.\r\n *\r\n * @param {Function} fn - the function to deprecate\r\n * @param {String} msg - the string to print to the console when `fn` is invoked\r\n * @returns {Function} a new \"deprecated\" version of `fn`\r\n * @api public\r\n */\r\n\r\nfunction deprecate (fn, msg) {\r\n  if (config('noDeprecation')) {\r\n    return fn;\r\n  }\r\n\r\n  var warned = false;\r\n  function deprecated() {\r\n    if (!warned) {\r\n      if (config('throwDeprecation')) {\r\n        throw new Error(msg);\r\n      } else if (config('traceDeprecation')) {\r\n        console.trace(msg);\r\n      } else {\r\n        console.warn(msg);\r\n      }\r\n      warned = true;\r\n    }\r\n    return fn.apply(this, arguments);\r\n  }\r\n\r\n  return deprecated;\r\n}\r\n\r\n/**\r\n * Checks `localStorage` for boolean values for the given `name`.\r\n *\r\n * @param {String} name\r\n * @returns {Boolean}\r\n * @api private\r\n */\r\n\r\nfunction config (name) {\r\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\r\n  try {\r\n    if (!__webpack_require__.g.localStorage) return false;\r\n  } catch (_) {\r\n    return false;\r\n  }\r\n  var val = __webpack_require__.g.localStorage[name];\r\n  if (null == val) return false;\r\n  return String(val).toLowerCase() === 'true';\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdXRpbC1kZXByZWNhdGUvYnJvd3Nlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHFCQUFNO0FBQ2YsSUFBSTtBQUNKO0FBQ0E7QUFDQSxZQUFZLHFCQUFNO0FBQ2xCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdXRpbC1kZXByZWNhdGUvYnJvd3Nlci5qcz9iYjM1Il0sInNvdXJjZXNDb250ZW50IjpbIlxyXG4vKipcclxuICogTW9kdWxlIGV4cG9ydHMuXHJcbiAqL1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBkZXByZWNhdGU7XHJcblxyXG4vKipcclxuICogTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cclxuICogUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cclxuICpcclxuICogSWYgYGxvY2FsU3RvcmFnZS5ub0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXHJcbiAqXHJcbiAqIElmIGBsb2NhbFN0b3JhZ2UudGhyb3dEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xyXG4gKiB3aWxsIHRocm93IGFuIEVycm9yIHdoZW4gaW52b2tlZC5cclxuICpcclxuICogSWYgYGxvY2FsU3RvcmFnZS50cmFjZURlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXHJcbiAqIHdpbGwgaW52b2tlIGBjb25zb2xlLnRyYWNlKClgIGluc3RlYWQgb2YgYGNvbnNvbGUuZXJyb3IoKWAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gdGhlIGZ1bmN0aW9uIHRvIGRlcHJlY2F0ZVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbXNnIC0gdGhlIHN0cmluZyB0byBwcmludCB0byB0aGUgY29uc29sZSB3aGVuIGBmbmAgaXMgaW52b2tlZFxyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgbmV3IFwiZGVwcmVjYXRlZFwiIHZlcnNpb24gb2YgYGZuYFxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIGRlcHJlY2F0ZSAoZm4sIG1zZykge1xyXG4gIGlmIChjb25maWcoJ25vRGVwcmVjYXRpb24nKSkge1xyXG4gICAgcmV0dXJuIGZuO1xyXG4gIH1cclxuXHJcbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xyXG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XHJcbiAgICBpZiAoIXdhcm5lZCkge1xyXG4gICAgICBpZiAoY29uZmlnKCd0aHJvd0RlcHJlY2F0aW9uJykpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcclxuICAgICAgfSBlbHNlIGlmIChjb25maWcoJ3RyYWNlRGVwcmVjYXRpb24nKSkge1xyXG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zb2xlLndhcm4obXNnKTtcclxuICAgICAgfVxyXG4gICAgICB3YXJuZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZGVwcmVjYXRlZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBgbG9jYWxTdG9yYWdlYCBmb3IgYm9vbGVhbiB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBgbmFtZWAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5mdW5jdGlvbiBjb25maWcgKG5hbWUpIHtcclxuICAvLyBhY2Nlc3NpbmcgZ2xvYmFsLmxvY2FsU3RvcmFnZSBjYW4gdHJpZ2dlciBhIERPTUV4Y2VwdGlvbiBpbiBzYW5kYm94ZWQgaWZyYW1lc1xyXG4gIHRyeSB7XHJcbiAgICBpZiAoIWdsb2JhbC5sb2NhbFN0b3JhZ2UpIHJldHVybiBmYWxzZTtcclxuICB9IGNhdGNoIChfKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIHZhciB2YWwgPSBnbG9iYWwubG9jYWxTdG9yYWdlW25hbWVdO1xyXG4gIGlmIChudWxsID09IHZhbCkgcmV0dXJuIGZhbHNlO1xyXG4gIHJldHVybiBTdHJpbmcodmFsKS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/util-deprecate/browser.js\n");

/***/ }),

/***/ "./node_modules/util/support/isBufferBrowser.js":
/*!******************************************************!*\
  !*** ./node_modules/util/support/isBufferBrowser.js ***!
  \******************************************************/
/***/ (function(module) {

eval("module.exports = function isBuffer(arg) {\r\n  return arg && typeof arg === 'object'\r\n    && typeof arg.copy === 'function'\r\n    && typeof arg.fill === 'function'\r\n    && typeof arg.readUInt8 === 'function';\r\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L2lzQnVmZmVyQnJvd3Nlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanM/ZDc1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xyXG4gIHJldHVybiBhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCdcclxuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xyXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXHJcbiAgICAmJiB0eXBlb2YgYXJnLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJztcclxufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/util/support/isBufferBrowser.js\n");

/***/ }),

/***/ "./node_modules/util/support/types.js":
/*!********************************************!*\
  !*** ./node_modules/util/support/types.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("// Currently in sync with Node.js lib/internal/util/types.js\r\n// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9\r\n\r\n\r\n\r\nvar isArgumentsObject = __webpack_require__(/*! is-arguments */ \"./node_modules/is-arguments/index.js\");\r\nvar isGeneratorFunction = __webpack_require__(/*! is-generator-function */ \"./node_modules/is-generator-function/index.js\");\r\nvar whichTypedArray = __webpack_require__(/*! which-typed-array */ \"./node_modules/which-typed-array/index.js\");\r\nvar isTypedArray = __webpack_require__(/*! is-typed-array */ \"./node_modules/is-typed-array/index.js\");\r\n\r\nfunction uncurryThis(f) {\r\n  return f.call.bind(f);\r\n}\r\n\r\nvar BigIntSupported = typeof BigInt !== 'undefined';\r\nvar SymbolSupported = typeof Symbol !== 'undefined';\r\n\r\nvar ObjectToString = uncurryThis(Object.prototype.toString);\r\n\r\nvar numberValue = uncurryThis(Number.prototype.valueOf);\r\nvar stringValue = uncurryThis(String.prototype.valueOf);\r\nvar booleanValue = uncurryThis(Boolean.prototype.valueOf);\r\n\r\nif (BigIntSupported) {\r\n  var bigIntValue = uncurryThis(BigInt.prototype.valueOf);\r\n}\r\n\r\nif (SymbolSupported) {\r\n  var symbolValue = uncurryThis(Symbol.prototype.valueOf);\r\n}\r\n\r\nfunction checkBoxedPrimitive(value, prototypeValueOf) {\r\n  if (typeof value !== 'object') {\r\n    return false;\r\n  }\r\n  try {\r\n    prototypeValueOf(value);\r\n    return true;\r\n  } catch(e) {\r\n    return false;\r\n  }\r\n}\r\n\r\nexports.isArgumentsObject = isArgumentsObject;\r\nexports.isGeneratorFunction = isGeneratorFunction;\r\nexports.isTypedArray = isTypedArray;\r\n\r\n// Taken from here and modified for better browser support\r\n// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js\r\nfunction isPromise(input) {\r\n\treturn (\r\n\t\t(\r\n\t\t\ttypeof Promise !== 'undefined' &&\r\n\t\t\tinput instanceof Promise\r\n\t\t) ||\r\n\t\t(\r\n\t\t\tinput !== null &&\r\n\t\t\ttypeof input === 'object' &&\r\n\t\t\ttypeof input.then === 'function' &&\r\n\t\t\ttypeof input.catch === 'function'\r\n\t\t)\r\n\t);\r\n}\r\nexports.isPromise = isPromise;\r\n\r\nfunction isArrayBufferView(value) {\r\n  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {\r\n    return ArrayBuffer.isView(value);\r\n  }\r\n\r\n  return (\r\n    isTypedArray(value) ||\r\n    isDataView(value)\r\n  );\r\n}\r\nexports.isArrayBufferView = isArrayBufferView;\r\n\r\n\r\nfunction isUint8Array(value) {\r\n  return whichTypedArray(value) === 'Uint8Array';\r\n}\r\nexports.isUint8Array = isUint8Array;\r\n\r\nfunction isUint8ClampedArray(value) {\r\n  return whichTypedArray(value) === 'Uint8ClampedArray';\r\n}\r\nexports.isUint8ClampedArray = isUint8ClampedArray;\r\n\r\nfunction isUint16Array(value) {\r\n  return whichTypedArray(value) === 'Uint16Array';\r\n}\r\nexports.isUint16Array = isUint16Array;\r\n\r\nfunction isUint32Array(value) {\r\n  return whichTypedArray(value) === 'Uint32Array';\r\n}\r\nexports.isUint32Array = isUint32Array;\r\n\r\nfunction isInt8Array(value) {\r\n  return whichTypedArray(value) === 'Int8Array';\r\n}\r\nexports.isInt8Array = isInt8Array;\r\n\r\nfunction isInt16Array(value) {\r\n  return whichTypedArray(value) === 'Int16Array';\r\n}\r\nexports.isInt16Array = isInt16Array;\r\n\r\nfunction isInt32Array(value) {\r\n  return whichTypedArray(value) === 'Int32Array';\r\n}\r\nexports.isInt32Array = isInt32Array;\r\n\r\nfunction isFloat32Array(value) {\r\n  return whichTypedArray(value) === 'Float32Array';\r\n}\r\nexports.isFloat32Array = isFloat32Array;\r\n\r\nfunction isFloat64Array(value) {\r\n  return whichTypedArray(value) === 'Float64Array';\r\n}\r\nexports.isFloat64Array = isFloat64Array;\r\n\r\nfunction isBigInt64Array(value) {\r\n  return whichTypedArray(value) === 'BigInt64Array';\r\n}\r\nexports.isBigInt64Array = isBigInt64Array;\r\n\r\nfunction isBigUint64Array(value) {\r\n  return whichTypedArray(value) === 'BigUint64Array';\r\n}\r\nexports.isBigUint64Array = isBigUint64Array;\r\n\r\nfunction isMapToString(value) {\r\n  return ObjectToString(value) === '[object Map]';\r\n}\r\nisMapToString.working = (\r\n  typeof Map !== 'undefined' &&\r\n  isMapToString(new Map())\r\n);\r\n\r\nfunction isMap(value) {\r\n  if (typeof Map === 'undefined') {\r\n    return false;\r\n  }\r\n\r\n  return isMapToString.working\r\n    ? isMapToString(value)\r\n    : value instanceof Map;\r\n}\r\nexports.isMap = isMap;\r\n\r\nfunction isSetToString(value) {\r\n  return ObjectToString(value) === '[object Set]';\r\n}\r\nisSetToString.working = (\r\n  typeof Set !== 'undefined' &&\r\n  isSetToString(new Set())\r\n);\r\nfunction isSet(value) {\r\n  if (typeof Set === 'undefined') {\r\n    return false;\r\n  }\r\n\r\n  return isSetToString.working\r\n    ? isSetToString(value)\r\n    : value instanceof Set;\r\n}\r\nexports.isSet = isSet;\r\n\r\nfunction isWeakMapToString(value) {\r\n  return ObjectToString(value) === '[object WeakMap]';\r\n}\r\nisWeakMapToString.working = (\r\n  typeof WeakMap !== 'undefined' &&\r\n  isWeakMapToString(new WeakMap())\r\n);\r\nfunction isWeakMap(value) {\r\n  if (typeof WeakMap === 'undefined') {\r\n    return false;\r\n  }\r\n\r\n  return isWeakMapToString.working\r\n    ? isWeakMapToString(value)\r\n    : value instanceof WeakMap;\r\n}\r\nexports.isWeakMap = isWeakMap;\r\n\r\nfunction isWeakSetToString(value) {\r\n  return ObjectToString(value) === '[object WeakSet]';\r\n}\r\nisWeakSetToString.working = (\r\n  typeof WeakSet !== 'undefined' &&\r\n  isWeakSetToString(new WeakSet())\r\n);\r\nfunction isWeakSet(value) {\r\n  return isWeakSetToString(value);\r\n}\r\nexports.isWeakSet = isWeakSet;\r\n\r\nfunction isArrayBufferToString(value) {\r\n  return ObjectToString(value) === '[object ArrayBuffer]';\r\n}\r\nisArrayBufferToString.working = (\r\n  typeof ArrayBuffer !== 'undefined' &&\r\n  isArrayBufferToString(new ArrayBuffer())\r\n);\r\nfunction isArrayBuffer(value) {\r\n  if (typeof ArrayBuffer === 'undefined') {\r\n    return false;\r\n  }\r\n\r\n  return isArrayBufferToString.working\r\n    ? isArrayBufferToString(value)\r\n    : value instanceof ArrayBuffer;\r\n}\r\nexports.isArrayBuffer = isArrayBuffer;\r\n\r\nfunction isDataViewToString(value) {\r\n  return ObjectToString(value) === '[object DataView]';\r\n}\r\nisDataViewToString.working = (\r\n  typeof ArrayBuffer !== 'undefined' &&\r\n  typeof DataView !== 'undefined' &&\r\n  isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1))\r\n);\r\nfunction isDataView(value) {\r\n  if (typeof DataView === 'undefined') {\r\n    return false;\r\n  }\r\n\r\n  return isDataViewToString.working\r\n    ? isDataViewToString(value)\r\n    : value instanceof DataView;\r\n}\r\nexports.isDataView = isDataView;\r\n\r\n// Store a copy of SharedArrayBuffer in case it's deleted elsewhere\r\nvar SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;\r\nfunction isSharedArrayBufferToString(value) {\r\n  return ObjectToString(value) === '[object SharedArrayBuffer]';\r\n}\r\nfunction isSharedArrayBuffer(value) {\r\n  if (typeof SharedArrayBufferCopy === 'undefined') {\r\n    return false;\r\n  }\r\n\r\n  if (typeof isSharedArrayBufferToString.working === 'undefined') {\r\n    isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());\r\n  }\r\n\r\n  return isSharedArrayBufferToString.working\r\n    ? isSharedArrayBufferToString(value)\r\n    : value instanceof SharedArrayBufferCopy;\r\n}\r\nexports.isSharedArrayBuffer = isSharedArrayBuffer;\r\n\r\nfunction isAsyncFunction(value) {\r\n  return ObjectToString(value) === '[object AsyncFunction]';\r\n}\r\nexports.isAsyncFunction = isAsyncFunction;\r\n\r\nfunction isMapIterator(value) {\r\n  return ObjectToString(value) === '[object Map Iterator]';\r\n}\r\nexports.isMapIterator = isMapIterator;\r\n\r\nfunction isSetIterator(value) {\r\n  return ObjectToString(value) === '[object Set Iterator]';\r\n}\r\nexports.isSetIterator = isSetIterator;\r\n\r\nfunction isGeneratorObject(value) {\r\n  return ObjectToString(value) === '[object Generator]';\r\n}\r\nexports.isGeneratorObject = isGeneratorObject;\r\n\r\nfunction isWebAssemblyCompiledModule(value) {\r\n  return ObjectToString(value) === '[object WebAssembly.Module]';\r\n}\r\nexports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;\r\n\r\nfunction isNumberObject(value) {\r\n  return checkBoxedPrimitive(value, numberValue);\r\n}\r\nexports.isNumberObject = isNumberObject;\r\n\r\nfunction isStringObject(value) {\r\n  return checkBoxedPrimitive(value, stringValue);\r\n}\r\nexports.isStringObject = isStringObject;\r\n\r\nfunction isBooleanObject(value) {\r\n  return checkBoxedPrimitive(value, booleanValue);\r\n}\r\nexports.isBooleanObject = isBooleanObject;\r\n\r\nfunction isBigIntObject(value) {\r\n  return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);\r\n}\r\nexports.isBigIntObject = isBigIntObject;\r\n\r\nfunction isSymbolObject(value) {\r\n  return SymbolSupported && checkBoxedPrimitive(value, symbolValue);\r\n}\r\nexports.isSymbolObject = isSymbolObject;\r\n\r\nfunction isBoxedPrimitive(value) {\r\n  return (\r\n    isNumberObject(value) ||\r\n    isStringObject(value) ||\r\n    isBooleanObject(value) ||\r\n    isBigIntObject(value) ||\r\n    isSymbolObject(value)\r\n  );\r\n}\r\nexports.isBoxedPrimitive = isBoxedPrimitive;\r\n\r\nfunction isAnyArrayBuffer(value) {\r\n  return typeof Uint8Array !== 'undefined' && (\r\n    isArrayBuffer(value) ||\r\n    isSharedArrayBuffer(value)\r\n  );\r\n}\r\nexports.isAnyArrayBuffer = isAnyArrayBuffer;\r\n\r\n['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function(method) {\r\n  Object.defineProperty(exports, method, {\r\n    enumerable: false,\r\n    value: function() {\r\n      throw new Error(method + ' is not supported in userland');\r\n    }\r\n  });\r\n});\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L3R5cGVzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNhO0FBQ2I7QUFDQSx3QkFBd0IsbUJBQU8sQ0FBQywwREFBYztBQUM5QywwQkFBMEIsbUJBQU8sQ0FBQyw0RUFBdUI7QUFDekQsc0JBQXNCLG1CQUFPLENBQUMsb0VBQW1CO0FBQ2pELG1CQUFtQixtQkFBTyxDQUFDLDhEQUFnQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLDJCQUEyQjtBQUMzQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC90eXBlcy5qcz9mYzM0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEN1cnJlbnRseSBpbiBzeW5jIHdpdGggTm9kZS5qcyBsaWIvaW50ZXJuYWwvdXRpbC90eXBlcy5qc1xyXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvY29tbWl0LzExMmNjN2MyNzU1MTI1NGFhMmIxNzA5OGZiNzc0ODY3ZjA1ZWQwZDlcclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBpc0FyZ3VtZW50c09iamVjdCA9IHJlcXVpcmUoJ2lzLWFyZ3VtZW50cycpO1xyXG52YXIgaXNHZW5lcmF0b3JGdW5jdGlvbiA9IHJlcXVpcmUoJ2lzLWdlbmVyYXRvci1mdW5jdGlvbicpO1xyXG52YXIgd2hpY2hUeXBlZEFycmF5ID0gcmVxdWlyZSgnd2hpY2gtdHlwZWQtYXJyYXknKTtcclxudmFyIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJ2lzLXR5cGVkLWFycmF5Jyk7XHJcblxyXG5mdW5jdGlvbiB1bmN1cnJ5VGhpcyhmKSB7XHJcbiAgcmV0dXJuIGYuY2FsbC5iaW5kKGYpO1xyXG59XHJcblxyXG52YXIgQmlnSW50U3VwcG9ydGVkID0gdHlwZW9mIEJpZ0ludCAhPT0gJ3VuZGVmaW5lZCc7XHJcbnZhciBTeW1ib2xTdXBwb3J0ZWQgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJztcclxuXHJcbnZhciBPYmplY3RUb1N0cmluZyA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpO1xyXG5cclxudmFyIG51bWJlclZhbHVlID0gdW5jdXJyeVRoaXMoTnVtYmVyLnByb3RvdHlwZS52YWx1ZU9mKTtcclxudmFyIHN0cmluZ1ZhbHVlID0gdW5jdXJyeVRoaXMoU3RyaW5nLnByb3RvdHlwZS52YWx1ZU9mKTtcclxudmFyIGJvb2xlYW5WYWx1ZSA9IHVuY3VycnlUaGlzKEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YpO1xyXG5cclxuaWYgKEJpZ0ludFN1cHBvcnRlZCkge1xyXG4gIHZhciBiaWdJbnRWYWx1ZSA9IHVuY3VycnlUaGlzKEJpZ0ludC5wcm90b3R5cGUudmFsdWVPZik7XHJcbn1cclxuXHJcbmlmIChTeW1ib2xTdXBwb3J0ZWQpIHtcclxuICB2YXIgc3ltYm9sVmFsdWUgPSB1bmN1cnJ5VGhpcyhTeW1ib2wucHJvdG90eXBlLnZhbHVlT2YpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBwcm90b3R5cGVWYWx1ZU9mKSB7XHJcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgdHJ5IHtcclxuICAgIHByb3RvdHlwZVZhbHVlT2YodmFsdWUpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSBjYXRjaChlKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLmlzQXJndW1lbnRzT2JqZWN0ID0gaXNBcmd1bWVudHNPYmplY3Q7XHJcbmV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGlzR2VuZXJhdG9yRnVuY3Rpb247XHJcbmV4cG9ydHMuaXNUeXBlZEFycmF5ID0gaXNUeXBlZEFycmF5O1xyXG5cclxuLy8gVGFrZW4gZnJvbSBoZXJlIGFuZCBtb2RpZmllZCBmb3IgYmV0dGVyIGJyb3dzZXIgc3VwcG9ydFxyXG4vLyBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL3AtaXMtcHJvbWlzZS9ibG9iL2NkYTM1YTUxM2JkYTAzZjk3N2FkNWNkZTNhMDc5ZDIzN2U4MmQ3ZWYvaW5kZXguanNcclxuZnVuY3Rpb24gaXNQcm9taXNlKGlucHV0KSB7XHJcblx0cmV0dXJuIChcclxuXHRcdChcclxuXHRcdFx0dHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmXHJcblx0XHRcdGlucHV0IGluc3RhbmNlb2YgUHJvbWlzZVxyXG5cdFx0KSB8fFxyXG5cdFx0KFxyXG5cdFx0XHRpbnB1dCAhPT0gbnVsbCAmJlxyXG5cdFx0XHR0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmXHJcblx0XHRcdHR5cGVvZiBpbnB1dC50aGVuID09PSAnZnVuY3Rpb24nICYmXHJcblx0XHRcdHR5cGVvZiBpbnB1dC5jYXRjaCA9PT0gJ2Z1bmN0aW9uJ1xyXG5cdFx0KVxyXG5cdCk7XHJcbn1cclxuZXhwb3J0cy5pc1Byb21pc2UgPSBpc1Byb21pc2U7XHJcblxyXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyh2YWx1ZSkge1xyXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIEFycmF5QnVmZmVyLmlzVmlldykge1xyXG4gICAgcmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gKFxyXG4gICAgaXNUeXBlZEFycmF5KHZhbHVlKSB8fFxyXG4gICAgaXNEYXRhVmlldyh2YWx1ZSlcclxuICApO1xyXG59XHJcbmV4cG9ydHMuaXNBcnJheUJ1ZmZlclZpZXcgPSBpc0FycmF5QnVmZmVyVmlldztcclxuXHJcblxyXG5mdW5jdGlvbiBpc1VpbnQ4QXJyYXkodmFsdWUpIHtcclxuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ1VpbnQ4QXJyYXknO1xyXG59XHJcbmV4cG9ydHMuaXNVaW50OEFycmF5ID0gaXNVaW50OEFycmF5O1xyXG5cclxuZnVuY3Rpb24gaXNVaW50OENsYW1wZWRBcnJheSh2YWx1ZSkge1xyXG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnVWludDhDbGFtcGVkQXJyYXknO1xyXG59XHJcbmV4cG9ydHMuaXNVaW50OENsYW1wZWRBcnJheSA9IGlzVWludDhDbGFtcGVkQXJyYXk7XHJcblxyXG5mdW5jdGlvbiBpc1VpbnQxNkFycmF5KHZhbHVlKSB7XHJcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdVaW50MTZBcnJheSc7XHJcbn1cclxuZXhwb3J0cy5pc1VpbnQxNkFycmF5ID0gaXNVaW50MTZBcnJheTtcclxuXHJcbmZ1bmN0aW9uIGlzVWludDMyQXJyYXkodmFsdWUpIHtcclxuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ1VpbnQzMkFycmF5JztcclxufVxyXG5leHBvcnRzLmlzVWludDMyQXJyYXkgPSBpc1VpbnQzMkFycmF5O1xyXG5cclxuZnVuY3Rpb24gaXNJbnQ4QXJyYXkodmFsdWUpIHtcclxuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0ludDhBcnJheSc7XHJcbn1cclxuZXhwb3J0cy5pc0ludDhBcnJheSA9IGlzSW50OEFycmF5O1xyXG5cclxuZnVuY3Rpb24gaXNJbnQxNkFycmF5KHZhbHVlKSB7XHJcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdJbnQxNkFycmF5JztcclxufVxyXG5leHBvcnRzLmlzSW50MTZBcnJheSA9IGlzSW50MTZBcnJheTtcclxuXHJcbmZ1bmN0aW9uIGlzSW50MzJBcnJheSh2YWx1ZSkge1xyXG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnSW50MzJBcnJheSc7XHJcbn1cclxuZXhwb3J0cy5pc0ludDMyQXJyYXkgPSBpc0ludDMyQXJyYXk7XHJcblxyXG5mdW5jdGlvbiBpc0Zsb2F0MzJBcnJheSh2YWx1ZSkge1xyXG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnRmxvYXQzMkFycmF5JztcclxufVxyXG5leHBvcnRzLmlzRmxvYXQzMkFycmF5ID0gaXNGbG9hdDMyQXJyYXk7XHJcblxyXG5mdW5jdGlvbiBpc0Zsb2F0NjRBcnJheSh2YWx1ZSkge1xyXG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnRmxvYXQ2NEFycmF5JztcclxufVxyXG5leHBvcnRzLmlzRmxvYXQ2NEFycmF5ID0gaXNGbG9hdDY0QXJyYXk7XHJcblxyXG5mdW5jdGlvbiBpc0JpZ0ludDY0QXJyYXkodmFsdWUpIHtcclxuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0JpZ0ludDY0QXJyYXknO1xyXG59XHJcbmV4cG9ydHMuaXNCaWdJbnQ2NEFycmF5ID0gaXNCaWdJbnQ2NEFycmF5O1xyXG5cclxuZnVuY3Rpb24gaXNCaWdVaW50NjRBcnJheSh2YWx1ZSkge1xyXG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnQmlnVWludDY0QXJyYXknO1xyXG59XHJcbmV4cG9ydHMuaXNCaWdVaW50NjRBcnJheSA9IGlzQmlnVWludDY0QXJyYXk7XHJcblxyXG5mdW5jdGlvbiBpc01hcFRvU3RyaW5nKHZhbHVlKSB7XHJcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgTWFwXSc7XHJcbn1cclxuaXNNYXBUb1N0cmluZy53b3JraW5nID0gKFxyXG4gIHR5cGVvZiBNYXAgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgaXNNYXBUb1N0cmluZyhuZXcgTWFwKCkpXHJcbik7XHJcblxyXG5mdW5jdGlvbiBpc01hcCh2YWx1ZSkge1xyXG4gIGlmICh0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGlzTWFwVG9TdHJpbmcud29ya2luZ1xyXG4gICAgPyBpc01hcFRvU3RyaW5nKHZhbHVlKVxyXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIE1hcDtcclxufVxyXG5leHBvcnRzLmlzTWFwID0gaXNNYXA7XHJcblxyXG5mdW5jdGlvbiBpc1NldFRvU3RyaW5nKHZhbHVlKSB7XHJcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgU2V0XSc7XHJcbn1cclxuaXNTZXRUb1N0cmluZy53b3JraW5nID0gKFxyXG4gIHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgaXNTZXRUb1N0cmluZyhuZXcgU2V0KCkpXHJcbik7XHJcbmZ1bmN0aW9uIGlzU2V0KHZhbHVlKSB7XHJcbiAgaWYgKHR5cGVvZiBTZXQgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gaXNTZXRUb1N0cmluZy53b3JraW5nXHJcbiAgICA/IGlzU2V0VG9TdHJpbmcodmFsdWUpXHJcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgU2V0O1xyXG59XHJcbmV4cG9ydHMuaXNTZXQgPSBpc1NldDtcclxuXHJcbmZ1bmN0aW9uIGlzV2Vha01hcFRvU3RyaW5nKHZhbHVlKSB7XHJcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgV2Vha01hcF0nO1xyXG59XHJcbmlzV2Vha01hcFRvU3RyaW5nLndvcmtpbmcgPSAoXHJcbiAgdHlwZW9mIFdlYWtNYXAgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgaXNXZWFrTWFwVG9TdHJpbmcobmV3IFdlYWtNYXAoKSlcclxuKTtcclxuZnVuY3Rpb24gaXNXZWFrTWFwKHZhbHVlKSB7XHJcbiAgaWYgKHR5cGVvZiBXZWFrTWFwID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGlzV2Vha01hcFRvU3RyaW5nLndvcmtpbmdcclxuICAgID8gaXNXZWFrTWFwVG9TdHJpbmcodmFsdWUpXHJcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgV2Vha01hcDtcclxufVxyXG5leHBvcnRzLmlzV2Vha01hcCA9IGlzV2Vha01hcDtcclxuXHJcbmZ1bmN0aW9uIGlzV2Vha1NldFRvU3RyaW5nKHZhbHVlKSB7XHJcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgV2Vha1NldF0nO1xyXG59XHJcbmlzV2Vha1NldFRvU3RyaW5nLndvcmtpbmcgPSAoXHJcbiAgdHlwZW9mIFdlYWtTZXQgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgaXNXZWFrU2V0VG9TdHJpbmcobmV3IFdlYWtTZXQoKSlcclxuKTtcclxuZnVuY3Rpb24gaXNXZWFrU2V0KHZhbHVlKSB7XHJcbiAgcmV0dXJuIGlzV2Vha1NldFRvU3RyaW5nKHZhbHVlKTtcclxufVxyXG5leHBvcnRzLmlzV2Vha1NldCA9IGlzV2Vha1NldDtcclxuXHJcbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJUb1N0cmluZyh2YWx1ZSkge1xyXG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXSc7XHJcbn1cclxuaXNBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmcgPSAoXHJcbiAgdHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gIGlzQXJyYXlCdWZmZXJUb1N0cmluZyhuZXcgQXJyYXlCdWZmZXIoKSlcclxuKTtcclxuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2YWx1ZSkge1xyXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gaXNBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmdcclxuICAgID8gaXNBcnJheUJ1ZmZlclRvU3RyaW5nKHZhbHVlKVxyXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyO1xyXG59XHJcbmV4cG9ydHMuaXNBcnJheUJ1ZmZlciA9IGlzQXJyYXlCdWZmZXI7XHJcblxyXG5mdW5jdGlvbiBpc0RhdGFWaWV3VG9TdHJpbmcodmFsdWUpIHtcclxuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBEYXRhVmlld10nO1xyXG59XHJcbmlzRGF0YVZpZXdUb1N0cmluZy53b3JraW5nID0gKFxyXG4gIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICB0eXBlb2YgRGF0YVZpZXcgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgaXNEYXRhVmlld1RvU3RyaW5nKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSksIDAsIDEpKVxyXG4pO1xyXG5mdW5jdGlvbiBpc0RhdGFWaWV3KHZhbHVlKSB7XHJcbiAgaWYgKHR5cGVvZiBEYXRhVmlldyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIHJldHVybiBpc0RhdGFWaWV3VG9TdHJpbmcud29ya2luZ1xyXG4gICAgPyBpc0RhdGFWaWV3VG9TdHJpbmcodmFsdWUpXHJcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgRGF0YVZpZXc7XHJcbn1cclxuZXhwb3J0cy5pc0RhdGFWaWV3ID0gaXNEYXRhVmlldztcclxuXHJcbi8vIFN0b3JlIGEgY29weSBvZiBTaGFyZWRBcnJheUJ1ZmZlciBpbiBjYXNlIGl0J3MgZGVsZXRlZCBlbHNld2hlcmVcclxudmFyIFNoYXJlZEFycmF5QnVmZmVyQ29weSA9IHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgPyBTaGFyZWRBcnJheUJ1ZmZlciA6IHVuZGVmaW5lZDtcclxuZnVuY3Rpb24gaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nKHZhbHVlKSB7XHJcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgU2hhcmVkQXJyYXlCdWZmZXJdJztcclxufVxyXG5mdW5jdGlvbiBpc1NoYXJlZEFycmF5QnVmZmVyKHZhbHVlKSB7XHJcbiAgaWYgKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlckNvcHkgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmcgPSBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcobmV3IFNoYXJlZEFycmF5QnVmZmVyQ29weSgpKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZ1xyXG4gICAgPyBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpXHJcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXJDb3B5O1xyXG59XHJcbmV4cG9ydHMuaXNTaGFyZWRBcnJheUJ1ZmZlciA9IGlzU2hhcmVkQXJyYXlCdWZmZXI7XHJcblxyXG5mdW5jdGlvbiBpc0FzeW5jRnVuY3Rpb24odmFsdWUpIHtcclxuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXSc7XHJcbn1cclxuZXhwb3J0cy5pc0FzeW5jRnVuY3Rpb24gPSBpc0FzeW5jRnVuY3Rpb247XHJcblxyXG5mdW5jdGlvbiBpc01hcEl0ZXJhdG9yKHZhbHVlKSB7XHJcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgTWFwIEl0ZXJhdG9yXSc7XHJcbn1cclxuZXhwb3J0cy5pc01hcEl0ZXJhdG9yID0gaXNNYXBJdGVyYXRvcjtcclxuXHJcbmZ1bmN0aW9uIGlzU2V0SXRlcmF0b3IodmFsdWUpIHtcclxuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBTZXQgSXRlcmF0b3JdJztcclxufVxyXG5leHBvcnRzLmlzU2V0SXRlcmF0b3IgPSBpc1NldEl0ZXJhdG9yO1xyXG5cclxuZnVuY3Rpb24gaXNHZW5lcmF0b3JPYmplY3QodmFsdWUpIHtcclxuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBHZW5lcmF0b3JdJztcclxufVxyXG5leHBvcnRzLmlzR2VuZXJhdG9yT2JqZWN0ID0gaXNHZW5lcmF0b3JPYmplY3Q7XHJcblxyXG5mdW5jdGlvbiBpc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGUodmFsdWUpIHtcclxuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBXZWJBc3NlbWJseS5Nb2R1bGVdJztcclxufVxyXG5leHBvcnRzLmlzV2ViQXNzZW1ibHlDb21waWxlZE1vZHVsZSA9IGlzV2ViQXNzZW1ibHlDb21waWxlZE1vZHVsZTtcclxuXHJcbmZ1bmN0aW9uIGlzTnVtYmVyT2JqZWN0KHZhbHVlKSB7XHJcbiAgcmV0dXJuIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIG51bWJlclZhbHVlKTtcclxufVxyXG5leHBvcnRzLmlzTnVtYmVyT2JqZWN0ID0gaXNOdW1iZXJPYmplY3Q7XHJcblxyXG5mdW5jdGlvbiBpc1N0cmluZ09iamVjdCh2YWx1ZSkge1xyXG4gIHJldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBzdHJpbmdWYWx1ZSk7XHJcbn1cclxuZXhwb3J0cy5pc1N0cmluZ09iamVjdCA9IGlzU3RyaW5nT2JqZWN0O1xyXG5cclxuZnVuY3Rpb24gaXNCb29sZWFuT2JqZWN0KHZhbHVlKSB7XHJcbiAgcmV0dXJuIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIGJvb2xlYW5WYWx1ZSk7XHJcbn1cclxuZXhwb3J0cy5pc0Jvb2xlYW5PYmplY3QgPSBpc0Jvb2xlYW5PYmplY3Q7XHJcblxyXG5mdW5jdGlvbiBpc0JpZ0ludE9iamVjdCh2YWx1ZSkge1xyXG4gIHJldHVybiBCaWdJbnRTdXBwb3J0ZWQgJiYgY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgYmlnSW50VmFsdWUpO1xyXG59XHJcbmV4cG9ydHMuaXNCaWdJbnRPYmplY3QgPSBpc0JpZ0ludE9iamVjdDtcclxuXHJcbmZ1bmN0aW9uIGlzU3ltYm9sT2JqZWN0KHZhbHVlKSB7XHJcbiAgcmV0dXJuIFN5bWJvbFN1cHBvcnRlZCAmJiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBzeW1ib2xWYWx1ZSk7XHJcbn1cclxuZXhwb3J0cy5pc1N5bWJvbE9iamVjdCA9IGlzU3ltYm9sT2JqZWN0O1xyXG5cclxuZnVuY3Rpb24gaXNCb3hlZFByaW1pdGl2ZSh2YWx1ZSkge1xyXG4gIHJldHVybiAoXHJcbiAgICBpc051bWJlck9iamVjdCh2YWx1ZSkgfHxcclxuICAgIGlzU3RyaW5nT2JqZWN0KHZhbHVlKSB8fFxyXG4gICAgaXNCb29sZWFuT2JqZWN0KHZhbHVlKSB8fFxyXG4gICAgaXNCaWdJbnRPYmplY3QodmFsdWUpIHx8XHJcbiAgICBpc1N5bWJvbE9iamVjdCh2YWx1ZSlcclxuICApO1xyXG59XHJcbmV4cG9ydHMuaXNCb3hlZFByaW1pdGl2ZSA9IGlzQm94ZWRQcmltaXRpdmU7XHJcblxyXG5mdW5jdGlvbiBpc0FueUFycmF5QnVmZmVyKHZhbHVlKSB7XHJcbiAgcmV0dXJuIHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiAoXHJcbiAgICBpc0FycmF5QnVmZmVyKHZhbHVlKSB8fFxyXG4gICAgaXNTaGFyZWRBcnJheUJ1ZmZlcih2YWx1ZSlcclxuICApO1xyXG59XHJcbmV4cG9ydHMuaXNBbnlBcnJheUJ1ZmZlciA9IGlzQW55QXJyYXlCdWZmZXI7XHJcblxyXG5bJ2lzUHJveHknLCAnaXNFeHRlcm5hbCcsICdpc01vZHVsZU5hbWVzcGFjZU9iamVjdCddLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG1ldGhvZCwge1xyXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXRob2QgKyAnIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdXNlcmxhbmQnKTtcclxuICAgIH1cclxuICB9KTtcclxufSk7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/util/support/types.js\n");

/***/ }),

/***/ "./node_modules/util/util.js":
/*!***********************************!*\
  !*** ./node_modules/util/util.js ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/process/browser.js\");\n// Copyright Joyent, Inc. and other Node contributors.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the\r\n// \"Software\"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n// persons to whom the Software is furnished to do so, subject to the\r\n// following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\r\n  function getOwnPropertyDescriptors(obj) {\r\n    var keys = Object.keys(obj);\r\n    var descriptors = {};\r\n    for (var i = 0; i < keys.length; i++) {\r\n      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\r\n    }\r\n    return descriptors;\r\n  };\r\n\r\nvar formatRegExp = /%[sdj%]/g;\r\nexports.format = function(f) {\r\n  if (!isString(f)) {\r\n    var objects = [];\r\n    for (var i = 0; i < arguments.length; i++) {\r\n      objects.push(inspect(arguments[i]));\r\n    }\r\n    return objects.join(' ');\r\n  }\r\n\r\n  var i = 1;\r\n  var args = arguments;\r\n  var len = args.length;\r\n  var str = String(f).replace(formatRegExp, function(x) {\r\n    if (x === '%%') return '%';\r\n    if (i >= len) return x;\r\n    switch (x) {\r\n      case '%s': return String(args[i++]);\r\n      case '%d': return Number(args[i++]);\r\n      case '%j':\r\n        try {\r\n          return JSON.stringify(args[i++]);\r\n        } catch (_) {\r\n          return '[Circular]';\r\n        }\r\n      default:\r\n        return x;\r\n    }\r\n  });\r\n  for (var x = args[i]; i < len; x = args[++i]) {\r\n    if (isNull(x) || !isObject(x)) {\r\n      str += ' ' + x;\r\n    } else {\r\n      str += ' ' + inspect(x);\r\n    }\r\n  }\r\n  return str;\r\n};\r\n\r\n\r\n// Mark that a method should not be used.\r\n// Returns a modified function which warns once by default.\r\n// If --no-deprecation is set, then it is a no-op.\r\nexports.deprecate = function(fn, msg) {\r\n  if (typeof process !== 'undefined' && process.noDeprecation === true) {\r\n    return fn;\r\n  }\r\n\r\n  // Allow for deprecating things in the process of starting up.\r\n  if (typeof process === 'undefined') {\r\n    return function() {\r\n      return exports.deprecate(fn, msg).apply(this, arguments);\r\n    };\r\n  }\r\n\r\n  var warned = false;\r\n  function deprecated() {\r\n    if (!warned) {\r\n      if (process.throwDeprecation) {\r\n        throw new Error(msg);\r\n      } else if (process.traceDeprecation) {\r\n        console.trace(msg);\r\n      } else {\r\n        console.error(msg);\r\n      }\r\n      warned = true;\r\n    }\r\n    return fn.apply(this, arguments);\r\n  }\r\n\r\n  return deprecated;\r\n};\r\n\r\n\r\nvar debugs = {};\r\nvar debugEnvRegex = /^$/;\r\n\r\nif (process.env.NODE_DEBUG) {\r\n  var debugEnv = process.env.NODE_DEBUG;\r\n  debugEnv = debugEnv.replace(/[|\\\\{}()[\\]^$+?.]/g, '\\\\$&')\r\n    .replace(/\\*/g, '.*')\r\n    .replace(/,/g, '$|^')\r\n    .toUpperCase();\r\n  debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');\r\n}\r\nexports.debuglog = function(set) {\r\n  set = set.toUpperCase();\r\n  if (!debugs[set]) {\r\n    if (debugEnvRegex.test(set)) {\r\n      var pid = process.pid;\r\n      debugs[set] = function() {\r\n        var msg = exports.format.apply(exports, arguments);\r\n        console.error('%s %d: %s', set, pid, msg);\r\n      };\r\n    } else {\r\n      debugs[set] = function() {};\r\n    }\r\n  }\r\n  return debugs[set];\r\n};\r\n\r\n\r\n/**\r\n * Echos the value of a value. Trys to print the value out\r\n * in the best way possible given the different types.\r\n *\r\n * @param {Object} obj The object to print out.\r\n * @param {Object} opts Optional options object that alters the output.\r\n */\r\n/* legacy: obj, showHidden, depth, colors*/\r\nfunction inspect(obj, opts) {\r\n  // default options\r\n  var ctx = {\r\n    seen: [],\r\n    stylize: stylizeNoColor\r\n  };\r\n  // legacy...\r\n  if (arguments.length >= 3) ctx.depth = arguments[2];\r\n  if (arguments.length >= 4) ctx.colors = arguments[3];\r\n  if (isBoolean(opts)) {\r\n    // legacy...\r\n    ctx.showHidden = opts;\r\n  } else if (opts) {\r\n    // got an \"options\" object\r\n    exports._extend(ctx, opts);\r\n  }\r\n  // set default options\r\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\r\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\r\n  if (isUndefined(ctx.colors)) ctx.colors = false;\r\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\r\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\r\n  return formatValue(ctx, obj, ctx.depth);\r\n}\r\nexports.inspect = inspect;\r\n\r\n\r\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\r\ninspect.colors = {\r\n  'bold' : [1, 22],\r\n  'italic' : [3, 23],\r\n  'underline' : [4, 24],\r\n  'inverse' : [7, 27],\r\n  'white' : [37, 39],\r\n  'grey' : [90, 39],\r\n  'black' : [30, 39],\r\n  'blue' : [34, 39],\r\n  'cyan' : [36, 39],\r\n  'green' : [32, 39],\r\n  'magenta' : [35, 39],\r\n  'red' : [31, 39],\r\n  'yellow' : [33, 39]\r\n};\r\n\r\n// Don't use 'blue' not visible on cmd.exe\r\ninspect.styles = {\r\n  'special': 'cyan',\r\n  'number': 'yellow',\r\n  'boolean': 'yellow',\r\n  'undefined': 'grey',\r\n  'null': 'bold',\r\n  'string': 'green',\r\n  'date': 'magenta',\r\n  // \"name\": intentionally not styling\r\n  'regexp': 'red'\r\n};\r\n\r\n\r\nfunction stylizeWithColor(str, styleType) {\r\n  var style = inspect.styles[styleType];\r\n\r\n  if (style) {\r\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\r\n           '\\u001b[' + inspect.colors[style][1] + 'm';\r\n  } else {\r\n    return str;\r\n  }\r\n}\r\n\r\n\r\nfunction stylizeNoColor(str, styleType) {\r\n  return str;\r\n}\r\n\r\n\r\nfunction arrayToHash(array) {\r\n  var hash = {};\r\n\r\n  array.forEach(function(val, idx) {\r\n    hash[val] = true;\r\n  });\r\n\r\n  return hash;\r\n}\r\n\r\n\r\nfunction formatValue(ctx, value, recurseTimes) {\r\n  // Provide a hook for user-specified inspect functions.\r\n  // Check that value is an object with an inspect function on it\r\n  if (ctx.customInspect &&\r\n      value &&\r\n      isFunction(value.inspect) &&\r\n      // Filter out the util module, it's inspect function is special\r\n      value.inspect !== exports.inspect &&\r\n      // Also filter out any prototype objects using the circular check.\r\n      !(value.constructor && value.constructor.prototype === value)) {\r\n    var ret = value.inspect(recurseTimes, ctx);\r\n    if (!isString(ret)) {\r\n      ret = formatValue(ctx, ret, recurseTimes);\r\n    }\r\n    return ret;\r\n  }\r\n\r\n  // Primitive types cannot have properties\r\n  var primitive = formatPrimitive(ctx, value);\r\n  if (primitive) {\r\n    return primitive;\r\n  }\r\n\r\n  // Look up the keys of the object.\r\n  var keys = Object.keys(value);\r\n  var visibleKeys = arrayToHash(keys);\r\n\r\n  if (ctx.showHidden) {\r\n    keys = Object.getOwnPropertyNames(value);\r\n  }\r\n\r\n  // IE doesn't make error fields non-enumerable\r\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\r\n  if (isError(value)\r\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\r\n    return formatError(value);\r\n  }\r\n\r\n  // Some type of object without properties can be shortcutted.\r\n  if (keys.length === 0) {\r\n    if (isFunction(value)) {\r\n      var name = value.name ? ': ' + value.name : '';\r\n      return ctx.stylize('[Function' + name + ']', 'special');\r\n    }\r\n    if (isRegExp(value)) {\r\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\r\n    }\r\n    if (isDate(value)) {\r\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\r\n    }\r\n    if (isError(value)) {\r\n      return formatError(value);\r\n    }\r\n  }\r\n\r\n  var base = '', array = false, braces = ['{', '}'];\r\n\r\n  // Make Array say that they are Array\r\n  if (isArray(value)) {\r\n    array = true;\r\n    braces = ['[', ']'];\r\n  }\r\n\r\n  // Make functions say that they are functions\r\n  if (isFunction(value)) {\r\n    var n = value.name ? ': ' + value.name : '';\r\n    base = ' [Function' + n + ']';\r\n  }\r\n\r\n  // Make RegExps say that they are RegExps\r\n  if (isRegExp(value)) {\r\n    base = ' ' + RegExp.prototype.toString.call(value);\r\n  }\r\n\r\n  // Make dates with properties first say the date\r\n  if (isDate(value)) {\r\n    base = ' ' + Date.prototype.toUTCString.call(value);\r\n  }\r\n\r\n  // Make error with message first say the error\r\n  if (isError(value)) {\r\n    base = ' ' + formatError(value);\r\n  }\r\n\r\n  if (keys.length === 0 && (!array || value.length == 0)) {\r\n    return braces[0] + base + braces[1];\r\n  }\r\n\r\n  if (recurseTimes < 0) {\r\n    if (isRegExp(value)) {\r\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\r\n    } else {\r\n      return ctx.stylize('[Object]', 'special');\r\n    }\r\n  }\r\n\r\n  ctx.seen.push(value);\r\n\r\n  var output;\r\n  if (array) {\r\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\r\n  } else {\r\n    output = keys.map(function(key) {\r\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\r\n    });\r\n  }\r\n\r\n  ctx.seen.pop();\r\n\r\n  return reduceToSingleString(output, base, braces);\r\n}\r\n\r\n\r\nfunction formatPrimitive(ctx, value) {\r\n  if (isUndefined(value))\r\n    return ctx.stylize('undefined', 'undefined');\r\n  if (isString(value)) {\r\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\r\n                                             .replace(/'/g, \"\\\\'\")\r\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\r\n    return ctx.stylize(simple, 'string');\r\n  }\r\n  if (isNumber(value))\r\n    return ctx.stylize('' + value, 'number');\r\n  if (isBoolean(value))\r\n    return ctx.stylize('' + value, 'boolean');\r\n  // For some reason typeof null is \"object\", so special case here.\r\n  if (isNull(value))\r\n    return ctx.stylize('null', 'null');\r\n}\r\n\r\n\r\nfunction formatError(value) {\r\n  return '[' + Error.prototype.toString.call(value) + ']';\r\n}\r\n\r\n\r\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\r\n  var output = [];\r\n  for (var i = 0, l = value.length; i < l; ++i) {\r\n    if (hasOwnProperty(value, String(i))) {\r\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\r\n          String(i), true));\r\n    } else {\r\n      output.push('');\r\n    }\r\n  }\r\n  keys.forEach(function(key) {\r\n    if (!key.match(/^\\d+$/)) {\r\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\r\n          key, true));\r\n    }\r\n  });\r\n  return output;\r\n}\r\n\r\n\r\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\r\n  var name, str, desc;\r\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\r\n  if (desc.get) {\r\n    if (desc.set) {\r\n      str = ctx.stylize('[Getter/Setter]', 'special');\r\n    } else {\r\n      str = ctx.stylize('[Getter]', 'special');\r\n    }\r\n  } else {\r\n    if (desc.set) {\r\n      str = ctx.stylize('[Setter]', 'special');\r\n    }\r\n  }\r\n  if (!hasOwnProperty(visibleKeys, key)) {\r\n    name = '[' + key + ']';\r\n  }\r\n  if (!str) {\r\n    if (ctx.seen.indexOf(desc.value) < 0) {\r\n      if (isNull(recurseTimes)) {\r\n        str = formatValue(ctx, desc.value, null);\r\n      } else {\r\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\r\n      }\r\n      if (str.indexOf('\\n') > -1) {\r\n        if (array) {\r\n          str = str.split('\\n').map(function(line) {\r\n            return '  ' + line;\r\n          }).join('\\n').substr(2);\r\n        } else {\r\n          str = '\\n' + str.split('\\n').map(function(line) {\r\n            return '   ' + line;\r\n          }).join('\\n');\r\n        }\r\n      }\r\n    } else {\r\n      str = ctx.stylize('[Circular]', 'special');\r\n    }\r\n  }\r\n  if (isUndefined(name)) {\r\n    if (array && key.match(/^\\d+$/)) {\r\n      return str;\r\n    }\r\n    name = JSON.stringify('' + key);\r\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\r\n      name = name.substr(1, name.length - 2);\r\n      name = ctx.stylize(name, 'name');\r\n    } else {\r\n      name = name.replace(/'/g, \"\\\\'\")\r\n                 .replace(/\\\\\"/g, '\"')\r\n                 .replace(/(^\"|\"$)/g, \"'\");\r\n      name = ctx.stylize(name, 'string');\r\n    }\r\n  }\r\n\r\n  return name + ': ' + str;\r\n}\r\n\r\n\r\nfunction reduceToSingleString(output, base, braces) {\r\n  var numLinesEst = 0;\r\n  var length = output.reduce(function(prev, cur) {\r\n    numLinesEst++;\r\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\r\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\r\n  }, 0);\r\n\r\n  if (length > 60) {\r\n    return braces[0] +\r\n           (base === '' ? '' : base + '\\n ') +\r\n           ' ' +\r\n           output.join(',\\n  ') +\r\n           ' ' +\r\n           braces[1];\r\n  }\r\n\r\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\r\n}\r\n\r\n\r\n// NOTE: These type checking functions intentionally don't use `instanceof`\r\n// because it is fragile and can be easily faked with `Object.create()`.\r\nexports.types = __webpack_require__(/*! ./support/types */ \"./node_modules/util/support/types.js\");\r\n\r\nfunction isArray(ar) {\r\n  return Array.isArray(ar);\r\n}\r\nexports.isArray = isArray;\r\n\r\nfunction isBoolean(arg) {\r\n  return typeof arg === 'boolean';\r\n}\r\nexports.isBoolean = isBoolean;\r\n\r\nfunction isNull(arg) {\r\n  return arg === null;\r\n}\r\nexports.isNull = isNull;\r\n\r\nfunction isNullOrUndefined(arg) {\r\n  return arg == null;\r\n}\r\nexports.isNullOrUndefined = isNullOrUndefined;\r\n\r\nfunction isNumber(arg) {\r\n  return typeof arg === 'number';\r\n}\r\nexports.isNumber = isNumber;\r\n\r\nfunction isString(arg) {\r\n  return typeof arg === 'string';\r\n}\r\nexports.isString = isString;\r\n\r\nfunction isSymbol(arg) {\r\n  return typeof arg === 'symbol';\r\n}\r\nexports.isSymbol = isSymbol;\r\n\r\nfunction isUndefined(arg) {\r\n  return arg === void 0;\r\n}\r\nexports.isUndefined = isUndefined;\r\n\r\nfunction isRegExp(re) {\r\n  return isObject(re) && objectToString(re) === '[object RegExp]';\r\n}\r\nexports.isRegExp = isRegExp;\r\nexports.types.isRegExp = isRegExp;\r\n\r\nfunction isObject(arg) {\r\n  return typeof arg === 'object' && arg !== null;\r\n}\r\nexports.isObject = isObject;\r\n\r\nfunction isDate(d) {\r\n  return isObject(d) && objectToString(d) === '[object Date]';\r\n}\r\nexports.isDate = isDate;\r\nexports.types.isDate = isDate;\r\n\r\nfunction isError(e) {\r\n  return isObject(e) &&\r\n      (objectToString(e) === '[object Error]' || e instanceof Error);\r\n}\r\nexports.isError = isError;\r\nexports.types.isNativeError = isError;\r\n\r\nfunction isFunction(arg) {\r\n  return typeof arg === 'function';\r\n}\r\nexports.isFunction = isFunction;\r\n\r\nfunction isPrimitive(arg) {\r\n  return arg === null ||\r\n         typeof arg === 'boolean' ||\r\n         typeof arg === 'number' ||\r\n         typeof arg === 'string' ||\r\n         typeof arg === 'symbol' ||  // ES6 symbol\r\n         typeof arg === 'undefined';\r\n}\r\nexports.isPrimitive = isPrimitive;\r\n\r\nexports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ \"./node_modules/util/support/isBufferBrowser.js\");\r\n\r\nfunction objectToString(o) {\r\n  return Object.prototype.toString.call(o);\r\n}\r\n\r\n\r\nfunction pad(n) {\r\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\r\n}\r\n\r\n\r\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\r\n              'Oct', 'Nov', 'Dec'];\r\n\r\n// 26 Feb 16:19:34\r\nfunction timestamp() {\r\n  var d = new Date();\r\n  var time = [pad(d.getHours()),\r\n              pad(d.getMinutes()),\r\n              pad(d.getSeconds())].join(':');\r\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\r\n}\r\n\r\n\r\n// log is just a thin wrapper to console.log that prepends a timestamp\r\nexports.log = function() {\r\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\r\n};\r\n\r\n\r\n/**\r\n * Inherit the prototype methods from one constructor into another.\r\n *\r\n * The Function.prototype.inherits from lang.js rewritten as a standalone\r\n * function (not on Function.prototype). NOTE: If this file is to be loaded\r\n * during bootstrapping this function needs to be rewritten using some native\r\n * functions as prototype setup using normal JavaScript does not work as\r\n * expected during bootstrapping (see mirror.js in r114903).\r\n *\r\n * @param {function} ctor Constructor function which needs to inherit the\r\n *     prototype.\r\n * @param {function} superCtor Constructor function to inherit prototype from.\r\n */\r\nexports.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\r\n\r\nexports._extend = function(origin, add) {\r\n  // Don't do anything if add isn't an object\r\n  if (!add || !isObject(add)) return origin;\r\n\r\n  var keys = Object.keys(add);\r\n  var i = keys.length;\r\n  while (i--) {\r\n    origin[keys[i]] = add[keys[i]];\r\n  }\r\n  return origin;\r\n};\r\n\r\nfunction hasOwnProperty(obj, prop) {\r\n  return Object.prototype.hasOwnProperty.call(obj, prop);\r\n}\r\n\r\nvar kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;\r\n\r\nexports.promisify = function promisify(original) {\r\n  if (typeof original !== 'function')\r\n    throw new TypeError('The \"original\" argument must be of type Function');\r\n\r\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\r\n    var fn = original[kCustomPromisifiedSymbol];\r\n    if (typeof fn !== 'function') {\r\n      throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\r\n    }\r\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\r\n      value: fn, enumerable: false, writable: false, configurable: true\r\n    });\r\n    return fn;\r\n  }\r\n\r\n  function fn() {\r\n    var promiseResolve, promiseReject;\r\n    var promise = new Promise(function (resolve, reject) {\r\n      promiseResolve = resolve;\r\n      promiseReject = reject;\r\n    });\r\n\r\n    var args = [];\r\n    for (var i = 0; i < arguments.length; i++) {\r\n      args.push(arguments[i]);\r\n    }\r\n    args.push(function (err, value) {\r\n      if (err) {\r\n        promiseReject(err);\r\n      } else {\r\n        promiseResolve(value);\r\n      }\r\n    });\r\n\r\n    try {\r\n      original.apply(this, args);\r\n    } catch (err) {\r\n      promiseReject(err);\r\n    }\r\n\r\n    return promise;\r\n  }\r\n\r\n  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\r\n\r\n  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {\r\n    value: fn, enumerable: false, writable: false, configurable: true\r\n  });\r\n  return Object.defineProperties(\r\n    fn,\r\n    getOwnPropertyDescriptors(original)\r\n  );\r\n}\r\n\r\nexports.promisify.custom = kCustomPromisifiedSymbol\r\n\r\nfunction callbackifyOnRejected(reason, cb) {\r\n  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\r\n  // Because `null` is a special error value in callbacks which means \"no error\r\n  // occurred\", we error-wrap so the callback consumer can distinguish between\r\n  // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\r\n  if (!reason) {\r\n    var newReason = new Error('Promise was rejected with a falsy value');\r\n    newReason.reason = reason;\r\n    reason = newReason;\r\n  }\r\n  return cb(reason);\r\n}\r\n\r\nfunction callbackify(original) {\r\n  if (typeof original !== 'function') {\r\n    throw new TypeError('The \"original\" argument must be of type Function');\r\n  }\r\n\r\n  // We DO NOT return the promise as it gives the user a false sense that\r\n  // the promise is actually somehow related to the callback's execution\r\n  // and that the callback throwing will reject the promise.\r\n  function callbackified() {\r\n    var args = [];\r\n    for (var i = 0; i < arguments.length; i++) {\r\n      args.push(arguments[i]);\r\n    }\r\n\r\n    var maybeCb = args.pop();\r\n    if (typeof maybeCb !== 'function') {\r\n      throw new TypeError('The last argument must be of type Function');\r\n    }\r\n    var self = this;\r\n    var cb = function() {\r\n      return maybeCb.apply(self, arguments);\r\n    };\r\n    // In true node style we process the callback on `nextTick` with all the\r\n    // implications (stack, `uncaughtException`, `async_hooks`)\r\n    original.apply(this, args)\r\n      .then(function(ret) { process.nextTick(cb.bind(null, null, ret)) },\r\n            function(rej) { process.nextTick(callbackifyOnRejected.bind(null, rej, cb)) });\r\n  }\r\n\r\n  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\r\n  Object.defineProperties(callbackified,\r\n                          getOwnPropertyDescriptors(original));\r\n  return callbackified;\r\n}\r\nexports.callbackify = callbackify;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzLmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWEsT0FBTyxvQkFBb0IsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCO0FBQ0EsUUFBUSxTQUFTLE9BQU87QUFDeEI7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksT0FBTztBQUNYLGlCQUFpQixPQUFPO0FBQ3hCLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxLQUFLO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrR0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxrSEFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQSxxR0FBc0M7QUFDdEM7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixPQUFPLHFDQUFxQztBQUN4RSw0QkFBNEIsT0FBTyxzREFBc0Q7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3V0aWwvdXRpbC5qcz8yYjM4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxyXG4vL1xyXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxyXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXHJcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xyXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXHJcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcclxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXHJcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG4vL1xyXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxyXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuLy9cclxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xyXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXHJcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cclxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXHJcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxyXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXHJcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXHJcblxyXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIHx8XHJcbiAgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmopIHtcclxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcclxuICAgIHZhciBkZXNjcmlwdG9ycyA9IHt9O1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGRlc2NyaXB0b3JzW2tleXNbaV1dID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleXNbaV0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRlc2NyaXB0b3JzO1xyXG4gIH07XHJcblxyXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcclxuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XHJcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xyXG4gICAgdmFyIG9iamVjdHMgPSBbXTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xyXG4gIH1cclxuXHJcbiAgdmFyIGkgPSAxO1xyXG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xyXG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcclxuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XHJcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcclxuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XHJcbiAgICBzd2l0Y2ggKHgpIHtcclxuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XHJcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xyXG4gICAgICBjYXNlICclaic6XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xyXG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcclxuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XHJcbiAgICAgICAgfVxyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHJldHVybiB4O1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XHJcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xyXG4gICAgICBzdHIgKz0gJyAnICsgeDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gc3RyO1xyXG59O1xyXG5cclxuXHJcbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXHJcbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXHJcbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXHJcbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xyXG4gIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XHJcbiAgICByZXR1cm4gZm47XHJcbiAgfVxyXG5cclxuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxyXG4gIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xyXG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XHJcbiAgICBpZiAoIXdhcm5lZCkge1xyXG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XHJcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XHJcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcclxuICAgICAgfVxyXG4gICAgICB3YXJuZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZGVwcmVjYXRlZDtcclxufTtcclxuXHJcblxyXG52YXIgZGVidWdzID0ge307XHJcbnZhciBkZWJ1Z0VudlJlZ2V4ID0gL14kLztcclxuXHJcbmlmIChwcm9jZXNzLmVudi5OT0RFX0RFQlVHKSB7XHJcbiAgdmFyIGRlYnVnRW52ID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRztcclxuICBkZWJ1Z0VudiA9IGRlYnVnRW52LnJlcGxhY2UoL1t8XFxcXHt9KClbXFxdXiQrPy5dL2csICdcXFxcJCYnKVxyXG4gICAgLnJlcGxhY2UoL1xcKi9nLCAnLionKVxyXG4gICAgLnJlcGxhY2UoLywvZywgJyR8XicpXHJcbiAgICAudG9VcHBlckNhc2UoKTtcclxuICBkZWJ1Z0VudlJlZ2V4ID0gbmV3IFJlZ0V4cCgnXicgKyBkZWJ1Z0VudiArICckJywgJ2knKTtcclxufVxyXG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XHJcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XHJcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xyXG4gICAgaWYgKGRlYnVnRW52UmVnZXgudGVzdChzZXQpKSB7XHJcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcclxuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcclxuICAgICAgfTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XHJcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxyXG4gKi9cclxuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xyXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xyXG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xyXG4gIHZhciBjdHggPSB7XHJcbiAgICBzZWVuOiBbXSxcclxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXHJcbiAgfTtcclxuICAvLyBsZWdhY3kuLi5cclxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XHJcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcclxuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XHJcbiAgICAvLyBsZWdhY3kuLi5cclxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcclxuICB9IGVsc2UgaWYgKG9wdHMpIHtcclxuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcclxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xyXG4gIH1cclxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXHJcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcclxuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcclxuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcclxuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XHJcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcclxuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XHJcbn1cclxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcclxuXHJcblxyXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3NcclxuaW5zcGVjdC5jb2xvcnMgPSB7XHJcbiAgJ2JvbGQnIDogWzEsIDIyXSxcclxuICAnaXRhbGljJyA6IFszLCAyM10sXHJcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxyXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXHJcbiAgJ3doaXRlJyA6IFszNywgMzldLFxyXG4gICdncmV5JyA6IFs5MCwgMzldLFxyXG4gICdibGFjaycgOiBbMzAsIDM5XSxcclxuICAnYmx1ZScgOiBbMzQsIDM5XSxcclxuICAnY3lhbicgOiBbMzYsIDM5XSxcclxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXHJcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXHJcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcclxuICAneWVsbG93JyA6IFszMywgMzldXHJcbn07XHJcblxyXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcclxuaW5zcGVjdC5zdHlsZXMgPSB7XHJcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXHJcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxyXG4gICdib29sZWFuJzogJ3llbGxvdycsXHJcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcclxuICAnbnVsbCc6ICdib2xkJyxcclxuICAnc3RyaW5nJzogJ2dyZWVuJyxcclxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcclxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xyXG4gICdyZWdleHAnOiAncmVkJ1xyXG59O1xyXG5cclxuXHJcbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcclxuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xyXG5cclxuICBpZiAoc3R5bGUpIHtcclxuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcclxuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gc3RyO1xyXG4gIH1cclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XHJcbiAgcmV0dXJuIHN0cjtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XHJcbiAgdmFyIGhhc2ggPSB7fTtcclxuXHJcbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xyXG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIGhhc2g7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcclxuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXHJcbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XHJcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXHJcbiAgICAgIHZhbHVlICYmXHJcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcclxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXHJcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxyXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cclxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xyXG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xyXG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XHJcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldDtcclxuICB9XHJcblxyXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXHJcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcclxuICBpZiAocHJpbWl0aXZlKSB7XHJcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xyXG4gIH1cclxuXHJcbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxyXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xyXG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xyXG5cclxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcclxuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XHJcbiAgfVxyXG5cclxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXHJcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcclxuICBpZiAoaXNFcnJvcih2YWx1ZSlcclxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XHJcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xyXG4gIH1cclxuXHJcbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxyXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XHJcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XHJcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XHJcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xyXG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcclxuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XHJcblxyXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcclxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgIGFycmF5ID0gdHJ1ZTtcclxuICAgIGJyYWNlcyA9IFsnWycsICddJ107XHJcbiAgfVxyXG5cclxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcclxuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcclxuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XHJcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcclxuICB9XHJcblxyXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXHJcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xyXG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XHJcbiAgfVxyXG5cclxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcclxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xyXG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xyXG4gIH1cclxuXHJcbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxyXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xyXG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcclxuICB9XHJcblxyXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xyXG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XHJcbiAgfVxyXG5cclxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xyXG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xyXG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcclxuXHJcbiAgdmFyIG91dHB1dDtcclxuICBpZiAoYXJyYXkpIHtcclxuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcclxuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBjdHguc2Vlbi5wb3AoKTtcclxuXHJcbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XHJcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcclxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xyXG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcclxuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcclxuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcclxuICB9XHJcbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcclxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XHJcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXHJcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcclxuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXHJcbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXHJcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcclxuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xyXG4gIHZhciBvdXRwdXQgPSBbXTtcclxuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xyXG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XHJcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXHJcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcclxuICAgIH1cclxuICB9XHJcbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xyXG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XHJcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXHJcbiAgICAgICAgICBrZXksIHRydWUpKTtcclxuICAgIH1cclxuICB9KTtcclxuICByZXR1cm4gb3V0cHV0O1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xyXG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XHJcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xyXG4gIGlmIChkZXNjLmdldCkge1xyXG4gICAgaWYgKGRlc2Muc2V0KSB7XHJcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgaWYgKGRlc2Muc2V0KSB7XHJcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcclxuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XHJcbiAgfVxyXG4gIGlmICghc3RyKSB7XHJcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcclxuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XHJcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xyXG4gICAgICAgIGlmIChhcnJheSkge1xyXG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XHJcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xyXG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xyXG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcclxuICAgICAgcmV0dXJuIHN0cjtcclxuICAgIH1cclxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XHJcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcclxuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XHJcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXHJcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxyXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xyXG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcclxuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xyXG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xyXG4gICAgbnVtTGluZXNFc3QrKztcclxuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcclxuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcclxuICB9LCAwKTtcclxuXHJcbiAgaWYgKGxlbmd0aCA+IDYwKSB7XHJcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcclxuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcclxuICAgICAgICAgICAnICcgK1xyXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXHJcbiAgICAgICAgICAgJyAnICtcclxuICAgICAgICAgICBicmFjZXNbMV07XHJcbiAgfVxyXG5cclxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xyXG59XHJcblxyXG5cclxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXHJcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxyXG5leHBvcnRzLnR5cGVzID0gcmVxdWlyZSgnLi9zdXBwb3J0L3R5cGVzJyk7XHJcblxyXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XHJcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xyXG59XHJcbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XHJcblxyXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XHJcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcclxufVxyXG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcclxuXHJcbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcclxuICByZXR1cm4gYXJnID09PSBudWxsO1xyXG59XHJcbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xyXG5cclxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XHJcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xyXG59XHJcbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcclxuXHJcbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xyXG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcclxufVxyXG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XHJcblxyXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcclxuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XHJcbn1cclxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xyXG5cclxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XHJcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xyXG59XHJcbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcclxuXHJcbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xyXG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcclxufVxyXG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XHJcblxyXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xyXG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcclxufVxyXG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XHJcbmV4cG9ydHMudHlwZXMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcclxuXHJcbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xyXG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XHJcbn1cclxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xyXG5cclxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcclxuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcclxufVxyXG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcclxuZXhwb3J0cy50eXBlcy5pc0RhdGUgPSBpc0RhdGU7XHJcblxyXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcclxuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcclxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XHJcbn1cclxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcclxuZXhwb3J0cy50eXBlcy5pc05hdGl2ZUVycm9yID0gaXNFcnJvcjtcclxuXHJcbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XHJcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XHJcbn1cclxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcclxuXHJcbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xyXG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcclxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XHJcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XHJcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XHJcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXHJcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xyXG59XHJcbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcclxuXHJcbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcclxuXHJcbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcclxuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gcGFkKG4pIHtcclxuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcclxufVxyXG5cclxuXHJcbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcclxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcclxuXHJcbi8vIDI2IEZlYiAxNjoxOTozNFxyXG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XHJcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xyXG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxyXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXHJcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xyXG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XHJcbn1cclxuXHJcblxyXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXHJcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XHJcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cclxuICpcclxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxyXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcclxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcclxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXHJcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxyXG4gKlxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXHJcbiAqICAgICBwcm90b3R5cGUuXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxyXG4gKi9cclxuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XHJcblxyXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xyXG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcclxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcclxuXHJcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xyXG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XHJcbiAgd2hpbGUgKGktLSkge1xyXG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xyXG4gIH1cclxuICByZXR1cm4gb3JpZ2luO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XHJcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xyXG59XHJcblxyXG52YXIga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgPyBTeW1ib2woJ3V0aWwucHJvbWlzaWZ5LmN1c3RvbScpIDogdW5kZWZpbmVkO1xyXG5cclxuZXhwb3J0cy5wcm9taXNpZnkgPSBmdW5jdGlvbiBwcm9taXNpZnkob3JpZ2luYWwpIHtcclxuICBpZiAodHlwZW9mIG9yaWdpbmFsICE9PSAnZnVuY3Rpb24nKVxyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwib3JpZ2luYWxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcclxuXHJcbiAgaWYgKGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCAmJiBvcmlnaW5hbFtrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xdKSB7XHJcbiAgICB2YXIgZm4gPSBvcmlnaW5hbFtrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xdO1xyXG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJ1dGlsLnByb21pc2lmeS5jdXN0b21cIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sLCB7XHJcbiAgICAgIHZhbHVlOiBmbiwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBmbjtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGZuKCkge1xyXG4gICAgdmFyIHByb21pc2VSZXNvbHZlLCBwcm9taXNlUmVqZWN0O1xyXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgIHByb21pc2VSZXNvbHZlID0gcmVzb2x2ZTtcclxuICAgICAgcHJvbWlzZVJlamVjdCA9IHJlamVjdDtcclxuICAgIH0pO1xyXG5cclxuICAgIHZhciBhcmdzID0gW107XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcclxuICAgIH1cclxuICAgIGFyZ3MucHVzaChmdW5jdGlvbiAoZXJyLCB2YWx1ZSkge1xyXG4gICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgcHJvbWlzZVJlamVjdChlcnIpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHByb21pc2VSZXNvbHZlKHZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgcHJvbWlzZVJlamVjdChlcnIpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwcm9taXNlO1xyXG4gIH1cclxuXHJcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGZuLCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob3JpZ2luYWwpKTtcclxuXHJcbiAgaWYgKGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wsIHtcclxuICAgIHZhbHVlOiBmbiwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgfSk7XHJcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFxyXG4gICAgZm4sXHJcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9yaWdpbmFsKVxyXG4gICk7XHJcbn1cclxuXHJcbmV4cG9ydHMucHJvbWlzaWZ5LmN1c3RvbSA9IGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbFxyXG5cclxuZnVuY3Rpb24gY2FsbGJhY2tpZnlPblJlamVjdGVkKHJlYXNvbiwgY2IpIHtcclxuICAvLyBgIXJlYXNvbmAgZ3VhcmQgaW5zcGlyZWQgYnkgYmx1ZWJpcmQgKFJlZjogaHR0cHM6Ly9nb28uZ2wvdDVJUzZNKS5cclxuICAvLyBCZWNhdXNlIGBudWxsYCBpcyBhIHNwZWNpYWwgZXJyb3IgdmFsdWUgaW4gY2FsbGJhY2tzIHdoaWNoIG1lYW5zIFwibm8gZXJyb3JcclxuICAvLyBvY2N1cnJlZFwiLCB3ZSBlcnJvci13cmFwIHNvIHRoZSBjYWxsYmFjayBjb25zdW1lciBjYW4gZGlzdGluZ3Vpc2ggYmV0d2VlblxyXG4gIC8vIFwidGhlIHByb21pc2UgcmVqZWN0ZWQgd2l0aCBudWxsXCIgb3IgXCJ0aGUgcHJvbWlzZSBmdWxmaWxsZWQgd2l0aCB1bmRlZmluZWRcIi5cclxuICBpZiAoIXJlYXNvbikge1xyXG4gICAgdmFyIG5ld1JlYXNvbiA9IG5ldyBFcnJvcignUHJvbWlzZSB3YXMgcmVqZWN0ZWQgd2l0aCBhIGZhbHN5IHZhbHVlJyk7XHJcbiAgICBuZXdSZWFzb24ucmVhc29uID0gcmVhc29uO1xyXG4gICAgcmVhc29uID0gbmV3UmVhc29uO1xyXG4gIH1cclxuICByZXR1cm4gY2IocmVhc29uKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2FsbGJhY2tpZnkob3JpZ2luYWwpIHtcclxuICBpZiAodHlwZW9mIG9yaWdpbmFsICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJvcmlnaW5hbFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xyXG4gIH1cclxuXHJcbiAgLy8gV2UgRE8gTk9UIHJldHVybiB0aGUgcHJvbWlzZSBhcyBpdCBnaXZlcyB0aGUgdXNlciBhIGZhbHNlIHNlbnNlIHRoYXRcclxuICAvLyB0aGUgcHJvbWlzZSBpcyBhY3R1YWxseSBzb21laG93IHJlbGF0ZWQgdG8gdGhlIGNhbGxiYWNrJ3MgZXhlY3V0aW9uXHJcbiAgLy8gYW5kIHRoYXQgdGhlIGNhbGxiYWNrIHRocm93aW5nIHdpbGwgcmVqZWN0IHRoZSBwcm9taXNlLlxyXG4gIGZ1bmN0aW9uIGNhbGxiYWNraWZpZWQoKSB7XHJcbiAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG1heWJlQ2IgPSBhcmdzLnBvcCgpO1xyXG4gICAgaWYgKHR5cGVvZiBtYXliZUNiICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBsYXN0IGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xyXG4gICAgfVxyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgdmFyIGNiID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiBtYXliZUNiLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gICAgLy8gSW4gdHJ1ZSBub2RlIHN0eWxlIHdlIHByb2Nlc3MgdGhlIGNhbGxiYWNrIG9uIGBuZXh0VGlja2Agd2l0aCBhbGwgdGhlXHJcbiAgICAvLyBpbXBsaWNhdGlvbnMgKHN0YWNrLCBgdW5jYXVnaHRFeGNlcHRpb25gLCBgYXN5bmNfaG9va3NgKVxyXG4gICAgb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncylcclxuICAgICAgLnRoZW4oZnVuY3Rpb24ocmV0KSB7IHByb2Nlc3MubmV4dFRpY2soY2IuYmluZChudWxsLCBudWxsLCByZXQpKSB9LFxyXG4gICAgICAgICAgICBmdW5jdGlvbihyZWopIHsgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFja2lmeU9uUmVqZWN0ZWQuYmluZChudWxsLCByZWosIGNiKSkgfSk7XHJcbiAgfVxyXG5cclxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoY2FsbGJhY2tpZmllZCwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9yaWdpbmFsKSk7XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY2FsbGJhY2tpZmllZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9yaWdpbmFsKSk7XHJcbiAgcmV0dXJuIGNhbGxiYWNraWZpZWQ7XHJcbn1cclxuZXhwb3J0cy5jYWxsYmFja2lmeSA9IGNhbGxiYWNraWZ5O1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/util/util.js\n");

/***/ }),

/***/ "./node_modules/which-typed-array/index.js":
/*!*************************************************!*\
  !*** ./node_modules/which-typed-array/index.js ***!
  \*************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar forEach = __webpack_require__(/*! foreach */ \"./node_modules/foreach/index.js\");\r\nvar availableTypedArrays = __webpack_require__(/*! available-typed-arrays */ \"./node_modules/available-typed-arrays/index.js\");\r\nvar callBound = __webpack_require__(/*! call-bind/callBound */ \"./node_modules/call-bind/callBound.js\");\r\n\r\nvar $toString = callBound('Object.prototype.toString');\r\nvar hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ \"./node_modules/has-tostringtag/shams.js\")();\r\n\r\nvar g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;\r\nvar typedArrays = availableTypedArrays();\r\n\r\nvar $slice = callBound('String.prototype.slice');\r\nvar toStrTags = {};\r\nvar gOPD = __webpack_require__(/*! es-abstract/helpers/getOwnPropertyDescriptor */ \"./node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js\");\r\nvar getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');\r\nif (hasToStringTag && gOPD && getPrototypeOf) {\r\n\tforEach(typedArrays, function (typedArray) {\r\n\t\tif (typeof g[typedArray] === 'function') {\r\n\t\t\tvar arr = new g[typedArray]();\r\n\t\t\tif (Symbol.toStringTag in arr) {\r\n\t\t\t\tvar proto = getPrototypeOf(arr);\r\n\t\t\t\tvar descriptor = gOPD(proto, Symbol.toStringTag);\r\n\t\t\t\tif (!descriptor) {\r\n\t\t\t\t\tvar superProto = getPrototypeOf(proto);\r\n\t\t\t\t\tdescriptor = gOPD(superProto, Symbol.toStringTag);\r\n\t\t\t\t}\r\n\t\t\t\ttoStrTags[typedArray] = descriptor.get;\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n}\r\n\r\nvar tryTypedArrays = function tryAllTypedArrays(value) {\r\n\tvar foundName = false;\r\n\tforEach(toStrTags, function (getter, typedArray) {\r\n\t\tif (!foundName) {\r\n\t\t\ttry {\r\n\t\t\t\tvar name = getter.call(value);\r\n\t\t\t\tif (name === typedArray) {\r\n\t\t\t\t\tfoundName = name;\r\n\t\t\t\t}\r\n\t\t\t} catch (e) {}\r\n\t\t}\r\n\t});\r\n\treturn foundName;\r\n};\r\n\r\nvar isTypedArray = __webpack_require__(/*! is-typed-array */ \"./node_modules/is-typed-array/index.js\");\r\n\r\nmodule.exports = function whichTypedArray(value) {\r\n\tif (!isTypedArray(value)) { return false; }\r\n\tif (!hasToStringTag || !(Symbol.toStringTag in value)) { return $slice($toString(value), 8, -1); }\r\n\treturn tryTypedArrays(value);\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2hpY2gtdHlwZWQtYXJyYXkvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxnREFBUztBQUMvQiwyQkFBMkIsbUJBQU8sQ0FBQyw4RUFBd0I7QUFDM0QsZ0JBQWdCLG1CQUFPLENBQUMsa0VBQXFCO0FBQzdDO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQU8sQ0FBQyxzRUFBdUI7QUFDcEQ7QUFDQSw0Q0FBNEMscUJBQU07QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFPLENBQUMsb0hBQThDO0FBQ2pFLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsOERBQWdCO0FBQzNDO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsMERBQTBEO0FBQzFEO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3doaWNoLXR5cGVkLWFycmF5L2luZGV4LmpzPzI0OTkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGZvckVhY2ggPSByZXF1aXJlKCdmb3JlYWNoJyk7XHJcbnZhciBhdmFpbGFibGVUeXBlZEFycmF5cyA9IHJlcXVpcmUoJ2F2YWlsYWJsZS10eXBlZC1hcnJheXMnKTtcclxudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC9jYWxsQm91bmQnKTtcclxuXHJcbnZhciAkdG9TdHJpbmcgPSBjYWxsQm91bmQoJ09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcnKTtcclxudmFyIGhhc1RvU3RyaW5nVGFnID0gcmVxdWlyZSgnaGFzLXRvc3RyaW5ndGFnL3NoYW1zJykoKTtcclxuXHJcbnZhciBnID0gdHlwZW9mIGdsb2JhbFRoaXMgPT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogZ2xvYmFsVGhpcztcclxudmFyIHR5cGVkQXJyYXlzID0gYXZhaWxhYmxlVHlwZWRBcnJheXMoKTtcclxuXHJcbnZhciAkc2xpY2UgPSBjYWxsQm91bmQoJ1N0cmluZy5wcm90b3R5cGUuc2xpY2UnKTtcclxudmFyIHRvU3RyVGFncyA9IHt9O1xyXG52YXIgZ09QRCA9IHJlcXVpcmUoJ2VzLWFic3RyYWN0L2hlbHBlcnMvZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJyk7XHJcbnZhciBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjsgLy8gcmVxdWlyZSgnZ2V0cHJvdG90eXBlb2YnKTtcclxuaWYgKGhhc1RvU3RyaW5nVGFnICYmIGdPUEQgJiYgZ2V0UHJvdG90eXBlT2YpIHtcclxuXHRmb3JFYWNoKHR5cGVkQXJyYXlzLCBmdW5jdGlvbiAodHlwZWRBcnJheSkge1xyXG5cdFx0aWYgKHR5cGVvZiBnW3R5cGVkQXJyYXldID09PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdHZhciBhcnIgPSBuZXcgZ1t0eXBlZEFycmF5XSgpO1xyXG5cdFx0XHRpZiAoU3ltYm9sLnRvU3RyaW5nVGFnIGluIGFycikge1xyXG5cdFx0XHRcdHZhciBwcm90byA9IGdldFByb3RvdHlwZU9mKGFycik7XHJcblx0XHRcdFx0dmFyIGRlc2NyaXB0b3IgPSBnT1BEKHByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpO1xyXG5cdFx0XHRcdGlmICghZGVzY3JpcHRvcikge1xyXG5cdFx0XHRcdFx0dmFyIHN1cGVyUHJvdG8gPSBnZXRQcm90b3R5cGVPZihwcm90byk7XHJcblx0XHRcdFx0XHRkZXNjcmlwdG9yID0gZ09QRChzdXBlclByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0b1N0clRhZ3NbdHlwZWRBcnJheV0gPSBkZXNjcmlwdG9yLmdldDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0pO1xyXG59XHJcblxyXG52YXIgdHJ5VHlwZWRBcnJheXMgPSBmdW5jdGlvbiB0cnlBbGxUeXBlZEFycmF5cyh2YWx1ZSkge1xyXG5cdHZhciBmb3VuZE5hbWUgPSBmYWxzZTtcclxuXHRmb3JFYWNoKHRvU3RyVGFncywgZnVuY3Rpb24gKGdldHRlciwgdHlwZWRBcnJheSkge1xyXG5cdFx0aWYgKCFmb3VuZE5hbWUpIHtcclxuXHRcdFx0dHJ5IHtcclxuXHRcdFx0XHR2YXIgbmFtZSA9IGdldHRlci5jYWxsKHZhbHVlKTtcclxuXHRcdFx0XHRpZiAobmFtZSA9PT0gdHlwZWRBcnJheSkge1xyXG5cdFx0XHRcdFx0Zm91bmROYW1lID0gbmFtZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gY2F0Y2ggKGUpIHt9XHJcblx0XHR9XHJcblx0fSk7XHJcblx0cmV0dXJuIGZvdW5kTmFtZTtcclxufTtcclxuXHJcbnZhciBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCdpcy10eXBlZC1hcnJheScpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB3aGljaFR5cGVkQXJyYXkodmFsdWUpIHtcclxuXHRpZiAoIWlzVHlwZWRBcnJheSh2YWx1ZSkpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblx0aWYgKCFoYXNUb1N0cmluZ1RhZyB8fCAhKFN5bWJvbC50b1N0cmluZ1RhZyBpbiB2YWx1ZSkpIHsgcmV0dXJuICRzbGljZSgkdG9TdHJpbmcodmFsdWUpLCA4LCAtMSk7IH1cclxuXHRyZXR1cm4gdHJ5VHlwZWRBcnJheXModmFsdWUpO1xyXG59O1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/which-typed-array/index.js\n");

/***/ }),

/***/ "./node_modules/wrappy/wrappy.js":
/*!***************************************!*\
  !*** ./node_modules/wrappy/wrappy.js ***!
  \***************************************/
/***/ (function(module) {

eval("// Returns a wrapper function that returns a wrapped callback\r\n// The wrapper function should do some stuff, and return a\r\n// presumably different callback function.\r\n// This makes sure that own properties are retained, so that\r\n// decorations and such are not lost along the way.\r\nmodule.exports = wrappy\r\nfunction wrappy (fn, cb) {\r\n  if (fn && cb) return wrappy(fn)(cb)\r\n\r\n  if (typeof fn !== 'function')\r\n    throw new TypeError('need wrapper function')\r\n\r\n  Object.keys(fn).forEach(function (k) {\r\n    wrapper[k] = fn[k]\r\n  })\r\n\r\n  return wrapper\r\n\r\n  function wrapper() {\r\n    var args = new Array(arguments.length)\r\n    for (var i = 0; i < args.length; i++) {\r\n      args[i] = arguments[i]\r\n    }\r\n    var ret = fn.apply(this, args)\r\n    var cb = args[args.length-1]\r\n    if (typeof ret === 'function' && ret !== cb) {\r\n      Object.keys(cb).forEach(function (k) {\r\n        ret[k] = cb[k]\r\n      })\r\n    }\r\n    return ret\r\n  }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd3JhcHB5L3dyYXBweS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy93cmFwcHkvd3JhcHB5LmpzPzk0ZDYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gUmV0dXJucyBhIHdyYXBwZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgd3JhcHBlZCBjYWxsYmFja1xyXG4vLyBUaGUgd3JhcHBlciBmdW5jdGlvbiBzaG91bGQgZG8gc29tZSBzdHVmZiwgYW5kIHJldHVybiBhXHJcbi8vIHByZXN1bWFibHkgZGlmZmVyZW50IGNhbGxiYWNrIGZ1bmN0aW9uLlxyXG4vLyBUaGlzIG1ha2VzIHN1cmUgdGhhdCBvd24gcHJvcGVydGllcyBhcmUgcmV0YWluZWQsIHNvIHRoYXRcclxuLy8gZGVjb3JhdGlvbnMgYW5kIHN1Y2ggYXJlIG5vdCBsb3N0IGFsb25nIHRoZSB3YXkuXHJcbm1vZHVsZS5leHBvcnRzID0gd3JhcHB5XHJcbmZ1bmN0aW9uIHdyYXBweSAoZm4sIGNiKSB7XHJcbiAgaWYgKGZuICYmIGNiKSByZXR1cm4gd3JhcHB5KGZuKShjYilcclxuXHJcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJylcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ25lZWQgd3JhcHBlciBmdW5jdGlvbicpXHJcblxyXG4gIE9iamVjdC5rZXlzKGZuKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XHJcbiAgICB3cmFwcGVyW2tdID0gZm5ba11cclxuICB9KVxyXG5cclxuICByZXR1cm4gd3JhcHBlclxyXG5cclxuICBmdW5jdGlvbiB3cmFwcGVyKCkge1xyXG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aClcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldXHJcbiAgICB9XHJcbiAgICB2YXIgcmV0ID0gZm4uYXBwbHkodGhpcywgYXJncylcclxuICAgIHZhciBjYiA9IGFyZ3NbYXJncy5sZW5ndGgtMV1cclxuICAgIGlmICh0eXBlb2YgcmV0ID09PSAnZnVuY3Rpb24nICYmIHJldCAhPT0gY2IpIHtcclxuICAgICAgT2JqZWN0LmtleXMoY2IpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcclxuICAgICAgICByZXRba10gPSBjYltrXVxyXG4gICAgICB9KVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldFxyXG4gIH1cclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/wrappy/wrappy.js\n");

/***/ }),

/***/ "?7a07":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (function() {

/* (ignored) */

/***/ }),

/***/ "?c852":
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/***/ (function() {

/* (ignored) */

/***/ }),

/***/ "?8c28":
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/***/ (function() {

/* (ignored) */

/***/ }),

/***/ "?114e":
/*!***************************!*\
  !*** ./node.js (ignored) ***!
  \***************************/
/***/ (function() {

/* (ignored) */

/***/ }),

/***/ "./node_modules/available-typed-arrays/index.js":
/*!******************************************************!*\
  !*** ./node_modules/available-typed-arrays/index.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar possibleNames = [\r\n\t'BigInt64Array',\r\n\t'BigUint64Array',\r\n\t'Float32Array',\r\n\t'Float64Array',\r\n\t'Int16Array',\r\n\t'Int32Array',\r\n\t'Int8Array',\r\n\t'Uint16Array',\r\n\t'Uint32Array',\r\n\t'Uint8Array',\r\n\t'Uint8ClampedArray'\r\n];\r\n\r\nvar g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;\r\n\r\nmodule.exports = function availableTypedArrays() {\r\n\tvar out = [];\r\n\tfor (var i = 0; i < possibleNames.length; i++) {\r\n\t\tif (typeof g[possibleNames[i]] === 'function') {\r\n\t\t\tout[out.length] = possibleNames[i];\r\n\t\t}\r\n\t}\r\n\treturn out;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXZhaWxhYmxlLXR5cGVkLWFycmF5cy9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxxQkFBTTtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMEJBQTBCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYXZhaWxhYmxlLXR5cGVkLWFycmF5cy9pbmRleC5qcz8yNjc4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBwb3NzaWJsZU5hbWVzID0gW1xyXG5cdCdCaWdJbnQ2NEFycmF5JyxcclxuXHQnQmlnVWludDY0QXJyYXknLFxyXG5cdCdGbG9hdDMyQXJyYXknLFxyXG5cdCdGbG9hdDY0QXJyYXknLFxyXG5cdCdJbnQxNkFycmF5JyxcclxuXHQnSW50MzJBcnJheScsXHJcblx0J0ludDhBcnJheScsXHJcblx0J1VpbnQxNkFycmF5JyxcclxuXHQnVWludDMyQXJyYXknLFxyXG5cdCdVaW50OEFycmF5JyxcclxuXHQnVWludDhDbGFtcGVkQXJyYXknXHJcbl07XHJcblxyXG52YXIgZyA9IHR5cGVvZiBnbG9iYWxUaGlzID09PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IGdsb2JhbFRoaXM7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGF2YWlsYWJsZVR5cGVkQXJyYXlzKCkge1xyXG5cdHZhciBvdXQgPSBbXTtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHBvc3NpYmxlTmFtZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdGlmICh0eXBlb2YgZ1twb3NzaWJsZU5hbWVzW2ldXSA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRvdXRbb3V0Lmxlbmd0aF0gPSBwb3NzaWJsZU5hbWVzW2ldO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gb3V0O1xyXG59O1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/available-typed-arrays/index.js\n");

/***/ }),

/***/ "./node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js":
/*!**********************************************************************!*\
  !*** ./node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js ***!
  \**********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar GetIntrinsic = __webpack_require__(/*! get-intrinsic */ \"./node_modules/get-intrinsic/index.js\");\r\n\r\nvar $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);\r\nif ($gOPD) {\r\n\ttry {\r\n\t\t$gOPD([], 'length');\r\n\t} catch (e) {\r\n\t\t// IE 8 has a broken gOPD\r\n\t\t$gOPD = null;\r\n\t}\r\n}\r\n\r\nmodule.exports = $gOPD;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvaGVscGVycy9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLDREQUFlO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC9oZWxwZXJzL2dldE93blByb3BlcnR5RGVzY3JpcHRvci5qcz9iN2VhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XHJcblxyXG52YXIgJGdPUEQgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJScsIHRydWUpO1xyXG5pZiAoJGdPUEQpIHtcclxuXHR0cnkge1xyXG5cdFx0JGdPUEQoW10sICdsZW5ndGgnKTtcclxuXHR9IGNhdGNoIChlKSB7XHJcblx0XHQvLyBJRSA4IGhhcyBhIGJyb2tlbiBnT1BEXHJcblx0XHQkZ09QRCA9IG51bGw7XHJcblx0fVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9ICRnT1BEO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/defineProperty.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _defineProperty; }\n/* harmony export */ });\nfunction _defineProperty(obj, key, value) {\r\n  if (key in obj) {\r\n    Object.defineProperty(obj, key, {\r\n      value: value,\r\n      enumerable: true,\r\n      configurable: true,\r\n      writable: true\r\n    });\r\n  } else {\r\n    obj[key] = value;\r\n  }\r\n\r\n  return obj;\r\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHkuanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eS5qcz9mZmIzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcclxuICBpZiAoa2V5IGluIG9iaikge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XHJcbiAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICB3cml0YWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIG9ialtrZXldID0gdmFsdWU7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gb2JqO1xyXG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/defineProperty.js\n");

/***/ }),

/***/ "./node_modules/@toruslabs/solana-embed/node_modules/is-stream/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@toruslabs/solana-embed/node_modules/is-stream/index.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isStream\": function() { return /* binding */ isStream; },\n/* harmony export */   \"isWritableStream\": function() { return /* binding */ isWritableStream; },\n/* harmony export */   \"isReadableStream\": function() { return /* binding */ isReadableStream; },\n/* harmony export */   \"isDuplexStream\": function() { return /* binding */ isDuplexStream; },\n/* harmony export */   \"isTransformStream\": function() { return /* binding */ isTransformStream; }\n/* harmony export */ });\nfunction isStream(stream) {\r\n\treturn stream !== null\r\n\t\t&& typeof stream === 'object'\r\n\t\t&& typeof stream.pipe === 'function';\r\n}\r\n\r\nfunction isWritableStream(stream) {\r\n\treturn isStream(stream)\r\n\t\t&& stream.writable !== false\r\n\t\t&& typeof stream._write === 'function'\r\n\t\t&& typeof stream._writableState === 'object';\r\n}\r\n\r\nfunction isReadableStream(stream) {\r\n\treturn isStream(stream)\r\n\t\t&& stream.readable !== false\r\n\t\t&& typeof stream._read === 'function'\r\n\t\t&& typeof stream._readableState === 'object';\r\n}\r\n\r\nfunction isDuplexStream(stream) {\r\n\treturn isWritableStream(stream)\r\n\t\t&& isReadableStream(stream);\r\n}\r\n\r\nfunction isTransformStream(stream) {\r\n\treturn isDuplexStream(stream)\r\n\t\t&& typeof stream._transform === 'function';\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9zb2xhbmEtZW1iZWQvbm9kZV9tb2R1bGVzL2lzLXN0cmVhbS9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvc29sYW5hLWVtYmVkL25vZGVfbW9kdWxlcy9pcy1zdHJlYW0vaW5kZXguanM/ZmUwYyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gaXNTdHJlYW0oc3RyZWFtKSB7XHJcblx0cmV0dXJuIHN0cmVhbSAhPT0gbnVsbFxyXG5cdFx0JiYgdHlwZW9mIHN0cmVhbSA9PT0gJ29iamVjdCdcclxuXHRcdCYmIHR5cGVvZiBzdHJlYW0ucGlwZSA9PT0gJ2Z1bmN0aW9uJztcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzV3JpdGFibGVTdHJlYW0oc3RyZWFtKSB7XHJcblx0cmV0dXJuIGlzU3RyZWFtKHN0cmVhbSlcclxuXHRcdCYmIHN0cmVhbS53cml0YWJsZSAhPT0gZmFsc2VcclxuXHRcdCYmIHR5cGVvZiBzdHJlYW0uX3dyaXRlID09PSAnZnVuY3Rpb24nXHJcblx0XHQmJiB0eXBlb2Ygc3RyZWFtLl93cml0YWJsZVN0YXRlID09PSAnb2JqZWN0JztcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVhZGFibGVTdHJlYW0oc3RyZWFtKSB7XHJcblx0cmV0dXJuIGlzU3RyZWFtKHN0cmVhbSlcclxuXHRcdCYmIHN0cmVhbS5yZWFkYWJsZSAhPT0gZmFsc2VcclxuXHRcdCYmIHR5cGVvZiBzdHJlYW0uX3JlYWQgPT09ICdmdW5jdGlvbidcclxuXHRcdCYmIHR5cGVvZiBzdHJlYW0uX3JlYWRhYmxlU3RhdGUgPT09ICdvYmplY3QnO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNEdXBsZXhTdHJlYW0oc3RyZWFtKSB7XHJcblx0cmV0dXJuIGlzV3JpdGFibGVTdHJlYW0oc3RyZWFtKVxyXG5cdFx0JiYgaXNSZWFkYWJsZVN0cmVhbShzdHJlYW0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNUcmFuc2Zvcm1TdHJlYW0oc3RyZWFtKSB7XHJcblx0cmV0dXJuIGlzRHVwbGV4U3RyZWFtKHN0cmVhbSlcclxuXHRcdCYmIHR5cGVvZiBzdHJlYW0uX3RyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJztcclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@toruslabs/solana-embed/node_modules/is-stream/index.js\n");

/***/ })

}]);